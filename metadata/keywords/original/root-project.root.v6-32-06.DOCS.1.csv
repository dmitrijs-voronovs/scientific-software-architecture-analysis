id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:33397,Integrability,interface,interface,33397,"## What the user must supply ###. The user must supply to M. - a valid implementation of the FCNBase base class. - parameters with their starting values. - expected uncertainties on the parameters. The input parameters can be simply defined via an; std::vector$<$double$>$, which means that all parameters are variables.; If the user wants fix a parameter or put limits on it before; minimization, they have to instantiate a MnUserParameters object and then; add parameters one by one, giving them a name, value, uncertainty. Once; all parameters are added to MnUserParameters, they can fix a parameter or; put limits on another one before handing them over to Minuit for; minimization. ### What the user can supply ###. Optionally the user can supply their own gradient calculator by; implementing the FCNGradientBase interface or supply a full covariance; matrix for input if one is available. The covariance matrix can be; supplied in form of a std::vector$<$double$>$ in packed storage format; (upper triangular), or in a more user-friendly way by using the; interface provided by the MnUserCovariance. ## Running a M minimization ##. Two use cases are addressed for minimization:. - The user just wants the function to be minimized in one go. - The user wants to minimize the $\mbox{FCN}$ in several; minimization steps, re-using the result of the preceeding; minimization in the next step and change parameters in between; (fix/release/put limits on them, etc.). How M minimizations can be performed is shown in [example:main]. ### Direct usage of minimizers ###. Minimizers such as the VariableMetricMinimizer are designed as; state-less minimization engines, which means that they do not depend on; the current function and its parameters. Any $\mbox{FCN}$ function; can be minimized with the same minimizer. The interface is restricted to; minimization and no parameter interaction is possible. ### Using an application (MnMigrad) ###. MnMigrad uses the VariableMetricMinimizer for minimizati",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:34030,Integrability,depend,depend,34030,"to Minuit for; minimization. ### What the user can supply ###. Optionally the user can supply their own gradient calculator by; implementing the FCNGradientBase interface or supply a full covariance; matrix for input if one is available. The covariance matrix can be; supplied in form of a std::vector$<$double$>$ in packed storage format; (upper triangular), or in a more user-friendly way by using the; interface provided by the MnUserCovariance. ## Running a M minimization ##. Two use cases are addressed for minimization:. - The user just wants the function to be minimized in one go. - The user wants to minimize the $\mbox{FCN}$ in several; minimization steps, re-using the result of the preceeding; minimization in the next step and change parameters in between; (fix/release/put limits on them, etc.). How M minimizations can be performed is shown in [example:main]. ### Direct usage of minimizers ###. Minimizers such as the VariableMetricMinimizer are designed as; state-less minimization engines, which means that they do not depend on; the current function and its parameters. Any $\mbox{FCN}$ function; can be minimized with the same minimizer. The interface is restricted to; minimization and no parameter interaction is possible. ### Using an application (MnMigrad) ###. MnMigrad uses the VariableMetricMinimizer for minimization but allows as; well for parameter interaction by the user. An instance of MnMigrad is; specific to the current $\mbox{FCN}$ and user parameters. Any; parameter interaction of the user between two minimization steps will; make use of the result of the preceeding minimization in an optimal way.; The interface for parameters (see [api:parameters], [api:covariance] and; [api:state]) is forwardedin MnMigrad. ### Subsequent minimizations ###. M takes care that all information is treated in an optimal and correct; way if the user interacts with the parameters between two minimizations.; MnMigrad retains the result of the last minimization and uses this ",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:34155,Integrability,interface,interface,34155,"atrix for input if one is available. The covariance matrix can be; supplied in form of a std::vector$<$double$>$ in packed storage format; (upper triangular), or in a more user-friendly way by using the; interface provided by the MnUserCovariance. ## Running a M minimization ##. Two use cases are addressed for minimization:. - The user just wants the function to be minimized in one go. - The user wants to minimize the $\mbox{FCN}$ in several; minimization steps, re-using the result of the preceeding; minimization in the next step and change parameters in between; (fix/release/put limits on them, etc.). How M minimizations can be performed is shown in [example:main]. ### Direct usage of minimizers ###. Minimizers such as the VariableMetricMinimizer are designed as; state-less minimization engines, which means that they do not depend on; the current function and its parameters. Any $\mbox{FCN}$ function; can be minimized with the same minimizer. The interface is restricted to; minimization and no parameter interaction is possible. ### Using an application (MnMigrad) ###. MnMigrad uses the VariableMetricMinimizer for minimization but allows as; well for parameter interaction by the user. An instance of MnMigrad is; specific to the current $\mbox{FCN}$ and user parameters. Any; parameter interaction of the user between two minimization steps will; make use of the result of the preceeding minimization in an optimal way.; The interface for parameters (see [api:parameters], [api:covariance] and; [api:state]) is forwardedin MnMigrad. ### Subsequent minimizations ###. M takes care that all information is treated in an optimal and correct; way if the user interacts with the parameters between two minimizations.; MnMigrad retains the result of the last minimization and uses this as; input for the next step. Between two minimization requests to MnMigrad; the user can fix or release parameters, put limits on them or remove; limits from them. Each instance of a MnMigrad object mai",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:34637,Integrability,interface,interface,34637,"preceeding; minimization in the next step and change parameters in between; (fix/release/put limits on them, etc.). How M minimizations can be performed is shown in [example:main]. ### Direct usage of minimizers ###. Minimizers such as the VariableMetricMinimizer are designed as; state-less minimization engines, which means that they do not depend on; the current function and its parameters. Any $\mbox{FCN}$ function; can be minimized with the same minimizer. The interface is restricted to; minimization and no parameter interaction is possible. ### Using an application (MnMigrad) ###. MnMigrad uses the VariableMetricMinimizer for minimization but allows as; well for parameter interaction by the user. An instance of MnMigrad is; specific to the current $\mbox{FCN}$ and user parameters. Any; parameter interaction of the user between two minimization steps will; make use of the result of the preceeding minimization in an optimal way.; The interface for parameters (see [api:parameters], [api:covariance] and; [api:state]) is forwardedin MnMigrad. ### Subsequent minimizations ###. M takes care that all information is treated in an optimal and correct; way if the user interacts with the parameters between two minimizations.; MnMigrad retains the result of the last minimization and uses this as; input for the next step. Between two minimization requests to MnMigrad; the user can fix or release parameters, put limits on them or remove; limits from them. Each instance of a MnMigrad object maintains its own; state and one can have multiple instances of MnMigrad objects. ### M fails to find a minimum ###. If M fails to find a minimum, the user is notified by a warning message; issued by M when running into troubles. Problems can be:. - a bug in M. - an error in the $\mbox{FCN}$. - a highly difficult problem (usually strong correlations among; parameters). - floating–point precision. ## The output from minimization ##. ### The FunctionMinimum ###. The output of the minimizers is ",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:35372,Integrability,message,message,35372,"arameter interaction by the user. An instance of MnMigrad is; specific to the current $\mbox{FCN}$ and user parameters. Any; parameter interaction of the user between two minimization steps will; make use of the result of the preceeding minimization in an optimal way.; The interface for parameters (see [api:parameters], [api:covariance] and; [api:state]) is forwardedin MnMigrad. ### Subsequent minimizations ###. M takes care that all information is treated in an optimal and correct; way if the user interacts with the parameters between two minimizations.; MnMigrad retains the result of the last minimization and uses this as; input for the next step. Between two minimization requests to MnMigrad; the user can fix or release parameters, put limits on them or remove; limits from them. Each instance of a MnMigrad object maintains its own; state and one can have multiple instances of MnMigrad objects. ### M fails to find a minimum ###. If M fails to find a minimum, the user is notified by a warning message; issued by M when running into troubles. Problems can be:. - a bug in M. - an error in the $\mbox{FCN}$. - a highly difficult problem (usually strong correlations among; parameters). - floating–point precision. ## The output from minimization ##. ### The FunctionMinimum ###. The output of the minimizers is the FunctionMinimum. The FunctionMinimum; contains the result of the minimization in both internal parameter; representation and external parameter representation. ### User representable format: MnUserParameterState ###. On request, the result of the minimization is transformed into a user; representable format for parameters and errors, the; MnUserParameterState. ### Access values, errors, covariance ###. The result can be accessed via methods like; MnUserParameterState::value(unsigned int n) and; MnUserParameterState::error(unsigned int n), where $n$ is the index of; the parameter in the list of parameters defined by the user. ### Printout of the result ###. The Fun",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:36626,Integrability,message,message,36626,"# The output from minimization ##. ### The FunctionMinimum ###. The output of the minimizers is the FunctionMinimum. The FunctionMinimum; contains the result of the minimization in both internal parameter; representation and external parameter representation. ### User representable format: MnUserParameterState ###. On request, the result of the minimization is transformed into a user; representable format for parameters and errors, the; MnUserParameterState. ### Access values, errors, covariance ###. The result can be accessed via methods like; MnUserParameterState::value(unsigned int n) and; MnUserParameterState::error(unsigned int n), where $n$ is the index of; the parameter in the list of parameters defined by the user. ### Printout of the result ###. The FunctionMinimum can be printed on the output simply via std::cout.; It will print both the internal and external state, that is parameters,; errors and the covariance matrix (if available). It also tells the user; if M did converge or not by issuing an appropriate message. If a; covariance matrix is available, the global correlation coefficients are; printed as well. ### Global correlation coefficients ###. The global correlation coefficient for parameter $n$ is a number between; zero and one which gives the correlation between parameter $n$ and that; linear combination of all other parameters which is most strongly; correlated with $n$. # M application programming interface (API) #. [api:api]. ## FunctionMinimum ##. [api:fm] The FunctionMinimum is the output of the minimizers and; contains the minimization result. The state at the minimum is available; both in internal and external representations. For the external; representations the return methods. - FunctionMinimum::userState(),. - FunctionMinimum::userParameters() and. - FunctionMinimum::userCovariance(). are provided. These can be used as new input to a new minimization after; some manipulation. The parameters and/or the FunctionMinimum can be; printed us",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:37035,Integrability,interface,interface,37035,"he; MnUserParameterState. ### Access values, errors, covariance ###. The result can be accessed via methods like; MnUserParameterState::value(unsigned int n) and; MnUserParameterState::error(unsigned int n), where $n$ is the index of; the parameter in the list of parameters defined by the user. ### Printout of the result ###. The FunctionMinimum can be printed on the output simply via std::cout.; It will print both the internal and external state, that is parameters,; errors and the covariance matrix (if available). It also tells the user; if M did converge or not by issuing an appropriate message. If a; covariance matrix is available, the global correlation coefficients are; printed as well. ### Global correlation coefficients ###. The global correlation coefficient for parameter $n$ is a number between; zero and one which gives the correlation between parameter $n$ and that; linear combination of all other parameters which is most strongly; correlated with $n$. # M application programming interface (API) #. [api:api]. ## FunctionMinimum ##. [api:fm] The FunctionMinimum is the output of the minimizers and; contains the minimization result. The state at the minimum is available; both in internal and external representations. For the external; representations the return methods. - FunctionMinimum::userState(),. - FunctionMinimum::userParameters() and. - FunctionMinimum::userCovariance(). are provided. These can be used as new input to a new minimization after; some manipulation. The parameters and/or the FunctionMinimum can be; printed using std::cout. ### isValid() ###. In general, if the method bool FunctionMinimum::isValid() returns; ""true"", the minimizer did find a minimum without running into troubles.; However, in some cases it may happen that a minimum cannot be found,; then the return value will be ""false"". Reasons for the minimization to; fail are. - the number of allowed function calls has been exhausted. - the minimizer could not improve the values of the p",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:42551,Integrability,message,messages,42551,"; $\mbox{eps}$. The method can be used to override M 's own; determination, when the user knows that the $\mbox{FCN}$ function; value is not calculated to the nominal machine accuracy. Typical values; of $\mbox{eps}$ are between $10^{-5}$ and $10^{-14}$. ## MnMigrad and VariableMetricMinimizer ##. [api:migrad]. MnMigrad provides minimization of the function by the method of; $\mbox{MIGRAD}$, the most efficient and complete single method,; recommended for general functions (see also [api:minimize]), and the; functionality for parameters interaction. It also retains the result; from the last minimization in case the user may want to do subsequent; minimization steps with parameter interactions in between the; minimization requests. The minimization is done by the; VariableMetricMinimizer. Minimization of the function can be done by; directly using the VariableMetricMinimizer if no parameters interaction; is required. The minimization produces as a by-product the error matrix; of the parameters, which is usually reliable unless warning messages are; produced. ### MnMigrad(const FCNBase&, const std::vector$<$double$>$&, const std::vector$<$double$>$&, unsigned int) ###. Constructor for the minimal required interface: $\mbox{FCN}$ and; starting values for parameters and uncertainties. Optional the strategy; level in MnStrategy can be specified. ### MnMigrad(const FCNBase&, const MnUserParameters&, unsigned int) ###. Constructor for high level parameters interface. Optional the strategy; level in MnStrategy can be specified. ### MnMigrad(const FCNBase&, const MnUserParameterState&, const MnStrategy&) ###. Constructor from a full state (parameters + covariance) as starting; input plus the desired strategy. ### operator() ###. [api:migradop] MnMigrad::operator()(unsigned int maxfcn, double; tolerance) causes minimization of the $\mbox{FCN}$ and returns the; result in form of a FunctionMinimum. The optional argument; $\mbox{maxfcn}$ specifies the (approximate) maximum number",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:42724,Integrability,interface,interface,42724," $10^{-14}$. ## MnMigrad and VariableMetricMinimizer ##. [api:migrad]. MnMigrad provides minimization of the function by the method of; $\mbox{MIGRAD}$, the most efficient and complete single method,; recommended for general functions (see also [api:minimize]), and the; functionality for parameters interaction. It also retains the result; from the last minimization in case the user may want to do subsequent; minimization steps with parameter interactions in between the; minimization requests. The minimization is done by the; VariableMetricMinimizer. Minimization of the function can be done by; directly using the VariableMetricMinimizer if no parameters interaction; is required. The minimization produces as a by-product the error matrix; of the parameters, which is usually reliable unless warning messages are; produced. ### MnMigrad(const FCNBase&, const std::vector$<$double$>$&, const std::vector$<$double$>$&, unsigned int) ###. Constructor for the minimal required interface: $\mbox{FCN}$ and; starting values for parameters and uncertainties. Optional the strategy; level in MnStrategy can be specified. ### MnMigrad(const FCNBase&, const MnUserParameters&, unsigned int) ###. Constructor for high level parameters interface. Optional the strategy; level in MnStrategy can be specified. ### MnMigrad(const FCNBase&, const MnUserParameterState&, const MnStrategy&) ###. Constructor from a full state (parameters + covariance) as starting; input plus the desired strategy. ### operator() ###. [api:migradop] MnMigrad::operator()(unsigned int maxfcn, double; tolerance) causes minimization of the $\mbox{FCN}$ and returns the; result in form of a FunctionMinimum. The optional argument; $\mbox{maxfcn}$ specifies the (approximate) maximum number of; function calls after which the calculation will be stopped even if it; has not yet converged. The optional argument $\mbox{tolerance}$; specifies the required tolerance on the function value at the minimum.; The default $\mbox{tolerance}",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:42975,Integrability,interface,interface,42975," general functions (see also [api:minimize]), and the; functionality for parameters interaction. It also retains the result; from the last minimization in case the user may want to do subsequent; minimization steps with parameter interactions in between the; minimization requests. The minimization is done by the; VariableMetricMinimizer. Minimization of the function can be done by; directly using the VariableMetricMinimizer if no parameters interaction; is required. The minimization produces as a by-product the error matrix; of the parameters, which is usually reliable unless warning messages are; produced. ### MnMigrad(const FCNBase&, const std::vector$<$double$>$&, const std::vector$<$double$>$&, unsigned int) ###. Constructor for the minimal required interface: $\mbox{FCN}$ and; starting values for parameters and uncertainties. Optional the strategy; level in MnStrategy can be specified. ### MnMigrad(const FCNBase&, const MnUserParameters&, unsigned int) ###. Constructor for high level parameters interface. Optional the strategy; level in MnStrategy can be specified. ### MnMigrad(const FCNBase&, const MnUserParameterState&, const MnStrategy&) ###. Constructor from a full state (parameters + covariance) as starting; input plus the desired strategy. ### operator() ###. [api:migradop] MnMigrad::operator()(unsigned int maxfcn, double; tolerance) causes minimization of the $\mbox{FCN}$ and returns the; result in form of a FunctionMinimum. The optional argument; $\mbox{maxfcn}$ specifies the (approximate) maximum number of; function calls after which the calculation will be stopped even if it; has not yet converged. The optional argument $\mbox{tolerance}$; specifies the required tolerance on the function value at the minimum.; The default $\mbox{tolerance}$ value is $0.1$, and the minimization; will stop when the estimated vertical distance to the minimum; ($\mbox{EDM}$) is less than; $0.001*$$\mbox{tolerance}$$*$$\mbox{up}$ (see [howto:errordef]). ### Parameter intera",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:44081,Integrability,interface,interface,44081,"n be specified. ### MnMigrad(const FCNBase&, const MnUserParameterState&, const MnStrategy&) ###. Constructor from a full state (parameters + covariance) as starting; input plus the desired strategy. ### operator() ###. [api:migradop] MnMigrad::operator()(unsigned int maxfcn, double; tolerance) causes minimization of the $\mbox{FCN}$ and returns the; result in form of a FunctionMinimum. The optional argument; $\mbox{maxfcn}$ specifies the (approximate) maximum number of; function calls after which the calculation will be stopped even if it; has not yet converged. The optional argument $\mbox{tolerance}$; specifies the required tolerance on the function value at the minimum.; The default $\mbox{tolerance}$ value is $0.1$, and the minimization; will stop when the estimated vertical distance to the minimum; ($\mbox{EDM}$) is less than; $0.001*$$\mbox{tolerance}$$*$$\mbox{up}$ (see [howto:errordef]). ### Parameter interaction ###. MnMigrad retains the result after each minimization; (MnUserParameterStae, see [api:state]) and forwards the interface. ### VariableMetricMinimizer() ###. The VariableMetricMinimizer is instantiated using default constructor. ### minimize(const FCNBase&, ...) ###. The VariableMetricMinimizer provides several overloaded methods minimize; with return value FunctionMinimum. Together with the user; $\mbox{FCN}$ (either an implementation of FCNBase or; FCNGradientBase) the user has to give as input the parameters with; starting values in one of the defined formats (std::vector$<$double$>$,; MnUserParameters or MnUserParameterState). ## MnMinimize and CombinedMinimizer ##. [api:minimize]. Causes minimization of the function by the method of; $\mbox{MIGRAD}$, as does the MnMigrad class, but switches to the; $\mbox{SIMPLEX}$ method if $\mbox{MIGRAD}$ fails to converge.; Constructor arguments, methods arguments and names of methods are the; same as for MnMigrad or MnSimplex and VariableMetricMinimizer or; SimplexMinimizer. ## MnMinos ##. [api:minos] Ca",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:49241,Integrability,interface,interface,49241,"}$ method is not intended for minimization; it can be used as a minimizer in its most primitive form. ## MnSimplex and SimplexMinimizer ##. [api:simplex]. $\mbox{SIMPLEX}$ is a function minimization method using the simplex; method of Nelder and Mead. MnSimplex provides minimization of the; function by the method of $\mbox{SIMPLEX}$ and the functionality for; parameters interaction. It also retains the result from the last; minimization in case the user may want to do subsequent minimization; steps with parameter interactions in between the minimization requests.; The minimization is done by the SimplexMinimizer. Minimization of the; function can be done by directly using the SimplexMinimizer if no; parameters interaction is required. As $\mbox{SIMPLEX}$ is a; stepping method it does not produce a covariance matrix. ### MnSimplex(const FCNBase&, const std::vector$<$double$>$&,\; const std::vector$<$double$>$&, unsigned int) ###. Constructor for the minimal required interface: $\mbox{FCN}$ and; starting values for parameters and uncertainties. Optional the strategy; level in MnStrategy can be specified. ### MnSimplex(const FCNBase&, const MnUserParameters&,\; unsigned int) ###. Constructor for high level parameters interface. Optional the strategy; level in MnStrategy can be specified. ### MnSimplex(const FCNBase&, const MnUserParameterState&,\; const MnStrategy&) ###. Constructor from a full state (parameters + covariance) as starting; input plus the desired strategy. ### operator() ###. MnSimplex::operator()(unsigned int maxfcn, double tolerance) causes; minimization of the $\mbox{FCN}$ and returns the result in form of a; FunctionMinimum. Minimization terminates either when the function has; been called (approximately) $\mbox{maxfcn}$ times, or when the; estimated vertical distance to minimum ($\mbox{EDM}$) is less than; $\mbox{tolerance*up}$. The default value of $\mbox{tolerance}$; is $\mbox{0.1}$. (see [howto:errordef]). ### Parameter interaction ###. MnSimplex",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:49495,Integrability,interface,interface,49495,"plex; method of Nelder and Mead. MnSimplex provides minimization of the; function by the method of $\mbox{SIMPLEX}$ and the functionality for; parameters interaction. It also retains the result from the last; minimization in case the user may want to do subsequent minimization; steps with parameter interactions in between the minimization requests.; The minimization is done by the SimplexMinimizer. Minimization of the; function can be done by directly using the SimplexMinimizer if no; parameters interaction is required. As $\mbox{SIMPLEX}$ is a; stepping method it does not produce a covariance matrix. ### MnSimplex(const FCNBase&, const std::vector$<$double$>$&,\; const std::vector$<$double$>$&, unsigned int) ###. Constructor for the minimal required interface: $\mbox{FCN}$ and; starting values for parameters and uncertainties. Optional the strategy; level in MnStrategy can be specified. ### MnSimplex(const FCNBase&, const MnUserParameters&,\; unsigned int) ###. Constructor for high level parameters interface. Optional the strategy; level in MnStrategy can be specified. ### MnSimplex(const FCNBase&, const MnUserParameterState&,\; const MnStrategy&) ###. Constructor from a full state (parameters + covariance) as starting; input plus the desired strategy. ### operator() ###. MnSimplex::operator()(unsigned int maxfcn, double tolerance) causes; minimization of the $\mbox{FCN}$ and returns the result in form of a; FunctionMinimum. Minimization terminates either when the function has; been called (approximately) $\mbox{maxfcn}$ times, or when the; estimated vertical distance to minimum ($\mbox{EDM}$) is less than; $\mbox{tolerance*up}$. The default value of $\mbox{tolerance}$; is $\mbox{0.1}$. (see [howto:errordef]). ### Parameter interaction ###. MnSimplex retains the result after each minimization; (MnUserParameterStae, see [api:state]) and forwards the interface for; parameter interaction. ### SimplexMinimizer() ###. The SimplexMinimizer() is instantiated using default ",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:50362,Integrability,interface,interface,50362,"nal the strategy; level in MnStrategy can be specified. ### MnSimplex(const FCNBase&, const MnUserParameters&,\; unsigned int) ###. Constructor for high level parameters interface. Optional the strategy; level in MnStrategy can be specified. ### MnSimplex(const FCNBase&, const MnUserParameterState&,\; const MnStrategy&) ###. Constructor from a full state (parameters + covariance) as starting; input plus the desired strategy. ### operator() ###. MnSimplex::operator()(unsigned int maxfcn, double tolerance) causes; minimization of the $\mbox{FCN}$ and returns the result in form of a; FunctionMinimum. Minimization terminates either when the function has; been called (approximately) $\mbox{maxfcn}$ times, or when the; estimated vertical distance to minimum ($\mbox{EDM}$) is less than; $\mbox{tolerance*up}$. The default value of $\mbox{tolerance}$; is $\mbox{0.1}$. (see [howto:errordef]). ### Parameter interaction ###. MnSimplex retains the result after each minimization; (MnUserParameterStae, see [api:state]) and forwards the interface for; parameter interaction. ### SimplexMinimizer() ###. The SimplexMinimizer() is instantiated using default constructor. ### minimize(const FCNBase&, ...) ###. The SimplexMinimizer provides several overloaded methods minimize with; return value FunctionMinimum. Together with the user $\mbox{FCN}$; (either an implementation of FCNBase or FCNGradientBase) the user has to; give as input the parameters with starting values in one of the defined; formats (std::vector$<$double$>$, MnUserParameters or; MnUserParameterState). ## MnStrategy ##. [api:strategy] Sets the strategy to be used in calculating first and; second derivatives and in certain minimization methods. In general, low; values of $\mbox{level}$ mean fewer function calls and high values; mean more reliable minimization. Currently allowed values are 0 (low), 1; (default), and 2 (high). ### MnStrategy() ###. Default constructor, sets all settings according to; $\mbox{level}$$ = 1.$. ##",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:61354,Integrability,depend,depends,61354,"sers were encouraged to find the one that worked; best for them. Since then, algorithms have improved considerably, but M; still offers several, mostly so that old users will not feel cheated,; but also to help the occasional user who does manage to defeat the best; algorithms. M currently offers four applications which can be used to; find a smaller function value, in addition to $\mbox{MINOS}$, which; will retain a smaller function value if it stumbles on one unexpectedly.; The objects which can be used to minimize are:. ### $\mbox{MIGRAD}$ ###. This is the best minimizer for nearly all functions. It is a; variable-metric method with inexact line search, a stable metric; updating scheme, and checks for positive-definiteness. It will run; faster if you instantiate it with a low–level MnStrategy and will be; more reliable if you instantiate it with a high–level MnStrategy; (although the latter option may not help much). Its main weakness is; that it depends heavily on knowledge of the first derivatives, and fails; miserably if they are very inaccurate. If first derivatives are a; problem, they can be calculated analytically inside $\mbox{FCN}$; (see [howto:fcn]) or if this is not feasible, the user can try to; improve the accuracy of M 's numerical approximation by adjusting values; of MnMachinePrecision and/or MnStrategy (see [api:epsmac] and; [api:strategy]). ### $\mbox{MINIMIZE}$ ###. This is equivalent to $\mbox{MIGRAD}$, except that if; $\mbox{MIGRAD}$ fails, it reverts to $\mbox{SIMPLEX}$ and then; calls $\mbox{MIGRAD}$ again. ### $\mbox{SCAN}$ ###. This is not intended to minimize, and just scans the function, one; parameter at a time. It does however retain the best value after each; scan, so it does some sort of highly primitive minimization. ### $\mbox{SIMPLEX}$ ###. This genuine multidimensional minimization routine is usually much; slower than $\mbox{MIGRAD}$, but it does not use first derivatives,; so it should not be so sensitive to the precision of the",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:62241,Integrability,rout,routine,62241," it depends heavily on knowledge of the first derivatives, and fails; miserably if they are very inaccurate. If first derivatives are a; problem, they can be calculated analytically inside $\mbox{FCN}$; (see [howto:fcn]) or if this is not feasible, the user can try to; improve the accuracy of M 's numerical approximation by adjusting values; of MnMachinePrecision and/or MnStrategy (see [api:epsmac] and; [api:strategy]). ### $\mbox{MINIMIZE}$ ###. This is equivalent to $\mbox{MIGRAD}$, except that if; $\mbox{MIGRAD}$ fails, it reverts to $\mbox{SIMPLEX}$ and then; calls $\mbox{MIGRAD}$ again. ### $\mbox{SCAN}$ ###. This is not intended to minimize, and just scans the function, one; parameter at a time. It does however retain the best value after each; scan, so it does some sort of highly primitive minimization. ### $\mbox{SIMPLEX}$ ###. This genuine multidimensional minimization routine is usually much; slower than $\mbox{MIGRAD}$, but it does not use first derivatives,; so it should not be so sensitive to the precision of the; $\mbox{FCN}$ calculations, and is even rather robust with respect to; gross fluctuations in the function value. However, it gives no reliable; information about parameter errors, no information whatsoever about; parameter correlations, and worst of all cannot be expected to converge; accurately to the minimum in a finite time. Its estimate of the; *expected distance to the minimum* $\mbox{EDM}$ is largely fantasy,; so it would not even know if it did converge. ## Floating point precision ##. M figures out at execution time the machine precision [api:epsmac], and; assumes that $\mbox{FCN}$ provides about the same precision. That; means not just the length of the numbers used and returned by; $\mbox{FCN}$, but the actual mathematical accuracy of the; calculations. Section [install:epsmac] describes what to do if this is; not the case. ## Parameter limits ##. Putting limits (absolute bounds) on the allowed values for a given; parameter, causes M t",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:69362,Integrability,message,messages,69362,"of increasing; complexity and completeness):. - *""Interpretation of the Errors on Parameters"",* see Part 3 of this; write-up. - *""Determining the Statistical Significance of Experimental; Results""*@bib-MIN81. - *""Statistical Methods in Experimental Physics""*@bib-EADIE. ### The reliability of M error estimates ###. M always carries around its own current estimates of the parameter; errors, which it will print out on request, no matter how accurate they; are at any given point in the execution. For example, at initialization,; these estimates are just the starting step sizes as specified by the; user. After a $\mbox{MIGRAD}$ or $\mbox{HESSE}$ step, the errors; are usually quite accurate, unless there has been a problem. If no; mitigating adjective is given in the printout of the errors, then at; least M believes the errors are accurate, although there is always a; small chance that M has been fooled. Some visible signs that M may have; been fooled are:. - Warning messages produced during the minimization or error analysis. - Failure to find new minimum. - Value of $\mbox{EDM}$ too big. For a ""normal"" minimization,; after $\mbox{MIGRAD}$, the value of $\mbox{EDM}$ is usually; more than three orders of magnitude smaller than $\mbox{up}$,; unless a looser tolerance has been specified. - Correlation coefficients exactly equal to zero, unless some; parameters are known to be uncorrelated with the others. - Correlation coefficients very close to one (greater than 0.99).\; This indicates both an exceptionally difficult problem, and one; which has been badly parametrized so that individual errors are not; very meaningful because they are so highly correlated. - Parameter at limit. This condition, signalled by a M warning; message, may make both the function minimum and parameter errors; unreliable. See section [answer:right-errors], *Getting the right; parameter errors with limits*. The best way to be absolutely sure of the errors, is to use; ""independent"" calculations and com",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:70128,Integrability,message,message,70128,"given in the printout of the errors, then at; least M believes the errors are accurate, although there is always a; small chance that M has been fooled. Some visible signs that M may have; been fooled are:. - Warning messages produced during the minimization or error analysis. - Failure to find new minimum. - Value of $\mbox{EDM}$ too big. For a ""normal"" minimization,; after $\mbox{MIGRAD}$, the value of $\mbox{EDM}$ is usually; more than three orders of magnitude smaller than $\mbox{up}$,; unless a looser tolerance has been specified. - Correlation coefficients exactly equal to zero, unless some; parameters are known to be uncorrelated with the others. - Correlation coefficients very close to one (greater than 0.99).\; This indicates both an exceptionally difficult problem, and one; which has been badly parametrized so that individual errors are not; very meaningful because they are so highly correlated. - Parameter at limit. This condition, signalled by a M warning; message, may make both the function minimum and parameter errors; unreliable. See section [answer:right-errors], *Getting the right; parameter errors with limits*. The best way to be absolutely sure of the errors, is to use; ""independent"" calculations and compare them, or compare the calculated; errors with a picture of the function if possible. For example, if there; is only one free parameter, $\mbox{SCAN}$ allows the user to verify; approximately the function curvature. Similarly, if there are only two; free parameters, use $\mbox{CONTOURS}$. To verify a full error; matrix, compare the results of $\mbox{MIGRAD}$ with those; (calculated afterward) by $\mbox{HESSE}$, which uses a different; method. And of course the most reliable and most expensive technique,; which must be used if asymmetric errors are required, is; $\mbox{MINOS}$. ## Convergence in $\mbox{MIGRAD}$, and positive–definiteness ##. $\mbox{MIGRAD}$ uses its current estimate of the covariance matrix; of the function to determine the curre",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:72507,Integrability,depend,dependence,72507,"be; downhill only if the covariance matrix is positive–definite, so in case; this is not true, it makes a positive–definite approximation by adding; an appropriate constant along the diagonal as determined by the; eigenvalues of the matrix. Theoretically, the covariance matrix for a; ""physical"" function must be positive–definite at the minimum, although; it may not be so for all points far away from the minimum, even for a; well–determined physical problem. Therefore, if $\mbox{MIGRAD}$; reports that it has found a non-positive–definite covariance matrix,; this may be a sign of one or more of the following:. - **A non–physical region.** On its way to the minimum,; $\mbox{MIGRAD}$ may have traversed a region which has unphysical; behaviour, which is of course not a serious problem as long as it; recovers and leaves such a region. - **An underdetermined problem.** If the matrix is not; positive–definite even at the minimum, this may mean that the; solution is not well–defined, for example that there are more; unknowns than there are data points, or that the parametrization of; the fit contains a linear dependence. If this is the case, then M; (or any other program) cannot solve your problem uniquely, and the; error matrix will necessarily be largely meaningless, so the user; must remove the under-determinedness by reformulating the; parametrization. M cannot do this itself, but it can provide some; hints (contours, global correlation coefficients, eigenvalues) which; can help the clever user to find out what is wrong. - **Numerical inaccuracies.** It is possible that the apparent lack of; positive–definiteness is in fact only due to excessive roundoff; errors in numerical calculations, either in $\mbox{FCN}$ or in M; . This is unlikely in general, but becomes more likely if the number; of free parameters is very large, or if the parameters are badly; scaled (not all of the same order of magnitude), and correlations; are also large. In any case, whether the non–positive",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:74426,Integrability,depend,dependence,74426,"irrelevant, since in both cases; the error matrix will be unreliable and the minimum suspicious. ## Additional trouble–shooting ##. When M just doesn't work, some of the more common causes are:. - **Precision mismatch.** Make sure your $\mbox{FCN}$ uses; internally the same precision as M . If the problem is only one of precision, and not of word length; mismatch, an appropriate MnMachinePrecision::setPrecision() may fix; it. - **Trivial bugs in $\mbox{FCN}$.** The possibilities for bugs are; numerous. Probably the most common among physicists inexperienced in; is the confusion between double and int types, which you can; sometimes get away with, but not always. [^3] M can spot some; trivial bugs itself, and issues a warning when it detects an unusual; $\mbox{FCN}$ behaviour. Such a warning should be taken; seriously. M also offers some tools (especially $\mbox{SCAN}$) which can; help the user to find trivial bugs. - **An ill–posed problem.** For questions of parameter dependence, see; the discussion above on postive–definiteness. Other mathematical; problems which can arise are: **excessive numerical roundoff** — be; especially careful of exponential and factorial functions which get; big very quickly and lose accuracy; **starting too far from the; solution** — the function may have unphysical local minima,; especially at infinity in some variables; **incorrect; normalization** — in likelihood functions, the probability; distributions must be normalized or at least have an integral which; is independent of the values of the variable parameters. - **A bug in M .** This is unlikely, but it happens. If a bug is; suspected, and all other possible causes can be eliminated, please; try to save a copy of the input and output files, listing of; $\mbox{FCN}$, and other information that may be relevant, and; send them to $\mbox{fred.james@cern.ch}$. # A complete example #. [example:example]. Here a full example of a fit is presented, following the example; DemoGaussSim.cpp. ",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:78830,Integrability,interface,interface,78830,"nclude ""GaussDataGen.h""; #include ""Minuit/FunctionMinimum.h""; #include ""Minuit/MnUserParameterState.h""; #include ""Minuit/MinimumPrint.h""; #include ""Minuit/MnMigrad.h""; #include ""Minuit/MnMinos.h""; #include ""Minuit/MnContours.h""; #include ""Minuit/MnPlot.h"". #include <iostream>. int main() {. // generate the data (100 data points); GaussDataGen gdg(100);. std::vector<double> pos = gdg.positions();; std::vector<double> meas = gdg.measurements();; std::vector<double> var = gdg.variances();. // create FCN function; GaussFcn theFCN(meas, pos, var);. // create initial starting values for parameters; double x = 0.;; double x2 = 0.;; double norm = 0.;; double dx = pos[1]-pos[0];; double area = 0.;; for(unsigned int i = 0; i < meas.size(); i++) {; norm += meas[i];; x += (meas[i]*pos[i]);; x2 += (meas[i]*pos[i]*pos[i]);; area += dx*meas[i];; }; double mean = x/norm;; double rms2 = x2/norm - mean*mean;; double rms = rms2 > 0. ? sqrt(rms2) : 1.;. {; // demonstrate minimal required interface for minimization; // create Minuit parameters without names. // starting values for parameters; std::vector<double> init_par;; init_par.push_back(mean);; init_par.push_back(rms);; init_par.push_back(area);. // starting values for initial uncertainties; std::vector<double> init_err;; init_err.push_back(0.1);; init_err.push_back(0.1);; init_err.push_back(0.1);. // create minimizer (default constructor); VariableMetricMinimizer theMinimizer;. // minimize; FunctionMinimum min =; theMinimizer.minimize(theFCN, init_par, init_err);. // output; std::cout<<""minimum: ""<<min<<std::endl;; }. {; // demonstrate standard minimization using MIGRAD; // create Minuit parameters with names; MnUserParameters upar;; upar.add(""mean"", mean, 0.1);; upar.add(""sigma"", rms, 0.1);; upar.add(""area"", area, 0.1);. // create MIGRAD minimizer; MnMigrad migrad(theFCN, upar);. // minimize; FunctionMinimum min = migrad();. // output; std::cout<<""minimum: ""<<min<<std::endl;; }. {; // demonstrate full interaction with parameters ",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:83494,Integrability,interface,interface,83494,": ""; <<min.userState().value(1); <<"" ""<<e1.first<<"" ""<<e1.second<<std::endl;; std::cout<<""par2: ""; <<min.userState().value(""area""); <<"" ""<<e2.first<<"" ""<<e2.second<<std::endl;; }; }. {; // demonstrate how to use the CONTOURs. // create Minuit parameters with names; MnUserParameters upar;; upar.add(""mean"", mean, 0.1);; upar.add(""sigma"", rms, 0.1);; upar.add(""area"", area, 0.1);. // create Migrad minimizer; MnMigrad migrad(theFCN, upar);. // minimize; FunctionMinimum min = migrad();. // create contours factory with FCN and minimum; MnContours contours(theFCN, min);. // 70% confidence level for 2 parameters contour; // around the minimum; theFCN.setErrorDef(2.41);; std::vector<std::pair<double,double> > cont =; contours(0, 1, 20);. // 95% confidence level for 2 parameters contour; theFCN.setErrorDef(5.99);; std::vector<std::pair<double,double> > cont4 =; contours(0, 1, 20);. // plot the contours; MnPlot plot;; cont4.insert(cont4.end(), cont.begin(), cont.end());; plot(min.userState().value(""mean""),; min.userState().value(""sigma""),; cont4);; }. return 0;; };; ```. [^1]: ROOT @bib-ROOT uses its own version of the Fortran M when this; manual was written. However an interface for this version exists and; the library can be loaded dynamically on demand. [^2]: The *internal error matrix* maintained by M is transformed for the; user into *external coordinates*, but the numbering of rows and; columns is of course still according to internal parameter; numbering, since one does not want rows and columns corresponding to; parameters which are not variable. The transformation therefore; affects only parameters with limits; if there are no limits,; internal and external error matrices are the same. [^3]: For example, if $\mbox{a}$ and $\mbox{b}$ are double; precision variables, the statement $\mbox{a = 2*b}$ is not good; programming, but happens to do what the user probably intended,; whereas the statement $\mbox{a = b + 2/3}$ almost certainly will; not do what the user intended.; ",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:2434,Modifiability,variab,variable,2434,".g.; $\mbox{MIGRAD}$, $\mbox{MINOS}$, $\mbox{CONTOURS}$), the; corresponding names of the classes are written using sans-serif font; type (MnMigrad, MnMinos, MnContours). # Introduction: M basic concepts #. [sec:intro]. ## The organization of M ##. The M package acts on a multiparameter *objective function* which is; called — for historical reasons — the $\mbox{FCN}$ function (see; [howto:fcn]). This function is usually a chisquared or a log–likelihood,; but it could also be a mathematical function. The $\mbox{FCN}$; function needs to be written in for which M defines the pure abstract; base class FCNBase as interface. The user must define and implement the; $\mbox{FCN}$ function in a derived class from FCNBase. Sometimes; this is done by an intermediate program such as HippoDraw@bib-HippoDraw,; in which case M is being used under the control of such an intermediate; program[^1]. The value of the $\mbox{FCN}$ function will in general; depend on one or more variable parameters whose meaning is defined by; the user (or by the intermediate program), but whose trial values are; determined by M . To take a simple example, suppose the problem is to fit a polynomial; through a set of data points. Then the user would write a; $\mbox{FCN}$ which calculates the $\chi^2$ between a polynomial and; the data; the variable parameters of $\mbox{FCN}$ would be the; coefficients of the polynomials. Using objects for minimization from M ,; the user would request M to minimize the $\mbox{FCN}$ with respect; to the parameters, that is, find those values of the coefficients which; give the lowest value of chisquare. The user must therefore supply, in addition to the function to be; analyzed, via a set or sequence of M applications the instructions which; analysis is wanted. The instructions are coded in in the calling program; (main.cpp), which allows looping, conditional execution, and all the; other possibilities of , but not interactivity, since it must be; compiled before execution. ",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:2784,Modifiability,variab,variable,2784,"on* which is; called — for historical reasons — the $\mbox{FCN}$ function (see; [howto:fcn]). This function is usually a chisquared or a log–likelihood,; but it could also be a mathematical function. The $\mbox{FCN}$; function needs to be written in for which M defines the pure abstract; base class FCNBase as interface. The user must define and implement the; $\mbox{FCN}$ function in a derived class from FCNBase. Sometimes; this is done by an intermediate program such as HippoDraw@bib-HippoDraw,; in which case M is being used under the control of such an intermediate; program[^1]. The value of the $\mbox{FCN}$ function will in general; depend on one or more variable parameters whose meaning is defined by; the user (or by the intermediate program), but whose trial values are; determined by M . To take a simple example, suppose the problem is to fit a polynomial; through a set of data points. Then the user would write a; $\mbox{FCN}$ which calculates the $\chi^2$ between a polynomial and; the data; the variable parameters of $\mbox{FCN}$ would be the; coefficients of the polynomials. Using objects for minimization from M ,; the user would request M to minimize the $\mbox{FCN}$ with respect; to the parameters, that is, find those values of the coefficients which; give the lowest value of chisquare. The user must therefore supply, in addition to the function to be; analyzed, via a set or sequence of M applications the instructions which; analysis is wanted. The instructions are coded in in the calling program; (main.cpp), which allows looping, conditional execution, and all the; other possibilities of , but not interactivity, since it must be; compiled before execution. ## Design aspects of M in ##. What M is:. - platform independent. - written in an object-oriented way using standard. - independent of any external package. The maintainability should be guaranteed with the choice of a modern; computer language. Choosing object-oriented technology M should profit; from an",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:3624,Modifiability,maintainab,maintainability,3624," points. Then the user would write a; $\mbox{FCN}$ which calculates the $\chi^2$ between a polynomial and; the data; the variable parameters of $\mbox{FCN}$ would be the; coefficients of the polynomials. Using objects for minimization from M ,; the user would request M to minimize the $\mbox{FCN}$ with respect; to the parameters, that is, find those values of the coefficients which; give the lowest value of chisquare. The user must therefore supply, in addition to the function to be; analyzed, via a set or sequence of M applications the instructions which; analysis is wanted. The instructions are coded in in the calling program; (main.cpp), which allows looping, conditional execution, and all the; other possibilities of , but not interactivity, since it must be; compiled before execution. ## Design aspects of M in ##. What M is:. - platform independent. - written in an object-oriented way using standard. - independent of any external package. The maintainability should be guaranteed with the choice of a modern; computer language. Choosing object-oriented technology M should profit; from an increased flexibility and functionality and make it also; extendable (recursiveness, new algorithms, new functionality). What M does not:. - histogramming. - data handling. - graphics. M is kept as a low-level package with optimal performance. The main usages of M are. - from a user's program (such as int main()...). - from a graphical data analysis tool such as HippoDraw@bib-HippoDraw. The most important goals of M in are. - its numerical accuracy (equivalent to its Fortran version). - its computational performance (equivalent to its Fortran version). For the design of the application programming interface (API) of M a; two-way strategy was imposed:. - a minimal required interface with minimum interaction with M objects; and with appropriate usage of the standard library (STL): the user's; implementation of the FCNBase class, initial parameter values and; uncertainties are provide",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:3828,Modifiability,extend,extendable,3828,"ters of $\mbox{FCN}$ would be the; coefficients of the polynomials. Using objects for minimization from M ,; the user would request M to minimize the $\mbox{FCN}$ with respect; to the parameters, that is, find those values of the coefficients which; give the lowest value of chisquare. The user must therefore supply, in addition to the function to be; analyzed, via a set or sequence of M applications the instructions which; analysis is wanted. The instructions are coded in in the calling program; (main.cpp), which allows looping, conditional execution, and all the; other possibilities of , but not interactivity, since it must be; compiled before execution. ## Design aspects of M in ##. What M is:. - platform independent. - written in an object-oriented way using standard. - independent of any external package. The maintainability should be guaranteed with the choice of a modern; computer language. Choosing object-oriented technology M should profit; from an increased flexibility and functionality and make it also; extendable (recursiveness, new algorithms, new functionality). What M does not:. - histogramming. - data handling. - graphics. M is kept as a low-level package with optimal performance. The main usages of M are. - from a user's program (such as int main()...). - from a graphical data analysis tool such as HippoDraw@bib-HippoDraw. The most important goals of M in are. - its numerical accuracy (equivalent to its Fortran version). - its computational performance (equivalent to its Fortran version). For the design of the application programming interface (API) of M a; two-way strategy was imposed:. - a minimal required interface with minimum interaction with M objects; and with appropriate usage of the standard library (STL): the user's; implementation of the FCNBase class, initial parameter values and; uncertainties are provided by the to M user via std::vectors. - a rich interface which provides the user with more functionality; such as interaction with param",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:5150,Modifiability,variab,variable,5150,"most important goals of M in are. - its numerical accuracy (equivalent to its Fortran version). - its computational performance (equivalent to its Fortran version). For the design of the application programming interface (API) of M a; two-way strategy was imposed:. - a minimal required interface with minimum interaction with M objects; and with appropriate usage of the standard library (STL): the user's; implementation of the FCNBase class, initial parameter values and; uncertainties are provided by the to M user via std::vectors. - a rich interface which provides the user with more functionality; such as interaction with parameters. The core of the minimization functionality and related tools (the kernel; of M ) should be clearly separated from the user, who is interfacing via; defined user interfaces (the API). ## Internal and external parameters ##. Each of the parameters to the $\mbox{FCN}$ is defined by the user as; belonging to one of the following types:. - Freely variable: allowed to take on any value. - Variable with double sided limits: allowed to vary only between two; limits specified by the user. - Variable with single sided limits: allowed to vary only between one; upper or one lower limit specified by the user and unlimited to the; other side. - Fixed: originally defined as variable, but now taking on only the; value the parameter had at the moment it was fixed, or a value later; assigned by the user. - Constant: taking on only one value as specified by the user. When using the minimal required interface, all variable parameters are; free and unbound. The user, in their $\mbox{FCN}$, must of course be able to ""see"" all; types of defined parameters, and they therefore have access to what we call; the *external parameter list*, that is, the parameters as he defined; them. On the other hand, the internal M minimizing routines only want to; ""see"" variable parameters without limits, and so they have access only; to the *internal parameter list* which is cre",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:5474,Modifiability,variab,variable,5474," usage of the standard library (STL): the user's; implementation of the FCNBase class, initial parameter values and; uncertainties are provided by the to M user via std::vectors. - a rich interface which provides the user with more functionality; such as interaction with parameters. The core of the minimization functionality and related tools (the kernel; of M ) should be clearly separated from the user, who is interfacing via; defined user interfaces (the API). ## Internal and external parameters ##. Each of the parameters to the $\mbox{FCN}$ is defined by the user as; belonging to one of the following types:. - Freely variable: allowed to take on any value. - Variable with double sided limits: allowed to vary only between two; limits specified by the user. - Variable with single sided limits: allowed to vary only between one; upper or one lower limit specified by the user and unlimited to the; other side. - Fixed: originally defined as variable, but now taking on only the; value the parameter had at the moment it was fixed, or a value later; assigned by the user. - Constant: taking on only one value as specified by the user. When using the minimal required interface, all variable parameters are; free and unbound. The user, in their $\mbox{FCN}$, must of course be able to ""see"" all; types of defined parameters, and they therefore have access to what we call; the *external parameter list*, that is, the parameters as he defined; them. On the other hand, the internal M minimizing routines only want to; ""see"" variable parameters without limits, and so they have access only; to the *internal parameter list* which is created from the external list; by the following transformation:. - Squeeze out all parameters that are not variable. - Transform all variable parameters with limits, so that the; transformed parameter can vary without limits. (See the next section; for details concerning this transformation.) Because this; transformation is non-linear, it is recommended to a",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:5714,Modifiability,variab,variable,5714,"nterface which provides the user with more functionality; such as interaction with parameters. The core of the minimization functionality and related tools (the kernel; of M ) should be clearly separated from the user, who is interfacing via; defined user interfaces (the API). ## Internal and external parameters ##. Each of the parameters to the $\mbox{FCN}$ is defined by the user as; belonging to one of the following types:. - Freely variable: allowed to take on any value. - Variable with double sided limits: allowed to vary only between two; limits specified by the user. - Variable with single sided limits: allowed to vary only between one; upper or one lower limit specified by the user and unlimited to the; other side. - Fixed: originally defined as variable, but now taking on only the; value the parameter had at the moment it was fixed, or a value later; assigned by the user. - Constant: taking on only one value as specified by the user. When using the minimal required interface, all variable parameters are; free and unbound. The user, in their $\mbox{FCN}$, must of course be able to ""see"" all; types of defined parameters, and they therefore have access to what we call; the *external parameter list*, that is, the parameters as he defined; them. On the other hand, the internal M minimizing routines only want to; ""see"" variable parameters without limits, and so they have access only; to the *internal parameter list* which is created from the external list; by the following transformation:. - Squeeze out all parameters that are not variable. - Transform all variable parameters with limits, so that the; transformed parameter can vary without limits. (See the next section; for details concerning this transformation.) Because this; transformation is non-linear, it is recommended to avoid putting; limits on parameters where they are not needed. As an example, suppose that the user has defined the following; parameters:. - Parameter 0, constant. - Parameter 1, freely va",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:6054,Modifiability,variab,variable,6054,"nging to one of the following types:. - Freely variable: allowed to take on any value. - Variable with double sided limits: allowed to vary only between two; limits specified by the user. - Variable with single sided limits: allowed to vary only between one; upper or one lower limit specified by the user and unlimited to the; other side. - Fixed: originally defined as variable, but now taking on only the; value the parameter had at the moment it was fixed, or a value later; assigned by the user. - Constant: taking on only one value as specified by the user. When using the minimal required interface, all variable parameters are; free and unbound. The user, in their $\mbox{FCN}$, must of course be able to ""see"" all; types of defined parameters, and they therefore have access to what we call; the *external parameter list*, that is, the parameters as he defined; them. On the other hand, the internal M minimizing routines only want to; ""see"" variable parameters without limits, and so they have access only; to the *internal parameter list* which is created from the external list; by the following transformation:. - Squeeze out all parameters that are not variable. - Transform all variable parameters with limits, so that the; transformed parameter can vary without limits. (See the next section; for details concerning this transformation.) Because this; transformation is non-linear, it is recommended to avoid putting; limits on parameters where they are not needed. As an example, suppose that the user has defined the following; parameters:. - Parameter 0, constant. - Parameter 1, freely variable. - Parameter 2, variable with limits. - Parameter 3, constant. - Parameter 4, freely variable. Then the internal parameter list would be as follows:. - Internal parameter 0 = external parameter 1. - Internal parameter 1 = external parameter 2, transformed; appropriately. - Internal parameter 2 = external parameter 4. In the above example, M considers that the number of external para",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:6270,Modifiability,variab,variable,6270,"en two; limits specified by the user. - Variable with single sided limits: allowed to vary only between one; upper or one lower limit specified by the user and unlimited to the; other side. - Fixed: originally defined as variable, but now taking on only the; value the parameter had at the moment it was fixed, or a value later; assigned by the user. - Constant: taking on only one value as specified by the user. When using the minimal required interface, all variable parameters are; free and unbound. The user, in their $\mbox{FCN}$, must of course be able to ""see"" all; types of defined parameters, and they therefore have access to what we call; the *external parameter list*, that is, the parameters as he defined; them. On the other hand, the internal M minimizing routines only want to; ""see"" variable parameters without limits, and so they have access only; to the *internal parameter list* which is created from the external list; by the following transformation:. - Squeeze out all parameters that are not variable. - Transform all variable parameters with limits, so that the; transformed parameter can vary without limits. (See the next section; for details concerning this transformation.) Because this; transformation is non-linear, it is recommended to avoid putting; limits on parameters where they are not needed. As an example, suppose that the user has defined the following; parameters:. - Parameter 0, constant. - Parameter 1, freely variable. - Parameter 2, variable with limits. - Parameter 3, constant. - Parameter 4, freely variable. Then the internal parameter list would be as follows:. - Internal parameter 0 = external parameter 1. - Internal parameter 1 = external parameter 2, transformed; appropriately. - Internal parameter 2 = external parameter 4. In the above example, M considers that the number of external parameters; is 5, and the number of internal parameters is 3. This is the number; which determines, for example, the size of the error matrix of the; para",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:6296,Modifiability,variab,variable,6296,"ed to vary only between one; upper or one lower limit specified by the user and unlimited to the; other side. - Fixed: originally defined as variable, but now taking on only the; value the parameter had at the moment it was fixed, or a value later; assigned by the user. - Constant: taking on only one value as specified by the user. When using the minimal required interface, all variable parameters are; free and unbound. The user, in their $\mbox{FCN}$, must of course be able to ""see"" all; types of defined parameters, and they therefore have access to what we call; the *external parameter list*, that is, the parameters as he defined; them. On the other hand, the internal M minimizing routines only want to; ""see"" variable parameters without limits, and so they have access only; to the *internal parameter list* which is created from the external list; by the following transformation:. - Squeeze out all parameters that are not variable. - Transform all variable parameters with limits, so that the; transformed parameter can vary without limits. (See the next section; for details concerning this transformation.) Because this; transformation is non-linear, it is recommended to avoid putting; limits on parameters where they are not needed. As an example, suppose that the user has defined the following; parameters:. - Parameter 0, constant. - Parameter 1, freely variable. - Parameter 2, variable with limits. - Parameter 3, constant. - Parameter 4, freely variable. Then the internal parameter list would be as follows:. - Internal parameter 0 = external parameter 1. - Internal parameter 1 = external parameter 2, transformed; appropriately. - Internal parameter 2 = external parameter 4. In the above example, M considers that the number of external parameters; is 5, and the number of internal parameters is 3. This is the number; which determines, for example, the size of the error matrix of the; parameters, since only variable parameters have errors. An important feature of M is ",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:6709,Modifiability,variab,variable,6709,"erface, all variable parameters are; free and unbound. The user, in their $\mbox{FCN}$, must of course be able to ""see"" all; types of defined parameters, and they therefore have access to what we call; the *external parameter list*, that is, the parameters as he defined; them. On the other hand, the internal M minimizing routines only want to; ""see"" variable parameters without limits, and so they have access only; to the *internal parameter list* which is created from the external list; by the following transformation:. - Squeeze out all parameters that are not variable. - Transform all variable parameters with limits, so that the; transformed parameter can vary without limits. (See the next section; for details concerning this transformation.) Because this; transformation is non-linear, it is recommended to avoid putting; limits on parameters where they are not needed. As an example, suppose that the user has defined the following; parameters:. - Parameter 0, constant. - Parameter 1, freely variable. - Parameter 2, variable with limits. - Parameter 3, constant. - Parameter 4, freely variable. Then the internal parameter list would be as follows:. - Internal parameter 0 = external parameter 1. - Internal parameter 1 = external parameter 2, transformed; appropriately. - Internal parameter 2 = external parameter 4. In the above example, M considers that the number of external parameters; is 5, and the number of internal parameters is 3. This is the number; which determines, for example, the size of the error matrix of the; parameters, since only variable parameters have errors. An important feature of M is that parameters are allowed to change types; during the M minimization and analysis of a $\mbox{FCN}$ function.; Several applications in M have methods available to make variable; parameters fixed and vice-versa; to impose, change, or remove limits; from variable parameters; and even to define completely new parameters; at any time during a run. In addition, some M ",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:6734,Modifiability,variab,variable,6734,"e; free and unbound. The user, in their $\mbox{FCN}$, must of course be able to ""see"" all; types of defined parameters, and they therefore have access to what we call; the *external parameter list*, that is, the parameters as he defined; them. On the other hand, the internal M minimizing routines only want to; ""see"" variable parameters without limits, and so they have access only; to the *internal parameter list* which is created from the external list; by the following transformation:. - Squeeze out all parameters that are not variable. - Transform all variable parameters with limits, so that the; transformed parameter can vary without limits. (See the next section; for details concerning this transformation.) Because this; transformation is non-linear, it is recommended to avoid putting; limits on parameters where they are not needed. As an example, suppose that the user has defined the following; parameters:. - Parameter 0, constant. - Parameter 1, freely variable. - Parameter 2, variable with limits. - Parameter 3, constant. - Parameter 4, freely variable. Then the internal parameter list would be as follows:. - Internal parameter 0 = external parameter 1. - Internal parameter 1 = external parameter 2, transformed; appropriately. - Internal parameter 2 = external parameter 4. In the above example, M considers that the number of external parameters; is 5, and the number of internal parameters is 3. This is the number; which determines, for example, the size of the error matrix of the; parameters, since only variable parameters have errors. An important feature of M is that parameters are allowed to change types; during the M minimization and analysis of a $\mbox{FCN}$ function.; Several applications in M have methods available to make variable; parameters fixed and vice-versa; to impose, change, or remove limits; from variable parameters; and even to define completely new parameters; at any time during a run. In addition, some M applications (notably the; $\mbox{M",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:6803,Modifiability,variab,variable,6803,"f course be able to ""see"" all; types of defined parameters, and they therefore have access to what we call; the *external parameter list*, that is, the parameters as he defined; them. On the other hand, the internal M minimizing routines only want to; ""see"" variable parameters without limits, and so they have access only; to the *internal parameter list* which is created from the external list; by the following transformation:. - Squeeze out all parameters that are not variable. - Transform all variable parameters with limits, so that the; transformed parameter can vary without limits. (See the next section; for details concerning this transformation.) Because this; transformation is non-linear, it is recommended to avoid putting; limits on parameters where they are not needed. As an example, suppose that the user has defined the following; parameters:. - Parameter 0, constant. - Parameter 1, freely variable. - Parameter 2, variable with limits. - Parameter 3, constant. - Parameter 4, freely variable. Then the internal parameter list would be as follows:. - Internal parameter 0 = external parameter 1. - Internal parameter 1 = external parameter 2, transformed; appropriately. - Internal parameter 2 = external parameter 4. In the above example, M considers that the number of external parameters; is 5, and the number of internal parameters is 3. This is the number; which determines, for example, the size of the error matrix of the; parameters, since only variable parameters have errors. An important feature of M is that parameters are allowed to change types; during the M minimization and analysis of a $\mbox{FCN}$ function.; Several applications in M have methods available to make variable; parameters fixed and vice-versa; to impose, change, or remove limits; from variable parameters; and even to define completely new parameters; at any time during a run. In addition, some M applications (notably the; $\mbox{MINOS}$ error analysis) cause one or more variable parameter",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:7272,Modifiability,variab,variable,7272,"ueeze out all parameters that are not variable. - Transform all variable parameters with limits, so that the; transformed parameter can vary without limits. (See the next section; for details concerning this transformation.) Because this; transformation is non-linear, it is recommended to avoid putting; limits on parameters where they are not needed. As an example, suppose that the user has defined the following; parameters:. - Parameter 0, constant. - Parameter 1, freely variable. - Parameter 2, variable with limits. - Parameter 3, constant. - Parameter 4, freely variable. Then the internal parameter list would be as follows:. - Internal parameter 0 = external parameter 1. - Internal parameter 1 = external parameter 2, transformed; appropriately. - Internal parameter 2 = external parameter 4. In the above example, M considers that the number of external parameters; is 5, and the number of internal parameters is 3. This is the number; which determines, for example, the size of the error matrix of the; parameters, since only variable parameters have errors. An important feature of M is that parameters are allowed to change types; during the M minimization and analysis of a $\mbox{FCN}$ function.; Several applications in M have methods available to make variable; parameters fixed and vice-versa; to impose, change, or remove limits; from variable parameters; and even to define completely new parameters; at any time during a run. In addition, some M applications (notably the; $\mbox{MINOS}$ error analysis) cause one or more variable parameters; to be temporarily fixed during the calculation. Therefore, the; correspondence between external and internal parameter lists is in; general a dynamic one, and the number of internal parameters is not; necessarily constant. For more details about parameter interaction see [api:parameters]. ### The transformation for parameters with limits ###. [intro:limits]. For variable parameters with double sided limits $a$ (lower) and $b$; (u",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:7504,Modifiability,variab,variable,7504," they are not needed. As an example, suppose that the user has defined the following; parameters:. - Parameter 0, constant. - Parameter 1, freely variable. - Parameter 2, variable with limits. - Parameter 3, constant. - Parameter 4, freely variable. Then the internal parameter list would be as follows:. - Internal parameter 0 = external parameter 1. - Internal parameter 1 = external parameter 2, transformed; appropriately. - Internal parameter 2 = external parameter 4. In the above example, M considers that the number of external parameters; is 5, and the number of internal parameters is 3. This is the number; which determines, for example, the size of the error matrix of the; parameters, since only variable parameters have errors. An important feature of M is that parameters are allowed to change types; during the M minimization and analysis of a $\mbox{FCN}$ function.; Several applications in M have methods available to make variable; parameters fixed and vice-versa; to impose, change, or remove limits; from variable parameters; and even to define completely new parameters; at any time during a run. In addition, some M applications (notably the; $\mbox{MINOS}$ error analysis) cause one or more variable parameters; to be temporarily fixed during the calculation. Therefore, the; correspondence between external and internal parameter lists is in; general a dynamic one, and the number of internal parameters is not; necessarily constant. For more details about parameter interaction see [api:parameters]. ### The transformation for parameters with limits ###. [intro:limits]. For variable parameters with double sided limits $a$ (lower) and $b$; (upper), M uses the following transformation:. $$\begin{aligned}; P_{\mathrm{int}} &=& \arcsin; \left( 2\: \frac{ P_{\mathrm{ext}}-a}{ b-a} - 1 \right) \\; P_{\mathrm{ext}} &=& a + \frac{ b - a}{ 2}; \left( \sin P_{\mathrm{int}} + 1 \right) \end{aligned}$$. so that the internal value $P_{\mathrm{int}}$ can take on any value,; while",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:7589,Modifiability,variab,variable,7589," they are not needed. As an example, suppose that the user has defined the following; parameters:. - Parameter 0, constant. - Parameter 1, freely variable. - Parameter 2, variable with limits. - Parameter 3, constant. - Parameter 4, freely variable. Then the internal parameter list would be as follows:. - Internal parameter 0 = external parameter 1. - Internal parameter 1 = external parameter 2, transformed; appropriately. - Internal parameter 2 = external parameter 4. In the above example, M considers that the number of external parameters; is 5, and the number of internal parameters is 3. This is the number; which determines, for example, the size of the error matrix of the; parameters, since only variable parameters have errors. An important feature of M is that parameters are allowed to change types; during the M minimization and analysis of a $\mbox{FCN}$ function.; Several applications in M have methods available to make variable; parameters fixed and vice-versa; to impose, change, or remove limits; from variable parameters; and even to define completely new parameters; at any time during a run. In addition, some M applications (notably the; $\mbox{MINOS}$ error analysis) cause one or more variable parameters; to be temporarily fixed during the calculation. Therefore, the; correspondence between external and internal parameter lists is in; general a dynamic one, and the number of internal parameters is not; necessarily constant. For more details about parameter interaction see [api:parameters]. ### The transformation for parameters with limits ###. [intro:limits]. For variable parameters with double sided limits $a$ (lower) and $b$; (upper), M uses the following transformation:. $$\begin{aligned}; P_{\mathrm{int}} &=& \arcsin; \left( 2\: \frac{ P_{\mathrm{ext}}-a}{ b-a} - 1 \right) \\; P_{\mathrm{ext}} &=& a + \frac{ b - a}{ 2}; \left( \sin P_{\mathrm{int}} + 1 \right) \end{aligned}$$. so that the internal value $P_{\mathrm{int}}$ can take on any value,; while",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:7778,Modifiability,variab,variable,7778,"eter 3, constant. - Parameter 4, freely variable. Then the internal parameter list would be as follows:. - Internal parameter 0 = external parameter 1. - Internal parameter 1 = external parameter 2, transformed; appropriately. - Internal parameter 2 = external parameter 4. In the above example, M considers that the number of external parameters; is 5, and the number of internal parameters is 3. This is the number; which determines, for example, the size of the error matrix of the; parameters, since only variable parameters have errors. An important feature of M is that parameters are allowed to change types; during the M minimization and analysis of a $\mbox{FCN}$ function.; Several applications in M have methods available to make variable; parameters fixed and vice-versa; to impose, change, or remove limits; from variable parameters; and even to define completely new parameters; at any time during a run. In addition, some M applications (notably the; $\mbox{MINOS}$ error analysis) cause one or more variable parameters; to be temporarily fixed during the calculation. Therefore, the; correspondence between external and internal parameter lists is in; general a dynamic one, and the number of internal parameters is not; necessarily constant. For more details about parameter interaction see [api:parameters]. ### The transformation for parameters with limits ###. [intro:limits]. For variable parameters with double sided limits $a$ (lower) and $b$; (upper), M uses the following transformation:. $$\begin{aligned}; P_{\mathrm{int}} &=& \arcsin; \left( 2\: \frac{ P_{\mathrm{ext}}-a}{ b-a} - 1 \right) \\; P_{\mathrm{ext}} &=& a + \frac{ b - a}{ 2}; \left( \sin P_{\mathrm{int}} + 1 \right) \end{aligned}$$. so that the internal value $P_{\mathrm{int}}$ can take on any value,; while the external value $P_{\mathrm{ext}}$ can take on values only; between the lower limit $a$ and the upper limit $b$. Since the; transformation is necessarily non-linear, it would transform a nice; line",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:8164,Modifiability,variab,variable,8164,"ize of the error matrix of the; parameters, since only variable parameters have errors. An important feature of M is that parameters are allowed to change types; during the M minimization and analysis of a $\mbox{FCN}$ function.; Several applications in M have methods available to make variable; parameters fixed and vice-versa; to impose, change, or remove limits; from variable parameters; and even to define completely new parameters; at any time during a run. In addition, some M applications (notably the; $\mbox{MINOS}$ error analysis) cause one or more variable parameters; to be temporarily fixed during the calculation. Therefore, the; correspondence between external and internal parameter lists is in; general a dynamic one, and the number of internal parameters is not; necessarily constant. For more details about parameter interaction see [api:parameters]. ### The transformation for parameters with limits ###. [intro:limits]. For variable parameters with double sided limits $a$ (lower) and $b$; (upper), M uses the following transformation:. $$\begin{aligned}; P_{\mathrm{int}} &=& \arcsin; \left( 2\: \frac{ P_{\mathrm{ext}}-a}{ b-a} - 1 \right) \\; P_{\mathrm{ext}} &=& a + \frac{ b - a}{ 2}; \left( \sin P_{\mathrm{int}} + 1 \right) \end{aligned}$$. so that the internal value $P_{\mathrm{int}}$ can take on any value,; while the external value $P_{\mathrm{ext}}$ can take on values only; between the lower limit $a$ and the upper limit $b$. Since the; transformation is necessarily non-linear, it would transform a nice; linear problem into a nasty non-linear one, which is the reason why; limits should be avoided if not necessary. In addition, the; transformation does require some computer time, so it slows down the; computation a little bit, and more importantly, it introduces additional; numerical inaccuracy into the problem in addition to what is introduced; in the numerical calculation of the $\mbox{FCN}$ value. The effects; of non-linearity and numerical roundoff bo",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:10558,Modifiability,variab,variable,10558,"ngle sided limits on parameters are provided by M ,; with their transformation being:. Lower bound $a$:. $$\begin{aligned}; P_{\mathrm{int}} &=& \pm\sqrt{(P_{\mathrm{ext}} - a + 1)^2 - 1} \\; P_{\mathrm{ext}} &=& a - 1 + \sqrt{P_{\mathrm{int}}^2 + 1} \end{aligned}$$. Upper bound $b$:. $$\begin{aligned}; P_{\mathrm{int}} &=& \pm\sqrt{(b - P_{\mathrm{ext}} + 1)^2 - 1} \\; P_{\mathrm{ext}} &=& b + 1 - \sqrt{P_{\mathrm{int}}^2 + 1} \end{aligned}$$. The transformation of course also affects the parameter error matrix, so; M does a transformation of the error matrix (and the ""parabolic""; parameter errors) when there are parameter limits. Users should however; realize that the transformation is only a linear approximation, and that; it cannot give a meaningful result if one or more parameters is very; close to a limit, where; $\partial P_{\mathrm{ext}} / \partial P_{\mathrm{int}} \approx 0$.; Therefore, it is recommended that:. - Limits on variable parameters should be used only when needed in; order to prevent the parameter from taking on unphysical values. - When a satisfactory minimum has been found using limits, the limits; should then be removed if possible, in order to perform or; re-perform the error analysis without limits. Further discussion of the effects of parameter limits may be found in; the last chapter. ## M strategy ##. At many places in the analysis of the $\mbox{FCN}$ (the user; provided function), M must decide whether to be ""safe"" and waste a few; function calls in order to know where it is, or to be ""fast"" and attempt; to get the requested results with the fewest possible calls at a certain; risk of not obtaining the precision desired by the user. In order to; allow the user to influence these decisions, there is a M class; MnStrategy (see [api:strategy]) which the user can use to put different; settings. In the current release, this MnStrategy can be instantiated; with three different minimization quality levels for low (0), medium (1); and high (2) q",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:11861,Modifiability,variab,variable,11861," the effects of parameter limits may be found in; the last chapter. ## M strategy ##. At many places in the analysis of the $\mbox{FCN}$ (the user; provided function), M must decide whether to be ""safe"" and waste a few; function calls in order to know where it is, or to be ""fast"" and attempt; to get the requested results with the fewest possible calls at a certain; risk of not obtaining the precision desired by the user. In order to; allow the user to influence these decisions, there is a M class; MnStrategy (see [api:strategy]) which the user can use to put different; settings. In the current release, this MnStrategy can be instantiated; with three different minimization quality levels for low (0), medium (1); and high (2) quality. Default settings for iteration cycles and; tolerances are initialized then. The default setting is set for medium; quality. Value 0 (low) indicates to M that it should economize function; calls; it is intended for cases where there are many variable parameters; and/or the function takes a long time to calculate and/or the user is; not interested in very precise values for parameter errors. On the other; hand, value 2 (high) indicates that M is allowed to waste function calls; in order to be sure that all values are precise; it is intended for; cases where the function is evaluated in a relatively short time and/or; where the parameter errors must be calculated reliably. In addition all; constants set in MnStrategy can be changed individually by the user,; e.g. the number of iteration cycles in the numerical gradient. ## Parameter errors ##. M is usually used to find the ""best"" values of a set of parameters,; where ""best"" is defined as those values which minimize a given function,; $\mbox{FCN}$. The width of the function minimum, or more generally,; the shape of the function in some neighbourhood of the minimum, gives; information about the *uncertainty* in the best parameter values, often; called by physicists the *parameter errors*. An i",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:18744,Modifiability,variab,variable,18744,"al asymmetric, and may be expensive to calculate,; especially if there are a lot of free parameters and the problem is very; non-linear. $\mbox{MINOS}$ can only operate after a good minimum has already; been found, and the error matrix has been calculated, so the; $\mbox{MINOS}$ error analysis will normally follow a; $\mbox{MIGRAD}$ minimization. The $\mbox{MINOS}$ error for a; given parameter is defined as the change in the value of that parameter; which causes ${\displaystyle F'}$ to increase by the amount; FCNBase::up(), where ${\displaystyle F'}$ is the minimum of; $\mbox{FCN}$ with respect to all *other* free parameters, and; FCNBase::up() is the return value of the error definition specified by; the user (default = 1.). The algorithm for finding the positive and negative $\mbox{MINOS}$; errors for parameter $\mbox{n}$ consists of varying parameter; $\mbox{n}$, each time minimizing $\mbox{FCN}$ with respect to; all the other $\mbox{npar - 1}$ variable parameters, to find; numerically the two values of parameter $\mbox{n}$ for which the; minimum of $\mbox{FCN}$ takes on the values; $\displaystyle F_{\mathrm{min}} + \mbox{up}$, where; $\displaystyle F_{\mathrm{min}}$ is the minimum of $\mbox{FCN}$ with; respect to all $\mbox{npar}$ parameters. In order to make the; procedure as fast as possible, $\mbox{MINOS}$ uses the error matrix; to predict the values of all parameters at the various sub-minima which; it will have to find in the course of the calculation, and in the limit; that the problem is nearly linear, the predictions of $\mbox{MINOS}$; will be nearly exact, requiring very few iterations. On the other hand,; when the problem is very non-linear (i.e., $\mbox{FCN}$ is far from; a quadratic function of its parameters), is precisely the situation when; $\mbox{MINOS}$ is needed in order to indicate the correct parameter; errors. ### $\mbox{CONTOURS}$ plotting ###. M offers a procedure for finding $\mbox{FCN}$ $\mbox{CONTOURS}$; (provided via the class MnContour",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:20144,Modifiability,variab,variable,20144,"MINOS}$ uses the error matrix; to predict the values of all parameters at the various sub-minima which; it will have to find in the course of the calculation, and in the limit; that the problem is nearly linear, the predictions of $\mbox{MINOS}$; will be nearly exact, requiring very few iterations. On the other hand,; when the problem is very non-linear (i.e., $\mbox{FCN}$ is far from; a quadratic function of its parameters), is precisely the situation when; $\mbox{MINOS}$ is needed in order to indicate the correct parameter; errors. ### $\mbox{CONTOURS}$ plotting ###. M offers a procedure for finding $\mbox{FCN}$ $\mbox{CONTOURS}$; (provided via the class MnContours, see [api:contours]). The contour calculated by MnContours::operator() is dynamic, in the; sense that it represents the minimum of $\mbox{FCN}$ with respect to; all the other $\mbox{npar - 2}$ parameters (if any). In statistical; terms, this means that MnContours takes account of the correlations; between the two parameters being plotted, and all the other variable; parameters, using a procedure analogous to that of $\mbox{MINOS}$.; (If this feature is not wanted, then the other parameters must be fixed; before calling $\mbox{CONTOURS}$.) MnContours provides the actual; coordinates of the points around the contour, suitable for plotting with; a graphics routine or by hand (using MnPlot, see [api:plot]). The points; are given in counter-clockwise order around the contour. Only one; contour is calculated per command, and the level is; $\displaystyle F_{\mathrm{min}} + \mbox{up}$. where $\mbox{up}$; is the return value of FCNBase::up() specified by the user (usually 1.0; by default). The number of points to be calculated is chosen by the user; (default is 20). As a by-product, $\mbox{CONTOURS}$ provides the; $\mbox{MINOS}$ errors of the two parameters in question, since these; are just the extreme points of the contour (use the; MnContours::contour(...) method in order to get the points of the; contour and",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:21997,Modifiability,adapt,adapt,21997,"re just the extreme points of the contour (use the; MnContours::contour(...) method in order to get the points of the; contour and the ones of the $\mbox{MINOS}$ errors).; MnContours::operator() returns a; std::vector$<$std::pair$<$double,double$> >$ of (x,y) points. Using; MnPlot::operator() will generate a text graphics plot in the terminal. # M installation #. ## M releases ##. To follow the current release process the user is referred to the M; homepage @bib-C++MINUIT. M was re–implemented in from 2002–2004, but the functionality is largely; compatible with the one of the version. The usage is different in the; sense that the re–write from to was done by its signification and not; literally (with minor exceptions). Applications such as; $\mbox{MIGRAD}$ have a corresponding class MnMigrad, M ""commands""; became classes or methods of classes according to their purpose. Users; familiar with the version of M , who have not yet used releases from the; version, should however read this manual, in order to adapt to the; changes as well as to discover the new features and easier ways of using; old features. ## Install M using autoconf/make ##. For each release of M a tar.gz file is provided for downloading from the; M homepage @bib-C++MINUIT. For non-UNIX platforms please refer to the M; homepage. The necessary steps to follow are:. 1. download the tar.gz by clicking on it from the release page. 2. unzip it:. $ unzip Minuit-x.x.x.tar.gz. 3. untar it:. $ tar xvf Minuit-x.x.x.tar. 4. step down to the created Minuit-x.x.x directory:. $ cd Minuit-x.x.x/. 5. run the ""configure"" script:. $ ./configure. 6. run ""make"" to compile the source code:. $ make. 7. run ""make check"" to create the executable example:. $ make check. 8. run the executable example:. $ tests/MnTutorial/Quad4FMain.C. The output should look like that:. Minuit did successfully converge. # of function calls: 74; minimum function value: 1.12392e-09; minimum edm: 1.12392e-09; minimum internal state vector: LAVector ",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:22563,Modifiability,config,configure,22563,"on. The usage is different in the; sense that the re–write from to was done by its signification and not; literally (with minor exceptions). Applications such as; $\mbox{MIGRAD}$ have a corresponding class MnMigrad, M ""commands""; became classes or methods of classes according to their purpose. Users; familiar with the version of M , who have not yet used releases from the; version, should however read this manual, in order to adapt to the; changes as well as to discover the new features and easier ways of using; old features. ## Install M using autoconf/make ##. For each release of M a tar.gz file is provided for downloading from the; M homepage @bib-C++MINUIT. For non-UNIX platforms please refer to the M; homepage. The necessary steps to follow are:. 1. download the tar.gz by clicking on it from the release page. 2. unzip it:. $ unzip Minuit-x.x.x.tar.gz. 3. untar it:. $ tar xvf Minuit-x.x.x.tar. 4. step down to the created Minuit-x.x.x directory:. $ cd Minuit-x.x.x/. 5. run the ""configure"" script:. $ ./configure. 6. run ""make"" to compile the source code:. $ make. 7. run ""make check"" to create the executable example:. $ make check. 8. run the executable example:. $ tests/MnTutorial/Quad4FMain.C. The output should look like that:. Minuit did successfully converge. # of function calls: 74; minimum function value: 1.12392e-09; minimum edm: 1.12392e-09; minimum internal state vector: LAVector parameters:. -1.82079e-05; -1.20794e-05; 6.22382e-06; -3.0465e-05. minimum internal covariance matrix: LASymMatrix parameters:. 4 1 2 2.70022e-18; 1 5 3 1.87754e-17; 2 3 6 2.29467e-17; 2.70022e-18 1.87754e-17 2.29467e-17 1. # ext. || name || type || value || error +/-. 0 || x || free ||-1.821e-05 || 2; 1 || y || free ||-1.208e-05 || 2.236; 2 || z || free || 6.224e-06 || 2.449; 3 || w || free ||-3.047e-05 || 1. MnUserCovariance:. 4 1 2 2.70022e-18; 1 5 3 1.87754e-17; 2 3 6 2.29467e-17; 2.70022e-18 1.87754e-17 2.29467e-17 1. MnUserCovariance parameter correlations:. 1 0.223607 0.4082",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:22587,Modifiability,config,configure,22587,"nt in the; sense that the re–write from to was done by its signification and not; literally (with minor exceptions). Applications such as; $\mbox{MIGRAD}$ have a corresponding class MnMigrad, M ""commands""; became classes or methods of classes according to their purpose. Users; familiar with the version of M , who have not yet used releases from the; version, should however read this manual, in order to adapt to the; changes as well as to discover the new features and easier ways of using; old features. ## Install M using autoconf/make ##. For each release of M a tar.gz file is provided for downloading from the; M homepage @bib-C++MINUIT. For non-UNIX platforms please refer to the M; homepage. The necessary steps to follow are:. 1. download the tar.gz by clicking on it from the release page. 2. unzip it:. $ unzip Minuit-x.x.x.tar.gz. 3. untar it:. $ tar xvf Minuit-x.x.x.tar. 4. step down to the created Minuit-x.x.x directory:. $ cd Minuit-x.x.x/. 5. run the ""configure"" script:. $ ./configure. 6. run ""make"" to compile the source code:. $ make. 7. run ""make check"" to create the executable example:. $ make check. 8. run the executable example:. $ tests/MnTutorial/Quad4FMain.C. The output should look like that:. Minuit did successfully converge. # of function calls: 74; minimum function value: 1.12392e-09; minimum edm: 1.12392e-09; minimum internal state vector: LAVector parameters:. -1.82079e-05; -1.20794e-05; 6.22382e-06; -3.0465e-05. minimum internal covariance matrix: LASymMatrix parameters:. 4 1 2 2.70022e-18; 1 5 3 1.87754e-17; 2 3 6 2.29467e-17; 2.70022e-18 1.87754e-17 2.29467e-17 1. # ext. || name || type || value || error +/-. 0 || x || free ||-1.821e-05 || 2; 1 || y || free ||-1.208e-05 || 2.236; 2 || z || free || 6.224e-06 || 2.449; 3 || w || free ||-3.047e-05 || 1. MnUserCovariance:. 4 1 2 2.70022e-18; 1 5 3 1.87754e-17; 2 3 6 2.29467e-17; 2.70022e-18 1.87754e-17 2.29467e-17 1. MnUserCovariance parameter correlations:. 1 0.223607 0.408248 1.35011e-18; 0.223607",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:24707,Modifiability,config,configure,24707,"eff:. 0.408248; 0.547723; 0.621261; 0. ## CVS code repository ##. How to check out (–in) code from the CVS code repository is described at; the M homepage @bib-C++MINUIT. To get the source code from the CVS; repository one needs to do:. Kerberos IV authorization:. $ setenv CVSROOT :kserver:SEAL.cvs.cern.ch:/cvs/SEAL. $ cvs co MathLibs/Minuit. Anonymous read-only access (if it's enabled by the librarian, see; details):. $ setenv CVSROOT :pserver:anonymous@SEAL.cvs.cern.ch:/cvs/SEAL. $ cvs login. (Logging in to :pserver:anonymous@seal.cvs.cern.ch:2401/cvs/SEAL) CVS; password:cvs. $ cvs co MathLibs/Minuit. (If you want to check out a tagged version SEAL\_x\_x\_x of MINUIT, then; do. $ cvs co -r SEAL\_x\_x\_x MathLibs/Minuit ). ## Create a tar.gz from CVS ##. Once the sources are checked out from the CVS code repository,. 1. change to the directory:. $ cd MathLibs/Minuit. 2. run autogen:. $ ./autogen. 3. create a new directory:. $ cd ..; $ mkdir Minuit-BUILD; $ cd Minuit-BUILD/. 4. run configure:. $ ../Minuit/configure. 5. create the tar.gz:. $ make dist. This will create a Minuit-x.x.x.tar.gz which can be distributed and used; as described above. ## M versions ##. The version numbers of M follow the release numbers of the SEAL project; @bib-SEAL at CERN @bib-CERN. ### From to ###. The program is entirely written in standard portable . M does not depend; on any external library. In its minimal usage the user must only provide; an implementation of the FCNBase class to M and parameters and; uncertainties in form of std::vector containers. ### Memory allocation and thread safety ###. Differently to the version of M , the version has its own memory manager; (StackAllocator. The user can select between the standard dynamic memory; allocation and deallocation (default) and performance-optimized; stack–like allocation (optional). However, the library is not thread; save using stack–allocation. ### M parameters ###. Differently to the version of M there is no limit on the numb",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:24731,Modifiability,config,configure,24731,"23; 0.621261; 0. ## CVS code repository ##. How to check out (–in) code from the CVS code repository is described at; the M homepage @bib-C++MINUIT. To get the source code from the CVS; repository one needs to do:. Kerberos IV authorization:. $ setenv CVSROOT :kserver:SEAL.cvs.cern.ch:/cvs/SEAL. $ cvs co MathLibs/Minuit. Anonymous read-only access (if it's enabled by the librarian, see; details):. $ setenv CVSROOT :pserver:anonymous@SEAL.cvs.cern.ch:/cvs/SEAL. $ cvs login. (Logging in to :pserver:anonymous@seal.cvs.cern.ch:2401/cvs/SEAL) CVS; password:cvs. $ cvs co MathLibs/Minuit. (If you want to check out a tagged version SEAL\_x\_x\_x of MINUIT, then; do. $ cvs co -r SEAL\_x\_x\_x MathLibs/Minuit ). ## Create a tar.gz from CVS ##. Once the sources are checked out from the CVS code repository,. 1. change to the directory:. $ cd MathLibs/Minuit. 2. run autogen:. $ ./autogen. 3. create a new directory:. $ cd ..; $ mkdir Minuit-BUILD; $ cd Minuit-BUILD/. 4. run configure:. $ ../Minuit/configure. 5. create the tar.gz:. $ make dist. This will create a Minuit-x.x.x.tar.gz which can be distributed and used; as described above. ## M versions ##. The version numbers of M follow the release numbers of the SEAL project; @bib-SEAL at CERN @bib-CERN. ### From to ###. The program is entirely written in standard portable . M does not depend; on any external library. In its minimal usage the user must only provide; an implementation of the FCNBase class to M and parameters and; uncertainties in form of std::vector containers. ### Memory allocation and thread safety ###. Differently to the version of M , the version has its own memory manager; (StackAllocator. The user can select between the standard dynamic memory; allocation and deallocation (default) and performance-optimized; stack–like allocation (optional). However, the library is not thread; save using stack–allocation. ### M parameters ###. Differently to the version of M there is no limit on the number of; parameters, var",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:25053,Modifiability,portab,portable,25053,"co MathLibs/Minuit. Anonymous read-only access (if it's enabled by the librarian, see; details):. $ setenv CVSROOT :pserver:anonymous@SEAL.cvs.cern.ch:/cvs/SEAL. $ cvs login. (Logging in to :pserver:anonymous@seal.cvs.cern.ch:2401/cvs/SEAL) CVS; password:cvs. $ cvs co MathLibs/Minuit. (If you want to check out a tagged version SEAL\_x\_x\_x of MINUIT, then; do. $ cvs co -r SEAL\_x\_x\_x MathLibs/Minuit ). ## Create a tar.gz from CVS ##. Once the sources are checked out from the CVS code repository,. 1. change to the directory:. $ cd MathLibs/Minuit. 2. run autogen:. $ ./autogen. 3. create a new directory:. $ cd ..; $ mkdir Minuit-BUILD; $ cd Minuit-BUILD/. 4. run configure:. $ ../Minuit/configure. 5. create the tar.gz:. $ make dist. This will create a Minuit-x.x.x.tar.gz which can be distributed and used; as described above. ## M versions ##. The version numbers of M follow the release numbers of the SEAL project; @bib-SEAL at CERN @bib-CERN. ### From to ###. The program is entirely written in standard portable . M does not depend; on any external library. In its minimal usage the user must only provide; an implementation of the FCNBase class to M and parameters and; uncertainties in form of std::vector containers. ### Memory allocation and thread safety ###. Differently to the version of M , the version has its own memory manager; (StackAllocator. The user can select between the standard dynamic memory; allocation and deallocation (default) and performance-optimized; stack–like allocation (optional). However, the library is not thread; save using stack–allocation. ### M parameters ###. Differently to the version of M there is no limit on the number of; parameters, variable or non-variable. Memory allocation is done; dynamically according to the actual needs and ""on demand"". There is no; protection against an upper limit on the number of parameters, however; the ""technological"" limitations of M can be seen around a maximum of 15; free parameters at a time. ## Interfe",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:25729,Modifiability,variab,variable,25729,". run configure:. $ ../Minuit/configure. 5. create the tar.gz:. $ make dist. This will create a Minuit-x.x.x.tar.gz which can be distributed and used; as described above. ## M versions ##. The version numbers of M follow the release numbers of the SEAL project; @bib-SEAL at CERN @bib-CERN. ### From to ###. The program is entirely written in standard portable . M does not depend; on any external library. In its minimal usage the user must only provide; an implementation of the FCNBase class to M and parameters and; uncertainties in form of std::vector containers. ### Memory allocation and thread safety ###. Differently to the version of M , the version has its own memory manager; (StackAllocator. The user can select between the standard dynamic memory; allocation and deallocation (default) and performance-optimized; stack–like allocation (optional). However, the library is not thread; save using stack–allocation. ### M parameters ###. Differently to the version of M there is no limit on the number of; parameters, variable or non-variable. Memory allocation is done; dynamically according to the actual needs and ""on demand"". There is no; protection against an upper limit on the number of parameters, however; the ""technological"" limitations of M can be seen around a maximum of 15; free parameters at a time. ## Interference with other packages ##. The new M has been designed to interfere as little as possible with; other programs or packages which may be loaded at the same time. M is; thread safe by default. Optionally the user can select a different way; of dynamically allocating memory in the class StackAllacator for M , in; which case (and after an entire recompilation of the whole library) the; thread safety is lost. ## Floating-point precision ##. [install:epsmac]. M is entirely based on double precision. The actual floating point; precision of double precision (32–bit or 64–bit) is platform dependent; and can even vary on the same platform, depending on whether a f",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:25745,Modifiability,variab,variable,25745,". run configure:. $ ../Minuit/configure. 5. create the tar.gz:. $ make dist. This will create a Minuit-x.x.x.tar.gz which can be distributed and used; as described above. ## M versions ##. The version numbers of M follow the release numbers of the SEAL project; @bib-SEAL at CERN @bib-CERN. ### From to ###. The program is entirely written in standard portable . M does not depend; on any external library. In its minimal usage the user must only provide; an implementation of the FCNBase class to M and parameters and; uncertainties in form of std::vector containers. ### Memory allocation and thread safety ###. Differently to the version of M , the version has its own memory manager; (StackAllocator. The user can select between the standard dynamic memory; allocation and deallocation (default) and performance-optimized; stack–like allocation (optional). However, the library is not thread; save using stack–allocation. ### M parameters ###. Differently to the version of M there is no limit on the number of; parameters, variable or non-variable. Memory allocation is done; dynamically according to the actual needs and ""on demand"". There is no; protection against an upper limit on the number of parameters, however; the ""technological"" limitations of M can be seen around a maximum of 15; free parameters at a time. ## Interference with other packages ##. The new M has been designed to interfere as little as possible with; other programs or packages which may be loaded at the same time. M is; thread safe by default. Optionally the user can select a different way; of dynamically allocating memory in the class StackAllacator for M , in; which case (and after an entire recompilation of the whole library) the; thread safety is lost. ## Floating-point precision ##. [install:epsmac]. M is entirely based on double precision. The actual floating point; precision of double precision (32–bit or 64–bit) is platform dependent; and can even vary on the same platform, depending on whether a f",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:30190,Modifiability,variab,variable,30190,"lied as input to the M minimizers such as VariableMetricMinimizer or; MnMigrad (see [api:migrad]). Later values are determined by M as it; searches for the minimum or performs whatever analysis is requested by; the user. ### FCNBase::up() ###. [howto:errordef] Returns the value of $\mbox{up}$ (default value; $= 1.$), defining parameter errors. M defines parameter errors as the; change in parameter value required to change the function value by; $\mbox{up}$. Normally, for chisquared fits $\mbox{up = 1}$, and; for negative log likelihood, $\mbox{up = 0.5}$. ### $\mbox{FCN}$ function with gradient ###. By default first derivatives are calculated numerically by M . In case; the user wants to supply their own gradient calculator (e.g. analytical; derivatives), they need to implement the FCNGradientBase interface. ![](figures/fcngradientbase.png). The size of the output vector is the same as of the input one. The same; is true for the position of the elements (first derivative of the; function with respect to the $n_\mathrm{th}$ variable has index $n$ in; the output vector). ## M parameters ##. Interaction with the parameters of the function are essential both for M; and the user. Different interfaces are provided, depending on the level; of interaction. ### Minimal required interface ###. Starting values of parameters and uncertainties can be provided to M by; the user via std::vector$<$double$>$ vector containers. Any interaction; with the parameters before minimization (fix, release, limits, etc.) is; not possible then. Optionally if the user wants to provide starting values for the; covariance, they have to provide the values in a std::vector$<$double$>$; vector container stored in upper triangular packed storage format (see; [api:covariance]). ### MnUserParameters ###. A more functional interface to the user parameters is provided through M; via the class MnUserParameters. The user can add parameters giving them; a name and starting values. More information can be fou",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:32644,Modifiability,variab,variables,32644,"of the minimization is transformed into the user; representable format by M . For more explanations see [api:state]. ## Input to M ##. The following input combinations to M are possible:. - $\mbox{FCN}$ + parameters + uncertainties. - $\mbox{FCN}$ with gradient + parameters + uncertainties. - $\mbox{FCN}$ + parameters + covariance. - $\mbox{FCN}$ with gradient + parameters + covariance. For each of these combinations the user can chose between a minimal; required interface (using std::vector containers) for the parameters and; uncertainties or a more functional one provided by M . If the user wants; to interact with the parameters before minimization (fixing,; adding/removing limits), the minimal required interface cannot be used. ### What the user must supply ###. The user must supply to M. - a valid implementation of the FCNBase base class. - parameters with their starting values. - expected uncertainties on the parameters. The input parameters can be simply defined via an; std::vector$<$double$>$, which means that all parameters are variables.; If the user wants fix a parameter or put limits on it before; minimization, they have to instantiate a MnUserParameters object and then; add parameters one by one, giving them a name, value, uncertainty. Once; all parameters are added to MnUserParameters, they can fix a parameter or; put limits on another one before handing them over to Minuit for; minimization. ### What the user can supply ###. Optionally the user can supply their own gradient calculator by; implementing the FCNGradientBase interface or supply a full covariance; matrix for input if one is available. The covariance matrix can be; supplied in form of a std::vector$<$double$>$ in packed storage format; (upper triangular), or in a more user-friendly way by using the; interface provided by the MnUserCovariance. ## Running a M minimization ##. Two use cases are addressed for minimization:. - The user just wants the function to be minimized in one go. - The user ",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:39202,Modifiability,variab,variable,39202,"s of the state at the minimum are; provided. ### fval(), edm(), nfcn() ###. The method double FunctionMinimum::fval() returns the function value at; the minimum, the method double FunctionMinimum::edm() returns the; expected *vertical* distance to the minimum EDM and unsigned int; FunctionMinimum::nfcn() returns the total number of function calls; during the minimization. ## MnContours ##. [api:contours]. ### MnContours(const FCNBase&, const FunctionMinimum&) ###. Construct an MnContours object from the user's FCN and a valid; FunctionMinimum. Additional constructors for user specific MnStrategy; settings are provided. ### operator() ###. The method MnContours::operator()(unsigned int parx, unsigned int pary,; unsigned int npoints = 20) const calculates one function contour of; $\mbox{FCN}$ with respect to parameters $\mbox{parx}$ and; $\mbox{pary}$. The return value is a; std::vector$<$std::pair$<$double,double$>$ $>$ of (x,y) points.; $\mbox{FCN}$ minimized always with respect to all other; $\mbox{n - 2}$ variable parameters (if any). M will try to find; $\mbox{npoints}$ points on the contour (default 20). To calculate; more than one contour, the user needs to set the error definition; [howto:errordef] in its $\mbox{FCN}$ to the appropriate value for; the desired confidence level and call the method MnContours::operator(); for each contour. ### contour(...) ###. MnContours::contour(unsigned int parx, unsigned int pary, unsigned int; npoints = 20) causes a $\mbox{CONTOURS}$ error analysis and returns; the result in form of ContoursError. As a by-product ContoursError keeps; the MinosError information of parameters $\mbox{parx}$ and; $\mbox{pary}$. The result ContoursError can be easily printed using; std::cout. ## MnEigen ##. [api:eigen] MnEigen calculates and the eigenvalues of the user; covariance matrix MnUserCovariance. ### MnEigen() ###. MnEigen is instantiated via default constructor. ### operator() ###. operator()(const MnUserCovariance&) const will perform t",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:40621,Modifiability,variab,variable,40621,"r(unsigned int parx, unsigned int pary, unsigned int; npoints = 20) causes a $\mbox{CONTOURS}$ error analysis and returns; the result in form of ContoursError. As a by-product ContoursError keeps; the MinosError information of parameters $\mbox{parx}$ and; $\mbox{pary}$. The result ContoursError can be easily printed using; std::cout. ## MnEigen ##. [api:eigen] MnEigen calculates and the eigenvalues of the user; covariance matrix MnUserCovariance. ### MnEigen() ###. MnEigen is instantiated via default constructor. ### operator() ###. operator()(const MnUserCovariance&) const will perform the calculation; of the eigenvalues of the covariance matrix and return the result in; form of a std::vector\<double\>. The eigenvalues are ordered from the; smallest first to the largest eigenvalue. ## MnHesse ##. [api:hesse]. With MnHesse the user can instructs M to calculate, by finite; differences, the Hessian or error matrix. That is, it calculates the; full matrix of second derivatives of the function with respect to the; currently variable parameters, and inverts it. ### MnHesse() ###. The default constructor of MnHesse() will use default settings of; MnStrategy. Other constructors with user specific MnStrategy settings; are provided as well. ### operator() ###. The MnHesse::operator() is overloaded both for internal (M ) and; external (user) parameters. External parameters can be specified as; std::vector$<$double$>$ or as MnUserParameters. The return value is; always a MnUserParameterState. The optional argument $\mbox{maxcalls}$ specifies the (approximate); maximum number of function calls after which the calculation will be; stopped. ## MnMachinePrecision ##. [api:epsmac]. ### MnMachinePrecision() ###. M determines the nominal precision itself in the default constructor; MnMachinePrecision(). ### setPrecision(double eps) ###. Informs M that the relative floating point arithmetic precision is; $\mbox{eps}$. The method can be used to override M 's own; determination, when t",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:47620,Modifiability,variab,variable,47620," MnPlot() ###. The default constructor initializes default settings for the text window; size. ### operator() ###. MnPlot::operator()(const std::vector$<$std::pair$<$double,double$>$; $>$&) prints a vector of (x,y) points on the text terminal.; operator()(double xmin, double ymin, const; std::vector$<$std::pair$<$double,double$>$ $>$&) prints in addition the; coordinates of the (x,y) values at the minimum. ## MnScan and ScanMinimizer ##. [api:scan]. MnScan scans the value of the user function by varying one parameter. It; is sometimes useful for debugging the user function or finding a; reasonable starting point. Constructor arguments, methods arguments and; names of methods are the same as for MnMigrad and; VariableMetricMinimizer. ### scan(unsigned int par, unsigned int npoint, double low, double high) ###. Scans the value of the user function by varying parameter number; $\mbox{par}$, leaving all other parameters fixed at the current; value. If $\mbox{par}$ is not specified, all variable parameters are; scanned in sequence. The number of points $\mbox{npoints}$ in the; scan is 40 by default, and cannot exceed 100. The range of the scan is; by default 2 standard deviations on each side of the current best value,; but can be specified as from $\mbox{low}$ to $\mbox{high}$.; After each scan, if a new minimum is found, the best parameter values; are retained as start values for future scans or minimizations. The; curve resulting from each scan can be plotted on the output terminal; using MnPlot [api:plot] in order to show the approximate behaviour of; the function. ### ScanMinimizer ###. Although the $\mbox{SCAN}$ method is not intended for minimization; it can be used as a minimizer in its most primitive form. ## MnSimplex and SimplexMinimizer ##. [api:simplex]. $\mbox{SIMPLEX}$ is a function minimization method using the simplex; method of Nelder and Mead. MnSimplex provides minimization of the; function by the method of $\mbox{SIMPLEX}$ and the functionality for; ",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:52055,Modifiability,variab,variable,52055,"n general, low; values of $\mbox{level}$ mean fewer function calls and high values; mean more reliable minimization. Currently allowed values are 0 (low), 1; (default), and 2 (high). ### MnStrategy() ###. Default constructor, sets all settings according to; $\mbox{level}$$ = 1.$. ### MnStrategy(unsigned int level) ###. Explicit constructor for predefined settings of desired; $\mbox{level}$ 0 (low), 1 (default), or 2 (high). ### setLowStrategy(), setMediumStrategy(), setHighStrategy() ###. Methods to set specific strategy level. ### Other methods ###. In addition, methods for individual settings such as; setGradientNCycles() are provided. ## MnUserCovariance ##. [api:covariance] MnUserCovariance is the external covariance matrix; designed for the interaction of the user. The result of the minimization; (internal covariance matrix) is converted into the user representable; format. It can also be used as input prior to the minimization. The size; of the covariance matrix is according to the number of variable; parameters (free and limited). ### MnUserCovariance(const std::vector$<$double$>$&, unsigned int nrow) ###. Construct from data, positions of the elements in the array are arranged; according to the packed storage format. The size of the array must be; $nrow*(nrow+1)/2$. The array must contain the upper triangular part of; the symmetric matrix packed sequentially, column by column, so that; arr(0) contains covar(0,0), arr(1) and arr(2) contain covar(0,1) and; covar(1,1) respectively, and so on. The number of rows (columns) has to; be specified. ### MnUserCovariance(unsigned int nrow) ###. Specify the number of rows (columns) at instantiation. It will allocate; an array of the length $nrow*(nrow+1)/2$ and initialize it to $0$.; Elements can then be set using the method operator()(unsigned int,; unsigned int). ### MnUserCovariance::operator()(unsigned int, unsigned int) ###. Individual elements can be accessed via the operator(), both for reading; and writing. ## M",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:53594,Modifiability,variab,variable,53594,"of rows (columns) has to; be specified. ### MnUserCovariance(unsigned int nrow) ###. Specify the number of rows (columns) at instantiation. It will allocate; an array of the length $nrow*(nrow+1)/2$ and initialize it to $0$.; Elements can then be set using the method operator()(unsigned int,; unsigned int). ### MnUserCovariance::operator()(unsigned int, unsigned int) ###. Individual elements can be accessed via the operator(), both for reading; and writing. ## MnUserParameters ##. [api:parameters] MnUserParameters is the main class for user interaction; with the parameters. It serves both as input to the minimization as well; as output as the result of the minimization is converted into the user; representable format in order to allow for further interaction.; Parameters for M can be added (defined) specifying a name, value and; initial uncertainty. ### add(...) ###. The method MnUserParameters::add(...) is overloaded for three kind of; parameters:. - add(const char\*, double, double) for adding a free variable; parameter. - add(const char\*, double, double, double, double) for adding a; variable parameter with limits (lower and upper). - add(const char\*, double) for adding a constant parameter. When adding parameters, M assigns indices to each parameter which will; be the same as in the std::vector$<$double$>$ in the; FCNBase::operator(). That means the first parameter the user adds gets; index 0, the second index 1, and so on. When calculating the function; value inside FCN, M will call FCNBase::operator() with the elements at; their positions. ### setValue(...) ###. [api:setvalue] setValue(unsigned int parno, double value) or; setValue(const char\* name, double value) set the value of parameter; $\mbox{parno}$ or with name $\mbox{name}$ to; $\mbox{ value}$. The parameter in question may be variable, fixed,; or constant, but must be defined. ### setError(...) ###. [api:seterror] setError(unsigned int parno, double error) or; setError(const char\* name, double erro",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:53681,Modifiability,variab,variable,53681," number of rows (columns) at instantiation. It will allocate; an array of the length $nrow*(nrow+1)/2$ and initialize it to $0$.; Elements can then be set using the method operator()(unsigned int,; unsigned int). ### MnUserCovariance::operator()(unsigned int, unsigned int) ###. Individual elements can be accessed via the operator(), both for reading; and writing. ## MnUserParameters ##. [api:parameters] MnUserParameters is the main class for user interaction; with the parameters. It serves both as input to the minimization as well; as output as the result of the minimization is converted into the user; representable format in order to allow for further interaction.; Parameters for M can be added (defined) specifying a name, value and; initial uncertainty. ### add(...) ###. The method MnUserParameters::add(...) is overloaded for three kind of; parameters:. - add(const char\*, double, double) for adding a free variable; parameter. - add(const char\*, double, double, double, double) for adding a; variable parameter with limits (lower and upper). - add(const char\*, double) for adding a constant parameter. When adding parameters, M assigns indices to each parameter which will; be the same as in the std::vector$<$double$>$ in the; FCNBase::operator(). That means the first parameter the user adds gets; index 0, the second index 1, and so on. When calculating the function; value inside FCN, M will call FCNBase::operator() with the elements at; their positions. ### setValue(...) ###. [api:setvalue] setValue(unsigned int parno, double value) or; setValue(const char\* name, double value) set the value of parameter; $\mbox{parno}$ or with name $\mbox{name}$ to; $\mbox{ value}$. The parameter in question may be variable, fixed,; or constant, but must be defined. ### setError(...) ###. [api:seterror] setError(unsigned int parno, double error) or; setError(const char\* name, double error) set the error (sigma) of; parameter $\mbox{parno}$ or with name $\mbox{name}$ to; $\mbox{val",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:54401,Modifiability,variab,variable,54401,"ue and; initial uncertainty. ### add(...) ###. The method MnUserParameters::add(...) is overloaded for three kind of; parameters:. - add(const char\*, double, double) for adding a free variable; parameter. - add(const char\*, double, double, double, double) for adding a; variable parameter with limits (lower and upper). - add(const char\*, double) for adding a constant parameter. When adding parameters, M assigns indices to each parameter which will; be the same as in the std::vector$<$double$>$ in the; FCNBase::operator(). That means the first parameter the user adds gets; index 0, the second index 1, and so on. When calculating the function; value inside FCN, M will call FCNBase::operator() with the elements at; their positions. ### setValue(...) ###. [api:setvalue] setValue(unsigned int parno, double value) or; setValue(const char\* name, double value) set the value of parameter; $\mbox{parno}$ or with name $\mbox{name}$ to; $\mbox{ value}$. The parameter in question may be variable, fixed,; or constant, but must be defined. ### setError(...) ###. [api:seterror] setError(unsigned int parno, double error) or; setError(const char\* name, double error) set the error (sigma) of; parameter $\mbox{parno}$ or with name $\mbox{name}$ to; $\mbox{value}$. ### fix(...) ###. [api:fix] fix(unsigned int parno) or fix(const char\* name) fixes; parameter $\mbox{parno}$ or with name $\mbox{name}$. ### release(...) ###. [api:release] release(unsigned int parno) or release(const char\* name); releases a previously fixed parameter $\mbox{parno}$ or with name; $\mbox{name}$. ### setLimits(...) ###. [api:setlimits] setLimits(unsigned int n, double low, double up) or; setLimits(const char\* name, double low, double up) sets the lower and; upper bound of parameter $\mbox{n}$ or with name $\mbox{name}$. However, if $\mbox{low}$ is equal to $\mbox{up}$, an error; condition results. ### setUpperLimit(...) ###. [api:setupperlimits] setUpperLimit(unsigned int n, double up) or; setUpperLimit(c",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:59715,Modifiability,variab,variable,59715,"unction value, the; expected distance to the minimum and the number of function calls. ### operator$<<$(std::ostream&, const MnUserParameters&) ###. Prints out the MnUserParameters. ### operator$<<$(std::ostream&, const MnUserCovariance&) ###. Prints out the MnUserCovariance. ### operator$<<$(std::ostream&, const MnGlobalCorrelationCoeff&) ###. Prints out the MnGlobalCorrelationCoeff. ### operator$<<$(std::ostream&, const MnUserParameterState&) ###. Prints out the whole MnUserParameterState: MnUserParameters,; MnUserCovariance and MnGlobalCorrelationCoeff. ### operator$<<$(std::ostream&, const MinosError&) ###. Prints out the MinosError of a given parameter. ### operator$<<$(std::ostream&, const ContoursErros&) ###. Prints out the MinosError of the two parameters and plots a line printer; graphic of the contours on the output terminal. # How to get the right answer from M #. The goal of M — to be able to minimize and analyze parameter errors for; all possible user functions with any number of variable parameters — is; of course impossible to realise, even in principle, in a finite amount; of time. In practice, some assumptions must be made about the behaviour; of the function in order to avoid evaluating it at all possible points.; In this chapter we give some hints on how the user can help M to make; the right assumptions. ## Which minimizer to use ##. One of the historically interesting advantages of M is that it was; probably the first minimization program to offer the user a choice of; several minimization algorithms. This could be taken as a reflection of; the fact that none of the algorithms known at that time were good enough; to be universal, so users were encouraged to find the one that worked; best for them. Since then, algorithms have improved considerably, but M; still offers several, mostly so that old users will not feel cheated,; but also to help the occasional user who does manage to defeat the best; algorithms. M currently offers four applications wh",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:61006,Modifiability,variab,variable-metric,61006," minimizer to use ##. One of the historically interesting advantages of M is that it was; probably the first minimization program to offer the user a choice of; several minimization algorithms. This could be taken as a reflection of; the fact that none of the algorithms known at that time were good enough; to be universal, so users were encouraged to find the one that worked; best for them. Since then, algorithms have improved considerably, but M; still offers several, mostly so that old users will not feel cheated,; but also to help the occasional user who does manage to defeat the best; algorithms. M currently offers four applications which can be used to; find a smaller function value, in addition to $\mbox{MINOS}$, which; will retain a smaller function value if it stumbles on one unexpectedly.; The objects which can be used to minimize are:. ### $\mbox{MIGRAD}$ ###. This is the best minimizer for nearly all functions. It is a; variable-metric method with inexact line search, a stable metric; updating scheme, and checks for positive-definiteness. It will run; faster if you instantiate it with a low–level MnStrategy and will be; more reliable if you instantiate it with a high–level MnStrategy; (although the latter option may not help much). Its main weakness is; that it depends heavily on knowledge of the first derivatives, and fails; miserably if they are very inaccurate. If first derivatives are a; problem, they can be calculated analytically inside $\mbox{FCN}$; (see [howto:fcn]) or if this is not feasible, the user can try to; improve the accuracy of M 's numerical approximation by adjusting values; of MnMachinePrecision and/or MnStrategy (see [api:epsmac] and; [api:strategy]). ### $\mbox{MINIMIZE}$ ###. This is equivalent to $\mbox{MIGRAD}$, except that if; $\mbox{MIGRAD}$ fails, it reverts to $\mbox{SIMPLEX}$ and then; calls $\mbox{MIGRAD}$ again. ### $\mbox{SCAN}$ ###. This is not intended to minimize, and just scans the function, one; parameter at a time. ",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:74804,Modifiability,variab,variables,74804,"s only one of precision, and not of word length; mismatch, an appropriate MnMachinePrecision::setPrecision() may fix; it. - **Trivial bugs in $\mbox{FCN}$.** The possibilities for bugs are; numerous. Probably the most common among physicists inexperienced in; is the confusion between double and int types, which you can; sometimes get away with, but not always. [^3] M can spot some; trivial bugs itself, and issues a warning when it detects an unusual; $\mbox{FCN}$ behaviour. Such a warning should be taken; seriously. M also offers some tools (especially $\mbox{SCAN}$) which can; help the user to find trivial bugs. - **An ill–posed problem.** For questions of parameter dependence, see; the discussion above on postive–definiteness. Other mathematical; problems which can arise are: **excessive numerical roundoff** — be; especially careful of exponential and factorial functions which get; big very quickly and lose accuracy; **starting too far from the; solution** — the function may have unphysical local minima,; especially at infinity in some variables; **incorrect; normalization** — in likelihood functions, the probability; distributions must be normalized or at least have an integral which; is independent of the values of the variable parameters. - **A bug in M .** This is unlikely, but it happens. If a bug is; suspected, and all other possible causes can be eliminated, please; try to save a copy of the input and output files, listing of; $\mbox{FCN}$, and other information that may be relevant, and; send them to $\mbox{fred.james@cern.ch}$. # A complete example #. [example:example]. Here a full example of a fit is presented, following the example; DemoGaussSim.cpp. ## The user's $\mbox{FCN}$ ##. The implementation of FCNBase by the user's GaussFcn is shown here. ### GaussFunction.h ###. The user's model function is a Gaussian. #ifndef MN_GaussFunction_H_; #define MN_GaussFunction_H_. #include <math.h>. class GaussFunction {. public:. GaussFunction(double mean, double s",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:74993,Modifiability,variab,variable,74993,"s only one of precision, and not of word length; mismatch, an appropriate MnMachinePrecision::setPrecision() may fix; it. - **Trivial bugs in $\mbox{FCN}$.** The possibilities for bugs are; numerous. Probably the most common among physicists inexperienced in; is the confusion between double and int types, which you can; sometimes get away with, but not always. [^3] M can spot some; trivial bugs itself, and issues a warning when it detects an unusual; $\mbox{FCN}$ behaviour. Such a warning should be taken; seriously. M also offers some tools (especially $\mbox{SCAN}$) which can; help the user to find trivial bugs. - **An ill–posed problem.** For questions of parameter dependence, see; the discussion above on postive–definiteness. Other mathematical; problems which can arise are: **excessive numerical roundoff** — be; especially careful of exponential and factorial functions which get; big very quickly and lose accuracy; **starting too far from the; solution** — the function may have unphysical local minima,; especially at infinity in some variables; **incorrect; normalization** — in likelihood functions, the probability; distributions must be normalized or at least have an integral which; is independent of the values of the variable parameters. - **A bug in M .** This is unlikely, but it happens. If a bug is; suspected, and all other possible causes can be eliminated, please; try to save a copy of the input and output files, listing of; $\mbox{FCN}$, and other information that may be relevant, and; send them to $\mbox{fred.james@cern.ch}$. # A complete example #. [example:example]. Here a full example of a fit is presented, following the example; DemoGaussSim.cpp. ## The user's $\mbox{FCN}$ ##. The implementation of FCNBase by the user's GaussFcn is shown here. ### GaussFunction.h ###. The user's model function is a Gaussian. #ifndef MN_GaussFunction_H_; #define MN_GaussFunction_H_. #include <math.h>. class GaussFunction {. public:. GaussFunction(double mean, double s",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:83876,Modifiability,variab,variable,83876,": ""; <<min.userState().value(1); <<"" ""<<e1.first<<"" ""<<e1.second<<std::endl;; std::cout<<""par2: ""; <<min.userState().value(""area""); <<"" ""<<e2.first<<"" ""<<e2.second<<std::endl;; }; }. {; // demonstrate how to use the CONTOURs. // create Minuit parameters with names; MnUserParameters upar;; upar.add(""mean"", mean, 0.1);; upar.add(""sigma"", rms, 0.1);; upar.add(""area"", area, 0.1);. // create Migrad minimizer; MnMigrad migrad(theFCN, upar);. // minimize; FunctionMinimum min = migrad();. // create contours factory with FCN and minimum; MnContours contours(theFCN, min);. // 70% confidence level for 2 parameters contour; // around the minimum; theFCN.setErrorDef(2.41);; std::vector<std::pair<double,double> > cont =; contours(0, 1, 20);. // 95% confidence level for 2 parameters contour; theFCN.setErrorDef(5.99);; std::vector<std::pair<double,double> > cont4 =; contours(0, 1, 20);. // plot the contours; MnPlot plot;; cont4.insert(cont4.end(), cont.begin(), cont.end());; plot(min.userState().value(""mean""),; min.userState().value(""sigma""),; cont4);; }. return 0;; };; ```. [^1]: ROOT @bib-ROOT uses its own version of the Fortran M when this; manual was written. However an interface for this version exists and; the library can be loaded dynamically on demand. [^2]: The *internal error matrix* maintained by M is transformed for the; user into *external coordinates*, but the numbering of rows and; columns is of course still according to internal parameter; numbering, since one does not want rows and columns corresponding to; parameters which are not variable. The transformation therefore; affects only parameters with limits; if there are no limits,; internal and external error matrices are the same. [^3]: For example, if $\mbox{a}$ and $\mbox{b}$ are double; precision variables, the statement $\mbox{a = 2*b}$ is not good; programming, but happens to do what the user probably intended,; whereas the statement $\mbox{a = b + 2/3}$ almost certainly will; not do what the user intended.; ",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:84099,Modifiability,variab,variables,84099,": ""; <<min.userState().value(1); <<"" ""<<e1.first<<"" ""<<e1.second<<std::endl;; std::cout<<""par2: ""; <<min.userState().value(""area""); <<"" ""<<e2.first<<"" ""<<e2.second<<std::endl;; }; }. {; // demonstrate how to use the CONTOURs. // create Minuit parameters with names; MnUserParameters upar;; upar.add(""mean"", mean, 0.1);; upar.add(""sigma"", rms, 0.1);; upar.add(""area"", area, 0.1);. // create Migrad minimizer; MnMigrad migrad(theFCN, upar);. // minimize; FunctionMinimum min = migrad();. // create contours factory with FCN and minimum; MnContours contours(theFCN, min);. // 70% confidence level for 2 parameters contour; // around the minimum; theFCN.setErrorDef(2.41);; std::vector<std::pair<double,double> > cont =; contours(0, 1, 20);. // 95% confidence level for 2 parameters contour; theFCN.setErrorDef(5.99);; std::vector<std::pair<double,double> > cont4 =; contours(0, 1, 20);. // plot the contours; MnPlot plot;; cont4.insert(cont4.end(), cont.begin(), cont.end());; plot(min.userState().value(""mean""),; min.userState().value(""sigma""),; cont4);; }. return 0;; };; ```. [^1]: ROOT @bib-ROOT uses its own version of the Fortran M when this; manual was written. However an interface for this version exists and; the library can be loaded dynamically on demand. [^2]: The *internal error matrix* maintained by M is transformed for the; user into *external coordinates*, but the numbering of rows and; columns is of course still according to internal parameter; numbering, since one does not want rows and columns corresponding to; parameters which are not variable. The transformation therefore; affects only parameters with limits; if there are no limits,; internal and external error matrices are the same. [^3]: For example, if $\mbox{a}$ and $\mbox{b}$ are double; precision variables, the statement $\mbox{a = 2*b}$ is not good; programming, but happens to do what the user probably intended,; whereas the statement $\mbox{a = b + 2/3}$ almost certainly will; not do what the user intended.; ",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:4001,Performance,perform,performance,4001,"parameters, that is, find those values of the coefficients which; give the lowest value of chisquare. The user must therefore supply, in addition to the function to be; analyzed, via a set or sequence of M applications the instructions which; analysis is wanted. The instructions are coded in in the calling program; (main.cpp), which allows looping, conditional execution, and all the; other possibilities of , but not interactivity, since it must be; compiled before execution. ## Design aspects of M in ##. What M is:. - platform independent. - written in an object-oriented way using standard. - independent of any external package. The maintainability should be guaranteed with the choice of a modern; computer language. Choosing object-oriented technology M should profit; from an increased flexibility and functionality and make it also; extendable (recursiveness, new algorithms, new functionality). What M does not:. - histogramming. - data handling. - graphics. M is kept as a low-level package with optimal performance. The main usages of M are. - from a user's program (such as int main()...). - from a graphical data analysis tool such as HippoDraw@bib-HippoDraw. The most important goals of M in are. - its numerical accuracy (equivalent to its Fortran version). - its computational performance (equivalent to its Fortran version). For the design of the application programming interface (API) of M a; two-way strategy was imposed:. - a minimal required interface with minimum interaction with M objects; and with appropriate usage of the standard library (STL): the user's; implementation of the FCNBase class, initial parameter values and; uncertainties are provided by the to M user via std::vectors. - a rich interface which provides the user with more functionality; such as interaction with parameters. The core of the minimization functionality and related tools (the kernel; of M ) should be clearly separated from the user, who is interfacing via; defined user interfaces (the A",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:4280,Performance,perform,performance,4280,"ogram; (main.cpp), which allows looping, conditional execution, and all the; other possibilities of , but not interactivity, since it must be; compiled before execution. ## Design aspects of M in ##. What M is:. - platform independent. - written in an object-oriented way using standard. - independent of any external package. The maintainability should be guaranteed with the choice of a modern; computer language. Choosing object-oriented technology M should profit; from an increased flexibility and functionality and make it also; extendable (recursiveness, new algorithms, new functionality). What M does not:. - histogramming. - data handling. - graphics. M is kept as a low-level package with optimal performance. The main usages of M are. - from a user's program (such as int main()...). - from a graphical data analysis tool such as HippoDraw@bib-HippoDraw. The most important goals of M in are. - its numerical accuracy (equivalent to its Fortran version). - its computational performance (equivalent to its Fortran version). For the design of the application programming interface (API) of M a; two-way strategy was imposed:. - a minimal required interface with minimum interaction with M objects; and with appropriate usage of the standard library (STL): the user's; implementation of the FCNBase class, initial parameter values and; uncertainties are provided by the to M user via std::vectors. - a rich interface which provides the user with more functionality; such as interaction with parameters. The core of the minimization functionality and related tools (the kernel; of M ) should be clearly separated from the user, who is interfacing via; defined user interfaces (the API). ## Internal and external parameters ##. Each of the parameters to the $\mbox{FCN}$ is defined by the user as; belonging to one of the following types:. - Freely variable: allowed to take on any value. - Variable with double sided limits: allowed to vary only between two; limits specified by the user. - V",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:10798,Performance,perform,perform,10798,"P_{\mathrm{ext}} - a + 1)^2 - 1} \\; P_{\mathrm{ext}} &=& a - 1 + \sqrt{P_{\mathrm{int}}^2 + 1} \end{aligned}$$. Upper bound $b$:. $$\begin{aligned}; P_{\mathrm{int}} &=& \pm\sqrt{(b - P_{\mathrm{ext}} + 1)^2 - 1} \\; P_{\mathrm{ext}} &=& b + 1 - \sqrt{P_{\mathrm{int}}^2 + 1} \end{aligned}$$. The transformation of course also affects the parameter error matrix, so; M does a transformation of the error matrix (and the ""parabolic""; parameter errors) when there are parameter limits. Users should however; realize that the transformation is only a linear approximation, and that; it cannot give a meaningful result if one or more parameters is very; close to a limit, where; $\partial P_{\mathrm{ext}} / \partial P_{\mathrm{int}} \approx 0$.; Therefore, it is recommended that:. - Limits on variable parameters should be used only when needed in; order to prevent the parameter from taking on unphysical values. - When a satisfactory minimum has been found using limits, the limits; should then be removed if possible, in order to perform or; re-perform the error analysis without limits. Further discussion of the effects of parameter limits may be found in; the last chapter. ## M strategy ##. At many places in the analysis of the $\mbox{FCN}$ (the user; provided function), M must decide whether to be ""safe"" and waste a few; function calls in order to know where it is, or to be ""fast"" and attempt; to get the requested results with the fewest possible calls at a certain; risk of not obtaining the precision desired by the user. In order to; allow the user to influence these decisions, there is a M class; MnStrategy (see [api:strategy]) which the user can use to put different; settings. In the current release, this MnStrategy can be instantiated; with three different minimization quality levels for low (0), medium (1); and high (2) quality. Default settings for iteration cycles and; tolerances are initialized then. The default setting is set for medium; quality. Value 0 (low) indicates",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:10813,Performance,perform,perform,10813,"P_{\mathrm{ext}} - a + 1)^2 - 1} \\; P_{\mathrm{ext}} &=& a - 1 + \sqrt{P_{\mathrm{int}}^2 + 1} \end{aligned}$$. Upper bound $b$:. $$\begin{aligned}; P_{\mathrm{int}} &=& \pm\sqrt{(b - P_{\mathrm{ext}} + 1)^2 - 1} \\; P_{\mathrm{ext}} &=& b + 1 - \sqrt{P_{\mathrm{int}}^2 + 1} \end{aligned}$$. The transformation of course also affects the parameter error matrix, so; M does a transformation of the error matrix (and the ""parabolic""; parameter errors) when there are parameter limits. Users should however; realize that the transformation is only a linear approximation, and that; it cannot give a meaningful result if one or more parameters is very; close to a limit, where; $\partial P_{\mathrm{ext}} / \partial P_{\mathrm{int}} \approx 0$.; Therefore, it is recommended that:. - Limits on variable parameters should be used only when needed in; order to prevent the parameter from taking on unphysical values. - When a satisfactory minimum has been found using limits, the limits; should then be removed if possible, in order to perform or; re-perform the error analysis without limits. Further discussion of the effects of parameter limits may be found in; the last chapter. ## M strategy ##. At many places in the analysis of the $\mbox{FCN}$ (the user; provided function), M must decide whether to be ""safe"" and waste a few; function calls in order to know where it is, or to be ""fast"" and attempt; to get the requested results with the fewest possible calls at a certain; risk of not obtaining the precision desired by the user. In order to; allow the user to influence these decisions, there is a M class; MnStrategy (see [api:strategy]) which the user can use to put different; settings. In the current release, this MnStrategy can be instantiated; with three different minimization quality levels for low (0), medium (1); and high (2) quality. Default settings for iteration cycles and; tolerances are initialized then. The default setting is set for medium; quality. Value 0 (low) indicates",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:14367,Performance,perform,perform,14367,"at the user knows what the normalization of their; $\mbox{FCN}$ means, and also that they are interested in parameter; errors, the user can change the error definition which allows them to; define what they means by one ""error"", in terms of the change in the; $\mbox{FCN}$ value which should be caused by changing one parameter; by one ""error"". If the $\mbox{FCN}$ is the usual chisquare function; (defined below) and if the user wants the usual one-standard-deviation; errors, then the error definition (return value of the FCNBase::up(); method, see [howto:errordef]) should be $1.0$. If the $\mbox{FCN}$; is a negative-log-likelihood function, then the one-standard-deviation; value for FCNBase::up() to return is $0.5$. If the $\mbox{FCN}$ is a; chisquare, but the user wants two-standard-deviation errors, then; FCNBase::up() should return $= 4.0$, etc. Note that in the usual case where M is being used to perform a fit to; some experimental data, the parameter errors will be proportional to the; uncertainty in the data, and therefore meaningful parameter errors; cannot be obtained unless the measurement errors of the data are known.; In the common case of a least-squares fit, $\mbox{FCN}$ is usually; defined as a chisquare:. $$\chi^2 (\alpha) = \sum_{i=1}^{n} (\frac{f(x_i,\alpha) - m_i)^2}{\sigma_i^2}$$. where $\alpha$ is the vector of free parameters being fitted, and the; $\sigma_i$ are the uncertainties in the individual measurements $m_i$.; If these uncertainties are not known, and are simply left out of the; calculation, then the fit may still have meaning, but not the; quantitative values of the resulting parameter errors. (Only the; relative errors of different parameters with respect to each other may; be meaningful.). If the $\sigma_i$ are all overestimated by a factor $\beta$, then the; resulting parameter errors from the fit will be overestimated by the; same factor $\beta$. ### The error matrix ###. The M processors $\mbox{MIGRAD}$ (MnMigrad, see [api:migrad]) a",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:25505,Performance,perform,performance-optimized,25505,"e sources are checked out from the CVS code repository,. 1. change to the directory:. $ cd MathLibs/Minuit. 2. run autogen:. $ ./autogen. 3. create a new directory:. $ cd ..; $ mkdir Minuit-BUILD; $ cd Minuit-BUILD/. 4. run configure:. $ ../Minuit/configure. 5. create the tar.gz:. $ make dist. This will create a Minuit-x.x.x.tar.gz which can be distributed and used; as described above. ## M versions ##. The version numbers of M follow the release numbers of the SEAL project; @bib-SEAL at CERN @bib-CERN. ### From to ###. The program is entirely written in standard portable . M does not depend; on any external library. In its minimal usage the user must only provide; an implementation of the FCNBase class to M and parameters and; uncertainties in form of std::vector containers. ### Memory allocation and thread safety ###. Differently to the version of M , the version has its own memory manager; (StackAllocator. The user can select between the standard dynamic memory; allocation and deallocation (default) and performance-optimized; stack–like allocation (optional). However, the library is not thread; save using stack–allocation. ### M parameters ###. Differently to the version of M there is no limit on the number of; parameters, variable or non-variable. Memory allocation is done; dynamically according to the actual needs and ""on demand"". There is no; protection against an upper limit on the number of parameters, however; the ""technological"" limitations of M can be seen around a maximum of 15; free parameters at a time. ## Interference with other packages ##. The new M has been designed to interfere as little as possible with; other programs or packages which may be loaded at the same time. M is; thread safe by default. Optionally the user can select a different way; of dynamically allocating memory in the class StackAllacator for M , in; which case (and after an entire recompilation of the whole library) the; thread safety is lost. ## Floating-point precision ##. [ins",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:26175,Performance,load,loaded,26175," user must only provide; an implementation of the FCNBase class to M and parameters and; uncertainties in form of std::vector containers. ### Memory allocation and thread safety ###. Differently to the version of M , the version has its own memory manager; (StackAllocator. The user can select between the standard dynamic memory; allocation and deallocation (default) and performance-optimized; stack–like allocation (optional). However, the library is not thread; save using stack–allocation. ### M parameters ###. Differently to the version of M there is no limit on the number of; parameters, variable or non-variable. Memory allocation is done; dynamically according to the actual needs and ""on demand"". There is no; protection against an upper limit on the number of parameters, however; the ""technological"" limitations of M can be seen around a maximum of 15; free parameters at a time. ## Interference with other packages ##. The new M has been designed to interfere as little as possible with; other programs or packages which may be loaded at the same time. M is; thread safe by default. Optionally the user can select a different way; of dynamically allocating memory in the class StackAllacator for M , in; which case (and after an entire recompilation of the whole library) the; thread safety is lost. ## Floating-point precision ##. [install:epsmac]. M is entirely based on double precision. The actual floating point; precision of double precision (32–bit or 64–bit) is platform dependent; and can even vary on the same platform, depending on whether a floating; point number is read from memory a CPU register. The argument of the user's implementation of FCNBase::operator() is; therefore a std:vector$<$double$>$. M expects that the calculations; inside $\mbox{FCN}$ will be performed approximately to the same; accuracy. The accuracy M expects is called *machine precision*; (MnMachinePrecision, see [api:epsmac]) and can be printed on demand; using std::cout. If the user fools M ",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:26925,Performance,perform,performed,26925,"however; the ""technological"" limitations of M can be seen around a maximum of 15; free parameters at a time. ## Interference with other packages ##. The new M has been designed to interfere as little as possible with; other programs or packages which may be loaded at the same time. M is; thread safe by default. Optionally the user can select a different way; of dynamically allocating memory in the class StackAllacator for M , in; which case (and after an entire recompilation of the whole library) the; thread safety is lost. ## Floating-point precision ##. [install:epsmac]. M is entirely based on double precision. The actual floating point; precision of double precision (32–bit or 64–bit) is platform dependent; and can even vary on the same platform, depending on whether a floating; point number is read from memory a CPU register. The argument of the user's implementation of FCNBase::operator() is; therefore a std:vector$<$double$>$. M expects that the calculations; inside $\mbox{FCN}$ will be performed approximately to the same; accuracy. The accuracy M expects is called *machine precision*; (MnMachinePrecision, see [api:epsmac]) and can be printed on demand; using std::cout. If the user fools M by making internal $\mbox{FCN}$; computations in single precision, M will interpret roundoff noise as; significant and will usually either fail to find a minimum, or give; incorrect values for the parameter errors. It is therefore recommended to make sure that all computations in; $\mbox{FCN}$, as well as all methods and functions called by; $\mbox{FCN}$, are done in double precision. If for some reason the; computations cannot be done to a precision comparable with that expected; by M , the user **must** inform M of this situation with setting a; different machine precision via the; MnMachinePrecision::setPrecision(double) method. With reduced precision, the user may find that certain features; sensitive to first and second differences ($\mbox{HESSE}$,; $\mbox{MINOS}$, $\mb",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:27994,Performance,perform,performed,27994,"inside $\mbox{FCN}$ will be performed approximately to the same; accuracy. The accuracy M expects is called *machine precision*; (MnMachinePrecision, see [api:epsmac]) and can be printed on demand; using std::cout. If the user fools M by making internal $\mbox{FCN}$; computations in single precision, M will interpret roundoff noise as; significant and will usually either fail to find a minimum, or give; incorrect values for the parameter errors. It is therefore recommended to make sure that all computations in; $\mbox{FCN}$, as well as all methods and functions called by; $\mbox{FCN}$, are done in double precision. If for some reason the; computations cannot be done to a precision comparable with that expected; by M , the user **must** inform M of this situation with setting a; different machine precision via the; MnMachinePrecision::setPrecision(double) method. With reduced precision, the user may find that certain features; sensitive to first and second differences ($\mbox{HESSE}$,; $\mbox{MINOS}$, $\mbox{CONTOURS}$) do not work properly, in; which case the calculations must be performed in higher precision. # How to use M #. [howto:howto]. ## The $\mbox{FCN}$ Function ##. [howto:fcn]. The user must always implement a derived class of FCNBase (the; ""$\mbox{FCN}$"") which calculates the function value to be minimized; or analyzed. ![](figures/fcnbase.png). Note that when M is being used through an intermediate package such as; HippoDraw @bib-HippoDraw, then the user's $\mbox{FCN}$ may be; supplied by the this package. The name of the user's class to implement the FCNBase interface may be; chosen freely (in documentation we give it the generic name; $\mbox{FCN}$). ### FCNBase::operator()(const std::vector$<$double$>$&) ###. The meaning of the vector of parameters std::vector$<$double$>$ in the; argument of FCNBase::operator() are of course defined by the user, who; uses the values of those parameters to calculate their function value. The; order and the position of th",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:29318,Performance,perform,performs,29318,"ough an intermediate package such as; HippoDraw @bib-HippoDraw, then the user's $\mbox{FCN}$ may be; supplied by the this package. The name of the user's class to implement the FCNBase interface may be; chosen freely (in documentation we give it the generic name; $\mbox{FCN}$). ### FCNBase::operator()(const std::vector$<$double$>$&) ###. The meaning of the vector of parameters std::vector$<$double$>$ in the; argument of FCNBase::operator() are of course defined by the user, who; uses the values of those parameters to calculate their function value. The; order and the position of these parameters is strictly the one specified; by the user when supplying the starting values for minimization. The starting values must be specified by the user, either via an; std::vector$<$double$>$ or the MnUserParameters (see [api:parameters]); supplied as input to the M minimizers such as VariableMetricMinimizer or; MnMigrad (see [api:migrad]). Later values are determined by M as it; searches for the minimum or performs whatever analysis is requested by; the user. ### FCNBase::up() ###. [howto:errordef] Returns the value of $\mbox{up}$ (default value; $= 1.$), defining parameter errors. M defines parameter errors as the; change in parameter value required to change the function value by; $\mbox{up}$. Normally, for chisquared fits $\mbox{up = 1}$, and; for negative log likelihood, $\mbox{up = 0.5}$. ### $\mbox{FCN}$ function with gradient ###. By default first derivatives are calculated numerically by M . In case; the user wants to supply their own gradient calculator (e.g. analytical; derivatives), they need to implement the FCNGradientBase interface. ![](figures/fcngradientbase.png). The size of the output vector is the same as of the input one. The same; is true for the position of the elements (first derivative of the; function with respect to the $n_\mathrm{th}$ variable has index $n$ in; the output vector). ## M parameters ##. Interaction with the parameters of the function are e",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:33830,Performance,perform,performed,33830,"name, value, uncertainty. Once; all parameters are added to MnUserParameters, they can fix a parameter or; put limits on another one before handing them over to Minuit for; minimization. ### What the user can supply ###. Optionally the user can supply their own gradient calculator by; implementing the FCNGradientBase interface or supply a full covariance; matrix for input if one is available. The covariance matrix can be; supplied in form of a std::vector$<$double$>$ in packed storage format; (upper triangular), or in a more user-friendly way by using the; interface provided by the MnUserCovariance. ## Running a M minimization ##. Two use cases are addressed for minimization:. - The user just wants the function to be minimized in one go. - The user wants to minimize the $\mbox{FCN}$ in several; minimization steps, re-using the result of the preceeding; minimization in the next step and change parameters in between; (fix/release/put limits on them, etc.). How M minimizations can be performed is shown in [example:main]. ### Direct usage of minimizers ###. Minimizers such as the VariableMetricMinimizer are designed as; state-less minimization engines, which means that they do not depend on; the current function and its parameters. Any $\mbox{FCN}$ function; can be minimized with the same minimizer. The interface is restricted to; minimization and no parameter interaction is possible. ### Using an application (MnMigrad) ###. MnMigrad uses the VariableMetricMinimizer for minimization but allows as; well for parameter interaction by the user. An instance of MnMigrad is; specific to the current $\mbox{FCN}$ and user parameters. Any; parameter interaction of the user between two minimization steps will; make use of the result of the preceeding minimization in an optimal way.; The interface for parameters (see [api:parameters], [api:covariance] and; [api:state]) is forwardedin MnMigrad. ### Subsequent minimizations ###. M takes care that all information is treated in an optim",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:40171,Performance,perform,perform,40171," parameters (if any). M will try to find; $\mbox{npoints}$ points on the contour (default 20). To calculate; more than one contour, the user needs to set the error definition; [howto:errordef] in its $\mbox{FCN}$ to the appropriate value for; the desired confidence level and call the method MnContours::operator(); for each contour. ### contour(...) ###. MnContours::contour(unsigned int parx, unsigned int pary, unsigned int; npoints = 20) causes a $\mbox{CONTOURS}$ error analysis and returns; the result in form of ContoursError. As a by-product ContoursError keeps; the MinosError information of parameters $\mbox{parx}$ and; $\mbox{pary}$. The result ContoursError can be easily printed using; std::cout. ## MnEigen ##. [api:eigen] MnEigen calculates and the eigenvalues of the user; covariance matrix MnUserCovariance. ### MnEigen() ###. MnEigen is instantiated via default constructor. ### operator() ###. operator()(const MnUserCovariance&) const will perform the calculation; of the eigenvalues of the covariance matrix and return the result in; form of a std::vector\<double\>. The eigenvalues are ordered from the; smallest first to the largest eigenvalue. ## MnHesse ##. [api:hesse]. With MnHesse the user can instructs M to calculate, by finite; differences, the Hessian or error matrix. That is, it calculates the; full matrix of second derivatives of the function with respect to the; currently variable parameters, and inverts it. ### MnHesse() ###. The default constructor of MnHesse() will use default settings of; MnStrategy. Other constructors with user specific MnStrategy settings; are provided as well. ### operator() ###. The MnHesse::operator() is overloaded both for internal (M ) and; external (user) parameters. External parameters can be specified as; std::vector$<$double$>$ or as MnUserParameters. The return value is; always a MnUserParameterState. The optional argument $\mbox{maxcalls}$ specifies the (approximate); maximum number of function calls after which the c",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:45074,Performance,perform,performed,45074,"ards the interface. ### VariableMetricMinimizer() ###. The VariableMetricMinimizer is instantiated using default constructor. ### minimize(const FCNBase&, ...) ###. The VariableMetricMinimizer provides several overloaded methods minimize; with return value FunctionMinimum. Together with the user; $\mbox{FCN}$ (either an implementation of FCNBase or; FCNGradientBase) the user has to give as input the parameters with; starting values in one of the defined formats (std::vector$<$double$>$,; MnUserParameters or MnUserParameterState). ## MnMinimize and CombinedMinimizer ##. [api:minimize]. Causes minimization of the function by the method of; $\mbox{MIGRAD}$, as does the MnMigrad class, but switches to the; $\mbox{SIMPLEX}$ method if $\mbox{MIGRAD}$ fails to converge.; Constructor arguments, methods arguments and names of methods are the; same as for MnMigrad or MnSimplex and VariableMetricMinimizer or; SimplexMinimizer. ## MnMinos ##. [api:minos] Causes a $\mbox{MINOS}$ error analysis to be performed; on the parameter whose number is specified. $\mbox{MINOS}$ errors; may be expensive to calculate, but are very reliable since they take; account of non-linearities in the problem as well as parameter; correlations, and are in general asymmetric. The optional argument; $\mbox{maxcalls}$ specifies the (approximate) maximum number of; function calls **per parameter requested**, after which the calculation; will be stopped for that parameter. ### MnMinos(const FCNBase&, const FunctionMinimum&) ###. Construct an MnMinos object from the user's $\mbox{FCN}$ and a valid; FunctionMinimum. Additional constructors for user specific MnStrategy; settings are provided. ### operator() ###. MnMinos::operator()(unsigned int n, unsigned int maxcalls) causes a; $\mbox{MINOS}$ error analysis for external parameter $\mbox{n}$.; The return value is a std::pair$<$double,double$>$ with the lower and; upper bounds of parameter $\mbox{n}$. ### minos(unsigned int n, unsigned int maxcalls) ###. MnMin",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:83552,Performance,load,loaded,83552,": ""; <<min.userState().value(1); <<"" ""<<e1.first<<"" ""<<e1.second<<std::endl;; std::cout<<""par2: ""; <<min.userState().value(""area""); <<"" ""<<e2.first<<"" ""<<e2.second<<std::endl;; }; }. {; // demonstrate how to use the CONTOURs. // create Minuit parameters with names; MnUserParameters upar;; upar.add(""mean"", mean, 0.1);; upar.add(""sigma"", rms, 0.1);; upar.add(""area"", area, 0.1);. // create Migrad minimizer; MnMigrad migrad(theFCN, upar);. // minimize; FunctionMinimum min = migrad();. // create contours factory with FCN and minimum; MnContours contours(theFCN, min);. // 70% confidence level for 2 parameters contour; // around the minimum; theFCN.setErrorDef(2.41);; std::vector<std::pair<double,double> > cont =; contours(0, 1, 20);. // 95% confidence level for 2 parameters contour; theFCN.setErrorDef(5.99);; std::vector<std::pair<double,double> > cont4 =; contours(0, 1, 20);. // plot the contours; MnPlot plot;; cont4.insert(cont4.end(), cont.begin(), cont.end());; plot(min.userState().value(""mean""),; min.userState().value(""sigma""),; cont4);; }. return 0;; };; ```. [^1]: ROOT @bib-ROOT uses its own version of the Fortran M when this; manual was written. However an interface for this version exists and; the library can be loaded dynamically on demand. [^2]: The *internal error matrix* maintained by M is transformed for the; user into *external coordinates*, but the numbering of rows and; columns is of course still according to internal parameter; numbering, since one does not want rows and columns corresponding to; parameters which are not variable. The transformation therefore; affects only parameters with limits; if there are no limits,; internal and external error matrices are the same. [^3]: For example, if $\mbox{a}$ and $\mbox{b}$ are double; precision variables, the statement $\mbox{a = 2*b}$ is not good; programming, but happens to do what the user probably intended,; whereas the statement $\mbox{a = b + 2/3}$ almost certainly will; not do what the user intended.; ",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:796,Safety,detect,detector,796,"; # Foreword #. ## What M is intended to do ##. M is conceived as a tool to find the minimum value of a multi-parameter; function (the ""$\mbox{FCN}$"") and analyze the shape of the function; around the minimum. The principal application is foreseen for; statistical analysis, working on chisquare or log-likelihood functions,; to compute the best-fit parameter values and uncertainties, including; correlations between the parameters. It is especially suited to handle; difficult problems, including those which may require guidance in order; to find the correct solution. ## What M is not intended to do ##. Although M will of course solve easy problems faster than complicated; ones, it is not intended for the repeated solution of identically; parametrized problems (such as track fitting in a detector) where a; specialized program will in general be much more efficient. ## Further remarks ##. M was initially written in Fortran around 1975-1980 at CERN by Fred; James @bib-MINUIT. Its main field of usage is statistical data analysis; of experimental data recorded at CERN, but it is also used by people; doing data analysis outside CERN or outside high energy physics (HEP).; In 2002 Fred James started a project aiming to re-implement M in an; object-oriented way using . More information about recent developments, releases and installation; can be obtained from the M homepage @bib-C++MINUIT. The names of M applications are written in capital letters (e.g.; $\mbox{MIGRAD}$, $\mbox{MINOS}$, $\mbox{CONTOURS}$), the; corresponding names of the classes are written using sans-serif font; type (MnMigrad, MnMinos, MnContours). # Introduction: M basic concepts #. [sec:intro]. ## The organization of M ##. The M package acts on a multiparameter *objective function* which is; called — for historical reasons — the $\mbox{FCN}$ function (see; [howto:fcn]). This function is usually a chisquared or a log–likelihood,; but it could also be a mathematical function. The $\mbox{FCN}$; function needs ",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:6522,Safety,avoid,avoid,6522,"he parameter had at the moment it was fixed, or a value later; assigned by the user. - Constant: taking on only one value as specified by the user. When using the minimal required interface, all variable parameters are; free and unbound. The user, in their $\mbox{FCN}$, must of course be able to ""see"" all; types of defined parameters, and they therefore have access to what we call; the *external parameter list*, that is, the parameters as he defined; them. On the other hand, the internal M minimizing routines only want to; ""see"" variable parameters without limits, and so they have access only; to the *internal parameter list* which is created from the external list; by the following transformation:. - Squeeze out all parameters that are not variable. - Transform all variable parameters with limits, so that the; transformed parameter can vary without limits. (See the next section; for details concerning this transformation.) Because this; transformation is non-linear, it is recommended to avoid putting; limits on parameters where they are not needed. As an example, suppose that the user has defined the following; parameters:. - Parameter 0, constant. - Parameter 1, freely variable. - Parameter 2, variable with limits. - Parameter 3, constant. - Parameter 4, freely variable. Then the internal parameter list would be as follows:. - Internal parameter 0 = external parameter 1. - Internal parameter 1 = external parameter 2, transformed; appropriately. - Internal parameter 2 = external parameter 4. In the above example, M considers that the number of external parameters; is 5, and the number of internal parameters is 3. This is the number; which determines, for example, the size of the error matrix of the; parameters, since only variable parameters have errors. An important feature of M is that parameters are allowed to change types; during the M minimization and analysis of a $\mbox{FCN}$ function.; Several applications in M have methods available to make variable; parame",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:8846,Safety,avoid,avoided,8846,"re variable parameters; to be temporarily fixed during the calculation. Therefore, the; correspondence between external and internal parameter lists is in; general a dynamic one, and the number of internal parameters is not; necessarily constant. For more details about parameter interaction see [api:parameters]. ### The transformation for parameters with limits ###. [intro:limits]. For variable parameters with double sided limits $a$ (lower) and $b$; (upper), M uses the following transformation:. $$\begin{aligned}; P_{\mathrm{int}} &=& \arcsin; \left( 2\: \frac{ P_{\mathrm{ext}}-a}{ b-a} - 1 \right) \\; P_{\mathrm{ext}} &=& a + \frac{ b - a}{ 2}; \left( \sin P_{\mathrm{int}} + 1 \right) \end{aligned}$$. so that the internal value $P_{\mathrm{int}}$ can take on any value,; while the external value $P_{\mathrm{ext}}$ can take on values only; between the lower limit $a$ and the upper limit $b$. Since the; transformation is necessarily non-linear, it would transform a nice; linear problem into a nasty non-linear one, which is the reason why; limits should be avoided if not necessary. In addition, the; transformation does require some computer time, so it slows down the; computation a little bit, and more importantly, it introduces additional; numerical inaccuracy into the problem in addition to what is introduced; in the numerical calculation of the $\mbox{FCN}$ value. The effects; of non-linearity and numerical roundoff both become more important as; the external value gets closer to one of the limits (expressed as the; distance to nearest limit divided by distance between limits). The user; must therefore be aware of the fact that, for example, if they put limits; of $(0,10^{10})$ on a parameter, then the values $0.0$ and $1.0$ will be; indistinguishable to the accuracy of most machines. For this purpose single sided limits on parameters are provided by M ,; with their transformation being:. Lower bound $a$:. $$\begin{aligned}; P_{\mathrm{int}} &=& \pm\sqrt{(P_{\mathr",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:11074,Safety,safe,safe,11074,"o; M does a transformation of the error matrix (and the ""parabolic""; parameter errors) when there are parameter limits. Users should however; realize that the transformation is only a linear approximation, and that; it cannot give a meaningful result if one or more parameters is very; close to a limit, where; $\partial P_{\mathrm{ext}} / \partial P_{\mathrm{int}} \approx 0$.; Therefore, it is recommended that:. - Limits on variable parameters should be used only when needed in; order to prevent the parameter from taking on unphysical values. - When a satisfactory minimum has been found using limits, the limits; should then be removed if possible, in order to perform or; re-perform the error analysis without limits. Further discussion of the effects of parameter limits may be found in; the last chapter. ## M strategy ##. At many places in the analysis of the $\mbox{FCN}$ (the user; provided function), M must decide whether to be ""safe"" and waste a few; function calls in order to know where it is, or to be ""fast"" and attempt; to get the requested results with the fewest possible calls at a certain; risk of not obtaining the precision desired by the user. In order to; allow the user to influence these decisions, there is a M class; MnStrategy (see [api:strategy]) which the user can use to put different; settings. In the current release, this MnStrategy can be instantiated; with three different minimization quality levels for low (0), medium (1); and high (2) quality. Default settings for iteration cycles and; tolerances are initialized then. The default setting is set for medium; quality. Value 0 (low) indicates to M that it should economize function; calls; it is intended for cases where there are many variable parameters; and/or the function takes a long time to calculate and/or the user is; not interested in very precise values for parameter errors. On the other; hand, value 2 (high) indicates that M is allowed to waste function calls; in order to be sure that all va",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:11245,Safety,risk,risk,11245,"o; M does a transformation of the error matrix (and the ""parabolic""; parameter errors) when there are parameter limits. Users should however; realize that the transformation is only a linear approximation, and that; it cannot give a meaningful result if one or more parameters is very; close to a limit, where; $\partial P_{\mathrm{ext}} / \partial P_{\mathrm{int}} \approx 0$.; Therefore, it is recommended that:. - Limits on variable parameters should be used only when needed in; order to prevent the parameter from taking on unphysical values. - When a satisfactory minimum has been found using limits, the limits; should then be removed if possible, in order to perform or; re-perform the error analysis without limits. Further discussion of the effects of parameter limits may be found in; the last chapter. ## M strategy ##. At many places in the analysis of the $\mbox{FCN}$ (the user; provided function), M must decide whether to be ""safe"" and waste a few; function calls in order to know where it is, or to be ""fast"" and attempt; to get the requested results with the fewest possible calls at a certain; risk of not obtaining the precision desired by the user. In order to; allow the user to influence these decisions, there is a M class; MnStrategy (see [api:strategy]) which the user can use to put different; settings. In the current release, this MnStrategy can be instantiated; with three different minimization quality levels for low (0), medium (1); and high (2) quality. Default settings for iteration cycles and; tolerances are initialized then. The default setting is set for medium; quality. Value 0 (low) indicates to M that it should economize function; calls; it is intended for cases where there are many variable parameters; and/or the function takes a long time to calculate and/or the user is; not interested in very precise values for parameter errors. On the other; hand, value 2 (high) indicates that M is allowed to waste function calls; in order to be sure that all va",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:19143,Safety,predict,predict,19143,"ameter; which causes ${\displaystyle F'}$ to increase by the amount; FCNBase::up(), where ${\displaystyle F'}$ is the minimum of; $\mbox{FCN}$ with respect to all *other* free parameters, and; FCNBase::up() is the return value of the error definition specified by; the user (default = 1.). The algorithm for finding the positive and negative $\mbox{MINOS}$; errors for parameter $\mbox{n}$ consists of varying parameter; $\mbox{n}$, each time minimizing $\mbox{FCN}$ with respect to; all the other $\mbox{npar - 1}$ variable parameters, to find; numerically the two values of parameter $\mbox{n}$ for which the; minimum of $\mbox{FCN}$ takes on the values; $\displaystyle F_{\mathrm{min}} + \mbox{up}$, where; $\displaystyle F_{\mathrm{min}}$ is the minimum of $\mbox{FCN}$ with; respect to all $\mbox{npar}$ parameters. In order to make the; procedure as fast as possible, $\mbox{MINOS}$ uses the error matrix; to predict the values of all parameters at the various sub-minima which; it will have to find in the course of the calculation, and in the limit; that the problem is nearly linear, the predictions of $\mbox{MINOS}$; will be nearly exact, requiring very few iterations. On the other hand,; when the problem is very non-linear (i.e., $\mbox{FCN}$ is far from; a quadratic function of its parameters), is precisely the situation when; $\mbox{MINOS}$ is needed in order to indicate the correct parameter; errors. ### $\mbox{CONTOURS}$ plotting ###. M offers a procedure for finding $\mbox{FCN}$ $\mbox{CONTOURS}$; (provided via the class MnContours, see [api:contours]). The contour calculated by MnContours::operator() is dynamic, in the; sense that it represents the minimum of $\mbox{FCN}$ with respect to; all the other $\mbox{npar - 2}$ parameters (if any). In statistical; terms, this means that MnContours takes account of the correlations; between the two parameters being plotted, and all the other variable; parameters, using a procedure analogous to that of $\mbox{MINOS}$.; (If th",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:19325,Safety,predict,predictions,19325,"ameter; which causes ${\displaystyle F'}$ to increase by the amount; FCNBase::up(), where ${\displaystyle F'}$ is the minimum of; $\mbox{FCN}$ with respect to all *other* free parameters, and; FCNBase::up() is the return value of the error definition specified by; the user (default = 1.). The algorithm for finding the positive and negative $\mbox{MINOS}$; errors for parameter $\mbox{n}$ consists of varying parameter; $\mbox{n}$, each time minimizing $\mbox{FCN}$ with respect to; all the other $\mbox{npar - 1}$ variable parameters, to find; numerically the two values of parameter $\mbox{n}$ for which the; minimum of $\mbox{FCN}$ takes on the values; $\displaystyle F_{\mathrm{min}} + \mbox{up}$, where; $\displaystyle F_{\mathrm{min}}$ is the minimum of $\mbox{FCN}$ with; respect to all $\mbox{npar}$ parameters. In order to make the; procedure as fast as possible, $\mbox{MINOS}$ uses the error matrix; to predict the values of all parameters at the various sub-minima which; it will have to find in the course of the calculation, and in the limit; that the problem is nearly linear, the predictions of $\mbox{MINOS}$; will be nearly exact, requiring very few iterations. On the other hand,; when the problem is very non-linear (i.e., $\mbox{FCN}$ is far from; a quadratic function of its parameters), is precisely the situation when; $\mbox{MINOS}$ is needed in order to indicate the correct parameter; errors. ### $\mbox{CONTOURS}$ plotting ###. M offers a procedure for finding $\mbox{FCN}$ $\mbox{CONTOURS}$; (provided via the class MnContours, see [api:contours]). The contour calculated by MnContours::operator() is dynamic, in the; sense that it represents the minimum of $\mbox{FCN}$ with respect to; all the other $\mbox{npar - 2}$ parameters (if any). In statistical; terms, this means that MnContours takes account of the correlations; between the two parameters being plotted, and all the other variable; parameters, using a procedure analogous to that of $\mbox{MINOS}$.; (If th",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:25303,Safety,safe,safety,25303,"vs. $ cvs co MathLibs/Minuit. (If you want to check out a tagged version SEAL\_x\_x\_x of MINUIT, then; do. $ cvs co -r SEAL\_x\_x\_x MathLibs/Minuit ). ## Create a tar.gz from CVS ##. Once the sources are checked out from the CVS code repository,. 1. change to the directory:. $ cd MathLibs/Minuit. 2. run autogen:. $ ./autogen. 3. create a new directory:. $ cd ..; $ mkdir Minuit-BUILD; $ cd Minuit-BUILD/. 4. run configure:. $ ../Minuit/configure. 5. create the tar.gz:. $ make dist. This will create a Minuit-x.x.x.tar.gz which can be distributed and used; as described above. ## M versions ##. The version numbers of M follow the release numbers of the SEAL project; @bib-SEAL at CERN @bib-CERN. ### From to ###. The program is entirely written in standard portable . M does not depend; on any external library. In its minimal usage the user must only provide; an implementation of the FCNBase class to M and parameters and; uncertainties in form of std::vector containers. ### Memory allocation and thread safety ###. Differently to the version of M , the version has its own memory manager; (StackAllocator. The user can select between the standard dynamic memory; allocation and deallocation (default) and performance-optimized; stack–like allocation (optional). However, the library is not thread; save using stack–allocation. ### M parameters ###. Differently to the version of M there is no limit on the number of; parameters, variable or non-variable. Memory allocation is done; dynamically according to the actual needs and ""on demand"". There is no; protection against an upper limit on the number of parameters, however; the ""technological"" limitations of M can be seen around a maximum of 15; free parameters at a time. ## Interference with other packages ##. The new M has been designed to interfere as little as possible with; other programs or packages which may be loaded at the same time. M is; thread safe by default. Optionally the user can select a different way; of dynamically",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:26213,Safety,safe,safe,26213,"s and; uncertainties in form of std::vector containers. ### Memory allocation and thread safety ###. Differently to the version of M , the version has its own memory manager; (StackAllocator. The user can select between the standard dynamic memory; allocation and deallocation (default) and performance-optimized; stack–like allocation (optional). However, the library is not thread; save using stack–allocation. ### M parameters ###. Differently to the version of M there is no limit on the number of; parameters, variable or non-variable. Memory allocation is done; dynamically according to the actual needs and ""on demand"". There is no; protection against an upper limit on the number of parameters, however; the ""technological"" limitations of M can be seen around a maximum of 15; free parameters at a time. ## Interference with other packages ##. The new M has been designed to interfere as little as possible with; other programs or packages which may be loaded at the same time. M is; thread safe by default. Optionally the user can select a different way; of dynamically allocating memory in the class StackAllacator for M , in; which case (and after an entire recompilation of the whole library) the; thread safety is lost. ## Floating-point precision ##. [install:epsmac]. M is entirely based on double precision. The actual floating point; precision of double precision (32–bit or 64–bit) is platform dependent; and can even vary on the same platform, depending on whether a floating; point number is read from memory a CPU register. The argument of the user's implementation of FCNBase::operator() is; therefore a std:vector$<$double$>$. M expects that the calculations; inside $\mbox{FCN}$ will be performed approximately to the same; accuracy. The accuracy M expects is called *machine precision*; (MnMachinePrecision, see [api:epsmac]) and can be printed on demand; using std::cout. If the user fools M by making internal $\mbox{FCN}$; computations in single precision, M will interpre",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:26431,Safety,safe,safety,26431,"sion of M , the version has its own memory manager; (StackAllocator. The user can select between the standard dynamic memory; allocation and deallocation (default) and performance-optimized; stack–like allocation (optional). However, the library is not thread; save using stack–allocation. ### M parameters ###. Differently to the version of M there is no limit on the number of; parameters, variable or non-variable. Memory allocation is done; dynamically according to the actual needs and ""on demand"". There is no; protection against an upper limit on the number of parameters, however; the ""technological"" limitations of M can be seen around a maximum of 15; free parameters at a time. ## Interference with other packages ##. The new M has been designed to interfere as little as possible with; other programs or packages which may be loaded at the same time. M is; thread safe by default. Optionally the user can select a different way; of dynamically allocating memory in the class StackAllacator for M , in; which case (and after an entire recompilation of the whole library) the; thread safety is lost. ## Floating-point precision ##. [install:epsmac]. M is entirely based on double precision. The actual floating point; precision of double precision (32–bit or 64–bit) is platform dependent; and can even vary on the same platform, depending on whether a floating; point number is read from memory a CPU register. The argument of the user's implementation of FCNBase::operator() is; therefore a std:vector$<$double$>$. M expects that the calculations; inside $\mbox{FCN}$ will be performed approximately to the same; accuracy. The accuracy M expects is called *machine precision*; (MnMachinePrecision, see [api:epsmac]) and can be printed on demand; using std::cout. If the user fools M by making internal $\mbox{FCN}$; computations in single precision, M will interpret roundoff noise as; significant and will usually either fail to find a minimum, or give; incorrect values for the parameter",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:59914,Safety,avoid,avoid,59914,"### operator$<<$(std::ostream&, const MnUserCovariance&) ###. Prints out the MnUserCovariance. ### operator$<<$(std::ostream&, const MnGlobalCorrelationCoeff&) ###. Prints out the MnGlobalCorrelationCoeff. ### operator$<<$(std::ostream&, const MnUserParameterState&) ###. Prints out the whole MnUserParameterState: MnUserParameters,; MnUserCovariance and MnGlobalCorrelationCoeff. ### operator$<<$(std::ostream&, const MinosError&) ###. Prints out the MinosError of a given parameter. ### operator$<<$(std::ostream&, const ContoursErros&) ###. Prints out the MinosError of the two parameters and plots a line printer; graphic of the contours on the output terminal. # How to get the right answer from M #. The goal of M — to be able to minimize and analyze parameter errors for; all possible user functions with any number of variable parameters — is; of course impossible to realise, even in principle, in a finite amount; of time. In practice, some assumptions must be made about the behaviour; of the function in order to avoid evaluating it at all possible points.; In this chapter we give some hints on how the user can help M to make; the right assumptions. ## Which minimizer to use ##. One of the historically interesting advantages of M is that it was; probably the first minimization program to offer the user a choice of; several minimization algorithms. This could be taken as a reflection of; the fact that none of the algorithms known at that time were good enough; to be universal, so users were encouraged to find the one that worked; best for them. Since then, algorithms have improved considerably, but M; still offers several, mostly so that old users will not feel cheated,; but also to help the occasional user who does manage to defeat the best; algorithms. M currently offers four applications which can be used to; find a smaller function value, in addition to $\mbox{MINOS}$, which; will retain a smaller function value if it stumbles on one unexpectedly.; The objects which ",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:63595,Safety,avoid,avoided,63595,"meter correlations, and worst of all cannot be expected to converge; accurately to the minimum in a finite time. Its estimate of the; *expected distance to the minimum* $\mbox{EDM}$ is largely fantasy,; so it would not even know if it did converge. ## Floating point precision ##. M figures out at execution time the machine precision [api:epsmac], and; assumes that $\mbox{FCN}$ provides about the same precision. That; means not just the length of the numbers used and returned by; $\mbox{FCN}$, but the actual mathematical accuracy of the; calculations. Section [install:epsmac] describes what to do if this is; not the case. ## Parameter limits ##. Putting limits (absolute bounds) on the allowed values for a given; parameter, causes M to make a non-linear transformation of its own; internal parameter values to obtain the (external) parameter values; passed to $\mbox{FCN}$. To understand the adverse effect of limits,; see [intro:limits]. Basically, the use of limits should be avoided unless needed to keep the; parameter inside a desired range. If parameter limits are needed, in spite of the effects described in; Chapter One, then the user should be aware of the following techniques; to alleviate problems caused by limits. ### Getting the Right Minimum with Limits ###. If $\mbox{MIGRAD}$ converges normally to a point where no parameter; is near one of its limits, then the existence of limits has probably not; prevented M from finding the right minimum. On the other hand, if one or; more parameters is near its limit at the minimum, this may be because; the true minimum is indeed at a limit, or it may be because the; minimizer has become ""blocked"" at a limit. This may normally happen only; if the parameter is so close to a limit (internal value at an odd; multiple of $\pm \frac{ \pi}{ 2}$ that M prints a warning to this effect; when it prints the parameter values. The minimizer can become blocked at a limit, because at a limit the; derivative seen by the minimizer; $\partia",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:66904,Safety,avoid,avoid,66904,"symmetric errors, then becomes essentially meaningless. On the; other hand, the $\mbox{MINOS}$ analysis is still meaningful, at; least in principle, as long as $\mbox{MIGRAD}$ (which is called; internally by $\mbox{MINOS}$) does not get blocked at a limit.; Unfortunately, the user has no control over this aspect of the; $\mbox{MINOS}$ calculation, although it is possible to get enough; printout from the $\mbox{MINOS}$ result to be able to determine; whether the results are reliable or not. ## Fixing and releasing parameters ##. When M needs to be guided to the ""right"" minimum, often the best way to; do this is with the methods e.g. MnMigrad::fix(...) and; MnMigrad::release(...). That is, suppose you have a problem with ten; free parameters, and when you minimize with respect to all at once, M; goes to an unphysical solution characterized by an unphysical or; unwanted value of parameter number four. One way to avoid this is to fix; parameter four at a ""good"" value (not necessarily the best, since you; presumably don't know that yet), and minimize with respect to the; others. Then release parameter four and minimize again. If the problem; admits a ""good"" physical solution, you will normally find it this way.; If it doesn't work, you may see what is wrong by the following sequence; (where $\mbox{xxx}$ is the expected physical value for parameter; four):. MnMigrad migrad(...);; migrad.setValue(4, xxx);; migrad.fix(4);; FunctionMinimum min = migrad();; migrad.release(4);; MnScan scan(...);; std::vector<std::pair<double, double> > points = scan(4);. where $\mbox{SCAN}$ gives you a picture of $\mbox{FCN}$ as a; function of parameter four alone, the others being fixed at their; current best values. If you suspect the difficulty is due to parameter; five, then add. MnContours contour(...);; std::vector<std::pair<double, double> > points = contour(4, 5);. to see a two-dimensional picture. ## Interpretation of parameter errors ##. There are two kinds of problems that can arise:",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:72195,Safety,recover,recovers,72195,"rmine the current search direction, since this is; the optimal strategy for quadratic functions and ""physical"" functions; should be quadratic in the neighbourhood of the minimum at least. The; search directions determined by $\mbox{MIGRAD}$ are guaranteed to be; downhill only if the covariance matrix is positive–definite, so in case; this is not true, it makes a positive–definite approximation by adding; an appropriate constant along the diagonal as determined by the; eigenvalues of the matrix. Theoretically, the covariance matrix for a; ""physical"" function must be positive–definite at the minimum, although; it may not be so for all points far away from the minimum, even for a; well–determined physical problem. Therefore, if $\mbox{MIGRAD}$; reports that it has found a non-positive–definite covariance matrix,; this may be a sign of one or more of the following:. - **A non–physical region.** On its way to the minimum,; $\mbox{MIGRAD}$ may have traversed a region which has unphysical; behaviour, which is of course not a serious problem as long as it; recovers and leaves such a region. - **An underdetermined problem.** If the matrix is not; positive–definite even at the minimum, this may mean that the; solution is not well–defined, for example that there are more; unknowns than there are data points, or that the parametrization of; the fit contains a linear dependence. If this is the case, then M; (or any other program) cannot solve your problem uniquely, and the; error matrix will necessarily be largely meaningless, so the user; must remove the under-determinedness by reformulating the; parametrization. M cannot do this itself, but it can provide some; hints (contours, global correlation coefficients, eigenvalues) which; can help the clever user to find out what is wrong. - **Numerical inaccuracies.** It is possible that the apparent lack of; positive–definiteness is in fact only due to excessive roundoff; errors in numerical calculations, either in $\mbox{FCN}$ or in",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:74185,Safety,detect,detects,74185,"ecomes more likely if the number; of free parameters is very large, or if the parameters are badly; scaled (not all of the same order of magnitude), and correlations; are also large. In any case, whether the non–positive–definiteness; is real or only numerical is largely irrelevant, since in both cases; the error matrix will be unreliable and the minimum suspicious. ## Additional trouble–shooting ##. When M just doesn't work, some of the more common causes are:. - **Precision mismatch.** Make sure your $\mbox{FCN}$ uses; internally the same precision as M . If the problem is only one of precision, and not of word length; mismatch, an appropriate MnMachinePrecision::setPrecision() may fix; it. - **Trivial bugs in $\mbox{FCN}$.** The possibilities for bugs are; numerous. Probably the most common among physicists inexperienced in; is the confusion between double and int types, which you can; sometimes get away with, but not always. [^3] M can spot some; trivial bugs itself, and issues a warning when it detects an unusual; $\mbox{FCN}$ behaviour. Such a warning should be taken; seriously. M also offers some tools (especially $\mbox{SCAN}$) which can; help the user to find trivial bugs. - **An ill–posed problem.** For questions of parameter dependence, see; the discussion above on postive–definiteness. Other mathematical; problems which can arise are: **excessive numerical roundoff** — be; especially careful of exponential and factorial functions which get; big very quickly and lose accuracy; **starting too far from the; solution** — the function may have unphysical local minima,; especially at infinity in some variables; **incorrect; normalization** — in likelihood functions, the probability; distributions must be normalized or at least have an integral which; is independent of the values of the variable parameters. - **A bug in M .** This is unlikely, but it happens. If a bug is; suspected, and all other possible causes can be eliminated, please; try to save a copy of ",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:5880,Security,access,access,5880,"(the kernel; of M ) should be clearly separated from the user, who is interfacing via; defined user interfaces (the API). ## Internal and external parameters ##. Each of the parameters to the $\mbox{FCN}$ is defined by the user as; belonging to one of the following types:. - Freely variable: allowed to take on any value. - Variable with double sided limits: allowed to vary only between two; limits specified by the user. - Variable with single sided limits: allowed to vary only between one; upper or one lower limit specified by the user and unlimited to the; other side. - Fixed: originally defined as variable, but now taking on only the; value the parameter had at the moment it was fixed, or a value later; assigned by the user. - Constant: taking on only one value as specified by the user. When using the minimal required interface, all variable parameters are; free and unbound. The user, in their $\mbox{FCN}$, must of course be able to ""see"" all; types of defined parameters, and they therefore have access to what we call; the *external parameter list*, that is, the parameters as he defined; them. On the other hand, the internal M minimizing routines only want to; ""see"" variable parameters without limits, and so they have access only; to the *internal parameter list* which is created from the external list; by the following transformation:. - Squeeze out all parameters that are not variable. - Transform all variable parameters with limits, so that the; transformed parameter can vary without limits. (See the next section; for details concerning this transformation.) Because this; transformation is non-linear, it is recommended to avoid putting; limits on parameters where they are not needed. As an example, suppose that the user has defined the following; parameters:. - Parameter 0, constant. - Parameter 1, freely variable. - Parameter 2, variable with limits. - Parameter 3, constant. - Parameter 4, freely variable. Then the internal parameter list would be as follows:. ",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:6107,Security,access,access,6107,"nging to one of the following types:. - Freely variable: allowed to take on any value. - Variable with double sided limits: allowed to vary only between two; limits specified by the user. - Variable with single sided limits: allowed to vary only between one; upper or one lower limit specified by the user and unlimited to the; other side. - Fixed: originally defined as variable, but now taking on only the; value the parameter had at the moment it was fixed, or a value later; assigned by the user. - Constant: taking on only one value as specified by the user. When using the minimal required interface, all variable parameters are; free and unbound. The user, in their $\mbox{FCN}$, must of course be able to ""see"" all; types of defined parameters, and they therefore have access to what we call; the *external parameter list*, that is, the parameters as he defined; them. On the other hand, the internal M minimizing routines only want to; ""see"" variable parameters without limits, and so they have access only; to the *internal parameter list* which is created from the external list; by the following transformation:. - Squeeze out all parameters that are not variable. - Transform all variable parameters with limits, so that the; transformed parameter can vary without limits. (See the next section; for details concerning this transformation.) Because this; transformation is non-linear, it is recommended to avoid putting; limits on parameters where they are not needed. As an example, suppose that the user has defined the following; parameters:. - Parameter 0, constant. - Parameter 1, freely variable. - Parameter 2, variable with limits. - Parameter 3, constant. - Parameter 4, freely variable. Then the internal parameter list would be as follows:. - Internal parameter 0 = external parameter 1. - Internal parameter 1 = external parameter 2, transformed; appropriately. - Internal parameter 2 = external parameter 4. In the above example, M considers that the number of external para",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:23959,Security,authoriz,authorization,23959,"te vector: LAVector parameters:. -1.82079e-05; -1.20794e-05; 6.22382e-06; -3.0465e-05. minimum internal covariance matrix: LASymMatrix parameters:. 4 1 2 2.70022e-18; 1 5 3 1.87754e-17; 2 3 6 2.29467e-17; 2.70022e-18 1.87754e-17 2.29467e-17 1. # ext. || name || type || value || error +/-. 0 || x || free ||-1.821e-05 || 2; 1 || y || free ||-1.208e-05 || 2.236; 2 || z || free || 6.224e-06 || 2.449; 3 || w || free ||-3.047e-05 || 1. MnUserCovariance:. 4 1 2 2.70022e-18; 1 5 3 1.87754e-17; 2 3 6 2.29467e-17; 2.70022e-18 1.87754e-17 2.29467e-17 1. MnUserCovariance parameter correlations:. 1 0.223607 0.408248 1.35011e-18; 0.223607 1 0.547723 8.39663e-18; 0.408248 0.547723 1 9.36796e-18; 1.35011e-18 8.39663e-18 9.36796e-18 1. MnGlobalCorrelationCoeff:. 0.408248; 0.547723; 0.621261; 0. ## CVS code repository ##. How to check out (–in) code from the CVS code repository is described at; the M homepage @bib-C++MINUIT. To get the source code from the CVS; repository one needs to do:. Kerberos IV authorization:. $ setenv CVSROOT :kserver:SEAL.cvs.cern.ch:/cvs/SEAL. $ cvs co MathLibs/Minuit. Anonymous read-only access (if it's enabled by the librarian, see; details):. $ setenv CVSROOT :pserver:anonymous@SEAL.cvs.cern.ch:/cvs/SEAL. $ cvs login. (Logging in to :pserver:anonymous@seal.cvs.cern.ch:2401/cvs/SEAL) CVS; password:cvs. $ cvs co MathLibs/Minuit. (If you want to check out a tagged version SEAL\_x\_x\_x of MINUIT, then; do. $ cvs co -r SEAL\_x\_x\_x MathLibs/Minuit ). ## Create a tar.gz from CVS ##. Once the sources are checked out from the CVS code repository,. 1. change to the directory:. $ cd MathLibs/Minuit. 2. run autogen:. $ ./autogen. 3. create a new directory:. $ cd ..; $ mkdir Minuit-BUILD; $ cd Minuit-BUILD/. 4. run configure:. $ ../Minuit/configure. 5. create the tar.gz:. $ make dist. This will create a Minuit-x.x.x.tar.gz which can be distributed and used; as described above. ## M versions ##. The version numbers of M follow the release numbers of the SEAL projec",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:24075,Security,access,access,24075,"x parameters:. 4 1 2 2.70022e-18; 1 5 3 1.87754e-17; 2 3 6 2.29467e-17; 2.70022e-18 1.87754e-17 2.29467e-17 1. # ext. || name || type || value || error +/-. 0 || x || free ||-1.821e-05 || 2; 1 || y || free ||-1.208e-05 || 2.236; 2 || z || free || 6.224e-06 || 2.449; 3 || w || free ||-3.047e-05 || 1. MnUserCovariance:. 4 1 2 2.70022e-18; 1 5 3 1.87754e-17; 2 3 6 2.29467e-17; 2.70022e-18 1.87754e-17 2.29467e-17 1. MnUserCovariance parameter correlations:. 1 0.223607 0.408248 1.35011e-18; 0.223607 1 0.547723 8.39663e-18; 0.408248 0.547723 1 9.36796e-18; 1.35011e-18 8.39663e-18 9.36796e-18 1. MnGlobalCorrelationCoeff:. 0.408248; 0.547723; 0.621261; 0. ## CVS code repository ##. How to check out (–in) code from the CVS code repository is described at; the M homepage @bib-C++MINUIT. To get the source code from the CVS; repository one needs to do:. Kerberos IV authorization:. $ setenv CVSROOT :kserver:SEAL.cvs.cern.ch:/cvs/SEAL. $ cvs co MathLibs/Minuit. Anonymous read-only access (if it's enabled by the librarian, see; details):. $ setenv CVSROOT :pserver:anonymous@SEAL.cvs.cern.ch:/cvs/SEAL. $ cvs login. (Logging in to :pserver:anonymous@seal.cvs.cern.ch:2401/cvs/SEAL) CVS; password:cvs. $ cvs co MathLibs/Minuit. (If you want to check out a tagged version SEAL\_x\_x\_x of MINUIT, then; do. $ cvs co -r SEAL\_x\_x\_x MathLibs/Minuit ). ## Create a tar.gz from CVS ##. Once the sources are checked out from the CVS code repository,. 1. change to the directory:. $ cd MathLibs/Minuit. 2. run autogen:. $ ./autogen. 3. create a new directory:. $ cd ..; $ mkdir Minuit-BUILD; $ cd Minuit-BUILD/. 4. run configure:. $ ../Minuit/configure. 5. create the tar.gz:. $ make dist. This will create a Minuit-x.x.x.tar.gz which can be distributed and used; as described above. ## M versions ##. The version numbers of M follow the release numbers of the SEAL project; @bib-SEAL at CERN @bib-CERN. ### From to ###. The program is entirely written in standard portable . M does not depend; on any ext",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:24281,Security,password,password,24281,"5 || 2; 1 || y || free ||-1.208e-05 || 2.236; 2 || z || free || 6.224e-06 || 2.449; 3 || w || free ||-3.047e-05 || 1. MnUserCovariance:. 4 1 2 2.70022e-18; 1 5 3 1.87754e-17; 2 3 6 2.29467e-17; 2.70022e-18 1.87754e-17 2.29467e-17 1. MnUserCovariance parameter correlations:. 1 0.223607 0.408248 1.35011e-18; 0.223607 1 0.547723 8.39663e-18; 0.408248 0.547723 1 9.36796e-18; 1.35011e-18 8.39663e-18 9.36796e-18 1. MnGlobalCorrelationCoeff:. 0.408248; 0.547723; 0.621261; 0. ## CVS code repository ##. How to check out (–in) code from the CVS code repository is described at; the M homepage @bib-C++MINUIT. To get the source code from the CVS; repository one needs to do:. Kerberos IV authorization:. $ setenv CVSROOT :kserver:SEAL.cvs.cern.ch:/cvs/SEAL. $ cvs co MathLibs/Minuit. Anonymous read-only access (if it's enabled by the librarian, see; details):. $ setenv CVSROOT :pserver:anonymous@SEAL.cvs.cern.ch:/cvs/SEAL. $ cvs login. (Logging in to :pserver:anonymous@seal.cvs.cern.ch:2401/cvs/SEAL) CVS; password:cvs. $ cvs co MathLibs/Minuit. (If you want to check out a tagged version SEAL\_x\_x\_x of MINUIT, then; do. $ cvs co -r SEAL\_x\_x\_x MathLibs/Minuit ). ## Create a tar.gz from CVS ##. Once the sources are checked out from the CVS code repository,. 1. change to the directory:. $ cd MathLibs/Minuit. 2. run autogen:. $ ./autogen. 3. create a new directory:. $ cd ..; $ mkdir Minuit-BUILD; $ cd Minuit-BUILD/. 4. run configure:. $ ../Minuit/configure. 5. create the tar.gz:. $ make dist. This will create a Minuit-x.x.x.tar.gz which can be distributed and used; as described above. ## M versions ##. The version numbers of M follow the release numbers of the SEAL project; @bib-SEAL at CERN @bib-CERN. ### From to ###. The program is entirely written in standard portable . M does not depend; on any external library. In its minimal usage the user must only provide; an implementation of the FCNBase class to M and parameters and; uncertainties in form of std::vector containers. ### Me",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:36116,Security,access,accessed,36116,"state and one can have multiple instances of MnMigrad objects. ### M fails to find a minimum ###. If M fails to find a minimum, the user is notified by a warning message; issued by M when running into troubles. Problems can be:. - a bug in M. - an error in the $\mbox{FCN}$. - a highly difficult problem (usually strong correlations among; parameters). - floating–point precision. ## The output from minimization ##. ### The FunctionMinimum ###. The output of the minimizers is the FunctionMinimum. The FunctionMinimum; contains the result of the minimization in both internal parameter; representation and external parameter representation. ### User representable format: MnUserParameterState ###. On request, the result of the minimization is transformed into a user; representable format for parameters and errors, the; MnUserParameterState. ### Access values, errors, covariance ###. The result can be accessed via methods like; MnUserParameterState::value(unsigned int n) and; MnUserParameterState::error(unsigned int n), where $n$ is the index of; the parameter in the list of parameters defined by the user. ### Printout of the result ###. The FunctionMinimum can be printed on the output simply via std::cout.; It will print both the internal and external state, that is parameters,; errors and the covariance matrix (if available). It also tells the user; if M did converge or not by issuing an appropriate message. If a; covariance matrix is available, the global correlation coefficients are; printed as well. ### Global correlation coefficients ###. The global correlation coefficient for parameter $n$ is a number between; zero and one which gives the correlation between parameter $n$ and that; linear combination of all other parameters which is most strongly; correlated with $n$. # M application programming interface (API) #. [api:api]. ## FunctionMinimum ##. [api:fm] The FunctionMinimum is the output of the minimizers and; contains the minimization result. The state at the minimu",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:52978,Security,access,accessed,52978," size; of the covariance matrix is according to the number of variable; parameters (free and limited). ### MnUserCovariance(const std::vector$<$double$>$&, unsigned int nrow) ###. Construct from data, positions of the elements in the array are arranged; according to the packed storage format. The size of the array must be; $nrow*(nrow+1)/2$. The array must contain the upper triangular part of; the symmetric matrix packed sequentially, column by column, so that; arr(0) contains covar(0,0), arr(1) and arr(2) contain covar(0,1) and; covar(1,1) respectively, and so on. The number of rows (columns) has to; be specified. ### MnUserCovariance(unsigned int nrow) ###. Specify the number of rows (columns) at instantiation. It will allocate; an array of the length $nrow*(nrow+1)/2$ and initialize it to $0$.; Elements can then be set using the method operator()(unsigned int,; unsigned int). ### MnUserCovariance::operator()(unsigned int, unsigned int) ###. Individual elements can be accessed via the operator(), both for reading; and writing. ## MnUserParameters ##. [api:parameters] MnUserParameters is the main class for user interaction; with the parameters. It serves both as input to the minimization as well; as output as the result of the minimization is converted into the user; representable format in order to allow for further interaction.; Parameters for M can be added (defined) specifying a name, value and; initial uncertainty. ### add(...) ###. The method MnUserParameters::add(...) is overloaded for three kind of; parameters:. - add(const char\*, double, double) for adding a free variable; parameter. - add(const char\*, double, double, double, double) for adding a; variable parameter with limits (lower and upper). - add(const char\*, double) for adding a constant parameter. When adding parameters, M assigns indices to each parameter which will; be the same as in the std::vector$<$double$>$ in the; FCNBase::operator(). That means the first parameter the user adds gets; inde",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:80039,Security,access,access,80039,"ng values for initial uncertainties; std::vector<double> init_err;; init_err.push_back(0.1);; init_err.push_back(0.1);; init_err.push_back(0.1);. // create minimizer (default constructor); VariableMetricMinimizer theMinimizer;. // minimize; FunctionMinimum min =; theMinimizer.minimize(theFCN, init_par, init_err);. // output; std::cout<<""minimum: ""<<min<<std::endl;; }. {; // demonstrate standard minimization using MIGRAD; // create Minuit parameters with names; MnUserParameters upar;; upar.add(""mean"", mean, 0.1);; upar.add(""sigma"", rms, 0.1);; upar.add(""area"", area, 0.1);. // create MIGRAD minimizer; MnMigrad migrad(theFCN, upar);. // minimize; FunctionMinimum min = migrad();. // output; std::cout<<""minimum: ""<<min<<std::endl;; }. {; // demonstrate full interaction with parameters over subsequent; // minimizations. // create Minuit parameters with names; MnUserParameters upar;; upar.add(""mean"", mean, 0.1);; upar.add(""sigma"", rms, 0.1);; upar.add(""area"", area, 0.1);. // access parameter by name to set limits...; upar.setLimits(""mean"", mean-0.01, mean+0.01);. // ... or access parameter by index; upar.setLimits(1, rms-0.1, rms+0.1);. // create Migrad minimizer; MnMigrad migrad(theFCN, upar);. // fix a parameter...; migrad.fix(""mean"");. // ... and minimize; FunctionMinimum min = migrad();. // output; std::cout<<""minimum: ""<<min<<std::endl;. // release a parameter...; migrad.release(""mean"");. // ... and fix another one; migrad.fix(1);. // and minimize again; FunctionMinimum min1 = migrad();. // output; std::cout<<""minimum1: ""<<min1<<std::endl;. // release the parameter...; migrad.release(1);. // ... and minimize with all three parameters; // (still with limits!); FunctionMinimum min2 = migrad();. // output; std::cout<<""minimum2: ""<<min2<<std::endl;. // remove all limits on parameters...; migrad.removeLimits(""mean"");; migrad.removeLimits(""sigma"");. // ... and minimize again with all three parameters; // (now without limits!); FunctionMinimum min3 = migrad();. // output; std",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:80139,Security,access,access,80139,"t_err.push_back(0.1);; init_err.push_back(0.1);. // create minimizer (default constructor); VariableMetricMinimizer theMinimizer;. // minimize; FunctionMinimum min =; theMinimizer.minimize(theFCN, init_par, init_err);. // output; std::cout<<""minimum: ""<<min<<std::endl;; }. {; // demonstrate standard minimization using MIGRAD; // create Minuit parameters with names; MnUserParameters upar;; upar.add(""mean"", mean, 0.1);; upar.add(""sigma"", rms, 0.1);; upar.add(""area"", area, 0.1);. // create MIGRAD minimizer; MnMigrad migrad(theFCN, upar);. // minimize; FunctionMinimum min = migrad();. // output; std::cout<<""minimum: ""<<min<<std::endl;; }. {; // demonstrate full interaction with parameters over subsequent; // minimizations. // create Minuit parameters with names; MnUserParameters upar;; upar.add(""mean"", mean, 0.1);; upar.add(""sigma"", rms, 0.1);; upar.add(""area"", area, 0.1);. // access parameter by name to set limits...; upar.setLimits(""mean"", mean-0.01, mean+0.01);. // ... or access parameter by index; upar.setLimits(1, rms-0.1, rms+0.1);. // create Migrad minimizer; MnMigrad migrad(theFCN, upar);. // fix a parameter...; migrad.fix(""mean"");. // ... and minimize; FunctionMinimum min = migrad();. // output; std::cout<<""minimum: ""<<min<<std::endl;. // release a parameter...; migrad.release(""mean"");. // ... and fix another one; migrad.fix(1);. // and minimize again; FunctionMinimum min1 = migrad();. // output; std::cout<<""minimum1: ""<<min1<<std::endl;. // release the parameter...; migrad.release(1);. // ... and minimize with all three parameters; // (still with limits!); FunctionMinimum min2 = migrad();. // output; std::cout<<""minimum2: ""<<min2<<std::endl;. // remove all limits on parameters...; migrad.removeLimits(""mean"");; migrad.removeLimits(""sigma"");. // ... and minimize again with all three parameters; // (now without limits!); FunctionMinimum min3 = migrad();. // output; std::cout<<""minimum3: ""<<min3<<std::endl;; }. {; // demonstrate MINOS error analysis. // create Min",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:299,Testability,log,log-likelihood,299,"; # Foreword #. ## What M is intended to do ##. M is conceived as a tool to find the minimum value of a multi-parameter; function (the ""$\mbox{FCN}$"") and analyze the shape of the function; around the minimum. The principal application is foreseen for; statistical analysis, working on chisquare or log-likelihood functions,; to compute the best-fit parameter values and uncertainties, including; correlations between the parameters. It is especially suited to handle; difficult problems, including those which may require guidance in order; to find the correct solution. ## What M is not intended to do ##. Although M will of course solve easy problems faster than complicated; ones, it is not intended for the repeated solution of identically; parametrized problems (such as track fitting in a detector) where a; specialized program will in general be much more efficient. ## Further remarks ##. M was initially written in Fortran around 1975-1980 at CERN by Fred; James @bib-MINUIT. Its main field of usage is statistical data analysis; of experimental data recorded at CERN, but it is also used by people; doing data analysis outside CERN or outside high energy physics (HEP).; In 2002 Fred James started a project aiming to re-implement M in an; object-oriented way using . More information about recent developments, releases and installation; can be obtained from the M homepage @bib-C++MINUIT. The names of M applications are written in capital letters (e.g.; $\mbox{MIGRAD}$, $\mbox{MINOS}$, $\mbox{CONTOURS}$), the; corresponding names of the classes are written using sans-serif font; type (MnMigrad, MnMinos, MnContours). # Introduction: M basic concepts #. [sec:intro]. ## The organization of M ##. The M package acts on a multiparameter *objective function* which is; called — for historical reasons — the $\mbox{FCN}$ function (see; [howto:fcn]). This function is usually a chisquared or a log–likelihood,; but it could also be a mathematical function. The $\mbox{FCN}$; function needs ",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:1905,Testability,log,log,1905,"written in Fortran around 1975-1980 at CERN by Fred; James @bib-MINUIT. Its main field of usage is statistical data analysis; of experimental data recorded at CERN, but it is also used by people; doing data analysis outside CERN or outside high energy physics (HEP).; In 2002 Fred James started a project aiming to re-implement M in an; object-oriented way using . More information about recent developments, releases and installation; can be obtained from the M homepage @bib-C++MINUIT. The names of M applications are written in capital letters (e.g.; $\mbox{MIGRAD}$, $\mbox{MINOS}$, $\mbox{CONTOURS}$), the; corresponding names of the classes are written using sans-serif font; type (MnMigrad, MnMinos, MnContours). # Introduction: M basic concepts #. [sec:intro]. ## The organization of M ##. The M package acts on a multiparameter *objective function* which is; called — for historical reasons — the $\mbox{FCN}$ function (see; [howto:fcn]). This function is usually a chisquared or a log–likelihood,; but it could also be a mathematical function. The $\mbox{FCN}$; function needs to be written in for which M defines the pure abstract; base class FCNBase as interface. The user must define and implement the; $\mbox{FCN}$ function in a derived class from FCNBase. Sometimes; this is done by an intermediate program such as HippoDraw@bib-HippoDraw,; in which case M is being used under the control of such an intermediate; program[^1]. The value of the $\mbox{FCN}$ function will in general; depend on one or more variable parameters whose meaning is defined by; the user (or by the intermediate program), but whose trial values are; determined by M . To take a simple example, suppose the problem is to fit a polynomial; through a set of data points. Then the user would write a; $\mbox{FCN}$ which calculates the $\chi^2$ between a polynomial and; the data; the variable parameters of $\mbox{FCN}$ would be the; coefficients of the polynomials. Using objects for minimization from M ,; the us",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:14077,Testability,log,log-likelihood,14077,"he overall (multiplicative) normalization of; $\mbox{FCN}$, in the sense that if the value of $\mbox{FCN}$ is; everywhere multiplied by a constant $\beta$, then the errors will be; decreased by a factor $\sqrt{\beta}$. Additive constants do not change; the parameter errors, but may imply a different goodness-of-fit; confidence level. Assuming that the user knows what the normalization of their; $\mbox{FCN}$ means, and also that they are interested in parameter; errors, the user can change the error definition which allows them to; define what they means by one ""error"", in terms of the change in the; $\mbox{FCN}$ value which should be caused by changing one parameter; by one ""error"". If the $\mbox{FCN}$ is the usual chisquare function; (defined below) and if the user wants the usual one-standard-deviation; errors, then the error definition (return value of the FCNBase::up(); method, see [howto:errordef]) should be $1.0$. If the $\mbox{FCN}$; is a negative-log-likelihood function, then the one-standard-deviation; value for FCNBase::up() to return is $0.5$. If the $\mbox{FCN}$ is a; chisquare, but the user wants two-standard-deviation errors, then; FCNBase::up() should return $= 4.0$, etc. Note that in the usual case where M is being used to perform a fit to; some experimental data, the parameter errors will be proportional to the; uncertainty in the data, and therefore meaningful parameter errors; cannot be obtained unless the measurement errors of the data are known.; In the common case of a least-squares fit, $\mbox{FCN}$ is usually; defined as a chisquare:. $$\chi^2 (\alpha) = \sum_{i=1}^{n} (\frac{f(x_i,\alpha) - m_i)^2}{\sigma_i^2}$$. where $\alpha$ is the vector of free parameters being fitted, and the; $\sigma_i$ are the uncertainties in the individual measurements $m_i$.; If these uncertainties are not known, and are simply left out of the; calculation, then the fit may still have meaning, but not the; quantitative values of the resulting parameter errors. (On",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:22752,Testability,test,tests,22752,"ng class MnMigrad, M ""commands""; became classes or methods of classes according to their purpose. Users; familiar with the version of M , who have not yet used releases from the; version, should however read this manual, in order to adapt to the; changes as well as to discover the new features and easier ways of using; old features. ## Install M using autoconf/make ##. For each release of M a tar.gz file is provided for downloading from the; M homepage @bib-C++MINUIT. For non-UNIX platforms please refer to the M; homepage. The necessary steps to follow are:. 1. download the tar.gz by clicking on it from the release page. 2. unzip it:. $ unzip Minuit-x.x.x.tar.gz. 3. untar it:. $ tar xvf Minuit-x.x.x.tar. 4. step down to the created Minuit-x.x.x directory:. $ cd Minuit-x.x.x/. 5. run the ""configure"" script:. $ ./configure. 6. run ""make"" to compile the source code:. $ make. 7. run ""make check"" to create the executable example:. $ make check. 8. run the executable example:. $ tests/MnTutorial/Quad4FMain.C. The output should look like that:. Minuit did successfully converge. # of function calls: 74; minimum function value: 1.12392e-09; minimum edm: 1.12392e-09; minimum internal state vector: LAVector parameters:. -1.82079e-05; -1.20794e-05; 6.22382e-06; -3.0465e-05. minimum internal covariance matrix: LASymMatrix parameters:. 4 1 2 2.70022e-18; 1 5 3 1.87754e-17; 2 3 6 2.29467e-17; 2.70022e-18 1.87754e-17 2.29467e-17 1. # ext. || name || type || value || error +/-. 0 || x || free ||-1.821e-05 || 2; 1 || y || free ||-1.208e-05 || 2.236; 2 || z || free || 6.224e-06 || 2.449; 3 || w || free ||-3.047e-05 || 1. MnUserCovariance:. 4 1 2 2.70022e-18; 1 5 3 1.87754e-17; 2 3 6 2.29467e-17; 2.70022e-18 1.87754e-17 2.29467e-17 1. MnUserCovariance parameter correlations:. 1 0.223607 0.408248 1.35011e-18; 0.223607 1 0.547723 8.39663e-18; 0.408248 0.547723 1 9.36796e-18; 1.35011e-18 8.39663e-18 9.36796e-18 1. MnGlobalCorrelationCoeff:. 0.408248; 0.547723; 0.621261; 0. ## CVS code repo",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:24203,Testability,log,login,24203,". # ext. || name || type || value || error +/-. 0 || x || free ||-1.821e-05 || 2; 1 || y || free ||-1.208e-05 || 2.236; 2 || z || free || 6.224e-06 || 2.449; 3 || w || free ||-3.047e-05 || 1. MnUserCovariance:. 4 1 2 2.70022e-18; 1 5 3 1.87754e-17; 2 3 6 2.29467e-17; 2.70022e-18 1.87754e-17 2.29467e-17 1. MnUserCovariance parameter correlations:. 1 0.223607 0.408248 1.35011e-18; 0.223607 1 0.547723 8.39663e-18; 0.408248 0.547723 1 9.36796e-18; 1.35011e-18 8.39663e-18 9.36796e-18 1. MnGlobalCorrelationCoeff:. 0.408248; 0.547723; 0.621261; 0. ## CVS code repository ##. How to check out (–in) code from the CVS code repository is described at; the M homepage @bib-C++MINUIT. To get the source code from the CVS; repository one needs to do:. Kerberos IV authorization:. $ setenv CVSROOT :kserver:SEAL.cvs.cern.ch:/cvs/SEAL. $ cvs co MathLibs/Minuit. Anonymous read-only access (if it's enabled by the librarian, see; details):. $ setenv CVSROOT :pserver:anonymous@SEAL.cvs.cern.ch:/cvs/SEAL. $ cvs login. (Logging in to :pserver:anonymous@seal.cvs.cern.ch:2401/cvs/SEAL) CVS; password:cvs. $ cvs co MathLibs/Minuit. (If you want to check out a tagged version SEAL\_x\_x\_x of MINUIT, then; do. $ cvs co -r SEAL\_x\_x\_x MathLibs/Minuit ). ## Create a tar.gz from CVS ##. Once the sources are checked out from the CVS code repository,. 1. change to the directory:. $ cd MathLibs/Minuit. 2. run autogen:. $ ./autogen. 3. create a new directory:. $ cd ..; $ mkdir Minuit-BUILD; $ cd Minuit-BUILD/. 4. run configure:. $ ../Minuit/configure. 5. create the tar.gz:. $ make dist. This will create a Minuit-x.x.x.tar.gz which can be distributed and used; as described above. ## M versions ##. The version numbers of M follow the release numbers of the SEAL project; @bib-SEAL at CERN @bib-CERN. ### From to ###. The program is entirely written in standard portable . M does not depend; on any external library. In its minimal usage the user must only provide; an implementation of the FCNBase class to M an",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:29678,Testability,log,log,29678,"g of the vector of parameters std::vector$<$double$>$ in the; argument of FCNBase::operator() are of course defined by the user, who; uses the values of those parameters to calculate their function value. The; order and the position of these parameters is strictly the one specified; by the user when supplying the starting values for minimization. The starting values must be specified by the user, either via an; std::vector$<$double$>$ or the MnUserParameters (see [api:parameters]); supplied as input to the M minimizers such as VariableMetricMinimizer or; MnMigrad (see [api:migrad]). Later values are determined by M as it; searches for the minimum or performs whatever analysis is requested by; the user. ### FCNBase::up() ###. [howto:errordef] Returns the value of $\mbox{up}$ (default value; $= 1.$), defining parameter errors. M defines parameter errors as the; change in parameter value required to change the function value by; $\mbox{up}$. Normally, for chisquared fits $\mbox{up = 1}$, and; for negative log likelihood, $\mbox{up = 0.5}$. ### $\mbox{FCN}$ function with gradient ###. By default first derivatives are calculated numerically by M . In case; the user wants to supply their own gradient calculator (e.g. analytical; derivatives), they need to implement the FCNGradientBase interface. ![](figures/fcngradientbase.png). The size of the output vector is the same as of the input one. The same; is true for the position of the elements (first derivative of the; function with respect to the $n_\mathrm{th}$ variable has index $n$ in; the output vector). ## M parameters ##. Interaction with the parameters of the function are essential both for M; and the user. Different interfaces are provided, depending on the level; of interaction. ### Minimal required interface ###. Starting values of parameters and uncertainties can be provided to M by; the user via std::vector$<$double$>$ vector containers. Any interaction; with the parameters before minimization (fix, release, lim",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:77422,Testability,assert,assert,77422,"c FCNBase {. public:. GaussFcn(const std::vector<double>& meas,; const std::vector<double>& pos,; const std::vector<double>& mvar) : theMeasurements(meas),; thePositions(pos),; theMVariances(mvar),; theErrorDef(1.) {}. ~GaussFcn() {}. virtual double up() const {return theErrorDef;}; virtual double operator()(const std::vector<double>&) const;. std::vector<double> measurements() const {return theMeasurements;}; std::vector<double> positions() const {return thePositions;}; std::vector<double> variances() const {return theMVariances;}. void setErrorDef(double def) {theErrorDef = def;}. private:. std::vector<double> theMeasurements;; std::vector<double> thePositions;; std::vector<double> theMVariances;; double theErrorDef;; };. #endif //MN_GaussFcn_H_. ### GaussFcn.cpp ###. The actual implementation of the FCNBase::operator() (called by Minuit):. #include ""GaussFcn.h""; #include ""GaussFunction.h"". #include <cassert>. double GaussFcn::operator()(const std::vector<double>& par) const {. assert(par.size() == 3);; GaussFunction gauss(par[0], par[1], par[2]);. double chi2 = 0.;; for(unsigned int n = 0; n < theMeasurements.size(); n++) {; chi2 += ((gauss(thePositions[n]) - theMeasurements[n]) *; (gauss(thePositions[n]) - theMeasurements[n]) /; theMVariances[n]);; }. return chi2;; }. ## The user's main program ##. [example:main]. This is the main program DemoGaussSim.cpp:. ```{.cpp}; #include ""GaussFcn.h""; #include ""GaussDataGen.h""; #include ""Minuit/FunctionMinimum.h""; #include ""Minuit/MnUserParameterState.h""; #include ""Minuit/MinimumPrint.h""; #include ""Minuit/MnMigrad.h""; #include ""Minuit/MnMinos.h""; #include ""Minuit/MnContours.h""; #include ""Minuit/MnPlot.h"". #include <iostream>. int main() {. // generate the data (100 data points); GaussDataGen gdg(100);. std::vector<double> pos = gdg.positions();; std::vector<double> meas = gdg.measurements();; std::vector<double> var = gdg.variances();. // create FCN function; GaussFcn theFCN(meas, pos, var);. // create initial starting val",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:523,Usability,guid,guidance,523,"; # Foreword #. ## What M is intended to do ##. M is conceived as a tool to find the minimum value of a multi-parameter; function (the ""$\mbox{FCN}$"") and analyze the shape of the function; around the minimum. The principal application is foreseen for; statistical analysis, working on chisquare or log-likelihood functions,; to compute the best-fit parameter values and uncertainties, including; correlations between the parameters. It is especially suited to handle; difficult problems, including those which may require guidance in order; to find the correct solution. ## What M is not intended to do ##. Although M will of course solve easy problems faster than complicated; ones, it is not intended for the repeated solution of identically; parametrized problems (such as track fitting in a detector) where a; specialized program will in general be much more efficient. ## Further remarks ##. M was initially written in Fortran around 1975-1980 at CERN by Fred; James @bib-MINUIT. Its main field of usage is statistical data analysis; of experimental data recorded at CERN, but it is also used by people; doing data analysis outside CERN or outside high energy physics (HEP).; In 2002 Fred James started a project aiming to re-implement M in an; object-oriented way using . More information about recent developments, releases and installation; can be obtained from the M homepage @bib-C++MINUIT. The names of M applications are written in capital letters (e.g.; $\mbox{MIGRAD}$, $\mbox{MINOS}$, $\mbox{CONTOURS}$), the; corresponding names of the classes are written using sans-serif font; type (MnMigrad, MnMinos, MnContours). # Introduction: M basic concepts #. [sec:intro]. ## The organization of M ##. The M package acts on a multiparameter *objective function* which is; called — for historical reasons — the $\mbox{FCN}$ function (see; [howto:fcn]). This function is usually a chisquared or a log–likelihood,; but it could also be a mathematical function. The $\mbox{FCN}$; function needs ",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:2582,Usability,simpl,simple,2582,"MnContours). # Introduction: M basic concepts #. [sec:intro]. ## The organization of M ##. The M package acts on a multiparameter *objective function* which is; called — for historical reasons — the $\mbox{FCN}$ function (see; [howto:fcn]). This function is usually a chisquared or a log–likelihood,; but it could also be a mathematical function. The $\mbox{FCN}$; function needs to be written in for which M defines the pure abstract; base class FCNBase as interface. The user must define and implement the; $\mbox{FCN}$ function in a derived class from FCNBase. Sometimes; this is done by an intermediate program such as HippoDraw@bib-HippoDraw,; in which case M is being used under the control of such an intermediate; program[^1]. The value of the $\mbox{FCN}$ function will in general; depend on one or more variable parameters whose meaning is defined by; the user (or by the intermediate program), but whose trial values are; determined by M . To take a simple example, suppose the problem is to fit a polynomial; through a set of data points. Then the user would write a; $\mbox{FCN}$ which calculates the $\chi^2$ between a polynomial and; the data; the variable parameters of $\mbox{FCN}$ would be the; coefficients of the polynomials. Using objects for minimization from M ,; the user would request M to minimize the $\mbox{FCN}$ with respect; to the parameters, that is, find those values of the coefficients which; give the lowest value of chisquare. The user must therefore supply, in addition to the function to be; analyzed, via a set or sequence of M applications the instructions which; analysis is wanted. The instructions are coded in in the calling program; (main.cpp), which allows looping, conditional execution, and all the; other possibilities of , but not interactivity, since it must be; compiled before execution. ## Design aspects of M in ##. What M is:. - platform independent. - written in an object-oriented way using standard. - independent of any external package. T",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:4897,Usability,clear,clearly,4897,"M does not:. - histogramming. - data handling. - graphics. M is kept as a low-level package with optimal performance. The main usages of M are. - from a user's program (such as int main()...). - from a graphical data analysis tool such as HippoDraw@bib-HippoDraw. The most important goals of M in are. - its numerical accuracy (equivalent to its Fortran version). - its computational performance (equivalent to its Fortran version). For the design of the application programming interface (API) of M a; two-way strategy was imposed:. - a minimal required interface with minimum interaction with M objects; and with appropriate usage of the standard library (STL): the user's; implementation of the FCNBase class, initial parameter values and; uncertainties are provided by the to M user via std::vectors. - a rich interface which provides the user with more functionality; such as interaction with parameters. The core of the minimization functionality and related tools (the kernel; of M ) should be clearly separated from the user, who is interfacing via; defined user interfaces (the API). ## Internal and external parameters ##. Each of the parameters to the $\mbox{FCN}$ is defined by the user as; belonging to one of the following types:. - Freely variable: allowed to take on any value. - Variable with double sided limits: allowed to vary only between two; limits specified by the user. - Variable with single sided limits: allowed to vary only between one; upper or one lower limit specified by the user and unlimited to the; other side. - Fixed: originally defined as variable, but now taking on only the; value the parameter had at the moment it was fixed, or a value later; assigned by the user. - Constant: taking on only one value as specified by the user. When using the minimal required interface, all variable parameters are; free and unbound. The user, in their $\mbox{FCN}$, must of course be able to ""see"" all; types of defined parameters, and they therefore have access to what we",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:14963,Usability,simpl,simply,14963,"owto:errordef]) should be $1.0$. If the $\mbox{FCN}$; is a negative-log-likelihood function, then the one-standard-deviation; value for FCNBase::up() to return is $0.5$. If the $\mbox{FCN}$ is a; chisquare, but the user wants two-standard-deviation errors, then; FCNBase::up() should return $= 4.0$, etc. Note that in the usual case where M is being used to perform a fit to; some experimental data, the parameter errors will be proportional to the; uncertainty in the data, and therefore meaningful parameter errors; cannot be obtained unless the measurement errors of the data are known.; In the common case of a least-squares fit, $\mbox{FCN}$ is usually; defined as a chisquare:. $$\chi^2 (\alpha) = \sum_{i=1}^{n} (\frac{f(x_i,\alpha) - m_i)^2}{\sigma_i^2}$$. where $\alpha$ is the vector of free parameters being fitted, and the; $\sigma_i$ are the uncertainties in the individual measurements $m_i$.; If these uncertainties are not known, and are simply left out of the; calculation, then the fit may still have meaning, but not the; quantitative values of the resulting parameter errors. (Only the; relative errors of different parameters with respect to each other may; be meaningful.). If the $\sigma_i$ are all overestimated by a factor $\beta$, then the; resulting parameter errors from the fit will be overestimated by the; same factor $\beta$. ### The error matrix ###. The M processors $\mbox{MIGRAD}$ (MnMigrad, see [api:migrad]) and; HESSE (MnHesse, see [api:hesse]) (normally) produce an error matrix.; This matrix is twice the inverse of the matrix of second derivatives of; the $\mbox{FCN}$, transformed if necessary into external coordinate; space[^2], and multiplied by FCNBase::up(). Therefore, errors based on; the M error matrix take account of all the parameter correlations, but; not the non-linearities. That is, from the error matrix alone,; two-standard-deviation errors are always exactly twice as big as; one-standard-deviation errors. When the error matrix has been ca",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:32560,Usability,simpl,simply,32560,"of the minimization is transformed into the user; representable format by M . For more explanations see [api:state]. ## Input to M ##. The following input combinations to M are possible:. - $\mbox{FCN}$ + parameters + uncertainties. - $\mbox{FCN}$ with gradient + parameters + uncertainties. - $\mbox{FCN}$ + parameters + covariance. - $\mbox{FCN}$ with gradient + parameters + covariance. For each of these combinations the user can chose between a minimal; required interface (using std::vector containers) for the parameters and; uncertainties or a more functional one provided by M . If the user wants; to interact with the parameters before minimization (fixing,; adding/removing limits), the minimal required interface cannot be used. ### What the user must supply ###. The user must supply to M. - a valid implementation of the FCNBase base class. - parameters with their starting values. - expected uncertainties on the parameters. The input parameters can be simply defined via an; std::vector$<$double$>$, which means that all parameters are variables.; If the user wants fix a parameter or put limits on it before; minimization, they have to instantiate a MnUserParameters object and then; add parameters one by one, giving them a name, value, uncertainty. Once; all parameters are added to MnUserParameters, they can fix a parameter or; put limits on another one before handing them over to Minuit for; minimization. ### What the user can supply ###. Optionally the user can supply their own gradient calculator by; implementing the FCNGradientBase interface or supply a full covariance; matrix for input if one is available. The covariance matrix can be; supplied in form of a std::vector$<$double$>$ in packed storage format; (upper triangular), or in a more user-friendly way by using the; interface provided by the MnUserCovariance. ## Running a M minimization ##. Two use cases are addressed for minimization:. - The user just wants the function to be minimized in one go. - The user ",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:33365,Usability,user-friendly,user-friendly,33365,"## What the user must supply ###. The user must supply to M. - a valid implementation of the FCNBase base class. - parameters with their starting values. - expected uncertainties on the parameters. The input parameters can be simply defined via an; std::vector$<$double$>$, which means that all parameters are variables.; If the user wants fix a parameter or put limits on it before; minimization, they have to instantiate a MnUserParameters object and then; add parameters one by one, giving them a name, value, uncertainty. Once; all parameters are added to MnUserParameters, they can fix a parameter or; put limits on another one before handing them over to Minuit for; minimization. ### What the user can supply ###. Optionally the user can supply their own gradient calculator by; implementing the FCNGradientBase interface or supply a full covariance; matrix for input if one is available. The covariance matrix can be; supplied in form of a std::vector$<$double$>$ in packed storage format; (upper triangular), or in a more user-friendly way by using the; interface provided by the MnUserCovariance. ## Running a M minimization ##. Two use cases are addressed for minimization:. - The user just wants the function to be minimized in one go. - The user wants to minimize the $\mbox{FCN}$ in several; minimization steps, re-using the result of the preceeding; minimization in the next step and change parameters in between; (fix/release/put limits on them, etc.). How M minimizations can be performed is shown in [example:main]. ### Direct usage of minimizers ###. Minimizers such as the VariableMetricMinimizer are designed as; state-less minimization engines, which means that they do not depend on; the current function and its parameters. Any $\mbox{FCN}$ function; can be minimized with the same minimizer. The interface is restricted to; minimization and no parameter interaction is possible. ### Using an application (MnMigrad) ###. MnMigrad uses the VariableMetricMinimizer for minimizati",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:36406,Usability,simpl,simply,36406,"M when running into troubles. Problems can be:. - a bug in M. - an error in the $\mbox{FCN}$. - a highly difficult problem (usually strong correlations among; parameters). - floating–point precision. ## The output from minimization ##. ### The FunctionMinimum ###. The output of the minimizers is the FunctionMinimum. The FunctionMinimum; contains the result of the minimization in both internal parameter; representation and external parameter representation. ### User representable format: MnUserParameterState ###. On request, the result of the minimization is transformed into a user; representable format for parameters and errors, the; MnUserParameterState. ### Access values, errors, covariance ###. The result can be accessed via methods like; MnUserParameterState::value(unsigned int n) and; MnUserParameterState::error(unsigned int n), where $n$ is the index of; the parameter in the list of parameters defined by the user. ### Printout of the result ###. The FunctionMinimum can be printed on the output simply via std::cout.; It will print both the internal and external state, that is parameters,; errors and the covariance matrix (if available). It also tells the user; if M did converge or not by issuing an appropriate message. If a; covariance matrix is available, the global correlation coefficients are; printed as well. ### Global correlation coefficients ###. The global correlation coefficient for parameter $n$ is a number between; zero and one which gives the correlation between parameter $n$ and that; linear combination of all other parameters which is most strongly; correlated with $n$. # M application programming interface (API) #. [api:api]. ## FunctionMinimum ##. [api:fm] The FunctionMinimum is the output of the minimizers and; contains the minimization result. The state at the minimum is available; both in internal and external representations. For the external; representations the return methods. - FunctionMinimum::userState(),. - FunctionMinimum::userParamete",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:48406,Usability,simpl,simplex,48406,"point, double low, double high) ###. Scans the value of the user function by varying parameter number; $\mbox{par}$, leaving all other parameters fixed at the current; value. If $\mbox{par}$ is not specified, all variable parameters are; scanned in sequence. The number of points $\mbox{npoints}$ in the; scan is 40 by default, and cannot exceed 100. The range of the scan is; by default 2 standard deviations on each side of the current best value,; but can be specified as from $\mbox{low}$ to $\mbox{high}$.; After each scan, if a new minimum is found, the best parameter values; are retained as start values for future scans or minimizations. The; curve resulting from each scan can be plotted on the output terminal; using MnPlot [api:plot] in order to show the approximate behaviour of; the function. ### ScanMinimizer ###. Although the $\mbox{SCAN}$ method is not intended for minimization; it can be used as a minimizer in its most primitive form. ## MnSimplex and SimplexMinimizer ##. [api:simplex]. $\mbox{SIMPLEX}$ is a function minimization method using the simplex; method of Nelder and Mead. MnSimplex provides minimization of the; function by the method of $\mbox{SIMPLEX}$ and the functionality for; parameters interaction. It also retains the result from the last; minimization in case the user may want to do subsequent minimization; steps with parameter interactions in between the minimization requests.; The minimization is done by the SimplexMinimizer. Minimization of the; function can be done by directly using the SimplexMinimizer if no; parameters interaction is required. As $\mbox{SIMPLEX}$ is a; stepping method it does not produce a covariance matrix. ### MnSimplex(const FCNBase&, const std::vector$<$double$>$&,\; const std::vector$<$double$>$&, unsigned int) ###. Constructor for the minimal required interface: $\mbox{FCN}$ and; starting values for parameters and uncertainties. Optional the strategy; level in MnStrategy can be specified. ### MnSimplex(const FCNBase",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:48477,Usability,simpl,simplex,48477,"the user function by varying parameter number; $\mbox{par}$, leaving all other parameters fixed at the current; value. If $\mbox{par}$ is not specified, all variable parameters are; scanned in sequence. The number of points $\mbox{npoints}$ in the; scan is 40 by default, and cannot exceed 100. The range of the scan is; by default 2 standard deviations on each side of the current best value,; but can be specified as from $\mbox{low}$ to $\mbox{high}$.; After each scan, if a new minimum is found, the best parameter values; are retained as start values for future scans or minimizations. The; curve resulting from each scan can be plotted on the output terminal; using MnPlot [api:plot] in order to show the approximate behaviour of; the function. ### ScanMinimizer ###. Although the $\mbox{SCAN}$ method is not intended for minimization; it can be used as a minimizer in its most primitive form. ## MnSimplex and SimplexMinimizer ##. [api:simplex]. $\mbox{SIMPLEX}$ is a function minimization method using the simplex; method of Nelder and Mead. MnSimplex provides minimization of the; function by the method of $\mbox{SIMPLEX}$ and the functionality for; parameters interaction. It also retains the result from the last; minimization in case the user may want to do subsequent minimization; steps with parameter interactions in between the minimization requests.; The minimization is done by the SimplexMinimizer. Minimization of the; function can be done by directly using the SimplexMinimizer if no; parameters interaction is required. As $\mbox{SIMPLEX}$ is a; stepping method it does not produce a covariance matrix. ### MnSimplex(const FCNBase&, const std::vector$<$double$>$&,\; const std::vector$<$double$>$&, unsigned int) ###. Constructor for the minimal required interface: $\mbox{FCN}$ and; starting values for parameters and uncertainties. Optional the strategy; level in MnStrategy can be specified. ### MnSimplex(const FCNBase&, const MnUserParameters&,\; unsigned int) ###. Constru",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:66534,Usability,guid,guided,66534,"ts should be accurate and very close to those you would have got; without limits. In other cases (which should be more common, since; otherwise you wouldn't need limits), the very meaning of parameter; errors becomes problematic. Mathematically, since the limit is an; absolute constraint on the parameter, a parameter at its limit has no; error, at least in one direction. The error matrix, which can assign; only symmetric errors, then becomes essentially meaningless. On the; other hand, the $\mbox{MINOS}$ analysis is still meaningful, at; least in principle, as long as $\mbox{MIGRAD}$ (which is called; internally by $\mbox{MINOS}$) does not get blocked at a limit.; Unfortunately, the user has no control over this aspect of the; $\mbox{MINOS}$ calculation, although it is possible to get enough; printout from the $\mbox{MINOS}$ result to be able to determine; whether the results are reliable or not. ## Fixing and releasing parameters ##. When M needs to be guided to the ""right"" minimum, often the best way to; do this is with the methods e.g. MnMigrad::fix(...) and; MnMigrad::release(...). That is, suppose you have a problem with ten; free parameters, and when you minimize with respect to all at once, M; goes to an unphysical solution characterized by an unphysical or; unwanted value of parameter number four. One way to avoid this is to fix; parameter four at a ""good"" value (not necessarily the best, since you; presumably don't know that yet), and minimize with respect to the; others. Then release parameter four and minimize again. If the problem; admits a ""good"" physical solution, you will normally find it this way.; If it doesn't work, you may see what is wrong by the following sequence; (where $\mbox{xxx}$ is the expected physical value for parameter; four):. MnMigrad migrad(...);; migrad.setValue(4, xxx);; migrad.fix(4);; FunctionMinimum min = migrad();; migrad.release(4);; MnScan scan(...);; std::vector<std::pair<double, double> > points = scan(4);. where $\mbox{SC",MatchSource.DOCS,documentation/minuit2/Minuit2.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/abstract.md:113,Energy Efficiency,power,powerful,113,"---------------------------------------. **Abstract**. ROOT is a software framework for data analysis and I/O: a powerful tool to cope; with the demanding tasks typical of state of the art scientific data analysis.; Among its prominent features are an advanced graphical user; interface, ideal for interactive analysis, an interpreter for the C++; programming language, for rapid and efficient prototyping and a; persistency mechanism for C++ objects, used also to write every year; petabytes of data recorded by the Large Hadron Collider experiments.; This introductory guide illustrates the main features of ROOT which are; relevant for the typical problems of data analysis: input and plotting of data; from measurements and fitting of analytical functions. *Original Authors*; - D. Piparo; - G. Quast; - M. Zeise. ",MatchSource.DOCS,documentation/primer/abstract.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/abstract.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/abstract.md:384,Energy Efficiency,efficient,efficient,384,"---------------------------------------. **Abstract**. ROOT is a software framework for data analysis and I/O: a powerful tool to cope; with the demanding tasks typical of state of the art scientific data analysis.; Among its prominent features are an advanced graphical user; interface, ideal for interactive analysis, an interpreter for the C++; programming language, for rapid and efficient prototyping and a; persistency mechanism for C++ objects, used also to write every year; petabytes of data recorded by the Large Hadron Collider experiments.; This introductory guide illustrates the main features of ROOT which are; relevant for the typical problems of data analysis: input and plotting of data; from measurements and fitting of analytical functions. *Original Authors*; - D. Piparo; - G. Quast; - M. Zeise. ",MatchSource.DOCS,documentation/primer/abstract.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/abstract.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/abstract.md:277,Integrability,interface,interface,277,"---------------------------------------. **Abstract**. ROOT is a software framework for data analysis and I/O: a powerful tool to cope; with the demanding tasks typical of state of the art scientific data analysis.; Among its prominent features are an advanced graphical user; interface, ideal for interactive analysis, an interpreter for the C++; programming language, for rapid and efficient prototyping and a; persistency mechanism for C++ objects, used also to write every year; petabytes of data recorded by the Large Hadron Collider experiments.; This introductory guide illustrates the main features of ROOT which are; relevant for the typical problems of data analysis: input and plotting of data; from measurements and fitting of analytical functions. *Original Authors*; - D. Piparo; - G. Quast; - M. Zeise. ",MatchSource.DOCS,documentation/primer/abstract.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/abstract.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/abstract.md:571,Usability,guid,guide,571,"---------------------------------------. **Abstract**. ROOT is a software framework for data analysis and I/O: a powerful tool to cope; with the demanding tasks typical of state of the art scientific data analysis.; Among its prominent features are an advanced graphical user; interface, ideal for interactive analysis, an interpreter for the C++; programming language, for rapid and efficient prototyping and a; persistency mechanism for C++ objects, used also to write every year; petabytes of data recorded by the Large Hadron Collider experiments.; This introductory guide illustrates the main features of ROOT which are; relevant for the typical problems of data analysis: input and plotting of data; from measurements and fitting of analytical functions. *Original Authors*; - D. Piparo; - G. Quast; - M. Zeise. ",MatchSource.DOCS,documentation/primer/abstract.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/abstract.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/concludingRemarks.md:567,Deployability,install,installation,567,"# Concluding Remarks #. This is the end of our guided tour for beginners through ROOT. There is; still a lot coming to mind to be said, but by now you are experienced; enough to use the ROOT documentation, most importantly the **[ROOT home; page](http://root.cern.ch)** and the **[ROOT reference; guide](https://root.cern/doc/master/)** with the; documentation of all ROOT classes, or the **[ROOT users; manual](https://root.cern/manual/)**. A very useful way for you to continue exploring ROOT is to study the; examples in the sub-directory `tutorials/` of any ROOT installation. There are some powerful features of ROOT which were not treated in this; document, e.g. packages named RooFit and RooStats providing an advanced; framework for model building, fitting and statistical analysis. The ROOT; namespace `TMVA` offers multi-variate analysis tools including an artificial; neural network and many other advanced tools for classification; problems. The remarkable ability of ROOT to handle large data volumes; was already mentioned in this guide, implemented through the class; `TTree`. But there is still much more for you to explore!. **End of this guide ... but hopefully not of your interaction with ROOT !**; ",MatchSource.DOCS,documentation/primer/concludingRemarks.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/concludingRemarks.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/concludingRemarks.md:596,Energy Efficiency,power,powerful,596,"# Concluding Remarks #. This is the end of our guided tour for beginners through ROOT. There is; still a lot coming to mind to be said, but by now you are experienced; enough to use the ROOT documentation, most importantly the **[ROOT home; page](http://root.cern.ch)** and the **[ROOT reference; guide](https://root.cern/doc/master/)** with the; documentation of all ROOT classes, or the **[ROOT users; manual](https://root.cern/manual/)**. A very useful way for you to continue exploring ROOT is to study the; examples in the sub-directory `tutorials/` of any ROOT installation. There are some powerful features of ROOT which were not treated in this; document, e.g. packages named RooFit and RooStats providing an advanced; framework for model building, fitting and statistical analysis. The ROOT; namespace `TMVA` offers multi-variate analysis tools including an artificial; neural network and many other advanced tools for classification; problems. The remarkable ability of ROOT to handle large data volumes; was already mentioned in this guide, implemented through the class; `TTree`. But there is still much more for you to explore!. **End of this guide ... but hopefully not of your interaction with ROOT !**; ",MatchSource.DOCS,documentation/primer/concludingRemarks.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/concludingRemarks.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/concludingRemarks.md:47,Usability,guid,guided,47,"# Concluding Remarks #. This is the end of our guided tour for beginners through ROOT. There is; still a lot coming to mind to be said, but by now you are experienced; enough to use the ROOT documentation, most importantly the **[ROOT home; page](http://root.cern.ch)** and the **[ROOT reference; guide](https://root.cern/doc/master/)** with the; documentation of all ROOT classes, or the **[ROOT users; manual](https://root.cern/manual/)**. A very useful way for you to continue exploring ROOT is to study the; examples in the sub-directory `tutorials/` of any ROOT installation. There are some powerful features of ROOT which were not treated in this; document, e.g. packages named RooFit and RooStats providing an advanced; framework for model building, fitting and statistical analysis. The ROOT; namespace `TMVA` offers multi-variate analysis tools including an artificial; neural network and many other advanced tools for classification; problems. The remarkable ability of ROOT to handle large data volumes; was already mentioned in this guide, implemented through the class; `TTree`. But there is still much more for you to explore!. **End of this guide ... but hopefully not of your interaction with ROOT !**; ",MatchSource.DOCS,documentation/primer/concludingRemarks.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/concludingRemarks.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/concludingRemarks.md:297,Usability,guid,guide,297,"# Concluding Remarks #. This is the end of our guided tour for beginners through ROOT. There is; still a lot coming to mind to be said, but by now you are experienced; enough to use the ROOT documentation, most importantly the **[ROOT home; page](http://root.cern.ch)** and the **[ROOT reference; guide](https://root.cern/doc/master/)** with the; documentation of all ROOT classes, or the **[ROOT users; manual](https://root.cern/manual/)**. A very useful way for you to continue exploring ROOT is to study the; examples in the sub-directory `tutorials/` of any ROOT installation. There are some powerful features of ROOT which were not treated in this; document, e.g. packages named RooFit and RooStats providing an advanced; framework for model building, fitting and statistical analysis. The ROOT; namespace `TMVA` offers multi-variate analysis tools including an artificial; neural network and many other advanced tools for classification; problems. The remarkable ability of ROOT to handle large data volumes; was already mentioned in this guide, implemented through the class; `TTree`. But there is still much more for you to explore!. **End of this guide ... but hopefully not of your interaction with ROOT !**; ",MatchSource.DOCS,documentation/primer/concludingRemarks.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/concludingRemarks.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/concludingRemarks.md:1045,Usability,guid,guide,1045,"# Concluding Remarks #. This is the end of our guided tour for beginners through ROOT. There is; still a lot coming to mind to be said, but by now you are experienced; enough to use the ROOT documentation, most importantly the **[ROOT home; page](http://root.cern.ch)** and the **[ROOT reference; guide](https://root.cern/doc/master/)** with the; documentation of all ROOT classes, or the **[ROOT users; manual](https://root.cern/manual/)**. A very useful way for you to continue exploring ROOT is to study the; examples in the sub-directory `tutorials/` of any ROOT installation. There are some powerful features of ROOT which were not treated in this; document, e.g. packages named RooFit and RooStats providing an advanced; framework for model building, fitting and statistical analysis. The ROOT; namespace `TMVA` offers multi-variate analysis tools including an artificial; neural network and many other advanced tools for classification; problems. The remarkable ability of ROOT to handle large data volumes; was already mentioned in this guide, implemented through the class; `TTree`. But there is still much more for you to explore!. **End of this guide ... but hopefully not of your interaction with ROOT !**; ",MatchSource.DOCS,documentation/primer/concludingRemarks.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/concludingRemarks.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/concludingRemarks.md:1156,Usability,guid,guide,1156,"# Concluding Remarks #. This is the end of our guided tour for beginners through ROOT. There is; still a lot coming to mind to be said, but by now you are experienced; enough to use the ROOT documentation, most importantly the **[ROOT home; page](http://root.cern.ch)** and the **[ROOT reference; guide](https://root.cern/doc/master/)** with the; documentation of all ROOT classes, or the **[ROOT users; manual](https://root.cern/manual/)**. A very useful way for you to continue exploring ROOT is to study the; examples in the sub-directory `tutorials/` of any ROOT installation. There are some powerful features of ROOT which were not treated in this; document, e.g. packages named RooFit and RooStats providing an advanced; framework for model building, fitting and statistical analysis. The ROOT; namespace `TMVA` offers multi-variate analysis tools including an artificial; neural network and many other advanced tools for classification; problems. The remarkable ability of ROOT to handle large data volumes; was already mentioned in this guide, implemented through the class; `TTree`. But there is still much more for you to explore!. **End of this guide ... but hopefully not of your interaction with ROOT !**; ",MatchSource.DOCS,documentation/primer/concludingRemarks.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/concludingRemarks.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md:9422,Availability,avail,available,9422,"me; histograms in `SlaveBegin()` and adds them to the instance `fOutput`,; which is of the class `TList` [^6]. The final processing in; `Terminate()` allows to access histograms and store, display or save; them as pictures. This is shown in the example via the `TList`; `fOutput`. See the commented listing below for more details; most of the; text is actually comments generated automatically by; `TTree::MakeSelector`. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/MySelector.C; ```. ### *For power-users:* Multi-core processing with `PROOF lite` ###. The processing of n-tuples via a selector function of type `TSelector`; through `TChain::Process()`, as described at the end of the previous; section, offers an additional advantage in particular for very large; data sets: on distributed systems or multi-core architectures, portions; of data can be processed in parallel, thus significantly reducing the; execution time. On modern computers with multi-core CPUs or; hardware-threading enabled, this allows a much faster turnaround of; analyses, since all the available CPU power is used. On distributed systems, a PROOF server and worker nodes have to be set; up, as described in detail in the ROOT documentation. On a single; computer with multiple cores, `PROOF lite` can be used instead. Try the; following little macro, `RunMySelector.C`, which contains two extra; lines compared to the example above (adjust the number of workers; according to the number of CPU cores):. ``` {.cpp}; {// set up a TChain; TChain *ch=new TChain(""cond_data"", ""My Chain for Example N-Tuple"");; ch->Add(""conductivity_experiment*.root"");; // eventually, start Proof Lite on cores; TProof::Open(""workers=4"");; ch->SetProof();; ch->Process(""MySelector.C+"");}; ```. The first command, `TProof::Open(const char*)` starts a local PROOF; server (if no arguments are specified, all cores will be used), and the; command `ch->SetProof();` enables processing of the chain using PROOF.; Now, when issuing the command `ch->Process(""M",MatchSource.DOCS,documentation/primer/filio.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md:10617,Availability,avail,available,10617,"le; computer with multiple cores, `PROOF lite` can be used instead. Try the; following little macro, `RunMySelector.C`, which contains two extra; lines compared to the example above (adjust the number of workers; according to the number of CPU cores):. ``` {.cpp}; {// set up a TChain; TChain *ch=new TChain(""cond_data"", ""My Chain for Example N-Tuple"");; ch->Add(""conductivity_experiment*.root"");; // eventually, start Proof Lite on cores; TProof::Open(""workers=4"");; ch->SetProof();; ch->Process(""MySelector.C+"");}; ```. The first command, `TProof::Open(const char*)` starts a local PROOF; server (if no arguments are specified, all cores will be used), and the; command `ch->SetProof();` enables processing of the chain using PROOF.; Now, when issuing the command `ch->Process(""MySelector.C+);`, the code; in `MySelector.C` is compiled and executed on each slave node. The; methods `Begin()` and `Terminate()` are executed on the master only. The; list of n-tuple files is analysed, and portions of the data are assigned; to the available slave processes. Histograms booked in `SlaveBegin()`; exist in the processes on the slave nodes, and are filled accordingly.; Upon termination, the PROOF master collects the histograms from the; slaves and merges them. In `Terminate()` all merged histograms are; available and can be inspected, analysed or stored. The histograms are; handled via the instances `fOutput` of class `TList` in each slave; process, and can be retrieved from this list after merging in; `Terminate`. To explore the power of this mechanism, generate some very large; n-tuples using the script from the section; [Storing Arbitrary N-tuples](#storing-arbitrary-n-tuples) -; you could try 10 000 000 events (this; results in a large n-tuple of about 160 MByte in size). You could also; generate a large number of files and use wildcards to add the to the; `TChain`. Now execute: `> root -l RunMySelector.C` and watch what; happens:. ``` {.cpp}; Processing RunMySelector.C...; +++ Start",MatchSource.DOCS,documentation/primer/filio.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md:10890,Availability,avail,available,10890,"(""cond_data"", ""My Chain for Example N-Tuple"");; ch->Add(""conductivity_experiment*.root"");; // eventually, start Proof Lite on cores; TProof::Open(""workers=4"");; ch->SetProof();; ch->Process(""MySelector.C+"");}; ```. The first command, `TProof::Open(const char*)` starts a local PROOF; server (if no arguments are specified, all cores will be used), and the; command `ch->SetProof();` enables processing of the chain using PROOF.; Now, when issuing the command `ch->Process(""MySelector.C+);`, the code; in `MySelector.C` is compiled and executed on each slave node. The; methods `Begin()` and `Terminate()` are executed on the master only. The; list of n-tuple files is analysed, and portions of the data are assigned; to the available slave processes. Histograms booked in `SlaveBegin()`; exist in the processes on the slave nodes, and are filled accordingly.; Upon termination, the PROOF master collects the histograms from the; slaves and merges them. In `Terminate()` all merged histograms are; available and can be inspected, analysed or stored. The histograms are; handled via the instances `fOutput` of class `TList` in each slave; process, and can be retrieved from this list after merging in; `Terminate`. To explore the power of this mechanism, generate some very large; n-tuples using the script from the section; [Storing Arbitrary N-tuples](#storing-arbitrary-n-tuples) -; you could try 10 000 000 events (this; results in a large n-tuple of about 160 MByte in size). You could also; generate a large number of files and use wildcards to add the to the; `TChain`. Now execute: `> root -l RunMySelector.C` and watch what; happens:. ``` {.cpp}; Processing RunMySelector.C...; +++ Starting PROOF-Lite with 4 workers +++; Opening connections to workers: OK (4 workers); Setting up worker servers: OK (4 workers); PROOF set to parallel mode (4 workers). Info in <TProofLite::SetQueryRunning>: starting query: 1; Info in <TProofQueryResult::SetRunning>: nwrks: 4; Info in <TUnixSystem::ACLiC>: c",MatchSource.DOCS,documentation/primer/filio.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md:13959,Availability,redundant,redundant,13959,"typical data analysis; programs limited by the I/O speed (for example the latencies implied by; reading data from a hard drive). It is therefore expected that this; limitation cannot be eliminated with the usage of any parallel analysis; toolkit. ### Optimisation Regarding N-tuples ###. ROOT automatically applies compression algorithms on n-tuples to reduce; the memory consumption. A value that is in most cases the same will; consume only small space on your disk (but it has to be decompressed on; reading). Nevertheless, you should think about the design of your; n-tuples and your analyses as soon as the processing time exceeds some; minutes. - Try to keep your n-tuples simple and use appropriate variable types.; If your measurement has only a limited precision, it is needless to; store it with double precision. - Experimental conditions that do not change with every single; measurement should be stored in a separate tree. Although the; compression can handle redundant values, the processing time; increase with every variable that has to be filled. - The function `SetCacheSize(long)` specifies the size of the cache; for reading a `TTree` object from a file. The default value is 30MB.; A manual increase may help in certain situations. Please note that; the caching mechanism can cover only one `TTree` object per `TFile`; object. - You can select the branches to be covered by the caching algorithm; with `AddBranchToCache` and deactivate unneeded branches with; `SetBranchStatus`. This mechanism can result in a significant; speed-up for simple operations on trees with many branches. - You can measure the performance easily with `TTreePerfStats`. The; ROOT documentation on this class also includes an introductory; example. For example, `TTreePerfStats` can show you that it is; beneficial to store meta data and payload data separately, i.e.; write the meta data tree in a bulk to a file at the end of your job; instead of writing both trees interleaved. [^6]: The usage of `f",MatchSource.DOCS,documentation/primer/filio.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md:6392,Energy Efficiency,power,powerful,6392,"type of a branch in ROOT:. type size C++ identifier; ------------------ -------- --------------- ------------; signed integer 32 bit int I; 64 bit long L; unsigned integer 32 bit unsigned int i; 64 bit unsigned long l; floating point 32 bit float F; 64 bit double D; boolean - bool O. ### Processing N-tuples Spanning over Several Files ###. Usually n-tuples or trees span over many files and it would be difficult; to add them manually. ROOT thus kindly provides a helper class in the; form of `TChain`. Its usage is shown in the following macro which is; very similar to the previous example. The constructor of a `TChain`; takes the name of the `TTree` (or `TNuple`) as an argument. The files; are added with the function `Add(fileName)`, where one can also use; wild-cards as shown in the example. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/read_ntuple_with_chain.C; ```. ### *For the advanced user:* Processing trees with a selector script ###. Another very general and powerful way of processing a `TChain` is; provided via the method `TChain::Process()`. This method takes as; arguments an instance of a -- user-implemented-- class of type; `TSelector`, and -- optionally -- the number of entries and the first; entry to be processed. A template for the class `TSelector` is provided; by the method `TTree::MakeSelector`, as is shown in the little macro; `makeSelector.C` below. It opens the n-tuple `conductivity_experiment.root` from the example; above and creates from it the header file `MySelector.h` and a template; to insert your own analysis code, `MySelector.C`.; \newpage. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/makeMySelector.C; ```. The template contains the entry points `Begin()` and `SlaveBegin()`; called before processing of the `TChain` starts, `Process()` called for; every entry of the chain, and `SlaveTerminate()` and `Terminate()`; called after the last entry has been processed. Typically,; initialization like booking of histograms is performed in; `SlaveBegin()`, the analy",MatchSource.DOCS,documentation/primer/filio.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md:8853,Energy Efficiency,power,power-users,8853,"; `MySelector.C`. The example is executed with the following sequence of; commands:. ``` {.cpp}; > TChain *ch=new TChain(""cond_data"", ""Chain for Example N-Tuple"");; > ch->Add(""conductivity_experiment*.root"");; > ch->Process(""MySelector.C+"");; ```. As usual, the ""`+`"" appended to the name of the macro to be executed; initiates the compilation of the `MySelector.C` with the system compiler; in order to improve performance. The code in `MySelector.C`, shown in the listing below, books some; histograms in `SlaveBegin()` and adds them to the instance `fOutput`,; which is of the class `TList` [^6]. The final processing in; `Terminate()` allows to access histograms and store, display or save; them as pictures. This is shown in the example via the `TList`; `fOutput`. See the commented listing below for more details; most of the; text is actually comments generated automatically by; `TTree::MakeSelector`. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/MySelector.C; ```. ### *For power-users:* Multi-core processing with `PROOF lite` ###. The processing of n-tuples via a selector function of type `TSelector`; through `TChain::Process()`, as described at the end of the previous; section, offers an additional advantage in particular for very large; data sets: on distributed systems or multi-core architectures, portions; of data can be processed in parallel, thus significantly reducing the; execution time. On modern computers with multi-core CPUs or; hardware-threading enabled, this allows a much faster turnaround of; analyses, since all the available CPU power is used. On distributed systems, a PROOF server and worker nodes have to be set; up, as described in detail in the ROOT documentation. On a single; computer with multiple cores, `PROOF lite` can be used instead. Try the; following little macro, `RunMySelector.C`, which contains two extra; lines compared to the example above (adjust the number of workers; according to the number of CPU cores):. ``` {.cpp}; {// set up a TChain; TChai",MatchSource.DOCS,documentation/primer/filio.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md:9436,Energy Efficiency,power,power,9436,"me; histograms in `SlaveBegin()` and adds them to the instance `fOutput`,; which is of the class `TList` [^6]. The final processing in; `Terminate()` allows to access histograms and store, display or save; them as pictures. This is shown in the example via the `TList`; `fOutput`. See the commented listing below for more details; most of the; text is actually comments generated automatically by; `TTree::MakeSelector`. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/MySelector.C; ```. ### *For power-users:* Multi-core processing with `PROOF lite` ###. The processing of n-tuples via a selector function of type `TSelector`; through `TChain::Process()`, as described at the end of the previous; section, offers an additional advantage in particular for very large; data sets: on distributed systems or multi-core architectures, portions; of data can be processed in parallel, thus significantly reducing the; execution time. On modern computers with multi-core CPUs or; hardware-threading enabled, this allows a much faster turnaround of; analyses, since all the available CPU power is used. On distributed systems, a PROOF server and worker nodes have to be set; up, as described in detail in the ROOT documentation. On a single; computer with multiple cores, `PROOF lite` can be used instead. Try the; following little macro, `RunMySelector.C`, which contains two extra; lines compared to the example above (adjust the number of workers; according to the number of CPU cores):. ``` {.cpp}; {// set up a TChain; TChain *ch=new TChain(""cond_data"", ""My Chain for Example N-Tuple"");; ch->Add(""conductivity_experiment*.root"");; // eventually, start Proof Lite on cores; TProof::Open(""workers=4"");; ch->SetProof();; ch->Process(""MySelector.C+"");}; ```. The first command, `TProof::Open(const char*)` starts a local PROOF; server (if no arguments are specified, all cores will be used), and the; command `ch->SetProof();` enables processing of the chain using PROOF.; Now, when issuing the command `ch->Process(""M",MatchSource.DOCS,documentation/primer/filio.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md:11121,Energy Efficiency,power,power,11121,"), and the; command `ch->SetProof();` enables processing of the chain using PROOF.; Now, when issuing the command `ch->Process(""MySelector.C+);`, the code; in `MySelector.C` is compiled and executed on each slave node. The; methods `Begin()` and `Terminate()` are executed on the master only. The; list of n-tuple files is analysed, and portions of the data are assigned; to the available slave processes. Histograms booked in `SlaveBegin()`; exist in the processes on the slave nodes, and are filled accordingly.; Upon termination, the PROOF master collects the histograms from the; slaves and merges them. In `Terminate()` all merged histograms are; available and can be inspected, analysed or stored. The histograms are; handled via the instances `fOutput` of class `TList` in each slave; process, and can be retrieved from this list after merging in; `Terminate`. To explore the power of this mechanism, generate some very large; n-tuples using the script from the section; [Storing Arbitrary N-tuples](#storing-arbitrary-n-tuples) -; you could try 10 000 000 events (this; results in a large n-tuple of about 160 MByte in size). You could also; generate a large number of files and use wildcards to add the to the; `TChain`. Now execute: `> root -l RunMySelector.C` and watch what; happens:. ``` {.cpp}; Processing RunMySelector.C...; +++ Starting PROOF-Lite with 4 workers +++; Opening connections to workers: OK (4 workers); Setting up worker servers: OK (4 workers); PROOF set to parallel mode (4 workers). Info in <TProofLite::SetQueryRunning>: starting query: 1; Info in <TProofQueryResult::SetRunning>: nwrks: 4; Info in <TUnixSystem::ACLiC>: creating shared library; ~/DivingROOT/macros/MySelector_C.so; *==* ----- Begin of Job ----- Date/Time = Wed Feb 15 23:00:04 2012; Looking up for exact location of files: OK (4 files); Looking up for exact location of files: OK (4 files); Info in <TPacketizerAdaptive::TPacketizerAdaptive>:; Setting max number of workers per node to 4; Validating",MatchSource.DOCS,documentation/primer/filio.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md:13338,Energy Efficiency,reduce,reduce,13338,"e files 1.000000; Info in <TCanvas::Print>:; file ResistanceDistribution.png has been created; *==* ----- End of Job ----- Date/Time = Wed Feb 15 23:00:08 2012; Lite-0: all output objects have been merged; ```. Log files of the whole processing chain are kept in the directory; `~.proof` for each worker node. This is very helpful for debugging or if; something goes wrong. As the method described here also works without; using PROOF, the development work on an analysis script can be done in; the standard way on a small subset of the data, and only for the full; processing one would use parallelism via PROOF. It is worth to remind the reader that the speed of typical data analysis; programs limited by the I/O speed (for example the latencies implied by; reading data from a hard drive). It is therefore expected that this; limitation cannot be eliminated with the usage of any parallel analysis; toolkit. ### Optimisation Regarding N-tuples ###. ROOT automatically applies compression algorithms on n-tuples to reduce; the memory consumption. A value that is in most cases the same will; consume only small space on your disk (but it has to be decompressed on; reading). Nevertheless, you should think about the design of your; n-tuples and your analyses as soon as the processing time exceeds some; minutes. - Try to keep your n-tuples simple and use appropriate variable types.; If your measurement has only a limited precision, it is needless to; store it with double precision. - Experimental conditions that do not change with every single; measurement should be stored in a separate tree. Although the; compression can handle redundant values, the processing time; increase with every variable that has to be filled. - The function `SetCacheSize(long)` specifies the size of the cache; for reading a `TTree` object from a file. The default value is 30MB.; A manual increase may help in certain situations. Please note that; the caching mechanism can cover only one `TTree` object per `TFi",MatchSource.DOCS,documentation/primer/filio.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md:13357,Energy Efficiency,consumption,consumption,13357,"e files 1.000000; Info in <TCanvas::Print>:; file ResistanceDistribution.png has been created; *==* ----- End of Job ----- Date/Time = Wed Feb 15 23:00:08 2012; Lite-0: all output objects have been merged; ```. Log files of the whole processing chain are kept in the directory; `~.proof` for each worker node. This is very helpful for debugging or if; something goes wrong. As the method described here also works without; using PROOF, the development work on an analysis script can be done in; the standard way on a small subset of the data, and only for the full; processing one would use parallelism via PROOF. It is worth to remind the reader that the speed of typical data analysis; programs limited by the I/O speed (for example the latencies implied by; reading data from a hard drive). It is therefore expected that this; limitation cannot be eliminated with the usage of any parallel analysis; toolkit. ### Optimisation Regarding N-tuples ###. ROOT automatically applies compression algorithms on n-tuples to reduce; the memory consumption. A value that is in most cases the same will; consume only small space on your disk (but it has to be decompressed on; reading). Nevertheless, you should think about the design of your; n-tuples and your analyses as soon as the processing time exceeds some; minutes. - Try to keep your n-tuples simple and use appropriate variable types.; If your measurement has only a limited precision, it is needless to; store it with double precision. - Experimental conditions that do not change with every single; measurement should be stored in a separate tree. Although the; compression can handle redundant values, the processing time; increase with every variable that has to be filled. - The function `SetCacheSize(long)` specifies the size of the cache; for reading a `TTree` object from a file. The default value is 30MB.; A manual increase may help in certain situations. Please note that; the caching mechanism can cover only one `TTree` object per `TFi",MatchSource.DOCS,documentation/primer/filio.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md:2486,Integrability,depend,depends,2486,"_INCLUDE_FILE macros/read_from_file.C; ```. ## N-tuples in ROOT ##. ### Storing simple N-tuples ###. Up to now we have seen how to manipulate input read from ASCII files.; ROOT offers the possibility to do much better than that, with its own; n-tuple classes. Among the many advantages provided by these classes one; could cite. - Optimised disk I/O. - Possibility to store many n-tuple rows. - Write the n-tuples in ROOT files. - Interactive inspection with `TBrowser`. - Store not only numbers, but also *objects* in the columns. In this section we will discuss briefly the `TNtuple` class, which is a; simplified version of the `TTree` class. A ROOT `TNtuple` object can; store rows of float entries. Let's tackle the problem according to the; usual strategy commenting a minimal example. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/write_ntuple_to_file.C; ```. This data written to this example n-tuple represents, in the statistical; sense, three independent variables (Potential or Voltage, Pressure and; Temperature), and one variable (Current) which depends on the others; according to very simple laws, and an additional Gaussian smearing. This; set of variables mimics a measurement of an electrical resistance while; varying pressure and temperature. Imagine your task now consists in finding the relations among the; variables -- of course without knowing the code used to generate them.; You will see that the possibilities of the `NTuple` class enable you to; perform this analysis task. Open the ROOT file (`cond_data.root`); written by the macro above in an interactive session and use a; `TBrowser` to interactively inspect it:. ``` {.cpp}; root[0] TBrowser b; ```; You find the columns of your n-tuple written as *leafs*. Simply clicking; on them you can obtain histograms of the variables!. Next, try the following commands at the shell prompt and in the; interactive ROOT shell, respectively:. ``` {.cpp}; > root conductivity_experiment.root; Attaching file conductivity_experiment.root",MatchSource.DOCS,documentation/primer/filio.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md:2392,Modifiability,variab,variables,2392,"_INCLUDE_FILE macros/read_from_file.C; ```. ## N-tuples in ROOT ##. ### Storing simple N-tuples ###. Up to now we have seen how to manipulate input read from ASCII files.; ROOT offers the possibility to do much better than that, with its own; n-tuple classes. Among the many advantages provided by these classes one; could cite. - Optimised disk I/O. - Possibility to store many n-tuple rows. - Write the n-tuples in ROOT files. - Interactive inspection with `TBrowser`. - Store not only numbers, but also *objects* in the columns. In this section we will discuss briefly the `TNtuple` class, which is a; simplified version of the `TTree` class. A ROOT `TNtuple` object can; store rows of float entries. Let's tackle the problem according to the; usual strategy commenting a minimal example. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/write_ntuple_to_file.C; ```. This data written to this example n-tuple represents, in the statistical; sense, three independent variables (Potential or Voltage, Pressure and; Temperature), and one variable (Current) which depends on the others; according to very simple laws, and an additional Gaussian smearing. This; set of variables mimics a measurement of an electrical resistance while; varying pressure and temperature. Imagine your task now consists in finding the relations among the; variables -- of course without knowing the code used to generate them.; You will see that the possibilities of the `NTuple` class enable you to; perform this analysis task. Open the ROOT file (`cond_data.root`); written by the macro above in an interactive session and use a; `TBrowser` to interactively inspect it:. ``` {.cpp}; root[0] TBrowser b; ```; You find the columns of your n-tuple written as *leafs*. Simply clicking; on them you can obtain histograms of the variables!. Next, try the following commands at the shell prompt and in the; interactive ROOT shell, respectively:. ``` {.cpp}; > root conductivity_experiment.root; Attaching file conductivity_experiment.root",MatchSource.DOCS,documentation/primer/filio.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md:2461,Modifiability,variab,variable,2461,"_INCLUDE_FILE macros/read_from_file.C; ```. ## N-tuples in ROOT ##. ### Storing simple N-tuples ###. Up to now we have seen how to manipulate input read from ASCII files.; ROOT offers the possibility to do much better than that, with its own; n-tuple classes. Among the many advantages provided by these classes one; could cite. - Optimised disk I/O. - Possibility to store many n-tuple rows. - Write the n-tuples in ROOT files. - Interactive inspection with `TBrowser`. - Store not only numbers, but also *objects* in the columns. In this section we will discuss briefly the `TNtuple` class, which is a; simplified version of the `TTree` class. A ROOT `TNtuple` object can; store rows of float entries. Let's tackle the problem according to the; usual strategy commenting a minimal example. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/write_ntuple_to_file.C; ```. This data written to this example n-tuple represents, in the statistical; sense, three independent variables (Potential or Voltage, Pressure and; Temperature), and one variable (Current) which depends on the others; according to very simple laws, and an additional Gaussian smearing. This; set of variables mimics a measurement of an electrical resistance while; varying pressure and temperature. Imagine your task now consists in finding the relations among the; variables -- of course without knowing the code used to generate them.; You will see that the possibilities of the `NTuple` class enable you to; perform this analysis task. Open the ROOT file (`cond_data.root`); written by the macro above in an interactive session and use a; `TBrowser` to interactively inspect it:. ``` {.cpp}; root[0] TBrowser b; ```; You find the columns of your n-tuple written as *leafs*. Simply clicking; on them you can obtain histograms of the variables!. Next, try the following commands at the shell prompt and in the; interactive ROOT shell, respectively:. ``` {.cpp}; > root conductivity_experiment.root; Attaching file conductivity_experiment.root",MatchSource.DOCS,documentation/primer/filio.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md:2590,Modifiability,variab,variables,2590,"y to do much better than that, with its own; n-tuple classes. Among the many advantages provided by these classes one; could cite. - Optimised disk I/O. - Possibility to store many n-tuple rows. - Write the n-tuples in ROOT files. - Interactive inspection with `TBrowser`. - Store not only numbers, but also *objects* in the columns. In this section we will discuss briefly the `TNtuple` class, which is a; simplified version of the `TTree` class. A ROOT `TNtuple` object can; store rows of float entries. Let's tackle the problem according to the; usual strategy commenting a minimal example. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/write_ntuple_to_file.C; ```. This data written to this example n-tuple represents, in the statistical; sense, three independent variables (Potential or Voltage, Pressure and; Temperature), and one variable (Current) which depends on the others; according to very simple laws, and an additional Gaussian smearing. This; set of variables mimics a measurement of an electrical resistance while; varying pressure and temperature. Imagine your task now consists in finding the relations among the; variables -- of course without knowing the code used to generate them.; You will see that the possibilities of the `NTuple` class enable you to; perform this analysis task. Open the ROOT file (`cond_data.root`); written by the macro above in an interactive session and use a; `TBrowser` to interactively inspect it:. ``` {.cpp}; root[0] TBrowser b; ```; You find the columns of your n-tuple written as *leafs*. Simply clicking; on them you can obtain histograms of the variables!. Next, try the following commands at the shell prompt and in the; interactive ROOT shell, respectively:. ``` {.cpp}; > root conductivity_experiment.root; Attaching file conductivity_experiment.root as _file0...; root [0] cond_data->Draw(""Current:Potential""); ```. You just produced a correlation plot with one single line of code!. Try to extend the syntax typing for example. ``` {.cpp}; root [1",MatchSource.DOCS,documentation/primer/filio.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md:2757,Modifiability,variab,variables,2757,"ite. - Optimised disk I/O. - Possibility to store many n-tuple rows. - Write the n-tuples in ROOT files. - Interactive inspection with `TBrowser`. - Store not only numbers, but also *objects* in the columns. In this section we will discuss briefly the `TNtuple` class, which is a; simplified version of the `TTree` class. A ROOT `TNtuple` object can; store rows of float entries. Let's tackle the problem according to the; usual strategy commenting a minimal example. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/write_ntuple_to_file.C; ```. This data written to this example n-tuple represents, in the statistical; sense, three independent variables (Potential or Voltage, Pressure and; Temperature), and one variable (Current) which depends on the others; according to very simple laws, and an additional Gaussian smearing. This; set of variables mimics a measurement of an electrical resistance while; varying pressure and temperature. Imagine your task now consists in finding the relations among the; variables -- of course without knowing the code used to generate them.; You will see that the possibilities of the `NTuple` class enable you to; perform this analysis task. Open the ROOT file (`cond_data.root`); written by the macro above in an interactive session and use a; `TBrowser` to interactively inspect it:. ``` {.cpp}; root[0] TBrowser b; ```; You find the columns of your n-tuple written as *leafs*. Simply clicking; on them you can obtain histograms of the variables!. Next, try the following commands at the shell prompt and in the; interactive ROOT shell, respectively:. ``` {.cpp}; > root conductivity_experiment.root; Attaching file conductivity_experiment.root as _file0...; root [0] cond_data->Draw(""Current:Potential""); ```. You just produced a correlation plot with one single line of code!. Try to extend the syntax typing for example. ``` {.cpp}; root [1] cond_data->Draw(""Current:Potential"",""Temperature<270""); ```. What do you obtain ?. Now try. ``` {.cpp}; root [2] cond_data-",MatchSource.DOCS,documentation/primer/filio.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md:3226,Modifiability,variab,variables,3226,"ting a minimal example. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/write_ntuple_to_file.C; ```. This data written to this example n-tuple represents, in the statistical; sense, three independent variables (Potential or Voltage, Pressure and; Temperature), and one variable (Current) which depends on the others; according to very simple laws, and an additional Gaussian smearing. This; set of variables mimics a measurement of an electrical resistance while; varying pressure and temperature. Imagine your task now consists in finding the relations among the; variables -- of course without knowing the code used to generate them.; You will see that the possibilities of the `NTuple` class enable you to; perform this analysis task. Open the ROOT file (`cond_data.root`); written by the macro above in an interactive session and use a; `TBrowser` to interactively inspect it:. ``` {.cpp}; root[0] TBrowser b; ```; You find the columns of your n-tuple written as *leafs*. Simply clicking; on them you can obtain histograms of the variables!. Next, try the following commands at the shell prompt and in the; interactive ROOT shell, respectively:. ``` {.cpp}; > root conductivity_experiment.root; Attaching file conductivity_experiment.root as _file0...; root [0] cond_data->Draw(""Current:Potential""); ```. You just produced a correlation plot with one single line of code!. Try to extend the syntax typing for example. ``` {.cpp}; root [1] cond_data->Draw(""Current:Potential"",""Temperature<270""); ```. What do you obtain ?. Now try. ``` {.cpp}; root [2] cond_data->Draw(""Current/Potential:Temperature""); ```. It should have become clear from these examples how to navigate in such; a multi-dimensional space of variables and unveil relations between; variables using n-tuples. ### Reading N-tuples. For completeness, you find here a small macro to read the data back from; a ROOT n-tuple. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/read_ntuple_from_file.C; ```. The macro shows the easiest way of accessing the co",MatchSource.DOCS,documentation/primer/filio.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md:3576,Modifiability,extend,extend,3576,"variables mimics a measurement of an electrical resistance while; varying pressure and temperature. Imagine your task now consists in finding the relations among the; variables -- of course without knowing the code used to generate them.; You will see that the possibilities of the `NTuple` class enable you to; perform this analysis task. Open the ROOT file (`cond_data.root`); written by the macro above in an interactive session and use a; `TBrowser` to interactively inspect it:. ``` {.cpp}; root[0] TBrowser b; ```; You find the columns of your n-tuple written as *leafs*. Simply clicking; on them you can obtain histograms of the variables!. Next, try the following commands at the shell prompt and in the; interactive ROOT shell, respectively:. ``` {.cpp}; > root conductivity_experiment.root; Attaching file conductivity_experiment.root as _file0...; root [0] cond_data->Draw(""Current:Potential""); ```. You just produced a correlation plot with one single line of code!. Try to extend the syntax typing for example. ``` {.cpp}; root [1] cond_data->Draw(""Current:Potential"",""Temperature<270""); ```. What do you obtain ?. Now try. ``` {.cpp}; root [2] cond_data->Draw(""Current/Potential:Temperature""); ```. It should have become clear from these examples how to navigate in such; a multi-dimensional space of variables and unveil relations between; variables using n-tuples. ### Reading N-tuples. For completeness, you find here a small macro to read the data back from; a ROOT n-tuple. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/read_ntuple_from_file.C; ```. The macro shows the easiest way of accessing the content of a n-tuple:; after loading the n-tuple, its branches are assigned to variables and; `GetEntry(long)` automatically fills them with the content for a; specific row. By doing so, the logic for reading the n-tuple and the; code to process it can be split and the source code remains clear. ### Storing Arbitrary N-tuples ###. It is also possible to write n-tuples of arbitrary type by",MatchSource.DOCS,documentation/primer/filio.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md:3905,Modifiability,variab,variables,3905," enable you to; perform this analysis task. Open the ROOT file (`cond_data.root`); written by the macro above in an interactive session and use a; `TBrowser` to interactively inspect it:. ``` {.cpp}; root[0] TBrowser b; ```; You find the columns of your n-tuple written as *leafs*. Simply clicking; on them you can obtain histograms of the variables!. Next, try the following commands at the shell prompt and in the; interactive ROOT shell, respectively:. ``` {.cpp}; > root conductivity_experiment.root; Attaching file conductivity_experiment.root as _file0...; root [0] cond_data->Draw(""Current:Potential""); ```. You just produced a correlation plot with one single line of code!. Try to extend the syntax typing for example. ``` {.cpp}; root [1] cond_data->Draw(""Current:Potential"",""Temperature<270""); ```. What do you obtain ?. Now try. ``` {.cpp}; root [2] cond_data->Draw(""Current/Potential:Temperature""); ```. It should have become clear from these examples how to navigate in such; a multi-dimensional space of variables and unveil relations between; variables using n-tuples. ### Reading N-tuples. For completeness, you find here a small macro to read the data back from; a ROOT n-tuple. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/read_ntuple_from_file.C; ```. The macro shows the easiest way of accessing the content of a n-tuple:; after loading the n-tuple, its branches are assigned to variables and; `GetEntry(long)` automatically fills them with the content for a; specific row. By doing so, the logic for reading the n-tuple and the; code to process it can be split and the source code remains clear. ### Storing Arbitrary N-tuples ###. It is also possible to write n-tuples of arbitrary type by using ROOT's; `TBranch` class. This is especially important as `TNtuple::Fill()`; accepts only floats. The following macro creates the same n-tuple as; before but the branches are booked directly. The `Fill()` function then; fills the current values of the connected variables to the tree. ``` ",MatchSource.DOCS,documentation/primer/filio.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md:3945,Modifiability,variab,variables,3945," enable you to; perform this analysis task. Open the ROOT file (`cond_data.root`); written by the macro above in an interactive session and use a; `TBrowser` to interactively inspect it:. ``` {.cpp}; root[0] TBrowser b; ```; You find the columns of your n-tuple written as *leafs*. Simply clicking; on them you can obtain histograms of the variables!. Next, try the following commands at the shell prompt and in the; interactive ROOT shell, respectively:. ``` {.cpp}; > root conductivity_experiment.root; Attaching file conductivity_experiment.root as _file0...; root [0] cond_data->Draw(""Current:Potential""); ```. You just produced a correlation plot with one single line of code!. Try to extend the syntax typing for example. ``` {.cpp}; root [1] cond_data->Draw(""Current:Potential"",""Temperature<270""); ```. What do you obtain ?. Now try. ``` {.cpp}; root [2] cond_data->Draw(""Current/Potential:Temperature""); ```. It should have become clear from these examples how to navigate in such; a multi-dimensional space of variables and unveil relations between; variables using n-tuples. ### Reading N-tuples. For completeness, you find here a small macro to read the data back from; a ROOT n-tuple. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/read_ntuple_from_file.C; ```. The macro shows the easiest way of accessing the content of a n-tuple:; after loading the n-tuple, its branches are assigned to variables and; `GetEntry(long)` automatically fills them with the content for a; specific row. By doing so, the logic for reading the n-tuple and the; code to process it can be split and the source code remains clear. ### Storing Arbitrary N-tuples ###. It is also possible to write n-tuples of arbitrary type by using ROOT's; `TBranch` class. This is especially important as `TNtuple::Fill()`; accepts only floats. The following macro creates the same n-tuple as; before but the branches are booked directly. The `Fill()` function then; fills the current values of the connected variables to the tree. ``` ",MatchSource.DOCS,documentation/primer/filio.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md:4279,Modifiability,variab,variables,4279," commands at the shell prompt and in the; interactive ROOT shell, respectively:. ``` {.cpp}; > root conductivity_experiment.root; Attaching file conductivity_experiment.root as _file0...; root [0] cond_data->Draw(""Current:Potential""); ```. You just produced a correlation plot with one single line of code!. Try to extend the syntax typing for example. ``` {.cpp}; root [1] cond_data->Draw(""Current:Potential"",""Temperature<270""); ```. What do you obtain ?. Now try. ``` {.cpp}; root [2] cond_data->Draw(""Current/Potential:Temperature""); ```. It should have become clear from these examples how to navigate in such; a multi-dimensional space of variables and unveil relations between; variables using n-tuples. ### Reading N-tuples. For completeness, you find here a small macro to read the data back from; a ROOT n-tuple. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/read_ntuple_from_file.C; ```. The macro shows the easiest way of accessing the content of a n-tuple:; after loading the n-tuple, its branches are assigned to variables and; `GetEntry(long)` automatically fills them with the content for a; specific row. By doing so, the logic for reading the n-tuple and the; code to process it can be split and the source code remains clear. ### Storing Arbitrary N-tuples ###. It is also possible to write n-tuples of arbitrary type by using ROOT's; `TBranch` class. This is especially important as `TNtuple::Fill()`; accepts only floats. The following macro creates the same n-tuple as; before but the branches are booked directly. The `Fill()` function then; fills the current values of the connected variables to the tree. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/write_ntuple_to_file_advanced.C; ```. The `Branch()` function requires a pointer to a variable and a; definition of the variable type. The following table lists some of the possible; values.; Please note that ROOT is not checking the input and mistakes are likely; to result in serious problems. This holds especially if values are read; as a",MatchSource.DOCS,documentation/primer/filio.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md:4859,Modifiability,variab,variables,4859,"m these examples how to navigate in such; a multi-dimensional space of variables and unveil relations between; variables using n-tuples. ### Reading N-tuples. For completeness, you find here a small macro to read the data back from; a ROOT n-tuple. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/read_ntuple_from_file.C; ```. The macro shows the easiest way of accessing the content of a n-tuple:; after loading the n-tuple, its branches are assigned to variables and; `GetEntry(long)` automatically fills them with the content for a; specific row. By doing so, the logic for reading the n-tuple and the; code to process it can be split and the source code remains clear. ### Storing Arbitrary N-tuples ###. It is also possible to write n-tuples of arbitrary type by using ROOT's; `TBranch` class. This is especially important as `TNtuple::Fill()`; accepts only floats. The following macro creates the same n-tuple as; before but the branches are booked directly. The `Fill()` function then; fills the current values of the connected variables to the tree. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/write_ntuple_to_file_advanced.C; ```. The `Branch()` function requires a pointer to a variable and a; definition of the variable type. The following table lists some of the possible; values.; Please note that ROOT is not checking the input and mistakes are likely; to result in serious problems. This holds especially if values are read; as another type than they have been written, e.g. when storing a; variable as float and reading it as double. List of variable types that can be used to define the type of a branch in ROOT:. type size C++ identifier; ------------------ -------- --------------- ------------; signed integer 32 bit int I; 64 bit long L; unsigned integer 32 bit unsigned int i; 64 bit unsigned long l; floating point 32 bit float F; 64 bit double D; boolean - bool O. ### Processing N-tuples Spanning over Several Files ###. Usually n-tuples or trees span over many files and it would be difficul",MatchSource.DOCS,documentation/primer/filio.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md:5006,Modifiability,variab,variable,5006,"ness, you find here a small macro to read the data back from; a ROOT n-tuple. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/read_ntuple_from_file.C; ```. The macro shows the easiest way of accessing the content of a n-tuple:; after loading the n-tuple, its branches are assigned to variables and; `GetEntry(long)` automatically fills them with the content for a; specific row. By doing so, the logic for reading the n-tuple and the; code to process it can be split and the source code remains clear. ### Storing Arbitrary N-tuples ###. It is also possible to write n-tuples of arbitrary type by using ROOT's; `TBranch` class. This is especially important as `TNtuple::Fill()`; accepts only floats. The following macro creates the same n-tuple as; before but the branches are booked directly. The `Fill()` function then; fills the current values of the connected variables to the tree. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/write_ntuple_to_file_advanced.C; ```. The `Branch()` function requires a pointer to a variable and a; definition of the variable type. The following table lists some of the possible; values.; Please note that ROOT is not checking the input and mistakes are likely; to result in serious problems. This holds especially if values are read; as another type than they have been written, e.g. when storing a; variable as float and reading it as double. List of variable types that can be used to define the type of a branch in ROOT:. type size C++ identifier; ------------------ -------- --------------- ------------; signed integer 32 bit int I; 64 bit long L; unsigned integer 32 bit unsigned int i; 64 bit unsigned long l; floating point 32 bit float F; 64 bit double D; boolean - bool O. ### Processing N-tuples Spanning over Several Files ###. Usually n-tuples or trees span over many files and it would be difficult; to add them manually. ROOT thus kindly provides a helper class in the; form of `TChain`. Its usage is shown in the following macro which is; very similar to the previou",MatchSource.DOCS,documentation/primer/filio.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md:5040,Modifiability,variab,variable,5040,"ness, you find here a small macro to read the data back from; a ROOT n-tuple. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/read_ntuple_from_file.C; ```. The macro shows the easiest way of accessing the content of a n-tuple:; after loading the n-tuple, its branches are assigned to variables and; `GetEntry(long)` automatically fills them with the content for a; specific row. By doing so, the logic for reading the n-tuple and the; code to process it can be split and the source code remains clear. ### Storing Arbitrary N-tuples ###. It is also possible to write n-tuples of arbitrary type by using ROOT's; `TBranch` class. This is especially important as `TNtuple::Fill()`; accepts only floats. The following macro creates the same n-tuple as; before but the branches are booked directly. The `Fill()` function then; fills the current values of the connected variables to the tree. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/write_ntuple_to_file_advanced.C; ```. The `Branch()` function requires a pointer to a variable and a; definition of the variable type. The following table lists some of the possible; values.; Please note that ROOT is not checking the input and mistakes are likely; to result in serious problems. This holds especially if values are read; as another type than they have been written, e.g. when storing a; variable as float and reading it as double. List of variable types that can be used to define the type of a branch in ROOT:. type size C++ identifier; ------------------ -------- --------------- ------------; signed integer 32 bit int I; 64 bit long L; unsigned integer 32 bit unsigned int i; 64 bit unsigned long l; floating point 32 bit float F; 64 bit double D; boolean - bool O. ### Processing N-tuples Spanning over Several Files ###. Usually n-tuples or trees span over many files and it would be difficult; to add them manually. ROOT thus kindly provides a helper class in the; form of `TChain`. Its usage is shown in the following macro which is; very similar to the previou",MatchSource.DOCS,documentation/primer/filio.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md:5324,Modifiability,variab,variable,5324,"ith the content for a; specific row. By doing so, the logic for reading the n-tuple and the; code to process it can be split and the source code remains clear. ### Storing Arbitrary N-tuples ###. It is also possible to write n-tuples of arbitrary type by using ROOT's; `TBranch` class. This is especially important as `TNtuple::Fill()`; accepts only floats. The following macro creates the same n-tuple as; before but the branches are booked directly. The `Fill()` function then; fills the current values of the connected variables to the tree. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/write_ntuple_to_file_advanced.C; ```. The `Branch()` function requires a pointer to a variable and a; definition of the variable type. The following table lists some of the possible; values.; Please note that ROOT is not checking the input and mistakes are likely; to result in serious problems. This holds especially if values are read; as another type than they have been written, e.g. when storing a; variable as float and reading it as double. List of variable types that can be used to define the type of a branch in ROOT:. type size C++ identifier; ------------------ -------- --------------- ------------; signed integer 32 bit int I; 64 bit long L; unsigned integer 32 bit unsigned int i; 64 bit unsigned long l; floating point 32 bit float F; 64 bit double D; boolean - bool O. ### Processing N-tuples Spanning over Several Files ###. Usually n-tuples or trees span over many files and it would be difficult; to add them manually. ROOT thus kindly provides a helper class in the; form of `TChain`. Its usage is shown in the following macro which is; very similar to the previous example. The constructor of a `TChain`; takes the name of the `TTree` (or `TNuple`) as an argument. The files; are added with the function `Add(fileName)`, where one can also use; wild-cards as shown in the example. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/read_ntuple_with_chain.C; ```. ### *For the advanced user:* Processing tree",MatchSource.DOCS,documentation/primer/filio.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md:5376,Modifiability,variab,variable,5376,"g the n-tuple and the; code to process it can be split and the source code remains clear. ### Storing Arbitrary N-tuples ###. It is also possible to write n-tuples of arbitrary type by using ROOT's; `TBranch` class. This is especially important as `TNtuple::Fill()`; accepts only floats. The following macro creates the same n-tuple as; before but the branches are booked directly. The `Fill()` function then; fills the current values of the connected variables to the tree. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/write_ntuple_to_file_advanced.C; ```. The `Branch()` function requires a pointer to a variable and a; definition of the variable type. The following table lists some of the possible; values.; Please note that ROOT is not checking the input and mistakes are likely; to result in serious problems. This holds especially if values are read; as another type than they have been written, e.g. when storing a; variable as float and reading it as double. List of variable types that can be used to define the type of a branch in ROOT:. type size C++ identifier; ------------------ -------- --------------- ------------; signed integer 32 bit int I; 64 bit long L; unsigned integer 32 bit unsigned int i; 64 bit unsigned long l; floating point 32 bit float F; 64 bit double D; boolean - bool O. ### Processing N-tuples Spanning over Several Files ###. Usually n-tuples or trees span over many files and it would be difficult; to add them manually. ROOT thus kindly provides a helper class in the; form of `TChain`. Its usage is shown in the following macro which is; very similar to the previous example. The constructor of a `TChain`; takes the name of the `TTree` (or `TNuple`) as an argument. The files; are added with the function `Add(fileName)`, where one can also use; wild-cards as shown in the example. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/read_ntuple_with_chain.C; ```. ### *For the advanced user:* Processing trees with a selector script ###. Another very general and powerful way of ",MatchSource.DOCS,documentation/primer/filio.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md:13691,Modifiability,variab,variable,13691,"; something goes wrong. As the method described here also works without; using PROOF, the development work on an analysis script can be done in; the standard way on a small subset of the data, and only for the full; processing one would use parallelism via PROOF. It is worth to remind the reader that the speed of typical data analysis; programs limited by the I/O speed (for example the latencies implied by; reading data from a hard drive). It is therefore expected that this; limitation cannot be eliminated with the usage of any parallel analysis; toolkit. ### Optimisation Regarding N-tuples ###. ROOT automatically applies compression algorithms on n-tuples to reduce; the memory consumption. A value that is in most cases the same will; consume only small space on your disk (but it has to be decompressed on; reading). Nevertheless, you should think about the design of your; n-tuples and your analyses as soon as the processing time exceeds some; minutes. - Try to keep your n-tuples simple and use appropriate variable types.; If your measurement has only a limited precision, it is needless to; store it with double precision. - Experimental conditions that do not change with every single; measurement should be stored in a separate tree. Although the; compression can handle redundant values, the processing time; increase with every variable that has to be filled. - The function `SetCacheSize(long)` specifies the size of the cache; for reading a `TTree` object from a file. The default value is 30MB.; A manual increase may help in certain situations. Please note that; the caching mechanism can cover only one `TTree` object per `TFile`; object. - You can select the branches to be covered by the caching algorithm; with `AddBranchToCache` and deactivate unneeded branches with; `SetBranchStatus`. This mechanism can result in a significant; speed-up for simple operations on trees with many branches. - You can measure the performance easily with `TTreePerfStats`. The; ROOT documen",MatchSource.DOCS,documentation/primer/filio.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md:14018,Modifiability,variab,variable,14018,"typical data analysis; programs limited by the I/O speed (for example the latencies implied by; reading data from a hard drive). It is therefore expected that this; limitation cannot be eliminated with the usage of any parallel analysis; toolkit. ### Optimisation Regarding N-tuples ###. ROOT automatically applies compression algorithms on n-tuples to reduce; the memory consumption. A value that is in most cases the same will; consume only small space on your disk (but it has to be decompressed on; reading). Nevertheless, you should think about the design of your; n-tuples and your analyses as soon as the processing time exceeds some; minutes. - Try to keep your n-tuples simple and use appropriate variable types.; If your measurement has only a limited precision, it is needless to; store it with double precision. - Experimental conditions that do not change with every single; measurement should be stored in a separate tree. Although the; compression can handle redundant values, the processing time; increase with every variable that has to be filled. - The function `SetCacheSize(long)` specifies the size of the cache; for reading a `TTree` object from a file. The default value is 30MB.; A manual increase may help in certain situations. Please note that; the caching mechanism can cover only one `TTree` object per `TFile`; object. - You can select the branches to be covered by the caching algorithm; with `AddBranchToCache` and deactivate unneeded branches with; `SetBranchStatus`. This mechanism can result in a significant; speed-up for simple operations on trees with many branches. - You can measure the performance easily with `TTreePerfStats`. The; ROOT documentation on this class also includes an introductory; example. For example, `TTreePerfStats` can show you that it is; beneficial to store meta data and payload data separately, i.e.; write the meta data tree in a bulk to a file at the end of your job; instead of writing both trees interleaved. [^6]: The usage of `f",MatchSource.DOCS,documentation/primer/filio.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md:367,Performance,perform,perform,367,"# File I/O and Parallel Analysis #. ## Storing ROOT Objects ##. ROOT offers the possibility to write instances of classes on; disk, into a *ROOT-file* (see the `TFile` class for more details).; One says that the object is made ""persistent"" by storing; it on disk. When reading the file back, the object is reconstructed; in memory. The requirement to be satisfied to perform I/O of instances; of a certain class is that the ROOT type system is aware of the layout; in memory of that class.; This topic is beyond the scope of this document: it is worth to mention; that I/O can be performed out of the box for the almost complete set; of ROOT classes. We can explore this functionality with histograms and two simple macros. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/write_to_file.C; ```. Not bad, eh ? Especially for a language that does not foresees; persistency natively like C++. The *RECREATE* option forces ROOT to; create a new file even if a file with the same name exists on disk. Now, you may use the Cling command line to access information in the file; and draw the previously written histogram:. ``` {.cpp}; > root my_rootfile.root; root [0]; Attaching file my_rootfile.root as _file0...; root [1] _file0->ls(); TFile** my_rootfile.root; TFile* my_rootfile.root; KEY: TH1F	my_histogram;1 My Title; root [2] my_histogram->Draw(); ```; \newpage; Alternatively, you can use a simple macro to carry out the job:. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/read_from_file.C; ```. ## N-tuples in ROOT ##. ### Storing simple N-tuples ###. Up to now we have seen how to manipulate input read from ASCII files.; ROOT offers the possibility to do much better than that, with its own; n-tuple classes. Among the many advantages provided by these classes one; could cite. - Optimised disk I/O. - Possibility to store many n-tuple rows. - Write the n-tuples in ROOT files. - Interactive inspection with `TBrowser`. - Store not only numbers, but also *objects* in the columns. In this section we will discuss bri",MatchSource.DOCS,documentation/primer/filio.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md:580,Performance,perform,performed,580,"# File I/O and Parallel Analysis #. ## Storing ROOT Objects ##. ROOT offers the possibility to write instances of classes on; disk, into a *ROOT-file* (see the `TFile` class for more details).; One says that the object is made ""persistent"" by storing; it on disk. When reading the file back, the object is reconstructed; in memory. The requirement to be satisfied to perform I/O of instances; of a certain class is that the ROOT type system is aware of the layout; in memory of that class.; This topic is beyond the scope of this document: it is worth to mention; that I/O can be performed out of the box for the almost complete set; of ROOT classes. We can explore this functionality with histograms and two simple macros. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/write_to_file.C; ```. Not bad, eh ? Especially for a language that does not foresees; persistency natively like C++. The *RECREATE* option forces ROOT to; create a new file even if a file with the same name exists on disk. Now, you may use the Cling command line to access information in the file; and draw the previously written histogram:. ``` {.cpp}; > root my_rootfile.root; root [0]; Attaching file my_rootfile.root as _file0...; root [1] _file0->ls(); TFile** my_rootfile.root; TFile* my_rootfile.root; KEY: TH1F	my_histogram;1 My Title; root [2] my_histogram->Draw(); ```; \newpage; Alternatively, you can use a simple macro to carry out the job:. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/read_from_file.C; ```. ## N-tuples in ROOT ##. ### Storing simple N-tuples ###. Up to now we have seen how to manipulate input read from ASCII files.; ROOT offers the possibility to do much better than that, with its own; n-tuple classes. Among the many advantages provided by these classes one; could cite. - Optimised disk I/O. - Possibility to store many n-tuple rows. - Write the n-tuples in ROOT files. - Interactive inspection with `TBrowser`. - Store not only numbers, but also *objects* in the columns. In this section we will discuss bri",MatchSource.DOCS,documentation/primer/filio.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md:2902,Performance,perform,perform,2902,"nspection with `TBrowser`. - Store not only numbers, but also *objects* in the columns. In this section we will discuss briefly the `TNtuple` class, which is a; simplified version of the `TTree` class. A ROOT `TNtuple` object can; store rows of float entries. Let's tackle the problem according to the; usual strategy commenting a minimal example. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/write_ntuple_to_file.C; ```. This data written to this example n-tuple represents, in the statistical; sense, three independent variables (Potential or Voltage, Pressure and; Temperature), and one variable (Current) which depends on the others; according to very simple laws, and an additional Gaussian smearing. This; set of variables mimics a measurement of an electrical resistance while; varying pressure and temperature. Imagine your task now consists in finding the relations among the; variables -- of course without knowing the code used to generate them.; You will see that the possibilities of the `NTuple` class enable you to; perform this analysis task. Open the ROOT file (`cond_data.root`); written by the macro above in an interactive session and use a; `TBrowser` to interactively inspect it:. ``` {.cpp}; root[0] TBrowser b; ```; You find the columns of your n-tuple written as *leafs*. Simply clicking; on them you can obtain histograms of the variables!. Next, try the following commands at the shell prompt and in the; interactive ROOT shell, respectively:. ``` {.cpp}; > root conductivity_experiment.root; Attaching file conductivity_experiment.root as _file0...; root [0] cond_data->Draw(""Current:Potential""); ```. You just produced a correlation plot with one single line of code!. Try to extend the syntax typing for example. ``` {.cpp}; root [1] cond_data->Draw(""Current:Potential"",""Temperature<270""); ```. What do you obtain ?. Now try. ``` {.cpp}; root [2] cond_data->Draw(""Current/Potential:Temperature""); ```. It should have become clear from these examples how to navigate in such; a ",MatchSource.DOCS,documentation/primer/filio.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md:4229,Performance,load,loading,4229," commands at the shell prompt and in the; interactive ROOT shell, respectively:. ``` {.cpp}; > root conductivity_experiment.root; Attaching file conductivity_experiment.root as _file0...; root [0] cond_data->Draw(""Current:Potential""); ```. You just produced a correlation plot with one single line of code!. Try to extend the syntax typing for example. ``` {.cpp}; root [1] cond_data->Draw(""Current:Potential"",""Temperature<270""); ```. What do you obtain ?. Now try. ``` {.cpp}; root [2] cond_data->Draw(""Current/Potential:Temperature""); ```. It should have become clear from these examples how to navigate in such; a multi-dimensional space of variables and unveil relations between; variables using n-tuples. ### Reading N-tuples. For completeness, you find here a small macro to read the data back from; a ROOT n-tuple. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/read_ntuple_from_file.C; ```. The macro shows the easiest way of accessing the content of a n-tuple:; after loading the n-tuple, its branches are assigned to variables and; `GetEntry(long)` automatically fills them with the content for a; specific row. By doing so, the logic for reading the n-tuple and the; code to process it can be split and the source code remains clear. ### Storing Arbitrary N-tuples ###. It is also possible to write n-tuples of arbitrary type by using ROOT's; `TBranch` class. This is especially important as `TNtuple::Fill()`; accepts only floats. The following macro creates the same n-tuple as; before but the branches are booked directly. The `Fill()` function then; fills the current values of the connected variables to the tree. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/write_ntuple_to_file_advanced.C; ```. The `Branch()` function requires a pointer to a variable and a; definition of the variable type. The following table lists some of the possible; values.; Please note that ROOT is not checking the input and mistakes are likely; to result in serious problems. This holds especially if values are read; as a",MatchSource.DOCS,documentation/primer/filio.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md:7383,Performance,perform,performed,7383,"ry general and powerful way of processing a `TChain` is; provided via the method `TChain::Process()`. This method takes as; arguments an instance of a -- user-implemented-- class of type; `TSelector`, and -- optionally -- the number of entries and the first; entry to be processed. A template for the class `TSelector` is provided; by the method `TTree::MakeSelector`, as is shown in the little macro; `makeSelector.C` below. It opens the n-tuple `conductivity_experiment.root` from the example; above and creates from it the header file `MySelector.h` and a template; to insert your own analysis code, `MySelector.C`.; \newpage. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/makeMySelector.C; ```. The template contains the entry points `Begin()` and `SlaveBegin()`; called before processing of the `TChain` starts, `Process()` called for; every entry of the chain, and `SlaveTerminate()` and `Terminate()`; called after the last entry has been processed. Typically,; initialization like booking of histograms is performed in; `SlaveBegin()`, the analysis, i.e. the selection of entries,; calculations and filling of histograms, is done in `Process()`, and; final operations like plotting and storing of results happen in; `SlaveTerminate()` or `Terminate()`. The entry points `SlaveBegin()` and `SlaveTerminate()` are called on; so-called slave nodes only if parallel processing via `PROOF` or; `PROOF lite` is enabled, as will be explained below. A simple example of a selector class is shown in the macro; `MySelector.C`. The example is executed with the following sequence of; commands:. ``` {.cpp}; > TChain *ch=new TChain(""cond_data"", ""Chain for Example N-Tuple"");; > ch->Add(""conductivity_experiment*.root"");; > ch->Process(""MySelector.C+"");; ```. As usual, the ""`+`"" appended to the name of the macro to be executed; initiates the compilation of the `MySelector.C` with the system compiler; in order to improve performance. The code in `MySelector.C`, shown in the listing below, books some; histogr",MatchSource.DOCS,documentation/primer/filio.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md:8289,Performance,perform,performance,8289,"ate()`; called after the last entry has been processed. Typically,; initialization like booking of histograms is performed in; `SlaveBegin()`, the analysis, i.e. the selection of entries,; calculations and filling of histograms, is done in `Process()`, and; final operations like plotting and storing of results happen in; `SlaveTerminate()` or `Terminate()`. The entry points `SlaveBegin()` and `SlaveTerminate()` are called on; so-called slave nodes only if parallel processing via `PROOF` or; `PROOF lite` is enabled, as will be explained below. A simple example of a selector class is shown in the macro; `MySelector.C`. The example is executed with the following sequence of; commands:. ``` {.cpp}; > TChain *ch=new TChain(""cond_data"", ""Chain for Example N-Tuple"");; > ch->Add(""conductivity_experiment*.root"");; > ch->Process(""MySelector.C+"");; ```. As usual, the ""`+`"" appended to the name of the macro to be executed; initiates the compilation of the `MySelector.C` with the system compiler; in order to improve performance. The code in `MySelector.C`, shown in the listing below, books some; histograms in `SlaveBegin()` and adds them to the instance `fOutput`,; which is of the class `TList` [^6]. The final processing in; `Terminate()` allows to access histograms and store, display or save; them as pictures. This is shown in the example via the `TList`; `fOutput`. See the commented listing below for more details; most of the; text is actually comments generated automatically by; `TTree::MakeSelector`. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/MySelector.C; ```. ### *For power-users:* Multi-core processing with `PROOF lite` ###. The processing of n-tuples via a selector function of type `TSelector`; through `TChain::Process()`, as described at the end of the previous; section, offers an additional advantage in particular for very large; data sets: on distributed systems or multi-core architectures, portions; of data can be processed in parallel, thus significantly reducing the; exe",MatchSource.DOCS,documentation/primer/filio.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md:14112,Performance,cache,cache,14112,"d drive). It is therefore expected that this; limitation cannot be eliminated with the usage of any parallel analysis; toolkit. ### Optimisation Regarding N-tuples ###. ROOT automatically applies compression algorithms on n-tuples to reduce; the memory consumption. A value that is in most cases the same will; consume only small space on your disk (but it has to be decompressed on; reading). Nevertheless, you should think about the design of your; n-tuples and your analyses as soon as the processing time exceeds some; minutes. - Try to keep your n-tuples simple and use appropriate variable types.; If your measurement has only a limited precision, it is needless to; store it with double precision. - Experimental conditions that do not change with every single; measurement should be stored in a separate tree. Although the; compression can handle redundant values, the processing time; increase with every variable that has to be filled. - The function `SetCacheSize(long)` specifies the size of the cache; for reading a `TTree` object from a file. The default value is 30MB.; A manual increase may help in certain situations. Please note that; the caching mechanism can cover only one `TTree` object per `TFile`; object. - You can select the branches to be covered by the caching algorithm; with `AddBranchToCache` and deactivate unneeded branches with; `SetBranchStatus`. This mechanism can result in a significant; speed-up for simple operations on trees with many branches. - You can measure the performance easily with `TTreePerfStats`. The; ROOT documentation on this class also includes an introductory; example. For example, `TTreePerfStats` can show you that it is; beneficial to store meta data and payload data separately, i.e.; write the meta data tree in a bulk to a file at the end of your job; instead of writing both trees interleaved. [^6]: The usage of `fOutput` is not really needed for this simple example, but it allows re-usage of the exact code in parallel processing wi",MatchSource.DOCS,documentation/primer/filio.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md:14612,Performance,perform,performance,14612,"d that this; limitation cannot be eliminated with the usage of any parallel analysis; toolkit. ### Optimisation Regarding N-tuples ###. ROOT automatically applies compression algorithms on n-tuples to reduce; the memory consumption. A value that is in most cases the same will; consume only small space on your disk (but it has to be decompressed on; reading). Nevertheless, you should think about the design of your; n-tuples and your analyses as soon as the processing time exceeds some; minutes. - Try to keep your n-tuples simple and use appropriate variable types.; If your measurement has only a limited precision, it is needless to; store it with double precision. - Experimental conditions that do not change with every single; measurement should be stored in a separate tree. Although the; compression can handle redundant values, the processing time; increase with every variable that has to be filled. - The function `SetCacheSize(long)` specifies the size of the cache; for reading a `TTree` object from a file. The default value is 30MB.; A manual increase may help in certain situations. Please note that; the caching mechanism can cover only one `TTree` object per `TFile`; object. - You can select the branches to be covered by the caching algorithm; with `AddBranchToCache` and deactivate unneeded branches with; `SetBranchStatus`. This mechanism can result in a significant; speed-up for simple operations on trees with many branches. - You can measure the performance easily with `TTreePerfStats`. The; ROOT documentation on this class also includes an introductory; example. For example, `TTreePerfStats` can show you that it is; beneficial to store meta data and payload data separately, i.e.; write the meta data tree in a bulk to a file at the end of your job; instead of writing both trees interleaved. [^6]: The usage of `fOutput` is not really needed for this simple example, but it allows re-usage of the exact code in parallel processing with `PROOF` (see next section).; ",MatchSource.DOCS,documentation/primer/filio.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md:13959,Safety,redund,redundant,13959,"typical data analysis; programs limited by the I/O speed (for example the latencies implied by; reading data from a hard drive). It is therefore expected that this; limitation cannot be eliminated with the usage of any parallel analysis; toolkit. ### Optimisation Regarding N-tuples ###. ROOT automatically applies compression algorithms on n-tuples to reduce; the memory consumption. A value that is in most cases the same will; consume only small space on your disk (but it has to be decompressed on; reading). Nevertheless, you should think about the design of your; n-tuples and your analyses as soon as the processing time exceeds some; minutes. - Try to keep your n-tuples simple and use appropriate variable types.; If your measurement has only a limited precision, it is needless to; store it with double precision. - Experimental conditions that do not change with every single; measurement should be stored in a separate tree. Although the; compression can handle redundant values, the processing time; increase with every variable that has to be filled. - The function `SetCacheSize(long)` specifies the size of the cache; for reading a `TTree` object from a file. The default value is 30MB.; A manual increase may help in certain situations. Please note that; the caching mechanism can cover only one `TTree` object per `TFile`; object. - You can select the branches to be covered by the caching algorithm; with `AddBranchToCache` and deactivate unneeded branches with; `SetBranchStatus`. This mechanism can result in a significant; speed-up for simple operations on trees with many branches. - You can measure the performance easily with `TTreePerfStats`. The; ROOT documentation on this class also includes an introductory; example. For example, `TTreePerfStats` can show you that it is; beneficial to store meta data and payload data separately, i.e.; write the meta data tree in a bulk to a file at the end of your job; instead of writing both trees interleaved. [^6]: The usage of `f",MatchSource.DOCS,documentation/primer/filio.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md:1028,Security,access,access,1028,"ing ROOT Objects ##. ROOT offers the possibility to write instances of classes on; disk, into a *ROOT-file* (see the `TFile` class for more details).; One says that the object is made ""persistent"" by storing; it on disk. When reading the file back, the object is reconstructed; in memory. The requirement to be satisfied to perform I/O of instances; of a certain class is that the ROOT type system is aware of the layout; in memory of that class.; This topic is beyond the scope of this document: it is worth to mention; that I/O can be performed out of the box for the almost complete set; of ROOT classes. We can explore this functionality with histograms and two simple macros. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/write_to_file.C; ```. Not bad, eh ? Especially for a language that does not foresees; persistency natively like C++. The *RECREATE* option forces ROOT to; create a new file even if a file with the same name exists on disk. Now, you may use the Cling command line to access information in the file; and draw the previously written histogram:. ``` {.cpp}; > root my_rootfile.root; root [0]; Attaching file my_rootfile.root as _file0...; root [1] _file0->ls(); TFile** my_rootfile.root; TFile* my_rootfile.root; KEY: TH1F	my_histogram;1 My Title; root [2] my_histogram->Draw(); ```; \newpage; Alternatively, you can use a simple macro to carry out the job:. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/read_from_file.C; ```. ## N-tuples in ROOT ##. ### Storing simple N-tuples ###. Up to now we have seen how to manipulate input read from ASCII files.; ROOT offers the possibility to do much better than that, with its own; n-tuple classes. Among the many advantages provided by these classes one; could cite. - Optimised disk I/O. - Possibility to store many n-tuple rows. - Write the n-tuples in ROOT files. - Interactive inspection with `TBrowser`. - Store not only numbers, but also *objects* in the columns. In this section we will discuss briefly the `TNtuple` class, which is a; simpl",MatchSource.DOCS,documentation/primer/filio.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md:4186,Security,access,accessing,4186," commands at the shell prompt and in the; interactive ROOT shell, respectively:. ``` {.cpp}; > root conductivity_experiment.root; Attaching file conductivity_experiment.root as _file0...; root [0] cond_data->Draw(""Current:Potential""); ```. You just produced a correlation plot with one single line of code!. Try to extend the syntax typing for example. ``` {.cpp}; root [1] cond_data->Draw(""Current:Potential"",""Temperature<270""); ```. What do you obtain ?. Now try. ``` {.cpp}; root [2] cond_data->Draw(""Current/Potential:Temperature""); ```. It should have become clear from these examples how to navigate in such; a multi-dimensional space of variables and unveil relations between; variables using n-tuples. ### Reading N-tuples. For completeness, you find here a small macro to read the data back from; a ROOT n-tuple. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/read_ntuple_from_file.C; ```. The macro shows the easiest way of accessing the content of a n-tuple:; after loading the n-tuple, its branches are assigned to variables and; `GetEntry(long)` automatically fills them with the content for a; specific row. By doing so, the logic for reading the n-tuple and the; code to process it can be split and the source code remains clear. ### Storing Arbitrary N-tuples ###. It is also possible to write n-tuples of arbitrary type by using ROOT's; `TBranch` class. This is especially important as `TNtuple::Fill()`; accepts only floats. The following macro creates the same n-tuple as; before but the branches are booked directly. The `Fill()` function then; fills the current values of the connected variables to the tree. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/write_ntuple_to_file_advanced.C; ```. The `Branch()` function requires a pointer to a variable and a; definition of the variable type. The following table lists some of the possible; values.; Please note that ROOT is not checking the input and mistakes are likely; to result in serious problems. This holds especially if values are read; as a",MatchSource.DOCS,documentation/primer/filio.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md:8526,Security,access,access,8526,"l operations like plotting and storing of results happen in; `SlaveTerminate()` or `Terminate()`. The entry points `SlaveBegin()` and `SlaveTerminate()` are called on; so-called slave nodes only if parallel processing via `PROOF` or; `PROOF lite` is enabled, as will be explained below. A simple example of a selector class is shown in the macro; `MySelector.C`. The example is executed with the following sequence of; commands:. ``` {.cpp}; > TChain *ch=new TChain(""cond_data"", ""Chain for Example N-Tuple"");; > ch->Add(""conductivity_experiment*.root"");; > ch->Process(""MySelector.C+"");; ```. As usual, the ""`+`"" appended to the name of the macro to be executed; initiates the compilation of the `MySelector.C` with the system compiler; in order to improve performance. The code in `MySelector.C`, shown in the listing below, books some; histograms in `SlaveBegin()` and adds them to the instance `fOutput`,; which is of the class `TList` [^6]. The final processing in; `Terminate()` allows to access histograms and store, display or save; them as pictures. This is shown in the example via the `TList`; `fOutput`. See the commented listing below for more details; most of the; text is actually comments generated automatically by; `TTree::MakeSelector`. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/MySelector.C; ```. ### *For power-users:* Multi-core processing with `PROOF lite` ###. The processing of n-tuples via a selector function of type `TSelector`; through `TChain::Process()`, as described at the end of the previous; section, offers an additional advantage in particular for very large; data sets: on distributed systems or multi-core architectures, portions; of data can be processed in parallel, thus significantly reducing the; execution time. On modern computers with multi-core CPUs or; hardware-threading enabled, this allows a much faster turnaround of; analyses, since all the available CPU power is used. On distributed systems, a PROOF server and worker nodes have to be set; up, as des",MatchSource.DOCS,documentation/primer/filio.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md:4391,Testability,log,logic,4391," as _file0...; root [0] cond_data->Draw(""Current:Potential""); ```. You just produced a correlation plot with one single line of code!. Try to extend the syntax typing for example. ``` {.cpp}; root [1] cond_data->Draw(""Current:Potential"",""Temperature<270""); ```. What do you obtain ?. Now try. ``` {.cpp}; root [2] cond_data->Draw(""Current/Potential:Temperature""); ```. It should have become clear from these examples how to navigate in such; a multi-dimensional space of variables and unveil relations between; variables using n-tuples. ### Reading N-tuples. For completeness, you find here a small macro to read the data back from; a ROOT n-tuple. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/read_ntuple_from_file.C; ```. The macro shows the easiest way of accessing the content of a n-tuple:; after loading the n-tuple, its branches are assigned to variables and; `GetEntry(long)` automatically fills them with the content for a; specific row. By doing so, the logic for reading the n-tuple and the; code to process it can be split and the source code remains clear. ### Storing Arbitrary N-tuples ###. It is also possible to write n-tuples of arbitrary type by using ROOT's; `TBranch` class. This is especially important as `TNtuple::Fill()`; accepts only floats. The following macro creates the same n-tuple as; before but the branches are booked directly. The `Fill()` function then; fills the current values of the connected variables to the tree. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/write_ntuple_to_file_advanced.C; ```. The `Branch()` function requires a pointer to a variable and a; definition of the variable type. The following table lists some of the possible; values.; Please note that ROOT is not checking the input and mistakes are likely; to result in serious problems. This holds especially if values are read; as another type than they have been written, e.g. when storing a; variable as float and reading it as double. List of variable types that can be used to define the type of a bra",MatchSource.DOCS,documentation/primer/filio.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md:709,Usability,simpl,simple,709,"# File I/O and Parallel Analysis #. ## Storing ROOT Objects ##. ROOT offers the possibility to write instances of classes on; disk, into a *ROOT-file* (see the `TFile` class for more details).; One says that the object is made ""persistent"" by storing; it on disk. When reading the file back, the object is reconstructed; in memory. The requirement to be satisfied to perform I/O of instances; of a certain class is that the ROOT type system is aware of the layout; in memory of that class.; This topic is beyond the scope of this document: it is worth to mention; that I/O can be performed out of the box for the almost complete set; of ROOT classes. We can explore this functionality with histograms and two simple macros. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/write_to_file.C; ```. Not bad, eh ? Especially for a language that does not foresees; persistency natively like C++. The *RECREATE* option forces ROOT to; create a new file even if a file with the same name exists on disk. Now, you may use the Cling command line to access information in the file; and draw the previously written histogram:. ``` {.cpp}; > root my_rootfile.root; root [0]; Attaching file my_rootfile.root as _file0...; root [1] _file0->ls(); TFile** my_rootfile.root; TFile* my_rootfile.root; KEY: TH1F	my_histogram;1 My Title; root [2] my_histogram->Draw(); ```; \newpage; Alternatively, you can use a simple macro to carry out the job:. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/read_from_file.C; ```. ## N-tuples in ROOT ##. ### Storing simple N-tuples ###. Up to now we have seen how to manipulate input read from ASCII files.; ROOT offers the possibility to do much better than that, with its own; n-tuple classes. Among the many advantages provided by these classes one; could cite. - Optimised disk I/O. - Possibility to store many n-tuple rows. - Write the n-tuples in ROOT files. - Interactive inspection with `TBrowser`. - Store not only numbers, but also *objects* in the columns. In this section we will discuss bri",MatchSource.DOCS,documentation/primer/filio.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md:1381,Usability,simpl,simple,1381,"irement to be satisfied to perform I/O of instances; of a certain class is that the ROOT type system is aware of the layout; in memory of that class.; This topic is beyond the scope of this document: it is worth to mention; that I/O can be performed out of the box for the almost complete set; of ROOT classes. We can explore this functionality with histograms and two simple macros. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/write_to_file.C; ```. Not bad, eh ? Especially for a language that does not foresees; persistency natively like C++. The *RECREATE* option forces ROOT to; create a new file even if a file with the same name exists on disk. Now, you may use the Cling command line to access information in the file; and draw the previously written histogram:. ``` {.cpp}; > root my_rootfile.root; root [0]; Attaching file my_rootfile.root as _file0...; root [1] _file0->ls(); TFile** my_rootfile.root; TFile* my_rootfile.root; KEY: TH1F	my_histogram;1 My Title; root [2] my_histogram->Draw(); ```; \newpage; Alternatively, you can use a simple macro to carry out the job:. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/read_from_file.C; ```. ## N-tuples in ROOT ##. ### Storing simple N-tuples ###. Up to now we have seen how to manipulate input read from ASCII files.; ROOT offers the possibility to do much better than that, with its own; n-tuple classes. Among the many advantages provided by these classes one; could cite. - Optimised disk I/O. - Possibility to store many n-tuple rows. - Write the n-tuples in ROOT files. - Interactive inspection with `TBrowser`. - Store not only numbers, but also *objects* in the columns. In this section we will discuss briefly the `TNtuple` class, which is a; simplified version of the `TTree` class. A ROOT `TNtuple` object can; store rows of float entries. Let's tackle the problem according to the; usual strategy commenting a minimal example. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/write_ntuple_to_file.C; ```. This data written to this example n-tuple repres",MatchSource.DOCS,documentation/primer/filio.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md:1514,Usability,simpl,simple,1514,"cope of this document: it is worth to mention; that I/O can be performed out of the box for the almost complete set; of ROOT classes. We can explore this functionality with histograms and two simple macros. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/write_to_file.C; ```. Not bad, eh ? Especially for a language that does not foresees; persistency natively like C++. The *RECREATE* option forces ROOT to; create a new file even if a file with the same name exists on disk. Now, you may use the Cling command line to access information in the file; and draw the previously written histogram:. ``` {.cpp}; > root my_rootfile.root; root [0]; Attaching file my_rootfile.root as _file0...; root [1] _file0->ls(); TFile** my_rootfile.root; TFile* my_rootfile.root; KEY: TH1F	my_histogram;1 My Title; root [2] my_histogram->Draw(); ```; \newpage; Alternatively, you can use a simple macro to carry out the job:. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/read_from_file.C; ```. ## N-tuples in ROOT ##. ### Storing simple N-tuples ###. Up to now we have seen how to manipulate input read from ASCII files.; ROOT offers the possibility to do much better than that, with its own; n-tuple classes. Among the many advantages provided by these classes one; could cite. - Optimised disk I/O. - Possibility to store many n-tuple rows. - Write the n-tuples in ROOT files. - Interactive inspection with `TBrowser`. - Store not only numbers, but also *objects* in the columns. In this section we will discuss briefly the `TNtuple` class, which is a; simplified version of the `TTree` class. A ROOT `TNtuple` object can; store rows of float entries. Let's tackle the problem according to the; usual strategy commenting a minimal example. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/write_ntuple_to_file.C; ```. This data written to this example n-tuple represents, in the statistical; sense, three independent variables (Potential or Voltage, Pressure and; Temperature), and one variable (Current) which depends on the others; according",MatchSource.DOCS,documentation/primer/filio.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md:2039,Usability,simpl,simplified,2039,"ne to access information in the file; and draw the previously written histogram:. ``` {.cpp}; > root my_rootfile.root; root [0]; Attaching file my_rootfile.root as _file0...; root [1] _file0->ls(); TFile** my_rootfile.root; TFile* my_rootfile.root; KEY: TH1F	my_histogram;1 My Title; root [2] my_histogram->Draw(); ```; \newpage; Alternatively, you can use a simple macro to carry out the job:. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/read_from_file.C; ```. ## N-tuples in ROOT ##. ### Storing simple N-tuples ###. Up to now we have seen how to manipulate input read from ASCII files.; ROOT offers the possibility to do much better than that, with its own; n-tuple classes. Among the many advantages provided by these classes one; could cite. - Optimised disk I/O. - Possibility to store many n-tuple rows. - Write the n-tuples in ROOT files. - Interactive inspection with `TBrowser`. - Store not only numbers, but also *objects* in the columns. In this section we will discuss briefly the `TNtuple` class, which is a; simplified version of the `TTree` class. A ROOT `TNtuple` object can; store rows of float entries. Let's tackle the problem according to the; usual strategy commenting a minimal example. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/write_ntuple_to_file.C; ```. This data written to this example n-tuple represents, in the statistical; sense, three independent variables (Potential or Voltage, Pressure and; Temperature), and one variable (Current) which depends on the others; according to very simple laws, and an additional Gaussian smearing. This; set of variables mimics a measurement of an electrical resistance while; varying pressure and temperature. Imagine your task now consists in finding the relations among the; variables -- of course without knowing the code used to generate them.; You will see that the possibilities of the `NTuple` class enable you to; perform this analysis task. Open the ROOT file (`cond_data.root`); written by the macro above in an interactive session ",MatchSource.DOCS,documentation/primer/filio.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md:2527,Usability,simpl,simple,2527,"_INCLUDE_FILE macros/read_from_file.C; ```. ## N-tuples in ROOT ##. ### Storing simple N-tuples ###. Up to now we have seen how to manipulate input read from ASCII files.; ROOT offers the possibility to do much better than that, with its own; n-tuple classes. Among the many advantages provided by these classes one; could cite. - Optimised disk I/O. - Possibility to store many n-tuple rows. - Write the n-tuples in ROOT files. - Interactive inspection with `TBrowser`. - Store not only numbers, but also *objects* in the columns. In this section we will discuss briefly the `TNtuple` class, which is a; simplified version of the `TTree` class. A ROOT `TNtuple` object can; store rows of float entries. Let's tackle the problem according to the; usual strategy commenting a minimal example. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/write_ntuple_to_file.C; ```. This data written to this example n-tuple represents, in the statistical; sense, three independent variables (Potential or Voltage, Pressure and; Temperature), and one variable (Current) which depends on the others; according to very simple laws, and an additional Gaussian smearing. This; set of variables mimics a measurement of an electrical resistance while; varying pressure and temperature. Imagine your task now consists in finding the relations among the; variables -- of course without knowing the code used to generate them.; You will see that the possibilities of the `NTuple` class enable you to; perform this analysis task. Open the ROOT file (`cond_data.root`); written by the macro above in an interactive session and use a; `TBrowser` to interactively inspect it:. ``` {.cpp}; root[0] TBrowser b; ```; You find the columns of your n-tuple written as *leafs*. Simply clicking; on them you can obtain histograms of the variables!. Next, try the following commands at the shell prompt and in the; interactive ROOT shell, respectively:. ``` {.cpp}; > root conductivity_experiment.root; Attaching file conductivity_experiment.root",MatchSource.DOCS,documentation/primer/filio.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md:3825,Usability,clear,clear,3825," enable you to; perform this analysis task. Open the ROOT file (`cond_data.root`); written by the macro above in an interactive session and use a; `TBrowser` to interactively inspect it:. ``` {.cpp}; root[0] TBrowser b; ```; You find the columns of your n-tuple written as *leafs*. Simply clicking; on them you can obtain histograms of the variables!. Next, try the following commands at the shell prompt and in the; interactive ROOT shell, respectively:. ``` {.cpp}; > root conductivity_experiment.root; Attaching file conductivity_experiment.root as _file0...; root [0] cond_data->Draw(""Current:Potential""); ```. You just produced a correlation plot with one single line of code!. Try to extend the syntax typing for example. ``` {.cpp}; root [1] cond_data->Draw(""Current:Potential"",""Temperature<270""); ```. What do you obtain ?. Now try. ``` {.cpp}; root [2] cond_data->Draw(""Current/Potential:Temperature""); ```. It should have become clear from these examples how to navigate in such; a multi-dimensional space of variables and unveil relations between; variables using n-tuples. ### Reading N-tuples. For completeness, you find here a small macro to read the data back from; a ROOT n-tuple. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/read_ntuple_from_file.C; ```. The macro shows the easiest way of accessing the content of a n-tuple:; after loading the n-tuple, its branches are assigned to variables and; `GetEntry(long)` automatically fills them with the content for a; specific row. By doing so, the logic for reading the n-tuple and the; code to process it can be split and the source code remains clear. ### Storing Arbitrary N-tuples ###. It is also possible to write n-tuples of arbitrary type by using ROOT's; `TBranch` class. This is especially important as `TNtuple::Fill()`; accepts only floats. The following macro creates the same n-tuple as; before but the branches are booked directly. The `Fill()` function then; fills the current values of the connected variables to the tree. ``` ",MatchSource.DOCS,documentation/primer/filio.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md:4490,Usability,clear,clear,4490," as _file0...; root [0] cond_data->Draw(""Current:Potential""); ```. You just produced a correlation plot with one single line of code!. Try to extend the syntax typing for example. ``` {.cpp}; root [1] cond_data->Draw(""Current:Potential"",""Temperature<270""); ```. What do you obtain ?. Now try. ``` {.cpp}; root [2] cond_data->Draw(""Current/Potential:Temperature""); ```. It should have become clear from these examples how to navigate in such; a multi-dimensional space of variables and unveil relations between; variables using n-tuples. ### Reading N-tuples. For completeness, you find here a small macro to read the data back from; a ROOT n-tuple. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/read_ntuple_from_file.C; ```. The macro shows the easiest way of accessing the content of a n-tuple:; after loading the n-tuple, its branches are assigned to variables and; `GetEntry(long)` automatically fills them with the content for a; specific row. By doing so, the logic for reading the n-tuple and the; code to process it can be split and the source code remains clear. ### Storing Arbitrary N-tuples ###. It is also possible to write n-tuples of arbitrary type by using ROOT's; `TBranch` class. This is especially important as `TNtuple::Fill()`; accepts only floats. The following macro creates the same n-tuple as; before but the branches are booked directly. The `Fill()` function then; fills the current values of the connected variables to the tree. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/write_ntuple_to_file_advanced.C; ```. The `Branch()` function requires a pointer to a variable and a; definition of the variable type. The following table lists some of the possible; values.; Please note that ROOT is not checking the input and mistakes are likely; to result in serious problems. This holds especially if values are read; as another type than they have been written, e.g. when storing a; variable as float and reading it as double. List of variable types that can be used to define the type of a bra",MatchSource.DOCS,documentation/primer/filio.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md:7821,Usability,simpl,simple,7821," from the example; above and creates from it the header file `MySelector.h` and a template; to insert your own analysis code, `MySelector.C`.; \newpage. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/makeMySelector.C; ```. The template contains the entry points `Begin()` and `SlaveBegin()`; called before processing of the `TChain` starts, `Process()` called for; every entry of the chain, and `SlaveTerminate()` and `Terminate()`; called after the last entry has been processed. Typically,; initialization like booking of histograms is performed in; `SlaveBegin()`, the analysis, i.e. the selection of entries,; calculations and filling of histograms, is done in `Process()`, and; final operations like plotting and storing of results happen in; `SlaveTerminate()` or `Terminate()`. The entry points `SlaveBegin()` and `SlaveTerminate()` are called on; so-called slave nodes only if parallel processing via `PROOF` or; `PROOF lite` is enabled, as will be explained below. A simple example of a selector class is shown in the macro; `MySelector.C`. The example is executed with the following sequence of; commands:. ``` {.cpp}; > TChain *ch=new TChain(""cond_data"", ""Chain for Example N-Tuple"");; > ch->Add(""conductivity_experiment*.root"");; > ch->Process(""MySelector.C+"");; ```. As usual, the ""`+`"" appended to the name of the macro to be executed; initiates the compilation of the `MySelector.C` with the system compiler; in order to improve performance. The code in `MySelector.C`, shown in the listing below, books some; histograms in `SlaveBegin()` and adds them to the instance `fOutput`,; which is of the class `TList` [^6]. The final processing in; `Terminate()` allows to access histograms and store, display or save; them as pictures. This is shown in the example via the `TList`; `fOutput`. See the commented listing below for more details; most of the; text is actually comments generated automatically by; `TTree::MakeSelector`. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/MySelector.C; ```. ### *For po",MatchSource.DOCS,documentation/primer/filio.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md:13664,Usability,simpl,simple,13664,"; something goes wrong. As the method described here also works without; using PROOF, the development work on an analysis script can be done in; the standard way on a small subset of the data, and only for the full; processing one would use parallelism via PROOF. It is worth to remind the reader that the speed of typical data analysis; programs limited by the I/O speed (for example the latencies implied by; reading data from a hard drive). It is therefore expected that this; limitation cannot be eliminated with the usage of any parallel analysis; toolkit. ### Optimisation Regarding N-tuples ###. ROOT automatically applies compression algorithms on n-tuples to reduce; the memory consumption. A value that is in most cases the same will; consume only small space on your disk (but it has to be decompressed on; reading). Nevertheless, you should think about the design of your; n-tuples and your analyses as soon as the processing time exceeds some; minutes. - Try to keep your n-tuples simple and use appropriate variable types.; If your measurement has only a limited precision, it is needless to; store it with double precision. - Experimental conditions that do not change with every single; measurement should be stored in a separate tree. Although the; compression can handle redundant values, the processing time; increase with every variable that has to be filled. - The function `SetCacheSize(long)` specifies the size of the cache; for reading a `TTree` object from a file. The default value is 30MB.; A manual increase may help in certain situations. Please note that; the caching mechanism can cover only one `TTree` object per `TFile`; object. - You can select the branches to be covered by the caching algorithm; with `AddBranchToCache` and deactivate unneeded branches with; `SetBranchStatus`. This mechanism can result in a significant; speed-up for simple operations on trees with many branches. - You can measure the performance easily with `TTreePerfStats`. The; ROOT documen",MatchSource.DOCS,documentation/primer/filio.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md:14543,Usability,simpl,simple,14543,"d that this; limitation cannot be eliminated with the usage of any parallel analysis; toolkit. ### Optimisation Regarding N-tuples ###. ROOT automatically applies compression algorithms on n-tuples to reduce; the memory consumption. A value that is in most cases the same will; consume only small space on your disk (but it has to be decompressed on; reading). Nevertheless, you should think about the design of your; n-tuples and your analyses as soon as the processing time exceeds some; minutes. - Try to keep your n-tuples simple and use appropriate variable types.; If your measurement has only a limited precision, it is needless to; store it with double precision. - Experimental conditions that do not change with every single; measurement should be stored in a separate tree. Although the; compression can handle redundant values, the processing time; increase with every variable that has to be filled. - The function `SetCacheSize(long)` specifies the size of the cache; for reading a `TTree` object from a file. The default value is 30MB.; A manual increase may help in certain situations. Please note that; the caching mechanism can cover only one `TTree` object per `TFile`; object. - You can select the branches to be covered by the caching algorithm; with `AddBranchToCache` and deactivate unneeded branches with; `SetBranchStatus`. This mechanism can result in a significant; speed-up for simple operations on trees with many branches. - You can measure the performance easily with `TTreePerfStats`. The; ROOT documentation on this class also includes an introductory; example. For example, `TTreePerfStats` can show you that it is; beneficial to store meta data and payload data separately, i.e.; write the meta data tree in a bulk to a file at the end of your job; instead of writing both trees interleaved. [^6]: The usage of `fOutput` is not really needed for this simple example, but it allows re-usage of the exact code in parallel processing with `PROOF` (see next section).; ",MatchSource.DOCS,documentation/primer/filio.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md:15023,Usability,simpl,simple,15023,"d that this; limitation cannot be eliminated with the usage of any parallel analysis; toolkit. ### Optimisation Regarding N-tuples ###. ROOT automatically applies compression algorithms on n-tuples to reduce; the memory consumption. A value that is in most cases the same will; consume only small space on your disk (but it has to be decompressed on; reading). Nevertheless, you should think about the design of your; n-tuples and your analyses as soon as the processing time exceeds some; minutes. - Try to keep your n-tuples simple and use appropriate variable types.; If your measurement has only a limited precision, it is needless to; store it with double precision. - Experimental conditions that do not change with every single; measurement should be stored in a separate tree. Although the; compression can handle redundant values, the processing time; increase with every variable that has to be filled. - The function `SetCacheSize(long)` specifies the size of the cache; for reading a `TTree` object from a file. The default value is 30MB.; A manual increase may help in certain situations. Please note that; the caching mechanism can cover only one `TTree` object per `TFile`; object. - You can select the branches to be covered by the caching algorithm; with `AddBranchToCache` and deactivate unneeded branches with; `SetBranchStatus`. This mechanism can result in a significant; speed-up for simple operations on trees with many branches. - You can measure the performance easily with `TTreePerfStats`. The; ROOT documentation on this class also includes an introductory; example. For example, `TTreePerfStats` can show you that it is; beneficial to store meta data and payload data separately, i.e.; write the meta data tree in a bulk to a file at the end of your job; instead of writing both trees interleaved. [^6]: The usage of `fOutput` is not really needed for this simple example, but it allows re-usage of the exact code in parallel processing with `PROOF` (see next section).; ",MatchSource.DOCS,documentation/primer/filio.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/functions_and_parameter_estimation.md:1403,Availability,error,error,1403,"he fundamental topic of parameter; estimation by fitting functions to data. For graphs and histograms, ROOT; offers an easy-to-use interface to perform fits - either the fit panel; of the graphical interface, or the `Fit` method. The class `TFitResult`; allows access to the detailed results. Very often it is necessary to study the statistical properties of; analysis procedures. This is most easily achieved by applying the; analysis to many sets of simulated data (or ""pseudo data""), each; representing one possible version of the true experiment. If the; simulation only deals with the final distributions observed in data, and; does not perform a full simulation of the underlying physics and the; experimental apparatus, the name ""Toy Monte Carlo"" is frequently used; [^5]. Since the true values of all parameters are known in the; pseudo-data, the differences between the parameter estimates from the; analysis procedure w.r.t. the true values can be determined, and it is; also possible to check that the analysis procedure provides correct; error estimates. ## Fitting Functions to Pseudo Data ##. In the example below, a pseudo-data set is produced and a model fitted; to it. ROOT offers various minimisation algorithms to minimise a chi2 or a; negative log-likelihood function. The default minimiser is MINUIT, a; package originally implemented in the FORTRAN programming language. A; C++ version is also available, MINUIT2, as well as Fumili [@Fumili] an; algorithm optimised for fitting. The; minimisation algorithms can be selected using the static functions of; the `ROOT::Math::MinimizerOptions` class. Steering options for the; minimiser, such as the convergence tolerance or the maximum number of; function calls, can also be set using the methods of this class. All; currently implemented minimisers are documented in the reference; documentation of ROOT: have a look for example to the; `ROOT::Math::Minimizer` class documentation.; \newpage; The complication level of the code be",MatchSource.DOCS,documentation/primer/functions_and_parameter_estimation.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/functions_and_parameter_estimation.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/functions_and_parameter_estimation.md:1769,Availability,avail,available,1769,"ts of simulated data (or ""pseudo data""), each; representing one possible version of the true experiment. If the; simulation only deals with the final distributions observed in data, and; does not perform a full simulation of the underlying physics and the; experimental apparatus, the name ""Toy Monte Carlo"" is frequently used; [^5]. Since the true values of all parameters are known in the; pseudo-data, the differences between the parameter estimates from the; analysis procedure w.r.t. the true values can be determined, and it is; also possible to check that the analysis procedure provides correct; error estimates. ## Fitting Functions to Pseudo Data ##. In the example below, a pseudo-data set is produced and a model fitted; to it. ROOT offers various minimisation algorithms to minimise a chi2 or a; negative log-likelihood function. The default minimiser is MINUIT, a; package originally implemented in the FORTRAN programming language. A; C++ version is also available, MINUIT2, as well as Fumili [@Fumili] an; algorithm optimised for fitting. The; minimisation algorithms can be selected using the static functions of; the `ROOT::Math::MinimizerOptions` class. Steering options for the; minimiser, such as the convergence tolerance or the maximum number of; function calls, can also be set using the methods of this class. All; currently implemented minimisers are documented in the reference; documentation of ROOT: have a look for example to the; `ROOT::Math::Minimizer` class documentation.; \newpage; The complication level of the code below is intentionally a little; higher than in the previous examples. The graphical output of the macro; is shown in Figure [6.1](#f61):. ``` {.cpp .numberLines}; @ROOT_INCLUDE_FILE macros/macro8.C; ```. Some step by step explanation is at this point necessary:. - Lines *1-3*: A simple function to ease the make-up of lines.; Remember that the class `TF1` inherits from `TAttLine`. - Lines *5-7* : Definition of a customised function, namely a Ga",MatchSource.DOCS,documentation/primer/functions_and_parameter_estimation.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/functions_and_parameter_estimation.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/functions_and_parameter_estimation.md:2033,Availability,toler,tolerance,2033,"he; experimental apparatus, the name ""Toy Monte Carlo"" is frequently used; [^5]. Since the true values of all parameters are known in the; pseudo-data, the differences between the parameter estimates from the; analysis procedure w.r.t. the true values can be determined, and it is; also possible to check that the analysis procedure provides correct; error estimates. ## Fitting Functions to Pseudo Data ##. In the example below, a pseudo-data set is produced and a model fitted; to it. ROOT offers various minimisation algorithms to minimise a chi2 or a; negative log-likelihood function. The default minimiser is MINUIT, a; package originally implemented in the FORTRAN programming language. A; C++ version is also available, MINUIT2, as well as Fumili [@Fumili] an; algorithm optimised for fitting. The; minimisation algorithms can be selected using the static functions of; the `ROOT::Math::MinimizerOptions` class. Steering options for the; minimiser, such as the convergence tolerance or the maximum number of; function calls, can also be set using the methods of this class. All; currently implemented minimisers are documented in the reference; documentation of ROOT: have a look for example to the; `ROOT::Math::Minimizer` class documentation.; \newpage; The complication level of the code below is intentionally a little; higher than in the previous examples. The graphical output of the macro; is shown in Figure [6.1](#f61):. ``` {.cpp .numberLines}; @ROOT_INCLUDE_FILE macros/macro8.C; ```. Some step by step explanation is at this point necessary:. - Lines *1-3*: A simple function to ease the make-up of lines.; Remember that the class `TF1` inherits from `TAttLine`. - Lines *5-7* : Definition of a customised function, namely a Gaussian; (the ""signal"") plus a parabolic function, the ""background"". - Lines *10-12*: Some make-up for the Canvas. In particular we want; that the parameters of the fit appear very clearly and nicely on the; plot. - Lines *20-25*: Define and initialise a",MatchSource.DOCS,documentation/primer/functions_and_parameter_estimation.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/functions_and_parameter_estimation.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/functions_and_parameter_estimation.md:4234,Availability,avail,available,4234," is used in the fit; hence, we need to; reset the function parameters. This part of the code is very; important for each fit procedure, as it sets the initial values of; the fit. - Line *41*: A very simple command, well known by now: fit the; function to the histogram. - Lines *42-46*: Retrieve the output from the fit. Here, we simply; print the fit result and access and print the covariance matrix of; the parameters. - Lines *54-end*: Plot the pseudo-data, the fitted function and the; signal and background components at the best-fit values. [f61]: figures/functions.png ""f61""; <a name=""f61""></a>. ![Fit of pseudo data: a signal shape over a background trend. This plot; is another example of how making a plot ""self-explanatory"" can help you; better displaying your results. \label{f61}][f61]. ## Toy Monte Carlo Experiments ##. Let us look at a simple example of a toy experiment comparing two; methods to fit a function to a histogram, the $\chi^{2}$. method and a method called ""binned log-likelihood fit"", both available in ROOT. As a very simple yet powerful quantity to check the quality of the fit; results, we construct for each pseudo-data set the so-called ""pull"", the; difference of the estimated and the true value of a parameter,; normalised to the estimated error on the parameter,; $\frac{(p_{estim} - p_{true})}{\sigma_{p}}$. If everything is OK, the; distribution of the pull values is a standard normal distribution, i.e.; a Gaussian distribution centred around zero with a standard deviation of one. The macro performs a rather big number of toy experiments, where a; histogram is repeatedly filled with Gaussian distributed numbers,; representing the pseudo-data in this example. Each time, a fit is; performed according to the selected method, and the pull is calculated; and filled into a histogram. Here is the code:. ``` {.cpp .numberLines}; @ROOT_INCLUDE_FILE macros/macro9.C; ```. Your present knowledge of ROOT should be enough to understand all the; technicalities ",MatchSource.DOCS,documentation/primer/functions_and_parameter_estimation.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/functions_and_parameter_estimation.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/functions_and_parameter_estimation.md:4491,Availability,error,error,4491,"very simple command, well known by now: fit the; function to the histogram. - Lines *42-46*: Retrieve the output from the fit. Here, we simply; print the fit result and access and print the covariance matrix of; the parameters. - Lines *54-end*: Plot the pseudo-data, the fitted function and the; signal and background components at the best-fit values. [f61]: figures/functions.png ""f61""; <a name=""f61""></a>. ![Fit of pseudo data: a signal shape over a background trend. This plot; is another example of how making a plot ""self-explanatory"" can help you; better displaying your results. \label{f61}][f61]. ## Toy Monte Carlo Experiments ##. Let us look at a simple example of a toy experiment comparing two; methods to fit a function to a histogram, the $\chi^{2}$. method and a method called ""binned log-likelihood fit"", both available in ROOT. As a very simple yet powerful quantity to check the quality of the fit; results, we construct for each pseudo-data set the so-called ""pull"", the; difference of the estimated and the true value of a parameter,; normalised to the estimated error on the parameter,; $\frac{(p_{estim} - p_{true})}{\sigma_{p}}$. If everything is OK, the; distribution of the pull values is a standard normal distribution, i.e.; a Gaussian distribution centred around zero with a standard deviation of one. The macro performs a rather big number of toy experiments, where a; histogram is repeatedly filled with Gaussian distributed numbers,; representing the pseudo-data in this example. Each time, a fit is; performed according to the selected method, and the pull is calculated; and filled into a histogram. Here is the code:. ``` {.cpp .numberLines}; @ROOT_INCLUDE_FILE macros/macro9.C; ```. Your present knowledge of ROOT should be enough to understand all the; technicalities behind the macro. Note that the variable `pull` in line; *61* is different from the definition above: instead of the parameter; error on `mean`, the fitted standard deviation of the distribution",MatchSource.DOCS,documentation/primer/functions_and_parameter_estimation.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/functions_and_parameter_estimation.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/functions_and_parameter_estimation.md:5340,Availability,error,error,5340,"}][f61]. ## Toy Monte Carlo Experiments ##. Let us look at a simple example of a toy experiment comparing two; methods to fit a function to a histogram, the $\chi^{2}$. method and a method called ""binned log-likelihood fit"", both available in ROOT. As a very simple yet powerful quantity to check the quality of the fit; results, we construct for each pseudo-data set the so-called ""pull"", the; difference of the estimated and the true value of a parameter,; normalised to the estimated error on the parameter,; $\frac{(p_{estim} - p_{true})}{\sigma_{p}}$. If everything is OK, the; distribution of the pull values is a standard normal distribution, i.e.; a Gaussian distribution centred around zero with a standard deviation of one. The macro performs a rather big number of toy experiments, where a; histogram is repeatedly filled with Gaussian distributed numbers,; representing the pseudo-data in this example. Each time, a fit is; performed according to the selected method, and the pull is calculated; and filled into a histogram. Here is the code:. ``` {.cpp .numberLines}; @ROOT_INCLUDE_FILE macros/macro9.C; ```. Your present knowledge of ROOT should be enough to understand all the; technicalities behind the macro. Note that the variable `pull` in line; *61* is different from the definition above: instead of the parameter; error on `mean`, the fitted standard deviation of the distribution; divided by the square root of the number of entries,; `sig/sqrt(n_tot_entries)`, is used. - What method exhibits the better performance with the default; parameters ?. - What happens if you increase the number of entries per histogram by; a factor of ten ? Why ?. The answers to these questions are well beyond the scope of this guide.; Basically all books about statistical methods provide a complete; treatment of the aforementioned topics. [^5]: ""Monte Carlo"" simulation means that random numbers play a role here; which is as crucial as in games of pure chance in the Casino of Monte Carlo.; ",MatchSource.DOCS,documentation/primer/functions_and_parameter_estimation.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/functions_and_parameter_estimation.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/functions_and_parameter_estimation.md:4274,Energy Efficiency,power,powerful,4274,"very simple command, well known by now: fit the; function to the histogram. - Lines *42-46*: Retrieve the output from the fit. Here, we simply; print the fit result and access and print the covariance matrix of; the parameters. - Lines *54-end*: Plot the pseudo-data, the fitted function and the; signal and background components at the best-fit values. [f61]: figures/functions.png ""f61""; <a name=""f61""></a>. ![Fit of pseudo data: a signal shape over a background trend. This plot; is another example of how making a plot ""self-explanatory"" can help you; better displaying your results. \label{f61}][f61]. ## Toy Monte Carlo Experiments ##. Let us look at a simple example of a toy experiment comparing two; methods to fit a function to a histogram, the $\chi^{2}$. method and a method called ""binned log-likelihood fit"", both available in ROOT. As a very simple yet powerful quantity to check the quality of the fit; results, we construct for each pseudo-data set the so-called ""pull"", the; difference of the estimated and the true value of a parameter,; normalised to the estimated error on the parameter,; $\frac{(p_{estim} - p_{true})}{\sigma_{p}}$. If everything is OK, the; distribution of the pull values is a standard normal distribution, i.e.; a Gaussian distribution centred around zero with a standard deviation of one. The macro performs a rather big number of toy experiments, where a; histogram is repeatedly filled with Gaussian distributed numbers,; representing the pseudo-data in this example. Each time, a fit is; performed according to the selected method, and the pull is calculated; and filled into a histogram. Here is the code:. ``` {.cpp .numberLines}; @ROOT_INCLUDE_FILE macros/macro9.C; ```. Your present knowledge of ROOT should be enough to understand all the; technicalities behind the macro. Note that the variable `pull` in line; *61* is different from the definition above: instead of the parameter; error on `mean`, the fitted standard deviation of the distribution",MatchSource.DOCS,documentation/primer/functions_and_parameter_estimation.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/functions_and_parameter_estimation.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/functions_and_parameter_estimation.md:484,Integrability,interface,interface,484,"# Functions and Parameter Estimation #. After going through the previous chapters, you already know how to use; analytical functions (class `TF1`), and you got some insight into the; graph (`TGraphErrors`) and histogram classes (`TH1F`) for data; visualisation. In this chapter we will add more detail to the previous; approximate explanations to face the fundamental topic of parameter; estimation by fitting functions to data. For graphs and histograms, ROOT; offers an easy-to-use interface to perform fits - either the fit panel; of the graphical interface, or the `Fit` method. The class `TFitResult`; allows access to the detailed results. Very often it is necessary to study the statistical properties of; analysis procedures. This is most easily achieved by applying the; analysis to many sets of simulated data (or ""pseudo data""), each; representing one possible version of the true experiment. If the; simulation only deals with the final distributions observed in data, and; does not perform a full simulation of the underlying physics and the; experimental apparatus, the name ""Toy Monte Carlo"" is frequently used; [^5]. Since the true values of all parameters are known in the; pseudo-data, the differences between the parameter estimates from the; analysis procedure w.r.t. the true values can be determined, and it is; also possible to check that the analysis procedure provides correct; error estimates. ## Fitting Functions to Pseudo Data ##. In the example below, a pseudo-data set is produced and a model fitted; to it. ROOT offers various minimisation algorithms to minimise a chi2 or a; negative log-likelihood function. The default minimiser is MINUIT, a; package originally implemented in the FORTRAN programming language. A; C++ version is also available, MINUIT2, as well as Fumili [@Fumili] an; algorithm optimised for fitting. The; minimisation algorithms can be selected using the static functions of; the `ROOT::Math::MinimizerOptions` class. Steering options for the; min",MatchSource.DOCS,documentation/primer/functions_and_parameter_estimation.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/functions_and_parameter_estimation.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/functions_and_parameter_estimation.md:551,Integrability,interface,interface,551,"# Functions and Parameter Estimation #. After going through the previous chapters, you already know how to use; analytical functions (class `TF1`), and you got some insight into the; graph (`TGraphErrors`) and histogram classes (`TH1F`) for data; visualisation. In this chapter we will add more detail to the previous; approximate explanations to face the fundamental topic of parameter; estimation by fitting functions to data. For graphs and histograms, ROOT; offers an easy-to-use interface to perform fits - either the fit panel; of the graphical interface, or the `Fit` method. The class `TFitResult`; allows access to the detailed results. Very often it is necessary to study the statistical properties of; analysis procedures. This is most easily achieved by applying the; analysis to many sets of simulated data (or ""pseudo data""), each; representing one possible version of the true experiment. If the; simulation only deals with the final distributions observed in data, and; does not perform a full simulation of the underlying physics and the; experimental apparatus, the name ""Toy Monte Carlo"" is frequently used; [^5]. Since the true values of all parameters are known in the; pseudo-data, the differences between the parameter estimates from the; analysis procedure w.r.t. the true values can be determined, and it is; also possible to check that the analysis procedure provides correct; error estimates. ## Fitting Functions to Pseudo Data ##. In the example below, a pseudo-data set is produced and a model fitted; to it. ROOT offers various minimisation algorithms to minimise a chi2 or a; negative log-likelihood function. The default minimiser is MINUIT, a; package originally implemented in the FORTRAN programming language. A; C++ version is also available, MINUIT2, as well as Fumili [@Fumili] an; algorithm optimised for fitting. The; minimisation algorithms can be selected using the static functions of; the `ROOT::Math::MinimizerOptions` class. Steering options for the; min",MatchSource.DOCS,documentation/primer/functions_and_parameter_estimation.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/functions_and_parameter_estimation.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/functions_and_parameter_estimation.md:2709,Modifiability,inherit,inherits,2709,"ted in the FORTRAN programming language. A; C++ version is also available, MINUIT2, as well as Fumili [@Fumili] an; algorithm optimised for fitting. The; minimisation algorithms can be selected using the static functions of; the `ROOT::Math::MinimizerOptions` class. Steering options for the; minimiser, such as the convergence tolerance or the maximum number of; function calls, can also be set using the methods of this class. All; currently implemented minimisers are documented in the reference; documentation of ROOT: have a look for example to the; `ROOT::Math::Minimizer` class documentation.; \newpage; The complication level of the code below is intentionally a little; higher than in the previous examples. The graphical output of the macro; is shown in Figure [6.1](#f61):. ``` {.cpp .numberLines}; @ROOT_INCLUDE_FILE macros/macro8.C; ```. Some step by step explanation is at this point necessary:. - Lines *1-3*: A simple function to ease the make-up of lines.; Remember that the class `TF1` inherits from `TAttLine`. - Lines *5-7* : Definition of a customised function, namely a Gaussian; (the ""signal"") plus a parabolic function, the ""background"". - Lines *10-12*: Some make-up for the Canvas. In particular we want; that the parameters of the fit appear very clearly and nicely on the; plot. - Lines *20-25*: Define and initialise an instance of `TF1`. - Lines *27-31*: Define and fill a histogram. - Lines *33-38*: For convenience, the same function as for the; generation of the pseudo-data is used in the fit; hence, we need to; reset the function parameters. This part of the code is very; important for each fit procedure, as it sets the initial values of; the fit. - Line *41*: A very simple command, well known by now: fit the; function to the histogram. - Lines *42-46*: Retrieve the output from the fit. Here, we simply; print the fit result and access and print the covariance matrix of; the parameters. - Lines *54-end*: Plot the pseudo-data, the fitted function and the; sig",MatchSource.DOCS,documentation/primer/functions_and_parameter_estimation.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/functions_and_parameter_estimation.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/functions_and_parameter_estimation.md:5244,Modifiability,variab,variable,5244,"}][f61]. ## Toy Monte Carlo Experiments ##. Let us look at a simple example of a toy experiment comparing two; methods to fit a function to a histogram, the $\chi^{2}$. method and a method called ""binned log-likelihood fit"", both available in ROOT. As a very simple yet powerful quantity to check the quality of the fit; results, we construct for each pseudo-data set the so-called ""pull"", the; difference of the estimated and the true value of a parameter,; normalised to the estimated error on the parameter,; $\frac{(p_{estim} - p_{true})}{\sigma_{p}}$. If everything is OK, the; distribution of the pull values is a standard normal distribution, i.e.; a Gaussian distribution centred around zero with a standard deviation of one. The macro performs a rather big number of toy experiments, where a; histogram is repeatedly filled with Gaussian distributed numbers,; representing the pseudo-data in this example. Each time, a fit is; performed according to the selected method, and the pull is calculated; and filled into a histogram. Here is the code:. ``` {.cpp .numberLines}; @ROOT_INCLUDE_FILE macros/macro9.C; ```. Your present knowledge of ROOT should be enough to understand all the; technicalities behind the macro. Note that the variable `pull` in line; *61* is different from the definition above: instead of the parameter; error on `mean`, the fitted standard deviation of the distribution; divided by the square root of the number of entries,; `sig/sqrt(n_tot_entries)`, is used. - What method exhibits the better performance with the default; parameters ?. - What happens if you increase the number of entries per histogram by; a factor of ten ? Why ?. The answers to these questions are well beyond the scope of this guide.; Basically all books about statistical methods provide a complete; treatment of the aforementioned topics. [^5]: ""Monte Carlo"" simulation means that random numbers play a role here; which is as crucial as in games of pure chance in the Casino of Monte Carlo.; ",MatchSource.DOCS,documentation/primer/functions_and_parameter_estimation.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/functions_and_parameter_estimation.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/functions_and_parameter_estimation.md:497,Performance,perform,perform,497,"# Functions and Parameter Estimation #. After going through the previous chapters, you already know how to use; analytical functions (class `TF1`), and you got some insight into the; graph (`TGraphErrors`) and histogram classes (`TH1F`) for data; visualisation. In this chapter we will add more detail to the previous; approximate explanations to face the fundamental topic of parameter; estimation by fitting functions to data. For graphs and histograms, ROOT; offers an easy-to-use interface to perform fits - either the fit panel; of the graphical interface, or the `Fit` method. The class `TFitResult`; allows access to the detailed results. Very often it is necessary to study the statistical properties of; analysis procedures. This is most easily achieved by applying the; analysis to many sets of simulated data (or ""pseudo data""), each; representing one possible version of the true experiment. If the; simulation only deals with the final distributions observed in data, and; does not perform a full simulation of the underlying physics and the; experimental apparatus, the name ""Toy Monte Carlo"" is frequently used; [^5]. Since the true values of all parameters are known in the; pseudo-data, the differences between the parameter estimates from the; analysis procedure w.r.t. the true values can be determined, and it is; also possible to check that the analysis procedure provides correct; error estimates. ## Fitting Functions to Pseudo Data ##. In the example below, a pseudo-data set is produced and a model fitted; to it. ROOT offers various minimisation algorithms to minimise a chi2 or a; negative log-likelihood function. The default minimiser is MINUIT, a; package originally implemented in the FORTRAN programming language. A; C++ version is also available, MINUIT2, as well as Fumili [@Fumili] an; algorithm optimised for fitting. The; minimisation algorithms can be selected using the static functions of; the `ROOT::Math::MinimizerOptions` class. Steering options for the; min",MatchSource.DOCS,documentation/primer/functions_and_parameter_estimation.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/functions_and_parameter_estimation.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/functions_and_parameter_estimation.md:995,Performance,perform,perform,995,"arameter Estimation #. After going through the previous chapters, you already know how to use; analytical functions (class `TF1`), and you got some insight into the; graph (`TGraphErrors`) and histogram classes (`TH1F`) for data; visualisation. In this chapter we will add more detail to the previous; approximate explanations to face the fundamental topic of parameter; estimation by fitting functions to data. For graphs and histograms, ROOT; offers an easy-to-use interface to perform fits - either the fit panel; of the graphical interface, or the `Fit` method. The class `TFitResult`; allows access to the detailed results. Very often it is necessary to study the statistical properties of; analysis procedures. This is most easily achieved by applying the; analysis to many sets of simulated data (or ""pseudo data""), each; representing one possible version of the true experiment. If the; simulation only deals with the final distributions observed in data, and; does not perform a full simulation of the underlying physics and the; experimental apparatus, the name ""Toy Monte Carlo"" is frequently used; [^5]. Since the true values of all parameters are known in the; pseudo-data, the differences between the parameter estimates from the; analysis procedure w.r.t. the true values can be determined, and it is; also possible to check that the analysis procedure provides correct; error estimates. ## Fitting Functions to Pseudo Data ##. In the example below, a pseudo-data set is produced and a model fitted; to it. ROOT offers various minimisation algorithms to minimise a chi2 or a; negative log-likelihood function. The default minimiser is MINUIT, a; package originally implemented in the FORTRAN programming language. A; C++ version is also available, MINUIT2, as well as Fumili [@Fumili] an; algorithm optimised for fitting. The; minimisation algorithms can be selected using the static functions of; the `ROOT::Math::MinimizerOptions` class. Steering options for the; minimiser, such as t",MatchSource.DOCS,documentation/primer/functions_and_parameter_estimation.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/functions_and_parameter_estimation.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/functions_and_parameter_estimation.md:4748,Performance,perform,performs,4748,"eudo data: a signal shape over a background trend. This plot; is another example of how making a plot ""self-explanatory"" can help you; better displaying your results. \label{f61}][f61]. ## Toy Monte Carlo Experiments ##. Let us look at a simple example of a toy experiment comparing two; methods to fit a function to a histogram, the $\chi^{2}$. method and a method called ""binned log-likelihood fit"", both available in ROOT. As a very simple yet powerful quantity to check the quality of the fit; results, we construct for each pseudo-data set the so-called ""pull"", the; difference of the estimated and the true value of a parameter,; normalised to the estimated error on the parameter,; $\frac{(p_{estim} - p_{true})}{\sigma_{p}}$. If everything is OK, the; distribution of the pull values is a standard normal distribution, i.e.; a Gaussian distribution centred around zero with a standard deviation of one. The macro performs a rather big number of toy experiments, where a; histogram is repeatedly filled with Gaussian distributed numbers,; representing the pseudo-data in this example. Each time, a fit is; performed according to the selected method, and the pull is calculated; and filled into a histogram. Here is the code:. ``` {.cpp .numberLines}; @ROOT_INCLUDE_FILE macros/macro9.C; ```. Your present knowledge of ROOT should be enough to understand all the; technicalities behind the macro. Note that the variable `pull` in line; *61* is different from the definition above: instead of the parameter; error on `mean`, the fitted standard deviation of the distribution; divided by the square root of the number of entries,; `sig/sqrt(n_tot_entries)`, is used. - What method exhibits the better performance with the default; parameters ?. - What happens if you increase the number of entries per histogram by; a factor of ten ? Why ?. The answers to these questions are well beyond the scope of this guide.; Basically all books about statistical methods provide a complete; treatment of the ",MatchSource.DOCS,documentation/primer/functions_and_parameter_estimation.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/functions_and_parameter_estimation.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/functions_and_parameter_estimation.md:4940,Performance,perform,performed,4940," your results. \label{f61}][f61]. ## Toy Monte Carlo Experiments ##. Let us look at a simple example of a toy experiment comparing two; methods to fit a function to a histogram, the $\chi^{2}$. method and a method called ""binned log-likelihood fit"", both available in ROOT. As a very simple yet powerful quantity to check the quality of the fit; results, we construct for each pseudo-data set the so-called ""pull"", the; difference of the estimated and the true value of a parameter,; normalised to the estimated error on the parameter,; $\frac{(p_{estim} - p_{true})}{\sigma_{p}}$. If everything is OK, the; distribution of the pull values is a standard normal distribution, i.e.; a Gaussian distribution centred around zero with a standard deviation of one. The macro performs a rather big number of toy experiments, where a; histogram is repeatedly filled with Gaussian distributed numbers,; representing the pseudo-data in this example. Each time, a fit is; performed according to the selected method, and the pull is calculated; and filled into a histogram. Here is the code:. ``` {.cpp .numberLines}; @ROOT_INCLUDE_FILE macros/macro9.C; ```. Your present knowledge of ROOT should be enough to understand all the; technicalities behind the macro. Note that the variable `pull` in line; *61* is different from the definition above: instead of the parameter; error on `mean`, the fitted standard deviation of the distribution; divided by the square root of the number of entries,; `sig/sqrt(n_tot_entries)`, is used. - What method exhibits the better performance with the default; parameters ?. - What happens if you increase the number of entries per histogram by; a factor of ten ? Why ?. The answers to these questions are well beyond the scope of this guide.; Basically all books about statistical methods provide a complete; treatment of the aforementioned topics. [^5]: ""Monte Carlo"" simulation means that random numbers play a role here; which is as crucial as in games of pure chance in the",MatchSource.DOCS,documentation/primer/functions_and_parameter_estimation.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/functions_and_parameter_estimation.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/functions_and_parameter_estimation.md:5532,Performance,perform,performance,5532,"}][f61]. ## Toy Monte Carlo Experiments ##. Let us look at a simple example of a toy experiment comparing two; methods to fit a function to a histogram, the $\chi^{2}$. method and a method called ""binned log-likelihood fit"", both available in ROOT. As a very simple yet powerful quantity to check the quality of the fit; results, we construct for each pseudo-data set the so-called ""pull"", the; difference of the estimated and the true value of a parameter,; normalised to the estimated error on the parameter,; $\frac{(p_{estim} - p_{true})}{\sigma_{p}}$. If everything is OK, the; distribution of the pull values is a standard normal distribution, i.e.; a Gaussian distribution centred around zero with a standard deviation of one. The macro performs a rather big number of toy experiments, where a; histogram is repeatedly filled with Gaussian distributed numbers,; representing the pseudo-data in this example. Each time, a fit is; performed according to the selected method, and the pull is calculated; and filled into a histogram. Here is the code:. ``` {.cpp .numberLines}; @ROOT_INCLUDE_FILE macros/macro9.C; ```. Your present knowledge of ROOT should be enough to understand all the; technicalities behind the macro. Note that the variable `pull` in line; *61* is different from the definition above: instead of the parameter; error on `mean`, the fitted standard deviation of the distribution; divided by the square root of the number of entries,; `sig/sqrt(n_tot_entries)`, is used. - What method exhibits the better performance with the default; parameters ?. - What happens if you increase the number of entries per histogram by; a factor of ten ? Why ?. The answers to these questions are well beyond the scope of this guide.; Basically all books about statistical methods provide a complete; treatment of the aforementioned topics. [^5]: ""Monte Carlo"" simulation means that random numbers play a role here; which is as crucial as in games of pure chance in the Casino of Monte Carlo.; ",MatchSource.DOCS,documentation/primer/functions_and_parameter_estimation.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/functions_and_parameter_estimation.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/functions_and_parameter_estimation.md:614,Security,access,access,614,"# Functions and Parameter Estimation #. After going through the previous chapters, you already know how to use; analytical functions (class `TF1`), and you got some insight into the; graph (`TGraphErrors`) and histogram classes (`TH1F`) for data; visualisation. In this chapter we will add more detail to the previous; approximate explanations to face the fundamental topic of parameter; estimation by fitting functions to data. For graphs and histograms, ROOT; offers an easy-to-use interface to perform fits - either the fit panel; of the graphical interface, or the `Fit` method. The class `TFitResult`; allows access to the detailed results. Very often it is necessary to study the statistical properties of; analysis procedures. This is most easily achieved by applying the; analysis to many sets of simulated data (or ""pseudo data""), each; representing one possible version of the true experiment. If the; simulation only deals with the final distributions observed in data, and; does not perform a full simulation of the underlying physics and the; experimental apparatus, the name ""Toy Monte Carlo"" is frequently used; [^5]. Since the true values of all parameters are known in the; pseudo-data, the differences between the parameter estimates from the; analysis procedure w.r.t. the true values can be determined, and it is; also possible to check that the analysis procedure provides correct; error estimates. ## Fitting Functions to Pseudo Data ##. In the example below, a pseudo-data set is produced and a model fitted; to it. ROOT offers various minimisation algorithms to minimise a chi2 or a; negative log-likelihood function. The default minimiser is MINUIT, a; package originally implemented in the FORTRAN programming language. A; C++ version is also available, MINUIT2, as well as Fumili [@Fumili] an; algorithm optimised for fitting. The; minimisation algorithms can be selected using the static functions of; the `ROOT::Math::MinimizerOptions` class. Steering options for the; min",MatchSource.DOCS,documentation/primer/functions_and_parameter_estimation.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/functions_and_parameter_estimation.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/functions_and_parameter_estimation.md:3575,Security,access,access,3575,"ion is at this point necessary:. - Lines *1-3*: A simple function to ease the make-up of lines.; Remember that the class `TF1` inherits from `TAttLine`. - Lines *5-7* : Definition of a customised function, namely a Gaussian; (the ""signal"") plus a parabolic function, the ""background"". - Lines *10-12*: Some make-up for the Canvas. In particular we want; that the parameters of the fit appear very clearly and nicely on the; plot. - Lines *20-25*: Define and initialise an instance of `TF1`. - Lines *27-31*: Define and fill a histogram. - Lines *33-38*: For convenience, the same function as for the; generation of the pseudo-data is used in the fit; hence, we need to; reset the function parameters. This part of the code is very; important for each fit procedure, as it sets the initial values of; the fit. - Line *41*: A very simple command, well known by now: fit the; function to the histogram. - Lines *42-46*: Retrieve the output from the fit. Here, we simply; print the fit result and access and print the covariance matrix of; the parameters. - Lines *54-end*: Plot the pseudo-data, the fitted function and the; signal and background components at the best-fit values. [f61]: figures/functions.png ""f61""; <a name=""f61""></a>. ![Fit of pseudo data: a signal shape over a background trend. This plot; is another example of how making a plot ""self-explanatory"" can help you; better displaying your results. \label{f61}][f61]. ## Toy Monte Carlo Experiments ##. Let us look at a simple example of a toy experiment comparing two; methods to fit a function to a histogram, the $\chi^{2}$. method and a method called ""binned log-likelihood fit"", both available in ROOT. As a very simple yet powerful quantity to check the quality of the fit; results, we construct for each pseudo-data set the so-called ""pull"", the; difference of the estimated and the true value of a parameter,; normalised to the estimated error on the parameter,; $\frac{(p_{estim} - p_{true})}{\sigma_{p}}$. If everything is OK, t",MatchSource.DOCS,documentation/primer/functions_and_parameter_estimation.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/functions_and_parameter_estimation.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/functions_and_parameter_estimation.md:1617,Testability,log,log-likelihood,1617,"ass `TFitResult`; allows access to the detailed results. Very often it is necessary to study the statistical properties of; analysis procedures. This is most easily achieved by applying the; analysis to many sets of simulated data (or ""pseudo data""), each; representing one possible version of the true experiment. If the; simulation only deals with the final distributions observed in data, and; does not perform a full simulation of the underlying physics and the; experimental apparatus, the name ""Toy Monte Carlo"" is frequently used; [^5]. Since the true values of all parameters are known in the; pseudo-data, the differences between the parameter estimates from the; analysis procedure w.r.t. the true values can be determined, and it is; also possible to check that the analysis procedure provides correct; error estimates. ## Fitting Functions to Pseudo Data ##. In the example below, a pseudo-data set is produced and a model fitted; to it. ROOT offers various minimisation algorithms to minimise a chi2 or a; negative log-likelihood function. The default minimiser is MINUIT, a; package originally implemented in the FORTRAN programming language. A; C++ version is also available, MINUIT2, as well as Fumili [@Fumili] an; algorithm optimised for fitting. The; minimisation algorithms can be selected using the static functions of; the `ROOT::Math::MinimizerOptions` class. Steering options for the; minimiser, such as the convergence tolerance or the maximum number of; function calls, can also be set using the methods of this class. All; currently implemented minimisers are documented in the reference; documentation of ROOT: have a look for example to the; `ROOT::Math::Minimizer` class documentation.; \newpage; The complication level of the code below is intentionally a little; higher than in the previous examples. The graphical output of the macro; is shown in Figure [6.1](#f61):. ``` {.cpp .numberLines}; @ROOT_INCLUDE_FILE macros/macro8.C; ```. Some step by step explanation is a",MatchSource.DOCS,documentation/primer/functions_and_parameter_estimation.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/functions_and_parameter_estimation.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/functions_and_parameter_estimation.md:4208,Testability,log,log-likelihood,4208," is used in the fit; hence, we need to; reset the function parameters. This part of the code is very; important for each fit procedure, as it sets the initial values of; the fit. - Line *41*: A very simple command, well known by now: fit the; function to the histogram. - Lines *42-46*: Retrieve the output from the fit. Here, we simply; print the fit result and access and print the covariance matrix of; the parameters. - Lines *54-end*: Plot the pseudo-data, the fitted function and the; signal and background components at the best-fit values. [f61]: figures/functions.png ""f61""; <a name=""f61""></a>. ![Fit of pseudo data: a signal shape over a background trend. This plot; is another example of how making a plot ""self-explanatory"" can help you; better displaying your results. \label{f61}][f61]. ## Toy Monte Carlo Experiments ##. Let us look at a simple example of a toy experiment comparing two; methods to fit a function to a histogram, the $\chi^{2}$. method and a method called ""binned log-likelihood fit"", both available in ROOT. As a very simple yet powerful quantity to check the quality of the fit; results, we construct for each pseudo-data set the so-called ""pull"", the; difference of the estimated and the true value of a parameter,; normalised to the estimated error on the parameter,; $\frac{(p_{estim} - p_{true})}{\sigma_{p}}$. If everything is OK, the; distribution of the pull values is a standard normal distribution, i.e.; a Gaussian distribution centred around zero with a standard deviation of one. The macro performs a rather big number of toy experiments, where a; histogram is repeatedly filled with Gaussian distributed numbers,; representing the pseudo-data in this example. Each time, a fit is; performed according to the selected method, and the pull is calculated; and filled into a histogram. Here is the code:. ``` {.cpp .numberLines}; @ROOT_INCLUDE_FILE macros/macro9.C; ```. Your present knowledge of ROOT should be enough to understand all the; technicalities ",MatchSource.DOCS,documentation/primer/functions_and_parameter_estimation.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/functions_and_parameter_estimation.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/functions_and_parameter_estimation.md:2632,Usability,simpl,simple,2632," default minimiser is MINUIT, a; package originally implemented in the FORTRAN programming language. A; C++ version is also available, MINUIT2, as well as Fumili [@Fumili] an; algorithm optimised for fitting. The; minimisation algorithms can be selected using the static functions of; the `ROOT::Math::MinimizerOptions` class. Steering options for the; minimiser, such as the convergence tolerance or the maximum number of; function calls, can also be set using the methods of this class. All; currently implemented minimisers are documented in the reference; documentation of ROOT: have a look for example to the; `ROOT::Math::Minimizer` class documentation.; \newpage; The complication level of the code below is intentionally a little; higher than in the previous examples. The graphical output of the macro; is shown in Figure [6.1](#f61):. ``` {.cpp .numberLines}; @ROOT_INCLUDE_FILE macros/macro8.C; ```. Some step by step explanation is at this point necessary:. - Lines *1-3*: A simple function to ease the make-up of lines.; Remember that the class `TF1` inherits from `TAttLine`. - Lines *5-7* : Definition of a customised function, namely a Gaussian; (the ""signal"") plus a parabolic function, the ""background"". - Lines *10-12*: Some make-up for the Canvas. In particular we want; that the parameters of the fit appear very clearly and nicely on the; plot. - Lines *20-25*: Define and initialise an instance of `TF1`. - Lines *27-31*: Define and fill a histogram. - Lines *33-38*: For convenience, the same function as for the; generation of the pseudo-data is used in the fit; hence, we need to; reset the function parameters. This part of the code is very; important for each fit procedure, as it sets the initial values of; the fit. - Line *41*: A very simple command, well known by now: fit the; function to the histogram. - Lines *42-46*: Retrieve the output from the fit. Here, we simply; print the fit result and access and print the covariance matrix of; the parameters. - Lines *54-",MatchSource.DOCS,documentation/primer/functions_and_parameter_estimation.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/functions_and_parameter_estimation.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/functions_and_parameter_estimation.md:2979,Usability,clear,clearly,2979,"ns` class. Steering options for the; minimiser, such as the convergence tolerance or the maximum number of; function calls, can also be set using the methods of this class. All; currently implemented minimisers are documented in the reference; documentation of ROOT: have a look for example to the; `ROOT::Math::Minimizer` class documentation.; \newpage; The complication level of the code below is intentionally a little; higher than in the previous examples. The graphical output of the macro; is shown in Figure [6.1](#f61):. ``` {.cpp .numberLines}; @ROOT_INCLUDE_FILE macros/macro8.C; ```. Some step by step explanation is at this point necessary:. - Lines *1-3*: A simple function to ease the make-up of lines.; Remember that the class `TF1` inherits from `TAttLine`. - Lines *5-7* : Definition of a customised function, namely a Gaussian; (the ""signal"") plus a parabolic function, the ""background"". - Lines *10-12*: Some make-up for the Canvas. In particular we want; that the parameters of the fit appear very clearly and nicely on the; plot. - Lines *20-25*: Define and initialise an instance of `TF1`. - Lines *27-31*: Define and fill a histogram. - Lines *33-38*: For convenience, the same function as for the; generation of the pseudo-data is used in the fit; hence, we need to; reset the function parameters. This part of the code is very; important for each fit procedure, as it sets the initial values of; the fit. - Line *41*: A very simple command, well known by now: fit the; function to the histogram. - Lines *42-46*: Retrieve the output from the fit. Here, we simply; print the fit result and access and print the covariance matrix of; the parameters. - Lines *54-end*: Plot the pseudo-data, the fitted function and the; signal and background components at the best-fit values. [f61]: figures/functions.png ""f61""; <a name=""f61""></a>. ![Fit of pseudo data: a signal shape over a background trend. This plot; is another example of how making a plot ""self-explanatory"" can help you; ",MatchSource.DOCS,documentation/primer/functions_and_parameter_estimation.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/functions_and_parameter_estimation.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/functions_and_parameter_estimation.md:3411,Usability,simpl,simple,3411," output of the macro; is shown in Figure [6.1](#f61):. ``` {.cpp .numberLines}; @ROOT_INCLUDE_FILE macros/macro8.C; ```. Some step by step explanation is at this point necessary:. - Lines *1-3*: A simple function to ease the make-up of lines.; Remember that the class `TF1` inherits from `TAttLine`. - Lines *5-7* : Definition of a customised function, namely a Gaussian; (the ""signal"") plus a parabolic function, the ""background"". - Lines *10-12*: Some make-up for the Canvas. In particular we want; that the parameters of the fit appear very clearly and nicely on the; plot. - Lines *20-25*: Define and initialise an instance of `TF1`. - Lines *27-31*: Define and fill a histogram. - Lines *33-38*: For convenience, the same function as for the; generation of the pseudo-data is used in the fit; hence, we need to; reset the function parameters. This part of the code is very; important for each fit procedure, as it sets the initial values of; the fit. - Line *41*: A very simple command, well known by now: fit the; function to the histogram. - Lines *42-46*: Retrieve the output from the fit. Here, we simply; print the fit result and access and print the covariance matrix of; the parameters. - Lines *54-end*: Plot the pseudo-data, the fitted function and the; signal and background components at the best-fit values. [f61]: figures/functions.png ""f61""; <a name=""f61""></a>. ![Fit of pseudo data: a signal shape over a background trend. This plot; is another example of how making a plot ""self-explanatory"" can help you; better displaying your results. \label{f61}][f61]. ## Toy Monte Carlo Experiments ##. Let us look at a simple example of a toy experiment comparing two; methods to fit a function to a histogram, the $\chi^{2}$. method and a method called ""binned log-likelihood fit"", both available in ROOT. As a very simple yet powerful quantity to check the quality of the fit; results, we construct for each pseudo-data set the so-called ""pull"", the; difference of the estimated and the t",MatchSource.DOCS,documentation/primer/functions_and_parameter_estimation.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/functions_and_parameter_estimation.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/functions_and_parameter_estimation.md:3542,Usability,simpl,simply,3542,"ion is at this point necessary:. - Lines *1-3*: A simple function to ease the make-up of lines.; Remember that the class `TF1` inherits from `TAttLine`. - Lines *5-7* : Definition of a customised function, namely a Gaussian; (the ""signal"") plus a parabolic function, the ""background"". - Lines *10-12*: Some make-up for the Canvas. In particular we want; that the parameters of the fit appear very clearly and nicely on the; plot. - Lines *20-25*: Define and initialise an instance of `TF1`. - Lines *27-31*: Define and fill a histogram. - Lines *33-38*: For convenience, the same function as for the; generation of the pseudo-data is used in the fit; hence, we need to; reset the function parameters. This part of the code is very; important for each fit procedure, as it sets the initial values of; the fit. - Line *41*: A very simple command, well known by now: fit the; function to the histogram. - Lines *42-46*: Retrieve the output from the fit. Here, we simply; print the fit result and access and print the covariance matrix of; the parameters. - Lines *54-end*: Plot the pseudo-data, the fitted function and the; signal and background components at the best-fit values. [f61]: figures/functions.png ""f61""; <a name=""f61""></a>. ![Fit of pseudo data: a signal shape over a background trend. This plot; is another example of how making a plot ""self-explanatory"" can help you; better displaying your results. \label{f61}][f61]. ## Toy Monte Carlo Experiments ##. Let us look at a simple example of a toy experiment comparing two; methods to fit a function to a histogram, the $\chi^{2}$. method and a method called ""binned log-likelihood fit"", both available in ROOT. As a very simple yet powerful quantity to check the quality of the fit; results, we construct for each pseudo-data set the so-called ""pull"", the; difference of the estimated and the true value of a parameter,; normalised to the estimated error on the parameter,; $\frac{(p_{estim} - p_{true})}{\sigma_{p}}$. If everything is OK, t",MatchSource.DOCS,documentation/primer/functions_and_parameter_estimation.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/functions_and_parameter_estimation.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/functions_and_parameter_estimation.md:4065,Usability,simpl,simple,4065,"istogram. - Lines *33-38*: For convenience, the same function as for the; generation of the pseudo-data is used in the fit; hence, we need to; reset the function parameters. This part of the code is very; important for each fit procedure, as it sets the initial values of; the fit. - Line *41*: A very simple command, well known by now: fit the; function to the histogram. - Lines *42-46*: Retrieve the output from the fit. Here, we simply; print the fit result and access and print the covariance matrix of; the parameters. - Lines *54-end*: Plot the pseudo-data, the fitted function and the; signal and background components at the best-fit values. [f61]: figures/functions.png ""f61""; <a name=""f61""></a>. ![Fit of pseudo data: a signal shape over a background trend. This plot; is another example of how making a plot ""self-explanatory"" can help you; better displaying your results. \label{f61}][f61]. ## Toy Monte Carlo Experiments ##. Let us look at a simple example of a toy experiment comparing two; methods to fit a function to a histogram, the $\chi^{2}$. method and a method called ""binned log-likelihood fit"", both available in ROOT. As a very simple yet powerful quantity to check the quality of the fit; results, we construct for each pseudo-data set the so-called ""pull"", the; difference of the estimated and the true value of a parameter,; normalised to the estimated error on the parameter,; $\frac{(p_{estim} - p_{true})}{\sigma_{p}}$. If everything is OK, the; distribution of the pull values is a standard normal distribution, i.e.; a Gaussian distribution centred around zero with a standard deviation of one. The macro performs a rather big number of toy experiments, where a; histogram is repeatedly filled with Gaussian distributed numbers,; representing the pseudo-data in this example. Each time, a fit is; performed according to the selected method, and the pull is calculated; and filled into a histogram. Here is the code:. ``` {.cpp .numberLines}; @ROOT_INCLUDE_FILE macros",MatchSource.DOCS,documentation/primer/functions_and_parameter_estimation.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/functions_and_parameter_estimation.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/functions_and_parameter_estimation.md:4263,Usability,simpl,simple,4263,"very simple command, well known by now: fit the; function to the histogram. - Lines *42-46*: Retrieve the output from the fit. Here, we simply; print the fit result and access and print the covariance matrix of; the parameters. - Lines *54-end*: Plot the pseudo-data, the fitted function and the; signal and background components at the best-fit values. [f61]: figures/functions.png ""f61""; <a name=""f61""></a>. ![Fit of pseudo data: a signal shape over a background trend. This plot; is another example of how making a plot ""self-explanatory"" can help you; better displaying your results. \label{f61}][f61]. ## Toy Monte Carlo Experiments ##. Let us look at a simple example of a toy experiment comparing two; methods to fit a function to a histogram, the $\chi^{2}$. method and a method called ""binned log-likelihood fit"", both available in ROOT. As a very simple yet powerful quantity to check the quality of the fit; results, we construct for each pseudo-data set the so-called ""pull"", the; difference of the estimated and the true value of a parameter,; normalised to the estimated error on the parameter,; $\frac{(p_{estim} - p_{true})}{\sigma_{p}}$. If everything is OK, the; distribution of the pull values is a standard normal distribution, i.e.; a Gaussian distribution centred around zero with a standard deviation of one. The macro performs a rather big number of toy experiments, where a; histogram is repeatedly filled with Gaussian distributed numbers,; representing the pseudo-data in this example. Each time, a fit is; performed according to the selected method, and the pull is calculated; and filled into a histogram. Here is the code:. ``` {.cpp .numberLines}; @ROOT_INCLUDE_FILE macros/macro9.C; ```. Your present knowledge of ROOT should be enough to understand all the; technicalities behind the macro. Note that the variable `pull` in line; *61* is different from the definition above: instead of the parameter; error on `mean`, the fitted standard deviation of the distribution",MatchSource.DOCS,documentation/primer/functions_and_parameter_estimation.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/functions_and_parameter_estimation.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/functions_and_parameter_estimation.md:5737,Usability,guid,guide,5737,"}][f61]. ## Toy Monte Carlo Experiments ##. Let us look at a simple example of a toy experiment comparing two; methods to fit a function to a histogram, the $\chi^{2}$. method and a method called ""binned log-likelihood fit"", both available in ROOT. As a very simple yet powerful quantity to check the quality of the fit; results, we construct for each pseudo-data set the so-called ""pull"", the; difference of the estimated and the true value of a parameter,; normalised to the estimated error on the parameter,; $\frac{(p_{estim} - p_{true})}{\sigma_{p}}$. If everything is OK, the; distribution of the pull values is a standard normal distribution, i.e.; a Gaussian distribution centred around zero with a standard deviation of one. The macro performs a rather big number of toy experiments, where a; histogram is repeatedly filled with Gaussian distributed numbers,; representing the pseudo-data in this example. Each time, a fit is; performed according to the selected method, and the pull is calculated; and filled into a histogram. Here is the code:. ``` {.cpp .numberLines}; @ROOT_INCLUDE_FILE macros/macro9.C; ```. Your present knowledge of ROOT should be enough to understand all the; technicalities behind the macro. Note that the variable `pull` in line; *61* is different from the definition above: instead of the parameter; error on `mean`, the fitted standard deviation of the distribution; divided by the square root of the number of entries,; `sig/sqrt(n_tot_entries)`, is used. - What method exhibits the better performance with the default; parameters ?. - What happens if you increase the number of entries per histogram by; a factor of ten ? Why ?. The answers to these questions are well beyond the scope of this guide.; Basically all books about statistical methods provide a complete; treatment of the aforementioned topics. [^5]: ""Monte Carlo"" simulation means that random numbers play a role here; which is as crucial as in games of pure chance in the Casino of Monte Carlo.; ",MatchSource.DOCS,documentation/primer/functions_and_parameter_estimation.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/functions_and_parameter_estimation.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/graphs.md:361,Availability,error,errors,361,"# Graphs #. In this Chapter we will learn how to exploit some of the functionalities; ROOT provides to display data exploiting the class `TGraphErrors`,; which you already got to know previously. ## Read Graph Points from File ##. The fastest way in which you can fill a graph with experimental data is; to use the constructor which reads data points and their errors from an; ASCII file (i.e. standard text) format:. ``` {.cpp}; TGraphErrors(const char *filename,; const char *format=""%lg %lg %lg %lg"", Option_t *option="""");; ```. The format string can be:. - `""%lg %lg""` read only 2 first columns into X,Y. - `""%lg %lg %lg""` read only 3 first columns into X,Y and EY. - `""%lg %lg %lg %lg""` read only 4 first columns into X,Y,EX,EY. This approach has the nice feature of allowing the user to reuse the; macro for many different data sets. Here is an example of an input file.; The nice graphic result shown is produced by the macro below, which; reads two such input files and uses different options to display the; data points. ```; # Measurement of Friday 26 March; # Experiment 2 Physics Lab. 1 6 5; 2 12 5; 3 14 4.7; 4 20 4.5; 5 22 4.2; 6 24 5.1; 7 35 2.9; 8 45 4.1; 9 44 4.8; 10 53 5.43; ```; \newpage; ![](figures/graph_with_expectation.png). ``` {.cpp}; @ROOT_INCLUDE_FILE macros/macro2.C; ```. In addition to the inspection of the plot, you can check the actual; contents of the graph with the `TGraph::Print()` method at any time,; obtaining a printout of the coordinates of data points on screen. The; macro also shows us how to print a coloured band around a graph instead; of error bars, quite useful for example to represent the errors of a; theoretical prediction. ## Polar Graphs ##. With ROOT you can profit from rather advanced plotting routines, like; the ones implemented in the `TPolarGraph`, a class to draw graphs in; polar coordinates. You can see the example macro in the following and the; resulting Figure is [4.2](#f42):. ``` {.cpp .numberLines}; @ROOT_INCLUDE_FILE macros/",MatchSource.DOCS,documentation/primer/graphs.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/graphs.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/graphs.md:1589,Availability,error,error,1589,"lumns into X,Y. - `""%lg %lg %lg""` read only 3 first columns into X,Y and EY. - `""%lg %lg %lg %lg""` read only 4 first columns into X,Y,EX,EY. This approach has the nice feature of allowing the user to reuse the; macro for many different data sets. Here is an example of an input file.; The nice graphic result shown is produced by the macro below, which; reads two such input files and uses different options to display the; data points. ```; # Measurement of Friday 26 March; # Experiment 2 Physics Lab. 1 6 5; 2 12 5; 3 14 4.7; 4 20 4.5; 5 22 4.2; 6 24 5.1; 7 35 2.9; 8 45 4.1; 9 44 4.8; 10 53 5.43; ```; \newpage; ![](figures/graph_with_expectation.png). ``` {.cpp}; @ROOT_INCLUDE_FILE macros/macro2.C; ```. In addition to the inspection of the plot, you can check the actual; contents of the graph with the `TGraph::Print()` method at any time,; obtaining a printout of the coordinates of data points on screen. The; macro also shows us how to print a coloured band around a graph instead; of error bars, quite useful for example to represent the errors of a; theoretical prediction. ## Polar Graphs ##. With ROOT you can profit from rather advanced plotting routines, like; the ones implemented in the `TPolarGraph`, a class to draw graphs in; polar coordinates. You can see the example macro in the following and the; resulting Figure is [4.2](#f42):. ``` {.cpp .numberLines}; @ROOT_INCLUDE_FILE macros/macro3.C; ```. A new element was added on line 4, the size of the canvas: it is; sometimes optically better to show plots in specific canvas sizes. [f42]: figures/polar_graph.png ""f42""; <a name=""f42""></a>. ![The graph of a fan obtained with ROOT.\label{f42}][f42]. ## 2D Graphs ##. Under specific circumstances, it might be useful to plot some quantities; versus two variables, therefore creating a bi-dimensional graph. Of; course ROOT can help you in this task, with the `TGraph2DErrors` class.; The following macro produces a bi-dimensional graph representing a; hypothetical measurement, ",MatchSource.DOCS,documentation/primer/graphs.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/graphs.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/graphs.md:1643,Availability,error,errors,1643,"lumns into X,Y. - `""%lg %lg %lg""` read only 3 first columns into X,Y and EY. - `""%lg %lg %lg %lg""` read only 4 first columns into X,Y,EX,EY. This approach has the nice feature of allowing the user to reuse the; macro for many different data sets. Here is an example of an input file.; The nice graphic result shown is produced by the macro below, which; reads two such input files and uses different options to display the; data points. ```; # Measurement of Friday 26 March; # Experiment 2 Physics Lab. 1 6 5; 2 12 5; 3 14 4.7; 4 20 4.5; 5 22 4.2; 6 24 5.1; 7 35 2.9; 8 45 4.1; 9 44 4.8; 10 53 5.43; ```; \newpage; ![](figures/graph_with_expectation.png). ``` {.cpp}; @ROOT_INCLUDE_FILE macros/macro2.C; ```. In addition to the inspection of the plot, you can check the actual; contents of the graph with the `TGraph::Print()` method at any time,; obtaining a printout of the coordinates of data points on screen. The; macro also shows us how to print a coloured band around a graph instead; of error bars, quite useful for example to represent the errors of a; theoretical prediction. ## Polar Graphs ##. With ROOT you can profit from rather advanced plotting routines, like; the ones implemented in the `TPolarGraph`, a class to draw graphs in; polar coordinates. You can see the example macro in the following and the; resulting Figure is [4.2](#f42):. ``` {.cpp .numberLines}; @ROOT_INCLUDE_FILE macros/macro3.C; ```. A new element was added on line 4, the size of the canvas: it is; sometimes optically better to show plots in specific canvas sizes. [f42]: figures/polar_graph.png ""f42""; <a name=""f42""></a>. ![The graph of a fan obtained with ROOT.\label{f42}][f42]. ## 2D Graphs ##. Under specific circumstances, it might be useful to plot some quantities; versus two variables, therefore creating a bi-dimensional graph. Of; course ROOT can help you in this task, with the `TGraph2DErrors` class.; The following macro produces a bi-dimensional graph representing a; hypothetical measurement, ",MatchSource.DOCS,documentation/primer/graphs.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/graphs.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/graphs.md:5106,Availability,error,errors,5106,"cording to; different probability density functions, like the Uniform one at; lines *27-29*. See the on-line documentation to appreciate the full; power of this ROOT feature. - Line *8*: You are already familiar with the `TF1` class. This is; its two-dimensional version. At line *16* two random numbers; distributed according to the `TF2` formula are drawn with the method; `TF2::GetRandom2(double& a, double&b)`. - Line *27-29*: Fitting a 2-dimensional function just works like in; the one-dimensional case, i.e. initialisation of parameters and; calling of the `Fit()` method. - Line *34*: The *Surf1* option draws the `TF2` objects (but also; bi-dimensional histograms) as coloured surfaces with a wire-frame on; three-dimensional canvases. See Figure [4.3](#f43). - Line *35-40*: Retrieve the axis pointer and define the axis titles. - Line *41*: Draw the cloud of points on top of the coloured surface. - Line *43-49*: Here you learn how to create a canvas, partition it in; two sub-pads and access them. It is very handy to show multiple; plots in the same window or image. [f43]: figures/fitted2dFunction.png ""f43""; <a name=""f43""></a>. ![A dataset fitted with a bidimensional function visualised as a colored; surface.\label{f43}][f43]. \newpage. ## Multiple graphs ##. The class `TMultigraph` allows to manipulate a set of graphs as a single entity.; It is a collection of `TGraph` (or derived) objects. When drawn, the X and Y axis; ranges are automatically computed such as all the graphs will be visible. ``` {.cpp .numberLines}; @ROOT_INCLUDE_FILE macros/multigraph.C; ```; - Line *6* creates the multigraph. - Line *9-28*: create two graphs with errors and add them in the multigraph. - Line *30-32*: draw the multigraph. The axis limits are computed automatically; to make sure all the graphs' points will be in range. [f44]: figures/multigraph.png ""f44""; <a name=""f44""></a>. ![A set of graphs grouped in a multigraph.\label{f44}][f44]. [^3] https://root.cern/blog/rainbow-color-map/; ",MatchSource.DOCS,documentation/primer/graphs.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/graphs.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/graphs.md:3593,Energy Efficiency,power,power,3593," measurement, fits a bi-dimensional function to it and draws; it together with its x and y projections. Some points of the code will; be explained in detail. This time, the graph is populated with data; points using random numbers, introducing a new and very important; ingredient, the ROOT `TRandom3` random number generator using the; Mersenne Twister algorithm [@MersenneTwister]. ``` {.cpp .numberLines}; @ROOT_INCLUDE_FILE macros/macro4.C; ```. Let's go through the code, step by step to understand what is going on:. - Line *3*: This sets the palette colour code to a much nicer one than; the default. Comment this line to give it a try.; [This article](https://root.cern/blog/rainbow-color-map/); gives more details about colour map choice. - Line *7*: The instance of the random generator. You can then draw; out of this instance random numbers distributed according to; different probability density functions, like the Uniform one at; lines *27-29*. See the on-line documentation to appreciate the full; power of this ROOT feature. - Line *8*: You are already familiar with the `TF1` class. This is; its two-dimensional version. At line *16* two random numbers; distributed according to the `TF2` formula are drawn with the method; `TF2::GetRandom2(double& a, double&b)`. - Line *27-29*: Fitting a 2-dimensional function just works like in; the one-dimensional case, i.e. initialisation of parameters and; calling of the `Fit()` method. - Line *34*: The *Surf1* option draws the `TF2` objects (but also; bi-dimensional histograms) as coloured surfaces with a wire-frame on; three-dimensional canvases. See Figure [4.3](#f43). - Line *35-40*: Retrieve the axis pointer and define the axis titles. - Line *41*: Draw the cloud of points on top of the coloured surface. - Line *43-49*: Here you learn how to create a canvas, partition it in; two sub-pads and access them. It is very handy to show multiple; plots in the same window or image. [f43]: figures/fitted2dFunction.png ""f43""; <a name=""",MatchSource.DOCS,documentation/primer/graphs.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/graphs.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/graphs.md:1755,Integrability,rout,routines,1755,"g the user to reuse the; macro for many different data sets. Here is an example of an input file.; The nice graphic result shown is produced by the macro below, which; reads two such input files and uses different options to display the; data points. ```; # Measurement of Friday 26 March; # Experiment 2 Physics Lab. 1 6 5; 2 12 5; 3 14 4.7; 4 20 4.5; 5 22 4.2; 6 24 5.1; 7 35 2.9; 8 45 4.1; 9 44 4.8; 10 53 5.43; ```; \newpage; ![](figures/graph_with_expectation.png). ``` {.cpp}; @ROOT_INCLUDE_FILE macros/macro2.C; ```. In addition to the inspection of the plot, you can check the actual; contents of the graph with the `TGraph::Print()` method at any time,; obtaining a printout of the coordinates of data points on screen. The; macro also shows us how to print a coloured band around a graph instead; of error bars, quite useful for example to represent the errors of a; theoretical prediction. ## Polar Graphs ##. With ROOT you can profit from rather advanced plotting routines, like; the ones implemented in the `TPolarGraph`, a class to draw graphs in; polar coordinates. You can see the example macro in the following and the; resulting Figure is [4.2](#f42):. ``` {.cpp .numberLines}; @ROOT_INCLUDE_FILE macros/macro3.C; ```. A new element was added on line 4, the size of the canvas: it is; sometimes optically better to show plots in specific canvas sizes. [f42]: figures/polar_graph.png ""f42""; <a name=""f42""></a>. ![The graph of a fan obtained with ROOT.\label{f42}][f42]. ## 2D Graphs ##. Under specific circumstances, it might be useful to plot some quantities; versus two variables, therefore creating a bi-dimensional graph. Of; course ROOT can help you in this task, with the `TGraph2DErrors` class.; The following macro produces a bi-dimensional graph representing a; hypothetical measurement, fits a bi-dimensional function to it and draws; it together with its x and y projections. Some points of the code will; be explained in detail. This time, the graph is populated with dat",MatchSource.DOCS,documentation/primer/graphs.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/graphs.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/graphs.md:2368,Modifiability,variab,variables,2368,"an check the actual; contents of the graph with the `TGraph::Print()` method at any time,; obtaining a printout of the coordinates of data points on screen. The; macro also shows us how to print a coloured band around a graph instead; of error bars, quite useful for example to represent the errors of a; theoretical prediction. ## Polar Graphs ##. With ROOT you can profit from rather advanced plotting routines, like; the ones implemented in the `TPolarGraph`, a class to draw graphs in; polar coordinates. You can see the example macro in the following and the; resulting Figure is [4.2](#f42):. ``` {.cpp .numberLines}; @ROOT_INCLUDE_FILE macros/macro3.C; ```. A new element was added on line 4, the size of the canvas: it is; sometimes optically better to show plots in specific canvas sizes. [f42]: figures/polar_graph.png ""f42""; <a name=""f42""></a>. ![The graph of a fan obtained with ROOT.\label{f42}][f42]. ## 2D Graphs ##. Under specific circumstances, it might be useful to plot some quantities; versus two variables, therefore creating a bi-dimensional graph. Of; course ROOT can help you in this task, with the `TGraph2DErrors` class.; The following macro produces a bi-dimensional graph representing a; hypothetical measurement, fits a bi-dimensional function to it and draws; it together with its x and y projections. Some points of the code will; be explained in detail. This time, the graph is populated with data; points using random numbers, introducing a new and very important; ingredient, the ROOT `TRandom3` random number generator using the; Mersenne Twister algorithm [@MersenneTwister]. ``` {.cpp .numberLines}; @ROOT_INCLUDE_FILE macros/macro4.C; ```. Let's go through the code, step by step to understand what is going on:. - Line *3*: This sets the palette colour code to a much nicer one than; the default. Comment this line to give it a try.; [This article](https://root.cern/blog/rainbow-color-map/); gives more details about colour map choice. - Line *7*: The instance ",MatchSource.DOCS,documentation/primer/graphs.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/graphs.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/graphs.md:1668,Safety,predict,prediction,1668,"lumns into X,Y. - `""%lg %lg %lg""` read only 3 first columns into X,Y and EY. - `""%lg %lg %lg %lg""` read only 4 first columns into X,Y,EX,EY. This approach has the nice feature of allowing the user to reuse the; macro for many different data sets. Here is an example of an input file.; The nice graphic result shown is produced by the macro below, which; reads two such input files and uses different options to display the; data points. ```; # Measurement of Friday 26 March; # Experiment 2 Physics Lab. 1 6 5; 2 12 5; 3 14 4.7; 4 20 4.5; 5 22 4.2; 6 24 5.1; 7 35 2.9; 8 45 4.1; 9 44 4.8; 10 53 5.43; ```; \newpage; ![](figures/graph_with_expectation.png). ``` {.cpp}; @ROOT_INCLUDE_FILE macros/macro2.C; ```. In addition to the inspection of the plot, you can check the actual; contents of the graph with the `TGraph::Print()` method at any time,; obtaining a printout of the coordinates of data points on screen. The; macro also shows us how to print a coloured band around a graph instead; of error bars, quite useful for example to represent the errors of a; theoretical prediction. ## Polar Graphs ##. With ROOT you can profit from rather advanced plotting routines, like; the ones implemented in the `TPolarGraph`, a class to draw graphs in; polar coordinates. You can see the example macro in the following and the; resulting Figure is [4.2](#f42):. ``` {.cpp .numberLines}; @ROOT_INCLUDE_FILE macros/macro3.C; ```. A new element was added on line 4, the size of the canvas: it is; sometimes optically better to show plots in specific canvas sizes. [f42]: figures/polar_graph.png ""f42""; <a name=""f42""></a>. ![The graph of a fan obtained with ROOT.\label{f42}][f42]. ## 2D Graphs ##. Under specific circumstances, it might be useful to plot some quantities; versus two variables, therefore creating a bi-dimensional graph. Of; course ROOT can help you in this task, with the `TGraph2DErrors` class.; The following macro produces a bi-dimensional graph representing a; hypothetical measurement, ",MatchSource.DOCS,documentation/primer/graphs.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/graphs.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/graphs.md:4444,Security,access,access,4444,"is instance random numbers distributed according to; different probability density functions, like the Uniform one at; lines *27-29*. See the on-line documentation to appreciate the full; power of this ROOT feature. - Line *8*: You are already familiar with the `TF1` class. This is; its two-dimensional version. At line *16* two random numbers; distributed according to the `TF2` formula are drawn with the method; `TF2::GetRandom2(double& a, double&b)`. - Line *27-29*: Fitting a 2-dimensional function just works like in; the one-dimensional case, i.e. initialisation of parameters and; calling of the `Fit()` method. - Line *34*: The *Surf1* option draws the `TF2` objects (but also; bi-dimensional histograms) as coloured surfaces with a wire-frame on; three-dimensional canvases. See Figure [4.3](#f43). - Line *35-40*: Retrieve the axis pointer and define the axis titles. - Line *41*: Draw the cloud of points on top of the coloured surface. - Line *43-49*: Here you learn how to create a canvas, partition it in; two sub-pads and access them. It is very handy to show multiple; plots in the same window or image. [f43]: figures/fitted2dFunction.png ""f43""; <a name=""f43""></a>. ![A dataset fitted with a bidimensional function visualised as a colored; surface.\label{f43}][f43]. \newpage. ## Multiple graphs ##. The class `TMultigraph` allows to manipulate a set of graphs as a single entity.; It is a collection of `TGraph` (or derived) objects. When drawn, the X and Y axis; ranges are automatically computed such as all the graphs will be visible. ``` {.cpp .numberLines}; @ROOT_INCLUDE_FILE macros/multigraph.C; ```; - Line *6* creates the multigraph. - Line *9-28*: create two graphs with errors and add them in the multigraph. - Line *30-32*: draw the multigraph. The axis limits are computed automatically; to make sure all the graphs' points will be in range. [f44]: figures/multigraph.png ""f44""; <a name=""f44""></a>. ![A set of graphs grouped in a multigraph.\label{f44}][f44]. [^3] ht",MatchSource.DOCS,documentation/primer/graphs.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/graphs.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/graphs.md:36,Usability,learn,learn,36,"# Graphs #. In this Chapter we will learn how to exploit some of the functionalities; ROOT provides to display data exploiting the class `TGraphErrors`,; which you already got to know previously. ## Read Graph Points from File ##. The fastest way in which you can fill a graph with experimental data is; to use the constructor which reads data points and their errors from an; ASCII file (i.e. standard text) format:. ``` {.cpp}; TGraphErrors(const char *filename,; const char *format=""%lg %lg %lg %lg"", Option_t *option="""");; ```. The format string can be:. - `""%lg %lg""` read only 2 first columns into X,Y. - `""%lg %lg %lg""` read only 3 first columns into X,Y and EY. - `""%lg %lg %lg %lg""` read only 4 first columns into X,Y,EX,EY. This approach has the nice feature of allowing the user to reuse the; macro for many different data sets. Here is an example of an input file.; The nice graphic result shown is produced by the macro below, which; reads two such input files and uses different options to display the; data points. ```; # Measurement of Friday 26 March; # Experiment 2 Physics Lab. 1 6 5; 2 12 5; 3 14 4.7; 4 20 4.5; 5 22 4.2; 6 24 5.1; 7 35 2.9; 8 45 4.1; 9 44 4.8; 10 53 5.43; ```; \newpage; ![](figures/graph_with_expectation.png). ``` {.cpp}; @ROOT_INCLUDE_FILE macros/macro2.C; ```. In addition to the inspection of the plot, you can check the actual; contents of the graph with the `TGraph::Print()` method at any time,; obtaining a printout of the coordinates of data points on screen. The; macro also shows us how to print a coloured band around a graph instead; of error bars, quite useful for example to represent the errors of a; theoretical prediction. ## Polar Graphs ##. With ROOT you can profit from rather advanced plotting routines, like; the ones implemented in the `TPolarGraph`, a class to draw graphs in; polar coordinates. You can see the example macro in the following and the; resulting Figure is [4.2](#f42):. ``` {.cpp .numberLines}; @ROOT_INCLUDE_FILE macros/",MatchSource.DOCS,documentation/primer/graphs.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/graphs.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/graphs.md:4380,Usability,learn,learn,4380,"is instance random numbers distributed according to; different probability density functions, like the Uniform one at; lines *27-29*. See the on-line documentation to appreciate the full; power of this ROOT feature. - Line *8*: You are already familiar with the `TF1` class. This is; its two-dimensional version. At line *16* two random numbers; distributed according to the `TF2` formula are drawn with the method; `TF2::GetRandom2(double& a, double&b)`. - Line *27-29*: Fitting a 2-dimensional function just works like in; the one-dimensional case, i.e. initialisation of parameters and; calling of the `Fit()` method. - Line *34*: The *Surf1* option draws the `TF2` objects (but also; bi-dimensional histograms) as coloured surfaces with a wire-frame on; three-dimensional canvases. See Figure [4.3](#f43). - Line *35-40*: Retrieve the axis pointer and define the axis titles. - Line *41*: Draw the cloud of points on top of the coloured surface. - Line *43-49*: Here you learn how to create a canvas, partition it in; two sub-pads and access them. It is very handy to show multiple; plots in the same window or image. [f43]: figures/fitted2dFunction.png ""f43""; <a name=""f43""></a>. ![A dataset fitted with a bidimensional function visualised as a colored; surface.\label{f43}][f43]. \newpage. ## Multiple graphs ##. The class `TMultigraph` allows to manipulate a set of graphs as a single entity.; It is a collection of `TGraph` (or derived) objects. When drawn, the X and Y axis; ranges are automatically computed such as all the graphs will be visible. ``` {.cpp .numberLines}; @ROOT_INCLUDE_FILE macros/multigraph.C; ```; - Line *6* creates the multigraph. - Line *9-28*: create two graphs with errors and add them in the multigraph. - Line *30-32*: draw the multigraph. The axis limits are computed automatically; to make sure all the graphs' points will be in range. [f44]: figures/multigraph.png ""f44""; <a name=""f44""></a>. ![A set of graphs grouped in a multigraph.\label{f44}][f44]. [^3] ht",MatchSource.DOCS,documentation/primer/graphs.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/graphs.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/histograms.md:1765,Availability,error,errors,1765,"ribution. Let's see how operatively you; can fill and draw a histogram with the following example macro. ``` {.cpp .numberLines}; @ROOT_INCLUDE_FILE macros/macro5.C; ```. Which gives you the following plot (Figure [5.1](#f51)):. [f51]: figures/poisson.png ""f51""; <a name=""f51""></a>. ![The result of a counting (pseudo) experiment. Only bins corresponding; to integer values are filled given the discrete nature of the poissonian; distribution. \label{f51}][f51]. Using histograms is rather simple. The main differences with respect to; graphs that emerge from the example are:. - line *5*: The histograms have a name and a title right from the; start, no predefined number of entries but a number of bins and a; lower-upper range. - line *15*: An entry is stored in the histogram through the; `TH1F::Fill` method. - line *18* and *21*: The histogram can be drawn also normalised, ROOT; automatically takes cares of the necessary rescaling. - line *24* to *30*: This small snippet shows how easy it is to access; the moments and associated errors of a histogram. ## Add and Divide Histograms ##. Quite a large number of operations can be carried out with histograms.; The most useful are addition and division. In the following macro we; will learn how to manage these procedures within ROOT. ``` {.cpp .numberLines}; @ROOT_INCLUDE_FILE macros/macro6.C; ```. The plots that you will obtain are shown in Figures [5.2](#f52) and [5.3](#f53). [f52]: figures/histo_sum.png ""f52""; <a name=""f52""></a>. ![The sum of two histograms.\label{f52}][f52]. [f53]: figures/histo_ratio.png ""f53""; <a name=""f53""></a>. ![The ratio of two histograms.\label{f53}][f53]. Some lines now need a bit of clarification:. - line *3*: Cling, as we know, is also able to interpret more than one; function per file. In this case the function simply sets up some; parameters to conveniently set the line of histograms. - line *19* to *21*: Some `C++` syntax for conditional; statements is used to fill the histograms with different ",MatchSource.DOCS,documentation/primer/histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/histograms.md:4366,Availability,error,error,4366,"n variables. You can exploit the; bi-dimensional histogram classes provided by ROOT in a simple way.; Let's see how in this macro:. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/macro7.C; ```. Two kinds of plots are provided within the code, the first one; containing three-dimensional representations (Figure [5.4](#f54)) and the second one; projections and profiles (Figure [5.5](#f55)) of the bi-dimensional histogram. [f54]: figures/th2f.png ""f54""; <a name=""f54""></a>. ![Different ways of representing bi-dimensional; histograms.\label{f54}][f54]. [f55]: figures/proj_and_prof.png ""f55""; <a name=""f55""></a>. ![The projections and profiles of bi-dimensional; histograms.\label{f55}][f55]. When a projection is performed along the x (y) direction, for every bin; along the x (y) axis, all bin contents along the y (x) axis are summed; up (upper the plots of Figure [5.5](#f55)). When a profile is performed along the x (y); direction, for every bin along the x (y) axis, the average of all the; bin contents along the y (x) is calculated together with their RMS and; displayed as a symbol with error bar (lower two plots of Figure [5.5](#f55)). Correlations between the variables are quantified by the methods; `Double_t GetCovariance()` and `Double_t GetCorrelationFactor()`. \newpage. ## Multiple histograms ##. The class `THStack` allows to manipulate a set of histograms as a single entity.; It is a collection of `TH1` (or derived) objects. When drawn, the X and Y axis; ranges are automatically computed such as all the histograms will be visible.; Several drawing option are available for both 1D and 2D histograms. The next; macros shows how it looks for 2D histograms:. ``` {.cpp .numberLines}; @ROOT_INCLUDE_FILE macros/hstack.C; ```. - Line *4*: creates the stack. - Lines *4-18*: create two histograms to be added in the stack. - Lines *20-21*: add the histograms in the stack. - Line *23*: draws the stack as a lego plot. The colour distinguish the two histograms [5.6](#f56). [f56]: figures/h",MatchSource.DOCS,documentation/primer/histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/histograms.md:4854,Availability,avail,available,4854,"ng three-dimensional representations (Figure [5.4](#f54)) and the second one; projections and profiles (Figure [5.5](#f55)) of the bi-dimensional histogram. [f54]: figures/th2f.png ""f54""; <a name=""f54""></a>. ![Different ways of representing bi-dimensional; histograms.\label{f54}][f54]. [f55]: figures/proj_and_prof.png ""f55""; <a name=""f55""></a>. ![The projections and profiles of bi-dimensional; histograms.\label{f55}][f55]. When a projection is performed along the x (y) direction, for every bin; along the x (y) axis, all bin contents along the y (x) axis are summed; up (upper the plots of Figure [5.5](#f55)). When a profile is performed along the x (y); direction, for every bin along the x (y) axis, the average of all the; bin contents along the y (x) is calculated together with their RMS and; displayed as a symbol with error bar (lower two plots of Figure [5.5](#f55)). Correlations between the variables are quantified by the methods; `Double_t GetCovariance()` and `Double_t GetCorrelationFactor()`. \newpage. ## Multiple histograms ##. The class `THStack` allows to manipulate a set of histograms as a single entity.; It is a collection of `TH1` (or derived) objects. When drawn, the X and Y axis; ranges are automatically computed such as all the histograms will be visible.; Several drawing option are available for both 1D and 2D histograms. The next; macros shows how it looks for 2D histograms:. ``` {.cpp .numberLines}; @ROOT_INCLUDE_FILE macros/hstack.C; ```. - Line *4*: creates the stack. - Lines *4-18*: create two histograms to be added in the stack. - Lines *20-21*: add the histograms in the stack. - Line *23*: draws the stack as a lego plot. The colour distinguish the two histograms [5.6](#f56). [f56]: figures/hstack.png ""f56""; <a name=""f56""></a>. ![Two 2D histograms stack on top of each other.\label{f56}][f56]. [^4]: To optimise the memory usage you might go for one byte (TH1C), short (TH1S), integer (TH1I), long64 (TH1L) or double-precision (TH1D) bin-content.; ",MatchSource.DOCS,documentation/primer/histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/histograms.md:132,Energy Efficiency,power,powerful,132,"# Histograms #. Histograms play a fundamental role in any type of physics analysis, not; only to visualise measurements but being a powerful form of data; reduction. ROOT offers many classes that represent histograms, all; inheriting from the `TH1` class. We will focus in this chapter on uni-; and bi- dimensional histograms the bin contents of which are represented by; floating point numbers [^4], the `TH1F` and `TH2F` classes respectively. ## Your First Histogram ##. Let's suppose you want to measure the counts of a Geiger detector located in; proximity of a radioactive source in a given time interval. This would; give you an idea of the activity of your source. The count distribution; in this case is a Poisson distribution. Let's see how operatively you; can fill and draw a histogram with the following example macro. ``` {.cpp .numberLines}; @ROOT_INCLUDE_FILE macros/macro5.C; ```. Which gives you the following plot (Figure [5.1](#f51)):. [f51]: figures/poisson.png ""f51""; <a name=""f51""></a>. ![The result of a counting (pseudo) experiment. Only bins corresponding; to integer values are filled given the discrete nature of the poissonian; distribution. \label{f51}][f51]. Using histograms is rather simple. The main differences with respect to; graphs that emerge from the example are:. - line *5*: The histograms have a name and a title right from the; start, no predefined number of entries but a number of bins and a; lower-upper range. - line *15*: An entry is stored in the histogram through the; `TH1F::Fill` method. - line *18* and *21*: The histogram can be drawn also normalised, ROOT; automatically takes cares of the necessary rescaling. - line *24* to *30*: This small snippet shows how easy it is to access; the moments and associated errors of a histogram. ## Add and Divide Histograms ##. Quite a large number of operations can be carried out with histograms.; The most useful are addition and division. In the following macro we; will learn how to manage these procedu",MatchSource.DOCS,documentation/primer/histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/histograms.md:223,Modifiability,inherit,inheriting,223,"# Histograms #. Histograms play a fundamental role in any type of physics analysis, not; only to visualise measurements but being a powerful form of data; reduction. ROOT offers many classes that represent histograms, all; inheriting from the `TH1` class. We will focus in this chapter on uni-; and bi- dimensional histograms the bin contents of which are represented by; floating point numbers [^4], the `TH1F` and `TH2F` classes respectively. ## Your First Histogram ##. Let's suppose you want to measure the counts of a Geiger detector located in; proximity of a radioactive source in a given time interval. This would; give you an idea of the activity of your source. The count distribution; in this case is a Poisson distribution. Let's see how operatively you; can fill and draw a histogram with the following example macro. ``` {.cpp .numberLines}; @ROOT_INCLUDE_FILE macros/macro5.C; ```. Which gives you the following plot (Figure [5.1](#f51)):. [f51]: figures/poisson.png ""f51""; <a name=""f51""></a>. ![The result of a counting (pseudo) experiment. Only bins corresponding; to integer values are filled given the discrete nature of the poissonian; distribution. \label{f51}][f51]. Using histograms is rather simple. The main differences with respect to; graphs that emerge from the example are:. - line *5*: The histograms have a name and a title right from the; start, no predefined number of entries but a number of bins and a; lower-upper range. - line *15*: An entry is stored in the histogram through the; `TH1F::Fill` method. - line *18* and *21*: The histogram can be drawn also normalised, ROOT; automatically takes cares of the necessary rescaling. - line *24* to *30*: This small snippet shows how easy it is to access; the moments and associated errors of a histogram. ## Add and Divide Histograms ##. Quite a large number of operations can be carried out with histograms.; The most useful are addition and division. In the following macro we; will learn how to manage these procedu",MatchSource.DOCS,documentation/primer/histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/histograms.md:3280,Modifiability,variab,variables,3280,"o histograms.\label{f52}][f52]. [f53]: figures/histo_ratio.png ""f53""; <a name=""f53""></a>. ![The ratio of two histograms.\label{f53}][f53]. Some lines now need a bit of clarification:. - line *3*: Cling, as we know, is also able to interpret more than one; function per file. In this case the function simply sets up some; parameters to conveniently set the line of histograms. - line *19* to *21*: Some `C++` syntax for conditional; statements is used to fill the histograms with different numbers of; entries inside the loop. - line *30*: The sum of two histograms. A weight, which can be negative, can; be assigned to the added histogram. - line *41*: The division of two histograms is rather straightforward. - line *44* to *62*: When you draw two quantities and their ratios, it; is much better if all the information is condensed in one single; plot. These lines provide a skeleton to perform this operation. ## Two-dimensional Histograms ##. Two-dimensional histograms are a very useful tool, for example to; inspect correlations between variables. You can exploit the; bi-dimensional histogram classes provided by ROOT in a simple way.; Let's see how in this macro:. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/macro7.C; ```. Two kinds of plots are provided within the code, the first one; containing three-dimensional representations (Figure [5.4](#f54)) and the second one; projections and profiles (Figure [5.5](#f55)) of the bi-dimensional histogram. [f54]: figures/th2f.png ""f54""; <a name=""f54""></a>. ![Different ways of representing bi-dimensional; histograms.\label{f54}][f54]. [f55]: figures/proj_and_prof.png ""f55""; <a name=""f55""></a>. ![The projections and profiles of bi-dimensional; histograms.\label{f55}][f55]. When a projection is performed along the x (y) direction, for every bin; along the x (y) axis, all bin contents along the y (x) axis are summed; up (upper the plots of Figure [5.5](#f55)). When a profile is performed along the x (y); direction, for every bin along the x (y) ",MatchSource.DOCS,documentation/primer/histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/histograms.md:4442,Modifiability,variab,variables,4442,"are provided within the code, the first one; containing three-dimensional representations (Figure [5.4](#f54)) and the second one; projections and profiles (Figure [5.5](#f55)) of the bi-dimensional histogram. [f54]: figures/th2f.png ""f54""; <a name=""f54""></a>. ![Different ways of representing bi-dimensional; histograms.\label{f54}][f54]. [f55]: figures/proj_and_prof.png ""f55""; <a name=""f55""></a>. ![The projections and profiles of bi-dimensional; histograms.\label{f55}][f55]. When a projection is performed along the x (y) direction, for every bin; along the x (y) axis, all bin contents along the y (x) axis are summed; up (upper the plots of Figure [5.5](#f55)). When a profile is performed along the x (y); direction, for every bin along the x (y) axis, the average of all the; bin contents along the y (x) is calculated together with their RMS and; displayed as a symbol with error bar (lower two plots of Figure [5.5](#f55)). Correlations between the variables are quantified by the methods; `Double_t GetCovariance()` and `Double_t GetCorrelationFactor()`. \newpage. ## Multiple histograms ##. The class `THStack` allows to manipulate a set of histograms as a single entity.; It is a collection of `TH1` (or derived) objects. When drawn, the X and Y axis; ranges are automatically computed such as all the histograms will be visible.; Several drawing option are available for both 1D and 2D histograms. The next; macros shows how it looks for 2D histograms:. ``` {.cpp .numberLines}; @ROOT_INCLUDE_FILE macros/hstack.C; ```. - Line *4*: creates the stack. - Lines *4-18*: create two histograms to be added in the stack. - Lines *20-21*: add the histograms in the stack. - Line *23*: draws the stack as a lego plot. The colour distinguish the two histograms [5.6](#f56). [f56]: figures/hstack.png ""f56""; <a name=""f56""></a>. ![Two 2D histograms stack on top of each other.\label{f56}][f56]. [^4]: To optimise the memory usage you might go for one byte (TH1C), short (TH1S), integer (TH1I), lo",MatchSource.DOCS,documentation/primer/histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/histograms.md:3126,Performance,perform,perform,3126,"hown in Figures [5.2](#f52) and [5.3](#f53). [f52]: figures/histo_sum.png ""f52""; <a name=""f52""></a>. ![The sum of two histograms.\label{f52}][f52]. [f53]: figures/histo_ratio.png ""f53""; <a name=""f53""></a>. ![The ratio of two histograms.\label{f53}][f53]. Some lines now need a bit of clarification:. - line *3*: Cling, as we know, is also able to interpret more than one; function per file. In this case the function simply sets up some; parameters to conveniently set the line of histograms. - line *19* to *21*: Some `C++` syntax for conditional; statements is used to fill the histograms with different numbers of; entries inside the loop. - line *30*: The sum of two histograms. A weight, which can be negative, can; be assigned to the added histogram. - line *41*: The division of two histograms is rather straightforward. - line *44* to *62*: When you draw two quantities and their ratios, it; is much better if all the information is condensed in one single; plot. These lines provide a skeleton to perform this operation. ## Two-dimensional Histograms ##. Two-dimensional histograms are a very useful tool, for example to; inspect correlations between variables. You can exploit the; bi-dimensional histogram classes provided by ROOT in a simple way.; Let's see how in this macro:. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/macro7.C; ```. Two kinds of plots are provided within the code, the first one; containing three-dimensional representations (Figure [5.4](#f54)) and the second one; projections and profiles (Figure [5.5](#f55)) of the bi-dimensional histogram. [f54]: figures/th2f.png ""f54""; <a name=""f54""></a>. ![Different ways of representing bi-dimensional; histograms.\label{f54}][f54]. [f55]: figures/proj_and_prof.png ""f55""; <a name=""f55""></a>. ![The projections and profiles of bi-dimensional; histograms.\label{f55}][f55]. When a projection is performed along the x (y) direction, for every bin; along the x (y) axis, all bin contents along the y (x) axis are summed; up (upper the",MatchSource.DOCS,documentation/primer/histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/histograms.md:3983,Performance,perform,performed,3983,"rmation is condensed in one single; plot. These lines provide a skeleton to perform this operation. ## Two-dimensional Histograms ##. Two-dimensional histograms are a very useful tool, for example to; inspect correlations between variables. You can exploit the; bi-dimensional histogram classes provided by ROOT in a simple way.; Let's see how in this macro:. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/macro7.C; ```. Two kinds of plots are provided within the code, the first one; containing three-dimensional representations (Figure [5.4](#f54)) and the second one; projections and profiles (Figure [5.5](#f55)) of the bi-dimensional histogram. [f54]: figures/th2f.png ""f54""; <a name=""f54""></a>. ![Different ways of representing bi-dimensional; histograms.\label{f54}][f54]. [f55]: figures/proj_and_prof.png ""f55""; <a name=""f55""></a>. ![The projections and profiles of bi-dimensional; histograms.\label{f55}][f55]. When a projection is performed along the x (y) direction, for every bin; along the x (y) axis, all bin contents along the y (x) axis are summed; up (upper the plots of Figure [5.5](#f55)). When a profile is performed along the x (y); direction, for every bin along the x (y) axis, the average of all the; bin contents along the y (x) is calculated together with their RMS and; displayed as a symbol with error bar (lower two plots of Figure [5.5](#f55)). Correlations between the variables are quantified by the methods; `Double_t GetCovariance()` and `Double_t GetCorrelationFactor()`. \newpage. ## Multiple histograms ##. The class `THStack` allows to manipulate a set of histograms as a single entity.; It is a collection of `TH1` (or derived) objects. When drawn, the X and Y axis; ranges are automatically computed such as all the histograms will be visible.; Several drawing option are available for both 1D and 2D histograms. The next; macros shows how it looks for 2D histograms:. ``` {.cpp .numberLines}; @ROOT_INCLUDE_FILE macros/hstack.C; ```. - Line *4*: creates the stack. - L",MatchSource.DOCS,documentation/primer/histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/histograms.md:4169,Performance,perform,performed,4169,"n variables. You can exploit the; bi-dimensional histogram classes provided by ROOT in a simple way.; Let's see how in this macro:. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/macro7.C; ```. Two kinds of plots are provided within the code, the first one; containing three-dimensional representations (Figure [5.4](#f54)) and the second one; projections and profiles (Figure [5.5](#f55)) of the bi-dimensional histogram. [f54]: figures/th2f.png ""f54""; <a name=""f54""></a>. ![Different ways of representing bi-dimensional; histograms.\label{f54}][f54]. [f55]: figures/proj_and_prof.png ""f55""; <a name=""f55""></a>. ![The projections and profiles of bi-dimensional; histograms.\label{f55}][f55]. When a projection is performed along the x (y) direction, for every bin; along the x (y) axis, all bin contents along the y (x) axis are summed; up (upper the plots of Figure [5.5](#f55)). When a profile is performed along the x (y); direction, for every bin along the x (y) axis, the average of all the; bin contents along the y (x) is calculated together with their RMS and; displayed as a symbol with error bar (lower two plots of Figure [5.5](#f55)). Correlations between the variables are quantified by the methods; `Double_t GetCovariance()` and `Double_t GetCorrelationFactor()`. \newpage. ## Multiple histograms ##. The class `THStack` allows to manipulate a set of histograms as a single entity.; It is a collection of `TH1` (or derived) objects. When drawn, the X and Y axis; ranges are automatically computed such as all the histograms will be visible.; Several drawing option are available for both 1D and 2D histograms. The next; macros shows how it looks for 2D histograms:. ``` {.cpp .numberLines}; @ROOT_INCLUDE_FILE macros/hstack.C; ```. - Line *4*: creates the stack. - Lines *4-18*: create two histograms to be added in the stack. - Lines *20-21*: add the histograms in the stack. - Line *23*: draws the stack as a lego plot. The colour distinguish the two histograms [5.6](#f56). [f56]: figures/h",MatchSource.DOCS,documentation/primer/histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/histograms.md:530,Safety,detect,detector,530,"# Histograms #. Histograms play a fundamental role in any type of physics analysis, not; only to visualise measurements but being a powerful form of data; reduction. ROOT offers many classes that represent histograms, all; inheriting from the `TH1` class. We will focus in this chapter on uni-; and bi- dimensional histograms the bin contents of which are represented by; floating point numbers [^4], the `TH1F` and `TH2F` classes respectively. ## Your First Histogram ##. Let's suppose you want to measure the counts of a Geiger detector located in; proximity of a radioactive source in a given time interval. This would; give you an idea of the activity of your source. The count distribution; in this case is a Poisson distribution. Let's see how operatively you; can fill and draw a histogram with the following example macro. ``` {.cpp .numberLines}; @ROOT_INCLUDE_FILE macros/macro5.C; ```. Which gives you the following plot (Figure [5.1](#f51)):. [f51]: figures/poisson.png ""f51""; <a name=""f51""></a>. ![The result of a counting (pseudo) experiment. Only bins corresponding; to integer values are filled given the discrete nature of the poissonian; distribution. \label{f51}][f51]. Using histograms is rather simple. The main differences with respect to; graphs that emerge from the example are:. - line *5*: The histograms have a name and a title right from the; start, no predefined number of entries but a number of bins and a; lower-upper range. - line *15*: An entry is stored in the histogram through the; `TH1F::Fill` method. - line *18* and *21*: The histogram can be drawn also normalised, ROOT; automatically takes cares of the necessary rescaling. - line *24* to *30*: This small snippet shows how easy it is to access; the moments and associated errors of a histogram. ## Add and Divide Histograms ##. Quite a large number of operations can be carried out with histograms.; The most useful are addition and division. In the following macro we; will learn how to manage these procedu",MatchSource.DOCS,documentation/primer/histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/histograms.md:1730,Security,access,access,1730,"ribution. Let's see how operatively you; can fill and draw a histogram with the following example macro. ``` {.cpp .numberLines}; @ROOT_INCLUDE_FILE macros/macro5.C; ```. Which gives you the following plot (Figure [5.1](#f51)):. [f51]: figures/poisson.png ""f51""; <a name=""f51""></a>. ![The result of a counting (pseudo) experiment. Only bins corresponding; to integer values are filled given the discrete nature of the poissonian; distribution. \label{f51}][f51]. Using histograms is rather simple. The main differences with respect to; graphs that emerge from the example are:. - line *5*: The histograms have a name and a title right from the; start, no predefined number of entries but a number of bins and a; lower-upper range. - line *15*: An entry is stored in the histogram through the; `TH1F::Fill` method. - line *18* and *21*: The histogram can be drawn also normalised, ROOT; automatically takes cares of the necessary rescaling. - line *24* to *30*: This small snippet shows how easy it is to access; the moments and associated errors of a histogram. ## Add and Divide Histograms ##. Quite a large number of operations can be carried out with histograms.; The most useful are addition and division. In the following macro we; will learn how to manage these procedures within ROOT. ``` {.cpp .numberLines}; @ROOT_INCLUDE_FILE macros/macro6.C; ```. The plots that you will obtain are shown in Figures [5.2](#f52) and [5.3](#f53). [f52]: figures/histo_sum.png ""f52""; <a name=""f52""></a>. ![The sum of two histograms.\label{f52}][f52]. [f53]: figures/histo_ratio.png ""f53""; <a name=""f53""></a>. ![The ratio of two histograms.\label{f53}][f53]. Some lines now need a bit of clarification:. - line *3*: Cling, as we know, is also able to interpret more than one; function per file. In this case the function simply sets up some; parameters to conveniently set the line of histograms. - line *19* to *21*: Some `C++` syntax for conditional; statements is used to fill the histograms with different ",MatchSource.DOCS,documentation/primer/histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/histograms.md:1216,Usability,simpl,simple,1216," histograms, all; inheriting from the `TH1` class. We will focus in this chapter on uni-; and bi- dimensional histograms the bin contents of which are represented by; floating point numbers [^4], the `TH1F` and `TH2F` classes respectively. ## Your First Histogram ##. Let's suppose you want to measure the counts of a Geiger detector located in; proximity of a radioactive source in a given time interval. This would; give you an idea of the activity of your source. The count distribution; in this case is a Poisson distribution. Let's see how operatively you; can fill and draw a histogram with the following example macro. ``` {.cpp .numberLines}; @ROOT_INCLUDE_FILE macros/macro5.C; ```. Which gives you the following plot (Figure [5.1](#f51)):. [f51]: figures/poisson.png ""f51""; <a name=""f51""></a>. ![The result of a counting (pseudo) experiment. Only bins corresponding; to integer values are filled given the discrete nature of the poissonian; distribution. \label{f51}][f51]. Using histograms is rather simple. The main differences with respect to; graphs that emerge from the example are:. - line *5*: The histograms have a name and a title right from the; start, no predefined number of entries but a number of bins and a; lower-upper range. - line *15*: An entry is stored in the histogram through the; `TH1F::Fill` method. - line *18* and *21*: The histogram can be drawn also normalised, ROOT; automatically takes cares of the necessary rescaling. - line *24* to *30*: This small snippet shows how easy it is to access; the moments and associated errors of a histogram. ## Add and Divide Histograms ##. Quite a large number of operations can be carried out with histograms.; The most useful are addition and division. In the following macro we; will learn how to manage these procedures within ROOT. ``` {.cpp .numberLines}; @ROOT_INCLUDE_FILE macros/macro6.C; ```. The plots that you will obtain are shown in Figures [5.2](#f52) and [5.3](#f53). [f52]: figures/histo_sum.png ""f52""; <a na",MatchSource.DOCS,documentation/primer/histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/histograms.md:1968,Usability,learn,learn,1968,"n.png ""f51""; <a name=""f51""></a>. ![The result of a counting (pseudo) experiment. Only bins corresponding; to integer values are filled given the discrete nature of the poissonian; distribution. \label{f51}][f51]. Using histograms is rather simple. The main differences with respect to; graphs that emerge from the example are:. - line *5*: The histograms have a name and a title right from the; start, no predefined number of entries but a number of bins and a; lower-upper range. - line *15*: An entry is stored in the histogram through the; `TH1F::Fill` method. - line *18* and *21*: The histogram can be drawn also normalised, ROOT; automatically takes cares of the necessary rescaling. - line *24* to *30*: This small snippet shows how easy it is to access; the moments and associated errors of a histogram. ## Add and Divide Histograms ##. Quite a large number of operations can be carried out with histograms.; The most useful are addition and division. In the following macro we; will learn how to manage these procedures within ROOT. ``` {.cpp .numberLines}; @ROOT_INCLUDE_FILE macros/macro6.C; ```. The plots that you will obtain are shown in Figures [5.2](#f52) and [5.3](#f53). [f52]: figures/histo_sum.png ""f52""; <a name=""f52""></a>. ![The sum of two histograms.\label{f52}][f52]. [f53]: figures/histo_ratio.png ""f53""; <a name=""f53""></a>. ![The ratio of two histograms.\label{f53}][f53]. Some lines now need a bit of clarification:. - line *3*: Cling, as we know, is also able to interpret more than one; function per file. In this case the function simply sets up some; parameters to conveniently set the line of histograms. - line *19* to *21*: Some `C++` syntax for conditional; statements is used to fill the histograms with different numbers of; entries inside the loop. - line *30*: The sum of two histograms. A weight, which can be negative, can; be assigned to the added histogram. - line *41*: The division of two histograms is rather straightforward. - line *44* to *62*: When yo",MatchSource.DOCS,documentation/primer/histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/histograms.md:2537,Usability,simpl,simply,2537," The histogram can be drawn also normalised, ROOT; automatically takes cares of the necessary rescaling. - line *24* to *30*: This small snippet shows how easy it is to access; the moments and associated errors of a histogram. ## Add and Divide Histograms ##. Quite a large number of operations can be carried out with histograms.; The most useful are addition and division. In the following macro we; will learn how to manage these procedures within ROOT. ``` {.cpp .numberLines}; @ROOT_INCLUDE_FILE macros/macro6.C; ```. The plots that you will obtain are shown in Figures [5.2](#f52) and [5.3](#f53). [f52]: figures/histo_sum.png ""f52""; <a name=""f52""></a>. ![The sum of two histograms.\label{f52}][f52]. [f53]: figures/histo_ratio.png ""f53""; <a name=""f53""></a>. ![The ratio of two histograms.\label{f53}][f53]. Some lines now need a bit of clarification:. - line *3*: Cling, as we know, is also able to interpret more than one; function per file. In this case the function simply sets up some; parameters to conveniently set the line of histograms. - line *19* to *21*: Some `C++` syntax for conditional; statements is used to fill the histograms with different numbers of; entries inside the loop. - line *30*: The sum of two histograms. A weight, which can be negative, can; be assigned to the added histogram. - line *41*: The division of two histograms is rather straightforward. - line *44* to *62*: When you draw two quantities and their ratios, it; is much better if all the information is condensed in one single; plot. These lines provide a skeleton to perform this operation. ## Two-dimensional Histograms ##. Two-dimensional histograms are a very useful tool, for example to; inspect correlations between variables. You can exploit the; bi-dimensional histogram classes provided by ROOT in a simple way.; Let's see how in this macro:. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/macro7.C; ```. Two kinds of plots are provided within the code, the first one; containing three-dimensional repre",MatchSource.DOCS,documentation/primer/histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/histograms.md:3367,Usability,simpl,simple,3367,"tio of two histograms.\label{f53}][f53]. Some lines now need a bit of clarification:. - line *3*: Cling, as we know, is also able to interpret more than one; function per file. In this case the function simply sets up some; parameters to conveniently set the line of histograms. - line *19* to *21*: Some `C++` syntax for conditional; statements is used to fill the histograms with different numbers of; entries inside the loop. - line *30*: The sum of two histograms. A weight, which can be negative, can; be assigned to the added histogram. - line *41*: The division of two histograms is rather straightforward. - line *44* to *62*: When you draw two quantities and their ratios, it; is much better if all the information is condensed in one single; plot. These lines provide a skeleton to perform this operation. ## Two-dimensional Histograms ##. Two-dimensional histograms are a very useful tool, for example to; inspect correlations between variables. You can exploit the; bi-dimensional histogram classes provided by ROOT in a simple way.; Let's see how in this macro:. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/macro7.C; ```. Two kinds of plots are provided within the code, the first one; containing three-dimensional representations (Figure [5.4](#f54)) and the second one; projections and profiles (Figure [5.5](#f55)) of the bi-dimensional histogram. [f54]: figures/th2f.png ""f54""; <a name=""f54""></a>. ![Different ways of representing bi-dimensional; histograms.\label{f54}][f54]. [f55]: figures/proj_and_prof.png ""f55""; <a name=""f55""></a>. ![The projections and profiles of bi-dimensional; histograms.\label{f55}][f55]. When a projection is performed along the x (y) direction, for every bin; along the x (y) axis, all bin contents along the y (x) axis are summed; up (upper the plots of Figure [5.5](#f55)). When a profile is performed along the x (y); direction, for every bin along the x (y) axis, the average of all the; bin contents along the y (x) is calculated together with their RMS ",MatchSource.DOCS,documentation/primer/histograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/histograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md:1171,Availability,error,errors,1171," physics. In the most simple case, a ""model"" is; just a function providing predictions of measured data. Very often, the; model depends on parameters. Such a model may simply state ""the current; *I* is proportional to the voltage *U*"", and the task of the; experimentalist consists of determining the resistance, *R*, from a set; of measurements. As a first step, a visualisation of the data is needed. Next, some; manipulations typically have to be applied, e.g. corrections or; parameter transformations. Quite often, these manipulations are complex; ones, and a powerful library of mathematical functions and procedures; should be provided - think for example of an integral or peak-search or; a Fourier transformation applied to an input spectrum to obtain the; actual measurement described by the model. One specialty of experimental physics are the inevitable uncertainties; affecting each measurement, and visualisation tools have to include; these. In subsequent analysis, the statistical nature of the errors must; be handled properly. As the last step, measurements are compared to models, and free model; parameters need to be determined in this process. See Figure [1.1](#f11) for an; example of a function (model) fit to data points. Several standard methods are; available, and a data analysis tool should provide easy access to more; than one of them. Means to quantify the level of agreement between; measurements and model must also be available.; <!--; [f11]: figures/examplefit.png ""f11""; <a name=""f11""></a>. ![Measured data points with error bars and fitted quadratic; function.\label{f11}][f11]-->. Quite often, the data volume to be analyzed is large - think of; fine-granular measurements accumulated with the aid of computers. A; usable tool therefore must contain easy-to-use and efficient methods for; storing and handling data. In Quantum mechanics, models typically only predict the probability; density function (""pdf"") of measurements depending on a number of; parameter",MatchSource.DOCS,documentation/primer/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md:1437,Availability,avail,available,1437,"tance, *R*, from a set; of measurements. As a first step, a visualisation of the data is needed. Next, some; manipulations typically have to be applied, e.g. corrections or; parameter transformations. Quite often, these manipulations are complex; ones, and a powerful library of mathematical functions and procedures; should be provided - think for example of an integral or peak-search or; a Fourier transformation applied to an input spectrum to obtain the; actual measurement described by the model. One specialty of experimental physics are the inevitable uncertainties; affecting each measurement, and visualisation tools have to include; these. In subsequent analysis, the statistical nature of the errors must; be handled properly. As the last step, measurements are compared to models, and free model; parameters need to be determined in this process. See Figure [1.1](#f11) for an; example of a function (model) fit to data points. Several standard methods are; available, and a data analysis tool should provide easy access to more; than one of them. Means to quantify the level of agreement between; measurements and model must also be available.; <!--; [f11]: figures/examplefit.png ""f11""; <a name=""f11""></a>. ![Measured data points with error bars and fitted quadratic; function.\label{f11}][f11]-->. Quite often, the data volume to be analyzed is large - think of; fine-granular measurements accumulated with the aid of computers. A; usable tool therefore must contain easy-to-use and efficient methods for; storing and handling data. In Quantum mechanics, models typically only predict the probability; density function (""pdf"") of measurements depending on a number of; parameters, and the aim of the experimental analysis is to extract the; parameters from the observed distribution of frequencies at which; certain values of the measurement are observed. Measurements of this; kind require means to generate and visualize frequency distributions,; so-called histograms, and stringent",MatchSource.DOCS,documentation/primer/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md:1613,Availability,avail,available,1613," manipulations typically have to be applied, e.g. corrections or; parameter transformations. Quite often, these manipulations are complex; ones, and a powerful library of mathematical functions and procedures; should be provided - think for example of an integral or peak-search or; a Fourier transformation applied to an input spectrum to obtain the; actual measurement described by the model. One specialty of experimental physics are the inevitable uncertainties; affecting each measurement, and visualisation tools have to include; these. In subsequent analysis, the statistical nature of the errors must; be handled properly. As the last step, measurements are compared to models, and free model; parameters need to be determined in this process. See Figure [1.1](#f11) for an; example of a function (model) fit to data points. Several standard methods are; available, and a data analysis tool should provide easy access to more; than one of them. Means to quantify the level of agreement between; measurements and model must also be available.; <!--; [f11]: figures/examplefit.png ""f11""; <a name=""f11""></a>. ![Measured data points with error bars and fitted quadratic; function.\label{f11}][f11]-->. Quite often, the data volume to be analyzed is large - think of; fine-granular measurements accumulated with the aid of computers. A; usable tool therefore must contain easy-to-use and efficient methods for; storing and handling data. In Quantum mechanics, models typically only predict the probability; density function (""pdf"") of measurements depending on a number of; parameters, and the aim of the experimental analysis is to extract the; parameters from the observed distribution of frequencies at which; certain values of the measurement are observed. Measurements of this; kind require means to generate and visualize frequency distributions,; so-called histograms, and stringent statistical treatment to extract the; model parameters from purely statistical distributions. Simulation of ",MatchSource.DOCS,documentation/primer/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md:1716,Availability,error,error,1716," a powerful library of mathematical functions and procedures; should be provided - think for example of an integral or peak-search or; a Fourier transformation applied to an input spectrum to obtain the; actual measurement described by the model. One specialty of experimental physics are the inevitable uncertainties; affecting each measurement, and visualisation tools have to include; these. In subsequent analysis, the statistical nature of the errors must; be handled properly. As the last step, measurements are compared to models, and free model; parameters need to be determined in this process. See Figure [1.1](#f11) for an; example of a function (model) fit to data points. Several standard methods are; available, and a data analysis tool should provide easy access to more; than one of them. Means to quantify the level of agreement between; measurements and model must also be available.; <!--; [f11]: figures/examplefit.png ""f11""; <a name=""f11""></a>. ![Measured data points with error bars and fitted quadratic; function.\label{f11}][f11]-->. Quite often, the data volume to be analyzed is large - think of; fine-granular measurements accumulated with the aid of computers. A; usable tool therefore must contain easy-to-use and efficient methods for; storing and handling data. In Quantum mechanics, models typically only predict the probability; density function (""pdf"") of measurements depending on a number of; parameters, and the aim of the experimental analysis is to extract the; parameters from the observed distribution of frequencies at which; certain values of the measurement are observed. Measurements of this; kind require means to generate and visualize frequency distributions,; so-called histograms, and stringent statistical treatment to extract the; model parameters from purely statistical distributions. Simulation of expected data is another important aspect in data; analysis. By repeated generation of ""pseudo-data"", which are analysed in; the same manner as inte",MatchSource.DOCS,documentation/primer/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md:2850,Availability,error,errors,2850,"ed with the aid of computers. A; usable tool therefore must contain easy-to-use and efficient methods for; storing and handling data. In Quantum mechanics, models typically only predict the probability; density function (""pdf"") of measurements depending on a number of; parameters, and the aim of the experimental analysis is to extract the; parameters from the observed distribution of frequencies at which; certain values of the measurement are observed. Measurements of this; kind require means to generate and visualize frequency distributions,; so-called histograms, and stringent statistical treatment to extract the; model parameters from purely statistical distributions. Simulation of expected data is another important aspect in data; analysis. By repeated generation of ""pseudo-data"", which are analysed in; the same manner as intended for the real data, analysis procedures can; be validated or compared. In many cases, the distribution of the; measurement errors is not precisely known, and simulation offers the; possibility to test the effects of different assumptions. A powerful software framework addressing all of the above requirements; is ROOT, an open source project coordinated by the European Organisation for; Nuclear Research, CERN in Geneva. ROOT is very flexible and provides both a programming interface to use in own; applications and a graphical user interface for interactive data analysis. The; purpose of this document is to serve as a beginners guide and provides extendable; examples for your own use cases, based on typical problems addressed in; student labs. This guide will hopefully lay the ground for more complex; applications in your future scientific work building on a modern,; state-of the art tool for data analysis. This guide in form of a tutorial is intended to introduce you quickly to the; ROOT package. This goal will be accomplished using concrete examples, according; to the ""learning by doing"" principle. Also because of this reason, this guid",MatchSource.DOCS,documentation/primer/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md:4543,Availability,avail,available,4543,"interface to use in own; applications and a graphical user interface for interactive data analysis. The; purpose of this document is to serve as a beginners guide and provides extendable; examples for your own use cases, based on typical problems addressed in; student labs. This guide will hopefully lay the ground for more complex; applications in your future scientific work building on a modern,; state-of the art tool for data analysis. This guide in form of a tutorial is intended to introduce you quickly to the; ROOT package. This goal will be accomplished using concrete examples, according; to the ""learning by doing"" principle. Also because of this reason, this guide; cannot cover all the complexity of the ROOT package. Nevertheless, once you feel; confident with the concepts presented in the following chapters, you will be; able to appreciate the ROOT Users Guide [@ROOT_Users_Guide] and navigate through; the Class Reference [@ROOT_Class_Reference] to find all the details you might be; interested in. You can even look at the code itself, since ROOT is a; free, open-source product. Use these documents in parallel to this; tutorial!. The ROOT Data Analysis Framework itself is written in and heavily relies; on the `C++` programming language: some knowledge about `C++` is required.; Jus take advantage from the immense available literature about `C++` if you do; not have any idea of what this language is about. ROOT is available for many platforms (Linux, Mac OS X, Windows...), but; in this guide we will implicitly assume that you are using Linux. The; first thing you need to do with ROOT is install it, don't you ? Obtaining; the latest ROOT version is straightforward. Just seek the ""Pro"" version; on this webpage <http://root.cern.ch/downloading-root>.; You will find precompiled versions for the different architectures, or; the ROOT source code to compile yourself. Just pick up the flavour you; need and follow the installation instructions. **Let's dive into ROOT!**; ",MatchSource.DOCS,documentation/primer/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md:4645,Availability,avail,available,4645,"interface to use in own; applications and a graphical user interface for interactive data analysis. The; purpose of this document is to serve as a beginners guide and provides extendable; examples for your own use cases, based on typical problems addressed in; student labs. This guide will hopefully lay the ground for more complex; applications in your future scientific work building on a modern,; state-of the art tool for data analysis. This guide in form of a tutorial is intended to introduce you quickly to the; ROOT package. This goal will be accomplished using concrete examples, according; to the ""learning by doing"" principle. Also because of this reason, this guide; cannot cover all the complexity of the ROOT package. Nevertheless, once you feel; confident with the concepts presented in the following chapters, you will be; able to appreciate the ROOT Users Guide [@ROOT_Users_Guide] and navigate through; the Class Reference [@ROOT_Class_Reference] to find all the details you might be; interested in. You can even look at the code itself, since ROOT is a; free, open-source product. Use these documents in parallel to this; tutorial!. The ROOT Data Analysis Framework itself is written in and heavily relies; on the `C++` programming language: some knowledge about `C++` is required.; Jus take advantage from the immense available literature about `C++` if you do; not have any idea of what this language is about. ROOT is available for many platforms (Linux, Mac OS X, Windows...), but; in this guide we will implicitly assume that you are using Linux. The; first thing you need to do with ROOT is install it, don't you ? Obtaining; the latest ROOT version is straightforward. Just seek the ""Pro"" version; on this webpage <http://root.cern.ch/downloading-root>.; You will find precompiled versions for the different architectures, or; the ROOT source code to compile yourself. Just pick up the flavour you; need and follow the installation instructions. **Let's dive into ROOT!**; ",MatchSource.DOCS,documentation/primer/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md:4966,Availability,down,downloading-root,4966,"interface to use in own; applications and a graphical user interface for interactive data analysis. The; purpose of this document is to serve as a beginners guide and provides extendable; examples for your own use cases, based on typical problems addressed in; student labs. This guide will hopefully lay the ground for more complex; applications in your future scientific work building on a modern,; state-of the art tool for data analysis. This guide in form of a tutorial is intended to introduce you quickly to the; ROOT package. This goal will be accomplished using concrete examples, according; to the ""learning by doing"" principle. Also because of this reason, this guide; cannot cover all the complexity of the ROOT package. Nevertheless, once you feel; confident with the concepts presented in the following chapters, you will be; able to appreciate the ROOT Users Guide [@ROOT_Users_Guide] and navigate through; the Class Reference [@ROOT_Class_Reference] to find all the details you might be; interested in. You can even look at the code itself, since ROOT is a; free, open-source product. Use these documents in parallel to this; tutorial!. The ROOT Data Analysis Framework itself is written in and heavily relies; on the `C++` programming language: some knowledge about `C++` is required.; Jus take advantage from the immense available literature about `C++` if you do; not have any idea of what this language is about. ROOT is available for many platforms (Linux, Mac OS X, Windows...), but; in this guide we will implicitly assume that you are using Linux. The; first thing you need to do with ROOT is install it, don't you ? Obtaining; the latest ROOT version is straightforward. Just seek the ""Pro"" version; on this webpage <http://root.cern.ch/downloading-root>.; You will find precompiled versions for the different architectures, or; the ROOT source code to compile yourself. Just pick up the flavour you; need and follow the installation instructions. **Let's dive into ROOT!**; ",MatchSource.DOCS,documentation/primer/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md:4821,Deployability,install,install,4821,"interface to use in own; applications and a graphical user interface for interactive data analysis. The; purpose of this document is to serve as a beginners guide and provides extendable; examples for your own use cases, based on typical problems addressed in; student labs. This guide will hopefully lay the ground for more complex; applications in your future scientific work building on a modern,; state-of the art tool for data analysis. This guide in form of a tutorial is intended to introduce you quickly to the; ROOT package. This goal will be accomplished using concrete examples, according; to the ""learning by doing"" principle. Also because of this reason, this guide; cannot cover all the complexity of the ROOT package. Nevertheless, once you feel; confident with the concepts presented in the following chapters, you will be; able to appreciate the ROOT Users Guide [@ROOT_Users_Guide] and navigate through; the Class Reference [@ROOT_Class_Reference] to find all the details you might be; interested in. You can even look at the code itself, since ROOT is a; free, open-source product. Use these documents in parallel to this; tutorial!. The ROOT Data Analysis Framework itself is written in and heavily relies; on the `C++` programming language: some knowledge about `C++` is required.; Jus take advantage from the immense available literature about `C++` if you do; not have any idea of what this language is about. ROOT is available for many platforms (Linux, Mac OS X, Windows...), but; in this guide we will implicitly assume that you are using Linux. The; first thing you need to do with ROOT is install it, don't you ? Obtaining; the latest ROOT version is straightforward. Just seek the ""Pro"" version; on this webpage <http://root.cern.ch/downloading-root>.; You will find precompiled versions for the different architectures, or; the ROOT source code to compile yourself. Just pick up the flavour you; need and follow the installation instructions. **Let's dive into ROOT!**; ",MatchSource.DOCS,documentation/primer/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md:5150,Deployability,install,installation,5150,"interface to use in own; applications and a graphical user interface for interactive data analysis. The; purpose of this document is to serve as a beginners guide and provides extendable; examples for your own use cases, based on typical problems addressed in; student labs. This guide will hopefully lay the ground for more complex; applications in your future scientific work building on a modern,; state-of the art tool for data analysis. This guide in form of a tutorial is intended to introduce you quickly to the; ROOT package. This goal will be accomplished using concrete examples, according; to the ""learning by doing"" principle. Also because of this reason, this guide; cannot cover all the complexity of the ROOT package. Nevertheless, once you feel; confident with the concepts presented in the following chapters, you will be; able to appreciate the ROOT Users Guide [@ROOT_Users_Guide] and navigate through; the Class Reference [@ROOT_Class_Reference] to find all the details you might be; interested in. You can even look at the code itself, since ROOT is a; free, open-source product. Use these documents in parallel to this; tutorial!. The ROOT Data Analysis Framework itself is written in and heavily relies; on the `C++` programming language: some knowledge about `C++` is required.; Jus take advantage from the immense available literature about `C++` if you do; not have any idea of what this language is about. ROOT is available for many platforms (Linux, Mac OS X, Windows...), but; in this guide we will implicitly assume that you are using Linux. The; first thing you need to do with ROOT is install it, don't you ? Obtaining; the latest ROOT version is straightforward. Just seek the ""Pro"" version; on this webpage <http://root.cern.ch/downloading-root>.; You will find precompiled versions for the different architectures, or; the ROOT source code to compile yourself. Just pick up the flavour you; need and follow the installation instructions. **Let's dive into ROOT!**; ",MatchSource.DOCS,documentation/primer/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md:725,Energy Efficiency,power,powerful,725,"# Motivation and Introduction #. ***Welcome to data analysis!***. Comparison of measurements to theoretical models is one of the standard; tasks in experimental physics. In the most simple case, a ""model"" is; just a function providing predictions of measured data. Very often, the; model depends on parameters. Such a model may simply state ""the current; *I* is proportional to the voltage *U*"", and the task of the; experimentalist consists of determining the resistance, *R*, from a set; of measurements. As a first step, a visualisation of the data is needed. Next, some; manipulations typically have to be applied, e.g. corrections or; parameter transformations. Quite often, these manipulations are complex; ones, and a powerful library of mathematical functions and procedures; should be provided - think for example of an integral or peak-search or; a Fourier transformation applied to an input spectrum to obtain the; actual measurement described by the model. One specialty of experimental physics are the inevitable uncertainties; affecting each measurement, and visualisation tools have to include; these. In subsequent analysis, the statistical nature of the errors must; be handled properly. As the last step, measurements are compared to models, and free model; parameters need to be determined in this process. See Figure [1.1](#f11) for an; example of a function (model) fit to data points. Several standard methods are; available, and a data analysis tool should provide easy access to more; than one of them. Means to quantify the level of agreement between; measurements and model must also be available.; <!--; [f11]: figures/examplefit.png ""f11""; <a name=""f11""></a>. ![Measured data points with error bars and fitted quadratic; function.\label{f11}][f11]-->. Quite often, the data volume to be analyzed is large - think of; fine-granular measurements accumulated with the aid of computers. A; usable tool therefore must contain easy-to-use and efficient methods for; storing and h",MatchSource.DOCS,documentation/primer/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md:1965,Energy Efficiency,efficient,efficient,1965,"model. One specialty of experimental physics are the inevitable uncertainties; affecting each measurement, and visualisation tools have to include; these. In subsequent analysis, the statistical nature of the errors must; be handled properly. As the last step, measurements are compared to models, and free model; parameters need to be determined in this process. See Figure [1.1](#f11) for an; example of a function (model) fit to data points. Several standard methods are; available, and a data analysis tool should provide easy access to more; than one of them. Means to quantify the level of agreement between; measurements and model must also be available.; <!--; [f11]: figures/examplefit.png ""f11""; <a name=""f11""></a>. ![Measured data points with error bars and fitted quadratic; function.\label{f11}][f11]-->. Quite often, the data volume to be analyzed is large - think of; fine-granular measurements accumulated with the aid of computers. A; usable tool therefore must contain easy-to-use and efficient methods for; storing and handling data. In Quantum mechanics, models typically only predict the probability; density function (""pdf"") of measurements depending on a number of; parameters, and the aim of the experimental analysis is to extract the; parameters from the observed distribution of frequencies at which; certain values of the measurement are observed. Measurements of this; kind require means to generate and visualize frequency distributions,; so-called histograms, and stringent statistical treatment to extract the; model parameters from purely statistical distributions. Simulation of expected data is another important aspect in data; analysis. By repeated generation of ""pseudo-data"", which are analysed in; the same manner as intended for the real data, analysis procedures can; be validated or compared. In many cases, the distribution of the; measurement errors is not precisely known, and simulation offers the; possibility to test the effects of different assumptio",MatchSource.DOCS,documentation/primer/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md:2968,Energy Efficiency,power,powerful,2968,"y predict the probability; density function (""pdf"") of measurements depending on a number of; parameters, and the aim of the experimental analysis is to extract the; parameters from the observed distribution of frequencies at which; certain values of the measurement are observed. Measurements of this; kind require means to generate and visualize frequency distributions,; so-called histograms, and stringent statistical treatment to extract the; model parameters from purely statistical distributions. Simulation of expected data is another important aspect in data; analysis. By repeated generation of ""pseudo-data"", which are analysed in; the same manner as intended for the real data, analysis procedures can; be validated or compared. In many cases, the distribution of the; measurement errors is not precisely known, and simulation offers the; possibility to test the effects of different assumptions. A powerful software framework addressing all of the above requirements; is ROOT, an open source project coordinated by the European Organisation for; Nuclear Research, CERN in Geneva. ROOT is very flexible and provides both a programming interface to use in own; applications and a graphical user interface for interactive data analysis. The; purpose of this document is to serve as a beginners guide and provides extendable; examples for your own use cases, based on typical problems addressed in; student labs. This guide will hopefully lay the ground for more complex; applications in your future scientific work building on a modern,; state-of the art tool for data analysis. This guide in form of a tutorial is intended to introduce you quickly to the; ROOT package. This goal will be accomplished using concrete examples, according; to the ""learning by doing"" principle. Also because of this reason, this guide; cannot cover all the complexity of the ROOT package. Nevertheless, once you feel; confident with the concepts presented in the following chapters, you will be; able to appre",MatchSource.DOCS,documentation/primer/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md:288,Integrability,depend,depends,288,"# Motivation and Introduction #. ***Welcome to data analysis!***. Comparison of measurements to theoretical models is one of the standard; tasks in experimental physics. In the most simple case, a ""model"" is; just a function providing predictions of measured data. Very often, the; model depends on parameters. Such a model may simply state ""the current; *I* is proportional to the voltage *U*"", and the task of the; experimentalist consists of determining the resistance, *R*, from a set; of measurements. As a first step, a visualisation of the data is needed. Next, some; manipulations typically have to be applied, e.g. corrections or; parameter transformations. Quite often, these manipulations are complex; ones, and a powerful library of mathematical functions and procedures; should be provided - think for example of an integral or peak-search or; a Fourier transformation applied to an input spectrum to obtain the; actual measurement described by the model. One specialty of experimental physics are the inevitable uncertainties; affecting each measurement, and visualisation tools have to include; these. In subsequent analysis, the statistical nature of the errors must; be handled properly. As the last step, measurements are compared to models, and free model; parameters need to be determined in this process. See Figure [1.1](#f11) for an; example of a function (model) fit to data points. Several standard methods are; available, and a data analysis tool should provide easy access to more; than one of them. Means to quantify the level of agreement between; measurements and model must also be available.; <!--; [f11]: figures/examplefit.png ""f11""; <a name=""f11""></a>. ![Measured data points with error bars and fitted quadratic; function.\label{f11}][f11]-->. Quite often, the data volume to be analyzed is large - think of; fine-granular measurements accumulated with the aid of computers. A; usable tool therefore must contain easy-to-use and efficient methods for; storing and h",MatchSource.DOCS,documentation/primer/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md:2125,Integrability,depend,depending,2125,"rs must; be handled properly. As the last step, measurements are compared to models, and free model; parameters need to be determined in this process. See Figure [1.1](#f11) for an; example of a function (model) fit to data points. Several standard methods are; available, and a data analysis tool should provide easy access to more; than one of them. Means to quantify the level of agreement between; measurements and model must also be available.; <!--; [f11]: figures/examplefit.png ""f11""; <a name=""f11""></a>. ![Measured data points with error bars and fitted quadratic; function.\label{f11}][f11]-->. Quite often, the data volume to be analyzed is large - think of; fine-granular measurements accumulated with the aid of computers. A; usable tool therefore must contain easy-to-use and efficient methods for; storing and handling data. In Quantum mechanics, models typically only predict the probability; density function (""pdf"") of measurements depending on a number of; parameters, and the aim of the experimental analysis is to extract the; parameters from the observed distribution of frequencies at which; certain values of the measurement are observed. Measurements of this; kind require means to generate and visualize frequency distributions,; so-called histograms, and stringent statistical treatment to extract the; model parameters from purely statistical distributions. Simulation of expected data is another important aspect in data; analysis. By repeated generation of ""pseudo-data"", which are analysed in; the same manner as intended for the real data, analysis procedures can; be validated or compared. In many cases, the distribution of the; measurement errors is not precisely known, and simulation offers the; possibility to test the effects of different assumptions. A powerful software framework addressing all of the above requirements; is ROOT, an open source project coordinated by the European Organisation for; Nuclear Research, CERN in Geneva. ROOT is very flexible and ",MatchSource.DOCS,documentation/primer/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md:3204,Integrability,interface,interface,3204,"ameters from the observed distribution of frequencies at which; certain values of the measurement are observed. Measurements of this; kind require means to generate and visualize frequency distributions,; so-called histograms, and stringent statistical treatment to extract the; model parameters from purely statistical distributions. Simulation of expected data is another important aspect in data; analysis. By repeated generation of ""pseudo-data"", which are analysed in; the same manner as intended for the real data, analysis procedures can; be validated or compared. In many cases, the distribution of the; measurement errors is not precisely known, and simulation offers the; possibility to test the effects of different assumptions. A powerful software framework addressing all of the above requirements; is ROOT, an open source project coordinated by the European Organisation for; Nuclear Research, CERN in Geneva. ROOT is very flexible and provides both a programming interface to use in own; applications and a graphical user interface for interactive data analysis. The; purpose of this document is to serve as a beginners guide and provides extendable; examples for your own use cases, based on typical problems addressed in; student labs. This guide will hopefully lay the ground for more complex; applications in your future scientific work building on a modern,; state-of the art tool for data analysis. This guide in form of a tutorial is intended to introduce you quickly to the; ROOT package. This goal will be accomplished using concrete examples, according; to the ""learning by doing"" principle. Also because of this reason, this guide; cannot cover all the complexity of the ROOT package. Nevertheless, once you feel; confident with the concepts presented in the following chapters, you will be; able to appreciate the ROOT Users Guide [@ROOT_Users_Guide] and navigate through; the Class Reference [@ROOT_Class_Reference] to find all the details you might be; interested in. You",MatchSource.DOCS,documentation/primer/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md:3263,Integrability,interface,interface,3263,"ameters from the observed distribution of frequencies at which; certain values of the measurement are observed. Measurements of this; kind require means to generate and visualize frequency distributions,; so-called histograms, and stringent statistical treatment to extract the; model parameters from purely statistical distributions. Simulation of expected data is another important aspect in data; analysis. By repeated generation of ""pseudo-data"", which are analysed in; the same manner as intended for the real data, analysis procedures can; be validated or compared. In many cases, the distribution of the; measurement errors is not precisely known, and simulation offers the; possibility to test the effects of different assumptions. A powerful software framework addressing all of the above requirements; is ROOT, an open source project coordinated by the European Organisation for; Nuclear Research, CERN in Geneva. ROOT is very flexible and provides both a programming interface to use in own; applications and a graphical user interface for interactive data analysis. The; purpose of this document is to serve as a beginners guide and provides extendable; examples for your own use cases, based on typical problems addressed in; student labs. This guide will hopefully lay the ground for more complex; applications in your future scientific work building on a modern,; state-of the art tool for data analysis. This guide in form of a tutorial is intended to introduce you quickly to the; ROOT package. This goal will be accomplished using concrete examples, according; to the ""learning by doing"" principle. Also because of this reason, this guide; cannot cover all the complexity of the ROOT package. Nevertheless, once you feel; confident with the concepts presented in the following chapters, you will be; able to appreciate the ROOT Users Guide [@ROOT_Users_Guide] and navigate through; the Class Reference [@ROOT_Class_Reference] to find all the details you might be; interested in. You",MatchSource.DOCS,documentation/primer/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md:3163,Modifiability,flexible,flexible,3163,"ameters from the observed distribution of frequencies at which; certain values of the measurement are observed. Measurements of this; kind require means to generate and visualize frequency distributions,; so-called histograms, and stringent statistical treatment to extract the; model parameters from purely statistical distributions. Simulation of expected data is another important aspect in data; analysis. By repeated generation of ""pseudo-data"", which are analysed in; the same manner as intended for the real data, analysis procedures can; be validated or compared. In many cases, the distribution of the; measurement errors is not precisely known, and simulation offers the; possibility to test the effects of different assumptions. A powerful software framework addressing all of the above requirements; is ROOT, an open source project coordinated by the European Organisation for; Nuclear Research, CERN in Geneva. ROOT is very flexible and provides both a programming interface to use in own; applications and a graphical user interface for interactive data analysis. The; purpose of this document is to serve as a beginners guide and provides extendable; examples for your own use cases, based on typical problems addressed in; student labs. This guide will hopefully lay the ground for more complex; applications in your future scientific work building on a modern,; state-of the art tool for data analysis. This guide in form of a tutorial is intended to introduce you quickly to the; ROOT package. This goal will be accomplished using concrete examples, according; to the ""learning by doing"" principle. Also because of this reason, this guide; cannot cover all the complexity of the ROOT package. Nevertheless, once you feel; confident with the concepts presented in the following chapters, you will be; able to appreciate the ROOT Users Guide [@ROOT_Users_Guide] and navigate through; the Class Reference [@ROOT_Class_Reference] to find all the details you might be; interested in. You",MatchSource.DOCS,documentation/primer/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md:3380,Modifiability,extend,extendable,3380," and visualize frequency distributions,; so-called histograms, and stringent statistical treatment to extract the; model parameters from purely statistical distributions. Simulation of expected data is another important aspect in data; analysis. By repeated generation of ""pseudo-data"", which are analysed in; the same manner as intended for the real data, analysis procedures can; be validated or compared. In many cases, the distribution of the; measurement errors is not precisely known, and simulation offers the; possibility to test the effects of different assumptions. A powerful software framework addressing all of the above requirements; is ROOT, an open source project coordinated by the European Organisation for; Nuclear Research, CERN in Geneva. ROOT is very flexible and provides both a programming interface to use in own; applications and a graphical user interface for interactive data analysis. The; purpose of this document is to serve as a beginners guide and provides extendable; examples for your own use cases, based on typical problems addressed in; student labs. This guide will hopefully lay the ground for more complex; applications in your future scientific work building on a modern,; state-of the art tool for data analysis. This guide in form of a tutorial is intended to introduce you quickly to the; ROOT package. This goal will be accomplished using concrete examples, according; to the ""learning by doing"" principle. Also because of this reason, this guide; cannot cover all the complexity of the ROOT package. Nevertheless, once you feel; confident with the concepts presented in the following chapters, you will be; able to appreciate the ROOT Users Guide [@ROOT_Users_Guide] and navigate through; the Class Reference [@ROOT_Class_Reference] to find all the details you might be; interested in. You can even look at the code itself, since ROOT is a; free, open-source product. Use these documents in parallel to this; tutorial!. The ROOT Data Analysis Framework i",MatchSource.DOCS,documentation/primer/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md:235,Safety,predict,predictions,235,"# Motivation and Introduction #. ***Welcome to data analysis!***. Comparison of measurements to theoretical models is one of the standard; tasks in experimental physics. In the most simple case, a ""model"" is; just a function providing predictions of measured data. Very often, the; model depends on parameters. Such a model may simply state ""the current; *I* is proportional to the voltage *U*"", and the task of the; experimentalist consists of determining the resistance, *R*, from a set; of measurements. As a first step, a visualisation of the data is needed. Next, some; manipulations typically have to be applied, e.g. corrections or; parameter transformations. Quite often, these manipulations are complex; ones, and a powerful library of mathematical functions and procedures; should be provided - think for example of an integral or peak-search or; a Fourier transformation applied to an input spectrum to obtain the; actual measurement described by the model. One specialty of experimental physics are the inevitable uncertainties; affecting each measurement, and visualisation tools have to include; these. In subsequent analysis, the statistical nature of the errors must; be handled properly. As the last step, measurements are compared to models, and free model; parameters need to be determined in this process. See Figure [1.1](#f11) for an; example of a function (model) fit to data points. Several standard methods are; available, and a data analysis tool should provide easy access to more; than one of them. Means to quantify the level of agreement between; measurements and model must also be available.; <!--; [f11]: figures/examplefit.png ""f11""; <a name=""f11""></a>. ![Measured data points with error bars and fitted quadratic; function.\label{f11}][f11]-->. Quite often, the data volume to be analyzed is large - think of; fine-granular measurements accumulated with the aid of computers. A; usable tool therefore must contain easy-to-use and efficient methods for; storing and h",MatchSource.DOCS,documentation/primer/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md:2059,Safety,predict,predict,2059,"rs must; be handled properly. As the last step, measurements are compared to models, and free model; parameters need to be determined in this process. See Figure [1.1](#f11) for an; example of a function (model) fit to data points. Several standard methods are; available, and a data analysis tool should provide easy access to more; than one of them. Means to quantify the level of agreement between; measurements and model must also be available.; <!--; [f11]: figures/examplefit.png ""f11""; <a name=""f11""></a>. ![Measured data points with error bars and fitted quadratic; function.\label{f11}][f11]-->. Quite often, the data volume to be analyzed is large - think of; fine-granular measurements accumulated with the aid of computers. A; usable tool therefore must contain easy-to-use and efficient methods for; storing and handling data. In Quantum mechanics, models typically only predict the probability; density function (""pdf"") of measurements depending on a number of; parameters, and the aim of the experimental analysis is to extract the; parameters from the observed distribution of frequencies at which; certain values of the measurement are observed. Measurements of this; kind require means to generate and visualize frequency distributions,; so-called histograms, and stringent statistical treatment to extract the; model parameters from purely statistical distributions. Simulation of expected data is another important aspect in data; analysis. By repeated generation of ""pseudo-data"", which are analysed in; the same manner as intended for the real data, analysis procedures can; be validated or compared. In many cases, the distribution of the; measurement errors is not precisely known, and simulation offers the; possibility to test the effects of different assumptions. A powerful software framework addressing all of the above requirements; is ROOT, an open source project coordinated by the European Organisation for; Nuclear Research, CERN in Geneva. ROOT is very flexible and ",MatchSource.DOCS,documentation/primer/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md:1493,Security,access,access,1493,"tance, *R*, from a set; of measurements. As a first step, a visualisation of the data is needed. Next, some; manipulations typically have to be applied, e.g. corrections or; parameter transformations. Quite often, these manipulations are complex; ones, and a powerful library of mathematical functions and procedures; should be provided - think for example of an integral or peak-search or; a Fourier transformation applied to an input spectrum to obtain the; actual measurement described by the model. One specialty of experimental physics are the inevitable uncertainties; affecting each measurement, and visualisation tools have to include; these. In subsequent analysis, the statistical nature of the errors must; be handled properly. As the last step, measurements are compared to models, and free model; parameters need to be determined in this process. See Figure [1.1](#f11) for an; example of a function (model) fit to data points. Several standard methods are; available, and a data analysis tool should provide easy access to more; than one of them. Means to quantify the level of agreement between; measurements and model must also be available.; <!--; [f11]: figures/examplefit.png ""f11""; <a name=""f11""></a>. ![Measured data points with error bars and fitted quadratic; function.\label{f11}][f11]-->. Quite often, the data volume to be analyzed is large - think of; fine-granular measurements accumulated with the aid of computers. A; usable tool therefore must contain easy-to-use and efficient methods for; storing and handling data. In Quantum mechanics, models typically only predict the probability; density function (""pdf"") of measurements depending on a number of; parameters, and the aim of the experimental analysis is to extract the; parameters from the observed distribution of frequencies at which; certain values of the measurement are observed. Measurements of this; kind require means to generate and visualize frequency distributions,; so-called histograms, and stringent",MatchSource.DOCS,documentation/primer/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md:2775,Security,validat,validated,2775,"error bars and fitted quadratic; function.\label{f11}][f11]-->. Quite often, the data volume to be analyzed is large - think of; fine-granular measurements accumulated with the aid of computers. A; usable tool therefore must contain easy-to-use and efficient methods for; storing and handling data. In Quantum mechanics, models typically only predict the probability; density function (""pdf"") of measurements depending on a number of; parameters, and the aim of the experimental analysis is to extract the; parameters from the observed distribution of frequencies at which; certain values of the measurement are observed. Measurements of this; kind require means to generate and visualize frequency distributions,; so-called histograms, and stringent statistical treatment to extract the; model parameters from purely statistical distributions. Simulation of expected data is another important aspect in data; analysis. By repeated generation of ""pseudo-data"", which are analysed in; the same manner as intended for the real data, analysis procedures can; be validated or compared. In many cases, the distribution of the; measurement errors is not precisely known, and simulation offers the; possibility to test the effects of different assumptions. A powerful software framework addressing all of the above requirements; is ROOT, an open source project coordinated by the European Organisation for; Nuclear Research, CERN in Geneva. ROOT is very flexible and provides both a programming interface to use in own; applications and a graphical user interface for interactive data analysis. The; purpose of this document is to serve as a beginners guide and provides extendable; examples for your own use cases, based on typical problems addressed in; student labs. This guide will hopefully lay the ground for more complex; applications in your future scientific work building on a modern,; state-of the art tool for data analysis. This guide in form of a tutorial is intended to introduce you quickly ",MatchSource.DOCS,documentation/primer/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md:2923,Testability,test,test,2923,"ed with the aid of computers. A; usable tool therefore must contain easy-to-use and efficient methods for; storing and handling data. In Quantum mechanics, models typically only predict the probability; density function (""pdf"") of measurements depending on a number of; parameters, and the aim of the experimental analysis is to extract the; parameters from the observed distribution of frequencies at which; certain values of the measurement are observed. Measurements of this; kind require means to generate and visualize frequency distributions,; so-called histograms, and stringent statistical treatment to extract the; model parameters from purely statistical distributions. Simulation of expected data is another important aspect in data; analysis. By repeated generation of ""pseudo-data"", which are analysed in; the same manner as intended for the real data, analysis procedures can; be validated or compared. In many cases, the distribution of the; measurement errors is not precisely known, and simulation offers the; possibility to test the effects of different assumptions. A powerful software framework addressing all of the above requirements; is ROOT, an open source project coordinated by the European Organisation for; Nuclear Research, CERN in Geneva. ROOT is very flexible and provides both a programming interface to use in own; applications and a graphical user interface for interactive data analysis. The; purpose of this document is to serve as a beginners guide and provides extendable; examples for your own use cases, based on typical problems addressed in; student labs. This guide will hopefully lay the ground for more complex; applications in your future scientific work building on a modern,; state-of the art tool for data analysis. This guide in form of a tutorial is intended to introduce you quickly to the; ROOT package. This goal will be accomplished using concrete examples, according; to the ""learning by doing"" principle. Also because of this reason, this guid",MatchSource.DOCS,documentation/primer/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md:182,Usability,simpl,simple,182,"# Motivation and Introduction #. ***Welcome to data analysis!***. Comparison of measurements to theoretical models is one of the standard; tasks in experimental physics. In the most simple case, a ""model"" is; just a function providing predictions of measured data. Very often, the; model depends on parameters. Such a model may simply state ""the current; *I* is proportional to the voltage *U*"", and the task of the; experimentalist consists of determining the resistance, *R*, from a set; of measurements. As a first step, a visualisation of the data is needed. Next, some; manipulations typically have to be applied, e.g. corrections or; parameter transformations. Quite often, these manipulations are complex; ones, and a powerful library of mathematical functions and procedures; should be provided - think for example of an integral or peak-search or; a Fourier transformation applied to an input spectrum to obtain the; actual measurement described by the model. One specialty of experimental physics are the inevitable uncertainties; affecting each measurement, and visualisation tools have to include; these. In subsequent analysis, the statistical nature of the errors must; be handled properly. As the last step, measurements are compared to models, and free model; parameters need to be determined in this process. See Figure [1.1](#f11) for an; example of a function (model) fit to data points. Several standard methods are; available, and a data analysis tool should provide easy access to more; than one of them. Means to quantify the level of agreement between; measurements and model must also be available.; <!--; [f11]: figures/examplefit.png ""f11""; <a name=""f11""></a>. ![Measured data points with error bars and fitted quadratic; function.\label{f11}][f11]-->. Quite often, the data volume to be analyzed is large - think of; fine-granular measurements accumulated with the aid of computers. A; usable tool therefore must contain easy-to-use and efficient methods for; storing and h",MatchSource.DOCS,documentation/primer/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md:328,Usability,simpl,simply,328,"# Motivation and Introduction #. ***Welcome to data analysis!***. Comparison of measurements to theoretical models is one of the standard; tasks in experimental physics. In the most simple case, a ""model"" is; just a function providing predictions of measured data. Very often, the; model depends on parameters. Such a model may simply state ""the current; *I* is proportional to the voltage *U*"", and the task of the; experimentalist consists of determining the resistance, *R*, from a set; of measurements. As a first step, a visualisation of the data is needed. Next, some; manipulations typically have to be applied, e.g. corrections or; parameter transformations. Quite often, these manipulations are complex; ones, and a powerful library of mathematical functions and procedures; should be provided - think for example of an integral or peak-search or; a Fourier transformation applied to an input spectrum to obtain the; actual measurement described by the model. One specialty of experimental physics are the inevitable uncertainties; affecting each measurement, and visualisation tools have to include; these. In subsequent analysis, the statistical nature of the errors must; be handled properly. As the last step, measurements are compared to models, and free model; parameters need to be determined in this process. See Figure [1.1](#f11) for an; example of a function (model) fit to data points. Several standard methods are; available, and a data analysis tool should provide easy access to more; than one of them. Means to quantify the level of agreement between; measurements and model must also be available.; <!--; [f11]: figures/examplefit.png ""f11""; <a name=""f11""></a>. ![Measured data points with error bars and fitted quadratic; function.\label{f11}][f11]-->. Quite often, the data volume to be analyzed is large - think of; fine-granular measurements accumulated with the aid of computers. A; usable tool therefore must contain easy-to-use and efficient methods for; storing and h",MatchSource.DOCS,documentation/primer/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md:1914,Usability,usab,usable,1914,"model. One specialty of experimental physics are the inevitable uncertainties; affecting each measurement, and visualisation tools have to include; these. In subsequent analysis, the statistical nature of the errors must; be handled properly. As the last step, measurements are compared to models, and free model; parameters need to be determined in this process. See Figure [1.1](#f11) for an; example of a function (model) fit to data points. Several standard methods are; available, and a data analysis tool should provide easy access to more; than one of them. Means to quantify the level of agreement between; measurements and model must also be available.; <!--; [f11]: figures/examplefit.png ""f11""; <a name=""f11""></a>. ![Measured data points with error bars and fitted quadratic; function.\label{f11}][f11]-->. Quite often, the data volume to be analyzed is large - think of; fine-granular measurements accumulated with the aid of computers. A; usable tool therefore must contain easy-to-use and efficient methods for; storing and handling data. In Quantum mechanics, models typically only predict the probability; density function (""pdf"") of measurements depending on a number of; parameters, and the aim of the experimental analysis is to extract the; parameters from the observed distribution of frequencies at which; certain values of the measurement are observed. Measurements of this; kind require means to generate and visualize frequency distributions,; so-called histograms, and stringent statistical treatment to extract the; model parameters from purely statistical distributions. Simulation of expected data is another important aspect in data; analysis. By repeated generation of ""pseudo-data"", which are analysed in; the same manner as intended for the real data, analysis procedures can; be validated or compared. In many cases, the distribution of the; measurement errors is not precisely known, and simulation offers the; possibility to test the effects of different assumptio",MatchSource.DOCS,documentation/primer/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md:3361,Usability,guid,guide,3361," and visualize frequency distributions,; so-called histograms, and stringent statistical treatment to extract the; model parameters from purely statistical distributions. Simulation of expected data is another important aspect in data; analysis. By repeated generation of ""pseudo-data"", which are analysed in; the same manner as intended for the real data, analysis procedures can; be validated or compared. In many cases, the distribution of the; measurement errors is not precisely known, and simulation offers the; possibility to test the effects of different assumptions. A powerful software framework addressing all of the above requirements; is ROOT, an open source project coordinated by the European Organisation for; Nuclear Research, CERN in Geneva. ROOT is very flexible and provides both a programming interface to use in own; applications and a graphical user interface for interactive data analysis. The; purpose of this document is to serve as a beginners guide and provides extendable; examples for your own use cases, based on typical problems addressed in; student labs. This guide will hopefully lay the ground for more complex; applications in your future scientific work building on a modern,; state-of the art tool for data analysis. This guide in form of a tutorial is intended to introduce you quickly to the; ROOT package. This goal will be accomplished using concrete examples, according; to the ""learning by doing"" principle. Also because of this reason, this guide; cannot cover all the complexity of the ROOT package. Nevertheless, once you feel; confident with the concepts presented in the following chapters, you will be; able to appreciate the ROOT Users Guide [@ROOT_Users_Guide] and navigate through; the Class Reference [@ROOT_Class_Reference] to find all the details you might be; interested in. You can even look at the code itself, since ROOT is a; free, open-source product. Use these documents in parallel to this; tutorial!. The ROOT Data Analysis Framework i",MatchSource.DOCS,documentation/primer/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md:3484,Usability,guid,guide,3484,"Simulation of expected data is another important aspect in data; analysis. By repeated generation of ""pseudo-data"", which are analysed in; the same manner as intended for the real data, analysis procedures can; be validated or compared. In many cases, the distribution of the; measurement errors is not precisely known, and simulation offers the; possibility to test the effects of different assumptions. A powerful software framework addressing all of the above requirements; is ROOT, an open source project coordinated by the European Organisation for; Nuclear Research, CERN in Geneva. ROOT is very flexible and provides both a programming interface to use in own; applications and a graphical user interface for interactive data analysis. The; purpose of this document is to serve as a beginners guide and provides extendable; examples for your own use cases, based on typical problems addressed in; student labs. This guide will hopefully lay the ground for more complex; applications in your future scientific work building on a modern,; state-of the art tool for data analysis. This guide in form of a tutorial is intended to introduce you quickly to the; ROOT package. This goal will be accomplished using concrete examples, according; to the ""learning by doing"" principle. Also because of this reason, this guide; cannot cover all the complexity of the ROOT package. Nevertheless, once you feel; confident with the concepts presented in the following chapters, you will be; able to appreciate the ROOT Users Guide [@ROOT_Users_Guide] and navigate through; the Class Reference [@ROOT_Class_Reference] to find all the details you might be; interested in. You can even look at the code itself, since ROOT is a; free, open-source product. Use these documents in parallel to this; tutorial!. The ROOT Data Analysis Framework itself is written in and heavily relies; on the `C++` programming language: some knowledge about `C++` is required.; Jus take advantage from the immense available literatur",MatchSource.DOCS,documentation/primer/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md:3651,Usability,guid,guide,3651,"ysed in; the same manner as intended for the real data, analysis procedures can; be validated or compared. In many cases, the distribution of the; measurement errors is not precisely known, and simulation offers the; possibility to test the effects of different assumptions. A powerful software framework addressing all of the above requirements; is ROOT, an open source project coordinated by the European Organisation for; Nuclear Research, CERN in Geneva. ROOT is very flexible and provides both a programming interface to use in own; applications and a graphical user interface for interactive data analysis. The; purpose of this document is to serve as a beginners guide and provides extendable; examples for your own use cases, based on typical problems addressed in; student labs. This guide will hopefully lay the ground for more complex; applications in your future scientific work building on a modern,; state-of the art tool for data analysis. This guide in form of a tutorial is intended to introduce you quickly to the; ROOT package. This goal will be accomplished using concrete examples, according; to the ""learning by doing"" principle. Also because of this reason, this guide; cannot cover all the complexity of the ROOT package. Nevertheless, once you feel; confident with the concepts presented in the following chapters, you will be; able to appreciate the ROOT Users Guide [@ROOT_Users_Guide] and navigate through; the Class Reference [@ROOT_Class_Reference] to find all the details you might be; interested in. You can even look at the code itself, since ROOT is a; free, open-source product. Use these documents in parallel to this; tutorial!. The ROOT Data Analysis Framework itself is written in and heavily relies; on the `C++` programming language: some knowledge about `C++` is required.; Jus take advantage from the immense available literature about `C++` if you do; not have any idea of what this language is about. ROOT is available for many platforms (Linux, Mac OS X,",MatchSource.DOCS,documentation/primer/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md:3813,Usability,learn,learning,3813,"ompared. In many cases, the distribution of the; measurement errors is not precisely known, and simulation offers the; possibility to test the effects of different assumptions. A powerful software framework addressing all of the above requirements; is ROOT, an open source project coordinated by the European Organisation for; Nuclear Research, CERN in Geneva. ROOT is very flexible and provides both a programming interface to use in own; applications and a graphical user interface for interactive data analysis. The; purpose of this document is to serve as a beginners guide and provides extendable; examples for your own use cases, based on typical problems addressed in; student labs. This guide will hopefully lay the ground for more complex; applications in your future scientific work building on a modern,; state-of the art tool for data analysis. This guide in form of a tutorial is intended to introduce you quickly to the; ROOT package. This goal will be accomplished using concrete examples, according; to the ""learning by doing"" principle. Also because of this reason, this guide; cannot cover all the complexity of the ROOT package. Nevertheless, once you feel; confident with the concepts presented in the following chapters, you will be; able to appreciate the ROOT Users Guide [@ROOT_Users_Guide] and navigate through; the Class Reference [@ROOT_Class_Reference] to find all the details you might be; interested in. You can even look at the code itself, since ROOT is a; free, open-source product. Use these documents in parallel to this; tutorial!. The ROOT Data Analysis Framework itself is written in and heavily relies; on the `C++` programming language: some knowledge about `C++` is required.; Jus take advantage from the immense available literature about `C++` if you do; not have any idea of what this language is about. ROOT is available for many platforms (Linux, Mac OS X, Windows...), but; in this guide we will implicitly assume that you are using Linux. The; first thi",MatchSource.DOCS,documentation/primer/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md:3877,Usability,guid,guide,3877,"lation offers the; possibility to test the effects of different assumptions. A powerful software framework addressing all of the above requirements; is ROOT, an open source project coordinated by the European Organisation for; Nuclear Research, CERN in Geneva. ROOT is very flexible and provides both a programming interface to use in own; applications and a graphical user interface for interactive data analysis. The; purpose of this document is to serve as a beginners guide and provides extendable; examples for your own use cases, based on typical problems addressed in; student labs. This guide will hopefully lay the ground for more complex; applications in your future scientific work building on a modern,; state-of the art tool for data analysis. This guide in form of a tutorial is intended to introduce you quickly to the; ROOT package. This goal will be accomplished using concrete examples, according; to the ""learning by doing"" principle. Also because of this reason, this guide; cannot cover all the complexity of the ROOT package. Nevertheless, once you feel; confident with the concepts presented in the following chapters, you will be; able to appreciate the ROOT Users Guide [@ROOT_Users_Guide] and navigate through; the Class Reference [@ROOT_Class_Reference] to find all the details you might be; interested in. You can even look at the code itself, since ROOT is a; free, open-source product. Use these documents in parallel to this; tutorial!. The ROOT Data Analysis Framework itself is written in and heavily relies; on the `C++` programming language: some knowledge about `C++` is required.; Jus take advantage from the immense available literature about `C++` if you do; not have any idea of what this language is about. ROOT is available for many platforms (Linux, Mac OS X, Windows...), but; in this guide we will implicitly assume that you are using Linux. The; first thing you need to do with ROOT is install it, don't you ? Obtaining; the latest ROOT version is straig",MatchSource.DOCS,documentation/primer/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md:4718,Usability,guid,guide,4718,"interface to use in own; applications and a graphical user interface for interactive data analysis. The; purpose of this document is to serve as a beginners guide and provides extendable; examples for your own use cases, based on typical problems addressed in; student labs. This guide will hopefully lay the ground for more complex; applications in your future scientific work building on a modern,; state-of the art tool for data analysis. This guide in form of a tutorial is intended to introduce you quickly to the; ROOT package. This goal will be accomplished using concrete examples, according; to the ""learning by doing"" principle. Also because of this reason, this guide; cannot cover all the complexity of the ROOT package. Nevertheless, once you feel; confident with the concepts presented in the following chapters, you will be; able to appreciate the ROOT Users Guide [@ROOT_Users_Guide] and navigate through; the Class Reference [@ROOT_Class_Reference] to find all the details you might be; interested in. You can even look at the code itself, since ROOT is a; free, open-source product. Use these documents in parallel to this; tutorial!. The ROOT Data Analysis Framework itself is written in and heavily relies; on the `C++` programming language: some knowledge about `C++` is required.; Jus take advantage from the immense available literature about `C++` if you do; not have any idea of what this language is about. ROOT is available for many platforms (Linux, Mac OS X, Windows...), but; in this guide we will implicitly assume that you are using Linux. The; first thing you need to do with ROOT is install it, don't you ? Obtaining; the latest ROOT version is straightforward. Just seek the ""Pro"" version; on this webpage <http://root.cern.ch/downloading-root>.; You will find precompiled versions for the different architectures, or; the ROOT source code to compile yourself. Just pick up the flavour you; need and follow the installation instructions. **Let's dive into ROOT!**; ",MatchSource.DOCS,documentation/primer/Introduction.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOTPrimer.md:27,Testability,log,logo,27,% ROOT Primer: ![](figures/logo.png); %; % May 2015. ,MatchSource.DOCS,documentation/primer/ROOTPrimer.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOTPrimer.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md:4874,Availability,down,download,4874,"; function with parameters, called `[0]`, `[1]` and so on in the ROOT; formula syntax. We now need a way to assign values to these parameters;; this is achieved with the method; `SetParameter(<parameter_number>,<parameter_value>)` of class `TF1`.; Here is an example:. ``` {.cpp}; root [13] TF1 f2(""f2"",""[0]*sin([1]*x)/x"",0.,10.);; root [14] f2.SetParameter(0,1);; root [15] f2.SetParameter(1,1);; root [16] f2.Draw();; ```. Of course, this version shows the same results as the initial one. Try; playing with the parameters and plot the function again. The class `TF1`; has a large number of very useful methods, including integration and; differentiation. To make full use of this and other ROOT classes, visit; the documentation on the Internet under; <https://root.cern/doc/master/>. Formulae in ROOT; are evaluated using the class `TFormula`, so also look up the relevant; class documentation for examples, implemented functions and syntax. You should definitely download this guide to your own system to have it; at you disposal whenever you need it. To extend a little bit on the above example, consider a more complex; function you would like to define. You can also do this using standard; `C` or `C++` code. Consider the example below, which calculates and displays the; interference pattern produced by light falling on a multiple slit.; Please do not type in the example below at the ROOT command line, there; is a much simpler way: Make sure you have the file `slits.C` on disk,; and type `root slits.C` in the shell. This will start root and make it; read the ""macro"" `slits.C`, i.e. all the lines in the file will be; executed one after the other. ``` {.cpp .numberLines}; @ROOT_INCLUDE_FILE macros/slits.C; ```; [f21]: figures/TF1_DoubleSlit.png ""f21""; <a name=""f21""></a>. ![Output of slits.C with parameters 0.2 and 2.\label{f21}][f21]. The example first asks for user input, namely the ratio of slit width; over slit distance, and the number of slits. After entering this; informatio",MatchSource.DOCS,documentation/primer/ROOT_as_calculator.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md:8466,Availability,avail,available,8466,"ot natively an interpreted; language! There is much more to say: chapter is indeed dedicated to; macros. ## Controlling ROOT ##. One more remark at this point: as every command you type into ROOT is; usually interpreted by Cling, an ""escape character"" is needed to pass; commands to ROOT directly. This character is the dot at the beginning of; a line:. ``` {.cpp}; root [1] .<command>; ```. This is a selection of the most common commands. - **quit root**, simply type `.q` or `.quit` or `.exit`. - obtain the full **list of commands**, use `.?` or `.help`. - **access the shell** of the operating system, type `.!<OS_command>`;; try, e.g. `.!ls` or `.!pwd`. - **execute a macro**, enter `.x <file_name>`; in the above example,; you might have used `.x slits.C` at the ROOT prompt. - **load a macro**, type `.L <file_name>`; in the above example, you; might instead have used the command `.L slits.C` followed by the; function call `slits();`. Note that after loading a macro all; functions and procedures defined therein are available at the ROOT; prompt. - **compile a macro**, type `.L <file_name>+`; ROOT is able to manage; for you the `C++` compiler behind the scenes and to produce machine; code starting from your macro. One could decide to compile a macro; in order to obtain better performance or to get nearer to the; production environment. ## Plotting Measurements ##. To display measurements in ROOT, including errors, there exists a; powerful class `TGraphErrors` with different types of constructors. In; the example here, we use data from the file `ExampleData.txt` in text; format:. ``` {.cpp}; root [0] TGraphErrors gr(""ExampleData.txt"");; root [1] gr.Draw(""AP"");; ```. You should see the output shown in Figure [2.2](#f22). [f22]: figures/TGraphErrors_Example.png ""f22""; <a name=""f22""></a>. ![Visualisation of data points with errors using the class TGraphErrors. \label{f22}][f22]. Make sure the file `ExampleData.txt` is available in the directory from; which you started ROOT. I",MatchSource.DOCS,documentation/primer/ROOT_as_calculator.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md:8864,Availability,error,errors,8864,"t root**, simply type `.q` or `.quit` or `.exit`. - obtain the full **list of commands**, use `.?` or `.help`. - **access the shell** of the operating system, type `.!<OS_command>`;; try, e.g. `.!ls` or `.!pwd`. - **execute a macro**, enter `.x <file_name>`; in the above example,; you might have used `.x slits.C` at the ROOT prompt. - **load a macro**, type `.L <file_name>`; in the above example, you; might instead have used the command `.L slits.C` followed by the; function call `slits();`. Note that after loading a macro all; functions and procedures defined therein are available at the ROOT; prompt. - **compile a macro**, type `.L <file_name>+`; ROOT is able to manage; for you the `C++` compiler behind the scenes and to produce machine; code starting from your macro. One could decide to compile a macro; in order to obtain better performance or to get nearer to the; production environment. ## Plotting Measurements ##. To display measurements in ROOT, including errors, there exists a; powerful class `TGraphErrors` with different types of constructors. In; the example here, we use data from the file `ExampleData.txt` in text; format:. ``` {.cpp}; root [0] TGraphErrors gr(""ExampleData.txt"");; root [1] gr.Draw(""AP"");; ```. You should see the output shown in Figure [2.2](#f22). [f22]: figures/TGraphErrors_Example.png ""f22""; <a name=""f22""></a>. ![Visualisation of data points with errors using the class TGraphErrors. \label{f22}][f22]. Make sure the file `ExampleData.txt` is available in the directory from; which you started ROOT. Inspect this file now with your favourite; editor, or use the command `less ExampleData.txt` to inspect the file,; you will see that the format is very simple and easy to understand.; Lines beginning with `#` are ignored. It is very convenient to add some; comments about the type of data. The data itself consist of lines with; four real numbers each, representing the x- and y- coordinates and their; errors of each data point. The argument of the",MatchSource.DOCS,documentation/primer/ROOT_as_calculator.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md:9286,Availability,error,errors,9286,", you; might instead have used the command `.L slits.C` followed by the; function call `slits();`. Note that after loading a macro all; functions and procedures defined therein are available at the ROOT; prompt. - **compile a macro**, type `.L <file_name>+`; ROOT is able to manage; for you the `C++` compiler behind the scenes and to produce machine; code starting from your macro. One could decide to compile a macro; in order to obtain better performance or to get nearer to the; production environment. ## Plotting Measurements ##. To display measurements in ROOT, including errors, there exists a; powerful class `TGraphErrors` with different types of constructors. In; the example here, we use data from the file `ExampleData.txt` in text; format:. ``` {.cpp}; root [0] TGraphErrors gr(""ExampleData.txt"");; root [1] gr.Draw(""AP"");; ```. You should see the output shown in Figure [2.2](#f22). [f22]: figures/TGraphErrors_Example.png ""f22""; <a name=""f22""></a>. ![Visualisation of data points with errors using the class TGraphErrors. \label{f22}][f22]. Make sure the file `ExampleData.txt` is available in the directory from; which you started ROOT. Inspect this file now with your favourite; editor, or use the command `less ExampleData.txt` to inspect the file,; you will see that the format is very simple and easy to understand.; Lines beginning with `#` are ignored. It is very convenient to add some; comments about the type of data. The data itself consist of lines with; four real numbers each, representing the x- and y- coordinates and their; errors of each data point. The argument of the method `Draw(""AP"")` is important here. Behind the scenes,; it tells the `TGraphPainter` class to show the axes and to plot markers at the; *x* and *y* positions of the specified data points. Note that this simple; example relies on the default settings of ROOT, concerning the size of; the canvas holding the plot, the marker type and the line colours and; thickness used and so on. In a well-writ",MatchSource.DOCS,documentation/primer/ROOT_as_calculator.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md:9382,Availability,avail,available,9382,"g a macro all; functions and procedures defined therein are available at the ROOT; prompt. - **compile a macro**, type `.L <file_name>+`; ROOT is able to manage; for you the `C++` compiler behind the scenes and to produce machine; code starting from your macro. One could decide to compile a macro; in order to obtain better performance or to get nearer to the; production environment. ## Plotting Measurements ##. To display measurements in ROOT, including errors, there exists a; powerful class `TGraphErrors` with different types of constructors. In; the example here, we use data from the file `ExampleData.txt` in text; format:. ``` {.cpp}; root [0] TGraphErrors gr(""ExampleData.txt"");; root [1] gr.Draw(""AP"");; ```. You should see the output shown in Figure [2.2](#f22). [f22]: figures/TGraphErrors_Example.png ""f22""; <a name=""f22""></a>. ![Visualisation of data points with errors using the class TGraphErrors. \label{f22}][f22]. Make sure the file `ExampleData.txt` is available in the directory from; which you started ROOT. Inspect this file now with your favourite; editor, or use the command `less ExampleData.txt` to inspect the file,; you will see that the format is very simple and easy to understand.; Lines beginning with `#` are ignored. It is very convenient to add some; comments about the type of data. The data itself consist of lines with; four real numbers each, representing the x- and y- coordinates and their; errors of each data point. The argument of the method `Draw(""AP"")` is important here. Behind the scenes,; it tells the `TGraphPainter` class to show the axes and to plot markers at the; *x* and *y* positions of the specified data points. Note that this simple; example relies on the default settings of ROOT, concerning the size of; the canvas holding the plot, the marker type and the line colours and; thickness used and so on. In a well-written, complete example, all this; would need to be specified explicitly in order to obtain nice and well; readable result",MatchSource.DOCS,documentation/primer/ROOT_as_calculator.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md:9842,Availability,error,errors,9842,"tting Measurements ##. To display measurements in ROOT, including errors, there exists a; powerful class `TGraphErrors` with different types of constructors. In; the example here, we use data from the file `ExampleData.txt` in text; format:. ``` {.cpp}; root [0] TGraphErrors gr(""ExampleData.txt"");; root [1] gr.Draw(""AP"");; ```. You should see the output shown in Figure [2.2](#f22). [f22]: figures/TGraphErrors_Example.png ""f22""; <a name=""f22""></a>. ![Visualisation of data points with errors using the class TGraphErrors. \label{f22}][f22]. Make sure the file `ExampleData.txt` is available in the directory from; which you started ROOT. Inspect this file now with your favourite; editor, or use the command `less ExampleData.txt` to inspect the file,; you will see that the format is very simple and easy to understand.; Lines beginning with `#` are ignored. It is very convenient to add some; comments about the type of data. The data itself consist of lines with; four real numbers each, representing the x- and y- coordinates and their; errors of each data point. The argument of the method `Draw(""AP"")` is important here. Behind the scenes,; it tells the `TGraphPainter` class to show the axes and to plot markers at the; *x* and *y* positions of the specified data points. Note that this simple; example relies on the default settings of ROOT, concerning the size of; the canvas holding the plot, the marker type and the line colours and; thickness used and so on. In a well-written, complete example, all this; would need to be specified explicitly in order to obtain nice and well; readable results. A full chapter on graphs will explain many; more of the features of the class `TGraphErrors` and its relation to; other ROOT classes in much more detail. ## Histograms in ROOT ##. Frequency distributions in ROOT are handled by a set of classes derived; from the histogram class `TH1`, in our case `TH1F`. The letter `F`; stands for ""float"", meaning that the data type `float` is used to st",MatchSource.DOCS,documentation/primer/ROOT_as_calculator.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md:13371,Availability,down,down,13371,"es; above, depending on how the random number generator is initialised. The class `TH1F` does not contain a convenient input format from plain; text files. The following lines of `C++` code do the job. One number per; line stored in the text file ""expo.dat"" is read in via an input stream; and filled in the histogram until end of file is reached. ``` {.cpp}; root [1] TH1F h(""h"",""example histogram"",100,0.,5.);; root [2] ifstream inp; double x;; root [3] inp.open(""expo.dat"");; root [4] while (inp >> x) { h.Fill(x); }; root [5] h.Draw();; root [6] inp.close();; ```. Histograms and random numbers are very important tools in statistical; data analysis, a whole chapter will be dedicated to this topic. ## Interactive ROOT ##. Look at one of your plots again and move the mouse across. You will; notice that this is much more than a static picture, as the mouse; pointer changes its shape when touching objects on the plot. When the; mouse is over an object, a right-click opens a pull-down menu displaying; in the top line the name of the ROOT class you are dealing with, e.g.; `TCanvas` for the display window itself, `TFrame` for the frame of the; plot, `TAxis` for the axes, `TPaveText` for the plot name. Depending on; which plot you are investigating, menus for the ROOT classes `TF1`,; `TGraphErrors` or `TH1F` will show up when a right-click is performed on; the respective graphical representations. The menu items allow direct; access to the members of the various classes, and you can even modify; them, e.g. change colour and size of the axis ticks or labels, the; function lines, marker types and so on. Try it!. [f24]: figures/ROOTPanel_SetParameters.png ""f24""; <a name=""f24""></a>. ![Interactive ROOT panel for setting function parameters.\label{f24}][f24]. You will probably like the following: in the output produced by the; example `slits.C`, right-click on the function line and select; ""SetLineAttributes"", then left-click on ""Set Parameters"". This gives; access to a panel allowi",MatchSource.DOCS,documentation/primer/ROOT_as_calculator.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md:14844,Availability,avail,available,14844,"rs of the various classes, and you can even modify; them, e.g. change colour and size of the axis ticks or labels, the; function lines, marker types and so on. Try it!. [f24]: figures/ROOTPanel_SetParameters.png ""f24""; <a name=""f24""></a>. ![Interactive ROOT panel for setting function parameters.\label{f24}][f24]. You will probably like the following: in the output produced by the; example `slits.C`, right-click on the function line and select; ""SetLineAttributes"", then left-click on ""Set Parameters"". This gives; access to a panel allowing you to interactively change the parameters of; the function, as shown in Figure [2.4](#f24). Change the slit width, or go from one to; two and then three or more slits, just as you like. When clicking on; ""Apply"", the function plot is updated to reflect the actual value of the; parameters you have set. [f25]: figures/ROOTPanel_FitPanel.png ""f25""; <a name=""f25""></a>. ![Fit Panel. \label{f25}][f25]. Another very useful interactive tool is the `FitPanel`, available for the; classes `TGraphErrors` and `TH1F`. Predefined fit functions can be selected; from a pull-down menu, including ""`gaus`"", ""`expo`"" and ""`pol0`"" - ""`pol9`""; for Gaussian and exponential functions or polynomials of degree 0 to 9,; respectively. In addition, user-defined functions using the same syntax as; for functions with parameters are possible. After setting the initial parameters, a fit of the selected function to the; data of a graph or histogram can be performed and the result displayed on the plot.; The fit panel is shown in Figure [2.5](#f25). The fit panel has a number of control options to; select the fit method, fix or release individual parameters in the fit, to steer; the level of output printed on the console, or to extract and display additional; information like contour lines showing parameter correlations. As function fitting; is of prime importance in any kind of data analysis, this topic will again show up; later. If you are satisfied with your plot",MatchSource.DOCS,documentation/primer/ROOT_as_calculator.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md:14952,Availability,down,down,14952,". Try it!. [f24]: figures/ROOTPanel_SetParameters.png ""f24""; <a name=""f24""></a>. ![Interactive ROOT panel for setting function parameters.\label{f24}][f24]. You will probably like the following: in the output produced by the; example `slits.C`, right-click on the function line and select; ""SetLineAttributes"", then left-click on ""Set Parameters"". This gives; access to a panel allowing you to interactively change the parameters of; the function, as shown in Figure [2.4](#f24). Change the slit width, or go from one to; two and then three or more slits, just as you like. When clicking on; ""Apply"", the function plot is updated to reflect the actual value of the; parameters you have set. [f25]: figures/ROOTPanel_FitPanel.png ""f25""; <a name=""f25""></a>. ![Fit Panel. \label{f25}][f25]. Another very useful interactive tool is the `FitPanel`, available for the; classes `TGraphErrors` and `TH1F`. Predefined fit functions can be selected; from a pull-down menu, including ""`gaus`"", ""`expo`"" and ""`pol0`"" - ""`pol9`""; for Gaussian and exponential functions or polynomials of degree 0 to 9,; respectively. In addition, user-defined functions using the same syntax as; for functions with parameters are possible. After setting the initial parameters, a fit of the selected function to the; data of a graph or histogram can be performed and the result displayed on the plot.; The fit panel is shown in Figure [2.5](#f25). The fit panel has a number of control options to; select the fit method, fix or release individual parameters in the fit, to steer; the level of output printed on the console, or to extract and display additional; information like contour lines showing parameter correlations. As function fitting; is of prime importance in any kind of data analysis, this topic will again show up; later. If you are satisfied with your plot, you probably want to save it. Just; close all selector boxes you opened previously and select the menu item; `Save as...` from the menu line of the window. ",MatchSource.DOCS,documentation/primer/ROOT_as_calculator.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md:16789,Availability,error,error,16789,"your plot, you probably want to save it. Just; close all selector boxes you opened previously and select the menu item; `Save as...` from the menu line of the window. It will pop up a file; selector box to allow you to choose the format, file name and target; directory to store the image. There is one very noticeable feature here:; you can store a plot as a root macro! In this macro, you find the C++; representation of all methods and classes involved in generating the; plot. This is a valuable source of information for your own macros,; which you will hopefully write after having worked through this; tutorial. Using ROOT's interactive capabilities is useful for a first exploration; of possibilities. Other ROOT classes you will encounter in this tutorial; have such graphical interfaces. We will not comment further on this,; just be aware of the existence of ROOT's interactive features and use; them if you find them convenient. Some trial-and-error is certainly necessary; to find your way through the huge number of menus and parameter; settings. ## ROOT Beginners' FAQ ##. At this point of the guide, some basic questions could have already come; to your mind. We will try to clarify some of them with further; explanations in the following. ### ROOT type declarations for basic data types ###. In the official ROOT documentation, you find special data types; replacing the normal ones, e.g. `Double_t`, `Float_t` or `Int_t`; replacing the standard `double`, `float` or `int` types. Using the ROOT; types makes it easier to port code between platforms (64/32 bit) or; operating systems (windows/Linux), as these types are mapped to suitable; ones in the ROOT header files. If you want adaptive code of this type,; use the ROOT type declarations. However, usually you do not need such; adaptive code, and you can safely use the standard C type declarations; for your private code, as we did and will do throughout this guide. If; you intend to become a ROOT developer, however, you bett",MatchSource.DOCS,documentation/primer/ROOT_as_calculator.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md:19723,Availability,down,down-arrow,19723,"wo rather; important files inspected at start-up: `rootalias.C` and `rootlogon.C`.; They can contain code that needs to be loaded and executed at ROOT; startup. `rootalias.C` is only loaded and best used to define some often; used functions. `rootlogon.C` contains code that will be executed at; startup: this file is extremely useful for example to pre-load a custom; style for the plots created with ROOT. This is done most easily by; creating a new `TStyle` object with your preferred settings, as; described in the class reference guide, and then use the command; `gROOT->SetStyle(""MyStyleName"");` to make this new style definition the; default one. As an example, have a look in the file `rootlogon.C` coming; with this tutorial. Another relevant file is `rootlogoff.C` that it; called when the session is finished. ### ROOT command history ###. Every command typed at the ROOT prompt is stored in a file `.root_hist`; in your home directory. ROOT uses this file to allow for navigation in; the command history with the up-arrow and down-arrow keys. It is also; convenient to extract successful ROOT commands with the help of a text; editor for use in your own macros. ### ROOT Global Pointers ###. All global pointers in ROOT begin with a small ""g"". Some of them were; already implicitly introduced (for example in the section; [Configure ROOT at start-up](#configure-root-at-start-up)).; The most important among them are presented in the following:. - **[gROOT](https://root.cern.ch/doc/master/classTROOT.html)**: the `gROOT`; variable is the entry point to the ROOT system. Technically it is an; instance of the `TROOT` class. Using the `gROOT` pointer one has; access to basically every object created in a ROOT based program.; The `TROOT` object is essentially a container of several lists; pointing to the main `ROOT` objects. - **[gStyle](https://root.cern.ch/doc/master/classTStyle.html)**: By default; ROOT creates a default style that can be accessed via the `gStyle`; pointer. This cl",MatchSource.DOCS,documentation/primer/ROOT_as_calculator.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md:35,Deployability,install,installed,35,"# ROOT Basics #. Now that you have installed ROOT, what's this interactive shell thing; you're running ? It's like this: ROOT leads a double life. It has an; interpreter for macros (Cling [@Cling]) that you can run from the command; line or run like applications. But it is also an interactive shell that; can evaluate arbitrary statements and expressions. This is extremely; useful for debugging, quick hacking and testing. Let us first have a; look at some very simple examples. ## ROOT as calculator ##. You can even use the ROOT interactive shell in lieu of a calculator!; Launch the ROOT interactive shell with the command. ``` {.cpp}; > root; ```. on your Linux box. The prompt should appear shortly:. ``` {.cpp}; root [0]; ```. and let's dive in with the steps shown here:. ``` {.cpp}; root [0] 1+1; (int) 2; root [1] 2*(4+2)/12.; (double) 1.000000; root [2] sqrt(3.); (double) 1.732051; root [3] 1 > 2; (bool) false; root [4] TMath::Pi(); (double) 3.141593; root [5] TMath::Erf(.2); (double) 0.222703; ```. Not bad. You can see that ROOT offers you the possibility not only to; type in `C++` statements, but also advanced mathematical functions,; which live in the `TMath` namespace. Now let's do something more elaborated. A numerical example with the; well known geometrical series:. ``` {.cpp}; root [6] double x=.5; (double) 0.500000; root [7] int N=30; (int) 30; root [8] double geom_series=0; (double) 0.000000; root [9] for (int i=0;i<N;++i)geom_series+=TMath::Power(x,i); root [10] cout << TMath::Abs(geom_series - (1-TMath::Power(x,N-1))/(1-x)) <<endl;; 1.86265e-09; ```. Here we made a step forward. We even declared variables and used a *for*; control structure. Note that there are some subtle differences between; Cling and the standard `C++` language. You do not need the "";"" at the end; of line in interactive mode -- try the difference e.g. using the command; at line `root [6]`. ## Learn C++ at the ROOT prompt ##; Behind the ROOT prompt there is an interpreter based on a rea",MatchSource.DOCS,documentation/primer/ROOT_as_calculator.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md:4530,Deployability,integrat,integration,4530,"rnal ROOT memory management system, the second string type; parameter defines the function, here `sin(x)/x`, and the two parameters; of type double define the range of the variable *x*. The `Draw()`; method, here without any parameters, displays the function in a window; which should pop up after you typed the above two lines. A slightly extended version of this example is the definition of a; function with parameters, called `[0]`, `[1]` and so on in the ROOT; formula syntax. We now need a way to assign values to these parameters;; this is achieved with the method; `SetParameter(<parameter_number>,<parameter_value>)` of class `TF1`.; Here is an example:. ``` {.cpp}; root [13] TF1 f2(""f2"",""[0]*sin([1]*x)/x"",0.,10.);; root [14] f2.SetParameter(0,1);; root [15] f2.SetParameter(1,1);; root [16] f2.Draw();; ```. Of course, this version shows the same results as the initial one. Try; playing with the parameters and plot the function again. The class `TF1`; has a large number of very useful methods, including integration and; differentiation. To make full use of this and other ROOT classes, visit; the documentation on the Internet under; <https://root.cern/doc/master/>. Formulae in ROOT; are evaluated using the class `TFormula`, so also look up the relevant; class documentation for examples, implemented functions and syntax. You should definitely download this guide to your own system to have it; at you disposal whenever you need it. To extend a little bit on the above example, consider a more complex; function you would like to define. You can also do this using standard; `C` or `C++` code. Consider the example below, which calculates and displays the; interference pattern produced by light falling on a multiple slit.; Please do not type in the example below at the ROOT command line, there; is a much simpler way: Make sure you have the file `slits.C` on disk,; and type `root slits.C` in the shell. This will start root and make it; read the ""macro"" `slits.C`, i.e. all the",MatchSource.DOCS,documentation/primer/ROOT_as_calculator.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md:14622,Deployability,update,updated,14622,"estigating, menus for the ROOT classes `TF1`,; `TGraphErrors` or `TH1F` will show up when a right-click is performed on; the respective graphical representations. The menu items allow direct; access to the members of the various classes, and you can even modify; them, e.g. change colour and size of the axis ticks or labels, the; function lines, marker types and so on. Try it!. [f24]: figures/ROOTPanel_SetParameters.png ""f24""; <a name=""f24""></a>. ![Interactive ROOT panel for setting function parameters.\label{f24}][f24]. You will probably like the following: in the output produced by the; example `slits.C`, right-click on the function line and select; ""SetLineAttributes"", then left-click on ""Set Parameters"". This gives; access to a panel allowing you to interactively change the parameters of; the function, as shown in Figure [2.4](#f24). Change the slit width, or go from one to; two and then three or more slits, just as you like. When clicking on; ""Apply"", the function plot is updated to reflect the actual value of the; parameters you have set. [f25]: figures/ROOTPanel_FitPanel.png ""f25""; <a name=""f25""></a>. ![Fit Panel. \label{f25}][f25]. Another very useful interactive tool is the `FitPanel`, available for the; classes `TGraphErrors` and `TH1F`. Predefined fit functions can be selected; from a pull-down menu, including ""`gaus`"", ""`expo`"" and ""`pol0`"" - ""`pol9`""; for Gaussian and exponential functions or polynomials of degree 0 to 9,; respectively. In addition, user-defined functions using the same syntax as; for functions with parameters are possible. After setting the initial parameters, a fit of the selected function to the; data of a graph or histogram can be performed and the result displayed on the plot.; The fit panel is shown in Figure [2.5](#f25). The fit panel has a number of control options to; select the fit method, fix or release individual parameters in the fit, to steer; the level of output printed on the console, or to extract and display additional; ",MatchSource.DOCS,documentation/primer/ROOT_as_calculator.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md:15498,Deployability,release,release,15498," just as you like. When clicking on; ""Apply"", the function plot is updated to reflect the actual value of the; parameters you have set. [f25]: figures/ROOTPanel_FitPanel.png ""f25""; <a name=""f25""></a>. ![Fit Panel. \label{f25}][f25]. Another very useful interactive tool is the `FitPanel`, available for the; classes `TGraphErrors` and `TH1F`. Predefined fit functions can be selected; from a pull-down menu, including ""`gaus`"", ""`expo`"" and ""`pol0`"" - ""`pol9`""; for Gaussian and exponential functions or polynomials of degree 0 to 9,; respectively. In addition, user-defined functions using the same syntax as; for functions with parameters are possible. After setting the initial parameters, a fit of the selected function to the; data of a graph or histogram can be performed and the result displayed on the plot.; The fit panel is shown in Figure [2.5](#f25). The fit panel has a number of control options to; select the fit method, fix or release individual parameters in the fit, to steer; the level of output printed on the console, or to extract and display additional; information like contour lines showing parameter correlations. As function fitting; is of prime importance in any kind of data analysis, this topic will again show up; later. If you are satisfied with your plot, you probably want to save it. Just; close all selector boxes you opened previously and select the menu item; `Save as...` from the menu line of the window. It will pop up a file; selector box to allow you to choose the format, file name and target; directory to store the image. There is one very noticeable feature here:; you can store a plot as a root macro! In this macro, you find the C++; representation of all methods and classes involved in generating the; plot. This is a valuable source of information for your own macros,; which you will hopefully write after having worked through this; tutorial. Using ROOT's interactive capabilities is useful for a first exploration; of possibilities. Other ROOT cl",MatchSource.DOCS,documentation/primer/ROOT_as_calculator.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md:3170,Energy Efficiency,power,powerful,3170," and we sort it in different ways:; ``` {.cpp}; root [0] using doubles = std::vector<double>;; root [1] auto pVec = [](const doubles& v){for (auto&& x:v) cout << x << endl;};; root [2] doubles v{0,3,5,4,1,2};; root [3] pVec(v);; 0; 3; 5; 4; 1; 2; root [4] std::sort(v.begin(),v.end());; root [5] pVec(v);; 0; 1; 2; 3; 4; 5; root [6] std::sort(v.begin(),v.end(),[](double a, double b){return a>b;});; root [7] pVec(v);; 5; 4; 3; 2; 1; 0; ```; Or, if you prefer random number generation:; ``` {.cpp}; root [0] std::default_random_engine generator;; root [1] std::normal_distribution<double> distribution(0.,1.);; root [2] distribution(generator); (std::normal_distribution<double>::result_type) -1.219658e-01; root [3] distribution(generator); (std::normal_distribution<double>::result_type) -1.086818e+00; root [4] distribution(generator); (std::normal_distribution<double>::result_type) 6.842899e-01; ```; Impressive isn't it?. ## ROOT as function plotter ##; Using one of ROOT's powerful classes, here `TF1` [^2], will allow us to; display a function of one variable, *x*. Try the following:. ``` {.cpp}; root [11] TF1 f1(""f1"",""sin(x)/x"",0.,10.);; root [12] f1.Draw();; ```. `f1` is an instance of a TF1 class, the arguments are used; in the constructor; the first one of type string is a name to be entered; in the internal ROOT memory management system, the second string type; parameter defines the function, here `sin(x)/x`, and the two parameters; of type double define the range of the variable *x*. The `Draw()`; method, here without any parameters, displays the function in a window; which should pop up after you typed the above two lines. A slightly extended version of this example is the definition of a; function with parameters, called `[0]`, `[1]` and so on in the ROOT; formula syntax. We now need a way to assign values to these parameters;; this is achieved with the method; `SetParameter(<parameter_number>,<parameter_value>)` of class `TF1`.; Here is an example:. ``` {.cpp}; roo",MatchSource.DOCS,documentation/primer/ROOT_as_calculator.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md:8888,Energy Efficiency,power,powerful,8888,"t root**, simply type `.q` or `.quit` or `.exit`. - obtain the full **list of commands**, use `.?` or `.help`. - **access the shell** of the operating system, type `.!<OS_command>`;; try, e.g. `.!ls` or `.!pwd`. - **execute a macro**, enter `.x <file_name>`; in the above example,; you might have used `.x slits.C` at the ROOT prompt. - **load a macro**, type `.L <file_name>`; in the above example, you; might instead have used the command `.L slits.C` followed by the; function call `slits();`. Note that after loading a macro all; functions and procedures defined therein are available at the ROOT; prompt. - **compile a macro**, type `.L <file_name>+`; ROOT is able to manage; for you the `C++` compiler behind the scenes and to produce machine; code starting from your macro. One could decide to compile a macro; in order to obtain better performance or to get nearer to the; production environment. ## Plotting Measurements ##. To display measurements in ROOT, including errors, there exists a; powerful class `TGraphErrors` with different types of constructors. In; the example here, we use data from the file `ExampleData.txt` in text; format:. ``` {.cpp}; root [0] TGraphErrors gr(""ExampleData.txt"");; root [1] gr.Draw(""AP"");; ```. You should see the output shown in Figure [2.2](#f22). [f22]: figures/TGraphErrors_Example.png ""f22""; <a name=""f22""></a>. ![Visualisation of data points with errors using the class TGraphErrors. \label{f22}][f22]. Make sure the file `ExampleData.txt` is available in the directory from; which you started ROOT. Inspect this file now with your favourite; editor, or use the command `less ExampleData.txt` to inspect the file,; you will see that the format is very simple and easy to understand.; Lines beginning with `#` are ignored. It is very convenient to add some; comments about the type of data. The data itself consist of lines with; four real numbers each, representing the x- and y- coordinates and their; errors of each data point. The argument of the",MatchSource.DOCS,documentation/primer/ROOT_as_calculator.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md:17533,Energy Efficiency,adapt,adaptive,17533,"asses you will encounter in this tutorial; have such graphical interfaces. We will not comment further on this,; just be aware of the existence of ROOT's interactive features and use; them if you find them convenient. Some trial-and-error is certainly necessary; to find your way through the huge number of menus and parameter; settings. ## ROOT Beginners' FAQ ##. At this point of the guide, some basic questions could have already come; to your mind. We will try to clarify some of them with further; explanations in the following. ### ROOT type declarations for basic data types ###. In the official ROOT documentation, you find special data types; replacing the normal ones, e.g. `Double_t`, `Float_t` or `Int_t`; replacing the standard `double`, `float` or `int` types. Using the ROOT; types makes it easier to port code between platforms (64/32 bit) or; operating systems (windows/Linux), as these types are mapped to suitable; ones in the ROOT header files. If you want adaptive code of this type,; use the ROOT type declarations. However, usually you do not need such; adaptive code, and you can safely use the standard C type declarations; for your private code, as we did and will do throughout this guide. If; you intend to become a ROOT developer, however, you better stick to the; official coding rules!. ### Configure ROOT at start-up ###. The behaviour of a ROOT session can be tailored with the options in the; `.rootrc` file. Examples of the tunable parameters are the ones related; to the operating and window system, to the fonts to be used, to the; location of start-up files. At start-up, ROOT looks for a `.rootrc` file; in the following order:. - `./.rootrc //local directory`. - `$HOME/.rootrc //user directory`. - `$ROOTSYS/etc/system.rootrc //global ROOT directory`. If more than one `.rootrc` files are found in the search paths above,; the options are merged, with precedence local, user, global. The parsing; and interpretation of this file is handled by the ROOT class `T",MatchSource.DOCS,documentation/primer/ROOT_as_calculator.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md:17633,Energy Efficiency,adapt,adaptive,17633," of the existence of ROOT's interactive features and use; them if you find them convenient. Some trial-and-error is certainly necessary; to find your way through the huge number of menus and parameter; settings. ## ROOT Beginners' FAQ ##. At this point of the guide, some basic questions could have already come; to your mind. We will try to clarify some of them with further; explanations in the following. ### ROOT type declarations for basic data types ###. In the official ROOT documentation, you find special data types; replacing the normal ones, e.g. `Double_t`, `Float_t` or `Int_t`; replacing the standard `double`, `float` or `int` types. Using the ROOT; types makes it easier to port code between platforms (64/32 bit) or; operating systems (windows/Linux), as these types are mapped to suitable; ones in the ROOT header files. If you want adaptive code of this type,; use the ROOT type declarations. However, usually you do not need such; adaptive code, and you can safely use the standard C type declarations; for your private code, as we did and will do throughout this guide. If; you intend to become a ROOT developer, however, you better stick to the; official coding rules!. ### Configure ROOT at start-up ###. The behaviour of a ROOT session can be tailored with the options in the; `.rootrc` file. Examples of the tunable parameters are the ones related; to the operating and window system, to the fonts to be used, to the; location of start-up files. At start-up, ROOT looks for a `.rootrc` file; in the following order:. - `./.rootrc //local directory`. - `$HOME/.rootrc //user directory`. - `$ROOTSYS/etc/system.rootrc //global ROOT directory`. If more than one `.rootrc` files are found in the search paths above,; the options are merged, with precedence local, user, global. The parsing; and interpretation of this file is handled by the ROOT class `TEnv`.; Have a look to its documentation if you need such rather advanced; features. The file `.rootrc` defines the location of",MatchSource.DOCS,documentation/primer/ROOT_as_calculator.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md:4530,Integrability,integrat,integration,4530,"rnal ROOT memory management system, the second string type; parameter defines the function, here `sin(x)/x`, and the two parameters; of type double define the range of the variable *x*. The `Draw()`; method, here without any parameters, displays the function in a window; which should pop up after you typed the above two lines. A slightly extended version of this example is the definition of a; function with parameters, called `[0]`, `[1]` and so on in the ROOT; formula syntax. We now need a way to assign values to these parameters;; this is achieved with the method; `SetParameter(<parameter_number>,<parameter_value>)` of class `TF1`.; Here is an example:. ``` {.cpp}; root [13] TF1 f2(""f2"",""[0]*sin([1]*x)/x"",0.,10.);; root [14] f2.SetParameter(0,1);; root [15] f2.SetParameter(1,1);; root [16] f2.Draw();; ```. Of course, this version shows the same results as the initial one. Try; playing with the parameters and plot the function again. The class `TF1`; has a large number of very useful methods, including integration and; differentiation. To make full use of this and other ROOT classes, visit; the documentation on the Internet under; <https://root.cern/doc/master/>. Formulae in ROOT; are evaluated using the class `TFormula`, so also look up the relevant; class documentation for examples, implemented functions and syntax. You should definitely download this guide to your own system to have it; at you disposal whenever you need it. To extend a little bit on the above example, consider a more complex; function you would like to define. You can also do this using standard; `C` or `C++` code. Consider the example below, which calculates and displays the; interference pattern produced by light falling on a multiple slit.; Please do not type in the example below at the ROOT command line, there; is a much simpler way: Make sure you have the file `slits.C` on disk,; and type `root slits.C` in the shell. This will start root and make it; read the ""macro"" `slits.C`, i.e. all the",MatchSource.DOCS,documentation/primer/ROOT_as_calculator.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md:6385,Integrability,depend,depending,6385,"e `root slits.C` in the shell. This will start root and make it; read the ""macro"" `slits.C`, i.e. all the lines in the file will be; executed one after the other. ``` {.cpp .numberLines}; @ROOT_INCLUDE_FILE macros/slits.C; ```; [f21]: figures/TF1_DoubleSlit.png ""f21""; <a name=""f21""></a>. ![Output of slits.C with parameters 0.2 and 2.\label{f21}][f21]. The example first asks for user input, namely the ratio of slit width; over slit distance, and the number of slits. After entering this; information, you should see the graphical output as is shown in Figure [2.1](#f21). This is a more complicated example than the ones we have seen before, so; spend some time analysing it carefully, you should have understood it; before continuing. Let us go through it in detail:. Lines *7-18* define the necessary functions in `C++` code, split into; three separate functions, as suggested by the problem considered. The; full interference pattern is given by the product of a function; depending on the ratio of the width and distance of the slits, and a; second one depending on the number of slits. More important for us here; is the definition of the interface of these functions to make them; usable for the ROOT class `TF1`: the first argument is the pointer to; *x*, the second one points to the array of parameters. The main program starts at line 21 with the definition of a function; `slits()` of type `void`. After asking for user input, a ROOT function; is defined using the C-type function given in the beginning. We can now; use all methods of the `TF1` class to control the behaviour of our; function -- nice, isn't it ?. If you like, you can easily extend the example to also plot the; interference pattern of a single slit, using function `double single`,; or of a grid with narrow slits, function `double nslit0`, in `TF1`; instances. Here, we used a macro, some sort of lightweight program, that the; interpreter distributed with ROOT, Cling, is able to execute. This is a; rather extraordi",MatchSource.DOCS,documentation/primer/ROOT_as_calculator.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md:6466,Integrability,depend,depending,6466,"e `root slits.C` in the shell. This will start root and make it; read the ""macro"" `slits.C`, i.e. all the lines in the file will be; executed one after the other. ``` {.cpp .numberLines}; @ROOT_INCLUDE_FILE macros/slits.C; ```; [f21]: figures/TF1_DoubleSlit.png ""f21""; <a name=""f21""></a>. ![Output of slits.C with parameters 0.2 and 2.\label{f21}][f21]. The example first asks for user input, namely the ratio of slit width; over slit distance, and the number of slits. After entering this; information, you should see the graphical output as is shown in Figure [2.1](#f21). This is a more complicated example than the ones we have seen before, so; spend some time analysing it carefully, you should have understood it; before continuing. Let us go through it in detail:. Lines *7-18* define the necessary functions in `C++` code, split into; three separate functions, as suggested by the problem considered. The; full interference pattern is given by the product of a function; depending on the ratio of the width and distance of the slits, and a; second one depending on the number of slits. More important for us here; is the definition of the interface of these functions to make them; usable for the ROOT class `TF1`: the first argument is the pointer to; *x*, the second one points to the array of parameters. The main program starts at line 21 with the definition of a function; `slits()` of type `void`. After asking for user input, a ROOT function; is defined using the C-type function given in the beginning. We can now; use all methods of the `TF1` class to control the behaviour of our; function -- nice, isn't it ?. If you like, you can easily extend the example to also plot the; interference pattern of a single slit, using function `double single`,; or of a grid with narrow slits, function `double nslit0`, in `TF1`; instances. Here, we used a macro, some sort of lightweight program, that the; interpreter distributed with ROOT, Cling, is able to execute. This is a; rather extraordi",MatchSource.DOCS,documentation/primer/ROOT_as_calculator.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md:6553,Integrability,interface,interface,6553,"LE macros/slits.C; ```; [f21]: figures/TF1_DoubleSlit.png ""f21""; <a name=""f21""></a>. ![Output of slits.C with parameters 0.2 and 2.\label{f21}][f21]. The example first asks for user input, namely the ratio of slit width; over slit distance, and the number of slits. After entering this; information, you should see the graphical output as is shown in Figure [2.1](#f21). This is a more complicated example than the ones we have seen before, so; spend some time analysing it carefully, you should have understood it; before continuing. Let us go through it in detail:. Lines *7-18* define the necessary functions in `C++` code, split into; three separate functions, as suggested by the problem considered. The; full interference pattern is given by the product of a function; depending on the ratio of the width and distance of the slits, and a; second one depending on the number of slits. More important for us here; is the definition of the interface of these functions to make them; usable for the ROOT class `TF1`: the first argument is the pointer to; *x*, the second one points to the array of parameters. The main program starts at line 21 with the definition of a function; `slits()` of type `void`. After asking for user input, a ROOT function; is defined using the C-type function given in the beginning. We can now; use all methods of the `TF1` class to control the behaviour of our; function -- nice, isn't it ?. If you like, you can easily extend the example to also plot the; interference pattern of a single slit, using function `double single`,; or of a grid with narrow slits, function `double nslit0`, in `TF1`; instances. Here, we used a macro, some sort of lightweight program, that the; interpreter distributed with ROOT, Cling, is able to execute. This is a; rather extraordinary situation, since `C++` is not natively an interpreted; language! There is much more to say: chapter is indeed dedicated to; macros. ## Controlling ROOT ##. One more remark at this point: as every co",MatchSource.DOCS,documentation/primer/ROOT_as_calculator.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md:12395,Integrability,depend,depending,12395,"[f23]: figures/TH1F_Example.png ""f23""; <a name=""f23""></a>. ![Visualisation of a histogram filled with exponentially distributed,; random numbers. \label{f23}][f23]. We use yet another new feature of ROOT to fill this histogram with data,; namely pseudo-random numbers generated with the method `TF1::GetRandom`,; which in turn uses an instance of the ROOT class `TRandom` created when; ROOT is started. Data is entered in the histogram at line *4* using the; method `TH1F::Fill` in a loop construct. As a result, the histogram is; filled with 1000 random numbers distributed according to the defined; function. The histogram is displayed using the method `TH1F::Draw()`.; You may think of this example as repeated measurements of the life time; of a quantum mechanical state, which are entered into the histogram,; thus giving a visual impression of the probability density distribution.; The plot is shown in Figure [2.3](#f23). Note that you will not obtain an identical plot when executing the lines; above, depending on how the random number generator is initialised. The class `TH1F` does not contain a convenient input format from plain; text files. The following lines of `C++` code do the job. One number per; line stored in the text file ""expo.dat"" is read in via an input stream; and filled in the histogram until end of file is reached. ``` {.cpp}; root [1] TH1F h(""h"",""example histogram"",100,0.,5.);; root [2] ifstream inp; double x;; root [3] inp.open(""expo.dat"");; root [4] while (inp >> x) { h.Fill(x); }; root [5] h.Draw();; root [6] inp.close();; ```. Histograms and random numbers are very important tools in statistical; data analysis, a whole chapter will be dedicated to this topic. ## Interactive ROOT ##. Look at one of your plots again and move the mouse across. You will; notice that this is much more than a static picture, as the mouse; pointer changes its shape when touching objects on the plot. When the; mouse is over an object, a right-click opens a pull-down menu dis",MatchSource.DOCS,documentation/primer/ROOT_as_calculator.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md:16619,Integrability,interface,interfaces,16619,"onsole, or to extract and display additional; information like contour lines showing parameter correlations. As function fitting; is of prime importance in any kind of data analysis, this topic will again show up; later. If you are satisfied with your plot, you probably want to save it. Just; close all selector boxes you opened previously and select the menu item; `Save as...` from the menu line of the window. It will pop up a file; selector box to allow you to choose the format, file name and target; directory to store the image. There is one very noticeable feature here:; you can store a plot as a root macro! In this macro, you find the C++; representation of all methods and classes involved in generating the; plot. This is a valuable source of information for your own macros,; which you will hopefully write after having worked through this; tutorial. Using ROOT's interactive capabilities is useful for a first exploration; of possibilities. Other ROOT classes you will encounter in this tutorial; have such graphical interfaces. We will not comment further on this,; just be aware of the existence of ROOT's interactive features and use; them if you find them convenient. Some trial-and-error is certainly necessary; to find your way through the huge number of menus and parameter; settings. ## ROOT Beginners' FAQ ##. At this point of the guide, some basic questions could have already come; to your mind. We will try to clarify some of them with further; explanations in the following. ### ROOT type declarations for basic data types ###. In the official ROOT documentation, you find special data types; replacing the normal ones, e.g. `Double_t`, `Float_t` or `Int_t`; replacing the standard `double`, `float` or `int` types. Using the ROOT; types makes it easier to port code between platforms (64/32 bit) or; operating systems (windows/Linux), as these types are mapped to suitable; ones in the ROOT header files. If you want adaptive code of this type,; use the ROOT type declar",MatchSource.DOCS,documentation/primer/ROOT_as_calculator.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md:21009,Integrability,interface,interface,21009,"root_hist`; in your home directory. ROOT uses this file to allow for navigation in; the command history with the up-arrow and down-arrow keys. It is also; convenient to extract successful ROOT commands with the help of a text; editor for use in your own macros. ### ROOT Global Pointers ###. All global pointers in ROOT begin with a small ""g"". Some of them were; already implicitly introduced (for example in the section; [Configure ROOT at start-up](#configure-root-at-start-up)).; The most important among them are presented in the following:. - **[gROOT](https://root.cern.ch/doc/master/classTROOT.html)**: the `gROOT`; variable is the entry point to the ROOT system. Technically it is an; instance of the `TROOT` class. Using the `gROOT` pointer one has; access to basically every object created in a ROOT based program.; The `TROOT` object is essentially a container of several lists; pointing to the main `ROOT` objects. - **[gStyle](https://root.cern.ch/doc/master/classTStyle.html)**: By default; ROOT creates a default style that can be accessed via the `gStyle`; pointer. This class includes functions to set some of the following; object attributes. - Canvas; - Pad; - Histogram axis; - Lines; - Fill areas; - Text; - Markers; - Functions; - Histogram Statistics and Titles; - etc ... - **[gSystem](https://root.cern.ch/doc/master/classTSystem.html)**: An; instance of a base class defining a generic interface to the; underlying Operating System, in our case `TUnixSystem`. - **[gInterpreter](http://root.cern.ch/htmldoc/html/TInterpreter.html)**: The; entry point for the ROOT interpreter. Technically an abstraction level; over a singleton instance of `TCling`. At this point you have already learnt quite a bit about some basic; features of ROOT. ***Please move on to become an expert!***. [^2]: All ROOT classes' names start with the letter T. A notable exception is; RooFit. In this context all classes' names are of the form Roo*. Starting with; ROOT7, all names start with and R.; ",MatchSource.DOCS,documentation/primer/ROOT_as_calculator.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md:1635,Modifiability,variab,variables,1635,"```. on your Linux box. The prompt should appear shortly:. ``` {.cpp}; root [0]; ```. and let's dive in with the steps shown here:. ``` {.cpp}; root [0] 1+1; (int) 2; root [1] 2*(4+2)/12.; (double) 1.000000; root [2] sqrt(3.); (double) 1.732051; root [3] 1 > 2; (bool) false; root [4] TMath::Pi(); (double) 3.141593; root [5] TMath::Erf(.2); (double) 0.222703; ```. Not bad. You can see that ROOT offers you the possibility not only to; type in `C++` statements, but also advanced mathematical functions,; which live in the `TMath` namespace. Now let's do something more elaborated. A numerical example with the; well known geometrical series:. ``` {.cpp}; root [6] double x=.5; (double) 0.500000; root [7] int N=30; (int) 30; root [8] double geom_series=0; (double) 0.000000; root [9] for (int i=0;i<N;++i)geom_series+=TMath::Power(x,i); root [10] cout << TMath::Abs(geom_series - (1-TMath::Power(x,N-1))/(1-x)) <<endl;; 1.86265e-09; ```. Here we made a step forward. We even declared variables and used a *for*; control structure. Note that there are some subtle differences between; Cling and the standard `C++` language. You do not need the "";"" at the end; of line in interactive mode -- try the difference e.g. using the command; at line `root [6]`. ## Learn C++ at the ROOT prompt ##; Behind the ROOT prompt there is an interpreter based on a real compiler toolkit:; LLVM. It is therefore possible to exercise many features of `C++` and the; standard library. For example in the following snippet we define a lambda; function, a vector and we sort it in different ways:; ``` {.cpp}; root [0] using doubles = std::vector<double>;; root [1] auto pVec = [](const doubles& v){for (auto&& x:v) cout << x << endl;};; root [2] doubles v{0,3,5,4,1,2};; root [3] pVec(v);; 0; 3; 5; 4; 1; 2; root [4] std::sort(v.begin(),v.end());; root [5] pVec(v);; 0; 1; 2; 3; 4; 5; root [6] std::sort(v.begin(),v.end(),[](double a, double b){return a>b;});; root [7] pVec(v);; 5; 4; 3; 2; 1; 0; ```; Or, if you prefer",MatchSource.DOCS,documentation/primer/ROOT_as_calculator.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md:3249,Modifiability,variab,variable,3249," and we sort it in different ways:; ``` {.cpp}; root [0] using doubles = std::vector<double>;; root [1] auto pVec = [](const doubles& v){for (auto&& x:v) cout << x << endl;};; root [2] doubles v{0,3,5,4,1,2};; root [3] pVec(v);; 0; 3; 5; 4; 1; 2; root [4] std::sort(v.begin(),v.end());; root [5] pVec(v);; 0; 1; 2; 3; 4; 5; root [6] std::sort(v.begin(),v.end(),[](double a, double b){return a>b;});; root [7] pVec(v);; 5; 4; 3; 2; 1; 0; ```; Or, if you prefer random number generation:; ``` {.cpp}; root [0] std::default_random_engine generator;; root [1] std::normal_distribution<double> distribution(0.,1.);; root [2] distribution(generator); (std::normal_distribution<double>::result_type) -1.219658e-01; root [3] distribution(generator); (std::normal_distribution<double>::result_type) -1.086818e+00; root [4] distribution(generator); (std::normal_distribution<double>::result_type) 6.842899e-01; ```; Impressive isn't it?. ## ROOT as function plotter ##; Using one of ROOT's powerful classes, here `TF1` [^2], will allow us to; display a function of one variable, *x*. Try the following:. ``` {.cpp}; root [11] TF1 f1(""f1"",""sin(x)/x"",0.,10.);; root [12] f1.Draw();; ```. `f1` is an instance of a TF1 class, the arguments are used; in the constructor; the first one of type string is a name to be entered; in the internal ROOT memory management system, the second string type; parameter defines the function, here `sin(x)/x`, and the two parameters; of type double define the range of the variable *x*. The `Draw()`; method, here without any parameters, displays the function in a window; which should pop up after you typed the above two lines. A slightly extended version of this example is the definition of a; function with parameters, called `[0]`, `[1]` and so on in the ROOT; formula syntax. We now need a way to assign values to these parameters;; this is achieved with the method; `SetParameter(<parameter_number>,<parameter_value>)` of class `TF1`.; Here is an example:. ``` {.cpp}; roo",MatchSource.DOCS,documentation/primer/ROOT_as_calculator.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md:3683,Modifiability,variab,variable,3683,"rt(v.begin(),v.end(),[](double a, double b){return a>b;});; root [7] pVec(v);; 5; 4; 3; 2; 1; 0; ```; Or, if you prefer random number generation:; ``` {.cpp}; root [0] std::default_random_engine generator;; root [1] std::normal_distribution<double> distribution(0.,1.);; root [2] distribution(generator); (std::normal_distribution<double>::result_type) -1.219658e-01; root [3] distribution(generator); (std::normal_distribution<double>::result_type) -1.086818e+00; root [4] distribution(generator); (std::normal_distribution<double>::result_type) 6.842899e-01; ```; Impressive isn't it?. ## ROOT as function plotter ##; Using one of ROOT's powerful classes, here `TF1` [^2], will allow us to; display a function of one variable, *x*. Try the following:. ``` {.cpp}; root [11] TF1 f1(""f1"",""sin(x)/x"",0.,10.);; root [12] f1.Draw();; ```. `f1` is an instance of a TF1 class, the arguments are used; in the constructor; the first one of type string is a name to be entered; in the internal ROOT memory management system, the second string type; parameter defines the function, here `sin(x)/x`, and the two parameters; of type double define the range of the variable *x*. The `Draw()`; method, here without any parameters, displays the function in a window; which should pop up after you typed the above two lines. A slightly extended version of this example is the definition of a; function with parameters, called `[0]`, `[1]` and so on in the ROOT; formula syntax. We now need a way to assign values to these parameters;; this is achieved with the method; `SetParameter(<parameter_number>,<parameter_value>)` of class `TF1`.; Here is an example:. ``` {.cpp}; root [13] TF1 f2(""f2"",""[0]*sin([1]*x)/x"",0.,10.);; root [14] f2.SetParameter(0,1);; root [15] f2.SetParameter(1,1);; root [16] f2.Draw();; ```. Of course, this version shows the same results as the initial one. Try; playing with the parameters and plot the function again. The class `TF1`; has a large number of very useful methods, including i",MatchSource.DOCS,documentation/primer/ROOT_as_calculator.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md:3851,Modifiability,extend,extended,3851,"tion(generator); (std::normal_distribution<double>::result_type) -1.086818e+00; root [4] distribution(generator); (std::normal_distribution<double>::result_type) 6.842899e-01; ```; Impressive isn't it?. ## ROOT as function plotter ##; Using one of ROOT's powerful classes, here `TF1` [^2], will allow us to; display a function of one variable, *x*. Try the following:. ``` {.cpp}; root [11] TF1 f1(""f1"",""sin(x)/x"",0.,10.);; root [12] f1.Draw();; ```. `f1` is an instance of a TF1 class, the arguments are used; in the constructor; the first one of type string is a name to be entered; in the internal ROOT memory management system, the second string type; parameter defines the function, here `sin(x)/x`, and the two parameters; of type double define the range of the variable *x*. The `Draw()`; method, here without any parameters, displays the function in a window; which should pop up after you typed the above two lines. A slightly extended version of this example is the definition of a; function with parameters, called `[0]`, `[1]` and so on in the ROOT; formula syntax. We now need a way to assign values to these parameters;; this is achieved with the method; `SetParameter(<parameter_number>,<parameter_value>)` of class `TF1`.; Here is an example:. ``` {.cpp}; root [13] TF1 f2(""f2"",""[0]*sin([1]*x)/x"",0.,10.);; root [14] f2.SetParameter(0,1);; root [15] f2.SetParameter(1,1);; root [16] f2.Draw();; ```. Of course, this version shows the same results as the initial one. Try; playing with the parameters and plot the function again. The class `TF1`; has a large number of very useful methods, including integration and; differentiation. To make full use of this and other ROOT classes, visit; the documentation on the Internet under; <https://root.cern/doc/master/>. Formulae in ROOT; are evaluated using the class `TFormula`, so also look up the relevant; class documentation for examples, implemented functions and syntax. You should definitely download this guide to your own system to ",MatchSource.DOCS,documentation/primer/ROOT_as_calculator.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md:4966,Modifiability,extend,extend,4966,"assign values to these parameters;; this is achieved with the method; `SetParameter(<parameter_number>,<parameter_value>)` of class `TF1`.; Here is an example:. ``` {.cpp}; root [13] TF1 f2(""f2"",""[0]*sin([1]*x)/x"",0.,10.);; root [14] f2.SetParameter(0,1);; root [15] f2.SetParameter(1,1);; root [16] f2.Draw();; ```. Of course, this version shows the same results as the initial one. Try; playing with the parameters and plot the function again. The class `TF1`; has a large number of very useful methods, including integration and; differentiation. To make full use of this and other ROOT classes, visit; the documentation on the Internet under; <https://root.cern/doc/master/>. Formulae in ROOT; are evaluated using the class `TFormula`, so also look up the relevant; class documentation for examples, implemented functions and syntax. You should definitely download this guide to your own system to have it; at you disposal whenever you need it. To extend a little bit on the above example, consider a more complex; function you would like to define. You can also do this using standard; `C` or `C++` code. Consider the example below, which calculates and displays the; interference pattern produced by light falling on a multiple slit.; Please do not type in the example below at the ROOT command line, there; is a much simpler way: Make sure you have the file `slits.C` on disk,; and type `root slits.C` in the shell. This will start root and make it; read the ""macro"" `slits.C`, i.e. all the lines in the file will be; executed one after the other. ``` {.cpp .numberLines}; @ROOT_INCLUDE_FILE macros/slits.C; ```; [f21]: figures/TF1_DoubleSlit.png ""f21""; <a name=""f21""></a>. ![Output of slits.C with parameters 0.2 and 2.\label{f21}][f21]. The example first asks for user input, namely the ratio of slit width; over slit distance, and the number of slits. After entering this; information, you should see the graphical output as is shown in Figure [2.1](#f21). This is a more complicated example",MatchSource.DOCS,documentation/primer/ROOT_as_calculator.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md:7063,Modifiability,extend,extend,7063,"g. Let us go through it in detail:. Lines *7-18* define the necessary functions in `C++` code, split into; three separate functions, as suggested by the problem considered. The; full interference pattern is given by the product of a function; depending on the ratio of the width and distance of the slits, and a; second one depending on the number of slits. More important for us here; is the definition of the interface of these functions to make them; usable for the ROOT class `TF1`: the first argument is the pointer to; *x*, the second one points to the array of parameters. The main program starts at line 21 with the definition of a function; `slits()` of type `void`. After asking for user input, a ROOT function; is defined using the C-type function given in the beginning. We can now; use all methods of the `TF1` class to control the behaviour of our; function -- nice, isn't it ?. If you like, you can easily extend the example to also plot the; interference pattern of a single slit, using function `double single`,; or of a grid with narrow slits, function `double nslit0`, in `TF1`; instances. Here, we used a macro, some sort of lightweight program, that the; interpreter distributed with ROOT, Cling, is able to execute. This is a; rather extraordinary situation, since `C++` is not natively an interpreted; language! There is much more to say: chapter is indeed dedicated to; macros. ## Controlling ROOT ##. One more remark at this point: as every command you type into ROOT is; usually interpreted by Cling, an ""escape character"" is needed to pass; commands to ROOT directly. This character is the dot at the beginning of; a line:. ``` {.cpp}; root [1] .<command>; ```. This is a selection of the most common commands. - **quit root**, simply type `.q` or `.quit` or `.exit`. - obtain the full **list of commands**, use `.?` or `.help`. - **access the shell** of the operating system, type `.!<OS_command>`;; try, e.g. `.!ls` or `.!pwd`. - **execute a macro**, enter `.x <file_name",MatchSource.DOCS,documentation/primer/ROOT_as_calculator.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md:17533,Modifiability,adapt,adaptive,17533,"asses you will encounter in this tutorial; have such graphical interfaces. We will not comment further on this,; just be aware of the existence of ROOT's interactive features and use; them if you find them convenient. Some trial-and-error is certainly necessary; to find your way through the huge number of menus and parameter; settings. ## ROOT Beginners' FAQ ##. At this point of the guide, some basic questions could have already come; to your mind. We will try to clarify some of them with further; explanations in the following. ### ROOT type declarations for basic data types ###. In the official ROOT documentation, you find special data types; replacing the normal ones, e.g. `Double_t`, `Float_t` or `Int_t`; replacing the standard `double`, `float` or `int` types. Using the ROOT; types makes it easier to port code between platforms (64/32 bit) or; operating systems (windows/Linux), as these types are mapped to suitable; ones in the ROOT header files. If you want adaptive code of this type,; use the ROOT type declarations. However, usually you do not need such; adaptive code, and you can safely use the standard C type declarations; for your private code, as we did and will do throughout this guide. If; you intend to become a ROOT developer, however, you better stick to the; official coding rules!. ### Configure ROOT at start-up ###. The behaviour of a ROOT session can be tailored with the options in the; `.rootrc` file. Examples of the tunable parameters are the ones related; to the operating and window system, to the fonts to be used, to the; location of start-up files. At start-up, ROOT looks for a `.rootrc` file; in the following order:. - `./.rootrc //local directory`. - `$HOME/.rootrc //user directory`. - `$ROOTSYS/etc/system.rootrc //global ROOT directory`. If more than one `.rootrc` files are found in the search paths above,; the options are merged, with precedence local, user, global. The parsing; and interpretation of this file is handled by the ROOT class `T",MatchSource.DOCS,documentation/primer/ROOT_as_calculator.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md:17633,Modifiability,adapt,adaptive,17633," of the existence of ROOT's interactive features and use; them if you find them convenient. Some trial-and-error is certainly necessary; to find your way through the huge number of menus and parameter; settings. ## ROOT Beginners' FAQ ##. At this point of the guide, some basic questions could have already come; to your mind. We will try to clarify some of them with further; explanations in the following. ### ROOT type declarations for basic data types ###. In the official ROOT documentation, you find special data types; replacing the normal ones, e.g. `Double_t`, `Float_t` or `Int_t`; replacing the standard `double`, `float` or `int` types. Using the ROOT; types makes it easier to port code between platforms (64/32 bit) or; operating systems (windows/Linux), as these types are mapped to suitable; ones in the ROOT header files. If you want adaptive code of this type,; use the ROOT type declarations. However, usually you do not need such; adaptive code, and you can safely use the standard C type declarations; for your private code, as we did and will do throughout this guide. If; you intend to become a ROOT developer, however, you better stick to the; official coding rules!. ### Configure ROOT at start-up ###. The behaviour of a ROOT session can be tailored with the options in the; `.rootrc` file. Examples of the tunable parameters are the ones related; to the operating and window system, to the fonts to be used, to the; location of start-up files. At start-up, ROOT looks for a `.rootrc` file; in the following order:. - `./.rootrc //local directory`. - `$HOME/.rootrc //user directory`. - `$ROOTSYS/etc/system.rootrc //global ROOT directory`. If more than one `.rootrc` files are found in the search paths above,; the options are merged, with precedence local, user, global. The parsing; and interpretation of this file is handled by the ROOT class `TEnv`.; Have a look to its documentation if you need such rather advanced; features. The file `.rootrc` defines the location of",MatchSource.DOCS,documentation/primer/ROOT_as_calculator.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md:20049,Modifiability,config,configure-root-at-start-up,20049,"ely useful for example to pre-load a custom; style for the plots created with ROOT. This is done most easily by; creating a new `TStyle` object with your preferred settings, as; described in the class reference guide, and then use the command; `gROOT->SetStyle(""MyStyleName"");` to make this new style definition the; default one. As an example, have a look in the file `rootlogon.C` coming; with this tutorial. Another relevant file is `rootlogoff.C` that it; called when the session is finished. ### ROOT command history ###. Every command typed at the ROOT prompt is stored in a file `.root_hist`; in your home directory. ROOT uses this file to allow for navigation in; the command history with the up-arrow and down-arrow keys. It is also; convenient to extract successful ROOT commands with the help of a text; editor for use in your own macros. ### ROOT Global Pointers ###. All global pointers in ROOT begin with a small ""g"". Some of them were; already implicitly introduced (for example in the section; [Configure ROOT at start-up](#configure-root-at-start-up)).; The most important among them are presented in the following:. - **[gROOT](https://root.cern.ch/doc/master/classTROOT.html)**: the `gROOT`; variable is the entry point to the ROOT system. Technically it is an; instance of the `TROOT` class. Using the `gROOT` pointer one has; access to basically every object created in a ROOT based program.; The `TROOT` object is essentially a container of several lists; pointing to the main `ROOT` objects. - **[gStyle](https://root.cern.ch/doc/master/classTStyle.html)**: By default; ROOT creates a default style that can be accessed via the `gStyle`; pointer. This class includes functions to set some of the following; object attributes. - Canvas; - Pad; - Histogram axis; - Lines; - Fill areas; - Text; - Markers; - Functions; - Histogram Statistics and Titles; - etc ... - **[gSystem](https://root.cern.ch/doc/master/classTSystem.html)**: An; instance of a base class defining a generic ",MatchSource.DOCS,documentation/primer/ROOT_as_calculator.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md:20220,Modifiability,variab,variable,20220,"hen use the command; `gROOT->SetStyle(""MyStyleName"");` to make this new style definition the; default one. As an example, have a look in the file `rootlogon.C` coming; with this tutorial. Another relevant file is `rootlogoff.C` that it; called when the session is finished. ### ROOT command history ###. Every command typed at the ROOT prompt is stored in a file `.root_hist`; in your home directory. ROOT uses this file to allow for navigation in; the command history with the up-arrow and down-arrow keys. It is also; convenient to extract successful ROOT commands with the help of a text; editor for use in your own macros. ### ROOT Global Pointers ###. All global pointers in ROOT begin with a small ""g"". Some of them were; already implicitly introduced (for example in the section; [Configure ROOT at start-up](#configure-root-at-start-up)).; The most important among them are presented in the following:. - **[gROOT](https://root.cern.ch/doc/master/classTROOT.html)**: the `gROOT`; variable is the entry point to the ROOT system. Technically it is an; instance of the `TROOT` class. Using the `gROOT` pointer one has; access to basically every object created in a ROOT based program.; The `TROOT` object is essentially a container of several lists; pointing to the main `ROOT` objects. - **[gStyle](https://root.cern.ch/doc/master/classTStyle.html)**: By default; ROOT creates a default style that can be accessed via the `gStyle`; pointer. This class includes functions to set some of the following; object attributes. - Canvas; - Pad; - Histogram axis; - Lines; - Fill areas; - Text; - Markers; - Functions; - Histogram Statistics and Titles; - etc ... - **[gSystem](https://root.cern.ch/doc/master/classTSystem.html)**: An; instance of a base class defining a generic interface to the; underlying Operating System, in our case `TUnixSystem`. - **[gInterpreter](http://root.cern.ch/htmldoc/html/TInterpreter.html)**: The; entry point for the ROOT interpreter. Technically an abstraction level;",MatchSource.DOCS,documentation/primer/ROOT_as_calculator.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md:8226,Performance,load,load,8226,"F1`; instances. Here, we used a macro, some sort of lightweight program, that the; interpreter distributed with ROOT, Cling, is able to execute. This is a; rather extraordinary situation, since `C++` is not natively an interpreted; language! There is much more to say: chapter is indeed dedicated to; macros. ## Controlling ROOT ##. One more remark at this point: as every command you type into ROOT is; usually interpreted by Cling, an ""escape character"" is needed to pass; commands to ROOT directly. This character is the dot at the beginning of; a line:. ``` {.cpp}; root [1] .<command>; ```. This is a selection of the most common commands. - **quit root**, simply type `.q` or `.quit` or `.exit`. - obtain the full **list of commands**, use `.?` or `.help`. - **access the shell** of the operating system, type `.!<OS_command>`;; try, e.g. `.!ls` or `.!pwd`. - **execute a macro**, enter `.x <file_name>`; in the above example,; you might have used `.x slits.C` at the ROOT prompt. - **load a macro**, type `.L <file_name>`; in the above example, you; might instead have used the command `.L slits.C` followed by the; function call `slits();`. Note that after loading a macro all; functions and procedures defined therein are available at the ROOT; prompt. - **compile a macro**, type `.L <file_name>+`; ROOT is able to manage; for you the `C++` compiler behind the scenes and to produce machine; code starting from your macro. One could decide to compile a macro; in order to obtain better performance or to get nearer to the; production environment. ## Plotting Measurements ##. To display measurements in ROOT, including errors, there exists a; powerful class `TGraphErrors` with different types of constructors. In; the example here, we use data from the file `ExampleData.txt` in text; format:. ``` {.cpp}; root [0] TGraphErrors gr(""ExampleData.txt"");; root [1] gr.Draw(""AP"");; ```. You should see the output shown in Figure [2.2](#f22). [f22]: figures/TGraphErrors_Example.png ""f22""; <a na",MatchSource.DOCS,documentation/primer/ROOT_as_calculator.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md:8400,Performance,load,loading,8400,"ot natively an interpreted; language! There is much more to say: chapter is indeed dedicated to; macros. ## Controlling ROOT ##. One more remark at this point: as every command you type into ROOT is; usually interpreted by Cling, an ""escape character"" is needed to pass; commands to ROOT directly. This character is the dot at the beginning of; a line:. ``` {.cpp}; root [1] .<command>; ```. This is a selection of the most common commands. - **quit root**, simply type `.q` or `.quit` or `.exit`. - obtain the full **list of commands**, use `.?` or `.help`. - **access the shell** of the operating system, type `.!<OS_command>`;; try, e.g. `.!ls` or `.!pwd`. - **execute a macro**, enter `.x <file_name>`; in the above example,; you might have used `.x slits.C` at the ROOT prompt. - **load a macro**, type `.L <file_name>`; in the above example, you; might instead have used the command `.L slits.C` followed by the; function call `slits();`. Note that after loading a macro all; functions and procedures defined therein are available at the ROOT; prompt. - **compile a macro**, type `.L <file_name>+`; ROOT is able to manage; for you the `C++` compiler behind the scenes and to produce machine; code starting from your macro. One could decide to compile a macro; in order to obtain better performance or to get nearer to the; production environment. ## Plotting Measurements ##. To display measurements in ROOT, including errors, there exists a; powerful class `TGraphErrors` with different types of constructors. In; the example here, we use data from the file `ExampleData.txt` in text; format:. ``` {.cpp}; root [0] TGraphErrors gr(""ExampleData.txt"");; root [1] gr.Draw(""AP"");; ```. You should see the output shown in Figure [2.2](#f22). [f22]: figures/TGraphErrors_Example.png ""f22""; <a name=""f22""></a>. ![Visualisation of data points with errors using the class TGraphErrors. \label{f22}][f22]. Make sure the file `ExampleData.txt` is available in the directory from; which you started ROOT. I",MatchSource.DOCS,documentation/primer/ROOT_as_calculator.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md:8731,Performance,perform,performance,8731,"rectly. This character is the dot at the beginning of; a line:. ``` {.cpp}; root [1] .<command>; ```. This is a selection of the most common commands. - **quit root**, simply type `.q` or `.quit` or `.exit`. - obtain the full **list of commands**, use `.?` or `.help`. - **access the shell** of the operating system, type `.!<OS_command>`;; try, e.g. `.!ls` or `.!pwd`. - **execute a macro**, enter `.x <file_name>`; in the above example,; you might have used `.x slits.C` at the ROOT prompt. - **load a macro**, type `.L <file_name>`; in the above example, you; might instead have used the command `.L slits.C` followed by the; function call `slits();`. Note that after loading a macro all; functions and procedures defined therein are available at the ROOT; prompt. - **compile a macro**, type `.L <file_name>+`; ROOT is able to manage; for you the `C++` compiler behind the scenes and to produce machine; code starting from your macro. One could decide to compile a macro; in order to obtain better performance or to get nearer to the; production environment. ## Plotting Measurements ##. To display measurements in ROOT, including errors, there exists a; powerful class `TGraphErrors` with different types of constructors. In; the example here, we use data from the file `ExampleData.txt` in text; format:. ``` {.cpp}; root [0] TGraphErrors gr(""ExampleData.txt"");; root [1] gr.Draw(""AP"");; ```. You should see the output shown in Figure [2.2](#f22). [f22]: figures/TGraphErrors_Example.png ""f22""; <a name=""f22""></a>. ![Visualisation of data points with errors using the class TGraphErrors. \label{f22}][f22]. Make sure the file `ExampleData.txt` is available in the directory from; which you started ROOT. Inspect this file now with your favourite; editor, or use the command `less ExampleData.txt` to inspect the file,; you will see that the format is very simple and easy to understand.; Lines beginning with `#` are ignored. It is very convenient to add some; comments about the type of data. ",MatchSource.DOCS,documentation/primer/ROOT_as_calculator.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md:13738,Performance,perform,performed,13738,"istogram until end of file is reached. ``` {.cpp}; root [1] TH1F h(""h"",""example histogram"",100,0.,5.);; root [2] ifstream inp; double x;; root [3] inp.open(""expo.dat"");; root [4] while (inp >> x) { h.Fill(x); }; root [5] h.Draw();; root [6] inp.close();; ```. Histograms and random numbers are very important tools in statistical; data analysis, a whole chapter will be dedicated to this topic. ## Interactive ROOT ##. Look at one of your plots again and move the mouse across. You will; notice that this is much more than a static picture, as the mouse; pointer changes its shape when touching objects on the plot. When the; mouse is over an object, a right-click opens a pull-down menu displaying; in the top line the name of the ROOT class you are dealing with, e.g.; `TCanvas` for the display window itself, `TFrame` for the frame of the; plot, `TAxis` for the axes, `TPaveText` for the plot name. Depending on; which plot you are investigating, menus for the ROOT classes `TF1`,; `TGraphErrors` or `TH1F` will show up when a right-click is performed on; the respective graphical representations. The menu items allow direct; access to the members of the various classes, and you can even modify; them, e.g. change colour and size of the axis ticks or labels, the; function lines, marker types and so on. Try it!. [f24]: figures/ROOTPanel_SetParameters.png ""f24""; <a name=""f24""></a>. ![Interactive ROOT panel for setting function parameters.\label{f24}][f24]. You will probably like the following: in the output produced by the; example `slits.C`, right-click on the function line and select; ""SetLineAttributes"", then left-click on ""Set Parameters"". This gives; access to a panel allowing you to interactively change the parameters of; the function, as shown in Figure [2.4](#f24). Change the slit width, or go from one to; two and then three or more slits, just as you like. When clicking on; ""Apply"", the function plot is updated to reflect the actual value of the; parameters you have set. [f2",MatchSource.DOCS,documentation/primer/ROOT_as_calculator.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md:15323,Performance,perform,performed,15323," ""SetLineAttributes"", then left-click on ""Set Parameters"". This gives; access to a panel allowing you to interactively change the parameters of; the function, as shown in Figure [2.4](#f24). Change the slit width, or go from one to; two and then three or more slits, just as you like. When clicking on; ""Apply"", the function plot is updated to reflect the actual value of the; parameters you have set. [f25]: figures/ROOTPanel_FitPanel.png ""f25""; <a name=""f25""></a>. ![Fit Panel. \label{f25}][f25]. Another very useful interactive tool is the `FitPanel`, available for the; classes `TGraphErrors` and `TH1F`. Predefined fit functions can be selected; from a pull-down menu, including ""`gaus`"", ""`expo`"" and ""`pol0`"" - ""`pol9`""; for Gaussian and exponential functions or polynomials of degree 0 to 9,; respectively. In addition, user-defined functions using the same syntax as; for functions with parameters are possible. After setting the initial parameters, a fit of the selected function to the; data of a graph or histogram can be performed and the result displayed on the plot.; The fit panel is shown in Figure [2.5](#f25). The fit panel has a number of control options to; select the fit method, fix or release individual parameters in the fit, to steer; the level of output printed on the console, or to extract and display additional; information like contour lines showing parameter correlations. As function fitting; is of prime importance in any kind of data analysis, this topic will again show up; later. If you are satisfied with your plot, you probably want to save it. Just; close all selector boxes you opened previously and select the menu item; `Save as...` from the menu line of the window. It will pop up a file; selector box to allow you to choose the format, file name and target; directory to store the image. There is one very noticeable feature here:; you can store a plot as a root macro! In this macro, you find the C++; representation of all methods and classes involved i",MatchSource.DOCS,documentation/primer/ROOT_as_calculator.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md:18808,Performance,load,loaded,18808,"eveloper, however, you better stick to the; official coding rules!. ### Configure ROOT at start-up ###. The behaviour of a ROOT session can be tailored with the options in the; `.rootrc` file. Examples of the tunable parameters are the ones related; to the operating and window system, to the fonts to be used, to the; location of start-up files. At start-up, ROOT looks for a `.rootrc` file; in the following order:. - `./.rootrc //local directory`. - `$HOME/.rootrc //user directory`. - `$ROOTSYS/etc/system.rootrc //global ROOT directory`. If more than one `.rootrc` files are found in the search paths above,; the options are merged, with precedence local, user, global. The parsing; and interpretation of this file is handled by the ROOT class `TEnv`.; Have a look to its documentation if you need such rather advanced; features. The file `.rootrc` defines the location of two rather; important files inspected at start-up: `rootalias.C` and `rootlogon.C`.; They can contain code that needs to be loaded and executed at ROOT; startup. `rootalias.C` is only loaded and best used to define some often; used functions. `rootlogon.C` contains code that will be executed at; startup: this file is extremely useful for example to pre-load a custom; style for the plots created with ROOT. This is done most easily by; creating a new `TStyle` object with your preferred settings, as; described in the class reference guide, and then use the command; `gROOT->SetStyle(""MyStyleName"");` to make this new style definition the; default one. As an example, have a look in the file `rootlogon.C` coming; with this tutorial. Another relevant file is `rootlogoff.C` that it; called when the session is finished. ### ROOT command history ###. Every command typed at the ROOT prompt is stored in a file `.root_hist`; in your home directory. ROOT uses this file to allow for navigation in; the command history with the up-arrow and down-arrow keys. It is also; convenient to extract successful ROOT commands with th",MatchSource.DOCS,documentation/primer/ROOT_as_calculator.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md:18868,Performance,load,loaded,18868,"T at start-up ###. The behaviour of a ROOT session can be tailored with the options in the; `.rootrc` file. Examples of the tunable parameters are the ones related; to the operating and window system, to the fonts to be used, to the; location of start-up files. At start-up, ROOT looks for a `.rootrc` file; in the following order:. - `./.rootrc //local directory`. - `$HOME/.rootrc //user directory`. - `$ROOTSYS/etc/system.rootrc //global ROOT directory`. If more than one `.rootrc` files are found in the search paths above,; the options are merged, with precedence local, user, global. The parsing; and interpretation of this file is handled by the ROOT class `TEnv`.; Have a look to its documentation if you need such rather advanced; features. The file `.rootrc` defines the location of two rather; important files inspected at start-up: `rootalias.C` and `rootlogon.C`.; They can contain code that needs to be loaded and executed at ROOT; startup. `rootalias.C` is only loaded and best used to define some often; used functions. `rootlogon.C` contains code that will be executed at; startup: this file is extremely useful for example to pre-load a custom; style for the plots created with ROOT. This is done most easily by; creating a new `TStyle` object with your preferred settings, as; described in the class reference guide, and then use the command; `gROOT->SetStyle(""MyStyleName"");` to make this new style definition the; default one. As an example, have a look in the file `rootlogon.C` coming; with this tutorial. Another relevant file is `rootlogoff.C` that it; called when the session is finished. ### ROOT command history ###. Every command typed at the ROOT prompt is stored in a file `.root_hist`; in your home directory. ROOT uses this file to allow for navigation in; the command history with the up-arrow and down-arrow keys. It is also; convenient to extract successful ROOT commands with the help of a text; editor for use in your own macros. ### ROOT Global Pointers ###. All",MatchSource.DOCS,documentation/primer/ROOT_as_calculator.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md:19039,Performance,load,load,19039,"tunable parameters are the ones related; to the operating and window system, to the fonts to be used, to the; location of start-up files. At start-up, ROOT looks for a `.rootrc` file; in the following order:. - `./.rootrc //local directory`. - `$HOME/.rootrc //user directory`. - `$ROOTSYS/etc/system.rootrc //global ROOT directory`. If more than one `.rootrc` files are found in the search paths above,; the options are merged, with precedence local, user, global. The parsing; and interpretation of this file is handled by the ROOT class `TEnv`.; Have a look to its documentation if you need such rather advanced; features. The file `.rootrc` defines the location of two rather; important files inspected at start-up: `rootalias.C` and `rootlogon.C`.; They can contain code that needs to be loaded and executed at ROOT; startup. `rootalias.C` is only loaded and best used to define some often; used functions. `rootlogon.C` contains code that will be executed at; startup: this file is extremely useful for example to pre-load a custom; style for the plots created with ROOT. This is done most easily by; creating a new `TStyle` object with your preferred settings, as; described in the class reference guide, and then use the command; `gROOT->SetStyle(""MyStyleName"");` to make this new style definition the; default one. As an example, have a look in the file `rootlogon.C` coming; with this tutorial. Another relevant file is `rootlogoff.C` that it; called when the session is finished. ### ROOT command history ###. Every command typed at the ROOT prompt is stored in a file `.root_hist`; in your home directory. ROOT uses this file to allow for navigation in; the command history with the up-arrow and down-arrow keys. It is also; convenient to extract successful ROOT commands with the help of a text; editor for use in your own macros. ### ROOT Global Pointers ###. All global pointers in ROOT begin with a small ""g"". Some of them were; already implicitly introduced (for example in the secti",MatchSource.DOCS,documentation/primer/ROOT_as_calculator.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md:17660,Safety,safe,safely,17660," of the existence of ROOT's interactive features and use; them if you find them convenient. Some trial-and-error is certainly necessary; to find your way through the huge number of menus and parameter; settings. ## ROOT Beginners' FAQ ##. At this point of the guide, some basic questions could have already come; to your mind. We will try to clarify some of them with further; explanations in the following. ### ROOT type declarations for basic data types ###. In the official ROOT documentation, you find special data types; replacing the normal ones, e.g. `Double_t`, `Float_t` or `Int_t`; replacing the standard `double`, `float` or `int` types. Using the ROOT; types makes it easier to port code between platforms (64/32 bit) or; operating systems (windows/Linux), as these types are mapped to suitable; ones in the ROOT header files. If you want adaptive code of this type,; use the ROOT type declarations. However, usually you do not need such; adaptive code, and you can safely use the standard C type declarations; for your private code, as we did and will do throughout this guide. If; you intend to become a ROOT developer, however, you better stick to the; official coding rules!. ### Configure ROOT at start-up ###. The behaviour of a ROOT session can be tailored with the options in the; `.rootrc` file. Examples of the tunable parameters are the ones related; to the operating and window system, to the fonts to be used, to the; location of start-up files. At start-up, ROOT looks for a `.rootrc` file; in the following order:. - `./.rootrc //local directory`. - `$HOME/.rootrc //user directory`. - `$ROOTSYS/etc/system.rootrc //global ROOT directory`. If more than one `.rootrc` files are found in the search paths above,; the options are merged, with precedence local, user, global. The parsing; and interpretation of this file is handled by the ROOT class `TEnv`.; Have a look to its documentation if you need such rather advanced; features. The file `.rootrc` defines the location of",MatchSource.DOCS,documentation/primer/ROOT_as_calculator.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md:8002,Security,access,access,8002,"n't it ?. If you like, you can easily extend the example to also plot the; interference pattern of a single slit, using function `double single`,; or of a grid with narrow slits, function `double nslit0`, in `TF1`; instances. Here, we used a macro, some sort of lightweight program, that the; interpreter distributed with ROOT, Cling, is able to execute. This is a; rather extraordinary situation, since `C++` is not natively an interpreted; language! There is much more to say: chapter is indeed dedicated to; macros. ## Controlling ROOT ##. One more remark at this point: as every command you type into ROOT is; usually interpreted by Cling, an ""escape character"" is needed to pass; commands to ROOT directly. This character is the dot at the beginning of; a line:. ``` {.cpp}; root [1] .<command>; ```. This is a selection of the most common commands. - **quit root**, simply type `.q` or `.quit` or `.exit`. - obtain the full **list of commands**, use `.?` or `.help`. - **access the shell** of the operating system, type `.!<OS_command>`;; try, e.g. `.!ls` or `.!pwd`. - **execute a macro**, enter `.x <file_name>`; in the above example,; you might have used `.x slits.C` at the ROOT prompt. - **load a macro**, type `.L <file_name>`; in the above example, you; might instead have used the command `.L slits.C` followed by the; function call `slits();`. Note that after loading a macro all; functions and procedures defined therein are available at the ROOT; prompt. - **compile a macro**, type `.L <file_name>+`; ROOT is able to manage; for you the `C++` compiler behind the scenes and to produce machine; code starting from your macro. One could decide to compile a macro; in order to obtain better performance or to get nearer to the; production environment. ## Plotting Measurements ##. To display measurements in ROOT, including errors, there exists a; powerful class `TGraphErrors` with different types of constructors. In; the example here, we use data from the file `ExampleData.txt` in ",MatchSource.DOCS,documentation/primer/ROOT_as_calculator.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md:13823,Security,access,access,13823,"n(""expo.dat"");; root [4] while (inp >> x) { h.Fill(x); }; root [5] h.Draw();; root [6] inp.close();; ```. Histograms and random numbers are very important tools in statistical; data analysis, a whole chapter will be dedicated to this topic. ## Interactive ROOT ##. Look at one of your plots again and move the mouse across. You will; notice that this is much more than a static picture, as the mouse; pointer changes its shape when touching objects on the plot. When the; mouse is over an object, a right-click opens a pull-down menu displaying; in the top line the name of the ROOT class you are dealing with, e.g.; `TCanvas` for the display window itself, `TFrame` for the frame of the; plot, `TAxis` for the axes, `TPaveText` for the plot name. Depending on; which plot you are investigating, menus for the ROOT classes `TF1`,; `TGraphErrors` or `TH1F` will show up when a right-click is performed on; the respective graphical representations. The menu items allow direct; access to the members of the various classes, and you can even modify; them, e.g. change colour and size of the axis ticks or labels, the; function lines, marker types and so on. Try it!. [f24]: figures/ROOTPanel_SetParameters.png ""f24""; <a name=""f24""></a>. ![Interactive ROOT panel for setting function parameters.\label{f24}][f24]. You will probably like the following: in the output produced by the; example `slits.C`, right-click on the function line and select; ""SetLineAttributes"", then left-click on ""Set Parameters"". This gives; access to a panel allowing you to interactively change the parameters of; the function, as shown in Figure [2.4](#f24). Change the slit width, or go from one to; two and then three or more slits, just as you like. When clicking on; ""Apply"", the function plot is updated to reflect the actual value of the; parameters you have set. [f25]: figures/ROOTPanel_FitPanel.png ""f25""; <a name=""f25""></a>. ![Fit Panel. \label{f25}][f25]. Another very useful interactive tool is the `FitPanel`, avai",MatchSource.DOCS,documentation/primer/ROOT_as_calculator.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md:14360,Security,access,access,14360," the name of the ROOT class you are dealing with, e.g.; `TCanvas` for the display window itself, `TFrame` for the frame of the; plot, `TAxis` for the axes, `TPaveText` for the plot name. Depending on; which plot you are investigating, menus for the ROOT classes `TF1`,; `TGraphErrors` or `TH1F` will show up when a right-click is performed on; the respective graphical representations. The menu items allow direct; access to the members of the various classes, and you can even modify; them, e.g. change colour and size of the axis ticks or labels, the; function lines, marker types and so on. Try it!. [f24]: figures/ROOTPanel_SetParameters.png ""f24""; <a name=""f24""></a>. ![Interactive ROOT panel for setting function parameters.\label{f24}][f24]. You will probably like the following: in the output produced by the; example `slits.C`, right-click on the function line and select; ""SetLineAttributes"", then left-click on ""Set Parameters"". This gives; access to a panel allowing you to interactively change the parameters of; the function, as shown in Figure [2.4](#f24). Change the slit width, or go from one to; two and then three or more slits, just as you like. When clicking on; ""Apply"", the function plot is updated to reflect the actual value of the; parameters you have set. [f25]: figures/ROOTPanel_FitPanel.png ""f25""; <a name=""f25""></a>. ![Fit Panel. \label{f25}][f25]. Another very useful interactive tool is the `FitPanel`, available for the; classes `TGraphErrors` and `TH1F`. Predefined fit functions can be selected; from a pull-down menu, including ""`gaus`"", ""`expo`"" and ""`pol0`"" - ""`pol9`""; for Gaussian and exponential functions or polynomials of degree 0 to 9,; respectively. In addition, user-defined functions using the same syntax as; for functions with parameters are possible. After setting the initial parameters, a fit of the selected function to the; data of a graph or histogram can be performed and the result displayed on the plot.; The fit panel is shown in Figure [2.5",MatchSource.DOCS,documentation/primer/ROOT_as_calculator.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md:20356,Security,access,access,20356,"he file `rootlogon.C` coming; with this tutorial. Another relevant file is `rootlogoff.C` that it; called when the session is finished. ### ROOT command history ###. Every command typed at the ROOT prompt is stored in a file `.root_hist`; in your home directory. ROOT uses this file to allow for navigation in; the command history with the up-arrow and down-arrow keys. It is also; convenient to extract successful ROOT commands with the help of a text; editor for use in your own macros. ### ROOT Global Pointers ###. All global pointers in ROOT begin with a small ""g"". Some of them were; already implicitly introduced (for example in the section; [Configure ROOT at start-up](#configure-root-at-start-up)).; The most important among them are presented in the following:. - **[gROOT](https://root.cern.ch/doc/master/classTROOT.html)**: the `gROOT`; variable is the entry point to the ROOT system. Technically it is an; instance of the `TROOT` class. Using the `gROOT` pointer one has; access to basically every object created in a ROOT based program.; The `TROOT` object is essentially a container of several lists; pointing to the main `ROOT` objects. - **[gStyle](https://root.cern.ch/doc/master/classTStyle.html)**: By default; ROOT creates a default style that can be accessed via the `gStyle`; pointer. This class includes functions to set some of the following; object attributes. - Canvas; - Pad; - Histogram axis; - Lines; - Fill areas; - Text; - Markers; - Functions; - Histogram Statistics and Titles; - etc ... - **[gSystem](https://root.cern.ch/doc/master/classTSystem.html)**: An; instance of a base class defining a generic interface to the; underlying Operating System, in our case `TUnixSystem`. - **[gInterpreter](http://root.cern.ch/htmldoc/html/TInterpreter.html)**: The; entry point for the ROOT interpreter. Technically an abstraction level; over a singleton instance of `TCling`. At this point you have already learnt quite a bit about some basic; features of ROOT. ***Please mo",MatchSource.DOCS,documentation/primer/ROOT_as_calculator.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md:20643,Security,access,accessed,20643,"root_hist`; in your home directory. ROOT uses this file to allow for navigation in; the command history with the up-arrow and down-arrow keys. It is also; convenient to extract successful ROOT commands with the help of a text; editor for use in your own macros. ### ROOT Global Pointers ###. All global pointers in ROOT begin with a small ""g"". Some of them were; already implicitly introduced (for example in the section; [Configure ROOT at start-up](#configure-root-at-start-up)).; The most important among them are presented in the following:. - **[gROOT](https://root.cern.ch/doc/master/classTROOT.html)**: the `gROOT`; variable is the entry point to the ROOT system. Technically it is an; instance of the `TROOT` class. Using the `gROOT` pointer one has; access to basically every object created in a ROOT based program.; The `TROOT` object is essentially a container of several lists; pointing to the main `ROOT` objects. - **[gStyle](https://root.cern.ch/doc/master/classTStyle.html)**: By default; ROOT creates a default style that can be accessed via the `gStyle`; pointer. This class includes functions to set some of the following; object attributes. - Canvas; - Pad; - Histogram axis; - Lines; - Fill areas; - Text; - Markers; - Functions; - Histogram Statistics and Titles; - etc ... - **[gSystem](https://root.cern.ch/doc/master/classTSystem.html)**: An; instance of a base class defining a generic interface to the; underlying Operating System, in our case `TUnixSystem`. - **[gInterpreter](http://root.cern.ch/htmldoc/html/TInterpreter.html)**: The; entry point for the ROOT interpreter. Technically an abstraction level; over a singleton instance of `TCling`. At this point you have already learnt quite a bit about some basic; features of ROOT. ***Please move on to become an expert!***. [^2]: All ROOT classes' names start with the letter T. A notable exception is; RooFit. In this context all classes' names are of the form Roo*. Starting with; ROOT7, all names start with and R.; ",MatchSource.DOCS,documentation/primer/ROOT_as_calculator.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md:416,Testability,test,testing,416,"# ROOT Basics #. Now that you have installed ROOT, what's this interactive shell thing; you're running ? It's like this: ROOT leads a double life. It has an; interpreter for macros (Cling [@Cling]) that you can run from the command; line or run like applications. But it is also an interactive shell that; can evaluate arbitrary statements and expressions. This is extremely; useful for debugging, quick hacking and testing. Let us first have a; look at some very simple examples. ## ROOT as calculator ##. You can even use the ROOT interactive shell in lieu of a calculator!; Launch the ROOT interactive shell with the command. ``` {.cpp}; > root; ```. on your Linux box. The prompt should appear shortly:. ``` {.cpp}; root [0]; ```. and let's dive in with the steps shown here:. ``` {.cpp}; root [0] 1+1; (int) 2; root [1] 2*(4+2)/12.; (double) 1.000000; root [2] sqrt(3.); (double) 1.732051; root [3] 1 > 2; (bool) false; root [4] TMath::Pi(); (double) 3.141593; root [5] TMath::Erf(.2); (double) 0.222703; ```. Not bad. You can see that ROOT offers you the possibility not only to; type in `C++` statements, but also advanced mathematical functions,; which live in the `TMath` namespace. Now let's do something more elaborated. A numerical example with the; well known geometrical series:. ``` {.cpp}; root [6] double x=.5; (double) 0.500000; root [7] int N=30; (int) 30; root [8] double geom_series=0; (double) 0.000000; root [9] for (int i=0;i<N;++i)geom_series+=TMath::Power(x,i); root [10] cout << TMath::Abs(geom_series - (1-TMath::Power(x,N-1))/(1-x)) <<endl;; 1.86265e-09; ```. Here we made a step forward. We even declared variables and used a *for*; control structure. Note that there are some subtle differences between; Cling and the standard `C++` language. You do not need the "";"" at the end; of line in interactive mode -- try the difference e.g. using the command; at line `root [6]`. ## Learn C++ at the ROOT prompt ##; Behind the ROOT prompt there is an interpreter based on a rea",MatchSource.DOCS,documentation/primer/ROOT_as_calculator.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md:464,Usability,simpl,simple,464,"# ROOT Basics #. Now that you have installed ROOT, what's this interactive shell thing; you're running ? It's like this: ROOT leads a double life. It has an; interpreter for macros (Cling [@Cling]) that you can run from the command; line or run like applications. But it is also an interactive shell that; can evaluate arbitrary statements and expressions. This is extremely; useful for debugging, quick hacking and testing. Let us first have a; look at some very simple examples. ## ROOT as calculator ##. You can even use the ROOT interactive shell in lieu of a calculator!; Launch the ROOT interactive shell with the command. ``` {.cpp}; > root; ```. on your Linux box. The prompt should appear shortly:. ``` {.cpp}; root [0]; ```. and let's dive in with the steps shown here:. ``` {.cpp}; root [0] 1+1; (int) 2; root [1] 2*(4+2)/12.; (double) 1.000000; root [2] sqrt(3.); (double) 1.732051; root [3] 1 > 2; (bool) false; root [4] TMath::Pi(); (double) 3.141593; root [5] TMath::Erf(.2); (double) 0.222703; ```. Not bad. You can see that ROOT offers you the possibility not only to; type in `C++` statements, but also advanced mathematical functions,; which live in the `TMath` namespace. Now let's do something more elaborated. A numerical example with the; well known geometrical series:. ``` {.cpp}; root [6] double x=.5; (double) 0.500000; root [7] int N=30; (int) 30; root [8] double geom_series=0; (double) 0.000000; root [9] for (int i=0;i<N;++i)geom_series+=TMath::Power(x,i); root [10] cout << TMath::Abs(geom_series - (1-TMath::Power(x,N-1))/(1-x)) <<endl;; 1.86265e-09; ```. Here we made a step forward. We even declared variables and used a *for*; control structure. Note that there are some subtle differences between; Cling and the standard `C++` language. You do not need the "";"" at the end; of line in interactive mode -- try the difference e.g. using the command; at line `root [6]`. ## Learn C++ at the ROOT prompt ##; Behind the ROOT prompt there is an interpreter based on a rea",MatchSource.DOCS,documentation/primer/ROOT_as_calculator.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md:4888,Usability,guid,guide,4888,"; function with parameters, called `[0]`, `[1]` and so on in the ROOT; formula syntax. We now need a way to assign values to these parameters;; this is achieved with the method; `SetParameter(<parameter_number>,<parameter_value>)` of class `TF1`.; Here is an example:. ``` {.cpp}; root [13] TF1 f2(""f2"",""[0]*sin([1]*x)/x"",0.,10.);; root [14] f2.SetParameter(0,1);; root [15] f2.SetParameter(1,1);; root [16] f2.Draw();; ```. Of course, this version shows the same results as the initial one. Try; playing with the parameters and plot the function again. The class `TF1`; has a large number of very useful methods, including integration and; differentiation. To make full use of this and other ROOT classes, visit; the documentation on the Internet under; <https://root.cern/doc/master/>. Formulae in ROOT; are evaluated using the class `TFormula`, so also look up the relevant; class documentation for examples, implemented functions and syntax. You should definitely download this guide to your own system to have it; at you disposal whenever you need it. To extend a little bit on the above example, consider a more complex; function you would like to define. You can also do this using standard; `C` or `C++` code. Consider the example below, which calculates and displays the; interference pattern produced by light falling on a multiple slit.; Please do not type in the example below at the ROOT command line, there; is a much simpler way: Make sure you have the file `slits.C` on disk,; and type `root slits.C` in the shell. This will start root and make it; read the ""macro"" `slits.C`, i.e. all the lines in the file will be; executed one after the other. ``` {.cpp .numberLines}; @ROOT_INCLUDE_FILE macros/slits.C; ```; [f21]: figures/TF1_DoubleSlit.png ""f21""; <a name=""f21""></a>. ![Output of slits.C with parameters 0.2 and 2.\label{f21}][f21]. The example first asks for user input, namely the ratio of slit width; over slit distance, and the number of slits. After entering this; informatio",MatchSource.DOCS,documentation/primer/ROOT_as_calculator.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md:5338,Usability,simpl,simpler,5338,"aw();; ```. Of course, this version shows the same results as the initial one. Try; playing with the parameters and plot the function again. The class `TF1`; has a large number of very useful methods, including integration and; differentiation. To make full use of this and other ROOT classes, visit; the documentation on the Internet under; <https://root.cern/doc/master/>. Formulae in ROOT; are evaluated using the class `TFormula`, so also look up the relevant; class documentation for examples, implemented functions and syntax. You should definitely download this guide to your own system to have it; at you disposal whenever you need it. To extend a little bit on the above example, consider a more complex; function you would like to define. You can also do this using standard; `C` or `C++` code. Consider the example below, which calculates and displays the; interference pattern produced by light falling on a multiple slit.; Please do not type in the example below at the ROOT command line, there; is a much simpler way: Make sure you have the file `slits.C` on disk,; and type `root slits.C` in the shell. This will start root and make it; read the ""macro"" `slits.C`, i.e. all the lines in the file will be; executed one after the other. ``` {.cpp .numberLines}; @ROOT_INCLUDE_FILE macros/slits.C; ```; [f21]: figures/TF1_DoubleSlit.png ""f21""; <a name=""f21""></a>. ![Output of slits.C with parameters 0.2 and 2.\label{f21}][f21]. The example first asks for user input, namely the ratio of slit width; over slit distance, and the number of slits. After entering this; information, you should see the graphical output as is shown in Figure [2.1](#f21). This is a more complicated example than the ones we have seen before, so; spend some time analysing it carefully, you should have understood it; before continuing. Let us go through it in detail:. Lines *7-18* define the necessary functions in `C++` code, split into; three separate functions, as suggested by the problem considered. The; ",MatchSource.DOCS,documentation/primer/ROOT_as_calculator.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md:6596,Usability,usab,usable,6596,"LE macros/slits.C; ```; [f21]: figures/TF1_DoubleSlit.png ""f21""; <a name=""f21""></a>. ![Output of slits.C with parameters 0.2 and 2.\label{f21}][f21]. The example first asks for user input, namely the ratio of slit width; over slit distance, and the number of slits. After entering this; information, you should see the graphical output as is shown in Figure [2.1](#f21). This is a more complicated example than the ones we have seen before, so; spend some time analysing it carefully, you should have understood it; before continuing. Let us go through it in detail:. Lines *7-18* define the necessary functions in `C++` code, split into; three separate functions, as suggested by the problem considered. The; full interference pattern is given by the product of a function; depending on the ratio of the width and distance of the slits, and a; second one depending on the number of slits. More important for us here; is the definition of the interface of these functions to make them; usable for the ROOT class `TF1`: the first argument is the pointer to; *x*, the second one points to the array of parameters. The main program starts at line 21 with the definition of a function; `slits()` of type `void`. After asking for user input, a ROOT function; is defined using the C-type function given in the beginning. We can now; use all methods of the `TF1` class to control the behaviour of our; function -- nice, isn't it ?. If you like, you can easily extend the example to also plot the; interference pattern of a single slit, using function `double single`,; or of a grid with narrow slits, function `double nslit0`, in `TF1`; instances. Here, we used a macro, some sort of lightweight program, that the; interpreter distributed with ROOT, Cling, is able to execute. This is a; rather extraordinary situation, since `C++` is not natively an interpreted; language! There is much more to say: chapter is indeed dedicated to; macros. ## Controlling ROOT ##. One more remark at this point: as every co",MatchSource.DOCS,documentation/primer/ROOT_as_calculator.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md:7897,Usability,simpl,simply,7897,"ction given in the beginning. We can now; use all methods of the `TF1` class to control the behaviour of our; function -- nice, isn't it ?. If you like, you can easily extend the example to also plot the; interference pattern of a single slit, using function `double single`,; or of a grid with narrow slits, function `double nslit0`, in `TF1`; instances. Here, we used a macro, some sort of lightweight program, that the; interpreter distributed with ROOT, Cling, is able to execute. This is a; rather extraordinary situation, since `C++` is not natively an interpreted; language! There is much more to say: chapter is indeed dedicated to; macros. ## Controlling ROOT ##. One more remark at this point: as every command you type into ROOT is; usually interpreted by Cling, an ""escape character"" is needed to pass; commands to ROOT directly. This character is the dot at the beginning of; a line:. ``` {.cpp}; root [1] .<command>; ```. This is a selection of the most common commands. - **quit root**, simply type `.q` or `.quit` or `.exit`. - obtain the full **list of commands**, use `.?` or `.help`. - **access the shell** of the operating system, type `.!<OS_command>`;; try, e.g. `.!ls` or `.!pwd`. - **execute a macro**, enter `.x <file_name>`; in the above example,; you might have used `.x slits.C` at the ROOT prompt. - **load a macro**, type `.L <file_name>`; in the above example, you; might instead have used the command `.L slits.C` followed by the; function call `slits();`. Note that after loading a macro all; functions and procedures defined therein are available at the ROOT; prompt. - **compile a macro**, type `.L <file_name>+`; ROOT is able to manage; for you the `C++` compiler behind the scenes and to produce machine; code starting from your macro. One could decide to compile a macro; in order to obtain better performance or to get nearer to the; production environment. ## Plotting Measurements ##. To display measurements in ROOT, including errors, there exists a; powerfu",MatchSource.DOCS,documentation/primer/ROOT_as_calculator.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md:9591,Usability,simpl,simple,9591,"u the `C++` compiler behind the scenes and to produce machine; code starting from your macro. One could decide to compile a macro; in order to obtain better performance or to get nearer to the; production environment. ## Plotting Measurements ##. To display measurements in ROOT, including errors, there exists a; powerful class `TGraphErrors` with different types of constructors. In; the example here, we use data from the file `ExampleData.txt` in text; format:. ``` {.cpp}; root [0] TGraphErrors gr(""ExampleData.txt"");; root [1] gr.Draw(""AP"");; ```. You should see the output shown in Figure [2.2](#f22). [f22]: figures/TGraphErrors_Example.png ""f22""; <a name=""f22""></a>. ![Visualisation of data points with errors using the class TGraphErrors. \label{f22}][f22]. Make sure the file `ExampleData.txt` is available in the directory from; which you started ROOT. Inspect this file now with your favourite; editor, or use the command `less ExampleData.txt` to inspect the file,; you will see that the format is very simple and easy to understand.; Lines beginning with `#` are ignored. It is very convenient to add some; comments about the type of data. The data itself consist of lines with; four real numbers each, representing the x- and y- coordinates and their; errors of each data point. The argument of the method `Draw(""AP"")` is important here. Behind the scenes,; it tells the `TGraphPainter` class to show the axes and to plot markers at the; *x* and *y* positions of the specified data points. Note that this simple; example relies on the default settings of ROOT, concerning the size of; the canvas holding the plot, the marker type and the line colours and; thickness used and so on. In a well-written, complete example, all this; would need to be specified explicitly in order to obtain nice and well; readable results. A full chapter on graphs will explain many; more of the features of the class `TGraphErrors` and its relation to; other ROOT classes in much more detail. ## Histogra",MatchSource.DOCS,documentation/primer/ROOT_as_calculator.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md:10095,Usability,simpl,simple,10095,"(#f22). [f22]: figures/TGraphErrors_Example.png ""f22""; <a name=""f22""></a>. ![Visualisation of data points with errors using the class TGraphErrors. \label{f22}][f22]. Make sure the file `ExampleData.txt` is available in the directory from; which you started ROOT. Inspect this file now with your favourite; editor, or use the command `less ExampleData.txt` to inspect the file,; you will see that the format is very simple and easy to understand.; Lines beginning with `#` are ignored. It is very convenient to add some; comments about the type of data. The data itself consist of lines with; four real numbers each, representing the x- and y- coordinates and their; errors of each data point. The argument of the method `Draw(""AP"")` is important here. Behind the scenes,; it tells the `TGraphPainter` class to show the axes and to plot markers at the; *x* and *y* positions of the specified data points. Note that this simple; example relies on the default settings of ROOT, concerning the size of; the canvas holding the plot, the marker type and the line colours and; thickness used and so on. In a well-written, complete example, all this; would need to be specified explicitly in order to obtain nice and well; readable results. A full chapter on graphs will explain many; more of the features of the class `TGraphErrors` and its relation to; other ROOT classes in much more detail. ## Histograms in ROOT ##. Frequency distributions in ROOT are handled by a set of classes derived; from the histogram class `TH1`, in our case `TH1F`. The letter `F`; stands for ""float"", meaning that the data type `float` is used to store; the entries in one histogram bin. ``` {.cpp}; root [0] TF1 efunc(""efunc"",""exp([0]+[1]*x)"",0.,5.);; root [1] efunc.SetParameter(0,1);; root [2] efunc.SetParameter(1,-1);; root [3] TH1F h(""h"",""example histogram"",100,0.,5.);; root [4] for (int i=0;i<1000;i++) {h.Fill(efunc.GetRandom());}; root [5] h.Draw();; ```. The first three lines of this example define a function, an ",MatchSource.DOCS,documentation/primer/ROOT_as_calculator.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md:16942,Usability,guid,guide,16942,"` from the menu line of the window. It will pop up a file; selector box to allow you to choose the format, file name and target; directory to store the image. There is one very noticeable feature here:; you can store a plot as a root macro! In this macro, you find the C++; representation of all methods and classes involved in generating the; plot. This is a valuable source of information for your own macros,; which you will hopefully write after having worked through this; tutorial. Using ROOT's interactive capabilities is useful for a first exploration; of possibilities. Other ROOT classes you will encounter in this tutorial; have such graphical interfaces. We will not comment further on this,; just be aware of the existence of ROOT's interactive features and use; them if you find them convenient. Some trial-and-error is certainly necessary; to find your way through the huge number of menus and parameter; settings. ## ROOT Beginners' FAQ ##. At this point of the guide, some basic questions could have already come; to your mind. We will try to clarify some of them with further; explanations in the following. ### ROOT type declarations for basic data types ###. In the official ROOT documentation, you find special data types; replacing the normal ones, e.g. `Double_t`, `Float_t` or `Int_t`; replacing the standard `double`, `float` or `int` types. Using the ROOT; types makes it easier to port code between platforms (64/32 bit) or; operating systems (windows/Linux), as these types are mapped to suitable; ones in the ROOT header files. If you want adaptive code of this type,; use the ROOT type declarations. However, usually you do not need such; adaptive code, and you can safely use the standard C type declarations; for your private code, as we did and will do throughout this guide. If; you intend to become a ROOT developer, however, you better stick to the; official coding rules!. ### Configure ROOT at start-up ###. The behaviour of a ROOT session can be tailored with t",MatchSource.DOCS,documentation/primer/ROOT_as_calculator.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md:17766,Usability,guid,guide,17766," of the existence of ROOT's interactive features and use; them if you find them convenient. Some trial-and-error is certainly necessary; to find your way through the huge number of menus and parameter; settings. ## ROOT Beginners' FAQ ##. At this point of the guide, some basic questions could have already come; to your mind. We will try to clarify some of them with further; explanations in the following. ### ROOT type declarations for basic data types ###. In the official ROOT documentation, you find special data types; replacing the normal ones, e.g. `Double_t`, `Float_t` or `Int_t`; replacing the standard `double`, `float` or `int` types. Using the ROOT; types makes it easier to port code between platforms (64/32 bit) or; operating systems (windows/Linux), as these types are mapped to suitable; ones in the ROOT header files. If you want adaptive code of this type,; use the ROOT type declarations. However, usually you do not need such; adaptive code, and you can safely use the standard C type declarations; for your private code, as we did and will do throughout this guide. If; you intend to become a ROOT developer, however, you better stick to the; official coding rules!. ### Configure ROOT at start-up ###. The behaviour of a ROOT session can be tailored with the options in the; `.rootrc` file. Examples of the tunable parameters are the ones related; to the operating and window system, to the fonts to be used, to the; location of start-up files. At start-up, ROOT looks for a `.rootrc` file; in the following order:. - `./.rootrc //local directory`. - `$HOME/.rootrc //user directory`. - `$ROOTSYS/etc/system.rootrc //global ROOT directory`. If more than one `.rootrc` files are found in the search paths above,; the options are merged, with precedence local, user, global. The parsing; and interpretation of this file is handled by the ROOT class `TEnv`.; Have a look to its documentation if you need such rather advanced; features. The file `.rootrc` defines the location of",MatchSource.DOCS,documentation/primer/ROOT_as_calculator.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md:19220,Usability,guid,guide,19220," order:. - `./.rootrc //local directory`. - `$HOME/.rootrc //user directory`. - `$ROOTSYS/etc/system.rootrc //global ROOT directory`. If more than one `.rootrc` files are found in the search paths above,; the options are merged, with precedence local, user, global. The parsing; and interpretation of this file is handled by the ROOT class `TEnv`.; Have a look to its documentation if you need such rather advanced; features. The file `.rootrc` defines the location of two rather; important files inspected at start-up: `rootalias.C` and `rootlogon.C`.; They can contain code that needs to be loaded and executed at ROOT; startup. `rootalias.C` is only loaded and best used to define some often; used functions. `rootlogon.C` contains code that will be executed at; startup: this file is extremely useful for example to pre-load a custom; style for the plots created with ROOT. This is done most easily by; creating a new `TStyle` object with your preferred settings, as; described in the class reference guide, and then use the command; `gROOT->SetStyle(""MyStyleName"");` to make this new style definition the; default one. As an example, have a look in the file `rootlogon.C` coming; with this tutorial. Another relevant file is `rootlogoff.C` that it; called when the session is finished. ### ROOT command history ###. Every command typed at the ROOT prompt is stored in a file `.root_hist`; in your home directory. ROOT uses this file to allow for navigation in; the command history with the up-arrow and down-arrow keys. It is also; convenient to extract successful ROOT commands with the help of a text; editor for use in your own macros. ### ROOT Global Pointers ###. All global pointers in ROOT begin with a small ""g"". Some of them were; already implicitly introduced (for example in the section; [Configure ROOT at start-up](#configure-root-at-start-up)).; The most important among them are presented in the following:. - **[gROOT](https://root.cern.ch/doc/master/classTROOT.html)**: the `gRO",MatchSource.DOCS,documentation/primer/ROOT_as_calculator.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md:21304,Usability,learn,learnt,21304,"root_hist`; in your home directory. ROOT uses this file to allow for navigation in; the command history with the up-arrow and down-arrow keys. It is also; convenient to extract successful ROOT commands with the help of a text; editor for use in your own macros. ### ROOT Global Pointers ###. All global pointers in ROOT begin with a small ""g"". Some of them were; already implicitly introduced (for example in the section; [Configure ROOT at start-up](#configure-root-at-start-up)).; The most important among them are presented in the following:. - **[gROOT](https://root.cern.ch/doc/master/classTROOT.html)**: the `gROOT`; variable is the entry point to the ROOT system. Technically it is an; instance of the `TROOT` class. Using the `gROOT` pointer one has; access to basically every object created in a ROOT based program.; The `TROOT` object is essentially a container of several lists; pointing to the main `ROOT` objects. - **[gStyle](https://root.cern.ch/doc/master/classTStyle.html)**: By default; ROOT creates a default style that can be accessed via the `gStyle`; pointer. This class includes functions to set some of the following; object attributes. - Canvas; - Pad; - Histogram axis; - Lines; - Fill areas; - Text; - Markers; - Functions; - Histogram Statistics and Titles; - etc ... - **[gSystem](https://root.cern.ch/doc/master/classTSystem.html)**: An; instance of a base class defining a generic interface to the; underlying Operating System, in our case `TUnixSystem`. - **[gInterpreter](http://root.cern.ch/htmldoc/html/TInterpreter.html)**: The; entry point for the ROOT interpreter. Technically an abstraction level; over a singleton instance of `TCling`. At this point you have already learnt quite a bit about some basic; features of ROOT. ***Please move on to become an expert!***. [^2]: All ROOT classes' names start with the letter T. A notable exception is; RooFit. In this context all classes' names are of the form Roo*. Starting with; ROOT7, all names start with and R.; ",MatchSource.DOCS,documentation/primer/ROOT_as_calculator.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/root_in_python.md:360,Availability,avail,available,360,"# ROOT in Python #. ROOT offers the possibility to interface to Python via a set of bindings called; PyROOT.; Python is used in a wide variety of application areas and one of the most used; scripting languages today.; With the help of PyROOT it becomes possible to combine the power of a scripting; language with ROOT tools. Introductory material to Python is available from many; sources on the web, see e. g. http://docs.python.org. ## PyROOT ##. The access to ROOT classes and their methods in PyROOT is almost identical to C++; macros, except for the special language features of Python, most importantly dynamic; type declaration at the time of assignment. Coming back to our first example, simply; plotting a function in ROOT, the following C++ code:. ``` {.cpp}; TF1 *f1 = new TF1(""f2"",""[0]*sin([1]*x)/x"",0.,10.);; f1->SetParameter(0,1);; f1->SetParameter(1,1);; f1->Draw();; ```. in Python becomes:. ``` {.python}; import ROOT; f1 = ROOT.TF1(""f2"",""[0]*sin([1]*x)/x"",0.,10.); f1.SetParameter(0,1);; f1.SetParameter(1,1);; f1.Draw();; ```. A slightly more advanced example hands over data defined in the macro to the ROOT; class `TGraphErrors`. Note that a Python array can be used to pass data between; Python and ROOT. The first line in the Python script allows it to be executed; directly from the operating system, without the need to start the script from; python or the highly recommended powerful interactive shell ipython. The last line; in the python script is there to allow you to have a look at the graphical output; in the ROOT canvas before it disappears upon termination of the script. Here is the C++ version:. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/TGraphFit.C; ```. In Python it looks like this:. ``` {.python}; @ROOT_INCLUDE_FILE macros/TGraphFit.py; ```. Comparing the C++ and Python versions in these two examples, it now should be; clear how easy it is to convert any ROOT Macro in C++ to a Python version. As another example, let us revisit macro3 from Chapter 4. A straigh",MatchSource.DOCS,documentation/primer/root_in_python.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/root_in_python.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/root_in_python.md:277,Energy Efficiency,power,power,277,"# ROOT in Python #. ROOT offers the possibility to interface to Python via a set of bindings called; PyROOT.; Python is used in a wide variety of application areas and one of the most used; scripting languages today.; With the help of PyROOT it becomes possible to combine the power of a scripting; language with ROOT tools. Introductory material to Python is available from many; sources on the web, see e. g. http://docs.python.org. ## PyROOT ##. The access to ROOT classes and their methods in PyROOT is almost identical to C++; macros, except for the special language features of Python, most importantly dynamic; type declaration at the time of assignment. Coming back to our first example, simply; plotting a function in ROOT, the following C++ code:. ``` {.cpp}; TF1 *f1 = new TF1(""f2"",""[0]*sin([1]*x)/x"",0.,10.);; f1->SetParameter(0,1);; f1->SetParameter(1,1);; f1->Draw();; ```. in Python becomes:. ``` {.python}; import ROOT; f1 = ROOT.TF1(""f2"",""[0]*sin([1]*x)/x"",0.,10.); f1.SetParameter(0,1);; f1.SetParameter(1,1);; f1.Draw();; ```. A slightly more advanced example hands over data defined in the macro to the ROOT; class `TGraphErrors`. Note that a Python array can be used to pass data between; Python and ROOT. The first line in the Python script allows it to be executed; directly from the operating system, without the need to start the script from; python or the highly recommended powerful interactive shell ipython. The last line; in the python script is there to allow you to have a look at the graphical output; in the ROOT canvas before it disappears upon termination of the script. Here is the C++ version:. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/TGraphFit.C; ```. In Python it looks like this:. ``` {.python}; @ROOT_INCLUDE_FILE macros/TGraphFit.py; ```. Comparing the C++ and Python versions in these two examples, it now should be; clear how easy it is to convert any ROOT Macro in C++ to a Python version. As another example, let us revisit macro3 from Chapter 4. A straigh",MatchSource.DOCS,documentation/primer/root_in_python.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/root_in_python.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/root_in_python.md:1401,Energy Efficiency,power,powerful,1401,"uctory material to Python is available from many; sources on the web, see e. g. http://docs.python.org. ## PyROOT ##. The access to ROOT classes and their methods in PyROOT is almost identical to C++; macros, except for the special language features of Python, most importantly dynamic; type declaration at the time of assignment. Coming back to our first example, simply; plotting a function in ROOT, the following C++ code:. ``` {.cpp}; TF1 *f1 = new TF1(""f2"",""[0]*sin([1]*x)/x"",0.,10.);; f1->SetParameter(0,1);; f1->SetParameter(1,1);; f1->Draw();; ```. in Python becomes:. ``` {.python}; import ROOT; f1 = ROOT.TF1(""f2"",""[0]*sin([1]*x)/x"",0.,10.); f1.SetParameter(0,1);; f1.SetParameter(1,1);; f1.Draw();; ```. A slightly more advanced example hands over data defined in the macro to the ROOT; class `TGraphErrors`. Note that a Python array can be used to pass data between; Python and ROOT. The first line in the Python script allows it to be executed; directly from the operating system, without the need to start the script from; python or the highly recommended powerful interactive shell ipython. The last line; in the python script is there to allow you to have a look at the graphical output; in the ROOT canvas before it disappears upon termination of the script. Here is the C++ version:. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/TGraphFit.C; ```. In Python it looks like this:. ``` {.python}; @ROOT_INCLUDE_FILE macros/TGraphFit.py; ```. Comparing the C++ and Python versions in these two examples, it now should be; clear how easy it is to convert any ROOT Macro in C++ to a Python version. As another example, let us revisit macro3 from Chapter 4. A straight-forward; Python version relying on the ROOT class `TMath`:. ``` {.python}; @ROOT_INCLUDE_FILE macros/macro3.py; ```. ### More Python- less C++ ###. You may have noticed already that there are some Python modules providing; functionality similar to ROOT classes, which fit more seamlessly into your; Python code. A more “pythonic",MatchSource.DOCS,documentation/primer/root_in_python.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/root_in_python.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/root_in_python.md:4108,Energy Efficiency,power,powerful,4108,"y similar to ROOT classes, which fit more seamlessly into your; Python code. A more “pythonic” version of the above macro3 would use a replacement of the; ROOT class TMath for the provisioning of data to TGraphPolar. With the math; package, the part of the code becomes. ``` {.cpp}; import math; from array import array; from ROOT import TCanvas , TGraphPolar; ...; ipt=range(0,npoints); r=array('d',map(lambda x: x*(rmax-rmin)/(npoints-1.)+rmin,ipt)); theta=array('d',map(math.sin,r)); e=array('d',npoints*[0.]); ... ```. #### Customised Binning ####; This example combines comfortable handling of arrays in Python to define; variable bin sizes of a ROOT histogram. All we need to know is the interface; of the relevant ROOT class and its methods (from the ROOT documentation):. ``` {.cpp}; TH1F(const char* name , const char* title , Int_t nbinsx , const Double_t* xbins); ```. Here is the Python code:. ``` {.python}; import ROOT; from array import array; arrBins = array('d' ,(1 ,4 ,9 ,16) ) # array of bin edges; histo = ROOT.TH1F(""hist"", ""hist"", len(arrBins)-1, arrBins); # fill it with equally spaced numbers; for i in range (1 ,16) :; histo.Fill(i); histo.Draw (); ```. ## Custom code: from C++ to Python ##; The ROOT interpreter and type sytem offer interesting possibilities when it comes; to JITting of C++ code.; Take for example this header file, containing a class and a function. ```{.cpp}; // file cpp2pythonExample.h; #include ""stdio.h"". class A{; public:; A(int i):m_i(i){}; int getI() const {return m_i;}; private:; int m_i=0;; };. void printA(const A& a ){; printf (""The value of A instance is %i.\n"",a.getI());; }; ```. ```{ .python }; >>> import ROOT; >>> ROOT.gInterpreter.ProcessLine('#include ""cpp2pythonExample.h""'); >>> a = ROOT.A(123); >>> ROOT.printA(a); The value of A instance is 123.; ```. This example might seem trivial, but it shows a powerful ROOT feature.; C++ code can be JITted within PyROOT and the entities defined in C++ can be; transparently used in Python!",MatchSource.DOCS,documentation/primer/root_in_python.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/root_in_python.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/root_in_python.md:51,Integrability,interface,interface,51,"# ROOT in Python #. ROOT offers the possibility to interface to Python via a set of bindings called; PyROOT.; Python is used in a wide variety of application areas and one of the most used; scripting languages today.; With the help of PyROOT it becomes possible to combine the power of a scripting; language with ROOT tools. Introductory material to Python is available from many; sources on the web, see e. g. http://docs.python.org. ## PyROOT ##. The access to ROOT classes and their methods in PyROOT is almost identical to C++; macros, except for the special language features of Python, most importantly dynamic; type declaration at the time of assignment. Coming back to our first example, simply; plotting a function in ROOT, the following C++ code:. ``` {.cpp}; TF1 *f1 = new TF1(""f2"",""[0]*sin([1]*x)/x"",0.,10.);; f1->SetParameter(0,1);; f1->SetParameter(1,1);; f1->Draw();; ```. in Python becomes:. ``` {.python}; import ROOT; f1 = ROOT.TF1(""f2"",""[0]*sin([1]*x)/x"",0.,10.); f1.SetParameter(0,1);; f1.SetParameter(1,1);; f1.Draw();; ```. A slightly more advanced example hands over data defined in the macro to the ROOT; class `TGraphErrors`. Note that a Python array can be used to pass data between; Python and ROOT. The first line in the Python script allows it to be executed; directly from the operating system, without the need to start the script from; python or the highly recommended powerful interactive shell ipython. The last line; in the python script is there to allow you to have a look at the graphical output; in the ROOT canvas before it disappears upon termination of the script. Here is the C++ version:. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/TGraphFit.C; ```. In Python it looks like this:. ``` {.python}; @ROOT_INCLUDE_FILE macros/TGraphFit.py; ```. Comparing the C++ and Python versions in these two examples, it now should be; clear how easy it is to convert any ROOT Macro in C++ to a Python version. As another example, let us revisit macro3 from Chapter 4. A straigh",MatchSource.DOCS,documentation/primer/root_in_python.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/root_in_python.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/root_in_python.md:2932,Integrability,interface,interface,2932," revisit macro3 from Chapter 4. A straight-forward; Python version relying on the ROOT class `TMath`:. ``` {.python}; @ROOT_INCLUDE_FILE macros/macro3.py; ```. ### More Python- less C++ ###. You may have noticed already that there are some Python modules providing; functionality similar to ROOT classes, which fit more seamlessly into your; Python code. A more “pythonic” version of the above macro3 would use a replacement of the; ROOT class TMath for the provisioning of data to TGraphPolar. With the math; package, the part of the code becomes. ``` {.cpp}; import math; from array import array; from ROOT import TCanvas , TGraphPolar; ...; ipt=range(0,npoints); r=array('d',map(lambda x: x*(rmax-rmin)/(npoints-1.)+rmin,ipt)); theta=array('d',map(math.sin,r)); e=array('d',npoints*[0.]); ... ```. #### Customised Binning ####; This example combines comfortable handling of arrays in Python to define; variable bin sizes of a ROOT histogram. All we need to know is the interface; of the relevant ROOT class and its methods (from the ROOT documentation):. ``` {.cpp}; TH1F(const char* name , const char* title , Int_t nbinsx , const Double_t* xbins); ```. Here is the Python code:. ``` {.python}; import ROOT; from array import array; arrBins = array('d' ,(1 ,4 ,9 ,16) ) # array of bin edges; histo = ROOT.TH1F(""hist"", ""hist"", len(arrBins)-1, arrBins); # fill it with equally spaced numbers; for i in range (1 ,16) :; histo.Fill(i); histo.Draw (); ```. ## Custom code: from C++ to Python ##; The ROOT interpreter and type sytem offer interesting possibilities when it comes; to JITting of C++ code.; Take for example this header file, containing a class and a function. ```{.cpp}; // file cpp2pythonExample.h; #include ""stdio.h"". class A{; public:; A(int i):m_i(i){}; int getI() const {return m_i;}; private:; int m_i=0;; };. void printA(const A& a ){; printf (""The value of A instance is %i.\n"",a.getI());; }; ```. ```{ .python }; >>> import ROOT; >>> ROOT.gInterpreter.ProcessLine('#include ""cpp2",MatchSource.DOCS,documentation/primer/root_in_python.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/root_in_python.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/root_in_python.md:2865,Modifiability,variab,variable,2865,"xamples, it now should be; clear how easy it is to convert any ROOT Macro in C++ to a Python version. As another example, let us revisit macro3 from Chapter 4. A straight-forward; Python version relying on the ROOT class `TMath`:. ``` {.python}; @ROOT_INCLUDE_FILE macros/macro3.py; ```. ### More Python- less C++ ###. You may have noticed already that there are some Python modules providing; functionality similar to ROOT classes, which fit more seamlessly into your; Python code. A more “pythonic” version of the above macro3 would use a replacement of the; ROOT class TMath for the provisioning of data to TGraphPolar. With the math; package, the part of the code becomes. ``` {.cpp}; import math; from array import array; from ROOT import TCanvas , TGraphPolar; ...; ipt=range(0,npoints); r=array('d',map(lambda x: x*(rmax-rmin)/(npoints-1.)+rmin,ipt)); theta=array('d',map(math.sin,r)); e=array('d',npoints*[0.]); ... ```. #### Customised Binning ####; This example combines comfortable handling of arrays in Python to define; variable bin sizes of a ROOT histogram. All we need to know is the interface; of the relevant ROOT class and its methods (from the ROOT documentation):. ``` {.cpp}; TH1F(const char* name , const char* title , Int_t nbinsx , const Double_t* xbins); ```. Here is the Python code:. ``` {.python}; import ROOT; from array import array; arrBins = array('d' ,(1 ,4 ,9 ,16) ) # array of bin edges; histo = ROOT.TH1F(""hist"", ""hist"", len(arrBins)-1, arrBins); # fill it with equally spaced numbers; for i in range (1 ,16) :; histo.Fill(i); histo.Draw (); ```. ## Custom code: from C++ to Python ##; The ROOT interpreter and type sytem offer interesting possibilities when it comes; to JITting of C++ code.; Take for example this header file, containing a class and a function. ```{.cpp}; // file cpp2pythonExample.h; #include ""stdio.h"". class A{; public:; A(int i):m_i(i){}; int getI() const {return m_i;}; private:; int m_i=0;; };. void printA(const A& a ){; printf (""The val",MatchSource.DOCS,documentation/primer/root_in_python.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/root_in_python.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/root_in_python.md:453,Security,access,access,453,"# ROOT in Python #. ROOT offers the possibility to interface to Python via a set of bindings called; PyROOT.; Python is used in a wide variety of application areas and one of the most used; scripting languages today.; With the help of PyROOT it becomes possible to combine the power of a scripting; language with ROOT tools. Introductory material to Python is available from many; sources on the web, see e. g. http://docs.python.org. ## PyROOT ##. The access to ROOT classes and their methods in PyROOT is almost identical to C++; macros, except for the special language features of Python, most importantly dynamic; type declaration at the time of assignment. Coming back to our first example, simply; plotting a function in ROOT, the following C++ code:. ``` {.cpp}; TF1 *f1 = new TF1(""f2"",""[0]*sin([1]*x)/x"",0.,10.);; f1->SetParameter(0,1);; f1->SetParameter(1,1);; f1->Draw();; ```. in Python becomes:. ``` {.python}; import ROOT; f1 = ROOT.TF1(""f2"",""[0]*sin([1]*x)/x"",0.,10.); f1.SetParameter(0,1);; f1.SetParameter(1,1);; f1.Draw();; ```. A slightly more advanced example hands over data defined in the macro to the ROOT; class `TGraphErrors`. Note that a Python array can be used to pass data between; Python and ROOT. The first line in the Python script allows it to be executed; directly from the operating system, without the need to start the script from; python or the highly recommended powerful interactive shell ipython. The last line; in the python script is there to allow you to have a look at the graphical output; in the ROOT canvas before it disappears upon termination of the script. Here is the C++ version:. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/TGraphFit.C; ```. In Python it looks like this:. ``` {.python}; @ROOT_INCLUDE_FILE macros/TGraphFit.py; ```. Comparing the C++ and Python versions in these two examples, it now should be; clear how easy it is to convert any ROOT Macro in C++ to a Python version. As another example, let us revisit macro3 from Chapter 4. A straigh",MatchSource.DOCS,documentation/primer/root_in_python.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/root_in_python.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/root_in_python.md:696,Usability,simpl,simply,696,"# ROOT in Python #. ROOT offers the possibility to interface to Python via a set of bindings called; PyROOT.; Python is used in a wide variety of application areas and one of the most used; scripting languages today.; With the help of PyROOT it becomes possible to combine the power of a scripting; language with ROOT tools. Introductory material to Python is available from many; sources on the web, see e. g. http://docs.python.org. ## PyROOT ##. The access to ROOT classes and their methods in PyROOT is almost identical to C++; macros, except for the special language features of Python, most importantly dynamic; type declaration at the time of assignment. Coming back to our first example, simply; plotting a function in ROOT, the following C++ code:. ``` {.cpp}; TF1 *f1 = new TF1(""f2"",""[0]*sin([1]*x)/x"",0.,10.);; f1->SetParameter(0,1);; f1->SetParameter(1,1);; f1->Draw();; ```. in Python becomes:. ``` {.python}; import ROOT; f1 = ROOT.TF1(""f2"",""[0]*sin([1]*x)/x"",0.,10.); f1.SetParameter(0,1);; f1.SetParameter(1,1);; f1.Draw();; ```. A slightly more advanced example hands over data defined in the macro to the ROOT; class `TGraphErrors`. Note that a Python array can be used to pass data between; Python and ROOT. The first line in the Python script allows it to be executed; directly from the operating system, without the need to start the script from; python or the highly recommended powerful interactive shell ipython. The last line; in the python script is there to allow you to have a look at the graphical output; in the ROOT canvas before it disappears upon termination of the script. Here is the C++ version:. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/TGraphFit.C; ```. In Python it looks like this:. ``` {.python}; @ROOT_INCLUDE_FILE macros/TGraphFit.py; ```. Comparing the C++ and Python versions in these two examples, it now should be; clear how easy it is to convert any ROOT Macro in C++ to a Python version. As another example, let us revisit macro3 from Chapter 4. A straigh",MatchSource.DOCS,documentation/primer/root_in_python.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/root_in_python.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/root_in_python.md:1859,Usability,clear,clear,1859,"ameter(1,1);; f1->Draw();; ```. in Python becomes:. ``` {.python}; import ROOT; f1 = ROOT.TF1(""f2"",""[0]*sin([1]*x)/x"",0.,10.); f1.SetParameter(0,1);; f1.SetParameter(1,1);; f1.Draw();; ```. A slightly more advanced example hands over data defined in the macro to the ROOT; class `TGraphErrors`. Note that a Python array can be used to pass data between; Python and ROOT. The first line in the Python script allows it to be executed; directly from the operating system, without the need to start the script from; python or the highly recommended powerful interactive shell ipython. The last line; in the python script is there to allow you to have a look at the graphical output; in the ROOT canvas before it disappears upon termination of the script. Here is the C++ version:. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/TGraphFit.C; ```. In Python it looks like this:. ``` {.python}; @ROOT_INCLUDE_FILE macros/TGraphFit.py; ```. Comparing the C++ and Python versions in these two examples, it now should be; clear how easy it is to convert any ROOT Macro in C++ to a Python version. As another example, let us revisit macro3 from Chapter 4. A straight-forward; Python version relying on the ROOT class `TMath`:. ``` {.python}; @ROOT_INCLUDE_FILE macros/macro3.py; ```. ### More Python- less C++ ###. You may have noticed already that there are some Python modules providing; functionality similar to ROOT classes, which fit more seamlessly into your; Python code. A more “pythonic” version of the above macro3 would use a replacement of the; ROOT class TMath for the provisioning of data to TGraphPolar. With the math; package, the part of the code becomes. ``` {.cpp}; import math; from array import array; from ROOT import TCanvas , TGraphPolar; ...; ipt=range(0,npoints); r=array('d',map(lambda x: x*(rmax-rmin)/(npoints-1.)+rmin,ipt)); theta=array('d',map(math.sin,r)); e=array('d',npoints*[0.]); ... ```. #### Customised Binning ####; This example combines comfortable handling of arrays in Python to",MatchSource.DOCS,documentation/primer/root_in_python.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/root_in_python.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md:2677,Availability,error,errors,2677,"suppress title box; ...; ```. Next, you should create a canvas for graphical output, with size,; subdivisions and format suitable to your needs, see documentation of; class `TCanvas`:. ``` {.cpp}; TCanvas c1(""c1"",""<Title>"",0,0,400,300); // create a canvas, specify position and size in pixels; c1.Divide(2,2); //set subdivisions, called pads; c1.cd(1); //change to pad 1 of canvas c1; ```. These parts of a well-written macro are pretty standard, and you should; remember to include pieces of code like in the examples above to make; sure your plots always look as you had intended. Below, in section [Interpretation and Compilation](#interpretation-and-compilation), some more code fragments; will be shown, allowing you to use the system compiler to compile macros for; more efficient execution, or turn macros into stand-alone applications linked; against the ROOT libraries. ## A more complete example ##. Let us now look at a rather complete example of a typical task in data; analysis, a macro that constructs a graph with errors, fits a (linear); model to it and saves it as an image. To run this macro, simply type in; the shell:. ``` {.cpp}; > root macro1.C; ```. The code is built around the ROOT class `TGraphErrors`, which was; already introduced previously. Have a look at it in the class reference; guide, where you will also find further examples. The macro shown below; uses additional classes, `TF1` to define a function, `TCanvas` to define; size and properties of the window used for our plot, and `TLegend` to; add a nice legend. For the moment, ignore the commented include; statements for header files, they will only become important at the end; in section [Interpretation and Compilation](#interpretation-and-compilation). ``` {.cpp .numberLines}; @ROOT_INCLUDE_FILE macros/macro1.C; ```. Let's comment it in detail:. - Line *13*: the name of the principal function (it plays the role of; the ""main"" function in compiled programs) in the macro file. It has; to be the same as ",MatchSource.DOCS,documentation/primer/your_first_ROOT_macro.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md:3836,Availability,error,errors,3836,"he code is built around the ROOT class `TGraphErrors`, which was; already introduced previously. Have a look at it in the class reference; guide, where you will also find further examples. The macro shown below; uses additional classes, `TF1` to define a function, `TCanvas` to define; size and properties of the window used for our plot, and `TLegend` to; add a nice legend. For the moment, ignore the commented include; statements for header files, they will only become important at the end; in section [Interpretation and Compilation](#interpretation-and-compilation). ``` {.cpp .numberLines}; @ROOT_INCLUDE_FILE macros/macro1.C; ```. Let's comment it in detail:. - Line *13*: the name of the principal function (it plays the role of; the ""main"" function in compiled programs) in the macro file. It has; to be the same as the file name without extension. - Line *24-25*: instance of the `TGraphErrors` class. The constructor; takes the number of points and the pointers to the arrays of; x values, y values, x errors (in this case none,; represented by the NULL pointer) and y errors. The second line; defines in one shot the title of the graph and the titles of the two; axes, separated by a "";"". - Line *28-30*: These three lines are rather intuitive right ? To understand; better the enumerators for colours and styles see the reference for; the `TColor` and `TMarker` classes. - Line *33*: the canvas object that will host the drawn objects. The; ""memory leak"" is intentional, to make the object existing also out; of the macro1 scope. - Line *36*: the method *DrawClone* draws a clone of the object on the; canvas. It *has to be* a clone, to survive after the scope of; `macro1`, and be displayed on screen after the end of the macro; execution. The string option ""APE"" stands for:. - *A* imposes the drawing of the Axes. - *P* imposes the drawing of the graph's markers. - *E* imposes the drawing of the graph's error bars. - Line *39*: define a mathematical function. There are several way",MatchSource.DOCS,documentation/primer/your_first_ROOT_macro.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md:3903,Availability,error,errors,3903,"he code is built around the ROOT class `TGraphErrors`, which was; already introduced previously. Have a look at it in the class reference; guide, where you will also find further examples. The macro shown below; uses additional classes, `TF1` to define a function, `TCanvas` to define; size and properties of the window used for our plot, and `TLegend` to; add a nice legend. For the moment, ignore the commented include; statements for header files, they will only become important at the end; in section [Interpretation and Compilation](#interpretation-and-compilation). ``` {.cpp .numberLines}; @ROOT_INCLUDE_FILE macros/macro1.C; ```. Let's comment it in detail:. - Line *13*: the name of the principal function (it plays the role of; the ""main"" function in compiled programs) in the macro file. It has; to be the same as the file name without extension. - Line *24-25*: instance of the `TGraphErrors` class. The constructor; takes the number of points and the pointers to the arrays of; x values, y values, x errors (in this case none,; represented by the NULL pointer) and y errors. The second line; defines in one shot the title of the graph and the titles of the two; axes, separated by a "";"". - Line *28-30*: These three lines are rather intuitive right ? To understand; better the enumerators for colours and styles see the reference for; the `TColor` and `TMarker` classes. - Line *33*: the canvas object that will host the drawn objects. The; ""memory leak"" is intentional, to make the object existing also out; of the macro1 scope. - Line *36*: the method *DrawClone* draws a clone of the object on the; canvas. It *has to be* a clone, to survive after the scope of; `macro1`, and be displayed on screen after the end of the macro; execution. The string option ""APE"" stands for:. - *A* imposes the drawing of the Axes. - *P* imposes the drawing of the graph's markers. - *E* imposes the drawing of the graph's error bars. - Line *39*: define a mathematical function. There are several way",MatchSource.DOCS,documentation/primer/your_first_ROOT_macro.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md:4744,Availability,error,error,4744,"class. The constructor; takes the number of points and the pointers to the arrays of; x values, y values, x errors (in this case none,; represented by the NULL pointer) and y errors. The second line; defines in one shot the title of the graph and the titles of the two; axes, separated by a "";"". - Line *28-30*: These three lines are rather intuitive right ? To understand; better the enumerators for colours and styles see the reference for; the `TColor` and `TMarker` classes. - Line *33*: the canvas object that will host the drawn objects. The; ""memory leak"" is intentional, to make the object existing also out; of the macro1 scope. - Line *36*: the method *DrawClone* draws a clone of the object on the; canvas. It *has to be* a clone, to survive after the scope of; `macro1`, and be displayed on screen after the end of the macro; execution. The string option ""APE"" stands for:. - *A* imposes the drawing of the Axes. - *P* imposes the drawing of the graph's markers. - *E* imposes the drawing of the graph's error bars. - Line *39*: define a mathematical function. There are several ways to; accomplish this, but in this case the constructor accepts the name; of the function, the formula, and the function range. - Line *41*: maquillage. Try to give a look to the line styles at your; disposal visiting the documentation of the `TLine` class. - Line *43*: fits the *f* function to the graph, observe that the; pointer is passed. It is more interesting to look at the output on; the screen to see the parameters values and other crucial; information that we will learn to read at the end of this guide. - Line *44*: again draws the clone of the object on the canvas. The; ""Same"" option avoids the cancellation of the already drawn objects,; in our case, the graph. The function *f* will be drawn using the *same* axis; system defined by the previously drawn graph. - Line *47-52*: completes the plot with a legend, represented by a; `TLegend` instance. The constructor takes as parameters the ",MatchSource.DOCS,documentation/primer/your_first_ROOT_macro.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md:7624,Availability,avail,available,7624,"es, isn't it ?. [f31]: figures/graf_with_law.png ""f31""; <a name=""f31""></a>. ![Your first plot with data points, a fit of an analytical function, a; legend and some additional information in the form of graphics; primitives and text. A well formatted plot, clear for the reader is; crucial to communicate the relevance of your results to the; reader.\label{f31}][f31]. ## Summary of Visual effects. ### Colours and Graph Markers. We have seen that to specify a colour, some identifiers like kWhite,; kRed or kBlue can be specified for markers, lines, arrows etc. The; complete summary of colours is represented by the ROOT ""[colour; wheel](https://root.cern.ch/doc/master/classTColor.html#C02)"". To know more; about the full story, refer to the online documentation of `TColor`. ROOT provides several [graphics; markers](https://root.cern.ch/doc/master/classTAttMarker.html#M2) types. Select; the most suited symbols for your plot among dots, triangles, crosses or; stars. An alternative set of names for the markers is available. ### Arrows and Lines. The macro line *55* shows how to define an arrow and draw it. The class; representing arrows is `TArrow`, which inherits from `TLine`. The; constructors of lines and arrows always contain the coordinates of the; endpoints. Arrows also foresee parameters to [specify; their](https://root.cern.ch/doc/master/classTArrow.html) shapes. Do not; underestimate the role of lines and arrows in your plots. Since each; plot should contain a message, it is convenient to stress it with; additional graphics primitives. ### Text. Also text plays a fundamental role in making the plots self-explanatory.; A possibility to add text in your plot is provided by the `TLatex`; class. The objects of this class are constructed with the coordinates of; the bottom-left corner of the text and a string which contains the text; itself. The real twist is that ordinary; [Latex mathematical symbols](https://root.cern.ch/doc/master/classTLatex.html#L5); are automaticall",MatchSource.DOCS,documentation/primer/your_first_ROOT_macro.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md:9755,Availability,avail,available,9755,"athText interface](https://root.cern.ch/doc/master/classTMathText.html); is invoked. It provides the plain TeX syntax and allow to access character's; set like Russian and Japanese. ## Interpretation and Compilation. As you observed, up to now we heavily exploited the capabilities of ROOT; for interpreting our code, more than compiling and then executing. This; is sufficient for a wide range of applications, but you might have; already asked yourself ""how can this code be compiled ?"". There are two; answers. ### Compile a Macro with ACLiC. ACLiC will create for you a compiled dynamic library for your macro,; without any effort from your side, except the insertion of the; appropriate header files in lines *5--11*. In this example, they are; already included. To generate an object library from the macro code, from inside the; interpreter type (please note the ""+""):. ``` {.cpp}; root [1] .L macro1.C+; ```. Once this operation is accomplished, the macro symbols will be available; in memory and you will be able to execute it simply by calling from; inside the interpreter:. ``` {.cpp}; root [2] macro1(); ```. ### Compile a Macro with the Compiler. A plethora of excellent compilers are available, both free and; commercial. We will refer to the `GCC` compiler in the following. In; this case, you have to include the appropriate headers in the code and; then exploit the *root-config* tool for the automatic settings of all; the compiler flags. *root-config* is a script that comes with ROOT; it; prints all flags and libraries needed to compile code and link it with; the ROOT libraries. In order to make the code executable stand-alone, an; entry point for the operating system is needed, in C++ this is the; procedure `int main();`. The easiest way to turn a ROOT macro code into; a stand-alone application is to add the following ""dressing code"" at the; end of the macro file. This defines the procedure main, the only purpose; of which is to call your macro:. ``` {.cpp}; int main() ",MatchSource.DOCS,documentation/primer/your_first_ROOT_macro.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md:9973,Availability,avail,available,9973,"on and Compilation. As you observed, up to now we heavily exploited the capabilities of ROOT; for interpreting our code, more than compiling and then executing. This; is sufficient for a wide range of applications, but you might have; already asked yourself ""how can this code be compiled ?"". There are two; answers. ### Compile a Macro with ACLiC. ACLiC will create for you a compiled dynamic library for your macro,; without any effort from your side, except the insertion of the; appropriate header files in lines *5--11*. In this example, they are; already included. To generate an object library from the macro code, from inside the; interpreter type (please note the ""+""):. ``` {.cpp}; root [1] .L macro1.C+; ```. Once this operation is accomplished, the macro symbols will be available; in memory and you will be able to execute it simply by calling from; inside the interpreter:. ``` {.cpp}; root [2] macro1(); ```. ### Compile a Macro with the Compiler. A plethora of excellent compilers are available, both free and; commercial. We will refer to the `GCC` compiler in the following. In; this case, you have to include the appropriate headers in the code and; then exploit the *root-config* tool for the automatic settings of all; the compiler flags. *root-config* is a script that comes with ROOT; it; prints all flags and libraries needed to compile code and link it with; the ROOT libraries. In order to make the code executable stand-alone, an; entry point for the operating system is needed, in C++ this is the; procedure `int main();`. The easiest way to turn a ROOT macro code into; a stand-alone application is to add the following ""dressing code"" at the; end of the macro file. This defines the procedure main, the only purpose; of which is to call your macro:. ``` {.cpp}; int main() {; ExampleMacro();; return 0;; }; ```. To create a stand-alone program from a macro called `ExampleMacro.C`, simply type. ``` {.cpp}; > g++ -o ExampleMacro ExampleMacro.C `root-config --cflags --li",MatchSource.DOCS,documentation/primer/your_first_ROOT_macro.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md:11206,Availability,avail,available,11206,"e code and; then exploit the *root-config* tool for the automatic settings of all; the compiler flags. *root-config* is a script that comes with ROOT; it; prints all flags and libraries needed to compile code and link it with; the ROOT libraries. In order to make the code executable stand-alone, an; entry point for the operating system is needed, in C++ this is the; procedure `int main();`. The easiest way to turn a ROOT macro code into; a stand-alone application is to add the following ""dressing code"" at the; end of the macro file. This defines the procedure main, the only purpose; of which is to call your macro:. ``` {.cpp}; int main() {; ExampleMacro();; return 0;; }; ```. To create a stand-alone program from a macro called `ExampleMacro.C`, simply type. ``` {.cpp}; > g++ -o ExampleMacro ExampleMacro.C `root-config --cflags --libs`; ```. and execute it by typing. ``` {.cpp}; > ./ExampleMacro; ```. This procedure will, however, not give access to the ROOT graphics, as; neither control of mouse or keyboard events nor access to the graphics; windows of ROOT is available. If you want your stand-alone application; have display graphics output and respond to mouse and keyboard, a; slightly more complex piece of code can be used. In the example below, a; macro `ExampleMacro_GUI` is executed by the ROOT class `TApplication`. As; a additional feature, this code example offers access to parameters; eventually passed to the program when started from the command line.; Here is the code fragment:. ``` {.cpp}; void StandaloneApplication(int argc, char** argv) {; // eventually, evaluate the application parameters argc, argv; // ==>> here the ROOT macro is called; ExampleMacro_GUI();; }; // This is the standard ""main"" of C++ starting; // a ROOT application; int main(int argc, char** argv) {; TApplication app(""ROOT Application"", &argc, argv);; StandaloneApplication(app.Argc(), app.Argv());; app.Run();; return 0;; }; ```. Compile the code with. ``` {.cpp}; > g++ -o ExampleMacro_GU",MatchSource.DOCS,documentation/primer/your_first_ROOT_macro.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md:2425,Energy Efficiency,efficient,efficient,2425,"OOT->SetStyle(""Plain""); // set plain TStyle; gStyle->SetOptStat(111111); // draw statistics on plots,; // (0) for no output; gStyle->SetOptFit(1111); // draw fit results on plot,; // (0) for no ouput; gStyle->SetPalette(57); // set color map; gStyle->SetOptTitle(0); // suppress title box; ...; ```. Next, you should create a canvas for graphical output, with size,; subdivisions and format suitable to your needs, see documentation of; class `TCanvas`:. ``` {.cpp}; TCanvas c1(""c1"",""<Title>"",0,0,400,300); // create a canvas, specify position and size in pixels; c1.Divide(2,2); //set subdivisions, called pads; c1.cd(1); //change to pad 1 of canvas c1; ```. These parts of a well-written macro are pretty standard, and you should; remember to include pieces of code like in the examples above to make; sure your plots always look as you had intended. Below, in section [Interpretation and Compilation](#interpretation-and-compilation), some more code fragments; will be shown, allowing you to use the system compiler to compile macros for; more efficient execution, or turn macros into stand-alone applications linked; against the ROOT libraries. ## A more complete example ##. Let us now look at a rather complete example of a typical task in data; analysis, a macro that constructs a graph with errors, fits a (linear); model to it and saves it as an image. To run this macro, simply type in; the shell:. ``` {.cpp}; > root macro1.C; ```. The code is built around the ROOT class `TGraphErrors`, which was; already introduced previously. Have a look at it in the class reference; guide, where you will also find further examples. The macro shown below; uses additional classes, `TF1` to define a function, `TCanvas` to define; size and properties of the window used for our plot, and `TLegend` to; add a nice legend. For the moment, ignore the commented include; statements for header files, they will only become important at the end; in section [Interpretation and Compilation](#interpretation-a",MatchSource.DOCS,documentation/primer/your_first_ROOT_macro.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md:8089,Integrability,message,message,8089,"or kBlue can be specified for markers, lines, arrows etc. The; complete summary of colours is represented by the ROOT ""[colour; wheel](https://root.cern.ch/doc/master/classTColor.html#C02)"". To know more; about the full story, refer to the online documentation of `TColor`. ROOT provides several [graphics; markers](https://root.cern.ch/doc/master/classTAttMarker.html#M2) types. Select; the most suited symbols for your plot among dots, triangles, crosses or; stars. An alternative set of names for the markers is available. ### Arrows and Lines. The macro line *55* shows how to define an arrow and draw it. The class; representing arrows is `TArrow`, which inherits from `TLine`. The; constructors of lines and arrows always contain the coordinates of the; endpoints. Arrows also foresee parameters to [specify; their](https://root.cern.ch/doc/master/classTArrow.html) shapes. Do not; underestimate the role of lines and arrows in your plots. Since each; plot should contain a message, it is convenient to stress it with; additional graphics primitives. ### Text. Also text plays a fundamental role in making the plots self-explanatory.; A possibility to add text in your plot is provided by the `TLatex`; class. The objects of this class are constructed with the coordinates of; the bottom-left corner of the text and a string which contains the text; itself. The real twist is that ordinary; [Latex mathematical symbols](https://root.cern.ch/doc/master/classTLatex.html#L5); are automatically interpreted, you just need to replace the ""\\"" by a ""\#"". If; [""\\"" is used as control character](https://root.cern.ch/doc/master/classTLatex.html#L14); , then the; [TMathText interface](https://root.cern.ch/doc/master/classTMathText.html); is invoked. It provides the plain TeX syntax and allow to access character's; set like Russian and Japanese. ## Interpretation and Compilation. As you observed, up to now we heavily exploited the capabilities of ROOT; for interpreting our code, more than compili",MatchSource.DOCS,documentation/primer/your_first_ROOT_macro.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md:8783,Integrability,interface,interface,8783,"from `TLine`. The; constructors of lines and arrows always contain the coordinates of the; endpoints. Arrows also foresee parameters to [specify; their](https://root.cern.ch/doc/master/classTArrow.html) shapes. Do not; underestimate the role of lines and arrows in your plots. Since each; plot should contain a message, it is convenient to stress it with; additional graphics primitives. ### Text. Also text plays a fundamental role in making the plots self-explanatory.; A possibility to add text in your plot is provided by the `TLatex`; class. The objects of this class are constructed with the coordinates of; the bottom-left corner of the text and a string which contains the text; itself. The real twist is that ordinary; [Latex mathematical symbols](https://root.cern.ch/doc/master/classTLatex.html#L5); are automatically interpreted, you just need to replace the ""\\"" by a ""\#"". If; [""\\"" is used as control character](https://root.cern.ch/doc/master/classTLatex.html#L14); , then the; [TMathText interface](https://root.cern.ch/doc/master/classTMathText.html); is invoked. It provides the plain TeX syntax and allow to access character's; set like Russian and Japanese. ## Interpretation and Compilation. As you observed, up to now we heavily exploited the capabilities of ROOT; for interpreting our code, more than compiling and then executing. This; is sufficient for a wide range of applications, but you might have; already asked yourself ""how can this code be compiled ?"". There are two; answers. ### Compile a Macro with ACLiC. ACLiC will create for you a compiled dynamic library for your macro,; without any effort from your side, except the insertion of the; appropriate header files in lines *5--11*. In this example, they are; already included. To generate an object library from the macro code, from inside the; interpreter type (please note the ""+""):. ``` {.cpp}; root [1] .L macro1.C+; ```. Once this operation is accomplished, the macro symbols will be available; in memory an",MatchSource.DOCS,documentation/primer/your_first_ROOT_macro.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md:7769,Modifiability,inherit,inherits,7769,"egend and some additional information in the form of graphics; primitives and text. A well formatted plot, clear for the reader is; crucial to communicate the relevance of your results to the; reader.\label{f31}][f31]. ## Summary of Visual effects. ### Colours and Graph Markers. We have seen that to specify a colour, some identifiers like kWhite,; kRed or kBlue can be specified for markers, lines, arrows etc. The; complete summary of colours is represented by the ROOT ""[colour; wheel](https://root.cern.ch/doc/master/classTColor.html#C02)"". To know more; about the full story, refer to the online documentation of `TColor`. ROOT provides several [graphics; markers](https://root.cern.ch/doc/master/classTAttMarker.html#M2) types. Select; the most suited symbols for your plot among dots, triangles, crosses or; stars. An alternative set of names for the markers is available. ### Arrows and Lines. The macro line *55* shows how to define an arrow and draw it. The class; representing arrows is `TArrow`, which inherits from `TLine`. The; constructors of lines and arrows always contain the coordinates of the; endpoints. Arrows also foresee parameters to [specify; their](https://root.cern.ch/doc/master/classTArrow.html) shapes. Do not; underestimate the role of lines and arrows in your plots. Since each; plot should contain a message, it is convenient to stress it with; additional graphics primitives. ### Text. Also text plays a fundamental role in making the plots self-explanatory.; A possibility to add text in your plot is provided by the `TLatex`; class. The objects of this class are constructed with the coordinates of; the bottom-left corner of the text and a string which contains the text; itself. The real twist is that ordinary; [Latex mathematical symbols](https://root.cern.ch/doc/master/classTLatex.html#L5); are automatically interpreted, you just need to replace the ""\\"" by a ""\#"". If; [""\\"" is used as control character](https://root.cern.ch/doc/master/classTLatex.html#L",MatchSource.DOCS,documentation/primer/your_first_ROOT_macro.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md:10164,Modifiability,config,config,10164,"cient for a wide range of applications, but you might have; already asked yourself ""how can this code be compiled ?"". There are two; answers. ### Compile a Macro with ACLiC. ACLiC will create for you a compiled dynamic library for your macro,; without any effort from your side, except the insertion of the; appropriate header files in lines *5--11*. In this example, they are; already included. To generate an object library from the macro code, from inside the; interpreter type (please note the ""+""):. ``` {.cpp}; root [1] .L macro1.C+; ```. Once this operation is accomplished, the macro symbols will be available; in memory and you will be able to execute it simply by calling from; inside the interpreter:. ``` {.cpp}; root [2] macro1(); ```. ### Compile a Macro with the Compiler. A plethora of excellent compilers are available, both free and; commercial. We will refer to the `GCC` compiler in the following. In; this case, you have to include the appropriate headers in the code and; then exploit the *root-config* tool for the automatic settings of all; the compiler flags. *root-config* is a script that comes with ROOT; it; prints all flags and libraries needed to compile code and link it with; the ROOT libraries. In order to make the code executable stand-alone, an; entry point for the operating system is needed, in C++ this is the; procedure `int main();`. The easiest way to turn a ROOT macro code into; a stand-alone application is to add the following ""dressing code"" at the; end of the macro file. This defines the procedure main, the only purpose; of which is to call your macro:. ``` {.cpp}; int main() {; ExampleMacro();; return 0;; }; ```. To create a stand-alone program from a macro called `ExampleMacro.C`, simply type. ``` {.cpp}; > g++ -o ExampleMacro ExampleMacro.C `root-config --cflags --libs`; ```. and execute it by typing. ``` {.cpp}; > ./ExampleMacro; ```. This procedure will, however, not give access to the ROOT graphics, as; neither control of mouse or keybo",MatchSource.DOCS,documentation/primer/your_first_ROOT_macro.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md:10238,Modifiability,config,config,10238,"Macro with ACLiC. ACLiC will create for you a compiled dynamic library for your macro,; without any effort from your side, except the insertion of the; appropriate header files in lines *5--11*. In this example, they are; already included. To generate an object library from the macro code, from inside the; interpreter type (please note the ""+""):. ``` {.cpp}; root [1] .L macro1.C+; ```. Once this operation is accomplished, the macro symbols will be available; in memory and you will be able to execute it simply by calling from; inside the interpreter:. ``` {.cpp}; root [2] macro1(); ```. ### Compile a Macro with the Compiler. A plethora of excellent compilers are available, both free and; commercial. We will refer to the `GCC` compiler in the following. In; this case, you have to include the appropriate headers in the code and; then exploit the *root-config* tool for the automatic settings of all; the compiler flags. *root-config* is a script that comes with ROOT; it; prints all flags and libraries needed to compile code and link it with; the ROOT libraries. In order to make the code executable stand-alone, an; entry point for the operating system is needed, in C++ this is the; procedure `int main();`. The easiest way to turn a ROOT macro code into; a stand-alone application is to add the following ""dressing code"" at the; end of the macro file. This defines the procedure main, the only purpose; of which is to call your macro:. ``` {.cpp}; int main() {; ExampleMacro();; return 0;; }; ```. To create a stand-alone program from a macro called `ExampleMacro.C`, simply type. ``` {.cpp}; > g++ -o ExampleMacro ExampleMacro.C `root-config --cflags --libs`; ```. and execute it by typing. ``` {.cpp}; > ./ExampleMacro; ```. This procedure will, however, not give access to the ROOT graphics, as; neither control of mouse or keyboard events nor access to the graphics; windows of ROOT is available. If you want your stand-alone application; have display graphics output and respond to ",MatchSource.DOCS,documentation/primer/your_first_ROOT_macro.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md:10952,Modifiability,config,config,10952,"pilers are available, both free and; commercial. We will refer to the `GCC` compiler in the following. In; this case, you have to include the appropriate headers in the code and; then exploit the *root-config* tool for the automatic settings of all; the compiler flags. *root-config* is a script that comes with ROOT; it; prints all flags and libraries needed to compile code and link it with; the ROOT libraries. In order to make the code executable stand-alone, an; entry point for the operating system is needed, in C++ this is the; procedure `int main();`. The easiest way to turn a ROOT macro code into; a stand-alone application is to add the following ""dressing code"" at the; end of the macro file. This defines the procedure main, the only purpose; of which is to call your macro:. ``` {.cpp}; int main() {; ExampleMacro();; return 0;; }; ```. To create a stand-alone program from a macro called `ExampleMacro.C`, simply type. ``` {.cpp}; > g++ -o ExampleMacro ExampleMacro.C `root-config --cflags --libs`; ```. and execute it by typing. ``` {.cpp}; > ./ExampleMacro; ```. This procedure will, however, not give access to the ROOT graphics, as; neither control of mouse or keyboard events nor access to the graphics; windows of ROOT is available. If you want your stand-alone application; have display graphics output and respond to mouse and keyboard, a; slightly more complex piece of code can be used. In the example below, a; macro `ExampleMacro_GUI` is executed by the ROOT class `TApplication`. As; a additional feature, this code example offers access to parameters; eventually passed to the program when started from the command line.; Here is the code fragment:. ``` {.cpp}; void StandaloneApplication(int argc, char** argv) {; // eventually, evaluate the application parameters argc, argv; // ==>> here the ROOT macro is called; ExampleMacro_GUI();; }; // This is the standard ""main"" of C++ starting; // a ROOT application; int main(int argc, char** argv) {; TApplication app(""ROOT A",MatchSource.DOCS,documentation/primer/your_first_ROOT_macro.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md:12154,Modifiability,config,config,12154,"ript that comes with ROOT; it; prints all flags and libraries needed to compile code and link it with; the ROOT libraries. In order to make the code executable stand-alone, an; entry point for the operating system is needed, in C++ this is the; procedure `int main();`. The easiest way to turn a ROOT macro code into; a stand-alone application is to add the following ""dressing code"" at the; end of the macro file. This defines the procedure main, the only purpose; of which is to call your macro:. ``` {.cpp}; int main() {; ExampleMacro();; return 0;; }; ```. To create a stand-alone program from a macro called `ExampleMacro.C`, simply type. ``` {.cpp}; > g++ -o ExampleMacro ExampleMacro.C `root-config --cflags --libs`; ```. and execute it by typing. ``` {.cpp}; > ./ExampleMacro; ```. This procedure will, however, not give access to the ROOT graphics, as; neither control of mouse or keyboard events nor access to the graphics; windows of ROOT is available. If you want your stand-alone application; have display graphics output and respond to mouse and keyboard, a; slightly more complex piece of code can be used. In the example below, a; macro `ExampleMacro_GUI` is executed by the ROOT class `TApplication`. As; a additional feature, this code example offers access to parameters; eventually passed to the program when started from the command line.; Here is the code fragment:. ``` {.cpp}; void StandaloneApplication(int argc, char** argv) {; // eventually, evaluate the application parameters argc, argv; // ==>> here the ROOT macro is called; ExampleMacro_GUI();; }; // This is the standard ""main"" of C++ starting; // a ROOT application; int main(int argc, char** argv) {; TApplication app(""ROOT Application"", &argc, argv);; StandaloneApplication(app.Argc(), app.Argv());; app.Run();; return 0;; }; ```. Compile the code with. ``` {.cpp}; > g++ -o ExampleMacro_GUI ExampleMacro_GUI `root-config --cflags --libs`; ```. and execute the program with. ``` {.cpp}; > ./ExampleMacro_GUI; ```; ",MatchSource.DOCS,documentation/primer/your_first_ROOT_macro.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md:334,Performance,load,load,334,"# ROOT Macros #. You know how other books go on and on about programming fundamentals and; finally work up to building a complete, working program ? Let's skip all; that. In this guide, we will describe macros executed by the ROOT C++; interpreter Cling. It is relatively easy to compile a macro, either as a pre-compiled; library to load into ROOT, or as a stand-alone application, by adding; some include statements for header file or some ""dressing code"" to any; macro. ## General Remarks on ROOT macros ##. If you have a number of lines which you were able to execute at the ROOT; prompt, they can be turned into a ROOT macro by giving them a name which; corresponds to the file name without extension. The general structure; for a macro stored in file `MacroName.C` is. ``` {.cpp}; void MacroName() {; < ...; your lines of C++ code; ... >; }; ```. The macro is executed by typing. ``` {.cpp}; > root MacroName.C; ```. at the system prompt, or executed using `.x`. ``` {.cpp}; > root; root [0] .x MacroName.C; ```. at the ROOT prompt. or it can be loaded into a ROOT session and then; be executed by typing. ``` {.cpp}; root [0].L MacroName.C; root [1] MacroName();; ```. at the ROOT prompt. Note that more than one macro can be loaded this; way, as each macro has a unique name in the ROOT name space. A small set; of options can help making your plot nicer. ``` {.cpp}; gROOT->SetStyle(""Plain""); // set plain TStyle; gStyle->SetOptStat(111111); // draw statistics on plots,; // (0) for no output; gStyle->SetOptFit(1111); // draw fit results on plot,; // (0) for no ouput; gStyle->SetPalette(57); // set color map; gStyle->SetOptTitle(0); // suppress title box; ...; ```. Next, you should create a canvas for graphical output, with size,; subdivisions and format suitable to your needs, see documentation of; class `TCanvas`:. ``` {.cpp}; TCanvas c1(""c1"",""<Title>"",0,0,400,300); // create a canvas, specify position and size in pixels; c1.Divide(2,2); //set subdivisions, called pads; c1.cd(1); ",MatchSource.DOCS,documentation/primer/your_first_ROOT_macro.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md:1052,Performance,load,loaded,1052,"undamentals and; finally work up to building a complete, working program ? Let's skip all; that. In this guide, we will describe macros executed by the ROOT C++; interpreter Cling. It is relatively easy to compile a macro, either as a pre-compiled; library to load into ROOT, or as a stand-alone application, by adding; some include statements for header file or some ""dressing code"" to any; macro. ## General Remarks on ROOT macros ##. If you have a number of lines which you were able to execute at the ROOT; prompt, they can be turned into a ROOT macro by giving them a name which; corresponds to the file name without extension. The general structure; for a macro stored in file `MacroName.C` is. ``` {.cpp}; void MacroName() {; < ...; your lines of C++ code; ... >; }; ```. The macro is executed by typing. ``` {.cpp}; > root MacroName.C; ```. at the system prompt, or executed using `.x`. ``` {.cpp}; > root; root [0] .x MacroName.C; ```. at the ROOT prompt. or it can be loaded into a ROOT session and then; be executed by typing. ``` {.cpp}; root [0].L MacroName.C; root [1] MacroName();; ```. at the ROOT prompt. Note that more than one macro can be loaded this; way, as each macro has a unique name in the ROOT name space. A small set; of options can help making your plot nicer. ``` {.cpp}; gROOT->SetStyle(""Plain""); // set plain TStyle; gStyle->SetOptStat(111111); // draw statistics on plots,; // (0) for no output; gStyle->SetOptFit(1111); // draw fit results on plot,; // (0) for no ouput; gStyle->SetPalette(57); // set color map; gStyle->SetOptTitle(0); // suppress title box; ...; ```. Next, you should create a canvas for graphical output, with size,; subdivisions and format suitable to your needs, see documentation of; class `TCanvas`:. ``` {.cpp}; TCanvas c1(""c1"",""<Title>"",0,0,400,300); // create a canvas, specify position and size in pixels; c1.Divide(2,2); //set subdivisions, called pads; c1.cd(1); //change to pad 1 of canvas c1; ```. These parts of a well-written macro a",MatchSource.DOCS,documentation/primer/your_first_ROOT_macro.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md:1233,Performance,load,loaded,1233,"ing. It is relatively easy to compile a macro, either as a pre-compiled; library to load into ROOT, or as a stand-alone application, by adding; some include statements for header file or some ""dressing code"" to any; macro. ## General Remarks on ROOT macros ##. If you have a number of lines which you were able to execute at the ROOT; prompt, they can be turned into a ROOT macro by giving them a name which; corresponds to the file name without extension. The general structure; for a macro stored in file `MacroName.C` is. ``` {.cpp}; void MacroName() {; < ...; your lines of C++ code; ... >; }; ```. The macro is executed by typing. ``` {.cpp}; > root MacroName.C; ```. at the system prompt, or executed using `.x`. ``` {.cpp}; > root; root [0] .x MacroName.C; ```. at the ROOT prompt. or it can be loaded into a ROOT session and then; be executed by typing. ``` {.cpp}; root [0].L MacroName.C; root [1] MacroName();; ```. at the ROOT prompt. Note that more than one macro can be loaded this; way, as each macro has a unique name in the ROOT name space. A small set; of options can help making your plot nicer. ``` {.cpp}; gROOT->SetStyle(""Plain""); // set plain TStyle; gStyle->SetOptStat(111111); // draw statistics on plots,; // (0) for no output; gStyle->SetOptFit(1111); // draw fit results on plot,; // (0) for no ouput; gStyle->SetPalette(57); // set color map; gStyle->SetOptTitle(0); // suppress title box; ...; ```. Next, you should create a canvas for graphical output, with size,; subdivisions and format suitable to your needs, see documentation of; class `TCanvas`:. ``` {.cpp}; TCanvas c1(""c1"",""<Title>"",0,0,400,300); // create a canvas, specify position and size in pixels; c1.Divide(2,2); //set subdivisions, called pads; c1.cd(1); //change to pad 1 of canvas c1; ```. These parts of a well-written macro are pretty standard, and you should; remember to include pieces of code like in the examples above to make; sure your plots always look as you had intended. Below, in section [I",MatchSource.DOCS,documentation/primer/your_first_ROOT_macro.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md:5422,Safety,avoid,avoids,5422,"as to be* a clone, to survive after the scope of; `macro1`, and be displayed on screen after the end of the macro; execution. The string option ""APE"" stands for:. - *A* imposes the drawing of the Axes. - *P* imposes the drawing of the graph's markers. - *E* imposes the drawing of the graph's error bars. - Line *39*: define a mathematical function. There are several ways to; accomplish this, but in this case the constructor accepts the name; of the function, the formula, and the function range. - Line *41*: maquillage. Try to give a look to the line styles at your; disposal visiting the documentation of the `TLine` class. - Line *43*: fits the *f* function to the graph, observe that the; pointer is passed. It is more interesting to look at the output on; the screen to see the parameters values and other crucial; information that we will learn to read at the end of this guide. - Line *44*: again draws the clone of the object on the canvas. The; ""Same"" option avoids the cancellation of the already drawn objects,; in our case, the graph. The function *f* will be drawn using the *same* axis; system defined by the previously drawn graph. - Line *47-52*: completes the plot with a legend, represented by a; `TLegend` instance. The constructor takes as parameters the lower; left and upper right corners coordinates with respect to the total; size of the canvas, assumed to be 1, and the legend header string.; You can add to the legend the objects, previously drawn or not; drawn, through the `addEntry` method. Observe how the legend is; drawn at the end: looks familiar now, right ?. - Line *55-57*: defines an arrow with a triangle on the right hand; side, a thickness of 2 and draws it. - Line *60-61*: interpret a Latex string which hast its lower left; corner located in the specified coordinate. The `#splitline{}{}`; construct allows to store multiple lines in the same `TLatex`; object. - Line *63*: save the canvas as image. The format is automatically; inferred from the file ex",MatchSource.DOCS,documentation/primer/your_first_ROOT_macro.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md:8906,Security,access,access,8906,"ers to [specify; their](https://root.cern.ch/doc/master/classTArrow.html) shapes. Do not; underestimate the role of lines and arrows in your plots. Since each; plot should contain a message, it is convenient to stress it with; additional graphics primitives. ### Text. Also text plays a fundamental role in making the plots self-explanatory.; A possibility to add text in your plot is provided by the `TLatex`; class. The objects of this class are constructed with the coordinates of; the bottom-left corner of the text and a string which contains the text; itself. The real twist is that ordinary; [Latex mathematical symbols](https://root.cern.ch/doc/master/classTLatex.html#L5); are automatically interpreted, you just need to replace the ""\\"" by a ""\#"". If; [""\\"" is used as control character](https://root.cern.ch/doc/master/classTLatex.html#L14); , then the; [TMathText interface](https://root.cern.ch/doc/master/classTMathText.html); is invoked. It provides the plain TeX syntax and allow to access character's; set like Russian and Japanese. ## Interpretation and Compilation. As you observed, up to now we heavily exploited the capabilities of ROOT; for interpreting our code, more than compiling and then executing. This; is sufficient for a wide range of applications, but you might have; already asked yourself ""how can this code be compiled ?"". There are two; answers. ### Compile a Macro with ACLiC. ACLiC will create for you a compiled dynamic library for your macro,; without any effort from your side, except the insertion of the; appropriate header files in lines *5--11*. In this example, they are; already included. To generate an object library from the macro code, from inside the; interpreter type (please note the ""+""):. ``` {.cpp}; root [1] .L macro1.C+; ```. Once this operation is accomplished, the macro symbols will be available; in memory and you will be able to execute it simply by calling from; inside the interpreter:. ``` {.cpp}; root [2] macro1(); ```. ### Compile ",MatchSource.DOCS,documentation/primer/your_first_ROOT_macro.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md:11082,Security,access,access,11082,"e code and; then exploit the *root-config* tool for the automatic settings of all; the compiler flags. *root-config* is a script that comes with ROOT; it; prints all flags and libraries needed to compile code and link it with; the ROOT libraries. In order to make the code executable stand-alone, an; entry point for the operating system is needed, in C++ this is the; procedure `int main();`. The easiest way to turn a ROOT macro code into; a stand-alone application is to add the following ""dressing code"" at the; end of the macro file. This defines the procedure main, the only purpose; of which is to call your macro:. ``` {.cpp}; int main() {; ExampleMacro();; return 0;; }; ```. To create a stand-alone program from a macro called `ExampleMacro.C`, simply type. ``` {.cpp}; > g++ -o ExampleMacro ExampleMacro.C `root-config --cflags --libs`; ```. and execute it by typing. ``` {.cpp}; > ./ExampleMacro; ```. This procedure will, however, not give access to the ROOT graphics, as; neither control of mouse or keyboard events nor access to the graphics; windows of ROOT is available. If you want your stand-alone application; have display graphics output and respond to mouse and keyboard, a; slightly more complex piece of code can be used. In the example below, a; macro `ExampleMacro_GUI` is executed by the ROOT class `TApplication`. As; a additional feature, this code example offers access to parameters; eventually passed to the program when started from the command line.; Here is the code fragment:. ``` {.cpp}; void StandaloneApplication(int argc, char** argv) {; // eventually, evaluate the application parameters argc, argv; // ==>> here the ROOT macro is called; ExampleMacro_GUI();; }; // This is the standard ""main"" of C++ starting; // a ROOT application; int main(int argc, char** argv) {; TApplication app(""ROOT Application"", &argc, argv);; StandaloneApplication(app.Argc(), app.Argv());; app.Run();; return 0;; }; ```. Compile the code with. ``` {.cpp}; > g++ -o ExampleMacro_GU",MatchSource.DOCS,documentation/primer/your_first_ROOT_macro.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md:11163,Security,access,access,11163,"e code and; then exploit the *root-config* tool for the automatic settings of all; the compiler flags. *root-config* is a script that comes with ROOT; it; prints all flags and libraries needed to compile code and link it with; the ROOT libraries. In order to make the code executable stand-alone, an; entry point for the operating system is needed, in C++ this is the; procedure `int main();`. The easiest way to turn a ROOT macro code into; a stand-alone application is to add the following ""dressing code"" at the; end of the macro file. This defines the procedure main, the only purpose; of which is to call your macro:. ``` {.cpp}; int main() {; ExampleMacro();; return 0;; }; ```. To create a stand-alone program from a macro called `ExampleMacro.C`, simply type. ``` {.cpp}; > g++ -o ExampleMacro ExampleMacro.C `root-config --cflags --libs`; ```. and execute it by typing. ``` {.cpp}; > ./ExampleMacro; ```. This procedure will, however, not give access to the ROOT graphics, as; neither control of mouse or keyboard events nor access to the graphics; windows of ROOT is available. If you want your stand-alone application; have display graphics output and respond to mouse and keyboard, a; slightly more complex piece of code can be used. In the example below, a; macro `ExampleMacro_GUI` is executed by the ROOT class `TApplication`. As; a additional feature, this code example offers access to parameters; eventually passed to the program when started from the command line.; Here is the code fragment:. ``` {.cpp}; void StandaloneApplication(int argc, char** argv) {; // eventually, evaluate the application parameters argc, argv; // ==>> here the ROOT macro is called; ExampleMacro_GUI();; }; // This is the standard ""main"" of C++ starting; // a ROOT application; int main(int argc, char** argv) {; TApplication app(""ROOT Application"", &argc, argv);; StandaloneApplication(app.Argc(), app.Argv());; app.Run();; return 0;; }; ```. Compile the code with. ``` {.cpp}; > g++ -o ExampleMacro_GU",MatchSource.DOCS,documentation/primer/your_first_ROOT_macro.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md:11522,Security,access,access,11522,"ript that comes with ROOT; it; prints all flags and libraries needed to compile code and link it with; the ROOT libraries. In order to make the code executable stand-alone, an; entry point for the operating system is needed, in C++ this is the; procedure `int main();`. The easiest way to turn a ROOT macro code into; a stand-alone application is to add the following ""dressing code"" at the; end of the macro file. This defines the procedure main, the only purpose; of which is to call your macro:. ``` {.cpp}; int main() {; ExampleMacro();; return 0;; }; ```. To create a stand-alone program from a macro called `ExampleMacro.C`, simply type. ``` {.cpp}; > g++ -o ExampleMacro ExampleMacro.C `root-config --cflags --libs`; ```. and execute it by typing. ``` {.cpp}; > ./ExampleMacro; ```. This procedure will, however, not give access to the ROOT graphics, as; neither control of mouse or keyboard events nor access to the graphics; windows of ROOT is available. If you want your stand-alone application; have display graphics output and respond to mouse and keyboard, a; slightly more complex piece of code can be used. In the example below, a; macro `ExampleMacro_GUI` is executed by the ROOT class `TApplication`. As; a additional feature, this code example offers access to parameters; eventually passed to the program when started from the command line.; Here is the code fragment:. ``` {.cpp}; void StandaloneApplication(int argc, char** argv) {; // eventually, evaluate the application parameters argc, argv; // ==>> here the ROOT macro is called; ExampleMacro_GUI();; }; // This is the standard ""main"" of C++ starting; // a ROOT application; int main(int argc, char** argv) {; TApplication app(""ROOT Application"", &argc, argv);; StandaloneApplication(app.Argc(), app.Argv());; app.Run();; return 0;; }; ```. Compile the code with. ``` {.cpp}; > g++ -o ExampleMacro_GUI ExampleMacro_GUI `root-config --cflags --libs`; ```. and execute the program with. ``` {.cpp}; > ./ExampleMacro_GUI; ```; ",MatchSource.DOCS,documentation/primer/your_first_ROOT_macro.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md:179,Usability,guid,guide,179,"# ROOT Macros #. You know how other books go on and on about programming fundamentals and; finally work up to building a complete, working program ? Let's skip all; that. In this guide, we will describe macros executed by the ROOT C++; interpreter Cling. It is relatively easy to compile a macro, either as a pre-compiled; library to load into ROOT, or as a stand-alone application, by adding; some include statements for header file or some ""dressing code"" to any; macro. ## General Remarks on ROOT macros ##. If you have a number of lines which you were able to execute at the ROOT; prompt, they can be turned into a ROOT macro by giving them a name which; corresponds to the file name without extension. The general structure; for a macro stored in file `MacroName.C` is. ``` {.cpp}; void MacroName() {; < ...; your lines of C++ code; ... >; }; ```. The macro is executed by typing. ``` {.cpp}; > root MacroName.C; ```. at the system prompt, or executed using `.x`. ``` {.cpp}; > root; root [0] .x MacroName.C; ```. at the ROOT prompt. or it can be loaded into a ROOT session and then; be executed by typing. ``` {.cpp}; root [0].L MacroName.C; root [1] MacroName();; ```. at the ROOT prompt. Note that more than one macro can be loaded this; way, as each macro has a unique name in the ROOT name space. A small set; of options can help making your plot nicer. ``` {.cpp}; gROOT->SetStyle(""Plain""); // set plain TStyle; gStyle->SetOptStat(111111); // draw statistics on plots,; // (0) for no output; gStyle->SetOptFit(1111); // draw fit results on plot,; // (0) for no ouput; gStyle->SetPalette(57); // set color map; gStyle->SetOptTitle(0); // suppress title box; ...; ```. Next, you should create a canvas for graphical output, with size,; subdivisions and format suitable to your needs, see documentation of; class `TCanvas`:. ``` {.cpp}; TCanvas c1(""c1"",""<Title>"",0,0,400,300); // create a canvas, specify position and size in pixels; c1.Divide(2,2); //set subdivisions, called pads; c1.cd(1); ",MatchSource.DOCS,documentation/primer/your_first_ROOT_macro.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md:2759,Usability,simpl,simply,2759,"format suitable to your needs, see documentation of; class `TCanvas`:. ``` {.cpp}; TCanvas c1(""c1"",""<Title>"",0,0,400,300); // create a canvas, specify position and size in pixels; c1.Divide(2,2); //set subdivisions, called pads; c1.cd(1); //change to pad 1 of canvas c1; ```. These parts of a well-written macro are pretty standard, and you should; remember to include pieces of code like in the examples above to make; sure your plots always look as you had intended. Below, in section [Interpretation and Compilation](#interpretation-and-compilation), some more code fragments; will be shown, allowing you to use the system compiler to compile macros for; more efficient execution, or turn macros into stand-alone applications linked; against the ROOT libraries. ## A more complete example ##. Let us now look at a rather complete example of a typical task in data; analysis, a macro that constructs a graph with errors, fits a (linear); model to it and saves it as an image. To run this macro, simply type in; the shell:. ``` {.cpp}; > root macro1.C; ```. The code is built around the ROOT class `TGraphErrors`, which was; already introduced previously. Have a look at it in the class reference; guide, where you will also find further examples. The macro shown below; uses additional classes, `TF1` to define a function, `TCanvas` to define; size and properties of the window used for our plot, and `TLegend` to; add a nice legend. For the moment, ignore the commented include; statements for header files, they will only become important at the end; in section [Interpretation and Compilation](#interpretation-and-compilation). ``` {.cpp .numberLines}; @ROOT_INCLUDE_FILE macros/macro1.C; ```. Let's comment it in detail:. - Line *13*: the name of the principal function (it plays the role of; the ""main"" function in compiled programs) in the macro file. It has; to be the same as the file name without extension. - Line *24-25*: instance of the `TGraphErrors` class. The constructor; takes the n",MatchSource.DOCS,documentation/primer/your_first_ROOT_macro.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md:2961,Usability,guid,guide,2961,"subdivisions, called pads; c1.cd(1); //change to pad 1 of canvas c1; ```. These parts of a well-written macro are pretty standard, and you should; remember to include pieces of code like in the examples above to make; sure your plots always look as you had intended. Below, in section [Interpretation and Compilation](#interpretation-and-compilation), some more code fragments; will be shown, allowing you to use the system compiler to compile macros for; more efficient execution, or turn macros into stand-alone applications linked; against the ROOT libraries. ## A more complete example ##. Let us now look at a rather complete example of a typical task in data; analysis, a macro that constructs a graph with errors, fits a (linear); model to it and saves it as an image. To run this macro, simply type in; the shell:. ``` {.cpp}; > root macro1.C; ```. The code is built around the ROOT class `TGraphErrors`, which was; already introduced previously. Have a look at it in the class reference; guide, where you will also find further examples. The macro shown below; uses additional classes, `TF1` to define a function, `TCanvas` to define; size and properties of the window used for our plot, and `TLegend` to; add a nice legend. For the moment, ignore the commented include; statements for header files, they will only become important at the end; in section [Interpretation and Compilation](#interpretation-and-compilation). ``` {.cpp .numberLines}; @ROOT_INCLUDE_FILE macros/macro1.C; ```. Let's comment it in detail:. - Line *13*: the name of the principal function (it plays the role of; the ""main"" function in compiled programs) in the macro file. It has; to be the same as the file name without extension. - Line *24-25*: instance of the `TGraphErrors` class. The constructor; takes the number of points and the pointers to the arrays of; x values, y values, x errors (in this case none,; represented by the NULL pointer) and y errors. The second line; defines in one shot the title of the",MatchSource.DOCS,documentation/primer/your_first_ROOT_macro.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md:4069,Usability,intuit,intuitive,4069,"nd properties of the window used for our plot, and `TLegend` to; add a nice legend. For the moment, ignore the commented include; statements for header files, they will only become important at the end; in section [Interpretation and Compilation](#interpretation-and-compilation). ``` {.cpp .numberLines}; @ROOT_INCLUDE_FILE macros/macro1.C; ```. Let's comment it in detail:. - Line *13*: the name of the principal function (it plays the role of; the ""main"" function in compiled programs) in the macro file. It has; to be the same as the file name without extension. - Line *24-25*: instance of the `TGraphErrors` class. The constructor; takes the number of points and the pointers to the arrays of; x values, y values, x errors (in this case none,; represented by the NULL pointer) and y errors. The second line; defines in one shot the title of the graph and the titles of the two; axes, separated by a "";"". - Line *28-30*: These three lines are rather intuitive right ? To understand; better the enumerators for colours and styles see the reference for; the `TColor` and `TMarker` classes. - Line *33*: the canvas object that will host the drawn objects. The; ""memory leak"" is intentional, to make the object existing also out; of the macro1 scope. - Line *36*: the method *DrawClone* draws a clone of the object on the; canvas. It *has to be* a clone, to survive after the scope of; `macro1`, and be displayed on screen after the end of the macro; execution. The string option ""APE"" stands for:. - *A* imposes the drawing of the Axes. - *P* imposes the drawing of the graph's markers. - *E* imposes the drawing of the graph's error bars. - Line *39*: define a mathematical function. There are several ways to; accomplish this, but in this case the constructor accepts the name; of the function, the formula, and the function range. - Line *41*: maquillage. Try to give a look to the line styles at your; disposal visiting the documentation of the `TLine` class. - Line *43*: fits the *f* function ",MatchSource.DOCS,documentation/primer/your_first_ROOT_macro.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md:5299,Usability,learn,learn,5299,"t the drawn objects. The; ""memory leak"" is intentional, to make the object existing also out; of the macro1 scope. - Line *36*: the method *DrawClone* draws a clone of the object on the; canvas. It *has to be* a clone, to survive after the scope of; `macro1`, and be displayed on screen after the end of the macro; execution. The string option ""APE"" stands for:. - *A* imposes the drawing of the Axes. - *P* imposes the drawing of the graph's markers. - *E* imposes the drawing of the graph's error bars. - Line *39*: define a mathematical function. There are several ways to; accomplish this, but in this case the constructor accepts the name; of the function, the formula, and the function range. - Line *41*: maquillage. Try to give a look to the line styles at your; disposal visiting the documentation of the `TLine` class. - Line *43*: fits the *f* function to the graph, observe that the; pointer is passed. It is more interesting to look at the output on; the screen to see the parameters values and other crucial; information that we will learn to read at the end of this guide. - Line *44*: again draws the clone of the object on the canvas. The; ""Same"" option avoids the cancellation of the already drawn objects,; in our case, the graph. The function *f* will be drawn using the *same* axis; system defined by the previously drawn graph. - Line *47-52*: completes the plot with a legend, represented by a; `TLegend` instance. The constructor takes as parameters the lower; left and upper right corners coordinates with respect to the total; size of the canvas, assumed to be 1, and the legend header string.; You can add to the legend the objects, previously drawn or not; drawn, through the `addEntry` method. Observe how the legend is; drawn at the end: looks familiar now, right ?. - Line *55-57*: defines an arrow with a triangle on the right hand; side, a thickness of 2 and draws it. - Line *60-61*: interpret a Latex string which hast its lower left; corner located in the specified",MatchSource.DOCS,documentation/primer/your_first_ROOT_macro.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md:5332,Usability,guid,guide,5332,"t the drawn objects. The; ""memory leak"" is intentional, to make the object existing also out; of the macro1 scope. - Line *36*: the method *DrawClone* draws a clone of the object on the; canvas. It *has to be* a clone, to survive after the scope of; `macro1`, and be displayed on screen after the end of the macro; execution. The string option ""APE"" stands for:. - *A* imposes the drawing of the Axes. - *P* imposes the drawing of the graph's markers. - *E* imposes the drawing of the graph's error bars. - Line *39*: define a mathematical function. There are several ways to; accomplish this, but in this case the constructor accepts the name; of the function, the formula, and the function range. - Line *41*: maquillage. Try to give a look to the line styles at your; disposal visiting the documentation of the `TLine` class. - Line *43*: fits the *f* function to the graph, observe that the; pointer is passed. It is more interesting to look at the output on; the screen to see the parameters values and other crucial; information that we will learn to read at the end of this guide. - Line *44*: again draws the clone of the object on the canvas. The; ""Same"" option avoids the cancellation of the already drawn objects,; in our case, the graph. The function *f* will be drawn using the *same* axis; system defined by the previously drawn graph. - Line *47-52*: completes the plot with a legend, represented by a; `TLegend` instance. The constructor takes as parameters the lower; left and upper right corners coordinates with respect to the total; size of the canvas, assumed to be 1, and the legend header string.; You can add to the legend the objects, previously drawn or not; drawn, through the `addEntry` method. Observe how the legend is; drawn at the end: looks familiar now, right ?. - Line *55-57*: defines an arrow with a triangle on the right hand; side, a thickness of 2 and draws it. - Line *60-61*: interpret a Latex string which hast its lower left; corner located in the specified",MatchSource.DOCS,documentation/primer/your_first_ROOT_macro.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md:6861,Usability,clear,clear,6861,"nd the objects, previously drawn or not; drawn, through the `addEntry` method. Observe how the legend is; drawn at the end: looks familiar now, right ?. - Line *55-57*: defines an arrow with a triangle on the right hand; side, a thickness of 2 and draws it. - Line *60-61*: interpret a Latex string which hast its lower left; corner located in the specified coordinate. The `#splitline{}{}`; construct allows to store multiple lines in the same `TLatex`; object. - Line *63*: save the canvas as image. The format is automatically; inferred from the file extension (it could have been eps, gif, ...). Let's give a look to the obtained plot in Figure [3.1](#f31). Beautiful; outcome for such a small bunch of lines, isn't it ?. [f31]: figures/graf_with_law.png ""f31""; <a name=""f31""></a>. ![Your first plot with data points, a fit of an analytical function, a; legend and some additional information in the form of graphics; primitives and text. A well formatted plot, clear for the reader is; crucial to communicate the relevance of your results to the; reader.\label{f31}][f31]. ## Summary of Visual effects. ### Colours and Graph Markers. We have seen that to specify a colour, some identifiers like kWhite,; kRed or kBlue can be specified for markers, lines, arrows etc. The; complete summary of colours is represented by the ROOT ""[colour; wheel](https://root.cern.ch/doc/master/classTColor.html#C02)"". To know more; about the full story, refer to the online documentation of `TColor`. ROOT provides several [graphics; markers](https://root.cern.ch/doc/master/classTAttMarker.html#M2) types. Select; the most suited symbols for your plot among dots, triangles, crosses or; stars. An alternative set of names for the markers is available. ### Arrows and Lines. The macro line *55* shows how to define an arrow and draw it. The class; representing arrows is `TArrow`, which inherits from `TLine`. The; constructors of lines and arrows always contain the coordinates of the; endpoints. Arrows also fore",MatchSource.DOCS,documentation/primer/your_first_ROOT_macro.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md:9811,Usability,simpl,simply,9811,"athText interface](https://root.cern.ch/doc/master/classTMathText.html); is invoked. It provides the plain TeX syntax and allow to access character's; set like Russian and Japanese. ## Interpretation and Compilation. As you observed, up to now we heavily exploited the capabilities of ROOT; for interpreting our code, more than compiling and then executing. This; is sufficient for a wide range of applications, but you might have; already asked yourself ""how can this code be compiled ?"". There are two; answers. ### Compile a Macro with ACLiC. ACLiC will create for you a compiled dynamic library for your macro,; without any effort from your side, except the insertion of the; appropriate header files in lines *5--11*. In this example, they are; already included. To generate an object library from the macro code, from inside the; interpreter type (please note the ""+""):. ``` {.cpp}; root [1] .L macro1.C+; ```. Once this operation is accomplished, the macro symbols will be available; in memory and you will be able to execute it simply by calling from; inside the interpreter:. ``` {.cpp}; root [2] macro1(); ```. ### Compile a Macro with the Compiler. A plethora of excellent compilers are available, both free and; commercial. We will refer to the `GCC` compiler in the following. In; this case, you have to include the appropriate headers in the code and; then exploit the *root-config* tool for the automatic settings of all; the compiler flags. *root-config* is a script that comes with ROOT; it; prints all flags and libraries needed to compile code and link it with; the ROOT libraries. In order to make the code executable stand-alone, an; entry point for the operating system is needed, in C++ this is the; procedure `int main();`. The easiest way to turn a ROOT macro code into; a stand-alone application is to add the following ""dressing code"" at the; end of the macro file. This defines the procedure main, the only purpose; of which is to call your macro:. ``` {.cpp}; int main() ",MatchSource.DOCS,documentation/primer/your_first_ROOT_macro.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md
https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md:10884,Usability,simpl,simply,10884,"); ```. ### Compile a Macro with the Compiler. A plethora of excellent compilers are available, both free and; commercial. We will refer to the `GCC` compiler in the following. In; this case, you have to include the appropriate headers in the code and; then exploit the *root-config* tool for the automatic settings of all; the compiler flags. *root-config* is a script that comes with ROOT; it; prints all flags and libraries needed to compile code and link it with; the ROOT libraries. In order to make the code executable stand-alone, an; entry point for the operating system is needed, in C++ this is the; procedure `int main();`. The easiest way to turn a ROOT macro code into; a stand-alone application is to add the following ""dressing code"" at the; end of the macro file. This defines the procedure main, the only purpose; of which is to call your macro:. ``` {.cpp}; int main() {; ExampleMacro();; return 0;; }; ```. To create a stand-alone program from a macro called `ExampleMacro.C`, simply type. ``` {.cpp}; > g++ -o ExampleMacro ExampleMacro.C `root-config --cflags --libs`; ```. and execute it by typing. ``` {.cpp}; > ./ExampleMacro; ```. This procedure will, however, not give access to the ROOT graphics, as; neither control of mouse or keyboard events nor access to the graphics; windows of ROOT is available. If you want your stand-alone application; have display graphics output and respond to mouse and keyboard, a; slightly more complex piece of code can be used. In the example below, a; macro `ExampleMacro_GUI` is executed by the ROOT class `TApplication`. As; a additional feature, this code example offers access to parameters; eventually passed to the program when started from the command line.; Here is the code fragment:. ``` {.cpp}; void StandaloneApplication(int argc, char** argv) {; // eventually, evaluate the application parameters argc, argv; // ==>> here the ROOT macro is called; ExampleMacro_GUI();; }; // This is the standard ""main"" of C++ starting; // a RO",MatchSource.DOCS,documentation/primer/your_first_ROOT_macro.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md
https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:231,Availability,error,error,231,"# BACKGROUND ELIMINATION. ## 1-DIMENSIONAL SPECTRA. This function calculates background spectrum from the source spectrum. The; result is placed in the vector pointed by spectrum pointer. On; successful completion it returns 0. On error it returns pointer to the; string describing error. ``` {.cpp}; char *Background1(float *spectrum,; int size,; int number_of_iterations);; ```. Function parameters:. - **`spectrum`**: pointer to the vector of the source spectrum; - **`size`**: length of spectrum; - **`number_of_iterations`**: or width of the clipping window. The function allows to separate useless spectrum information (continuous; background) from peaks, based on Sensitive Nonlinear Iterative Peak; Clipping Algorithm. In fact, it represents the second order difference filter; (-1,2,-1). The basic algorithm is described in details in [1], [2]. $$ v_p(i)= min\left\{v_{p-1} , \frac{[v_{p-1}(i+p)+v_{p-1}(i-p)]}{2} \right\} $$. where `p` can be changed as follows:. a. from 1 up to a given parameter value `w` by incrementing it in each; iteration step by 1 - INCREASING CLIPPING WINDOW. b. from a given value `w` by decrementing it in each iteration step by; 1 - DECREASING CLIPPING WINDOW. An example of the original spectrum and estimated background (INCREASING; CLIPPING WINDOW) is given in the Figure 1.1. ![Example of the original spectrum and estimated background (INCREASING; CLIPPING WINDOW)](figures/image004.png). One can notice that on the edges of the peaks the estimated background; goes under the peaks. An alternative approach is to decrease the; clipping window from a given value to the value of one (DECREASING; CLIPPING WINDOW). Then the result obtained is given in the Figure 1.2. ![An alternative approach is to decrease the clipping window from a given value to the value of one (DECREASING CLIPPING WINDOW)](figures/image006.png). The estimated background is smoother. The method does not deform the; shape of peaks. However, sometimes the shape of the background is ve",MatchSource.DOCS,documentation/spectrum/Spectrum.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md
https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:282,Availability,error,error,282,"# BACKGROUND ELIMINATION. ## 1-DIMENSIONAL SPECTRA. This function calculates background spectrum from the source spectrum. The; result is placed in the vector pointed by spectrum pointer. On; successful completion it returns 0. On error it returns pointer to the; string describing error. ``` {.cpp}; char *Background1(float *spectrum,; int size,; int number_of_iterations);; ```. Function parameters:. - **`spectrum`**: pointer to the vector of the source spectrum; - **`size`**: length of spectrum; - **`number_of_iterations`**: or width of the clipping window. The function allows to separate useless spectrum information (continuous; background) from peaks, based on Sensitive Nonlinear Iterative Peak; Clipping Algorithm. In fact, it represents the second order difference filter; (-1,2,-1). The basic algorithm is described in details in [1], [2]. $$ v_p(i)= min\left\{v_{p-1} , \frac{[v_{p-1}(i+p)+v_{p-1}(i-p)]}{2} \right\} $$. where `p` can be changed as follows:. a. from 1 up to a given parameter value `w` by incrementing it in each; iteration step by 1 - INCREASING CLIPPING WINDOW. b. from a given value `w` by decrementing it in each iteration step by; 1 - DECREASING CLIPPING WINDOW. An example of the original spectrum and estimated background (INCREASING; CLIPPING WINDOW) is given in the Figure 1.1. ![Example of the original spectrum and estimated background (INCREASING; CLIPPING WINDOW)](figures/image004.png). One can notice that on the edges of the peaks the estimated background; goes under the peaks. An alternative approach is to decrease the; clipping window from a given value to the value of one (DECREASING; CLIPPING WINDOW). Then the result obtained is given in the Figure 1.2. ![An alternative approach is to decrease the clipping window from a given value to the value of one (DECREASING CLIPPING WINDOW)](figures/image006.png). The estimated background is smoother. The method does not deform the; shape of peaks. However, sometimes the shape of the background is ve",MatchSource.DOCS,documentation/spectrum/Spectrum.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md
https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:4724,Availability,error,error,4724," pointer to the vector of the source spectrum; - **`size`**: length of spectrum vector; - **`number_of_iterations`**: maximal width of clipping window; - **`direction`**: direction of change of clipping window. Possible values:; - `BACK1_INCREASING_WINDOW`; - `BACK1_DECREASING_WINDOW`; - **`filter_order`**: order of clipping filter. Possible values:; - `BACK1_ORDER2`; - `BACK1_ORDER4`; - `BACK1_ORDER6`; - `BACK1_ORDER8`; - **`compton`**: logical variable whether the estimation of Compton edge will be included. Possible values:; - `BACK1_EXCLUDE_COMPTON`; - `BACK1_INCLUDE_COMPTON`. ## 2-DIMENSIONAL SPECTRA. This basic background estimation function allows to separate useless; spectrum information (2D-continuous background and coincidences of peaks; with background in both dimensions) from peaks. It calculates background; spectrum from the source spectrum. The result is placed in the array; pointed by spectrum pointer. On successful completion it returns 0. On; error it returns a pointer to the string describing error. ``` {.cpp}; char *Background2(float **spectrum,; int sizex,; int sizey,; int number_of_iterations);; ```. Function parameters:. - **`spectrum`**: pointer to the array of the source spectrum; - **`sizex`**: x length of spectrum; - **`sizey`**: y length of spectrum; - **`number_of_iterations`**: width of the clipping window. In Figure 1.6 we present an example of a 2-dimensional spectrum before background elimination. ![2-dimensional spectrum before background elimination](figures/image014.png). Estimated background is shown in Figure 1.7. After subtraction we get pure; 2-dimensional peaks. ![Estimated background](figures/image016.png). Similarly to 1-dimensional case, we have generalized also the function; for 2-dimensional background estimation. Sometimes the widths of peaks in; both dimensions are different. As an example, we can introduce an n-gamma; 2-dimensional spectra. Then it is necessary to set different widths of; clipping window in both dimensi",MatchSource.DOCS,documentation/spectrum/Spectrum.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md
https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:4776,Availability,error,error,4776," pointer to the vector of the source spectrum; - **`size`**: length of spectrum vector; - **`number_of_iterations`**: maximal width of clipping window; - **`direction`**: direction of change of clipping window. Possible values:; - `BACK1_INCREASING_WINDOW`; - `BACK1_DECREASING_WINDOW`; - **`filter_order`**: order of clipping filter. Possible values:; - `BACK1_ORDER2`; - `BACK1_ORDER4`; - `BACK1_ORDER6`; - `BACK1_ORDER8`; - **`compton`**: logical variable whether the estimation of Compton edge will be included. Possible values:; - `BACK1_EXCLUDE_COMPTON`; - `BACK1_INCLUDE_COMPTON`. ## 2-DIMENSIONAL SPECTRA. This basic background estimation function allows to separate useless; spectrum information (2D-continuous background and coincidences of peaks; with background in both dimensions) from peaks. It calculates background; spectrum from the source spectrum. The result is placed in the array; pointed by spectrum pointer. On successful completion it returns 0. On; error it returns a pointer to the string describing error. ``` {.cpp}; char *Background2(float **spectrum,; int sizex,; int sizey,; int number_of_iterations);; ```. Function parameters:. - **`spectrum`**: pointer to the array of the source spectrum; - **`sizex`**: x length of spectrum; - **`sizey`**: y length of spectrum; - **`number_of_iterations`**: width of the clipping window. In Figure 1.6 we present an example of a 2-dimensional spectrum before background elimination. ![2-dimensional spectrum before background elimination](figures/image014.png). Estimated background is shown in Figure 1.7. After subtraction we get pure; 2-dimensional peaks. ![Estimated background](figures/image016.png). Similarly to 1-dimensional case, we have generalized also the function; for 2-dimensional background estimation. Sometimes the widths of peaks in; both dimensions are different. As an example, we can introduce an n-gamma; 2-dimensional spectra. Then it is necessary to set different widths of; clipping window in both dimensi",MatchSource.DOCS,documentation/spectrum/Spectrum.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md
https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:20456,Availability,robust,robustness,20456,"the source spectrum. The number of found; peaks and their positions are written into the structure pointed by the; `one_dim_peak` structure pointer. Function parameters:. - **`spectrum`**: pointer to the vector of the source spectrum. This source spectrum is replaced by the new spectrum calculated using Markov chains method.; - **`size`**: length of the source spectrum; - **`sigma`**: sigma of searched peaks; - **`threshold`**: threshold value for peaks selection; - **`markov`**: logical variable. If it is set to `true`, then the source spectrum is first replaced by the new spectrum calculated using Markov chains method; - **`aver_window`**: averaging window used in the calculation of Markov spectrum, applies only if the `markov` variable was set to `true`. The methods of peak searching are sensitive to the `sigma`. Usually the; `sigma` value is known beforehand. It also changes only slightly with the; energy. We have investigated as well the robustness of the proposed; algorithms to the spectrum with the peaks with `sigma` changing from 1 to; 10 (see Figure 3.6). ![Robustness of the proposed algorithms to the spectrum with the peaks with sigma changing from 1 to 10](figures/image068.png). We applied peak searching algorithm based on Markov approach. We changed; `sigma` in the interval from 1 to 10. The spectra for averaging windows 3,; 5, 10 are shown in Figure 3.7. ![Spectra for averaging windows 3, 5, 10](figures/image070.png). When we applied peak searching function to the Markov spectrum averaged; with the `window=10`, we obtained correct estimate of all 10 peak; positions for `sigma=2,3,4,5,6,7,8`. It was not the case when we made the; same experiment with the original spectrum. For all sigmas some peaks; were not discovered. ## 2-DIMENSIONAL SPECTRA. The basic function of the 2-dimensional peak searching is described in; details in [4]. It automatically identifies the peaks in a; spectrum with the presence of the continuous background, statistical; fluctuatio",MatchSource.DOCS,documentation/spectrum/Spectrum.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md
https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:37191,Availability,error,errors,37191," gradients, etc.) and more or less successfully implemented; into programs for analysis of complex spectra. They are based on matrix; inversion that can impose appreciable convergence difficulties mainly; for large number of fitted parameters. Peaks can be fitted separately,; each peak (or multiplets) in a region or together all peaks in a; spectrum. To fit separately each peak one needs to determine the fitted; region. However it can happen that the regions of neighboring peaks are; overlapping (mainly in 2-dimensional spectra). Then the results of; fitting are very poor. On the other hand, when fitting together all the; peaks found in a spectrum, one needs to have a method that is stable; (i.e., converges) and fast enough to carry out the fitting in a reasonable time. The; gradient methods based on the inversion of large matrices are not; applicable because of two reasons:. a. calculation of inverse matrix is extremely time consuming;. b. due to accumulation of truncation and rounding-off errors, the; result can become worthless. We have implemented two kinds of fitting functions. The first approach; is based on the algorithm without matrix inversion [9] - awmi algorithm.; It allows to fit large blocks of data and large number of parameters. The other one is based on a calculation of the system of linear equations; using Stiefel-Hestens method [10]. It converges faster than the awmi; algorithm, however, it is not suitable to fit large number of parameters. ## 1-DIMENSIONAL SPECTRA. The quantity to be minimized in the fitting procedure for one-dimensional spectrum is defined as. $$ \chi^2 = \frac{1}{N-M}\sum_{i=1}^{N}\frac{[y_i-f(i,a)]^2}{y_i} $$. where `i` is the channel in the fitted spectrum, `N` is the number of; channels in the fitting subregion, `M` is the number of free parameters,; `y_i` is the content of the `i`-th channel, `a` is a vector of the; parameters being fitted and `f(i,a)` is a fitting or peak shape function. Instead of the weighting coefficient ",MatchSource.DOCS,documentation/spectrum/Spectrum.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md
https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:39393,Availability,error,error,39393,", is the Maximum Likelihood Method. It is up to the user; to select a suitable statistic. After differentiating chi^2 we obtain the following `M` simultaneous; equations:. $$ \sum_{i=1}^{N}; \frac{y_i-f(i,a^{(t)})}{y_i}; \frac{\partial f(i,a^t)}{\partial a_k}=; \sum_{j=1}^{M}\sum_{i=1}^{N}; \frac{\partial f(i,a^{(t)})}{\partial a_j}; \frac{\partial f(i,a^{(t)})}{\partial a_k}; \Delta a_j^{(t)} $$. - in gamma-ray spectra we have to fit together tens, hundreds of peaks; simultaneously that sometimes represent thousands of parameters. - the calculation of the inversion matrix of such a size is; practically impossible. - the awmi method is based on the assumption that the off-diagonal; terms in the matrix A are equal to zero. $$; \Delta a_{k}^{(t+1)} = \alpha^{(t)}; \frac{; \sum_{i=1}^{N} \frac{e_{i}^{(t)}}{y_i}\frac{\partial f(i,a^{(t)})}{\partial a_k}; }{; \sum_{i=1}^{N} \left[ \frac{\partial f(i,a^{(t)})}{\partial a_k}\right]^2\frac{1}{y_i}; }; $$. where the error in the channel `i` is $e_{i}^{(t)} = y_i-f(i,a^{(t)}); k=1,2,...,M$ and; $\alpha^{(t)}=1$ if the process is convergent or $\alpha^{(t)}=0.5 \alpha^{(t-1)}$; if it is divergent. Another possibility is to optimize this coefficient. The error of `k`-th parameter estimate is. $$; \Delta a_k^{(e)}=; \sqrt{\frac; {\sum_{i=1}^{N}\frac{e_i^2}{y_i}}; {\sum_{i=1}^{N} \left[ \frac{\partial f(i,a^{(t)})}{\partial a_k}\right]^2\frac{1}{y_i}}; }; $$. Algorithm with higher powers `w=1,2,3...`:. $$; \Delta a_{k,w}^{(t+1)}=; \alpha^{(t)}; \frac; {\sum_{i=1}^{N} \frac{e_i}{y_i}\left[ \frac{\partial f(i,a^{(t)})}{\partial a_k}\right]^{2w-1}}; {\sum_{i=1}^{N} \left[ \frac{\partial f(i,a^{(t)})}{\partial a_k}\right]^{2w}\frac{1}{y_i}}; $$. We have implemented the non-symmetrical semi-empirical peak shape function. It contains the symmetrical Gaussian as well as non-symmetrical terms:. $$; f(i,a) =; \sum_{i=1}^{M} A(j); \left\{; exp\left[\frac{-(i-p(j))^2}{2\sigma^2}\right]; +\frac{1}{2}T.exp\left[\frac{(i-p(j))}{B\sigma}\right];",MatchSource.DOCS,documentation/spectrum/Spectrum.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md
https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:39633,Availability,error,error,39633,"partial f(i,a^t)}{\partial a_k}=; \sum_{j=1}^{M}\sum_{i=1}^{N}; \frac{\partial f(i,a^{(t)})}{\partial a_j}; \frac{\partial f(i,a^{(t)})}{\partial a_k}; \Delta a_j^{(t)} $$. - in gamma-ray spectra we have to fit together tens, hundreds of peaks; simultaneously that sometimes represent thousands of parameters. - the calculation of the inversion matrix of such a size is; practically impossible. - the awmi method is based on the assumption that the off-diagonal; terms in the matrix A are equal to zero. $$; \Delta a_{k}^{(t+1)} = \alpha^{(t)}; \frac{; \sum_{i=1}^{N} \frac{e_{i}^{(t)}}{y_i}\frac{\partial f(i,a^{(t)})}{\partial a_k}; }{; \sum_{i=1}^{N} \left[ \frac{\partial f(i,a^{(t)})}{\partial a_k}\right]^2\frac{1}{y_i}; }; $$. where the error in the channel `i` is $e_{i}^{(t)} = y_i-f(i,a^{(t)}); k=1,2,...,M$ and; $\alpha^{(t)}=1$ if the process is convergent or $\alpha^{(t)}=0.5 \alpha^{(t-1)}$; if it is divergent. Another possibility is to optimize this coefficient. The error of `k`-th parameter estimate is. $$; \Delta a_k^{(e)}=; \sqrt{\frac; {\sum_{i=1}^{N}\frac{e_i^2}{y_i}}; {\sum_{i=1}^{N} \left[ \frac{\partial f(i,a^{(t)})}{\partial a_k}\right]^2\frac{1}{y_i}}; }; $$. Algorithm with higher powers `w=1,2,3...`:. $$; \Delta a_{k,w}^{(t+1)}=; \alpha^{(t)}; \frac; {\sum_{i=1}^{N} \frac{e_i}{y_i}\left[ \frac{\partial f(i,a^{(t)})}{\partial a_k}\right]^{2w-1}}; {\sum_{i=1}^{N} \left[ \frac{\partial f(i,a^{(t)})}{\partial a_k}\right]^{2w}\frac{1}{y_i}}; $$. We have implemented the non-symmetrical semi-empirical peak shape function. It contains the symmetrical Gaussian as well as non-symmetrical terms:. $$; f(i,a) =; \sum_{i=1}^{M} A(j); \left\{; exp\left[\frac{-(i-p(j))^2}{2\sigma^2}\right]; +\frac{1}{2}T.exp\left[\frac{(i-p(j))}{B\sigma}\right]; .erfc\left[\frac{(i-p(j))}{\sigma}+\frac{1}{2B}\right]; +\frac{1}{2}S.erfc\left[\frac{(i-p(j))}{\sigma}\right]; \right\}; $$. where `T, S` are relative amplitudes and `B` is a slope. Detailed description of the algorithm is giv",MatchSource.DOCS,documentation/spectrum/Spectrum.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md
https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:42594,Availability,error,errors,42594,"t fitted channel; int xmax; // last fitted channel; double alpha; // convergence coefficient, input parameter, it should be a positive number and <=1; double chi; // here the function returns the resulting chi-square; int statistic_type; // type of statistics, possible values are:; // FIT1_OPTIM_CHI_COUNTS (chi square statistics with counts as weighting coefficients),; // FIT1_OPTIM_CHI_FUNC_VALUES (chi square statistics with function values as weighting coefficients); // FIT1_OPTIM_MAX_LIKELIHOOD; int alpha_optim; // optimization of convergence coefficients, possible values are:; // FIT1_ALPHA_HALVING,; // FIT1_ALPHA_OPTIMAL; int power; // possible values FIT1_FIT_POWER2,4,6,8,10,12; int fit_taylor; // order of Taylor expansion, possible values; // FIT1_TAYLOR_ORDER_FIRST, FIT1_TAYLOR_ORDER_SECOND. double position_init[MAX_NUMBER_OF_PEAKS1]; // initial values of peaks positions, input parameters; double position_calc[MAX_NUMBER_OF_PEAKS1]; // calculated values of fitted positions, output parameters; double position_err[MAX_NUMBER_OF_PEAKS1]; // position errors; bool fix_position[MAX_NUMBER_OF_PEAKS1]; // logical vector which allows to fix appropriate positions (not fit). However they are present in the estimated functional; double amp_init[MAX_NUMBER_OF_PEAKS1]; // initial values of peaks amplitudes, input parameters; double amp_calc[MAX_NUMBER_OF_PEAKS1]; // calculated values of fitted amplitudes, output parameters; double amp_err[MAX_NUMBER_OF_PEAKS1]; // amplitude errors; bool fix_amp[MAX_NUMBER_OF_PEAKS1]i; // logical vector, which allows to fix appropriate amplitudes (not fit). However they are present in the estimated functional; double area[MAX_NUMBER_OF_PEAKS1]; // calculated areas of peaks; double area_err[MAX_NUMBER_OF_PEAKS1]; // errors of peak areas; double sigma_init; // sigma parameter, see peak shape function; double sigma_calc;; double sigma_err;; bool fix_sigma;; double t_init // t parameter, see peak shape function; double t_calc;; double t_err;; ",MatchSource.DOCS,documentation/spectrum/Spectrum.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md
https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:43016,Availability,error,errors,43016,"S (chi square statistics with function values as weighting coefficients); // FIT1_OPTIM_MAX_LIKELIHOOD; int alpha_optim; // optimization of convergence coefficients, possible values are:; // FIT1_ALPHA_HALVING,; // FIT1_ALPHA_OPTIMAL; int power; // possible values FIT1_FIT_POWER2,4,6,8,10,12; int fit_taylor; // order of Taylor expansion, possible values; // FIT1_TAYLOR_ORDER_FIRST, FIT1_TAYLOR_ORDER_SECOND. double position_init[MAX_NUMBER_OF_PEAKS1]; // initial values of peaks positions, input parameters; double position_calc[MAX_NUMBER_OF_PEAKS1]; // calculated values of fitted positions, output parameters; double position_err[MAX_NUMBER_OF_PEAKS1]; // position errors; bool fix_position[MAX_NUMBER_OF_PEAKS1]; // logical vector which allows to fix appropriate positions (not fit). However they are present in the estimated functional; double amp_init[MAX_NUMBER_OF_PEAKS1]; // initial values of peaks amplitudes, input parameters; double amp_calc[MAX_NUMBER_OF_PEAKS1]; // calculated values of fitted amplitudes, output parameters; double amp_err[MAX_NUMBER_OF_PEAKS1]; // amplitude errors; bool fix_amp[MAX_NUMBER_OF_PEAKS1]i; // logical vector, which allows to fix appropriate amplitudes (not fit). However they are present in the estimated functional; double area[MAX_NUMBER_OF_PEAKS1]; // calculated areas of peaks; double area_err[MAX_NUMBER_OF_PEAKS1]; // errors of peak areas; double sigma_init; // sigma parameter, see peak shape function; double sigma_calc;; double sigma_err;; bool fix_sigma;; double t_init // t parameter, see peak shape function; double t_calc;; double t_err;; bool fix_t;; double b_init // b parameter, see peak shape function; double b_calc;; double b_err;; bool fix_b;; double s_init; // s parameter, see peak shape function; double s_calc;; double s_err;; bool fix_s;; double a0_init; // background is estimated as a0+a1*x+a2*x*x; double a0_calc;; double a0_err;; bool fix_a0;; double a1_init;; double a1_calc;; double a1_err;; bool fix_a1;; double a2_init;",MatchSource.DOCS,documentation/spectrum/Spectrum.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md
https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:43295,Availability,error,errors,43295,"rr[MAX_NUMBER_OF_PEAKS1]; // position errors; bool fix_position[MAX_NUMBER_OF_PEAKS1]; // logical vector which allows to fix appropriate positions (not fit). However they are present in the estimated functional; double amp_init[MAX_NUMBER_OF_PEAKS1]; // initial values of peaks amplitudes, input parameters; double amp_calc[MAX_NUMBER_OF_PEAKS1]; // calculated values of fitted amplitudes, output parameters; double amp_err[MAX_NUMBER_OF_PEAKS1]; // amplitude errors; bool fix_amp[MAX_NUMBER_OF_PEAKS1]i; // logical vector, which allows to fix appropriate amplitudes (not fit). However they are present in the estimated functional; double area[MAX_NUMBER_OF_PEAKS1]; // calculated areas of peaks; double area_err[MAX_NUMBER_OF_PEAKS1]; // errors of peak areas; double sigma_init; // sigma parameter, see peak shape function; double sigma_calc;; double sigma_err;; bool fix_sigma;; double t_init // t parameter, see peak shape function; double t_calc;; double t_err;; bool fix_t;; double b_init // b parameter, see peak shape function; double b_calc;; double b_err;; bool fix_b;; double s_init; // s parameter, see peak shape function; double s_calc;; double s_err;; bool fix_s;; double a0_init; // background is estimated as a0+a1*x+a2*x*x; double a0_calc;; double a0_err;; bool fix_a0;; double a1_init;; double a1_calc;; double a1_err;; bool fix_a1;; double a2_init;; double a2_calc;; double a2_err;; bool fix_a2;; };; ```. As an example we present a simple 1-dimensional synthetic spectrum with 5; peaks. The fit (obtained using above-given awmi fitting function) is given; in Figure 5.1. The chi-square achieved in this fit was 0.76873. The input; value of the fit (positions of peaks and their amplitudes) were; estimated using peak searching function. ![Fit obtained using above given awmi fitting function](figures/image172.png). Let us go to a more complicated fit with a lot of overlapping peaks as in Figure 5.2.; The initial positions of peaks were determined from original data, using; peak",MatchSource.DOCS,documentation/spectrum/Spectrum.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md
https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:50294,Availability,error,errors,50294,"to the `two_dim_fit` structure pointer, see manual; - **`sizex`**: length x of the source spectrum; - **`sizey`**: length y of the source spectrum. The `two_dim_fit` structure has the form of. ``` {.cpp}; class TSpectrumTwoDimFit{. public:. int number_of_peaks; // input parameter, should be>0; int number_of_iterations; // input parameter, should be >0; int xmin; // first fitted channel in x direction; int xmax; // last fitted channel in x direction; int ymin; // first fitted channel in y direction; int ymax; // last fitted channel in y direction; double alpha; // convergence coefficient, input parameter, it should be a positive number and <=1; double chi; // here the function returns resulting chi square; int statistic_type; // type of statistics, possible values are:; // FIT2_OPTIM_CHI_COUNTS (chi square statistics with counts as weighting coefficients),; // FIT2_OPTIM_CHI_FUNC_VALUES (chi square statistics with function values as weighting coefficients),; // FIT2_OPTIM_MAX_LIKELIHOOD; int alpha_optim; // optimization of convergence coefficients, possible values are:; // FIT2_ALPHA_HALVING, FIT2_ALPHA_OPTIMAL; int power; // possible values are: FIT21_FIT_POWER2,4,6,8,10,12; int fit_taylor; // order of Taylor expansion, possible values are:; // FIT2_TAYLOR_ORDER_FIRST,; // FIT2_TAYLOR_ORDER_SECOND; double position_init_x[MAX_NUMBER_OF_PEAKS2]; // initial values of x positions of 2D peaks, input parameters; double position_calc_x[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitted x positions of 2D peaks, output parameters; double position_err_x[MAX_NUMBER_OF_PEAKS2]; // x position errors of 2D peaks; bool fix_position_x[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix the appropriate x positions of 2D peaks (not fit). However, they are present in the estimated functional; double position_init_y[MAX_NUMBER_OF_PEAKS2]; // initial values of y positions of 2D peaks, input parameters; double position_calc_y[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitt",MatchSource.DOCS,documentation/spectrum/Spectrum.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md
https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:50791,Availability,error,errors,50791,"ha_optim; // optimization of convergence coefficients, possible values are:; // FIT2_ALPHA_HALVING, FIT2_ALPHA_OPTIMAL; int power; // possible values are: FIT21_FIT_POWER2,4,6,8,10,12; int fit_taylor; // order of Taylor expansion, possible values are:; // FIT2_TAYLOR_ORDER_FIRST,; // FIT2_TAYLOR_ORDER_SECOND; double position_init_x[MAX_NUMBER_OF_PEAKS2]; // initial values of x positions of 2D peaks, input parameters; double position_calc_x[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitted x positions of 2D peaks, output parameters; double position_err_x[MAX_NUMBER_OF_PEAKS2]; // x position errors of 2D peaks; bool fix_position_x[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix the appropriate x positions of 2D peaks (not fit). However, they are present in the estimated functional; double position_init_y[MAX_NUMBER_OF_PEAKS2]; // initial values of y positions of 2D peaks, input parameters; double position_calc_y[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitted y positions of 2D peaks, output parameters; double position_err_y[MAX_NUMBER_OF_PEAKS2]; // y position errors of 2D peaks; bool fix_position_y[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix the appropriate y positions of 2D peaks (not fit). However, they are present in the estimated functional; double position_init_x1[MAX_NUMBER_OF_PEAKS2]; // initial values of x positions of 1D ridges, input parameters; double position_calc_x1[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitted x positions of 1D ridges, output parameters; double position_err_x1[MAX_NUMBER_OF_PEAKS2]; // x position errors of 1D ridges; bool fix_position_x1[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix appropriate x positions of 1D ridges (not fit). However, they are present in the estimated functional; double position_init_y1[MAX_NUMBER_OF_PEAKS2]; // initial values of y positions of 1D ridges, input parameters; double position_calc_y1[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitted y pos",MatchSource.DOCS,documentation/spectrum/Spectrum.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md
https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:51293,Availability,error,errors,51293," positions of 2D peaks, output parameters; double position_err_x[MAX_NUMBER_OF_PEAKS2]; // x position errors of 2D peaks; bool fix_position_x[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix the appropriate x positions of 2D peaks (not fit). However, they are present in the estimated functional; double position_init_y[MAX_NUMBER_OF_PEAKS2]; // initial values of y positions of 2D peaks, input parameters; double position_calc_y[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitted y positions of 2D peaks, output parameters; double position_err_y[MAX_NUMBER_OF_PEAKS2]; // y position errors of 2D peaks; bool fix_position_y[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix the appropriate y positions of 2D peaks (not fit). However, they are present in the estimated functional; double position_init_x1[MAX_NUMBER_OF_PEAKS2]; // initial values of x positions of 1D ridges, input parameters; double position_calc_x1[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitted x positions of 1D ridges, output parameters; double position_err_x1[MAX_NUMBER_OF_PEAKS2]; // x position errors of 1D ridges; bool fix_position_x1[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix appropriate x positions of 1D ridges (not fit). However, they are present in the estimated functional; double position_init_y1[MAX_NUMBER_OF_PEAKS2]; // initial values of y positions of 1D ridges, input parameters; double position_calc_y1[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitted y positions of 1D ridges, output parameters; double position_err_y1[MAX_NUMBER_OF_PEAKS2]; // y position errors of 1D ridges; bool fix_position_y1[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix the appropriate y positions of 1D ridges (not fit). However, they are present in the estimated functional; double amp_init[MAX_NUMBER_OF_PEAKS2]; // initial values of 2D peaks amplitudes, input parameters; double amp_calc[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitted amplitudes of 2D pea",MatchSource.DOCS,documentation/spectrum/Spectrum.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md
https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:51794,Availability,error,errors,51794,"ions of 2D peaks, output parameters; double position_err_y[MAX_NUMBER_OF_PEAKS2]; // y position errors of 2D peaks; bool fix_position_y[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix the appropriate y positions of 2D peaks (not fit). However, they are present in the estimated functional; double position_init_x1[MAX_NUMBER_OF_PEAKS2]; // initial values of x positions of 1D ridges, input parameters; double position_calc_x1[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitted x positions of 1D ridges, output parameters; double position_err_x1[MAX_NUMBER_OF_PEAKS2]; // x position errors of 1D ridges; bool fix_position_x1[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix appropriate x positions of 1D ridges (not fit). However, they are present in the estimated functional; double position_init_y1[MAX_NUMBER_OF_PEAKS2]; // initial values of y positions of 1D ridges, input parameters; double position_calc_y1[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitted y positions of 1D ridges, output parameters; double position_err_y1[MAX_NUMBER_OF_PEAKS2]; // y position errors of 1D ridges; bool fix_position_y1[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix the appropriate y positions of 1D ridges (not fit). However, they are present in the estimated functional; double amp_init[MAX_NUMBER_OF_PEAKS2]; // initial values of 2D peaks amplitudes, input parameters; double amp_calc[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitted amplitudes of 2D peaks, output parameters; double amp_err[MAX_NUMBER_OF_PEAKS2]; // amplitude errors of 2D peaks; bool fix_amp[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix appropriate amplitudes of 2D peaks (not fit). However, they are present in the estimated functional; double amp_init_x1[MAX_NUMBER_OF_PEAKS2]; // initial values of 1D ridges amplitudes, input parameters; double amp_calc_x1[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitted amplitudes of 1D ridges, output parameters; double amp_err",MatchSource.DOCS,documentation/spectrum/Spectrum.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md
https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:52267,Availability,error,errors,52267," of fitted x positions of 1D ridges, output parameters; double position_err_x1[MAX_NUMBER_OF_PEAKS2]; // x position errors of 1D ridges; bool fix_position_x1[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix appropriate x positions of 1D ridges (not fit). However, they are present in the estimated functional; double position_init_y1[MAX_NUMBER_OF_PEAKS2]; // initial values of y positions of 1D ridges, input parameters; double position_calc_y1[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitted y positions of 1D ridges, output parameters; double position_err_y1[MAX_NUMBER_OF_PEAKS2]; // y position errors of 1D ridges; bool fix_position_y1[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix the appropriate y positions of 1D ridges (not fit). However, they are present in the estimated functional; double amp_init[MAX_NUMBER_OF_PEAKS2]; // initial values of 2D peaks amplitudes, input parameters; double amp_calc[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitted amplitudes of 2D peaks, output parameters; double amp_err[MAX_NUMBER_OF_PEAKS2]; // amplitude errors of 2D peaks; bool fix_amp[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix appropriate amplitudes of 2D peaks (not fit). However, they are present in the estimated functional; double amp_init_x1[MAX_NUMBER_OF_PEAKS2]; // initial values of 1D ridges amplitudes, input parameters; double amp_calc_x1[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitted amplitudes of 1D ridges, output parameters; double amp_err_x1[MAX_NUMBER_OF_PEAKS2]; // amplitude errors of 1D ridges; bool fix_amp_x1[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix the appropriate amplitudes of 1D ridges (not fit). However, they are present in the estimated functional; double amp_init_y1[MAX_NUMBER_OF_PEAKS2]; // initial values of 1D ridges amplitudes, input parameters; double amp_calc_y1[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitted amplitudes of 1D ridges, output parameters; double amp_err_y1",MatchSource.DOCS,documentation/spectrum/Spectrum.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md
https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:52736,Availability,error,errors,52736,"_OF_PEAKS2]; // calculated values of fitted y positions of 1D ridges, output parameters; double position_err_y1[MAX_NUMBER_OF_PEAKS2]; // y position errors of 1D ridges; bool fix_position_y1[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix the appropriate y positions of 1D ridges (not fit). However, they are present in the estimated functional; double amp_init[MAX_NUMBER_OF_PEAKS2]; // initial values of 2D peaks amplitudes, input parameters; double amp_calc[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitted amplitudes of 2D peaks, output parameters; double amp_err[MAX_NUMBER_OF_PEAKS2]; // amplitude errors of 2D peaks; bool fix_amp[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix appropriate amplitudes of 2D peaks (not fit). However, they are present in the estimated functional; double amp_init_x1[MAX_NUMBER_OF_PEAKS2]; // initial values of 1D ridges amplitudes, input parameters; double amp_calc_x1[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitted amplitudes of 1D ridges, output parameters; double amp_err_x1[MAX_NUMBER_OF_PEAKS2]; // amplitude errors of 1D ridges; bool fix_amp_x1[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix the appropriate amplitudes of 1D ridges (not fit). However, they are present in the estimated functional; double amp_init_y1[MAX_NUMBER_OF_PEAKS2]; // initial values of 1D ridges amplitudes, input parameters; double amp_calc_y1[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitted amplitudes of 1D ridges, output parameters; double amp_err_y1[MAX_NUMBER_OF_PEAKS2]; // amplitude errors of 1D ridges; bool fix_amp_y1[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix the appropriate amplitudes of 1D ridges (not fit). However, they are present in the estimated functional; double volume[MAX_NUMBER_OF_PEAKS1]; // calculated volumes of peaks; double volume_err[MAX_NUMBER_OF_PEAKS1]; // errors of peak volumes; double sigma_init_x; // sigma x parameter; double sigma_calc_x;; double sigma_err_x;; bool",MatchSource.DOCS,documentation/spectrum/Spectrum.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md
https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:53214,Availability,error,errors,53214,"NUMBER_OF_PEAKS2]; // calculated values of fitted amplitudes of 2D peaks, output parameters; double amp_err[MAX_NUMBER_OF_PEAKS2]; // amplitude errors of 2D peaks; bool fix_amp[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix appropriate amplitudes of 2D peaks (not fit). However, they are present in the estimated functional; double amp_init_x1[MAX_NUMBER_OF_PEAKS2]; // initial values of 1D ridges amplitudes, input parameters; double amp_calc_x1[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitted amplitudes of 1D ridges, output parameters; double amp_err_x1[MAX_NUMBER_OF_PEAKS2]; // amplitude errors of 1D ridges; bool fix_amp_x1[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix the appropriate amplitudes of 1D ridges (not fit). However, they are present in the estimated functional; double amp_init_y1[MAX_NUMBER_OF_PEAKS2]; // initial values of 1D ridges amplitudes, input parameters; double amp_calc_y1[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitted amplitudes of 1D ridges, output parameters; double amp_err_y1[MAX_NUMBER_OF_PEAKS2]; // amplitude errors of 1D ridges; bool fix_amp_y1[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix the appropriate amplitudes of 1D ridges (not fit). However, they are present in the estimated functional; double volume[MAX_NUMBER_OF_PEAKS1]; // calculated volumes of peaks; double volume_err[MAX_NUMBER_OF_PEAKS1]; // errors of peak volumes; double sigma_init_x; // sigma x parameter; double sigma_calc_x;; double sigma_err_x;; bool fix_sigma_x;; double sigma_init_y; // sigma y parameter; double sigma_calc_y;; double sigma_err_y;; bool fix_sigma_y;; double ro_init; // correlation coefficient; double ro_calc;; double ro_err;; bool fix_ro;; double txy_init; // t parameter for 2D peaks; double txy_calc;; double txy_err;; bool fix_txy;; double sxy_init; // s parameter for 2D peaks; double sxy_calc;; double sxy_err;; bool fix_sxy;; double tx_init; // t parameter for 1D ridges (x direction); double tx_calc;",MatchSource.DOCS,documentation/spectrum/Spectrum.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md
https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:53531,Availability,error,errors,53531," parameters; double amp_err_y1[MAX_NUMBER_OF_PEAKS2]; // amplitude errors of 1D ridges; bool fix_amp_y1[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix the appropriate amplitudes of 1D ridges (not fit). However, they are present in the estimated functional; double volume[MAX_NUMBER_OF_PEAKS1]; // calculated volumes of peaks; double volume_err[MAX_NUMBER_OF_PEAKS1]; // errors of peak volumes; double sigma_init_x; // sigma x parameter; double sigma_calc_x;; double sigma_err_x;; bool fix_sigma_x;; double sigma_init_y; // sigma y parameter; double sigma_calc_y;; double sigma_err_y;; bool fix_sigma_y;; double ro_init; // correlation coefficient; double ro_calc;; double ro_err;; bool fix_ro;; double txy_init; // t parameter for 2D peaks; double txy_calc;; double txy_err;; bool fix_txy;; double sxy_init; // s parameter for 2D peaks; double sxy_calc;; double sxy_err;; bool fix_sxy;; double tx_init; // t parameter for 1D ridges (x direction); double tx_calc;; double tx_err;; bool fix_tx;; double ty_init; // t parameter for 1D ridges (y direction); double ty_calc;; double ty_err;; bool fix_ty;; double sx_init; // s parameter for 1D ridges (x direction); double sx_calc;; double sx_err;; bool fix_sx;; double sy_init; // s parameter for 1D ridges (y direction); double sy_calc;; double sy_err;; bool fix_sy;; double bx_init; // b parameter for 1D ridges (x direction); double bx_calc;; double bx_err;; bool fix_bx;; double by_init; // b parameter for 1D ridges (y direction); double by_calc;; double by_err;; bool fix_by;; double a0_init; // background is estimated as a0+ax*x+ay*y; double a0_calc;; double a0_err;; bool fix_a0;; double ax_init;; double ax_calc;; double ax_err;; bool fix_ax;; double ay_init;; double ay_calc;; double ay_err;; bool fix_ay;; };; ```. The example of the original spectrum and the fitted spectrum is given in; Figures 5.6 and 5.7, respectively. We have fitted 5 peaks. Each peak was; represented by 7 parameters, which together with `sigmax`, `sigmay",MatchSource.DOCS,documentation/spectrum/Spectrum.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md
https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:626,Deployability,continuous,continuous,626,"# BACKGROUND ELIMINATION. ## 1-DIMENSIONAL SPECTRA. This function calculates background spectrum from the source spectrum. The; result is placed in the vector pointed by spectrum pointer. On; successful completion it returns 0. On error it returns pointer to the; string describing error. ``` {.cpp}; char *Background1(float *spectrum,; int size,; int number_of_iterations);; ```. Function parameters:. - **`spectrum`**: pointer to the vector of the source spectrum; - **`size`**: length of spectrum; - **`number_of_iterations`**: or width of the clipping window. The function allows to separate useless spectrum information (continuous; background) from peaks, based on Sensitive Nonlinear Iterative Peak; Clipping Algorithm. In fact, it represents the second order difference filter; (-1,2,-1). The basic algorithm is described in details in [1], [2]. $$ v_p(i)= min\left\{v_{p-1} , \frac{[v_{p-1}(i+p)+v_{p-1}(i-p)]}{2} \right\} $$. where `p` can be changed as follows:. a. from 1 up to a given parameter value `w` by incrementing it in each; iteration step by 1 - INCREASING CLIPPING WINDOW. b. from a given value `w` by decrementing it in each iteration step by; 1 - DECREASING CLIPPING WINDOW. An example of the original spectrum and estimated background (INCREASING; CLIPPING WINDOW) is given in the Figure 1.1. ![Example of the original spectrum and estimated background (INCREASING; CLIPPING WINDOW)](figures/image004.png). One can notice that on the edges of the peaks the estimated background; goes under the peaks. An alternative approach is to decrease the; clipping window from a given value to the value of one (DECREASING; CLIPPING WINDOW). Then the result obtained is given in the Figure 1.2. ![An alternative approach is to decrease the clipping window from a given value to the value of one (DECREASING CLIPPING WINDOW)](figures/image006.png). The estimated background is smoother. The method does not deform the; shape of peaks. However, sometimes the shape of the background is ve",MatchSource.DOCS,documentation/spectrum/Spectrum.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md
https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:4459,Deployability,continuous,continuous,4459,"he generalized form of the algorithm is implemented in the following function. ``` {.cpp}; char *Background1General(float *spectrum,; int size,; int number_of_iterations,; int direction,; int filter_order,; bool compton);; ```. The meaning of the parameters is as follows:. - **`spectrum`**: pointer to the vector of the source spectrum; - **`size`**: length of spectrum vector; - **`number_of_iterations`**: maximal width of clipping window; - **`direction`**: direction of change of clipping window. Possible values:; - `BACK1_INCREASING_WINDOW`; - `BACK1_DECREASING_WINDOW`; - **`filter_order`**: order of clipping filter. Possible values:; - `BACK1_ORDER2`; - `BACK1_ORDER4`; - `BACK1_ORDER6`; - `BACK1_ORDER8`; - **`compton`**: logical variable whether the estimation of Compton edge will be included. Possible values:; - `BACK1_EXCLUDE_COMPTON`; - `BACK1_INCLUDE_COMPTON`. ## 2-DIMENSIONAL SPECTRA. This basic background estimation function allows to separate useless; spectrum information (2D-continuous background and coincidences of peaks; with background in both dimensions) from peaks. It calculates background; spectrum from the source spectrum. The result is placed in the array; pointed by spectrum pointer. On successful completion it returns 0. On; error it returns a pointer to the string describing error. ``` {.cpp}; char *Background2(float **spectrum,; int sizex,; int sizey,; int number_of_iterations);; ```. Function parameters:. - **`spectrum`**: pointer to the array of the source spectrum; - **`sizex`**: x length of spectrum; - **`sizey`**: y length of spectrum; - **`number_of_iterations`**: width of the clipping window. In Figure 1.6 we present an example of a 2-dimensional spectrum before background elimination. ![2-dimensional spectrum before background elimination](figures/image014.png). Estimated background is shown in Figure 1.7. After subtraction we get pure; 2-dimensional peaks. ![Estimated background](figures/image016.png). Similarly to 1-dimensional case, ",MatchSource.DOCS,documentation/spectrum/Spectrum.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md
https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:8506,Deployability,continuous,continuous,8506,"terations_x,; int number_of_iterations_y,; int direction,; int filter_order,; int filter_type);; ```. This function calculates background spectrum from source spectrum. The; result is placed to the array pointed by spectrum pointer. Function parameters:. - **`spectrum`**: pointer to the array of the source spectrum; - **`sizex`**: x length of spectrum; - **`sizey`**: y length of spectrum; - **`number_of_iterations_x_maximal`**: x width of clipping window; - **`number_of_iterations_y_maximal`**: y width of clipping window; - **`direction`**: direction of change of clipping window. Possible values:; - `BACK2_INCREASING_WINDOW`; - `BACK2_DECREASING_WINDOW`; - **`filter_order`**: order of clipping filter. Possible values:; - `BACK2_ORDER2 BACK2_ORDER4`; - `BACK2_ORDER6 BACK2_ORDER8`; - **`filter_type`**: determines the algorithm of the filtering. Possible values:; - `BACK2_SUCCESSIVE_FILTERING`; - `BACK2_ONE_STEP_FILTERING`. In what follows we describe a function to estimate a continuous; 2-dimensional background together with rectangular and skew ridges. In; Figure 1.13 we present a spectrum of this type. ![Function to estimate continuous 2-dimensional background together with rectangular and skew ridges](figures/image030.png). The goal is to remove rectangular as well as skew ridges from the; spectrum and to leave only 2-dimensional coincidence peaks. After; applying background elimination function and subtraction we get the two-dimensional peaks presented in Figure 1.14. ![Two dimensional peaks obtained after applying background elimination function and subtraction](figures/image032.png). In Figures 1.15 and 1.16 we present an experimental spectrum with skew ridges and estimated background, respectively. ![Experimental spectrum with skew ridges](figures/image034.png). ![Experimental spectrum with estimated background](figures/image036.png). The function for the estimation of background together with skew ridges; has the form of. ``` {.cpp}; char *Background2SkewRidges",MatchSource.DOCS,documentation/spectrum/Spectrum.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md
https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:8661,Deployability,continuous,continuous,8661,"t is placed to the array pointed by spectrum pointer. Function parameters:. - **`spectrum`**: pointer to the array of the source spectrum; - **`sizex`**: x length of spectrum; - **`sizey`**: y length of spectrum; - **`number_of_iterations_x_maximal`**: x width of clipping window; - **`number_of_iterations_y_maximal`**: y width of clipping window; - **`direction`**: direction of change of clipping window. Possible values:; - `BACK2_INCREASING_WINDOW`; - `BACK2_DECREASING_WINDOW`; - **`filter_order`**: order of clipping filter. Possible values:; - `BACK2_ORDER2 BACK2_ORDER4`; - `BACK2_ORDER6 BACK2_ORDER8`; - **`filter_type`**: determines the algorithm of the filtering. Possible values:; - `BACK2_SUCCESSIVE_FILTERING`; - `BACK2_ONE_STEP_FILTERING`. In what follows we describe a function to estimate a continuous; 2-dimensional background together with rectangular and skew ridges. In; Figure 1.13 we present a spectrum of this type. ![Function to estimate continuous 2-dimensional background together with rectangular and skew ridges](figures/image030.png). The goal is to remove rectangular as well as skew ridges from the; spectrum and to leave only 2-dimensional coincidence peaks. After; applying background elimination function and subtraction we get the two-dimensional peaks presented in Figure 1.14. ![Two dimensional peaks obtained after applying background elimination function and subtraction](figures/image032.png). In Figures 1.15 and 1.16 we present an experimental spectrum with skew ridges and estimated background, respectively. ![Experimental spectrum with skew ridges](figures/image034.png). ![Experimental spectrum with estimated background](figures/image036.png). The function for the estimation of background together with skew ridges; has the form of. ``` {.cpp}; char *Background2SkewRidges(float **spectrum,; int sizex,; int sizey,; int number_of_iterations_x,; int number_of_iterations_y,; int direction,; int filter_order);; ```. The result is placed to the array p",MatchSource.DOCS,documentation/spectrum/Spectrum.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md
https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:10341,Deployability,continuous,continuous,10341,"ted background](figures/image036.png). The function for the estimation of background together with skew ridges; has the form of. ``` {.cpp}; char *Background2SkewRidges(float **spectrum,; int sizex,; int sizey,; int number_of_iterations_x,; int number_of_iterations_y,; int direction,; int filter_order);; ```. The result is placed to the array pointed by spectrum pointer. Function parameters:. - **`spectrum`**: pointer to the array of the source spectrum; - **`sizex`**: x length of spectrum; - **`sizey`**: y length of spectrum; - **`number_of_iterations_x`**: maximal x width of clipping window; - **`number_of_iterations_y`**: maximal y width of clipping window; - **`direction`**: direction of change of clipping window. Possible values:; - `BACK2_INCREASING_WINDOW`; - `BACK2_DECREASING_WINDOW`; - **`filter_order`**: order of clipping filter. Possible values:; - `BACK2_ORDER2`; - `BACK2_ORDER4`; - `BACK2_ORDER6`; - `BACK2_ORDER8`. Next we present the function that estimates the continuous; background together with rectangular and nonlinear ridges. To; illustrate the data of such a form we present synthetic data shown in; Figure 1.17. The estimated background is given in Figure 1.18. Pure Gaussian; after subtracting the background from the original spectrum is shown in; Figure 1.19. ![Synthetic data](figures/image038.png). ![Estimated background](figures/image040.png). ![Pure Gaussian after subtracting the background from the original spectrum ](figures/image042.png). The function to estimate also the nonlinear ridges has the form of. ``` {.cpp}; char *Background2NonlinearRidges(float **spectrum,; int sizex,; int sizey,; int number_of_iterations_x,; int number_of_iterations_y,; int direction,; int filter_order);; ```. The result is placed to the array pointed by spectrum pointer. Function parameters:. - **`spectrum`**: pointer to the array of the source spectrum; - **`sizex`**: x length of spectrum; - **`sizey`**: y length of spectrum; - **`number_of_iterations_x`**: max",MatchSource.DOCS,documentation/spectrum/Spectrum.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md
https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:16633,Deployability,continuous,continuous,16633,"p}; char *Smooth2(float **spectrum,; int sizex,; int sizey,; int pointsx,; int pointsy);; ```. This function calculates smoothed spectrum from the source spectrum. The; result is placed in the array pointed by the spectrum pointer. Function parameters:. - **`spectrum`**: pointer to the array of the source spectrum; - **`sizex`**: x length of spectrum; - **`sizey`**: y length of spectrum; - **`pointsx, pointsy`**: width of smoothing window. Possible values:; - `SMOOTH2_3POINTS`; - `SMOOTH2_5POINTS`; - `SMOOTH2_7POINTS`; - `SMOOTH2_9POINTS`; - `SMOOTH2_11POINTS`; - `SMOOTH2_13POINTS`; - `SMOOTH2_15POINTS`. An example of 2-D original data and data after smoothing is given in Figures 2.2, 2.3. ![2-D original data](figures/image054.png). ![Data after smoothing](figures/image056.png). # PEAK SEARCHING. ## 1-DIMENSIONAL SPECTRA. The basic function of the 1-dimensional peak searching is described in; details in [4], [5]. It allows to automatically identify the; peaks in a spectrum with the presence of the continuous background and; statistical fluctuations -- noise. The algorithm is based on smoothed; second differences that are compared to its standard deviations.; Therefore it is necessary to pass a parameter of sigma to the peak; searching function. The algorithm is selective to the peaks with a; given sigma. The form of the basic peak searching function is. ```{.cpp}; Int_t Search1(const float *spectrum,; int size,; double sigma);; ```. This function searches for peaks in the source spectrum. The number of found; peaks and their positions are written into structure pointed by; `one_dim_peak` structure pointer. Function parameters:. - **`source`**: pointer to the vector of the source spectrum; - **`p`**: pointer to the `one_dim_peak` structure pointer; - **`size`**: length of the source spectrum; - **`sigma`**: sigma of searched peaks. The `one_dim_peak` structure has the form of. ```{.cpp}; struct one_dim_peak{; int number_of_peaks;; double position[MAX_NUMBER_OF_PEAKS1",MatchSource.DOCS,documentation/spectrum/Spectrum.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md
https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:21453,Deployability,continuous,continuous,21453,"; algorithms to the spectrum with the peaks with `sigma` changing from 1 to; 10 (see Figure 3.6). ![Robustness of the proposed algorithms to the spectrum with the peaks with sigma changing from 1 to 10](figures/image068.png). We applied peak searching algorithm based on Markov approach. We changed; `sigma` in the interval from 1 to 10. The spectra for averaging windows 3,; 5, 10 are shown in Figure 3.7. ![Spectra for averaging windows 3, 5, 10](figures/image070.png). When we applied peak searching function to the Markov spectrum averaged; with the `window=10`, we obtained correct estimate of all 10 peak; positions for `sigma=2,3,4,5,6,7,8`. It was not the case when we made the; same experiment with the original spectrum. For all sigmas some peaks; were not discovered. ## 2-DIMENSIONAL SPECTRA. The basic function of the 2-dimensional peak searching is described in; details in [4]. It automatically identifies the peaks in a; spectrum with the presence of the continuous background, statistical; fluctuations as well as coincidences of background in one dimension and; peak in the other one-ridges. The form of the basic function of; 2-dimensional peak searching is. ```{.cpp}; Int_t Search2(const float **source,; int sizex,; int sizey,; double sigma);; ```. This function searches for peaks in the source spectrum. The number of found; peaks and their positions are written into the structure pointed by; `two_dim_peak` structure pointer. Function parameters:. - **`source`**: pointer to the vector of the source spectrum; - **`sizex`**: x length of the source spectrum; - **`sizey`**: y length of the source spectrum; - **`sigma`**: sigma of searched peaks. An example of the two-dimensional spectrum with the identified peaks is; shown in Figure 3.8. ![Two-dimensional spectrum with the identified peaks](figures/image072.png). We have also generalized the peak searching function similarly to one-dimensional data. The generalized peak searching function for two-dimensional spectra ha",MatchSource.DOCS,documentation/spectrum/Spectrum.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md
https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:20415,Energy Efficiency,energy,energy,20415,"at sigma,; int threshold,; bool markov,; int aver_window);; ```. This function searches for peaks in the source spectrum. The number of found; peaks and their positions are written into the structure pointed by the; `one_dim_peak` structure pointer. Function parameters:. - **`spectrum`**: pointer to the vector of the source spectrum. This source spectrum is replaced by the new spectrum calculated using Markov chains method.; - **`size`**: length of the source spectrum; - **`sigma`**: sigma of searched peaks; - **`threshold`**: threshold value for peaks selection; - **`markov`**: logical variable. If it is set to `true`, then the source spectrum is first replaced by the new spectrum calculated using Markov chains method; - **`aver_window`**: averaging window used in the calculation of Markov spectrum, applies only if the `markov` variable was set to `true`. The methods of peak searching are sensitive to the `sigma`. Usually the; `sigma` value is known beforehand. It also changes only slightly with the; energy. We have investigated as well the robustness of the proposed; algorithms to the spectrum with the peaks with `sigma` changing from 1 to; 10 (see Figure 3.6). ![Robustness of the proposed algorithms to the spectrum with the peaks with sigma changing from 1 to 10](figures/image068.png). We applied peak searching algorithm based on Markov approach. We changed; `sigma` in the interval from 1 to 10. The spectra for averaging windows 3,; 5, 10 are shown in Figure 3.7. ![Spectra for averaging windows 3, 5, 10](figures/image070.png). When we applied peak searching function to the Markov spectrum averaged; with the `window=10`, we obtained correct estimate of all 10 peak; positions for `sigma=2,3,4,5,6,7,8`. It was not the case when we made the; same experiment with the original spectrum. For all sigmas some peaks; were not discovered. ## 2-DIMENSIONAL SPECTRA. The basic function of the 2-dimensional peak searching is described in; details in [4]. It automatically identi",MatchSource.DOCS,documentation/spectrum/Spectrum.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md
https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:26920,Energy Efficiency,energy,energy,26920,"Hx $$; $$ H^T=H^THx $$; $$ y^{'} = H^{'}x $$; $$x_{i}^{(k+1)}=\frac{y_{i}^{'}}{\sum_{m=0}^{N-1}H_{im}^{'}x_{m}^{(k)}}x_{i}^{(k)}, i=0,1,...,N-1, $$; where:; $$ k=1,2,3,...,I $$; $$ x^{(0)} = [1,1,...,1]^T $$. The basic function has the form of. ```{.cpp}; char *Deconvolution1(float *source,; const float *resp,; int size,; int number_of_iterations);; ```. This function calculates deconvolution from the source spectrum according to the response spectrum. Function parameters:. - **`source`**: pointer to the vector of the source spectrum; - **`resp`**: pointer to the vector of the response spectrum; - **`size`**: length of source and the response spectra; - **`number_of_iterations`**: for details see [8]. As an illustration of the method, let us introduce a small example. In; Figure 4.1 we present original 1-dimensional spectrum. It contains; multiplets that cannot be directly analyzed. The response function (one; peak) is given in Figure 4.2. We assume the same response function (not; changing the shape) along the entire energy scale. So the response; matrix is composed of mutually shifted response functions by one; channel, however of the same shape. ![Original 1-dimensional spectrum](figures/image086.png). ![Response function (one peak)](figures/image088.png). The result after deconvolution is given in Figure 4.3. It substantially; improves the resolution in the spectrum. ![Result after deconvolution](figures/image090.png). We have developed a new high resolution deconvolution algorithm. We have; observed that the Gold deconvolution converges to its stable state; (solution). It is useless to increase the number of iterations, the; result obtained does not change. To continue decreasing the width of; peaks, we have found that when the solution reaches its stable state, it; is necessary to stop iterations, then to change the vector in a way and; repeat again the Gold deconvolution. We have found that in order to change the; particular solution we need to apply a non-li",MatchSource.DOCS,documentation/spectrum/Spectrum.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md
https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:27921,Energy Efficiency,power,power,27921,"response; matrix is composed of mutually shifted response functions by one; channel, however of the same shape. ![Original 1-dimensional spectrum](figures/image086.png). ![Response function (one peak)](figures/image088.png). The result after deconvolution is given in Figure 4.3. It substantially; improves the resolution in the spectrum. ![Result after deconvolution](figures/image090.png). We have developed a new high resolution deconvolution algorithm. We have; observed that the Gold deconvolution converges to its stable state; (solution). It is useless to increase the number of iterations, the; result obtained does not change. To continue decreasing the width of; peaks, we have found that when the solution reaches its stable state, it; is necessary to stop iterations, then to change the vector in a way and; repeat again the Gold deconvolution. We have found that in order to change the; particular solution we need to apply a non-linear boosting function to it.; The power function proved to give the best results. At the beginning the; function calculates exact solution of the Toeplitz system of linear; equations. $$ x^{(0)} = [x_e^2(0),x_e^2(1),...,x_e^2(N-1),]^T$$; where; $$ x_e=H^{'-1}y^{'}$$. Then it applies the Gold deconvolution algorithm to the solution and; carries out preset number of iterations. Then the power function with; the exponent equal to the boosting coefficient is applied to the; deconvolved data. These data are then used as initial estimate of the; solution of linear system of equations and again the Gold algorithm is; employed. The whole procedure is repeated `number_of_repetitions` times. The form of the high-resolution deconvolution function is. ```{.cpp}; char *Deconvolution1HighResolution(float *source,; const float *resp,; int size,; int number_of_iterations,; int number_of_repetitions,; double boost);; ```. This function calculates deconvolution from the source spectrum according; to the response spectrum. The result is placed in the vector ",MatchSource.DOCS,documentation/spectrum/Spectrum.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md
https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:28275,Energy Efficiency,power,power,28275,"e090.png). We have developed a new high resolution deconvolution algorithm. We have; observed that the Gold deconvolution converges to its stable state; (solution). It is useless to increase the number of iterations, the; result obtained does not change. To continue decreasing the width of; peaks, we have found that when the solution reaches its stable state, it; is necessary to stop iterations, then to change the vector in a way and; repeat again the Gold deconvolution. We have found that in order to change the; particular solution we need to apply a non-linear boosting function to it.; The power function proved to give the best results. At the beginning the; function calculates exact solution of the Toeplitz system of linear; equations. $$ x^{(0)} = [x_e^2(0),x_e^2(1),...,x_e^2(N-1),]^T$$; where; $$ x_e=H^{'-1}y^{'}$$. Then it applies the Gold deconvolution algorithm to the solution and; carries out preset number of iterations. Then the power function with; the exponent equal to the boosting coefficient is applied to the; deconvolved data. These data are then used as initial estimate of the; solution of linear system of equations and again the Gold algorithm is; employed. The whole procedure is repeated `number_of_repetitions` times. The form of the high-resolution deconvolution function is. ```{.cpp}; char *Deconvolution1HighResolution(float *source,; const float *resp,; int size,; int number_of_iterations,; int number_of_repetitions,; double boost);; ```. This function calculates deconvolution from the source spectrum according; to the response spectrum. The result is placed in the vector pointed by the source pointer. Function parameters:. - **`source`**: pointer to the vector of the source spectrum; - **`resp`**: pointer to the vector of the response spectrum; - **`size`**: length of source and the response spectra; - **`number_of_iterations`**: for details we refer to manual; - **`number_of_repetitions`**: for details we refer to manual; - **`boost`**: boosti",MatchSource.DOCS,documentation/spectrum/Spectrum.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md
https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:39862,Energy Efficiency,power,powers,39862,"t together tens, hundreds of peaks; simultaneously that sometimes represent thousands of parameters. - the calculation of the inversion matrix of such a size is; practically impossible. - the awmi method is based on the assumption that the off-diagonal; terms in the matrix A are equal to zero. $$; \Delta a_{k}^{(t+1)} = \alpha^{(t)}; \frac{; \sum_{i=1}^{N} \frac{e_{i}^{(t)}}{y_i}\frac{\partial f(i,a^{(t)})}{\partial a_k}; }{; \sum_{i=1}^{N} \left[ \frac{\partial f(i,a^{(t)})}{\partial a_k}\right]^2\frac{1}{y_i}; }; $$. where the error in the channel `i` is $e_{i}^{(t)} = y_i-f(i,a^{(t)}); k=1,2,...,M$ and; $\alpha^{(t)}=1$ if the process is convergent or $\alpha^{(t)}=0.5 \alpha^{(t-1)}$; if it is divergent. Another possibility is to optimize this coefficient. The error of `k`-th parameter estimate is. $$; \Delta a_k^{(e)}=; \sqrt{\frac; {\sum_{i=1}^{N}\frac{e_i^2}{y_i}}; {\sum_{i=1}^{N} \left[ \frac{\partial f(i,a^{(t)})}{\partial a_k}\right]^2\frac{1}{y_i}}; }; $$. Algorithm with higher powers `w=1,2,3...`:. $$; \Delta a_{k,w}^{(t+1)}=; \alpha^{(t)}; \frac; {\sum_{i=1}^{N} \frac{e_i}{y_i}\left[ \frac{\partial f(i,a^{(t)})}{\partial a_k}\right]^{2w-1}}; {\sum_{i=1}^{N} \left[ \frac{\partial f(i,a^{(t)})}{\partial a_k}\right]^{2w}\frac{1}{y_i}}; $$. We have implemented the non-symmetrical semi-empirical peak shape function. It contains the symmetrical Gaussian as well as non-symmetrical terms:. $$; f(i,a) =; \sum_{i=1}^{M} A(j); \left\{; exp\left[\frac{-(i-p(j))^2}{2\sigma^2}\right]; +\frac{1}{2}T.exp\left[\frac{(i-p(j))}{B\sigma}\right]; .erfc\left[\frac{(i-p(j))}{\sigma}+\frac{1}{2B}\right]; +\frac{1}{2}S.erfc\left[\frac{(i-p(j))}{\sigma}\right]; \right\}; $$. where `T, S` are relative amplitudes and `B` is a slope. Detailed description of the algorithm is given in [13]. The fitting function implementing the algorithm without matrix inversion; has the form of. ``` {.cpp}; char* Fit1Awmi(float *source,; TSpectrumOneDimFit *p,; int size);; ```. This function fits the",MatchSource.DOCS,documentation/spectrum/Spectrum.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md
https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:42162,Energy Efficiency,power,power,42162,"ource spectrum. The calling program should fill; in the input parameters of the `one_dim_fit` structure. The fitted parameters; are written into structure pointed by `one_dim_fit` structure pointer; and fitted data are written into source spectrum. Function parameters:. - **`source`**: pointer to the vector of the source spectrum; - **`p`**: pointer to the `one_dim_fit` structure pointer; - **`size`**: length of the source spectrum. The `one_dim_fit` structure has the form of. ``` {.cpp}; class TSpectrumOneDimFit{. public:. int number_of_peaks; // input parameter, should be >0; int number_of_iterations; // input parameter, should be >0; int xmin; // first fitted channel; int xmax; // last fitted channel; double alpha; // convergence coefficient, input parameter, it should be a positive number and <=1; double chi; // here the function returns the resulting chi-square; int statistic_type; // type of statistics, possible values are:; // FIT1_OPTIM_CHI_COUNTS (chi square statistics with counts as weighting coefficients),; // FIT1_OPTIM_CHI_FUNC_VALUES (chi square statistics with function values as weighting coefficients); // FIT1_OPTIM_MAX_LIKELIHOOD; int alpha_optim; // optimization of convergence coefficients, possible values are:; // FIT1_ALPHA_HALVING,; // FIT1_ALPHA_OPTIMAL; int power; // possible values FIT1_FIT_POWER2,4,6,8,10,12; int fit_taylor; // order of Taylor expansion, possible values; // FIT1_TAYLOR_ORDER_FIRST, FIT1_TAYLOR_ORDER_SECOND. double position_init[MAX_NUMBER_OF_PEAKS1]; // initial values of peaks positions, input parameters; double position_calc[MAX_NUMBER_OF_PEAKS1]; // calculated values of fitted positions, output parameters; double position_err[MAX_NUMBER_OF_PEAKS1]; // position errors; bool fix_position[MAX_NUMBER_OF_PEAKS1]; // logical vector which allows to fix appropriate positions (not fit). However they are present in the estimated functional; double amp_init[MAX_NUMBER_OF_PEAKS1]; // initial values of peaks amplitudes, input parameters",MatchSource.DOCS,documentation/spectrum/Spectrum.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md
https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:46525,Energy Efficiency,power,power,46525,"ow; the fitted function corresponds much better to the experimental values. ![Fit of the original experimental spectrum (with background)](figures/image180.png). We have also implemented the fitting function with matrix inversion; based on Stiefel-Hestens method of the solution of the system of linear; equations. The form of the function is as follows:. ```{.cpp}; char *Fit1Stiefel(float *source,; TSpectrumOneDimFit* p,; int size);; ```. This function fits the source spectrum. The calling program should fill; in the input parameters of the `one_dim_fit` structure. The fitted parameters; are written into structure pointed by `one_dim_fit` structure pointer; and fitted data are written into source spectrum. Function parameters:. - **`source`**: pointer to the vector of the source spectrum; - **`p`**: pointer to the `one_dim_fit` structure pointer; - **`size`**: length of the source spectrum. The structure `one_dim_fit` is the same as in awmi function. The; parameters power, `fit_taylor`, are not applicable for this function. The results for small number of fitted parameters are the same as with; awmi function. However, it converges faster. The example for data given; in Figure 5.1 is given in the following table:. | # of iterations | Chi awmi | Chi-Stiefel |; | ---------------- | ---------| ------------ |; | 1 | 924 | 89.042 |; | 5 | 773.15 | 0.96242 |; | 10 | 38.13 | 0.77041 |; | 50 | 0.90293 | 0.76873 |; | 100 | 0.76886 | 0.76873 |; | 500 | 0.76873 | 0.76873 |. ## 2-DIMENSIONAL SPECTRA. It is straightforward that for two-dimensional spectra one can write. $$; \Delta a_k^{(t+1)}=\alpha^{(t)}; \frac; {\sum_{i_1=1}^{N_1}\sum_{i_2=1}^{N_2}\frac{e_{i_1,i_2}^{(t)}}{y_{i_1,i_2}}; \frac{\partial f(i_1,i_2,a^{(t)})}{\partial a_k}}; {\sum_{i_1=1}^{N_1}\sum_{i_2=1}^{N_2}; \left[\frac{\partial f(i_1,i_2,a^{(t)})}{\partial a_k} \right]^2; \frac{1}{y_{i_1,i_2}}}; $$. In a similar way, for two-dimensional peaks we have chosen the peak shape; function of the following form:. $$; f(i",MatchSource.DOCS,documentation/spectrum/Spectrum.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md
https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:49817,Energy Efficiency,power,power,49817,"to the `two_dim_fit` structure pointer, see manual; - **`sizex`**: length x of the source spectrum; - **`sizey`**: length y of the source spectrum. The `two_dim_fit` structure has the form of. ``` {.cpp}; class TSpectrumTwoDimFit{. public:. int number_of_peaks; // input parameter, should be>0; int number_of_iterations; // input parameter, should be >0; int xmin; // first fitted channel in x direction; int xmax; // last fitted channel in x direction; int ymin; // first fitted channel in y direction; int ymax; // last fitted channel in y direction; double alpha; // convergence coefficient, input parameter, it should be a positive number and <=1; double chi; // here the function returns resulting chi square; int statistic_type; // type of statistics, possible values are:; // FIT2_OPTIM_CHI_COUNTS (chi square statistics with counts as weighting coefficients),; // FIT2_OPTIM_CHI_FUNC_VALUES (chi square statistics with function values as weighting coefficients),; // FIT2_OPTIM_MAX_LIKELIHOOD; int alpha_optim; // optimization of convergence coefficients, possible values are:; // FIT2_ALPHA_HALVING, FIT2_ALPHA_OPTIMAL; int power; // possible values are: FIT21_FIT_POWER2,4,6,8,10,12; int fit_taylor; // order of Taylor expansion, possible values are:; // FIT2_TAYLOR_ORDER_FIRST,; // FIT2_TAYLOR_ORDER_SECOND; double position_init_x[MAX_NUMBER_OF_PEAKS2]; // initial values of x positions of 2D peaks, input parameters; double position_calc_x[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitted x positions of 2D peaks, output parameters; double position_err_x[MAX_NUMBER_OF_PEAKS2]; // x position errors of 2D peaks; bool fix_position_x[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix the appropriate x positions of 2D peaks (not fit). However, they are present in the estimated functional; double position_init_y[MAX_NUMBER_OF_PEAKS2]; // initial values of y positions of 2D peaks, input parameters; double position_calc_y[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitt",MatchSource.DOCS,documentation/spectrum/Spectrum.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md
https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:56762,Energy Efficiency,power,power,56762,"2.png). ![Fitted function](figures/image194.png). We have implemented the fitting function with matrix inversion based on; Stiefel-Hestens method of the solution of the system of linear equations; also for 2-dimensional data. The form of the function is as follows. ```{.cpp}; char* Fit2Stiefel(float **source,; TSpectrumTwoDimFit* p,; int sizex,; int sizey);; ```. This function fits the source spectrum. The calling program should; fill in the input parameters of the `two_dim_fit structure`. The fitted; parameters are written into structure pointed by `two_dim_fit` structure; pointer and fitted data are written back into the source spectrum. Function parameters:. - **`source`**: pointer to the matrix of the source spectrum; - **`p`**: pointer to the `two_dim_fit` structure pointer, see manual; - **`sizex`**: length x of the source spectrum; - **`sizey`**: length y of the source spectrum. The structure `two_dim_fit` is the same as in the awmi function. The; parameters power, `fit_taylor` are not applicable for this function. The results for small number of fitted parameters are the same as with; awmi function. However, it converges faster. The example for data given; in Figure 5.6 (38 parameters) is presented in the following table:. | # of iterations | Chi awmi | Chi-Stiefel |; | ---------------- | ---------| ------------ |; | 1 | 24.989 | 10.415 |; | 5 | 20.546 | 1.0553 |; | 10 | 6.256 | 0.84383 |; | 50 | 1.0985 | 0.64297 |; | 100 | 0.6571 | 0.64297 |; | 500 | 0.65194 | 0.64297 |. Again, Stiefel-Hestens method converges faster. However, its calculation; is for this number of parameters takes approximately 3 times longer. For; larger number of parameters the time needed to calculate the inversion; grows with the cube of the number of fitted parameters. For example, the; fit of large number of parameters (2068) for data in Figure 5.8 using awmi; algorithm took about 12 hours (using 450 MHz PC). The calculation; using matrix inversion method is not realizable in any rea",MatchSource.DOCS,documentation/spectrum/Spectrum.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md
https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:67439,Energy Efficiency,efficient,efficient,67439,"ngth to store real and imaginary; coefficients; - **`sizex,sizey`**: basic dimensions of the source and dest spectra; - **`type`**: type of transform; - `TRANSFORM2_HAAR`; - `TRANSFORM2_WALSH`; - `TRANSFORM2_COS`; - `TRANSFORM2_SIN`; - `TRANSFORM2_FOURIER`; - `TRANSFORM2_HARTLEY`; - `TRANSFORM2_FOURIER_WALSH`; - `TRANSFORM2_FOURIER_HAAR`; - `TRANSFORM2_WALSH_HAAR`; - `TRANSFORM2_COS_WALSH`; - `TRANSFORM2_COS_HAAR`; - `TRANSFORM2_SIN_WALSH`; - `TRANSFORM2_SIN_HAAR`; - **`direction`**: transform direction (forward, inverse); - **`degree`**: applies only for mixed transforms. An example of the 2-dimensional Cosine transform of data from Figure 5.6 is; given in Figure 6.7. One can notice that the data are concentrated again; around the beginning of the coordinate system. This allows to apply; filtration, enhancement and compression techniques in the transform; domain. ![2-dimensional Cosine transform of data from Figure 5.6](figures/image208.png). In some cases, when the spectrum is smooth, the cosine transforms are very; efficient. In Figures 6.8, 6.9 we show original spectrum and transformed; coefficients using Cosine transform, respectively. ![Original spectrum](figures/image210.png). ![Transformed coefficients using Cosine transform](figures/image212.png). Similarly to 1-dimensional case we have also implemented the functions for zonal filtration, Gauss filtration and enhancement.; The zonal filtration function using classic transforms has the form of. ```{.cpp}; char *Filter2Zonal(const float **source,; float **dest,; int sizex,; int sizey,; int type,; int degree,; int xmin,; int xmax,; int ymin,; int ymax,; float filter_coeff);; ```. This function transforms the source spectrum. The calling program should; fill in the input parameters. Then it sets transformed coefficients in the; given region to the given; `filter_coeff` and transforms it back. Filtered data are written into the dest; spectrum. Function parameters:. - **`source`**: pointer to the matrix of source ",MatchSource.DOCS,documentation/spectrum/Spectrum.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md
https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:18938,Integrability,depend,depending,18938,"l spectrum with many identified peaks](figures/image060.png). However, when we have noisy data, the number of peaks can be enormous. One; such an example is given in Figure 3.3. ![With noisy data the number of peaks can be enormous](figures/image062.png). Therefore it can be useful to have a possibility to set a threshold value and to consider only the peaks higher than this threshold (see Figure 3.4, only three peaks were identified, threshold=50). The value in the center of the peak (`value[i]`) minus the average value in two symmetrically positioned channels (channels `i-3*sigma`, `i+3*sigma`) must be greater than threshold.; Otherwise the peak is ignored. ![Iwth threshold=50, only three peaks were identified](figures/image064.png). An alternative approach was proposed in [6]. The algorithm generates; new invariant spectrum based on discrete Markov chains. In this spectrum; the noise is suppressed, the spectrum is smoother than the original one.; On the other hand it emphasizes peaks (depending on the averaging; window). The example of the part of original noisy spectrum and Markov; spectrum for `window=3` is given in Figure 3.5 Then the peaks can be found in; Markov spectrum using standard above-presented algorithm. ![Part of original noisy spectrum and Markov spectrum for window=3](figures/image066.png). The form of the generalized peak searching function is as follows:. ```{.cpp}; Int_t Search1General(float *spectrum,; int size,; float sigma,; int threshold,; bool markov,; int aver_window);; ```. This function searches for peaks in the source spectrum. The number of found; peaks and their positions are written into the structure pointed by the; `one_dim_peak` structure pointer. Function parameters:. - **`spectrum`**: pointer to the vector of the source spectrum. This source spectrum is replaced by the new spectrum calculated using Markov chains method.; - **`size`**: length of the source spectrum; - **`sigma`**: sigma of searched peaks; - **`threshold`**: thres",MatchSource.DOCS,documentation/spectrum/Spectrum.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md
https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:58513,Integrability,depend,depends,58513,"on; grows with the cube of the number of fitted parameters. For example, the; fit of large number of parameters (2068) for data in Figure 5.8 using awmi; algorithm took about 12 hours (using 450 MHz PC). The calculation; using matrix inversion method is not realizable in any reasonable time. # TRANSFORMS. ## 1-DIMENSIONAL SPECTRA. Orthogonal transforms can be successfully used for the; processing of nuclear spectra. They can be used to remove high; frequency noise, to increase signal-to-background ratio as well as to; enhance low intensity components [14]. We have implemented also the; function for the calculation of the commonly used orthogonal transforms:. - Haar; - Walsh; - Cos; - Sin; - Fourier; - Hartley. Between these transform one can define so called generalized mixed; transforms that are also implemented in the transform function:. - Fourier-Haar; - Fourier-Walsh; - Walsh-Haar; - Cos-Walsh; - Cos-Haar; - Sin-Walsh; - Sin-Haar. The suitability of the application of appropriate transform depends on; the character of the data, i.e., on the shape of dominant components; contained in the data. The form of the transform function is as follows:. ```{.cpp}; char *Transform1(const float *source,; float *dest,; int size,; int type,; int direction,; int degree);; ```. This function transforms the source spectrum. The calling program; should fill in the input parameters. Transformed data are written into the dest spectrum. Function parameters:. - **`source`**: pointer to the vector of the source spectrum, its length should be equal to the `size` parameter except for inverse FOURIER, FOUR-WALSH, FOUR-HAAR transform. These need 2*`size` length to supply real and imaginary coefficients; - **`dest`**: pointer to the vector of the dest data, its length should be equal to the size parameter except for direct FOURIER, FOUR-WALSh, FOUR-HAAR. These need 2*`size` length to store real and imaginary coefficients; - **`size`**: basic length of the source and dest spectra; - **`type",MatchSource.DOCS,documentation/spectrum/Spectrum.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md
https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:4200,Modifiability,variab,variable,4200,"igure we present; the background, which was added to the synthetic spectrum. One can; observe good coincidence with the estimated background. The method of; the estimation of Compton edge is described in details in [3]. ![Synthetic spectrum with Compton edges](figures/image012.png). The generalized form of the algorithm is implemented in the following function. ``` {.cpp}; char *Background1General(float *spectrum,; int size,; int number_of_iterations,; int direction,; int filter_order,; bool compton);; ```. The meaning of the parameters is as follows:. - **`spectrum`**: pointer to the vector of the source spectrum; - **`size`**: length of spectrum vector; - **`number_of_iterations`**: maximal width of clipping window; - **`direction`**: direction of change of clipping window. Possible values:; - `BACK1_INCREASING_WINDOW`; - `BACK1_DECREASING_WINDOW`; - **`filter_order`**: order of clipping filter. Possible values:; - `BACK1_ORDER2`; - `BACK1_ORDER4`; - `BACK1_ORDER6`; - `BACK1_ORDER8`; - **`compton`**: logical variable whether the estimation of Compton edge will be included. Possible values:; - `BACK1_EXCLUDE_COMPTON`; - `BACK1_INCLUDE_COMPTON`. ## 2-DIMENSIONAL SPECTRA. This basic background estimation function allows to separate useless; spectrum information (2D-continuous background and coincidences of peaks; with background in both dimensions) from peaks. It calculates background; spectrum from the source spectrum. The result is placed in the array; pointed by spectrum pointer. On successful completion it returns 0. On; error it returns a pointer to the string describing error. ``` {.cpp}; char *Background2(float **spectrum,; int sizex,; int sizey,; int number_of_iterations);; ```. Function parameters:. - **`spectrum`**: pointer to the array of the source spectrum; - **`sizex`**: x length of spectrum; - **`sizey`**: y length of spectrum; - **`number_of_iterations`**: width of the clipping window. In Figure 1.6 we present an example of a 2-dimensional spectrum bef",MatchSource.DOCS,documentation/spectrum/Spectrum.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md
https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:19992,Modifiability,variab,variable,19992,"and it emphasizes peaks (depending on the averaging; window). The example of the part of original noisy spectrum and Markov; spectrum for `window=3` is given in Figure 3.5 Then the peaks can be found in; Markov spectrum using standard above-presented algorithm. ![Part of original noisy spectrum and Markov spectrum for window=3](figures/image066.png). The form of the generalized peak searching function is as follows:. ```{.cpp}; Int_t Search1General(float *spectrum,; int size,; float sigma,; int threshold,; bool markov,; int aver_window);; ```. This function searches for peaks in the source spectrum. The number of found; peaks and their positions are written into the structure pointed by the; `one_dim_peak` structure pointer. Function parameters:. - **`spectrum`**: pointer to the vector of the source spectrum. This source spectrum is replaced by the new spectrum calculated using Markov chains method.; - **`size`**: length of the source spectrum; - **`sigma`**: sigma of searched peaks; - **`threshold`**: threshold value for peaks selection; - **`markov`**: logical variable. If it is set to `true`, then the source spectrum is first replaced by the new spectrum calculated using Markov chains method; - **`aver_window`**: averaging window used in the calculation of Markov spectrum, applies only if the `markov` variable was set to `true`. The methods of peak searching are sensitive to the `sigma`. Usually the; `sigma` value is known beforehand. It also changes only slightly with the; energy. We have investigated as well the robustness of the proposed; algorithms to the spectrum with the peaks with `sigma` changing from 1 to; 10 (see Figure 3.6). ![Robustness of the proposed algorithms to the spectrum with the peaks with sigma changing from 1 to 10](figures/image068.png). We applied peak searching algorithm based on Markov approach. We changed; `sigma` in the interval from 1 to 10. The spectra for averaging windows 3,; 5, 10 are shown in Figure 3.7. ![Spectra for averaging ",MatchSource.DOCS,documentation/spectrum/Spectrum.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md
https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:20239,Modifiability,variab,variable,20239,"using standard above-presented algorithm. ![Part of original noisy spectrum and Markov spectrum for window=3](figures/image066.png). The form of the generalized peak searching function is as follows:. ```{.cpp}; Int_t Search1General(float *spectrum,; int size,; float sigma,; int threshold,; bool markov,; int aver_window);; ```. This function searches for peaks in the source spectrum. The number of found; peaks and their positions are written into the structure pointed by the; `one_dim_peak` structure pointer. Function parameters:. - **`spectrum`**: pointer to the vector of the source spectrum. This source spectrum is replaced by the new spectrum calculated using Markov chains method.; - **`size`**: length of the source spectrum; - **`sigma`**: sigma of searched peaks; - **`threshold`**: threshold value for peaks selection; - **`markov`**: logical variable. If it is set to `true`, then the source spectrum is first replaced by the new spectrum calculated using Markov chains method; - **`aver_window`**: averaging window used in the calculation of Markov spectrum, applies only if the `markov` variable was set to `true`. The methods of peak searching are sensitive to the `sigma`. Usually the; `sigma` value is known beforehand. It also changes only slightly with the; energy. We have investigated as well the robustness of the proposed; algorithms to the spectrum with the peaks with `sigma` changing from 1 to; 10 (see Figure 3.6). ![Robustness of the proposed algorithms to the spectrum with the peaks with sigma changing from 1 to 10](figures/image068.png). We applied peak searching algorithm based on Markov approach. We changed; `sigma` in the interval from 1 to 10. The spectra for averaging windows 3,; 5, 10 are shown in Figure 3.7. ![Spectra for averaging windows 3, 5, 10](figures/image070.png). When we applied peak searching function to the Markov spectrum averaged; with the `window=10`, we obtained correct estimate of all 10 peak; positions for `sigma=2,3,4,5,6,7,8`. It ",MatchSource.DOCS,documentation/spectrum/Spectrum.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md
https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:23121,Modifiability,variab,variable,23121," vector of the source spectrum; - **`sizex`**: x length of the source spectrum; - **`sizey`**: y length of the source spectrum; - **`sigma`**: sigma of searched peaks. An example of the two-dimensional spectrum with the identified peaks is; shown in Figure 3.8. ![Two-dimensional spectrum with the identified peaks](figures/image072.png). We have also generalized the peak searching function similarly to one-dimensional data. The generalized peak searching function for two-dimensional spectra has the form of. ```{.cpp}; Int_t Search2General(float **source,; int sizex,; int sizey,; double sigma,; int threshold,; bool markov,; int aver_window);; ```. This function searches for peaks in the source spectrum. The number of found; peaks and their positions are written into the structure pointed by; `two_dim_peak` structure pointer. Function parameters:. - **`source`**: pointer to the vector of the source spectrum; - **`sizex`**: x length of the source spectrum; - **`sizey`**: y length of the source spectrum; - **`sigma`**: sigma of searched peaks; - **`threshold`**: threshold value for peaks selection; - **`markov`**: logical variable. If it is set to `true`, then the source spectrum is first replaced by the new spectrum calculated using Markov chains method; - **`aver_window`** averaging window of searched peaks (applies only for the Markov method). An example of experimental 2-dimensional spectrum is given in Figure 3.9.; The number of peaks identified by the function now is 295. ![Experimental 2-dimensional spectrum](figures/image074.png). The function works even for very noisy data. In Figure 3.10 we present; synthetic 2-dimensional spectrum with 5 peaks. The method should; recognize what is the real 2-dimensional peak and what is the crossing of; two 1-dimensional ridges. The Markov spectrum with averaging window=3 is; given in Figure 3.11. One can observe that this spectrum is smoother than; the original one. After applying the general peak searching function to; the M",MatchSource.DOCS,documentation/spectrum/Spectrum.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md
https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:32603,Modifiability,extend,extended,32603,"iginal spectrum, are presented in the Figure 4.8. ![Original spectrum before unfolding](figures/image100.png). ![Contents of the responses in the original spectrum](figures/image102.png). Another example where we have used the unfolding method is the; decomposition of continuum of gamma-ray spectra. Using simulation and; interpolation techniques, we have synthesized the response matrix (size; `3400x3400` channels) of Gammasphere spectrometer (Figure 4.9). Its details are; presented in Figure 4.10. The original spectrum of Co^56 before and after; continuum decomposition are presented in Figures 4.11, 4.12, respectively. ![Response matrix (size 3400x3400 channels) of Gammasphere spectrometer](figures/image104.png). ![Detail of Figure 4.9](figures/image106.png). ![Original spectrum of Co56 before continuum decomposition](figures/image108.png). ![Original spectrum of Co56 after continuum decomposition](figures/image110.png). ## 2-DIMENSIONAL SPECTRA. We have extended the method of Gold deconvolution also for; 2-dimensional data. Again, the goal of the deconvolution methods is to; improve the resolution in the spectrum and to decompose multiplets. The method of optimized 2-dimensional deconvolution is described in details in [8]. Mathematical formulation of 2-dimensional convolution system is as; follows:. $$ y(i_1,i_2) = \sum_{k_1=0}^{N_1-1}\sum_{k_2=0}^{N_2-1}h(i_1-k_1,i_2-k_2)x(k_1,k_2), i_1=0,1,2,...,N_1-1, i_2=0,1,2,...,N_2-1 $$. Assuming we know the output; spectrum `y` and the response spectrum `h`, the task is to calculate the matrix `x`. The basic function has the form of. ``` {.cpp}; char *Deconvolution2(float **source,; const float **resp,; int sizex,; int sizey,; int niter);; ```. This function calculates deconvolution from the source spectrum according to; the response spectrum. The result is placed in the matrix pointed by the source; pointer. Function parameters:. - **`source`**: pointer to the matrix of the source spectrum; - **`resp`**: pointer to the ma",MatchSource.DOCS,documentation/spectrum/Spectrum.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md
https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:58027,Modifiability,enhance,enhance,58027,") is presented in the following table:. | # of iterations | Chi awmi | Chi-Stiefel |; | ---------------- | ---------| ------------ |; | 1 | 24.989 | 10.415 |; | 5 | 20.546 | 1.0553 |; | 10 | 6.256 | 0.84383 |; | 50 | 1.0985 | 0.64297 |; | 100 | 0.6571 | 0.64297 |; | 500 | 0.65194 | 0.64297 |. Again, Stiefel-Hestens method converges faster. However, its calculation; is for this number of parameters takes approximately 3 times longer. For; larger number of parameters the time needed to calculate the inversion; grows with the cube of the number of fitted parameters. For example, the; fit of large number of parameters (2068) for data in Figure 5.8 using awmi; algorithm took about 12 hours (using 450 MHz PC). The calculation; using matrix inversion method is not realizable in any reasonable time. # TRANSFORMS. ## 1-DIMENSIONAL SPECTRA. Orthogonal transforms can be successfully used for the; processing of nuclear spectra. They can be used to remove high; frequency noise, to increase signal-to-background ratio as well as to; enhance low intensity components [14]. We have implemented also the; function for the calculation of the commonly used orthogonal transforms:. - Haar; - Walsh; - Cos; - Sin; - Fourier; - Hartley. Between these transform one can define so called generalized mixed; transforms that are also implemented in the transform function:. - Fourier-Haar; - Fourier-Walsh; - Walsh-Haar; - Cos-Walsh; - Cos-Haar; - Sin-Walsh; - Sin-Haar. The suitability of the application of appropriate transform depends on; the character of the data, i.e., on the shape of dominant components; contained in the data. The form of the transform function is as follows:. ```{.cpp}; char *Transform1(const float *source,; float *dest,; int size,; int type,; int direction,; int degree);; ```. This function transforms the source spectrum. The calling program; should fill in the input parameters. Transformed data are written into the dest spectrum. Function parameters:. - **`source`**: pointer t",MatchSource.DOCS,documentation/spectrum/Spectrum.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md
https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:60656,Modifiability,enhance,enhanced,60656," `TRANSFORM1_HARTLEY`; - `TRANSFORM1_FOURIER_WALSH`; - `TRANSFORM1_FOURIER_HAAR`; - `TRANSFORM1_WALSH_HAAR`; - `TRANSFORM1_COS_WALSH`; - `TRANSFORM1_COS_HAAR`; - `TRANSFORM1_SIN_WALSH`; - `TRANSFORM1_SIN_HAAR`; - **`direction`**: transform direction (forward, inverse); - `TRANSFORM1_FORWARD`; - `TRANSFORM1_INVERSE`; - **`degree`**: applies only for mixed transforms. Let us illustrate the applications of the transform using an example. In Figure 6.1 we have spectrum with many peaks, complicated background and high level of noise. ![Spectrum with many peaks](figures/image196.png). In Figures 6.2, 6.3, 6.4 we present this spectrum transformed using Haar,; Walsh and Cosine transforms, respectively. ![Spectrum transformed using Haar transform](figures/image198.png). ![Spectrum transformed using Walsh transform](figures/image200.png). ![Spectrum transformed using Cosine transform](figures/image202.png). Haar transforms (Figure 6.2) creates clusters of data. These coefficients; can be analyzed and then filtered, enhanced, etc. On the other hand, the Walsh; transform (Figure 6.3) concentrates the dominant components near zero of; the coordinate system. It is more suitable to process data of a; rectangular shape (e.g., in the field of digital signal processing).; Finally, Cosine transform concentrates in the best way the transform; coefficients to the beginning of the coordinate system. From the point; of view of the variance distribution, it is sometimes called suboptimal.; One can notice that approximately one half of the coefficients are; negligible. This fact can be used to the compression purposes (in; two- or more dimensional data), filtering (smoothing), etc. We have implemented several application functions exploiting; the properties of the orthogonal transforms. Let us start with zonal; filtration function. It has the following form:. ```{.cpp}; char *Filter1Zonal(const float *source,; float *dest,; int size,; int type,; int degree,; int xmin,; int xmax,; float filt",MatchSource.DOCS,documentation/spectrum/Spectrum.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md
https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:63407,Modifiability,enhance,enhance,63407,"RIER_HAAR`; - `TRANSFORM1_WALSH_HAAR`; - `TRANSFORM1_COS_WALSH`; - `TRANSFORM1_COS_HAAR`; - `TRANSFORM1_SIN_WALSH`; - `TRANSFORM1_SIN_HAAR`; - **`degree`**: applied only for mixed transforms; - **`xmin`**: low limit of filtered region; - **`xmax`**: high limit of filtered region; - **`filter_coeff`**: value which is set in filtered region. An example of the filtration using Cosine transform is given in the Figure 6.5.; It illustrates a part of the spectrum from Figure 6.1 and two spectra; after filtration preserving 2048 coefficients and 1536 coefficients. One; can observe a very good fidelity of the overall shape of both spectra with; the original data. However, some distortion can be observed in details of; the second spectrum after filtration preserving only 1536 coefficients.; The useful information in the transform domain can be compressed into; one half of the original space. ![Filtration using Cosine transform](figures/image204.png). In the transform domain one can also enhance (multiply with; the constant > 1) some regions. This way, one can change; peak-to-background ratio. This function has a form of. ```{.cpp}; char *Enhance1(const float *source,; float *dest,; int size,; int type,; int degree,; int xmin,; int xmax,; float enhance_coeff);; ```. This function transforms the source spectrum. The calling program; should fill in the input parameters. Then it multiplies transformed; coefficients in the given region (`xmin`, `xmax`) by the given; `enhance_coeff` and transforms it back. Processed data are written into; the dest spectrum. Function parameters:. - **`source`**: pointer to the vector of the source spectrum, its length should be equal to `size`; - **`dest`**: pointer to the vector of the dest data, its length should be equal to `size`; - **`size`**: basic length of the source and dest spectra; - **`type`**: type of transform; - `TRANSFORM1_HAAR`; - `TRANSFORM1_WALSH`; - `TRANSFORM1_COS`; - `TRANSFORM1_SIN`; - `TRANSFORM1_FOURIER`; - `TRANSFORM1_HARTLE",MatchSource.DOCS,documentation/spectrum/Spectrum.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md
https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:64835,Modifiability,enhance,enhancement,64835,"`enhance_coeff` and transforms it back. Processed data are written into; the dest spectrum. Function parameters:. - **`source`**: pointer to the vector of the source spectrum, its length should be equal to `size`; - **`dest`**: pointer to the vector of the dest data, its length should be equal to `size`; - **`size`**: basic length of the source and dest spectra; - **`type`**: type of transform; - `TRANSFORM1_HAAR`; - `TRANSFORM1_WALSH`; - `TRANSFORM1_COS`; - `TRANSFORM1_SIN`; - `TRANSFORM1_FOURIER`; - `TRANSFORM1_HARTLEY`; - `TRANSFORM1_FOURIER_WALSH`; - `TRANSFORM1_FOURIER_HAAR`; - `TRANSFORM1_WALSH_HAAR`; - `TRANSFORM1_COS_WALSH`; - `TRANSFORM1_COS_HAAR`; - `TRANSFORM1_SIN_WALSH`; - `TRANSFORM1_SIN_HAAR`; - **`degree`**: applied only for mixed transforms; - **`xmin`**: low limit of filtered region; - **`xmax`**: high limit of filtered region; - **`enhance_coeff`**: value by which the filtered region is multiplied. An example of enhancement of the coefficients from region 380-800 by the; constant 2 in the Cosine transform domain is given in the Figure 6.6. The; determination of the region is a matter of analysis in the appropriate; transform domain. We assumed that low frequency components are placed in; the low coefficients. As it can be observed, the enhancement changes the; peak-to-background ratio. ![Enhancement of the coefficients from region 380-800 by the constant 2 in the Cosine transform domain](figures/image206.png). ## 2-DIMENSIONAL SPECTRA ##. Similarly to 1-dimensional data, we have implemented the; transforms also for 2-dimensional data. Besides the classic; orthogonal transforms like. - Haar; - Walsh; - Cos; - Sin; - Fourier; - Hartley; - Fourier-Haar; - Fourier-Walsh; - Walsh-Haar; - Cos-Walsh; - Cos-Haar; - Sin-Walsh; - Sin-Haar. ```{.cpp}; char *Transform2(const float **source,; float **dest,; int sizex,; int sizey,; int type,; int direction,; int degree);; ```. This function transforms the source spectrum. The calling program should; fill in the ",MatchSource.DOCS,documentation/spectrum/Spectrum.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md
https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:65165,Modifiability,enhance,enhancement,65165," be equal to `size`; - **`size`**: basic length of the source and dest spectra; - **`type`**: type of transform; - `TRANSFORM1_HAAR`; - `TRANSFORM1_WALSH`; - `TRANSFORM1_COS`; - `TRANSFORM1_SIN`; - `TRANSFORM1_FOURIER`; - `TRANSFORM1_HARTLEY`; - `TRANSFORM1_FOURIER_WALSH`; - `TRANSFORM1_FOURIER_HAAR`; - `TRANSFORM1_WALSH_HAAR`; - `TRANSFORM1_COS_WALSH`; - `TRANSFORM1_COS_HAAR`; - `TRANSFORM1_SIN_WALSH`; - `TRANSFORM1_SIN_HAAR`; - **`degree`**: applied only for mixed transforms; - **`xmin`**: low limit of filtered region; - **`xmax`**: high limit of filtered region; - **`enhance_coeff`**: value by which the filtered region is multiplied. An example of enhancement of the coefficients from region 380-800 by the; constant 2 in the Cosine transform domain is given in the Figure 6.6. The; determination of the region is a matter of analysis in the appropriate; transform domain. We assumed that low frequency components are placed in; the low coefficients. As it can be observed, the enhancement changes the; peak-to-background ratio. ![Enhancement of the coefficients from region 380-800 by the constant 2 in the Cosine transform domain](figures/image206.png). ## 2-DIMENSIONAL SPECTRA ##. Similarly to 1-dimensional data, we have implemented the; transforms also for 2-dimensional data. Besides the classic; orthogonal transforms like. - Haar; - Walsh; - Cos; - Sin; - Fourier; - Hartley; - Fourier-Haar; - Fourier-Walsh; - Walsh-Haar; - Cos-Walsh; - Cos-Haar; - Sin-Walsh; - Sin-Haar. ```{.cpp}; char *Transform2(const float **source,; float **dest,; int sizex,; int sizey,; int type,; int direction,; int degree);; ```. This function transforms the source spectrum. The calling program should; fill in the input parameters. Transformed data are written into the dest; spectrum. Function parameters:. - **`source`**: pointer to the matrix of the source spectrum, its size should; be `sizex`*`sizey` except for inverse FOURIER, FOUR-WALSH, FOUR-HAAR; transform. These need `sizex`\*2\*`sizey` ",MatchSource.DOCS,documentation/spectrum/Spectrum.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md
https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:67217,Modifiability,enhance,enhancement,67217,"*`dest`**: pointer to the matrix of destination data, its size should; be `sizex`*`sizey` except for direct FOURIER, FOUR-WALSh, FOUR-HAAR.; These need `sizex`\*2\*`sizey` length to store real and imaginary; coefficients; - **`sizex,sizey`**: basic dimensions of the source and dest spectra; - **`type`**: type of transform; - `TRANSFORM2_HAAR`; - `TRANSFORM2_WALSH`; - `TRANSFORM2_COS`; - `TRANSFORM2_SIN`; - `TRANSFORM2_FOURIER`; - `TRANSFORM2_HARTLEY`; - `TRANSFORM2_FOURIER_WALSH`; - `TRANSFORM2_FOURIER_HAAR`; - `TRANSFORM2_WALSH_HAAR`; - `TRANSFORM2_COS_WALSH`; - `TRANSFORM2_COS_HAAR`; - `TRANSFORM2_SIN_WALSH`; - `TRANSFORM2_SIN_HAAR`; - **`direction`**: transform direction (forward, inverse); - **`degree`**: applies only for mixed transforms. An example of the 2-dimensional Cosine transform of data from Figure 5.6 is; given in Figure 6.7. One can notice that the data are concentrated again; around the beginning of the coordinate system. This allows to apply; filtration, enhancement and compression techniques in the transform; domain. ![2-dimensional Cosine transform of data from Figure 5.6](figures/image208.png). In some cases, when the spectrum is smooth, the cosine transforms are very; efficient. In Figures 6.8, 6.9 we show original spectrum and transformed; coefficients using Cosine transform, respectively. ![Original spectrum](figures/image210.png). ![Transformed coefficients using Cosine transform](figures/image212.png). Similarly to 1-dimensional case we have also implemented the functions for zonal filtration, Gauss filtration and enhancement.; The zonal filtration function using classic transforms has the form of. ```{.cpp}; char *Filter2Zonal(const float **source,; float **dest,; int sizex,; int sizey,; int type,; int degree,; int xmin,; int xmax,; int ymin,; int ymax,; float filter_coeff);; ```. This function transforms the source spectrum. The calling program should; fill in the input parameters. Then it sets transformed coefficients in the; given region ",MatchSource.DOCS,documentation/spectrum/Spectrum.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md
https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:67796,Modifiability,enhance,enhancement,67796,"; - `TRANSFORM2_WALSH_HAAR`; - `TRANSFORM2_COS_WALSH`; - `TRANSFORM2_COS_HAAR`; - `TRANSFORM2_SIN_WALSH`; - `TRANSFORM2_SIN_HAAR`; - **`direction`**: transform direction (forward, inverse); - **`degree`**: applies only for mixed transforms. An example of the 2-dimensional Cosine transform of data from Figure 5.6 is; given in Figure 6.7. One can notice that the data are concentrated again; around the beginning of the coordinate system. This allows to apply; filtration, enhancement and compression techniques in the transform; domain. ![2-dimensional Cosine transform of data from Figure 5.6](figures/image208.png). In some cases, when the spectrum is smooth, the cosine transforms are very; efficient. In Figures 6.8, 6.9 we show original spectrum and transformed; coefficients using Cosine transform, respectively. ![Original spectrum](figures/image210.png). ![Transformed coefficients using Cosine transform](figures/image212.png). Similarly to 1-dimensional case we have also implemented the functions for zonal filtration, Gauss filtration and enhancement.; The zonal filtration function using classic transforms has the form of. ```{.cpp}; char *Filter2Zonal(const float **source,; float **dest,; int sizex,; int sizey,; int type,; int degree,; int xmin,; int xmax,; int ymin,; int ymax,; float filter_coeff);; ```. This function transforms the source spectrum. The calling program should; fill in the input parameters. Then it sets transformed coefficients in the; given region to the given; `filter_coeff` and transforms it back. Filtered data are written into the dest; spectrum. Function parameters:. - **`source`**: pointer to the matrix of source spectrum, its size should be `sizex`*`sizey`; - **`dest`**: pointer to the matrix of destination data, its size should be `sizex`*`sizey`; - **`sizex,sizey`**: basic dimensions of source and dest spectra; - **`type`**: type of transform:; - `TRANSFORM2_HAAR`; - `TRANSFORM2_WALSH`; - `TRANSFORM2_COS`; - `TRANSFORM2_SIN`; - `TRANSFORM2_FOU",MatchSource.DOCS,documentation/spectrum/Spectrum.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md
https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:69266,Modifiability,enhance,enhancement,69266,"ered data are written into the dest; spectrum. Function parameters:. - **`source`**: pointer to the matrix of source spectrum, its size should be `sizex`*`sizey`; - **`dest`**: pointer to the matrix of destination data, its size should be `sizex`*`sizey`; - **`sizex,sizey`**: basic dimensions of source and dest spectra; - **`type`**: type of transform:; - `TRANSFORM2_HAAR`; - `TRANSFORM2_WALSH`; - `TRANSFORM2_COS`; - `TRANSFORM2_SIN`; - `TRANSFORM2_FOURIER`; - `TRANSFORM2_HARTLEY`; - `TRANSFORM2_FOURIER_WALSH`; - `TRANSFORM2_FOURIER_HAAR`; - `TRANSFORM2_WALSH_HAAR`; - `TRANSFORM2_COS_WALSH`; - `TRANSFORM2_COS_HAAR`; - `TRANSFORM2_SIN_WALSH`; - `TRANSFORM2_SIN_HAAR`; - **`degree`**: applies only for mixed transforms; - **`xmin`**: low limit x of filtered region; - **`xmax`**: high limit x of filtered region; - **`ymin`**: low limit y of filtered region; - **`ymax`**: high limit y of filtered region; - **`filter_coeff`**: value which is set in filtered region. The enhancement function using transforms has a form of. ```{.cpp}; char *Enhance2(const float **source,; float **dest,; int sizex,; int sizey,; int type,; int degree,; int xmin,; int xmax,; int ymin,; int ymax,; float enhance_coeff);; ```. This function transforms the source spectrum. The calling program should; fill in the input parameters. Then it multiplies transformed coefficients in; the given region by the given `enhance_coeff` and transforms it; back. Function parameters:. - **`source`**: pointer to the matrix of the source spectrum, its size should be `sizex`*`sizey`; - **`dest`**: pointer to the matrix of the destination data, its size should be `sizex`*`sizey`; - **`sizex,sizey`**: basic dimensions of the source and dest spectra; - **`type`**: type of transform; - `TRANSFORM2_HAAR`; - `TRANSFORM2_WALSH`; - `TRANSFORM2_COS`; - `TRANSFORM2_SIN`; - `TRANSFORM2_FOURIER`; - `TRANSFORM2_HARTLEY`; - `TRANSFORM2_FOURIER_WALSH`; - `TRANSFORM2_FOURIER_HAAR`; - `TRANSFORM2_WALSH_HAAR`; - `TRANSFORM2_COS_WALSH`; -",MatchSource.DOCS,documentation/spectrum/Spectrum.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md
https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:73914,Modifiability,variab,variables,73914,"ithm, hsv modulo color component [15]. int bar_thickness; // applies only for bar display mode; int bar_empty_flag; // (empty bars, full bars) applies only for bar display mode; int border_color; // color of background of the picture; int full_border; // decides whether background is painted; int raster_en_dis; // decides whether the axes and rasters are shown; int raster_long; // decides whether the rasters are drawn as long lines; int raster_color; // color of the rasters; char *raster_description_x; // x axis description; char *raster_description_y; // y axis description. int pen_color; // color of spectrum; int pen_dash; // style of pen; int pen_width; // width of line. int chanmark_style; // style of channel marks; int chanmark_width; // width of channel marks; int chanmark_height; // height of channel marks; int chanmark_en_dis; // decides whether the channel marks are shown; int chanmark_color; // color of channel marks. // auxiliary variables, transform coefficients, for internal use only; double mx;; double my;; double px;; double py;. // auxiliary internal variables, working place; double gbezx,gbezy;; TPoint bz[4];; };; ```. The examples using different display parameters are shown in the next; few Figures. ![Display mode -polyline, width of pen=3](figures/image214.png). ![Display mode- bars, shown channel marks](figures/image216.png). ![Display mode- steps, log scale, shown channel marks](figures/image218.png). ![Display mode -Bezier curve interpolation, shown channel marks](figures/image220.png). ![Display mode- rainbow bars, color algorithm (model) RGB, number of color levels=1024, pen width=3](figures/image222.png). ![Display mode-empty bars, color algorithm YIQ, number of color levels 2048](figures/image224.png). ## 2-DIMENSIONAL SPECTRA. The 2-dimensional visualization function displays spectrum; (or its part) on the Canvas of a form. Before calling the function, one; has to fill in the `two_dim_pic` structure containing all parameters of the; displa",MatchSource.DOCS,documentation/spectrum/Spectrum.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md
https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:74042,Modifiability,variab,variables,74042,"pty_flag; // (empty bars, full bars) applies only for bar display mode; int border_color; // color of background of the picture; int full_border; // decides whether background is painted; int raster_en_dis; // decides whether the axes and rasters are shown; int raster_long; // decides whether the rasters are drawn as long lines; int raster_color; // color of the rasters; char *raster_description_x; // x axis description; char *raster_description_y; // y axis description. int pen_color; // color of spectrum; int pen_dash; // style of pen; int pen_width; // width of line. int chanmark_style; // style of channel marks; int chanmark_width; // width of channel marks; int chanmark_height; // height of channel marks; int chanmark_en_dis; // decides whether the channel marks are shown; int chanmark_color; // color of channel marks. // auxiliary variables, transform coefficients, for internal use only; double mx;; double my;; double px;; double py;. // auxiliary internal variables, working place; double gbezx,gbezy;; TPoint bz[4];; };; ```. The examples using different display parameters are shown in the next; few Figures. ![Display mode -polyline, width of pen=3](figures/image214.png). ![Display mode- bars, shown channel marks](figures/image216.png). ![Display mode- steps, log scale, shown channel marks](figures/image218.png). ![Display mode -Bezier curve interpolation, shown channel marks](figures/image220.png). ![Display mode- rainbow bars, color algorithm (model) RGB, number of color levels=1024, pen width=3](figures/image222.png). ![Display mode-empty bars, color algorithm YIQ, number of color levels 2048](figures/image224.png). ## 2-DIMENSIONAL SPECTRA. The 2-dimensional visualization function displays spectrum; (or its part) on the Canvas of a form. Before calling the function, one; has to fill in the `two_dim_pic` structure containing all parameters of the; display. The function has a form of. ```{.cpp}; char *display2(struct two_dim_pic* p);; ```. This function displ",MatchSource.DOCS,documentation/spectrum/Spectrum.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md
https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:80296,Modifiability,variab,variables,80296,"r_color; // color of background of the picture; int full_border; // decides whether background is painted; int raster_en_dis; // decides whether the rasters are shown; int raster_long; // decides whether the rasters are drawn as long lines; int raster_color; // color of the rasters; char *raster_description_x; // x axis description; char *raster_description_y; // y axis description; char *raster_description_z; // z axis description; int pen_color; // color of spectrum; int pen_dash; // style of pen; int pen_width; // width of line; int chanmark_en_dis; // decides whether the channel marks are shown; int chanmark_style; // style of channel marks; int chanmark_width; // width of channel marks; int chanmark_height; // height of channel marks; int chanmark_color; // color of channel marks; int chanline_en_dis; // decides whether the channel lines (grid) are shown. // auxiliary variables, transformation coefficients for internal use only; double kx;; double ky;; double mxx;; double mxy;; double myx;; double myy;; double txx;; double txy;; double tyx;; double tyy;; double tyz;; double vx;; double vy;; double nu_sli;. // auxiliary internal variables, working place; double z,zeq,gbezx,gbezy,dxspline,dyspline;; int xt,yt,xs,ys,xe,ye,priamka,z_preset_value;; unsigned short obal[MAXIMUM_XSCREEN_RESOLUTION];; unsigned short obal_cont[MAXIMUM_XSCREEN_RESOLUTION];; TPoint bz[4];; };; ```. The examples using different display parameters are shown in the next few Figures. ![Display mode-bars, pen width=2](figures/image226.png). ![Display mode-triangles, log scale](figures/image228.png). ![Display mode-contours](figures/image230.png). ![Display mode surface shading according to height](figures/image232.png). ![Display mode-surface shading according to light point](figures/image234.png). ![Display mode-surface shading according to height+light position with ratio 50:50, CMY color model](figures/image236.png). ![Display mode bars shaded according to height](figures/image238.png). ![Di",MatchSource.DOCS,documentation/spectrum/Spectrum.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md
https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:80561,Modifiability,variab,variables,80561,"color of the rasters; char *raster_description_x; // x axis description; char *raster_description_y; // y axis description; char *raster_description_z; // z axis description; int pen_color; // color of spectrum; int pen_dash; // style of pen; int pen_width; // width of line; int chanmark_en_dis; // decides whether the channel marks are shown; int chanmark_style; // style of channel marks; int chanmark_width; // width of channel marks; int chanmark_height; // height of channel marks; int chanmark_color; // color of channel marks; int chanline_en_dis; // decides whether the channel lines (grid) are shown. // auxiliary variables, transformation coefficients for internal use only; double kx;; double ky;; double mxx;; double mxy;; double myx;; double myy;; double txx;; double txy;; double tyx;; double tyy;; double tyz;; double vx;; double vy;; double nu_sli;. // auxiliary internal variables, working place; double z,zeq,gbezx,gbezy,dxspline,dyspline;; int xt,yt,xs,ys,xe,ye,priamka,z_preset_value;; unsigned short obal[MAXIMUM_XSCREEN_RESOLUTION];; unsigned short obal_cont[MAXIMUM_XSCREEN_RESOLUTION];; TPoint bz[4];; };; ```. The examples using different display parameters are shown in the next few Figures. ![Display mode-bars, pen width=2](figures/image226.png). ![Display mode-triangles, log scale](figures/image228.png). ![Display mode-contours](figures/image230.png). ![Display mode surface shading according to height](figures/image232.png). ![Display mode-surface shading according to light point](figures/image234.png). ![Display mode-surface shading according to height+light position with ratio 50:50, CMY color model](figures/image236.png). ![Display mode bars shaded according to height](figures/image238.png). ![Display mode- surface shading according to light position with shadows](figures/image240.png). ![Display mode- surface shading according to height with 10 levels of contours](figures/image242.png). ![Display mode- surface shading according to height, sqrt scale, ch",MatchSource.DOCS,documentation/spectrum/Spectrum.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md
https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:84026,Modifiability,enhance,enhancement,84026,"NIM, B34 (1988), 396-402. [3] D. D. Burgess, R. J. Tervo: Background estimation for gamma-ray; spectroscopy. NIM 214 (1983), 431-434. [4] M. Morháč, J. Kliman, V. Matoušek, M. Veselský, I.; Turzo.:Identification of peaks in multidimensional coincidence gamma-ray; spectra. NIM, A443 (2000) 108-125. [5] M.A. Mariscotti: A method for identification of peaks in the; presence of background and its application to spectrum analysis. NIM 50; (1967), 309-320. [6] Z.K. Silagadze, A new algorithm for automatic photopeak searches.; NIM A 376 (1996), 451. [7] P. Bandžuch, M. Morháč, J. Krištiak: Study of the VanCitter and Gold; iterative methods of deconvolution and their application in the; deconvolution of experimental spectra of positron annihilation, NIM A; 384 (1997) 506-515. [8] M. Morháč, J. Kliman, V. Matoušek, M. Veselský, I. Turzo.:; Efficient one- and two-dimensional Gold deconvolution and its; application to gamma-ray spectra decomposition. NIM, A401 (1997); 385-408. [9] I. A. Slavic: Nonlinear least-squares fitting without matrix; inversion applied to complex Gaussian spectra analysis. NIM 134 (1976); 285-289. [10] B. Mihaila: Analysis of complex gamma spectra, Rom. Jorn. Phys.,; Vol. 39, No. 2, (1994), 139-148. [11] T. Awaya: A new method for curve fitting to the data with low; statistics not using chi-square method. NIM 165 (1979) 317-323. [12] T. Hauschild, M. Jentschel: Comparison of maximum likelihood; estimation and chi-square statistics applied to counting experiments.; NIM A 457 (2001) 384-401. [13] M. Morháč, J. Kliman, M. Jandel, Ľ. Krupa, V. Matoušek: Study; of fitting algorithms applied to simultaneous analysis of large number; of peaks in $\gamma$-ray spectra. Applied Spectroscopy, Vol. 57, No. 7 (2003) 753-760. [14] C.V. Hampton, B. Lian, Wm. C. McHarris: Fast-Fourier-transform; spectral enhancement techniques for gamma-ray spectroscopy. NIM A353; (1994) 280-284. [15] D. Hearn, M. P. Baker: Computer Graphics, Prentice-Hall; International, Inc., 1994.; ",MatchSource.DOCS,documentation/spectrum/Spectrum.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md
https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:32809,Performance,optimiz,optimized,32809,"e where we have used the unfolding method is the; decomposition of continuum of gamma-ray spectra. Using simulation and; interpolation techniques, we have synthesized the response matrix (size; `3400x3400` channels) of Gammasphere spectrometer (Figure 4.9). Its details are; presented in Figure 4.10. The original spectrum of Co^56 before and after; continuum decomposition are presented in Figures 4.11, 4.12, respectively. ![Response matrix (size 3400x3400 channels) of Gammasphere spectrometer](figures/image104.png). ![Detail of Figure 4.9](figures/image106.png). ![Original spectrum of Co56 before continuum decomposition](figures/image108.png). ![Original spectrum of Co56 after continuum decomposition](figures/image110.png). ## 2-DIMENSIONAL SPECTRA. We have extended the method of Gold deconvolution also for; 2-dimensional data. Again, the goal of the deconvolution methods is to; improve the resolution in the spectrum and to decompose multiplets. The method of optimized 2-dimensional deconvolution is described in details in [8]. Mathematical formulation of 2-dimensional convolution system is as; follows:. $$ y(i_1,i_2) = \sum_{k_1=0}^{N_1-1}\sum_{k_2=0}^{N_2-1}h(i_1-k_1,i_2-k_2)x(k_1,k_2), i_1=0,1,2,...,N_1-1, i_2=0,1,2,...,N_2-1 $$. Assuming we know the output; spectrum `y` and the response spectrum `h`, the task is to calculate the matrix `x`. The basic function has the form of. ``` {.cpp}; char *Deconvolution2(float **source,; const float **resp,; int sizex,; int sizey,; int niter);; ```. This function calculates deconvolution from the source spectrum according to; the response spectrum. The result is placed in the matrix pointed by the source; pointer. Function parameters:. - **`source`**: pointer to the matrix of the source spectrum; - **`resp`**: pointer to the matrix of the response spectrum; - **`sizex`**: x length of source and the response spectra; - **`sizey`**: y length of source and the response spectra; - **`number_of_iterations`**: see [8] for details. ",MatchSource.DOCS,documentation/spectrum/Spectrum.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md
https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:38364,Performance,optimiz,optimized,38364,"large blocks of data and large number of parameters. The other one is based on a calculation of the system of linear equations; using Stiefel-Hestens method [10]. It converges faster than the awmi; algorithm, however, it is not suitable to fit large number of parameters. ## 1-DIMENSIONAL SPECTRA. The quantity to be minimized in the fitting procedure for one-dimensional spectrum is defined as. $$ \chi^2 = \frac{1}{N-M}\sum_{i=1}^{N}\frac{[y_i-f(i,a)]^2}{y_i} $$. where `i` is the channel in the fitted spectrum, `N` is the number of; channels in the fitting subregion, `M` is the number of free parameters,; `y_i` is the content of the `i`-th channel, `a` is a vector of the; parameters being fitted and `f(i,a)` is a fitting or peak shape function. Instead of the weighting coefficient `y_i` in the denominator of the formula; given above, one can use also the value of `f(i,a)`. It is suitable for; data with poor statistics [11], [12]. The third statistic to be optimized, which is implemented in the fitting; functions, is the Maximum Likelihood Method. It is up to the user; to select a suitable statistic. After differentiating chi^2 we obtain the following `M` simultaneous; equations:. $$ \sum_{i=1}^{N}; \frac{y_i-f(i,a^{(t)})}{y_i}; \frac{\partial f(i,a^t)}{\partial a_k}=; \sum_{j=1}^{M}\sum_{i=1}^{N}; \frac{\partial f(i,a^{(t)})}{\partial a_j}; \frac{\partial f(i,a^{(t)})}{\partial a_k}; \Delta a_j^{(t)} $$. - in gamma-ray spectra we have to fit together tens, hundreds of peaks; simultaneously that sometimes represent thousands of parameters. - the calculation of the inversion matrix of such a size is; practically impossible. - the awmi method is based on the assumption that the off-diagonal; terms in the matrix A are equal to zero. $$; \Delta a_{k}^{(t+1)} = \alpha^{(t)}; \frac{; \sum_{i=1}^{N} \frac{e_{i}^{(t)}}{y_i}\frac{\partial f(i,a^{(t)})}{\partial a_k}; }{; \sum_{i=1}^{N} \left[ \frac{\partial f(i,a^{(t)})}{\partial a_k}\right]^2\frac{1}{y_i}; }; $$. where the erro",MatchSource.DOCS,documentation/spectrum/Spectrum.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md
https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:39602,Performance,optimiz,optimize,39602,"{i=1}^{N}; \frac{y_i-f(i,a^{(t)})}{y_i}; \frac{\partial f(i,a^t)}{\partial a_k}=; \sum_{j=1}^{M}\sum_{i=1}^{N}; \frac{\partial f(i,a^{(t)})}{\partial a_j}; \frac{\partial f(i,a^{(t)})}{\partial a_k}; \Delta a_j^{(t)} $$. - in gamma-ray spectra we have to fit together tens, hundreds of peaks; simultaneously that sometimes represent thousands of parameters. - the calculation of the inversion matrix of such a size is; practically impossible. - the awmi method is based on the assumption that the off-diagonal; terms in the matrix A are equal to zero. $$; \Delta a_{k}^{(t+1)} = \alpha^{(t)}; \frac{; \sum_{i=1}^{N} \frac{e_{i}^{(t)}}{y_i}\frac{\partial f(i,a^{(t)})}{\partial a_k}; }{; \sum_{i=1}^{N} \left[ \frac{\partial f(i,a^{(t)})}{\partial a_k}\right]^2\frac{1}{y_i}; }; $$. where the error in the channel `i` is $e_{i}^{(t)} = y_i-f(i,a^{(t)}); k=1,2,...,M$ and; $\alpha^{(t)}=1$ if the process is convergent or $\alpha^{(t)}=0.5 \alpha^{(t-1)}$; if it is divergent. Another possibility is to optimize this coefficient. The error of `k`-th parameter estimate is. $$; \Delta a_k^{(e)}=; \sqrt{\frac; {\sum_{i=1}^{N}\frac{e_i^2}{y_i}}; {\sum_{i=1}^{N} \left[ \frac{\partial f(i,a^{(t)})}{\partial a_k}\right]^2\frac{1}{y_i}}; }; $$. Algorithm with higher powers `w=1,2,3...`:. $$; \Delta a_{k,w}^{(t+1)}=; \alpha^{(t)}; \frac; {\sum_{i=1}^{N} \frac{e_i}{y_i}\left[ \frac{\partial f(i,a^{(t)})}{\partial a_k}\right]^{2w-1}}; {\sum_{i=1}^{N} \left[ \frac{\partial f(i,a^{(t)})}{\partial a_k}\right]^{2w}\frac{1}{y_i}}; $$. We have implemented the non-symmetrical semi-empirical peak shape function. It contains the symmetrical Gaussian as well as non-symmetrical terms:. $$; f(i,a) =; \sum_{i=1}^{M} A(j); \left\{; exp\left[\frac{-(i-p(j))^2}{2\sigma^2}\right]; +\frac{1}{2}T.exp\left[\frac{(i-p(j))}{B\sigma}\right]; .erfc\left[\frac{(i-p(j))}{\sigma}+\frac{1}{2B}\right]; +\frac{1}{2}S.erfc\left[\frac{(i-p(j))}{\sigma}\right]; \right\}; $$. where `T, S` are relative amplitudes and `B` is a slo",MatchSource.DOCS,documentation/spectrum/Spectrum.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md
https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:42047,Performance,optimiz,optimization,42047,"ource spectrum. The calling program should fill; in the input parameters of the `one_dim_fit` structure. The fitted parameters; are written into structure pointed by `one_dim_fit` structure pointer; and fitted data are written into source spectrum. Function parameters:. - **`source`**: pointer to the vector of the source spectrum; - **`p`**: pointer to the `one_dim_fit` structure pointer; - **`size`**: length of the source spectrum. The `one_dim_fit` structure has the form of. ``` {.cpp}; class TSpectrumOneDimFit{. public:. int number_of_peaks; // input parameter, should be >0; int number_of_iterations; // input parameter, should be >0; int xmin; // first fitted channel; int xmax; // last fitted channel; double alpha; // convergence coefficient, input parameter, it should be a positive number and <=1; double chi; // here the function returns the resulting chi-square; int statistic_type; // type of statistics, possible values are:; // FIT1_OPTIM_CHI_COUNTS (chi square statistics with counts as weighting coefficients),; // FIT1_OPTIM_CHI_FUNC_VALUES (chi square statistics with function values as weighting coefficients); // FIT1_OPTIM_MAX_LIKELIHOOD; int alpha_optim; // optimization of convergence coefficients, possible values are:; // FIT1_ALPHA_HALVING,; // FIT1_ALPHA_OPTIMAL; int power; // possible values FIT1_FIT_POWER2,4,6,8,10,12; int fit_taylor; // order of Taylor expansion, possible values; // FIT1_TAYLOR_ORDER_FIRST, FIT1_TAYLOR_ORDER_SECOND. double position_init[MAX_NUMBER_OF_PEAKS1]; // initial values of peaks positions, input parameters; double position_calc[MAX_NUMBER_OF_PEAKS1]; // calculated values of fitted positions, output parameters; double position_err[MAX_NUMBER_OF_PEAKS1]; // position errors; bool fix_position[MAX_NUMBER_OF_PEAKS1]; // logical vector which allows to fix appropriate positions (not fit). However they are present in the estimated functional; double amp_init[MAX_NUMBER_OF_PEAKS1]; // initial values of peaks amplitudes, input parameters",MatchSource.DOCS,documentation/spectrum/Spectrum.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md
https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:49706,Performance,optimiz,optimization,49706,"to the `two_dim_fit` structure pointer, see manual; - **`sizex`**: length x of the source spectrum; - **`sizey`**: length y of the source spectrum. The `two_dim_fit` structure has the form of. ``` {.cpp}; class TSpectrumTwoDimFit{. public:. int number_of_peaks; // input parameter, should be>0; int number_of_iterations; // input parameter, should be >0; int xmin; // first fitted channel in x direction; int xmax; // last fitted channel in x direction; int ymin; // first fitted channel in y direction; int ymax; // last fitted channel in y direction; double alpha; // convergence coefficient, input parameter, it should be a positive number and <=1; double chi; // here the function returns resulting chi square; int statistic_type; // type of statistics, possible values are:; // FIT2_OPTIM_CHI_COUNTS (chi square statistics with counts as weighting coefficients),; // FIT2_OPTIM_CHI_FUNC_VALUES (chi square statistics with function values as weighting coefficients),; // FIT2_OPTIM_MAX_LIKELIHOOD; int alpha_optim; // optimization of convergence coefficients, possible values are:; // FIT2_ALPHA_HALVING, FIT2_ALPHA_OPTIMAL; int power; // possible values are: FIT21_FIT_POWER2,4,6,8,10,12; int fit_taylor; // order of Taylor expansion, possible values are:; // FIT2_TAYLOR_ORDER_FIRST,; // FIT2_TAYLOR_ORDER_SECOND; double position_init_x[MAX_NUMBER_OF_PEAKS2]; // initial values of x positions of 2D peaks, input parameters; double position_calc_x[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitted x positions of 2D peaks, output parameters; double position_err_x[MAX_NUMBER_OF_PEAKS2]; // x position errors of 2D peaks; bool fix_position_x[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix the appropriate x positions of 2D peaks (not fit). However, they are present in the estimated functional; double position_init_y[MAX_NUMBER_OF_PEAKS2]; // initial values of y positions of 2D peaks, input parameters; double position_calc_y[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitt",MatchSource.DOCS,documentation/spectrum/Spectrum.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md
https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:4192,Testability,log,logical,4192,"igure we present; the background, which was added to the synthetic spectrum. One can; observe good coincidence with the estimated background. The method of; the estimation of Compton edge is described in details in [3]. ![Synthetic spectrum with Compton edges](figures/image012.png). The generalized form of the algorithm is implemented in the following function. ``` {.cpp}; char *Background1General(float *spectrum,; int size,; int number_of_iterations,; int direction,; int filter_order,; bool compton);; ```. The meaning of the parameters is as follows:. - **`spectrum`**: pointer to the vector of the source spectrum; - **`size`**: length of spectrum vector; - **`number_of_iterations`**: maximal width of clipping window; - **`direction`**: direction of change of clipping window. Possible values:; - `BACK1_INCREASING_WINDOW`; - `BACK1_DECREASING_WINDOW`; - **`filter_order`**: order of clipping filter. Possible values:; - `BACK1_ORDER2`; - `BACK1_ORDER4`; - `BACK1_ORDER6`; - `BACK1_ORDER8`; - **`compton`**: logical variable whether the estimation of Compton edge will be included. Possible values:; - `BACK1_EXCLUDE_COMPTON`; - `BACK1_INCLUDE_COMPTON`. ## 2-DIMENSIONAL SPECTRA. This basic background estimation function allows to separate useless; spectrum information (2D-continuous background and coincidences of peaks; with background in both dimensions) from peaks. It calculates background; spectrum from the source spectrum. The result is placed in the array; pointed by spectrum pointer. On successful completion it returns 0. On; error it returns a pointer to the string describing error. ``` {.cpp}; char *Background2(float **spectrum,; int sizex,; int sizey,; int number_of_iterations);; ```. Function parameters:. - **`spectrum`**: pointer to the array of the source spectrum; - **`sizex`**: x length of spectrum; - **`sizey`**: y length of spectrum; - **`number_of_iterations`**: width of the clipping window. In Figure 1.6 we present an example of a 2-dimensional spectrum bef",MatchSource.DOCS,documentation/spectrum/Spectrum.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md
https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:19984,Testability,log,logical,19984,"and it emphasizes peaks (depending on the averaging; window). The example of the part of original noisy spectrum and Markov; spectrum for `window=3` is given in Figure 3.5 Then the peaks can be found in; Markov spectrum using standard above-presented algorithm. ![Part of original noisy spectrum and Markov spectrum for window=3](figures/image066.png). The form of the generalized peak searching function is as follows:. ```{.cpp}; Int_t Search1General(float *spectrum,; int size,; float sigma,; int threshold,; bool markov,; int aver_window);; ```. This function searches for peaks in the source spectrum. The number of found; peaks and their positions are written into the structure pointed by the; `one_dim_peak` structure pointer. Function parameters:. - **`spectrum`**: pointer to the vector of the source spectrum. This source spectrum is replaced by the new spectrum calculated using Markov chains method.; - **`size`**: length of the source spectrum; - **`sigma`**: sigma of searched peaks; - **`threshold`**: threshold value for peaks selection; - **`markov`**: logical variable. If it is set to `true`, then the source spectrum is first replaced by the new spectrum calculated using Markov chains method; - **`aver_window`**: averaging window used in the calculation of Markov spectrum, applies only if the `markov` variable was set to `true`. The methods of peak searching are sensitive to the `sigma`. Usually the; `sigma` value is known beforehand. It also changes only slightly with the; energy. We have investigated as well the robustness of the proposed; algorithms to the spectrum with the peaks with `sigma` changing from 1 to; 10 (see Figure 3.6). ![Robustness of the proposed algorithms to the spectrum with the peaks with sigma changing from 1 to 10](figures/image068.png). We applied peak searching algorithm based on Markov approach. We changed; `sigma` in the interval from 1 to 10. The spectra for averaging windows 3,; 5, 10 are shown in Figure 3.7. ![Spectra for averaging ",MatchSource.DOCS,documentation/spectrum/Spectrum.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md
https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:23113,Testability,log,logical,23113," vector of the source spectrum; - **`sizex`**: x length of the source spectrum; - **`sizey`**: y length of the source spectrum; - **`sigma`**: sigma of searched peaks. An example of the two-dimensional spectrum with the identified peaks is; shown in Figure 3.8. ![Two-dimensional spectrum with the identified peaks](figures/image072.png). We have also generalized the peak searching function similarly to one-dimensional data. The generalized peak searching function for two-dimensional spectra has the form of. ```{.cpp}; Int_t Search2General(float **source,; int sizex,; int sizey,; double sigma,; int threshold,; bool markov,; int aver_window);; ```. This function searches for peaks in the source spectrum. The number of found; peaks and their positions are written into the structure pointed by; `two_dim_peak` structure pointer. Function parameters:. - **`source`**: pointer to the vector of the source spectrum; - **`sizex`**: x length of the source spectrum; - **`sizey`**: y length of the source spectrum; - **`sigma`**: sigma of searched peaks; - **`threshold`**: threshold value for peaks selection; - **`markov`**: logical variable. If it is set to `true`, then the source spectrum is first replaced by the new spectrum calculated using Markov chains method; - **`aver_window`** averaging window of searched peaks (applies only for the Markov method). An example of experimental 2-dimensional spectrum is given in Figure 3.9.; The number of peaks identified by the function now is 295. ![Experimental 2-dimensional spectrum](figures/image074.png). The function works even for very noisy data. In Figure 3.10 we present; synthetic 2-dimensional spectrum with 5 peaks. The method should; recognize what is the real 2-dimensional peak and what is the crossing of; two 1-dimensional ridges. The Markov spectrum with averaging window=3 is; given in Figure 3.11. One can observe that this spectrum is smoother than; the original one. After applying the general peak searching function to; the M",MatchSource.DOCS,documentation/spectrum/Spectrum.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md
https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:42646,Testability,log,logical,42646,"t fitted channel; int xmax; // last fitted channel; double alpha; // convergence coefficient, input parameter, it should be a positive number and <=1; double chi; // here the function returns the resulting chi-square; int statistic_type; // type of statistics, possible values are:; // FIT1_OPTIM_CHI_COUNTS (chi square statistics with counts as weighting coefficients),; // FIT1_OPTIM_CHI_FUNC_VALUES (chi square statistics with function values as weighting coefficients); // FIT1_OPTIM_MAX_LIKELIHOOD; int alpha_optim; // optimization of convergence coefficients, possible values are:; // FIT1_ALPHA_HALVING,; // FIT1_ALPHA_OPTIMAL; int power; // possible values FIT1_FIT_POWER2,4,6,8,10,12; int fit_taylor; // order of Taylor expansion, possible values; // FIT1_TAYLOR_ORDER_FIRST, FIT1_TAYLOR_ORDER_SECOND. double position_init[MAX_NUMBER_OF_PEAKS1]; // initial values of peaks positions, input parameters; double position_calc[MAX_NUMBER_OF_PEAKS1]; // calculated values of fitted positions, output parameters; double position_err[MAX_NUMBER_OF_PEAKS1]; // position errors; bool fix_position[MAX_NUMBER_OF_PEAKS1]; // logical vector which allows to fix appropriate positions (not fit). However they are present in the estimated functional; double amp_init[MAX_NUMBER_OF_PEAKS1]; // initial values of peaks amplitudes, input parameters; double amp_calc[MAX_NUMBER_OF_PEAKS1]; // calculated values of fitted amplitudes, output parameters; double amp_err[MAX_NUMBER_OF_PEAKS1]; // amplitude errors; bool fix_amp[MAX_NUMBER_OF_PEAKS1]i; // logical vector, which allows to fix appropriate amplitudes (not fit). However they are present in the estimated functional; double area[MAX_NUMBER_OF_PEAKS1]; // calculated areas of peaks; double area_err[MAX_NUMBER_OF_PEAKS1]; // errors of peak areas; double sigma_init; // sigma parameter, see peak shape function; double sigma_calc;; double sigma_err;; bool fix_sigma;; double t_init // t parameter, see peak shape function; double t_calc;; double t_err;; ",MatchSource.DOCS,documentation/spectrum/Spectrum.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md
https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:43064,Testability,log,logical,43064,"S (chi square statistics with function values as weighting coefficients); // FIT1_OPTIM_MAX_LIKELIHOOD; int alpha_optim; // optimization of convergence coefficients, possible values are:; // FIT1_ALPHA_HALVING,; // FIT1_ALPHA_OPTIMAL; int power; // possible values FIT1_FIT_POWER2,4,6,8,10,12; int fit_taylor; // order of Taylor expansion, possible values; // FIT1_TAYLOR_ORDER_FIRST, FIT1_TAYLOR_ORDER_SECOND. double position_init[MAX_NUMBER_OF_PEAKS1]; // initial values of peaks positions, input parameters; double position_calc[MAX_NUMBER_OF_PEAKS1]; // calculated values of fitted positions, output parameters; double position_err[MAX_NUMBER_OF_PEAKS1]; // position errors; bool fix_position[MAX_NUMBER_OF_PEAKS1]; // logical vector which allows to fix appropriate positions (not fit). However they are present in the estimated functional; double amp_init[MAX_NUMBER_OF_PEAKS1]; // initial values of peaks amplitudes, input parameters; double amp_calc[MAX_NUMBER_OF_PEAKS1]; // calculated values of fitted amplitudes, output parameters; double amp_err[MAX_NUMBER_OF_PEAKS1]; // amplitude errors; bool fix_amp[MAX_NUMBER_OF_PEAKS1]i; // logical vector, which allows to fix appropriate amplitudes (not fit). However they are present in the estimated functional; double area[MAX_NUMBER_OF_PEAKS1]; // calculated areas of peaks; double area_err[MAX_NUMBER_OF_PEAKS1]; // errors of peak areas; double sigma_init; // sigma parameter, see peak shape function; double sigma_calc;; double sigma_err;; bool fix_sigma;; double t_init // t parameter, see peak shape function; double t_calc;; double t_err;; bool fix_t;; double b_init // b parameter, see peak shape function; double b_calc;; double b_err;; bool fix_b;; double s_init; // s parameter, see peak shape function; double s_calc;; double s_err;; bool fix_s;; double a0_init; // background is estimated as a0+a1*x+a2*x*x; double a0_calc;; double a0_err;; bool fix_a0;; double a1_init;; double a1_calc;; double a1_err;; bool fix_a1;; double a2_init;",MatchSource.DOCS,documentation/spectrum/Spectrum.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md
https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:50360,Testability,log,logical,50360,"to the `two_dim_fit` structure pointer, see manual; - **`sizex`**: length x of the source spectrum; - **`sizey`**: length y of the source spectrum. The `two_dim_fit` structure has the form of. ``` {.cpp}; class TSpectrumTwoDimFit{. public:. int number_of_peaks; // input parameter, should be>0; int number_of_iterations; // input parameter, should be >0; int xmin; // first fitted channel in x direction; int xmax; // last fitted channel in x direction; int ymin; // first fitted channel in y direction; int ymax; // last fitted channel in y direction; double alpha; // convergence coefficient, input parameter, it should be a positive number and <=1; double chi; // here the function returns resulting chi square; int statistic_type; // type of statistics, possible values are:; // FIT2_OPTIM_CHI_COUNTS (chi square statistics with counts as weighting coefficients),; // FIT2_OPTIM_CHI_FUNC_VALUES (chi square statistics with function values as weighting coefficients),; // FIT2_OPTIM_MAX_LIKELIHOOD; int alpha_optim; // optimization of convergence coefficients, possible values are:; // FIT2_ALPHA_HALVING, FIT2_ALPHA_OPTIMAL; int power; // possible values are: FIT21_FIT_POWER2,4,6,8,10,12; int fit_taylor; // order of Taylor expansion, possible values are:; // FIT2_TAYLOR_ORDER_FIRST,; // FIT2_TAYLOR_ORDER_SECOND; double position_init_x[MAX_NUMBER_OF_PEAKS2]; // initial values of x positions of 2D peaks, input parameters; double position_calc_x[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitted x positions of 2D peaks, output parameters; double position_err_x[MAX_NUMBER_OF_PEAKS2]; // x position errors of 2D peaks; bool fix_position_x[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix the appropriate x positions of 2D peaks (not fit). However, they are present in the estimated functional; double position_init_y[MAX_NUMBER_OF_PEAKS2]; // initial values of y positions of 2D peaks, input parameters; double position_calc_y[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitt",MatchSource.DOCS,documentation/spectrum/Spectrum.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md
https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:50857,Testability,log,logical,50857,"ha_optim; // optimization of convergence coefficients, possible values are:; // FIT2_ALPHA_HALVING, FIT2_ALPHA_OPTIMAL; int power; // possible values are: FIT21_FIT_POWER2,4,6,8,10,12; int fit_taylor; // order of Taylor expansion, possible values are:; // FIT2_TAYLOR_ORDER_FIRST,; // FIT2_TAYLOR_ORDER_SECOND; double position_init_x[MAX_NUMBER_OF_PEAKS2]; // initial values of x positions of 2D peaks, input parameters; double position_calc_x[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitted x positions of 2D peaks, output parameters; double position_err_x[MAX_NUMBER_OF_PEAKS2]; // x position errors of 2D peaks; bool fix_position_x[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix the appropriate x positions of 2D peaks (not fit). However, they are present in the estimated functional; double position_init_y[MAX_NUMBER_OF_PEAKS2]; // initial values of y positions of 2D peaks, input parameters; double position_calc_y[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitted y positions of 2D peaks, output parameters; double position_err_y[MAX_NUMBER_OF_PEAKS2]; // y position errors of 2D peaks; bool fix_position_y[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix the appropriate y positions of 2D peaks (not fit). However, they are present in the estimated functional; double position_init_x1[MAX_NUMBER_OF_PEAKS2]; // initial values of x positions of 1D ridges, input parameters; double position_calc_x1[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitted x positions of 1D ridges, output parameters; double position_err_x1[MAX_NUMBER_OF_PEAKS2]; // x position errors of 1D ridges; bool fix_position_x1[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix appropriate x positions of 1D ridges (not fit). However, they are present in the estimated functional; double position_init_y1[MAX_NUMBER_OF_PEAKS2]; // initial values of y positions of 1D ridges, input parameters; double position_calc_y1[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitted y pos",MatchSource.DOCS,documentation/spectrum/Spectrum.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md
https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:51361,Testability,log,logical,51361," positions of 2D peaks, output parameters; double position_err_x[MAX_NUMBER_OF_PEAKS2]; // x position errors of 2D peaks; bool fix_position_x[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix the appropriate x positions of 2D peaks (not fit). However, they are present in the estimated functional; double position_init_y[MAX_NUMBER_OF_PEAKS2]; // initial values of y positions of 2D peaks, input parameters; double position_calc_y[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitted y positions of 2D peaks, output parameters; double position_err_y[MAX_NUMBER_OF_PEAKS2]; // y position errors of 2D peaks; bool fix_position_y[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix the appropriate y positions of 2D peaks (not fit). However, they are present in the estimated functional; double position_init_x1[MAX_NUMBER_OF_PEAKS2]; // initial values of x positions of 1D ridges, input parameters; double position_calc_x1[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitted x positions of 1D ridges, output parameters; double position_err_x1[MAX_NUMBER_OF_PEAKS2]; // x position errors of 1D ridges; bool fix_position_x1[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix appropriate x positions of 1D ridges (not fit). However, they are present in the estimated functional; double position_init_y1[MAX_NUMBER_OF_PEAKS2]; // initial values of y positions of 1D ridges, input parameters; double position_calc_y1[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitted y positions of 1D ridges, output parameters; double position_err_y1[MAX_NUMBER_OF_PEAKS2]; // y position errors of 1D ridges; bool fix_position_y1[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix the appropriate y positions of 1D ridges (not fit). However, they are present in the estimated functional; double amp_init[MAX_NUMBER_OF_PEAKS2]; // initial values of 2D peaks amplitudes, input parameters; double amp_calc[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitted amplitudes of 2D pea",MatchSource.DOCS,documentation/spectrum/Spectrum.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md
https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:51862,Testability,log,logical,51862,"ions of 2D peaks, output parameters; double position_err_y[MAX_NUMBER_OF_PEAKS2]; // y position errors of 2D peaks; bool fix_position_y[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix the appropriate y positions of 2D peaks (not fit). However, they are present in the estimated functional; double position_init_x1[MAX_NUMBER_OF_PEAKS2]; // initial values of x positions of 1D ridges, input parameters; double position_calc_x1[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitted x positions of 1D ridges, output parameters; double position_err_x1[MAX_NUMBER_OF_PEAKS2]; // x position errors of 1D ridges; bool fix_position_x1[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix appropriate x positions of 1D ridges (not fit). However, they are present in the estimated functional; double position_init_y1[MAX_NUMBER_OF_PEAKS2]; // initial values of y positions of 1D ridges, input parameters; double position_calc_y1[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitted y positions of 1D ridges, output parameters; double position_err_y1[MAX_NUMBER_OF_PEAKS2]; // y position errors of 1D ridges; bool fix_position_y1[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix the appropriate y positions of 1D ridges (not fit). However, they are present in the estimated functional; double amp_init[MAX_NUMBER_OF_PEAKS2]; // initial values of 2D peaks amplitudes, input parameters; double amp_calc[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitted amplitudes of 2D peaks, output parameters; double amp_err[MAX_NUMBER_OF_PEAKS2]; // amplitude errors of 2D peaks; bool fix_amp[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix appropriate amplitudes of 2D peaks (not fit). However, they are present in the estimated functional; double amp_init_x1[MAX_NUMBER_OF_PEAKS2]; // initial values of 1D ridges amplitudes, input parameters; double amp_calc_x1[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitted amplitudes of 1D ridges, output parameters; double amp_err",MatchSource.DOCS,documentation/spectrum/Spectrum.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md
https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:52326,Testability,log,logical,52326," of fitted x positions of 1D ridges, output parameters; double position_err_x1[MAX_NUMBER_OF_PEAKS2]; // x position errors of 1D ridges; bool fix_position_x1[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix appropriate x positions of 1D ridges (not fit). However, they are present in the estimated functional; double position_init_y1[MAX_NUMBER_OF_PEAKS2]; // initial values of y positions of 1D ridges, input parameters; double position_calc_y1[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitted y positions of 1D ridges, output parameters; double position_err_y1[MAX_NUMBER_OF_PEAKS2]; // y position errors of 1D ridges; bool fix_position_y1[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix the appropriate y positions of 1D ridges (not fit). However, they are present in the estimated functional; double amp_init[MAX_NUMBER_OF_PEAKS2]; // initial values of 2D peaks amplitudes, input parameters; double amp_calc[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitted amplitudes of 2D peaks, output parameters; double amp_err[MAX_NUMBER_OF_PEAKS2]; // amplitude errors of 2D peaks; bool fix_amp[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix appropriate amplitudes of 2D peaks (not fit). However, they are present in the estimated functional; double amp_init_x1[MAX_NUMBER_OF_PEAKS2]; // initial values of 1D ridges amplitudes, input parameters; double amp_calc_x1[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitted amplitudes of 1D ridges, output parameters; double amp_err_x1[MAX_NUMBER_OF_PEAKS2]; // amplitude errors of 1D ridges; bool fix_amp_x1[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix the appropriate amplitudes of 1D ridges (not fit). However, they are present in the estimated functional; double amp_init_y1[MAX_NUMBER_OF_PEAKS2]; // initial values of 1D ridges amplitudes, input parameters; double amp_calc_y1[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitted amplitudes of 1D ridges, output parameters; double amp_err_y1",MatchSource.DOCS,documentation/spectrum/Spectrum.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md
https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:52799,Testability,log,logical,52799,"_OF_PEAKS2]; // calculated values of fitted y positions of 1D ridges, output parameters; double position_err_y1[MAX_NUMBER_OF_PEAKS2]; // y position errors of 1D ridges; bool fix_position_y1[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix the appropriate y positions of 1D ridges (not fit). However, they are present in the estimated functional; double amp_init[MAX_NUMBER_OF_PEAKS2]; // initial values of 2D peaks amplitudes, input parameters; double amp_calc[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitted amplitudes of 2D peaks, output parameters; double amp_err[MAX_NUMBER_OF_PEAKS2]; // amplitude errors of 2D peaks; bool fix_amp[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix appropriate amplitudes of 2D peaks (not fit). However, they are present in the estimated functional; double amp_init_x1[MAX_NUMBER_OF_PEAKS2]; // initial values of 1D ridges amplitudes, input parameters; double amp_calc_x1[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitted amplitudes of 1D ridges, output parameters; double amp_err_x1[MAX_NUMBER_OF_PEAKS2]; // amplitude errors of 1D ridges; bool fix_amp_x1[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix the appropriate amplitudes of 1D ridges (not fit). However, they are present in the estimated functional; double amp_init_y1[MAX_NUMBER_OF_PEAKS2]; // initial values of 1D ridges amplitudes, input parameters; double amp_calc_y1[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitted amplitudes of 1D ridges, output parameters; double amp_err_y1[MAX_NUMBER_OF_PEAKS2]; // amplitude errors of 1D ridges; bool fix_amp_y1[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix the appropriate amplitudes of 1D ridges (not fit). However, they are present in the estimated functional; double volume[MAX_NUMBER_OF_PEAKS1]; // calculated volumes of peaks; double volume_err[MAX_NUMBER_OF_PEAKS1]; // errors of peak volumes; double sigma_init_x; // sigma x parameter; double sigma_calc_x;; double sigma_err_x;; bool",MatchSource.DOCS,documentation/spectrum/Spectrum.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md
https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:53277,Testability,log,logical,53277,"NUMBER_OF_PEAKS2]; // calculated values of fitted amplitudes of 2D peaks, output parameters; double amp_err[MAX_NUMBER_OF_PEAKS2]; // amplitude errors of 2D peaks; bool fix_amp[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix appropriate amplitudes of 2D peaks (not fit). However, they are present in the estimated functional; double amp_init_x1[MAX_NUMBER_OF_PEAKS2]; // initial values of 1D ridges amplitudes, input parameters; double amp_calc_x1[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitted amplitudes of 1D ridges, output parameters; double amp_err_x1[MAX_NUMBER_OF_PEAKS2]; // amplitude errors of 1D ridges; bool fix_amp_x1[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix the appropriate amplitudes of 1D ridges (not fit). However, they are present in the estimated functional; double amp_init_y1[MAX_NUMBER_OF_PEAKS2]; // initial values of 1D ridges amplitudes, input parameters; double amp_calc_y1[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitted amplitudes of 1D ridges, output parameters; double amp_err_y1[MAX_NUMBER_OF_PEAKS2]; // amplitude errors of 1D ridges; bool fix_amp_y1[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix the appropriate amplitudes of 1D ridges (not fit). However, they are present in the estimated functional; double volume[MAX_NUMBER_OF_PEAKS1]; // calculated volumes of peaks; double volume_err[MAX_NUMBER_OF_PEAKS1]; // errors of peak volumes; double sigma_init_x; // sigma x parameter; double sigma_calc_x;; double sigma_err_x;; bool fix_sigma_x;; double sigma_init_y; // sigma y parameter; double sigma_calc_y;; double sigma_err_y;; bool fix_sigma_y;; double ro_init; // correlation coefficient; double ro_calc;; double ro_err;; bool fix_ro;; double txy_init; // t parameter for 2D peaks; double txy_calc;; double txy_err;; bool fix_txy;; double sxy_init; // s parameter for 2D peaks; double sxy_calc;; double sxy_err;; bool fix_sxy;; double tx_init; // t parameter for 1D ridges (x direction); double tx_calc;",MatchSource.DOCS,documentation/spectrum/Spectrum.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md
https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:72134,Testability,log,log,72134,"from description of `one_dim_pic` structure. The constants, which can be used for appropriate parameters, are defined in `procfunc.h` header file. ``` {.cpp}; struct one_dim_pic {. float *source; // spectrum to be displayed. TCanvas *Canvas; // Canvas where the spectrum will be displayed. int size; // size of source spectrum; int xmin; // x-starting channel of spectrum; int xmax; // x-end channel of spectrum; int ymin; // base counts; int ymax; // count full scale. int bx1; // position of picture on Canvas, min x; int bx2; // position of picture on Canvas, max x; int by1; // position of picture on Canvas, min y; int by2; // position of picture on Canvas, max y. int display_mode; // spectrum display mode (points, polyline, bars, rainbow, steps, bezier); int y_scale; // y scale (linear, log, sqrt); int levels; // # of color levels for rainbow display mode, it does not apply; // for other display modes; float rainbow1_step; // determines the first color component step for neighboring; // color levels, applies only for rainbow display mode; float rainbow2_step; // determines the second component color step for; // neighboring color levels, applies only for rainbow display mode; float rainbow3_step; // determines the third component color step for; // neighboring color levels, applies only for rainbow display mode. int color_alg; // applies only for rainbow display mode (rgb smooth algorithm, rgb; // modulo color component, cmy smooth algorithm, cmy modulo color; // component, cie smooth algorithm, cie modulo color component, yiq; // smooth algorithm, yiq modulo color component, hsv smooth; // algorithm, hsv modulo color component [15]. int bar_thickness; // applies only for bar display mode; int bar_empty_flag; // (empty bars, full bars) applies only for bar display mode; int border_color; // color of background of the picture; int full_border; // decides whether background is painted; int raster_en_dis; // decides whether the axes and rasters are shown; int raster_long",MatchSource.DOCS,documentation/spectrum/Spectrum.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md
https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:74351,Testability,log,log,74351,"rasters are drawn as long lines; int raster_color; // color of the rasters; char *raster_description_x; // x axis description; char *raster_description_y; // y axis description. int pen_color; // color of spectrum; int pen_dash; // style of pen; int pen_width; // width of line. int chanmark_style; // style of channel marks; int chanmark_width; // width of channel marks; int chanmark_height; // height of channel marks; int chanmark_en_dis; // decides whether the channel marks are shown; int chanmark_color; // color of channel marks. // auxiliary variables, transform coefficients, for internal use only; double mx;; double my;; double px;; double py;. // auxiliary internal variables, working place; double gbezx,gbezy;; TPoint bz[4];; };; ```. The examples using different display parameters are shown in the next; few Figures. ![Display mode -polyline, width of pen=3](figures/image214.png). ![Display mode- bars, shown channel marks](figures/image216.png). ![Display mode- steps, log scale, shown channel marks](figures/image218.png). ![Display mode -Bezier curve interpolation, shown channel marks](figures/image220.png). ![Display mode- rainbow bars, color algorithm (model) RGB, number of color levels=1024, pen width=3](figures/image222.png). ![Display mode-empty bars, color algorithm YIQ, number of color levels 2048](figures/image224.png). ## 2-DIMENSIONAL SPECTRA. The 2-dimensional visualization function displays spectrum; (or its part) on the Canvas of a form. Before calling the function, one; has to fill in the `two_dim_pic` structure containing all parameters of the; display. The function has a form of. ```{.cpp}; char *display2(struct two_dim_pic* p);; ```. This function displays the source two-dimensional spectrum on Canvas.; All parameters are grouped in the `two_dim_pic` structure. Before calling the; `display2` function, the structure should be filled in and the address of; `two_dim_pic` should be passed as a parameter to `display2` function. The meaning of corresp",MatchSource.DOCS,documentation/spectrum/Spectrum.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md
https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:76752,Testability,log,log,76752," y-size of source spectrum; int xmin; // x-starting channel of spectrum; int xmax; // x-end channel of spectrum; int ymin; // y-starting channel of spectrum; int ymax; // y-end channel of spectrum; int zmin; // base counts; int zmax; // counts full scale; int bx1; // position of picture on Canvas, min x; int bx2; // position of picture on Canvas, max x; int by1; // position of picture on Canvas, min y; int by2; // position of picture on Canvas, max y; int mode_group; // display mode algorithm group (simple modes-; // PICTURE2_MODE_GROUP_SIMPLE, modes with shading; // according to light-PICTURE2_MODE_GROUP_LIGHT, modes with; // shading according to channels counts-; // PICTURE2_MODE_GROUP_HEIGHT, modes of combination of; // shading according to light and to channels counts-; // PICTURE2_MODE_GROUP_LIGHT_HEIGHT); int display_mode; // spectrum display mode (points, grid, contours, bars, x_lines,; // y_lines, bars_x, bars_y, needles, surface, triangles); int z_scale; // z scale (linear, log, sqrt); int nodesx; // number of nodes in x dimension of grid; int nodesy; // number of nodes in y dimension of grid; int count_reg; // width between contours, applies only for contours display mode; int alfa; // angles of display,alfa+beta must be less or equal to 90, alpha- angle; // between base line of Canvas and left lower edge of picture picture; // base plane; int beta; // angle between base line of Canvas and right lower edge of picture base plane; int view_angle; // rotation angle of the view, it can be 0, 90, 180, 270 degrees; int levels; // # of color levels for rainbowed display modes, it does not apply for; // simple display modes algorithm group; float rainbow1_step; // determines the first component step for neighboring color; // levels, applies only for rainbowed display modes, it does not apply; // for simple display modes algorithm group; float rainbow2_step; // determines the second component step for neighboring; // color levels, applies only for rainbowed display",MatchSource.DOCS,documentation/spectrum/Spectrum.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md
https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:80974,Testability,log,log,80974,"cides whether the channel marks are shown; int chanmark_style; // style of channel marks; int chanmark_width; // width of channel marks; int chanmark_height; // height of channel marks; int chanmark_color; // color of channel marks; int chanline_en_dis; // decides whether the channel lines (grid) are shown. // auxiliary variables, transformation coefficients for internal use only; double kx;; double ky;; double mxx;; double mxy;; double myx;; double myy;; double txx;; double txy;; double tyx;; double tyy;; double tyz;; double vx;; double vy;; double nu_sli;. // auxiliary internal variables, working place; double z,zeq,gbezx,gbezy,dxspline,dyspline;; int xt,yt,xs,ys,xe,ye,priamka,z_preset_value;; unsigned short obal[MAXIMUM_XSCREEN_RESOLUTION];; unsigned short obal_cont[MAXIMUM_XSCREEN_RESOLUTION];; TPoint bz[4];; };; ```. The examples using different display parameters are shown in the next few Figures. ![Display mode-bars, pen width=2](figures/image226.png). ![Display mode-triangles, log scale](figures/image228.png). ![Display mode-contours](figures/image230.png). ![Display mode surface shading according to height](figures/image232.png). ![Display mode-surface shading according to light point](figures/image234.png). ![Display mode-surface shading according to height+light position with ratio 50:50, CMY color model](figures/image236.png). ![Display mode bars shaded according to height](figures/image238.png). ![Display mode- surface shading according to light position with shadows](figures/image240.png). ![Display mode- surface shading according to height with 10 levels of contours](figures/image242.png). ![Display mode- surface shading according to height, sqrt scale, channel marks and lines shown](figures/image244.png). ![Display mode- surface shading according to height-contours, rasters allowing to localize interesting parts are shown.](figures/image246.png). # References. [1] M. Morháč, J. Kliman, V. Matoušek, M. Veselský, I. Turzo.:; Background elimination metho",MatchSource.DOCS,documentation/spectrum/Spectrum.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md
https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:17647,Usability,simpl,simple,17647,"uations -- noise. The algorithm is based on smoothed; second differences that are compared to its standard deviations.; Therefore it is necessary to pass a parameter of sigma to the peak; searching function. The algorithm is selective to the peaks with a; given sigma. The form of the basic peak searching function is. ```{.cpp}; Int_t Search1(const float *spectrum,; int size,; double sigma);; ```. This function searches for peaks in the source spectrum. The number of found; peaks and their positions are written into structure pointed by; `one_dim_peak` structure pointer. Function parameters:. - **`source`**: pointer to the vector of the source spectrum; - **`p`**: pointer to the `one_dim_peak` structure pointer; - **`size`**: length of the source spectrum; - **`sigma`**: sigma of searched peaks. The `one_dim_peak` structure has the form of. ```{.cpp}; struct one_dim_peak{; int number_of_peaks;; double position[MAX_NUMBER_OF_PEAKS1];; };; ```. An example of simple one-dimensional spectrum with identified peaks is; given in Figure 3.1. ![Simple one-dimensional spectrum with identified peaks](figures/image058.png). An example of 1-dimensional experimental spectrum with many identified; peaks is given in Figure 3.2. ![1-dimensional experimental spectrum with many identified peaks](figures/image060.png). However, when we have noisy data, the number of peaks can be enormous. One; such an example is given in Figure 3.3. ![With noisy data the number of peaks can be enormous](figures/image062.png). Therefore it can be useful to have a possibility to set a threshold value and to consider only the peaks higher than this threshold (see Figure 3.4, only three peaks were identified, threshold=50). The value in the center of the peak (`value[i]`) minus the average value in two symmetrically positioned channels (channels `i-3*sigma`, `i+3*sigma`) must be greater than threshold.; Otherwise the peak is ignored. ![Iwth threshold=50, only three peaks were identified](figures/image064.png",MatchSource.DOCS,documentation/spectrum/Spectrum.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md
https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:44008,Usability,simpl,simple,44008,"s; bool fix_amp[MAX_NUMBER_OF_PEAKS1]i; // logical vector, which allows to fix appropriate amplitudes (not fit). However they are present in the estimated functional; double area[MAX_NUMBER_OF_PEAKS1]; // calculated areas of peaks; double area_err[MAX_NUMBER_OF_PEAKS1]; // errors of peak areas; double sigma_init; // sigma parameter, see peak shape function; double sigma_calc;; double sigma_err;; bool fix_sigma;; double t_init // t parameter, see peak shape function; double t_calc;; double t_err;; bool fix_t;; double b_init // b parameter, see peak shape function; double b_calc;; double b_err;; bool fix_b;; double s_init; // s parameter, see peak shape function; double s_calc;; double s_err;; bool fix_s;; double a0_init; // background is estimated as a0+a1*x+a2*x*x; double a0_calc;; double a0_err;; bool fix_a0;; double a1_init;; double a1_calc;; double a1_err;; bool fix_a1;; double a2_init;; double a2_calc;; double a2_err;; bool fix_a2;; };; ```. As an example we present a simple 1-dimensional synthetic spectrum with 5; peaks. The fit (obtained using above-given awmi fitting function) is given; in Figure 5.1. The chi-square achieved in this fit was 0.76873. The input; value of the fit (positions of peaks and their amplitudes) were; estimated using peak searching function. ![Fit obtained using above given awmi fitting function](figures/image172.png). Let us go to a more complicated fit with a lot of overlapping peaks as in Figure 5.2.; The initial positions of peaks were determined from original data, using; peak searching function. The fit is not very good, as there are some; peaks missing. ![More complicated fit with lot of overlapping peaks](figures/image174.png). However, in order to analyze the spectrum, we can proceed in a completely different way employing the sophisticated functions of background elimination and deconvolution. First, let us remove background from the original raw; data. We get spectrum given in Figure 5.3. ![Removed background from the origina",MatchSource.DOCS,documentation/spectrum/Spectrum.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md
https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:76259,Usability,simpl,simple,76259,,MatchSource.DOCS,documentation/spectrum/Spectrum.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md
https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:77387,Usability,simpl,simple,77387,"hading according to channels counts-; // PICTURE2_MODE_GROUP_HEIGHT, modes of combination of; // shading according to light and to channels counts-; // PICTURE2_MODE_GROUP_LIGHT_HEIGHT); int display_mode; // spectrum display mode (points, grid, contours, bars, x_lines,; // y_lines, bars_x, bars_y, needles, surface, triangles); int z_scale; // z scale (linear, log, sqrt); int nodesx; // number of nodes in x dimension of grid; int nodesy; // number of nodes in y dimension of grid; int count_reg; // width between contours, applies only for contours display mode; int alfa; // angles of display,alfa+beta must be less or equal to 90, alpha- angle; // between base line of Canvas and left lower edge of picture picture; // base plane; int beta; // angle between base line of Canvas and right lower edge of picture base plane; int view_angle; // rotation angle of the view, it can be 0, 90, 180, 270 degrees; int levels; // # of color levels for rainbowed display modes, it does not apply for; // simple display modes algorithm group; float rainbow1_step; // determines the first component step for neighboring color; // levels, applies only for rainbowed display modes, it does not apply; // for simple display modes algorithm group; float rainbow2_step; // determines the second component step for neighboring; // color levels, applies only for rainbowed display modes, it does not; // apply for simple display modes algorithm group; float rainbow3_step; // determines the third component step for neighboring; // color levels, applies only for rainbowed display modes, it does not; // apply for simple display modes algorithm group; int color_alg; // applies only for rainbowed display modes (rgb smooth algorithm,; // rgb modulo color component, cmy smooth algorithm, cmy modulo; // color component, cie smooth algorithm, cie modulo color component,; // yiq smooth algorithm, yiq modulo color component, hsv smooth; // algorithm, hsv modulo color component, it does not apply for simple; // displa",MatchSource.DOCS,documentation/spectrum/Spectrum.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md
https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:77587,Usability,simpl,simple,77587,"ode; // spectrum display mode (points, grid, contours, bars, x_lines,; // y_lines, bars_x, bars_y, needles, surface, triangles); int z_scale; // z scale (linear, log, sqrt); int nodesx; // number of nodes in x dimension of grid; int nodesy; // number of nodes in y dimension of grid; int count_reg; // width between contours, applies only for contours display mode; int alfa; // angles of display,alfa+beta must be less or equal to 90, alpha- angle; // between base line of Canvas and left lower edge of picture picture; // base plane; int beta; // angle between base line of Canvas and right lower edge of picture base plane; int view_angle; // rotation angle of the view, it can be 0, 90, 180, 270 degrees; int levels; // # of color levels for rainbowed display modes, it does not apply for; // simple display modes algorithm group; float rainbow1_step; // determines the first component step for neighboring color; // levels, applies only for rainbowed display modes, it does not apply; // for simple display modes algorithm group; float rainbow2_step; // determines the second component step for neighboring; // color levels, applies only for rainbowed display modes, it does not; // apply for simple display modes algorithm group; float rainbow3_step; // determines the third component step for neighboring; // color levels, applies only for rainbowed display modes, it does not; // apply for simple display modes algorithm group; int color_alg; // applies only for rainbowed display modes (rgb smooth algorithm,; // rgb modulo color component, cmy smooth algorithm, cmy modulo; // color component, cie smooth algorithm, cie modulo color component,; // yiq smooth algorithm, yiq modulo color component, hsv smooth; // algorithm, hsv modulo color component, it does not apply for simple; // display modes algorithm group [15]; float l_h_weight; // weight between shading according to fictive light source and; // according to channels counts, applies only for; // PICTURE2_MODE_GROUP_LIGHT_HEIGHT ",MatchSource.DOCS,documentation/spectrum/Spectrum.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md
https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:77788,Usability,simpl,simple,77788,"des in x dimension of grid; int nodesy; // number of nodes in y dimension of grid; int count_reg; // width between contours, applies only for contours display mode; int alfa; // angles of display,alfa+beta must be less or equal to 90, alpha- angle; // between base line of Canvas and left lower edge of picture picture; // base plane; int beta; // angle between base line of Canvas and right lower edge of picture base plane; int view_angle; // rotation angle of the view, it can be 0, 90, 180, 270 degrees; int levels; // # of color levels for rainbowed display modes, it does not apply for; // simple display modes algorithm group; float rainbow1_step; // determines the first component step for neighboring color; // levels, applies only for rainbowed display modes, it does not apply; // for simple display modes algorithm group; float rainbow2_step; // determines the second component step for neighboring; // color levels, applies only for rainbowed display modes, it does not; // apply for simple display modes algorithm group; float rainbow3_step; // determines the third component step for neighboring; // color levels, applies only for rainbowed display modes, it does not; // apply for simple display modes algorithm group; int color_alg; // applies only for rainbowed display modes (rgb smooth algorithm,; // rgb modulo color component, cmy smooth algorithm, cmy modulo; // color component, cie smooth algorithm, cie modulo color component,; // yiq smooth algorithm, yiq modulo color component, hsv smooth; // algorithm, hsv modulo color component, it does not apply for simple; // display modes algorithm group [15]; float l_h_weight; // weight between shading according to fictive light source and; // according to channels counts, applies only for; // PICTURE2_MODE_GROUP_LIGHT_HEIGHT modes group; int xlight; // x position of fictive light source, applies only for rainbowed display; // modes with shading according to light; int ylight; // y position of fictive light source, applies ",MatchSource.DOCS,documentation/spectrum/Spectrum.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md
https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:77988,Usability,simpl,simple,77988,"+beta must be less or equal to 90, alpha- angle; // between base line of Canvas and left lower edge of picture picture; // base plane; int beta; // angle between base line of Canvas and right lower edge of picture base plane; int view_angle; // rotation angle of the view, it can be 0, 90, 180, 270 degrees; int levels; // # of color levels for rainbowed display modes, it does not apply for; // simple display modes algorithm group; float rainbow1_step; // determines the first component step for neighboring color; // levels, applies only for rainbowed display modes, it does not apply; // for simple display modes algorithm group; float rainbow2_step; // determines the second component step for neighboring; // color levels, applies only for rainbowed display modes, it does not; // apply for simple display modes algorithm group; float rainbow3_step; // determines the third component step for neighboring; // color levels, applies only for rainbowed display modes, it does not; // apply for simple display modes algorithm group; int color_alg; // applies only for rainbowed display modes (rgb smooth algorithm,; // rgb modulo color component, cmy smooth algorithm, cmy modulo; // color component, cie smooth algorithm, cie modulo color component,; // yiq smooth algorithm, yiq modulo color component, hsv smooth; // algorithm, hsv modulo color component, it does not apply for simple; // display modes algorithm group [15]; float l_h_weight; // weight between shading according to fictive light source and; // according to channels counts, applies only for; // PICTURE2_MODE_GROUP_LIGHT_HEIGHT modes group; int xlight; // x position of fictive light source, applies only for rainbowed display; // modes with shading according to light; int ylight; // y position of fictive light source, applies only for rainbowed display; // modes with shading according to light; int zlight; // z position of fictive light source, applies only for rainbowed display; // modes with shading according to light; i",MatchSource.DOCS,documentation/spectrum/Spectrum.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md
https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:78374,Usability,simpl,simple,78374,"y for; // simple display modes algorithm group; float rainbow1_step; // determines the first component step for neighboring color; // levels, applies only for rainbowed display modes, it does not apply; // for simple display modes algorithm group; float rainbow2_step; // determines the second component step for neighboring; // color levels, applies only for rainbowed display modes, it does not; // apply for simple display modes algorithm group; float rainbow3_step; // determines the third component step for neighboring; // color levels, applies only for rainbowed display modes, it does not; // apply for simple display modes algorithm group; int color_alg; // applies only for rainbowed display modes (rgb smooth algorithm,; // rgb modulo color component, cmy smooth algorithm, cmy modulo; // color component, cie smooth algorithm, cie modulo color component,; // yiq smooth algorithm, yiq modulo color component, hsv smooth; // algorithm, hsv modulo color component, it does not apply for simple; // display modes algorithm group [15]; float l_h_weight; // weight between shading according to fictive light source and; // according to channels counts, applies only for; // PICTURE2_MODE_GROUP_LIGHT_HEIGHT modes group; int xlight; // x position of fictive light source, applies only for rainbowed display; // modes with shading according to light; int ylight; // y position of fictive light source, applies only for rainbowed display; // modes with shading according to light; int zlight; // z position of fictive light source, applies only for rainbowed display; // modes with shading according to light; int shadow; // determines whether shadow will be drawn (no shadow, shadow),; // for rainbowed display modes with shading according to light; int shading; // determines whether the picture will shaded, smoothed (no shading,; // shading), for rainbowed display modes only; int bezier; // determines Bezier interpolation (applies only for simple display; // modes group for grid, x_lines, y",MatchSource.DOCS,documentation/spectrum/Spectrum.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md
https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:79327,Usability,simpl,simple,79327,"color component, hsv smooth; // algorithm, hsv modulo color component, it does not apply for simple; // display modes algorithm group [15]; float l_h_weight; // weight between shading according to fictive light source and; // according to channels counts, applies only for; // PICTURE2_MODE_GROUP_LIGHT_HEIGHT modes group; int xlight; // x position of fictive light source, applies only for rainbowed display; // modes with shading according to light; int ylight; // y position of fictive light source, applies only for rainbowed display; // modes with shading according to light; int zlight; // z position of fictive light source, applies only for rainbowed display; // modes with shading according to light; int shadow; // determines whether shadow will be drawn (no shadow, shadow),; // for rainbowed display modes with shading according to light; int shading; // determines whether the picture will shaded, smoothed (no shading,; // shading), for rainbowed display modes only; int bezier; // determines Bezier interpolation (applies only for simple display; // modes group for grid, x_lines, y_lines display modes); int border_color; // color of background of the picture; int full_border; // decides whether background is painted; int raster_en_dis; // decides whether the rasters are shown; int raster_long; // decides whether the rasters are drawn as long lines; int raster_color; // color of the rasters; char *raster_description_x; // x axis description; char *raster_description_y; // y axis description; char *raster_description_z; // z axis description; int pen_color; // color of spectrum; int pen_dash; // style of pen; int pen_width; // width of line; int chanmark_en_dis; // decides whether the channel marks are shown; int chanmark_style; // style of channel marks; int chanmark_width; // width of channel marks; int chanmark_height; // height of channel marks; int chanmark_color; // color of channel marks; int chanline_en_dis; // decides whether the channel lines (grid) are shown.",MatchSource.DOCS,documentation/spectrum/Spectrum.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md:235,Availability,error,error,235,"# Adding a Class. ## The Role of TObject. The light-weight **`TObject`** class provides the default behavior and; protocol for the objects in the ROOT system. Specifically, it is the; primary interface to classes providing object I/O, error handling,; inspection, introspection, and drawing. The interface to this service is; via abstract classes. ### Introspection, Reflection and Run Time Type Identification. Introspection, which is also referred to as reflection, or run time type; identification (RTTI) is the ability of a class to reflect upon itself; or to ""look inside itself. ROOT implements reflection with the; **`TClass`** class. It provides all the information about a class, a; full description of data members and methods, including the comment; field and the method parameter types. A class with the `ClassDef` macro; has the ability to obtain a **`TClass`** with the `IsA` method. ``` {.cpp}; TClass *cl = obj->IsA();; ```. It returns a **`TClass`**. In addition, an object can directly get the; class name and the base classes by:. ``` {.cpp}; const char* name = obj->ClassName();; ```. If the class is a descendent of **`TObject`**, you can check if an; object inherits from a specific class, you can use the `InheritsFrom`; method. This method returns `kTrue` if the object inherits from the; specified class name or **`TClass`**. ``` {.cpp}; Bool_t b = obj->InheritsFrom(""TLine"");; Bool_t b = obj->InheritsFrom(TLine::Class());; ```. ROOT and `Cling` rely on reflection and the class dictionary to identify; the type of a variable at run time. With **`TObject`** inheritance come; some methods that use Introspection to help you see the data in the; object or class. For instance:. ``` {.cpp}; obj->Dump(); // lists all data members and their current values; obj->Inspect(); // opens a window to browse data members; obj->DrawClass(); // Draws the class inheritance tree; ```. For an example of `obj->Inspect()`, see ""Inspecting Objects"". ### Collections. To store an object in a ",MatchSource.DOCS,documentation/users-guide/AddingaClass.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md:5517,Availability,mask,mask,5517,"status window, select the `Options` menu and the; `EventStatus` item. This method returns a string of information about; the object at position (x, y). Every time the cursor moves, the object; under the cursor executes the `GetObjectInfo` method. The string is then; shown in the status bar. There is a default implementation in; **`TObject`**, but it is typically overridden for classes that can; report peculiarities for different cursor positions (for example the bin; contents in a TH1). ### IsFolder. By default an object inheriting from **`TObject`** is not brows-able,; because **`TObject::IsFolder()`** returns `kFALSE`. To make a class; browse-able, the `IsFolder` method needs to be overridden to return; `kTRUE`. In general, this method returns `kTRUE` if the object contains; browse-able objects (like containers or lists of other objects). ### Bit Masks and Unique ID. A **`TObject`** descendent inherits two data members: `fBits` and; `fUniqueID`. `fBits `is 32-bit data member used with a bit mask to get; object information. Bits 0 - 13 are reserved as global bits, bits 14 -; 23 can be used in different class hierarchies. ``` {.cpp}; enum EObjBits {; kCanDelete = BIT(0), // if can be deleted; kMustCleanup = BIT(3), // if destructor must call RecursiveRemove(); kObjInCanvas = BIT(3), // for backward compatibility only; kIsReferenced = BIT(4), // if referenced by TRef or TRefArray; kHasUUID = BIT(5), // if has a TUUID, fUniqueID=UUIDNumber; kCannotPick = BIT(6), // if cannot be picked in a pad; kNoContextMenu = BIT(8), // if does not want a context menu; kInvalidObject = BIT(13) // object ctor succeeded but the object should not be used; };; ```. For example, the bits `kMustCleanup` and `kCanDelete` are used in; **`TObject`**. See ""The kCanDelete Bit"" and ""The kMustCleanup Bit"". They; can be set by any object and should not be reused. Make sure not; to overlap them in any given hierarchy. The bit 13 (`kInvalidObject`) is; set when an object could not be read from a ROO",MatchSource.DOCS,documentation/users-guide/AddingaClass.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md:9095,Availability,error,error,9095,":. ``` {.cpp}; ClassDef(TLine,1); //A line segment; ```. The **`ClassVersionID`** is used by the ROOT I/O system. It is written; on the output stream and during reading you can check this version ID; and take appropriate action depending on the value of the ID. See; ""Streamers"". Every time you change the data members of a class, you; should increase its `ClassVersionID` by one. The `ClassVersionID` should; be `>=1`. Set `ClassVersionID=0` in case you don't need object I/O. To; be able to generate properly documentation for your classes using; **`THtml`** you must add the statement:. ``` {.cpp}; ClassImp(ClassName); ```. For example in `TLine.cxx`:. ``` {.cpp}; ClassImp(TLine); ```. Note that you should provide a default constructor for your classes,; i.e. a constructor with zero parameters or with one or more parameters; all with default values in case you want to use object I/O. If do not; provide such a default constructor, you MUST implement an I/O; constructor. If not you will get a compile time error. See the ""The; Default Constructor"" paragraph in this chapter. The `ClassDef` and; `ClassImp` macros are defined in the file `Rtypes.h`. This file is; referenced by all ROOT include files, so you will automatically get them; if you use a ROOT include file. ### Template Support. In ROOT version 3.03 and older, ROOT provided special `ClassDef` and; `ClassImp` macros for classes with two and three template arguments. In; ROOT version 3.04 and above, the macros `ClassDef` and `ClassImp` can be; used directly even for a class template. `ClassImp` is used to register; an implementation file in a class. For class templates, the `ClassImp`; can only be used for a specific class template instance. ``` {.cpp}; ClassImp(MyClass1<double>);; ```. For multiple template arguments, you will need to use an intermediary; `typedef`:. ``` {.cpp}; typedef MyClass2<int,float> myc_i_f;; ClassImp(myc_i_f);; ```. You can also register an implementation for all instances of a class; templat",MatchSource.DOCS,documentation/users-guide/AddingaClass.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md:20619,Availability,avail,available,20619,"or for your class. See the ""The Default Constructor"" paragraph; in this chapter. ``` {.cpp}; #include <iostream.h>; #include ""TObject.h""; class SClass : public TObject {; private:; Float_t fX; //x position in centimeters; Float_t fY; //y position in centimeters; Int_t fTempValue; //! temporary state value; public:; SClass() { fX = fY = -1; }; void Print() const;; void SetX(float x) { fX = x; }; void SetY(float y) { fY = y; }. ClassDef(SClass, 1); };; ```. **Step 2:** Add a call to the `ClassDef` macro to at the end of the class; definition (in the `SClass.h` file). `ClassDef(SClass,1)`. Add a call to; the `ClassImp` macro in the implementation file (`SClass.cxx`):; `ClassImp(SClass)`. ``` {.cpp}; // SClass.cxx:; #include ""SClass.h""; ClassImp(SClass);; void SClass::Print() const {; cout << ""fX = "" << fX << "", fY = "" << fY << endl;; }; ```. You can add a class without using the `ClassDef` and `ClassImp` macros;; however, you will be limited. Specifically the object I/O features of; ROOT will not be available to you for these classes. See ""Cling the C++; Interpreter"". The `ShowMembers` and `Streamer` method, as well as the; `>>` operator overloads, are implemented only if you use `ClassDef` and; `ClassImp`. See `$ROOTSYS/include/Rtypes.h` for the definition of; `ClassDef` and `ClassImp`. To exclude a data member from the `Streamer`,; add a `!` as the first character in the comments of the field:. ``` {.cpp}; Int_t fTempValue; //! temporary state value; ```. ### The LinkDef.h File. **Step 3:** The `LinkDef.h` file tells `rootcling` which classes should; be added to the dictionary. ``` {.cpp}; #ifdef __CLING__; #pragma link C++ class SClass;; #endif; ```. Three options can trail the class name:. - `-` : tells `rootcling` **not** to generate the `Streamer` method for; this class. This is necessary for those classes that need a; customized `Streamer` method. ``` {.cpp}; #pragma link C++ class SClass-; // no streamer; ```. - **`!`** : tells `rootcling` **not** to generate t",MatchSource.DOCS,documentation/users-guide/AddingaClass.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md:22127,Availability,error,error,22127,"e `LinkDef.h` file tells `rootcling` which classes should; be added to the dictionary. ``` {.cpp}; #ifdef __CLING__; #pragma link C++ class SClass;; #endif; ```. Three options can trail the class name:. - `-` : tells `rootcling` **not** to generate the `Streamer` method for; this class. This is necessary for those classes that need a; customized `Streamer` method. ``` {.cpp}; #pragma link C++ class SClass-; // no streamer; ```. - **`!`** : tells `rootcling` **not** to generate the; `operator>>(`**`TBuffer`** `&b,MyClass *&obj)` method for this; class. This is necessary to be able to write pointers to objects of; classes not inheriting from **`TObject`**. ``` {.cpp}; #pragma link C++ class SClass!; // no >> operator; // or; #pragma link C++ class SClass-!; // no streamer, no >> operator; ```. - **+** : in ROOT version 1 and 2 tells `rootcling` to generate a; `Streamer` with extra byte count information. This adds an integer; to each object in the output buffer, but it allows for powerful; error correction in case a `Streamer` method is out of sync with; data in the file. The `+` option is mutual exclusive with both the; `-` and `!` options. IMPORTANT NOTE: In ROOT Version 3 and later, a ""+"" after the class name; tells `rootcling` to use the new I/O system. The byte count check is; always added. The new I/O system has many advantages including support; automatic schema evolution, full support for STL collections and better; run-time performance. We strongly recommend using it. ``` {.cpp}; #pragma link C++ class SClass+; // add byte count; ```. For information on `Streamers` see ""Input/Output"". To get help on; `rootcling` type on the UNIX command line: **`rootcling -h`**. #### The Order Matters. When using template classes, the order of the pragma statements matters.; For example, here is a template class `Tmpl` and a normal class `Norm`,; which holds a specialized instance of a `Tmpl`:. ``` {.cpp}; class Norm {; private:; Tmpl<int>* fIntTmpl;; public:; ...; };; ```. Th",MatchSource.DOCS,documentation/users-guide/AddingaClass.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md:23933,Availability,error,error,23933,"mple, here is a template class `Tmpl` and a normal class `Norm`,; which holds a specialized instance of a `Tmpl`:. ``` {.cpp}; class Norm {; private:; Tmpl<int>* fIntTmpl;; public:; ...; };; ```. Then in `Linkdef.h,` the pragma statements must be ordered by listing; all specializations before any classes that need them:. ``` {.cpp}; // Correct Linkdef.h ordering; ...; #pragma link C++ class Tmpl<int>;; #pragma link C++ class Norm;; ...; ```. And not vice versa:. ``` {.cpp}; // Bad Linkdef.h ordering; ...; #pragma link C++ class Norm;; #pragma link C++ class Tmpl<int>;; ...; ```. In this case, `rootcling` generates `Norm::Streamer()` that makes; reference to `Tmpl<int>::Streamer()`. Then `rootcling` gets to process; `Tmpl<int>` and generates a specialized `Tmpl<int>::Streamer()`; function. The problem is, when the compiler finds the first; `Tmpl<int>::Streamer()`, it will instantiate it. However, later in the; file it finds the specialized version that `rootcling` generated. This; causes the error. However, if the `Linkdef.h` order is reversed then; `rootcling` can generate the specialized `Tmpl<int>::Streamer()` before; it is needed (and thus never instantiated by the compiler). #### Other Useful Pragma Statements. The complete list of pragma statements currently supported by Cling is:. ``` {.cpp}; #pragma link [C|C++|off] all [class|function|global|typedef];; #pragma link [C|C++|off]; [class|struct|union|enum|namespace|protected][name];; #pragma link [C|C++|off] [global|typedef][name];; #pragma link [C|C++|off] [nestedclass|nestedtypedef];. #pragma link [C++|C|off|MACRO] function [name]<(argtypes)>;; #pragma link; [C++|C|off|MACRO] function [classname]::[name]<(argtypes)>;; #pragma link off all methods;; #pragma link [C|C++|off] defined_in [filename];; #pragma link; [C|C++|off] defined_in [class|struct|namespace] [name];; #pragma link [C|C++|off] all_function [classname];; #pragma link [C|C++|off] all_datamember [classname];; ```. The `[classname]` and the `[name]`",MatchSource.DOCS,documentation/users-guide/AddingaClass.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md:35417,Availability,avail,available,35417,"the CLI switches of `genreflex` can be; inspected with the `genreflex --help` command. The entity corresponding to the `LinkDef` file for `genreflex` is the; *selection XML file*, also called *selection XML* or simply *selection file*.; A *selection XML file* allows to describe a list of classes for which; the dictionaries are to be created. In addition, it allows to specify; properties of classes or data members, without the need to add comments in; the source code. This is of primary importance when dictionaries must be; created for classes residing in code which cannot be modified.; For a complete description of the structure of the *selection XML files*; and the way in which attributes can be set, refer to the `genreflex --help`; command. It is important to observe that *selection XML files* can be used in presence; of `rootcling` invocations instead of `LinkDef` files. ### The `ROOT::Meta::Selection` namespace. Not only `LinkDef` and `selection` files allow to select the classes for which; the dictionaries must be created: a third method is available. This is; represented by the `ROOT::Meta::Selection` namespace. The idea behind this; technique is that all the classes which are located in this special namespace; are automatically selected for dictionary generation. All the properties and; annotations allowed by `LinkDef` and `selection XML` files are possible.; For a detailed documentation of the features of the `ROOT::Meta::Selection`; namespace, refer to its online documentation. ## Adding a Class with ACLiC. \index{adding a class!ACLiC}; **Step 1:** Define your class. ``` {.cpp}; #include ""TObject.h"". // define the ABC class and make it inherit from TObject so that; // we can write ABC to a ROOT file; class ABC : public TObject {. public:; Float_t a, b, c, p;; ABC() : a(0), b(0), c(0), p(0){};. // Define the class for the dictionary; ClassDef (ABC,1); };. // Call the ClassImp macro to give the ABC class RTTI and; // full I/O capabilities. #if !defined(__CLING",MatchSource.DOCS,documentation/users-guide/AddingaClass.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md:7764,Deployability,integrat,integrate,7764,"8 bits are reserved; for the system usage; the low 24 bits are user settable. `fUniqueID` is; a data member used to give a unique identification number to an object.; It is initialized to zero by the **`TObject`** constructor. ROOT does; not use this data member. The two data members (`fBits` and `fUniqueID`); are streamed out when writing an object to disk. If you do not use them,; you can save some space and time by specifying:. ``` {.cpp}; MyClass::Class()->IgnoreTObjectStreamer();; ```. This sets a bit in the **`TClass`** object. If the file is compressed,; the savings are minimal since most values are zero; however, it saves; some space when the file is not compressed. A call; to` IgnoreTObjectStreamer` also prevents the creation of two additional; branches when splitting the object. If left alone, two branches called; `fBits` and `fUniqueID` will appear. ## Motivation. If you want to integrate and use your classes with ROOT, to enjoy; features like, extensive RTTI (Run Time Type Information) and ROOT; object I/O and inspection, you have to add the following line to your; class header files:. ``` {.cpp}; ClassDef(ClassName,ClassVersionID); //The class title; ```. For example in `TLine.h` we have:. ``` {.cpp}; ClassDef(TLine,1); //A line segment; ```. The **`ClassVersionID`** is used by the ROOT I/O system. It is written; on the output stream and during reading you can check this version ID; and take appropriate action depending on the value of the ID. See; ""Streamers"". Every time you change the data members of a class, you; should increase its `ClassVersionID` by one. The `ClassVersionID` should; be `>=1`. Set `ClassVersionID=0` in case you don't need object I/O. To; be able to generate properly documentation for your classes using; **`THtml`** you must add the statement:. ``` {.cpp}; ClassImp(ClassName); ```. For example in `TLine.cxx`:. ``` {.cpp}; ClassImp(TLine); ```. Note that you should provide a default constructor for your classes,; i.e. a constructor wi",MatchSource.DOCS,documentation/users-guide/AddingaClass.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md:13669,Deployability,install,installed,13669,"e following 3 constructors which exists and is; public:. ``` {.cpp}; MyClass(UserClass*);MyClass(TRootIOCtor*);; MyClass(); // Or a constructor with all its arguments defaulted.; ```. When more than one pragma ioctortype is used, the first seen as; priority. For example with:. ``` {.cpp}; #pragma link C++ ioctortype UserClass1;; #pragma link C++ ioctortype UserClass2;; ```. We look for the first existing public constructor in the following; order:. ``` {.cpp}; MyClass(UserClass1*);; MyClass(UserClass2*);; MyClass(TRootIOCtor*);; MyClass(); // Or a constructor with all its arguments defaulted.; ```. ## rootcling: The Cling Dictionary Generator. A way in which dictionaries can be generated is via the `rootcling`; utility. This tool generates takes as input a set of headers and; generates in output the dictionary C++ code and a `pcm` file.; This latter file is fundamental for the correct functioning of the; dictionary at runtime. It should be located in the directory where; the shared library is installed in which the compiled dictionary; resides. NOTA BENE: the dictionaries that will be used within the same project; must have unique names. In other words, compiled object files relative; to dictionary source files cannot reside in the same library or in; two libraries loaded by the same application if the original source; files have the same name.; This loose limitation is imposed by the registration mechanism ROOT; has in place to keep track of dynamically loaded libraries. In the following example, we walk through the steps necessary to; generate a dictionary, I/O, and inspect member functions. Let's start; with a **`TEvent`** class, which contains a collection of **`TTracks`**. The `TEvent.h` header is:. ``` {.cpp}; #ifndef __TEvent__; #define __TEvent__; #include ""TObject.h""; #include ""TCollection.h"". class TTrack;. class TEvent : public TObject {; private:; Int_t fId; // event sequential id; Float_t fTotalMom; // total momentum; TCollection *fTracks; // collection",MatchSource.DOCS,documentation/users-guide/AddingaClass.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md:19307,Deployability,toggle,toggle,19307," changing this line in the source file:. ``` {.cpp}; ClassDef(TEvent,0);; ```. If you want to prevent the generation of `Streamer()`, see the section; ""Adding a Class with a Shared Library"". ### Dictionaries for STL. Usually, headers are passed to rootcling at the command line. To generate; a dictionary for a class from the STL, e.g. **std::vector\<MyClass\>**, you would normally pass the header defining; **MyClass** and **std::vector**. The latter is a compiler specific; header and cannot be passed to rootcling directly. Instead, create a; little header file that includes both headers, and pass that to; rootcling. Often ROOT knows where **MyClass** and the templated class (e.g. vector); are defined, for example because the files got **\#included**. Knowing; these header files ROOT can automatically generate the dictionary for; any template combination (e.g. **vector\<myClass\>**) when it is needed,; by generating files starting with **AutoDict\***. You can toggle this; feature on or off at the ROOT prompt by executing **.autodict**. ## Adding a Class with a Shared Library. \index{adding a class!shared library}; **Step 1:** Define your own class in `SClass.h` and implement it in; `SClass.cxx`. You must provide a default constructor or an I/O; constructor for your class. See the ""The Default Constructor"" paragraph; in this chapter. ``` {.cpp}; #include <iostream.h>; #include ""TObject.h""; class SClass : public TObject {; private:; Float_t fX; //x position in centimeters; Float_t fY; //y position in centimeters; Int_t fTempValue; //! temporary state value; public:; SClass() { fX = fY = -1; }; void Print() const;; void SetX(float x) { fX = x; }; void SetY(float y) { fY = y; }. ClassDef(SClass, 1); };; ```. **Step 2:** Add a call to the `ClassDef` macro to at the end of the class; definition (in the `SClass.h` file). `ClassDef(SClass,1)`. Add a call to; the `ClassImp` macro in the implementation file (`SClass.cxx`):; `ClassImp(SClass)`. ``` {.cpp}; // SClass.cxx:; #includ",MatchSource.DOCS,documentation/users-guide/AddingaClass.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md:6702,Energy Efficiency,allocate,allocated,6702,"cpp}; enum EObjBits {; kCanDelete = BIT(0), // if can be deleted; kMustCleanup = BIT(3), // if destructor must call RecursiveRemove(); kObjInCanvas = BIT(3), // for backward compatibility only; kIsReferenced = BIT(4), // if referenced by TRef or TRefArray; kHasUUID = BIT(5), // if has a TUUID, fUniqueID=UUIDNumber; kCannotPick = BIT(6), // if cannot be picked in a pad; kNoContextMenu = BIT(8), // if does not want a context menu; kInvalidObject = BIT(13) // object ctor succeeded but the object should not be used; };; ```. For example, the bits `kMustCleanup` and `kCanDelete` are used in; **`TObject`**. See ""The kCanDelete Bit"" and ""The kMustCleanup Bit"". They; can be set by any object and should not be reused. Make sure not; to overlap them in any given hierarchy. The bit 13 (`kInvalidObject`) is; set when an object could not be read from a ROOT file. It will check; this bit and will skip to the next object on the file. The **`TObject`** constructor initializes the `fBits` to zero depending; if the object is created on the stack or allocated on the heap. When the; object is created on the stack, the `kCanDelete` bit is set to false to; protect from deleting objects on the stack. The high 8 bits are reserved; for the system usage; the low 24 bits are user settable. `fUniqueID` is; a data member used to give a unique identification number to an object.; It is initialized to zero by the **`TObject`** constructor. ROOT does; not use this data member. The two data members (`fBits` and `fUniqueID`); are streamed out when writing an object to disk. If you do not use them,; you can save some space and time by specifying:. ``` {.cpp}; MyClass::Class()->IgnoreTObjectStreamer();; ```. This sets a bit in the **`TClass`** object. If the file is compressed,; the savings are minimal since most values are zero; however, it saves; some space when the file is not compressed. A call; to` IgnoreTObjectStreamer` also prevents the creation of two additional; branches when splitting the obj",MatchSource.DOCS,documentation/users-guide/AddingaClass.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md:11627,Energy Efficiency,allocate,allocate,11627,".h file with all the explicit template instances; // that will be needed at link time; #ifdef __CLING__. #pragma link C++ class MyClass1<float>+;; #pragma link C++ class MyClass1<double>+;; #pragma link C++ class MyClass2<float,int>+;; #pragma link C++ class MyClass2<float,double>+;; #pragma link C++ class MyClass3<float,int,TObject*>+;; #pragma link C++ class MyClass3<float,TEvent*,TObject*>+;. #endif; ```. ## The Default Constructor. ROOT object I/O requires every class to have either a default; constructor or an I/O constructor. A default constructor is a; constructor with zero parameters or with one or more parameters all with; default values. An I/O constructor is a constructor with exactly one; parameter which type is a pointer to one of the type marked as an 'io; constructor type'. We will come back to this context in a few; paragraphs. This default or I/O constructor is called whenever an object; is being read from a ROOT database. Be sure that you do not allocate any; space for embedded pointer objects in this constructor. This space will; be lost (memory leak) while reading in the object. For example:. ``` {.cpp}; class T49Event : public TObject {; private:; Int_t fId;; TCollection *fTracks;; ...; public:; // Error space for TList pointer will be lost; T49Event() { fId = 0; fTrack = new TList; }; // Correct default initialization of pointer; T49Event() { fId = 0; fTrack = 0; }; ...; };; ```. The memory will be lost because during reading of the object the pointer; will be set to the object it was pointing to at the time the object was; written. Create the `fTrack` list when you need it, e.g. when you start; filling the list or in a **not-default** constructor. ``` {.cpp}; ...; if (!fTrack) fTrack = new TList;; ...; ```. The constructor actually called by the ROOT I/O can be customized by; using the rootcling pragma:. ``` {.cpp}; #pragma link C++ ioctortype UserClass;; ```. For example, with this pragma and a class named MyClass, the ROOT I/O; will call the",MatchSource.DOCS,documentation/users-guide/AddingaClass.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md:22117,Energy Efficiency,power,powerful,22117,"e `LinkDef.h` file tells `rootcling` which classes should; be added to the dictionary. ``` {.cpp}; #ifdef __CLING__; #pragma link C++ class SClass;; #endif; ```. Three options can trail the class name:. - `-` : tells `rootcling` **not** to generate the `Streamer` method for; this class. This is necessary for those classes that need a; customized `Streamer` method. ``` {.cpp}; #pragma link C++ class SClass-; // no streamer; ```. - **`!`** : tells `rootcling` **not** to generate the; `operator>>(`**`TBuffer`** `&b,MyClass *&obj)` method for this; class. This is necessary to be able to write pointers to objects of; classes not inheriting from **`TObject`**. ``` {.cpp}; #pragma link C++ class SClass!; // no >> operator; // or; #pragma link C++ class SClass-!; // no streamer, no >> operator; ```. - **+** : in ROOT version 1 and 2 tells `rootcling` to generate a; `Streamer` with extra byte count information. This adds an integer; to each object in the output buffer, but it allows for powerful; error correction in case a `Streamer` method is out of sync with; data in the file. The `+` option is mutual exclusive with both the; `-` and `!` options. IMPORTANT NOTE: In ROOT Version 3 and later, a ""+"" after the class name; tells `rootcling` to use the new I/O system. The byte count check is; always added. The new I/O system has many advantages including support; automatic schema evolution, full support for STL collections and better; run-time performance. We strongly recommend using it. ``` {.cpp}; #pragma link C++ class SClass+; // add byte count; ```. For information on `Streamers` see ""Input/Output"". To get help on; `rootcling` type on the UNIX command line: **`rootcling -h`**. #### The Order Matters. When using template classes, the order of the pragma statements matters.; For example, here is a template class `Tmpl` and a normal class `Norm`,; which holds a specialized instance of a `Tmpl`:. ``` {.cpp}; class Norm {; private:; Tmpl<int>* fIntTmpl;; public:; ...; };; ```. Th",MatchSource.DOCS,documentation/users-guide/AddingaClass.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md:114,Integrability,protocol,protocol,114,"# Adding a Class. ## The Role of TObject. The light-weight **`TObject`** class provides the default behavior and; protocol for the objects in the ROOT system. Specifically, it is the; primary interface to classes providing object I/O, error handling,; inspection, introspection, and drawing. The interface to this service is; via abstract classes. ### Introspection, Reflection and Run Time Type Identification. Introspection, which is also referred to as reflection, or run time type; identification (RTTI) is the ability of a class to reflect upon itself; or to ""look inside itself. ROOT implements reflection with the; **`TClass`** class. It provides all the information about a class, a; full description of data members and methods, including the comment; field and the method parameter types. A class with the `ClassDef` macro; has the ability to obtain a **`TClass`** with the `IsA` method. ``` {.cpp}; TClass *cl = obj->IsA();; ```. It returns a **`TClass`**. In addition, an object can directly get the; class name and the base classes by:. ``` {.cpp}; const char* name = obj->ClassName();; ```. If the class is a descendent of **`TObject`**, you can check if an; object inherits from a specific class, you can use the `InheritsFrom`; method. This method returns `kTrue` if the object inherits from the; specified class name or **`TClass`**. ``` {.cpp}; Bool_t b = obj->InheritsFrom(""TLine"");; Bool_t b = obj->InheritsFrom(TLine::Class());; ```. ROOT and `Cling` rely on reflection and the class dictionary to identify; the type of a variable at run time. With **`TObject`** inheritance come; some methods that use Introspection to help you see the data in the; object or class. For instance:. ``` {.cpp}; obj->Dump(); // lists all data members and their current values; obj->Inspect(); // opens a window to browse data members; obj->DrawClass(); // Draws the class inheritance tree; ```. For an example of `obj->Inspect()`, see ""Inspecting Objects"". ### Collections. To store an object in a ",MatchSource.DOCS,documentation/users-guide/AddingaClass.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md:192,Integrability,interface,interface,192,"# Adding a Class. ## The Role of TObject. The light-weight **`TObject`** class provides the default behavior and; protocol for the objects in the ROOT system. Specifically, it is the; primary interface to classes providing object I/O, error handling,; inspection, introspection, and drawing. The interface to this service is; via abstract classes. ### Introspection, Reflection and Run Time Type Identification. Introspection, which is also referred to as reflection, or run time type; identification (RTTI) is the ability of a class to reflect upon itself; or to ""look inside itself. ROOT implements reflection with the; **`TClass`** class. It provides all the information about a class, a; full description of data members and methods, including the comment; field and the method parameter types. A class with the `ClassDef` macro; has the ability to obtain a **`TClass`** with the `IsA` method. ``` {.cpp}; TClass *cl = obj->IsA();; ```. It returns a **`TClass`**. In addition, an object can directly get the; class name and the base classes by:. ``` {.cpp}; const char* name = obj->ClassName();; ```. If the class is a descendent of **`TObject`**, you can check if an; object inherits from a specific class, you can use the `InheritsFrom`; method. This method returns `kTrue` if the object inherits from the; specified class name or **`TClass`**. ``` {.cpp}; Bool_t b = obj->InheritsFrom(""TLine"");; Bool_t b = obj->InheritsFrom(TLine::Class());; ```. ROOT and `Cling` rely on reflection and the class dictionary to identify; the type of a variable at run time. With **`TObject`** inheritance come; some methods that use Introspection to help you see the data in the; object or class. For instance:. ``` {.cpp}; obj->Dump(); // lists all data members and their current values; obj->Inspect(); // opens a window to browse data members; obj->DrawClass(); // Draws the class inheritance tree; ```. For an example of `obj->Inspect()`, see ""Inspecting Objects"". ### Collections. To store an object in a ",MatchSource.DOCS,documentation/users-guide/AddingaClass.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md:296,Integrability,interface,interface,296,"# Adding a Class. ## The Role of TObject. The light-weight **`TObject`** class provides the default behavior and; protocol for the objects in the ROOT system. Specifically, it is the; primary interface to classes providing object I/O, error handling,; inspection, introspection, and drawing. The interface to this service is; via abstract classes. ### Introspection, Reflection and Run Time Type Identification. Introspection, which is also referred to as reflection, or run time type; identification (RTTI) is the ability of a class to reflect upon itself; or to ""look inside itself. ROOT implements reflection with the; **`TClass`** class. It provides all the information about a class, a; full description of data members and methods, including the comment; field and the method parameter types. A class with the `ClassDef` macro; has the ability to obtain a **`TClass`** with the `IsA` method. ``` {.cpp}; TClass *cl = obj->IsA();; ```. It returns a **`TClass`**. In addition, an object can directly get the; class name and the base classes by:. ``` {.cpp}; const char* name = obj->ClassName();; ```. If the class is a descendent of **`TObject`**, you can check if an; object inherits from a specific class, you can use the `InheritsFrom`; method. This method returns `kTrue` if the object inherits from the; specified class name or **`TClass`**. ``` {.cpp}; Bool_t b = obj->InheritsFrom(""TLine"");; Bool_t b = obj->InheritsFrom(TLine::Class());; ```. ROOT and `Cling` rely on reflection and the class dictionary to identify; the type of a variable at run time. With **`TObject`** inheritance come; some methods that use Introspection to help you see the data in the; object or class. For instance:. ``` {.cpp}; obj->Dump(); // lists all data members and their current values; obj->Inspect(); // opens a window to browse data members; obj->DrawClass(); // Draws the class inheritance tree; ```. For an example of `obj->Inspect()`, see ""Inspecting Objects"". ### Collections. To store an object in a ",MatchSource.DOCS,documentation/users-guide/AddingaClass.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md:2582,Integrability,interface,interface,2582,"`** inheritance come; some methods that use Introspection to help you see the data in the; object or class. For instance:. ``` {.cpp}; obj->Dump(); // lists all data members and their current values; obj->Inspect(); // opens a window to browse data members; obj->DrawClass(); // Draws the class inheritance tree; ```. For an example of `obj->Inspect()`, see ""Inspecting Objects"". ### Collections. To store an object in a ROOT collection, it must be a descendent of; **`TObject`**. This is convenient if you want to store objects of; different classes in the same collection and execute the method of the; same name on all members of the collection. For example, the list of; graphics primitives are in a ROOT collection called **`TList`**. When; the canvas is drawn, the `Paint` method is executed on the entire; collection. Each member may be a different class, and if the `Paint`; method is not implemented, **`TObject::Paint`** will be executed. ### Input/Output. The `TObject::Write` method is the interface to the ROOT I/O system. It; streams the object into a buffer using the `Streamer` method. It; supports cycle numbers and automatic schema evolution. See; ""Input/Output"". ### Paint/Draw. These graphics methods are defaults; their implementation in; **`TObject`** does not use the graphics subsystem. The `TObject::Draw`; method is simply a call to `AppendPad`. The `Paint` method is empty. The; default is provided so that one can call `Paint` in a collection. The; method `GetDrawOption` returns the draw option that was used when the; object was drawn on the canvas. This is especially relevant with; histograms and graphs. ### Clone/DrawClone. Two useful methods are `Clone` and `DrawClone`. The `Clone` method takes; a snapshot of the object with the `Streamer` and creates a new object.; The `DrawClone` method does the same thing and in addition draws the; clone. ### Browse. This method is called if the object is browse-able and is to be; displayed in the object browser. For exampl",MatchSource.DOCS,documentation/users-guide/AddingaClass.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md:6650,Integrability,depend,depending,6650,"cpp}; enum EObjBits {; kCanDelete = BIT(0), // if can be deleted; kMustCleanup = BIT(3), // if destructor must call RecursiveRemove(); kObjInCanvas = BIT(3), // for backward compatibility only; kIsReferenced = BIT(4), // if referenced by TRef or TRefArray; kHasUUID = BIT(5), // if has a TUUID, fUniqueID=UUIDNumber; kCannotPick = BIT(6), // if cannot be picked in a pad; kNoContextMenu = BIT(8), // if does not want a context menu; kInvalidObject = BIT(13) // object ctor succeeded but the object should not be used; };; ```. For example, the bits `kMustCleanup` and `kCanDelete` are used in; **`TObject`**. See ""The kCanDelete Bit"" and ""The kMustCleanup Bit"". They; can be set by any object and should not be reused. Make sure not; to overlap them in any given hierarchy. The bit 13 (`kInvalidObject`) is; set when an object could not be read from a ROOT file. It will check; this bit and will skip to the next object on the file. The **`TObject`** constructor initializes the `fBits` to zero depending; if the object is created on the stack or allocated on the heap. When the; object is created on the stack, the `kCanDelete` bit is set to false to; protect from deleting objects on the stack. The high 8 bits are reserved; for the system usage; the low 24 bits are user settable. `fUniqueID` is; a data member used to give a unique identification number to an object.; It is initialized to zero by the **`TObject`** constructor. ROOT does; not use this data member. The two data members (`fBits` and `fUniqueID`); are streamed out when writing an object to disk. If you do not use them,; you can save some space and time by specifying:. ``` {.cpp}; MyClass::Class()->IgnoreTObjectStreamer();; ```. This sets a bit in the **`TClass`** object. If the file is compressed,; the savings are minimal since most values are zero; however, it saves; some space when the file is not compressed. A call; to` IgnoreTObjectStreamer` also prevents the creation of two additional; branches when splitting the obj",MatchSource.DOCS,documentation/users-guide/AddingaClass.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md:7764,Integrability,integrat,integrate,7764,"8 bits are reserved; for the system usage; the low 24 bits are user settable. `fUniqueID` is; a data member used to give a unique identification number to an object.; It is initialized to zero by the **`TObject`** constructor. ROOT does; not use this data member. The two data members (`fBits` and `fUniqueID`); are streamed out when writing an object to disk. If you do not use them,; you can save some space and time by specifying:. ``` {.cpp}; MyClass::Class()->IgnoreTObjectStreamer();; ```. This sets a bit in the **`TClass`** object. If the file is compressed,; the savings are minimal since most values are zero; however, it saves; some space when the file is not compressed. A call; to` IgnoreTObjectStreamer` also prevents the creation of two additional; branches when splitting the object. If left alone, two branches called; `fBits` and `fUniqueID` will appear. ## Motivation. If you want to integrate and use your classes with ROOT, to enjoy; features like, extensive RTTI (Run Time Type Information) and ROOT; object I/O and inspection, you have to add the following line to your; class header files:. ``` {.cpp}; ClassDef(ClassName,ClassVersionID); //The class title; ```. For example in `TLine.h` we have:. ``` {.cpp}; ClassDef(TLine,1); //A line segment; ```. The **`ClassVersionID`** is used by the ROOT I/O system. It is written; on the output stream and during reading you can check this version ID; and take appropriate action depending on the value of the ID. See; ""Streamers"". Every time you change the data members of a class, you; should increase its `ClassVersionID` by one. The `ClassVersionID` should; be `>=1`. Set `ClassVersionID=0` in case you don't need object I/O. To; be able to generate properly documentation for your classes using; **`THtml`** you must add the statement:. ``` {.cpp}; ClassImp(ClassName); ```. For example in `TLine.cxx`:. ``` {.cpp}; ClassImp(TLine); ```. Note that you should provide a default constructor for your classes,; i.e. a constructor wi",MatchSource.DOCS,documentation/users-guide/AddingaClass.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md:8308,Integrability,depend,depending,8308,"ace and time by specifying:. ``` {.cpp}; MyClass::Class()->IgnoreTObjectStreamer();; ```. This sets a bit in the **`TClass`** object. If the file is compressed,; the savings are minimal since most values are zero; however, it saves; some space when the file is not compressed. A call; to` IgnoreTObjectStreamer` also prevents the creation of two additional; branches when splitting the object. If left alone, two branches called; `fBits` and `fUniqueID` will appear. ## Motivation. If you want to integrate and use your classes with ROOT, to enjoy; features like, extensive RTTI (Run Time Type Information) and ROOT; object I/O and inspection, you have to add the following line to your; class header files:. ``` {.cpp}; ClassDef(ClassName,ClassVersionID); //The class title; ```. For example in `TLine.h` we have:. ``` {.cpp}; ClassDef(TLine,1); //A line segment; ```. The **`ClassVersionID`** is used by the ROOT I/O system. It is written; on the output stream and during reading you can check this version ID; and take appropriate action depending on the value of the ID. See; ""Streamers"". Every time you change the data members of a class, you; should increase its `ClassVersionID` by one. The `ClassVersionID` should; be `>=1`. Set `ClassVersionID=0` in case you don't need object I/O. To; be able to generate properly documentation for your classes using; **`THtml`** you must add the statement:. ``` {.cpp}; ClassImp(ClassName); ```. For example in `TLine.cxx`:. ``` {.cpp}; ClassImp(TLine); ```. Note that you should provide a default constructor for your classes,; i.e. a constructor with zero parameters or with one or more parameters; all with default values in case you want to use object I/O. If do not; provide such a default constructor, you MUST implement an I/O; constructor. If not you will get a compile time error. See the ""The; Default Constructor"" paragraph in this chapter. The `ClassDef` and; `ClassImp` macros are defined in the file `Rtypes.h`. This file is; referenced by a",MatchSource.DOCS,documentation/users-guide/AddingaClass.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md:32346,Integrability,interface,interface,32346,"ll globals;. #pragma link off all typedef;; #pragma link C++ defined_in file1.h;; #endif; ```. The next pragma statements turn on or off the dictionary generation of; the object defined in a specific scope. The [`scope_name`] should be; `class` name, `struct` name or `namespace` name. When using these; pragmas, it is recommended to use also:. ``` {.cpp}; #pragma link C++ nestedclass; ```. Otherwise, definitions in enclosed scope do not appear in the; dictionary. ``` {.cpp}; #pragma link [C|C++|off] defined_in [scope_name];; #pragma link [C|C++|off] defined_in; [class|struct|namespace] [scope_name];; ```. Example:. ``` {.cpp}; namespace ns {; int a;; double b;; };; ```. The pragma statements are:. ``` {.cpp}; #ifdef __ROOTCLING__; #pragma link C++ defined_in ns;; #pragma link C++ nestedclass;; #endif; ```. This statements controls default link mode for `rootcling`. ``` {.cpp}; #pragma link default [on|off]; ```. By turning default 'on', all language constructs in given header files; will be included in generated Cling dictionary (interface method source; file). If default is set to 'off', nothing will be included in the; generated dictionary. The next statement explicitly set linkage to each; item:. ``` {.cpp}; #pragma link [C|C++|off] [class|function|global]; ```. This pragma statement must be given before `rootcling` reads any; C/C++ definitions from header files. Example:. ``` {.cpp}; #ifdef __ROOTCLING__; #pragma link default off;; #endif. class A {; int a;; double b;; };. class B {; int d;; double e;; };. #ifdef __ROOTCLING__; #pragma link C++ class A; // only class A is linked, not B; #endif; ```. ##### Compilation. **Step 4:** Compile the class using the `Makefile. `In the `Makefile`; call `rootcling` to make the dictionary for the class. Call it; `SClassDict.cxx`. The `rootcling` utility generates the methods; `Streamer`, **`TBuffer`** &operator\>\>() and `ShowMembers `for ROOT; classes. ``` {.cpp}; gmake -f Makefile; ```. Load the shared library:. ``` {.cpp}",MatchSource.DOCS,documentation/users-guide/AddingaClass.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md:34051,Integrability,wrap,wrapper,34051,"ass. Call it; `SClassDict.cxx`. The `rootcling` utility generates the methods; `Streamer`, **`TBuffer`** &operator\>\>() and `ShowMembers `for ROOT; classes. ``` {.cpp}; gmake -f Makefile; ```. Load the shared library:. ``` {.cpp}; root[] .L SClass.so; root[] SClass *sc = new SClass(); root[] TFile *f = new TFile(""Afile.root"",""UPDATE"");; root[] sc->Write();; ```. For more information on `rootcling` see the `$ROOTSYS/test` directory; `Makefile`, `Event.cxx`, and `Event.h` for an example, or follow this; link: <http://root.cern.ch/root/RootCintMan.html>. ## genreflex: A Comfortable Interface to rootcling. Version 5 supported both `Cint` and `Reflex` dictionaries. The tool to create; `Reflex` dictionaries was a Python script called `genreflex` and was very; successful in the user community.; Even if version 6 has only one type of dictionaries, `cling` dictionaries,; a re-implementation of `genreflex` is provided.; More precisely, in ROOT6, `genreflex` is nothing but a wrapper around; `rootcling`, which offers an identical CLI and behaviour to the old Python; tool.; The input to `genreflex` is a C++ header file, a set of switches and a; *selection XML file*. The output, as for `rootcling`, is a C++ dictionary; source and a `pcm` files.; An exhaustive documentation of the CLI switches of `genreflex` can be; inspected with the `genreflex --help` command. The entity corresponding to the `LinkDef` file for `genreflex` is the; *selection XML file*, also called *selection XML* or simply *selection file*.; A *selection XML file* allows to describe a list of classes for which; the dictionaries are to be created. In addition, it allows to specify; properties of classes or data members, without the need to add comments in; the source code. This is of primary importance when dictionaries must be; created for classes residing in code which cannot be modified.; For a complete description of the structure of the *selection XML files*; and the way in which attributes can be set, refer",MatchSource.DOCS,documentation/users-guide/AddingaClass.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md:1180,Modifiability,inherit,inherits,1180,"s the; primary interface to classes providing object I/O, error handling,; inspection, introspection, and drawing. The interface to this service is; via abstract classes. ### Introspection, Reflection and Run Time Type Identification. Introspection, which is also referred to as reflection, or run time type; identification (RTTI) is the ability of a class to reflect upon itself; or to ""look inside itself. ROOT implements reflection with the; **`TClass`** class. It provides all the information about a class, a; full description of data members and methods, including the comment; field and the method parameter types. A class with the `ClassDef` macro; has the ability to obtain a **`TClass`** with the `IsA` method. ``` {.cpp}; TClass *cl = obj->IsA();; ```. It returns a **`TClass`**. In addition, an object can directly get the; class name and the base classes by:. ``` {.cpp}; const char* name = obj->ClassName();; ```. If the class is a descendent of **`TObject`**, you can check if an; object inherits from a specific class, you can use the `InheritsFrom`; method. This method returns `kTrue` if the object inherits from the; specified class name or **`TClass`**. ``` {.cpp}; Bool_t b = obj->InheritsFrom(""TLine"");; Bool_t b = obj->InheritsFrom(TLine::Class());; ```. ROOT and `Cling` rely on reflection and the class dictionary to identify; the type of a variable at run time. With **`TObject`** inheritance come; some methods that use Introspection to help you see the data in the; object or class. For instance:. ``` {.cpp}; obj->Dump(); // lists all data members and their current values; obj->Inspect(); // opens a window to browse data members; obj->DrawClass(); // Draws the class inheritance tree; ```. For an example of `obj->Inspect()`, see ""Inspecting Objects"". ### Collections. To store an object in a ROOT collection, it must be a descendent of; **`TObject`**. This is convenient if you want to store objects of; different classes in the same collection and execute the method o",MatchSource.DOCS,documentation/users-guide/AddingaClass.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md:1294,Modifiability,inherit,inherits,1294,"rface to this service is; via abstract classes. ### Introspection, Reflection and Run Time Type Identification. Introspection, which is also referred to as reflection, or run time type; identification (RTTI) is the ability of a class to reflect upon itself; or to ""look inside itself. ROOT implements reflection with the; **`TClass`** class. It provides all the information about a class, a; full description of data members and methods, including the comment; field and the method parameter types. A class with the `ClassDef` macro; has the ability to obtain a **`TClass`** with the `IsA` method. ``` {.cpp}; TClass *cl = obj->IsA();; ```. It returns a **`TClass`**. In addition, an object can directly get the; class name and the base classes by:. ``` {.cpp}; const char* name = obj->ClassName();; ```. If the class is a descendent of **`TObject`**, you can check if an; object inherits from a specific class, you can use the `InheritsFrom`; method. This method returns `kTrue` if the object inherits from the; specified class name or **`TClass`**. ``` {.cpp}; Bool_t b = obj->InheritsFrom(""TLine"");; Bool_t b = obj->InheritsFrom(TLine::Class());; ```. ROOT and `Cling` rely on reflection and the class dictionary to identify; the type of a variable at run time. With **`TObject`** inheritance come; some methods that use Introspection to help you see the data in the; object or class. For instance:. ``` {.cpp}; obj->Dump(); // lists all data members and their current values; obj->Inspect(); // opens a window to browse data members; obj->DrawClass(); // Draws the class inheritance tree; ```. For an example of `obj->Inspect()`, see ""Inspecting Objects"". ### Collections. To store an object in a ROOT collection, it must be a descendent of; **`TObject`**. This is convenient if you want to store objects of; different classes in the same collection and execute the method of the; same name on all members of the collection. For example, the list of; graphics primitives are in a ROOT collection c",MatchSource.DOCS,documentation/users-guide/AddingaClass.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md:1543,Modifiability,variab,variable,1543,"s the ability of a class to reflect upon itself; or to ""look inside itself. ROOT implements reflection with the; **`TClass`** class. It provides all the information about a class, a; full description of data members and methods, including the comment; field and the method parameter types. A class with the `ClassDef` macro; has the ability to obtain a **`TClass`** with the `IsA` method. ``` {.cpp}; TClass *cl = obj->IsA();; ```. It returns a **`TClass`**. In addition, an object can directly get the; class name and the base classes by:. ``` {.cpp}; const char* name = obj->ClassName();; ```. If the class is a descendent of **`TObject`**, you can check if an; object inherits from a specific class, you can use the `InheritsFrom`; method. This method returns `kTrue` if the object inherits from the; specified class name or **`TClass`**. ``` {.cpp}; Bool_t b = obj->InheritsFrom(""TLine"");; Bool_t b = obj->InheritsFrom(TLine::Class());; ```. ROOT and `Cling` rely on reflection and the class dictionary to identify; the type of a variable at run time. With **`TObject`** inheritance come; some methods that use Introspection to help you see the data in the; object or class. For instance:. ``` {.cpp}; obj->Dump(); // lists all data members and their current values; obj->Inspect(); // opens a window to browse data members; obj->DrawClass(); // Draws the class inheritance tree; ```. For an example of `obj->Inspect()`, see ""Inspecting Objects"". ### Collections. To store an object in a ROOT collection, it must be a descendent of; **`TObject`**. This is convenient if you want to store objects of; different classes in the same collection and execute the method of the; same name on all members of the collection. For example, the list of; graphics primitives are in a ROOT collection called **`TList`**. When; the canvas is drawn, the `Paint` method is executed on the entire; collection. Each member may be a different class, and if the `Paint`; method is not implemented, **`TObject::Paint`*",MatchSource.DOCS,documentation/users-guide/AddingaClass.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md:1584,Modifiability,inherit,inheritance,1584,"TClass`** class. It provides all the information about a class, a; full description of data members and methods, including the comment; field and the method parameter types. A class with the `ClassDef` macro; has the ability to obtain a **`TClass`** with the `IsA` method. ``` {.cpp}; TClass *cl = obj->IsA();; ```. It returns a **`TClass`**. In addition, an object can directly get the; class name and the base classes by:. ``` {.cpp}; const char* name = obj->ClassName();; ```. If the class is a descendent of **`TObject`**, you can check if an; object inherits from a specific class, you can use the `InheritsFrom`; method. This method returns `kTrue` if the object inherits from the; specified class name or **`TClass`**. ``` {.cpp}; Bool_t b = obj->InheritsFrom(""TLine"");; Bool_t b = obj->InheritsFrom(TLine::Class());; ```. ROOT and `Cling` rely on reflection and the class dictionary to identify; the type of a variable at run time. With **`TObject`** inheritance come; some methods that use Introspection to help you see the data in the; object or class. For instance:. ``` {.cpp}; obj->Dump(); // lists all data members and their current values; obj->Inspect(); // opens a window to browse data members; obj->DrawClass(); // Draws the class inheritance tree; ```. For an example of `obj->Inspect()`, see ""Inspecting Objects"". ### Collections. To store an object in a ROOT collection, it must be a descendent of; **`TObject`**. This is convenient if you want to store objects of; different classes in the same collection and execute the method of the; same name on all members of the collection. For example, the list of; graphics primitives are in a ROOT collection called **`TList`**. When; the canvas is drawn, the `Paint` method is executed on the entire; collection. Each member may be a different class, and if the `Paint`; method is not implemented, **`TObject::Paint`** will be executed. ### Input/Output. The `TObject::Write` method is the interface to the ROOT I/O system. It; stream",MatchSource.DOCS,documentation/users-guide/AddingaClass.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md:1875,Modifiability,inherit,inheritance,1875,"ass with the `ClassDef` macro; has the ability to obtain a **`TClass`** with the `IsA` method. ``` {.cpp}; TClass *cl = obj->IsA();; ```. It returns a **`TClass`**. In addition, an object can directly get the; class name and the base classes by:. ``` {.cpp}; const char* name = obj->ClassName();; ```. If the class is a descendent of **`TObject`**, you can check if an; object inherits from a specific class, you can use the `InheritsFrom`; method. This method returns `kTrue` if the object inherits from the; specified class name or **`TClass`**. ``` {.cpp}; Bool_t b = obj->InheritsFrom(""TLine"");; Bool_t b = obj->InheritsFrom(TLine::Class());; ```. ROOT and `Cling` rely on reflection and the class dictionary to identify; the type of a variable at run time. With **`TObject`** inheritance come; some methods that use Introspection to help you see the data in the; object or class. For instance:. ``` {.cpp}; obj->Dump(); // lists all data members and their current values; obj->Inspect(); // opens a window to browse data members; obj->DrawClass(); // Draws the class inheritance tree; ```. For an example of `obj->Inspect()`, see ""Inspecting Objects"". ### Collections. To store an object in a ROOT collection, it must be a descendent of; **`TObject`**. This is convenient if you want to store objects of; different classes in the same collection and execute the method of the; same name on all members of the collection. For example, the list of; graphics primitives are in a ROOT collection called **`TList`**. When; the canvas is drawn, the `Paint` method is executed on the entire; collection. Each member may be a different class, and if the `Paint`; method is not implemented, **`TObject::Paint`** will be executed. ### Input/Output. The `TObject::Write` method is the interface to the ROOT I/O system. It; streams the object into a buffer using the `Streamer` method. It; supports cycle numbers and automatic schema evolution. See; ""Input/Output"". ### Paint/Draw. These graphics methods ar",MatchSource.DOCS,documentation/users-guide/AddingaClass.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md:5036,Modifiability,inherit,inheriting,5036,"save a; primitive as a C++ statement(s). Most ROOT classes implement the; `SavePrimitive` method. It is recommended that the `SavePrimitive` is; implemented in user defined classes if it is to be drawn on a canvas.; Such that the command `TCanvas::SaveAs(Canvas.C)` will preserve the; user-class object in the resulting script. ### GetObjectInfo. This method is called when displaying the event status in a canvas. To; show the event status window, select the `Options` menu and the; `EventStatus` item. This method returns a string of information about; the object at position (x, y). Every time the cursor moves, the object; under the cursor executes the `GetObjectInfo` method. The string is then; shown in the status bar. There is a default implementation in; **`TObject`**, but it is typically overridden for classes that can; report peculiarities for different cursor positions (for example the bin; contents in a TH1). ### IsFolder. By default an object inheriting from **`TObject`** is not brows-able,; because **`TObject::IsFolder()`** returns `kFALSE`. To make a class; browse-able, the `IsFolder` method needs to be overridden to return; `kTRUE`. In general, this method returns `kTRUE` if the object contains; browse-able objects (like containers or lists of other objects). ### Bit Masks and Unique ID. A **`TObject`** descendent inherits two data members: `fBits` and; `fUniqueID`. `fBits `is 32-bit data member used with a bit mask to get; object information. Bits 0 - 13 are reserved as global bits, bits 14 -; 23 can be used in different class hierarchies. ``` {.cpp}; enum EObjBits {; kCanDelete = BIT(0), // if can be deleted; kMustCleanup = BIT(3), // if destructor must call RecursiveRemove(); kObjInCanvas = BIT(3), // for backward compatibility only; kIsReferenced = BIT(4), // if referenced by TRef or TRefArray; kHasUUID = BIT(5), // if has a TUUID, fUniqueID=UUIDNumber; kCannotPick = BIT(6), // if cannot be picked in a pad; kNoContextMenu = BIT(8), // if does not want a co",MatchSource.DOCS,documentation/users-guide/AddingaClass.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md:5418,Modifiability,inherit,inherits,5418,"hod is called when displaying the event status in a canvas. To; show the event status window, select the `Options` menu and the; `EventStatus` item. This method returns a string of information about; the object at position (x, y). Every time the cursor moves, the object; under the cursor executes the `GetObjectInfo` method. The string is then; shown in the status bar. There is a default implementation in; **`TObject`**, but it is typically overridden for classes that can; report peculiarities for different cursor positions (for example the bin; contents in a TH1). ### IsFolder. By default an object inheriting from **`TObject`** is not brows-able,; because **`TObject::IsFolder()`** returns `kFALSE`. To make a class; browse-able, the `IsFolder` method needs to be overridden to return; `kTRUE`. In general, this method returns `kTRUE` if the object contains; browse-able objects (like containers or lists of other objects). ### Bit Masks and Unique ID. A **`TObject`** descendent inherits two data members: `fBits` and; `fUniqueID`. `fBits `is 32-bit data member used with a bit mask to get; object information. Bits 0 - 13 are reserved as global bits, bits 14 -; 23 can be used in different class hierarchies. ``` {.cpp}; enum EObjBits {; kCanDelete = BIT(0), // if can be deleted; kMustCleanup = BIT(3), // if destructor must call RecursiveRemove(); kObjInCanvas = BIT(3), // for backward compatibility only; kIsReferenced = BIT(4), // if referenced by TRef or TRefArray; kHasUUID = BIT(5), // if has a TUUID, fUniqueID=UUIDNumber; kCannotPick = BIT(6), // if cannot be picked in a pad; kNoContextMenu = BIT(8), // if does not want a context menu; kInvalidObject = BIT(13) // object ctor succeeded but the object should not be used; };; ```. For example, the bits `kMustCleanup` and `kCanDelete` are used in; **`TObject`**. See ""The kCanDelete Bit"" and ""The kMustCleanup Bit"". They; can be set by any object and should not be reused. Make sure not; to overlap them in any given hierarchy. T",MatchSource.DOCS,documentation/users-guide/AddingaClass.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md:21756,Modifiability,inherit,inheriting,21756,"well as the; `>>` operator overloads, are implemented only if you use `ClassDef` and; `ClassImp`. See `$ROOTSYS/include/Rtypes.h` for the definition of; `ClassDef` and `ClassImp`. To exclude a data member from the `Streamer`,; add a `!` as the first character in the comments of the field:. ``` {.cpp}; Int_t fTempValue; //! temporary state value; ```. ### The LinkDef.h File. **Step 3:** The `LinkDef.h` file tells `rootcling` which classes should; be added to the dictionary. ``` {.cpp}; #ifdef __CLING__; #pragma link C++ class SClass;; #endif; ```. Three options can trail the class name:. - `-` : tells `rootcling` **not** to generate the `Streamer` method for; this class. This is necessary for those classes that need a; customized `Streamer` method. ``` {.cpp}; #pragma link C++ class SClass-; // no streamer; ```. - **`!`** : tells `rootcling` **not** to generate the; `operator>>(`**`TBuffer`** `&b,MyClass *&obj)` method for this; class. This is necessary to be able to write pointers to objects of; classes not inheriting from **`TObject`**. ``` {.cpp}; #pragma link C++ class SClass!; // no >> operator; // or; #pragma link C++ class SClass-!; // no streamer, no >> operator; ```. - **+** : in ROOT version 1 and 2 tells `rootcling` to generate a; `Streamer` with extra byte count information. This adds an integer; to each object in the output buffer, but it allows for powerful; error correction in case a `Streamer` method is out of sync with; data in the file. The `+` option is mutual exclusive with both the; `-` and `!` options. IMPORTANT NOTE: In ROOT Version 3 and later, a ""+"" after the class name; tells `rootcling` to use the new I/O system. The byte count check is; always added. The new I/O system has many advantages including support; automatic schema evolution, full support for STL collections and better; run-time performance. We strongly recommend using it. ``` {.cpp}; #pragma link C++ class SClass+; // add byte count; ```. For information on `Streamers` see ""Input/",MatchSource.DOCS,documentation/users-guide/AddingaClass.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md:25408,Modifiability,variab,variables,25408,"name];; #pragma link [C|C++|off] [global|typedef][name];; #pragma link [C|C++|off] [nestedclass|nestedtypedef];. #pragma link [C++|C|off|MACRO] function [name]<(argtypes)>;; #pragma link; [C++|C|off|MACRO] function [classname]::[name]<(argtypes)>;; #pragma link off all methods;; #pragma link [C|C++|off] defined_in [filename];; #pragma link; [C|C++|off] defined_in [class|struct|namespace] [name];; #pragma link [C|C++|off] all_function [classname];; #pragma link [C|C++|off] all_datamember [classname];; ```. The `[classname]` and the `[name]` can also contain wildcards. For; example:. ``` {.cpp}; #pragma link C++ class MyClass*;; ```. This will request the dictionary for all the class whose name start with; `'MyClass'` and are already known to Cling (class templates need to have; already been instantiated to be considered). ``` {.cpp}; #pragma link [C|C++|off] all [class|function|global|typedef];; ```. This pragma statement turns on or off the dictionary generation for all; classes, structures, namespaces, global variables, global functions and; typedefs seen so far by Cling. Example:. ``` {.cpp}; // some C++ header definition; #ifdef __ROOTCLING__; // turns off dictionary generation for all; #pragma link off all class;; #pragma link off all function;; #pragma link off all global;; #pragma link off all typedef;; #endif; ```. The next pragma statement selectively turns on or off the dictionary; generation for the specified `classs`, `struct`, `union`, `enum` or; `namespace`:. ``` {.cpp}; #pragma link; [C|C++|off][class|class+protected|; struct|union|enum|namespace][name];; ```. The Dictionary of all public members of class and struct will be; generated. If the '`class+protected`' flag is used, the dictionary for; protected members will also be generated. However, dictionary for; protected constructor and destructor will not be generated. This '; `class+protected` ' flag will help you only for plain protected member; access, but not for virtual function resolution. If you",MatchSource.DOCS,documentation/users-guide/AddingaClass.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md:27036,Modifiability,variab,variables,27036," all public members of class and struct will be; generated. If the '`class+protected`' flag is used, the dictionary for; protected members will also be generated. However, dictionary for; protected constructor and destructor will not be generated. This '; `class+protected` ' flag will help you only for plain protected member; access, but not for virtual function resolution. If you use the '`namespace`' flag, it is recommended to add also:. ``` {.cpp}; #pragma link C++ nestedclass;; #pragma link C++ nestedtypedef;; ```. The behavior of '`class`', '`struct`' and '`namespace`' flag are; identical. Example:. ``` {.cpp}; // some C++ header definition; #ifdef __ROOTCLING__; #pragma link off all class;; #pragma link C++ class A;; #pragma link C++ class B;; #pragma link C++ class C<int>;; #pragma link C++ class+protected D;; #pragma link C++ namespace project1;; #pragma link C++ nestedclass;; #pragma link C++ nestedtypedef;; #endif; ```. The next pragma statement selectively turns on or off the dictionary; generation for global variables and typedef. ``` {.cpp}; #pragma link [C|C++|off] [global|typedef] [name];; ```. Example:. ``` {.cpp}; // some C/C++ header definition; #ifdef __ROOTCLING__; #pragma link off all global;; #pragma link off all typedef;; #pragma link C++ global a;; #pragma link C++ typedef Int_t;; #endif; ```. This pragma statement turns on the dictionary generation for nested; classes and nested typedefs. ``` {.cpp}; #pragma link [C|C++|off] [nestedclass|nestedtypedef];; ```. Example:. ``` {.cpp}; // some C/C++ header definition; #ifdef __ROOTCLING__; #pragma link off all global;; #pragma link off all typedef;; #pragma link C++ global a;; #pragma link C++ typedef Int_t;; #endif; ```. The next pragma statements turn on or off the dictionary generation for; the specified function(s) or member function(s). The list of arguments'; type is optional. If you omit argument types, all function with; specified [`name`] will be affected. If the list of arguments' type i",MatchSource.DOCS,documentation/users-guide/AddingaClass.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md:36028,Modifiability,inherit,inherit,36028,"h; the dictionaries are to be created. In addition, it allows to specify; properties of classes or data members, without the need to add comments in; the source code. This is of primary importance when dictionaries must be; created for classes residing in code which cannot be modified.; For a complete description of the structure of the *selection XML files*; and the way in which attributes can be set, refer to the `genreflex --help`; command. It is important to observe that *selection XML files* can be used in presence; of `rootcling` invocations instead of `LinkDef` files. ### The `ROOT::Meta::Selection` namespace. Not only `LinkDef` and `selection` files allow to select the classes for which; the dictionaries must be created: a third method is available. This is; represented by the `ROOT::Meta::Selection` namespace. The idea behind this; technique is that all the classes which are located in this special namespace; are automatically selected for dictionary generation. All the properties and; annotations allowed by `LinkDef` and `selection XML` files are possible.; For a detailed documentation of the features of the `ROOT::Meta::Selection`; namespace, refer to its online documentation. ## Adding a Class with ACLiC. \index{adding a class!ACLiC}; **Step 1:** Define your class. ``` {.cpp}; #include ""TObject.h"". // define the ABC class and make it inherit from TObject so that; // we can write ABC to a ROOT file; class ABC : public TObject {. public:; Float_t a, b, c, p;; ABC() : a(0), b(0), c(0), p(0){};. // Define the class for the dictionary; ClassDef (ABC,1); };. // Call the ClassImp macro to give the ABC class RTTI and; // full I/O capabilities. #if !defined(__CLING__); ClassImp(ABC);; #endif; ```. **Step 2:** Load the ABC class in the script. ``` {.cpp}; // Check if ABC is already loaded; if (!TClass::GetDict(""ABC"")) {; gROOT->ProcessLine("".L ABCClass.C++"");; }. // Use the Class; ABC *v = new ABC;; v->p = (sqrt((v->a * v->a)+ (v->b * v->b)+(v->c * v->c)));; ```; ",MatchSource.DOCS,documentation/users-guide/AddingaClass.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md:13947,Performance,load,loaded,13947,"or example with:. ``` {.cpp}; #pragma link C++ ioctortype UserClass1;; #pragma link C++ ioctortype UserClass2;; ```. We look for the first existing public constructor in the following; order:. ``` {.cpp}; MyClass(UserClass1*);; MyClass(UserClass2*);; MyClass(TRootIOCtor*);; MyClass(); // Or a constructor with all its arguments defaulted.; ```. ## rootcling: The Cling Dictionary Generator. A way in which dictionaries can be generated is via the `rootcling`; utility. This tool generates takes as input a set of headers and; generates in output the dictionary C++ code and a `pcm` file.; This latter file is fundamental for the correct functioning of the; dictionary at runtime. It should be located in the directory where; the shared library is installed in which the compiled dictionary; resides. NOTA BENE: the dictionaries that will be used within the same project; must have unique names. In other words, compiled object files relative; to dictionary source files cannot reside in the same library or in; two libraries loaded by the same application if the original source; files have the same name.; This loose limitation is imposed by the registration mechanism ROOT; has in place to keep track of dynamically loaded libraries. In the following example, we walk through the steps necessary to; generate a dictionary, I/O, and inspect member functions. Let's start; with a **`TEvent`** class, which contains a collection of **`TTracks`**. The `TEvent.h` header is:. ``` {.cpp}; #ifndef __TEvent__; #define __TEvent__; #include ""TObject.h""; #include ""TCollection.h"". class TTrack;. class TEvent : public TObject {; private:; Int_t fId; // event sequential id; Float_t fTotalMom; // total momentum; TCollection *fTracks; // collection of tracks; public:; TEvent() { fId = 0; fTotalMom = 0; fTracks = nullptr; }; TEvent(Int_t id);; ~TEvent();; void AddTrack(TTrack *t);; Int_t GetId() const { return fId; }; Int_t GetNoTracks() const;; void Print(Option_t *opt="""");; Float_t TotalMomentum();. Cla",MatchSource.DOCS,documentation/users-guide/AddingaClass.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md:14140,Performance,load,loaded,14140,"he following; order:. ``` {.cpp}; MyClass(UserClass1*);; MyClass(UserClass2*);; MyClass(TRootIOCtor*);; MyClass(); // Or a constructor with all its arguments defaulted.; ```. ## rootcling: The Cling Dictionary Generator. A way in which dictionaries can be generated is via the `rootcling`; utility. This tool generates takes as input a set of headers and; generates in output the dictionary C++ code and a `pcm` file.; This latter file is fundamental for the correct functioning of the; dictionary at runtime. It should be located in the directory where; the shared library is installed in which the compiled dictionary; resides. NOTA BENE: the dictionaries that will be used within the same project; must have unique names. In other words, compiled object files relative; to dictionary source files cannot reside in the same library or in; two libraries loaded by the same application if the original source; files have the same name.; This loose limitation is imposed by the registration mechanism ROOT; has in place to keep track of dynamically loaded libraries. In the following example, we walk through the steps necessary to; generate a dictionary, I/O, and inspect member functions. Let's start; with a **`TEvent`** class, which contains a collection of **`TTracks`**. The `TEvent.h` header is:. ``` {.cpp}; #ifndef __TEvent__; #define __TEvent__; #include ""TObject.h""; #include ""TCollection.h"". class TTrack;. class TEvent : public TObject {; private:; Int_t fId; // event sequential id; Float_t fTotalMom; // total momentum; TCollection *fTracks; // collection of tracks; public:; TEvent() { fId = 0; fTotalMom = 0; fTracks = nullptr; }; TEvent(Int_t id);; ~TEvent();; void AddTrack(TTrack *t);; Int_t GetId() const { return fId; }; Int_t GetNoTracks() const;; void Print(Option_t *opt="""");; Float_t TotalMomentum();. ClassDef(TEvent,1); //Simple event class; };. #endif; ```. The things to notice in these header files are:. - The usage of the `ClassDef` macro. - The default constructors o",MatchSource.DOCS,documentation/users-guide/AddingaClass.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md:22579,Performance,perform,performance,22579,"k C++ class SClass-; // no streamer; ```. - **`!`** : tells `rootcling` **not** to generate the; `operator>>(`**`TBuffer`** `&b,MyClass *&obj)` method for this; class. This is necessary to be able to write pointers to objects of; classes not inheriting from **`TObject`**. ``` {.cpp}; #pragma link C++ class SClass!; // no >> operator; // or; #pragma link C++ class SClass-!; // no streamer, no >> operator; ```. - **+** : in ROOT version 1 and 2 tells `rootcling` to generate a; `Streamer` with extra byte count information. This adds an integer; to each object in the output buffer, but it allows for powerful; error correction in case a `Streamer` method is out of sync with; data in the file. The `+` option is mutual exclusive with both the; `-` and `!` options. IMPORTANT NOTE: In ROOT Version 3 and later, a ""+"" after the class name; tells `rootcling` to use the new I/O system. The byte count check is; always added. The new I/O system has many advantages including support; automatic schema evolution, full support for STL collections and better; run-time performance. We strongly recommend using it. ``` {.cpp}; #pragma link C++ class SClass+; // add byte count; ```. For information on `Streamers` see ""Input/Output"". To get help on; `rootcling` type on the UNIX command line: **`rootcling -h`**. #### The Order Matters. When using template classes, the order of the pragma statements matters.; For example, here is a template class `Tmpl` and a normal class `Norm`,; which holds a specialized instance of a `Tmpl`:. ``` {.cpp}; class Norm {; private:; Tmpl<int>* fIntTmpl;; public:; ...; };; ```. Then in `Linkdef.h,` the pragma statements must be ordered by listing; all specializations before any classes that need them:. ``` {.cpp}; // Correct Linkdef.h ordering; ...; #pragma link C++ class Tmpl<int>;; #pragma link C++ class Norm;; ...; ```. And not vice versa:. ``` {.cpp}; // Bad Linkdef.h ordering; ...; #pragma link C++ class Norm;; #pragma link C++ class Tmpl<int>;; ...; ```. In",MatchSource.DOCS,documentation/users-guide/AddingaClass.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md:36475,Performance,load,loaded,36475,"h; the dictionaries are to be created. In addition, it allows to specify; properties of classes or data members, without the need to add comments in; the source code. This is of primary importance when dictionaries must be; created for classes residing in code which cannot be modified.; For a complete description of the structure of the *selection XML files*; and the way in which attributes can be set, refer to the `genreflex --help`; command. It is important to observe that *selection XML files* can be used in presence; of `rootcling` invocations instead of `LinkDef` files. ### The `ROOT::Meta::Selection` namespace. Not only `LinkDef` and `selection` files allow to select the classes for which; the dictionaries must be created: a third method is available. This is; represented by the `ROOT::Meta::Selection` namespace. The idea behind this; technique is that all the classes which are located in this special namespace; are automatically selected for dictionary generation. All the properties and; annotations allowed by `LinkDef` and `selection XML` files are possible.; For a detailed documentation of the features of the `ROOT::Meta::Selection`; namespace, refer to its online documentation. ## Adding a Class with ACLiC. \index{adding a class!ACLiC}; **Step 1:** Define your class. ``` {.cpp}; #include ""TObject.h"". // define the ABC class and make it inherit from TObject so that; // we can write ABC to a ROOT file; class ABC : public TObject {. public:; Float_t a, b, c, p;; ABC() : a(0), b(0), c(0), p(0){};. // Define the class for the dictionary; ClassDef (ABC,1); };. // Call the ClassImp macro to give the ABC class RTTI and; // full I/O capabilities. #if !defined(__CLING__); ClassImp(ABC);; #endif; ```. **Step 2:** Load the ABC class in the script. ``` {.cpp}; // Check if ABC is already loaded; if (!TClass::GetDict(""ABC"")) {; gROOT->ProcessLine("".L ABCClass.C++"");; }. // Use the Class; ABC *v = new ABC;; v->p = (sqrt((v->a * v->a)+ (v->b * v->b)+(v->c * v->c)));; ```; ",MatchSource.DOCS,documentation/users-guide/AddingaClass.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md:26328,Security,access,access,26328,"ement turns on or off the dictionary generation for all; classes, structures, namespaces, global variables, global functions and; typedefs seen so far by Cling. Example:. ``` {.cpp}; // some C++ header definition; #ifdef __ROOTCLING__; // turns off dictionary generation for all; #pragma link off all class;; #pragma link off all function;; #pragma link off all global;; #pragma link off all typedef;; #endif; ```. The next pragma statement selectively turns on or off the dictionary; generation for the specified `classs`, `struct`, `union`, `enum` or; `namespace`:. ``` {.cpp}; #pragma link; [C|C++|off][class|class+protected|; struct|union|enum|namespace][name];; ```. The Dictionary of all public members of class and struct will be; generated. If the '`class+protected`' flag is used, the dictionary for; protected members will also be generated. However, dictionary for; protected constructor and destructor will not be generated. This '; `class+protected` ' flag will help you only for plain protected member; access, but not for virtual function resolution. If you use the '`namespace`' flag, it is recommended to add also:. ``` {.cpp}; #pragma link C++ nestedclass;; #pragma link C++ nestedtypedef;; ```. The behavior of '`class`', '`struct`' and '`namespace`' flag are; identical. Example:. ``` {.cpp}; // some C++ header definition; #ifdef __ROOTCLING__; #pragma link off all class;; #pragma link C++ class A;; #pragma link C++ class B;; #pragma link C++ class C<int>;; #pragma link C++ class+protected D;; #pragma link C++ namespace project1;; #pragma link C++ nestedclass;; #pragma link C++ nestedtypedef;; #endif; ```. The next pragma statement selectively turns on or off the dictionary; generation for global variables and typedef. ``` {.cpp}; #pragma link [C|C++|off] [global|typedef] [name];; ```. Example:. ``` {.cpp}; // some C/C++ header definition; #ifdef __ROOTCLING__; #pragma link off all global;; #pragma link off all typedef;; #pragma link C++ global a;; #pragma link C++ ty",MatchSource.DOCS,documentation/users-guide/AddingaClass.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md:33491,Testability,test,test,33491,"xplicitly set linkage to each; item:. ``` {.cpp}; #pragma link [C|C++|off] [class|function|global]; ```. This pragma statement must be given before `rootcling` reads any; C/C++ definitions from header files. Example:. ``` {.cpp}; #ifdef __ROOTCLING__; #pragma link default off;; #endif. class A {; int a;; double b;; };. class B {; int d;; double e;; };. #ifdef __ROOTCLING__; #pragma link C++ class A; // only class A is linked, not B; #endif; ```. ##### Compilation. **Step 4:** Compile the class using the `Makefile. `In the `Makefile`; call `rootcling` to make the dictionary for the class. Call it; `SClassDict.cxx`. The `rootcling` utility generates the methods; `Streamer`, **`TBuffer`** &operator\>\>() and `ShowMembers `for ROOT; classes. ``` {.cpp}; gmake -f Makefile; ```. Load the shared library:. ``` {.cpp}; root[] .L SClass.so; root[] SClass *sc = new SClass(); root[] TFile *f = new TFile(""Afile.root"",""UPDATE"");; root[] sc->Write();; ```. For more information on `rootcling` see the `$ROOTSYS/test` directory; `Makefile`, `Event.cxx`, and `Event.h` for an example, or follow this; link: <http://root.cern.ch/root/RootCintMan.html>. ## genreflex: A Comfortable Interface to rootcling. Version 5 supported both `Cint` and `Reflex` dictionaries. The tool to create; `Reflex` dictionaries was a Python script called `genreflex` and was very; successful in the user community.; Even if version 6 has only one type of dictionaries, `cling` dictionaries,; a re-implementation of `genreflex` is provided.; More precisely, in ROOT6, `genreflex` is nothing but a wrapper around; `rootcling`, which offers an identical CLI and behaviour to the old Python; tool.; The input to `genreflex` is a C++ header file, a set of switches and a; *selection XML file*. The output, as for `rootcling`, is a C++ dictionary; source and a `pcm` files.; An exhaustive documentation of the CLI switches of `genreflex` can be; inspected with the `genreflex --help` command. The entity corresponding to the `LinkDef",MatchSource.DOCS,documentation/users-guide/AddingaClass.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md:2922,Usability,simpl,simply,2922,"->Inspect()`, see ""Inspecting Objects"". ### Collections. To store an object in a ROOT collection, it must be a descendent of; **`TObject`**. This is convenient if you want to store objects of; different classes in the same collection and execute the method of the; same name on all members of the collection. For example, the list of; graphics primitives are in a ROOT collection called **`TList`**. When; the canvas is drawn, the `Paint` method is executed on the entire; collection. Each member may be a different class, and if the `Paint`; method is not implemented, **`TObject::Paint`** will be executed. ### Input/Output. The `TObject::Write` method is the interface to the ROOT I/O system. It; streams the object into a buffer using the `Streamer` method. It; supports cycle numbers and automatic schema evolution. See; ""Input/Output"". ### Paint/Draw. These graphics methods are defaults; their implementation in; **`TObject`** does not use the graphics subsystem. The `TObject::Draw`; method is simply a call to `AppendPad`. The `Paint` method is empty. The; default is provided so that one can call `Paint` in a collection. The; method `GetDrawOption` returns the draw option that was used when the; object was drawn on the canvas. This is especially relevant with; histograms and graphs. ### Clone/DrawClone. Two useful methods are `Clone` and `DrawClone`. The `Clone` method takes; a snapshot of the object with the `Streamer` and creates a new object.; The `DrawClone` method does the same thing and in addition draws the; clone. ### Browse. This method is called if the object is browse-able and is to be; displayed in the object browser. For example the **`TTree`**; implementation of `Browse`, calls the Browse method for each branch. The; `TBranch::Browse` method displays the name of each leaf. For the; object's `Browse` method to be called, the `IsFolder()` method must be; overridden to return true. This does not mean it has to be a folder, it; just means that it is browse-able. #",MatchSource.DOCS,documentation/users-guide/AddingaClass.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md:34566,Usability,simpl,simply,34566,"le`, `Event.cxx`, and `Event.h` for an example, or follow this; link: <http://root.cern.ch/root/RootCintMan.html>. ## genreflex: A Comfortable Interface to rootcling. Version 5 supported both `Cint` and `Reflex` dictionaries. The tool to create; `Reflex` dictionaries was a Python script called `genreflex` and was very; successful in the user community.; Even if version 6 has only one type of dictionaries, `cling` dictionaries,; a re-implementation of `genreflex` is provided.; More precisely, in ROOT6, `genreflex` is nothing but a wrapper around; `rootcling`, which offers an identical CLI and behaviour to the old Python; tool.; The input to `genreflex` is a C++ header file, a set of switches and a; *selection XML file*. The output, as for `rootcling`, is a C++ dictionary; source and a `pcm` files.; An exhaustive documentation of the CLI switches of `genreflex` can be; inspected with the `genreflex --help` command. The entity corresponding to the `LinkDef` file for `genreflex` is the; *selection XML file*, also called *selection XML* or simply *selection file*.; A *selection XML file* allows to describe a list of classes for which; the dictionaries are to be created. In addition, it allows to specify; properties of classes or data members, without the need to add comments in; the source code. This is of primary importance when dictionaries must be; created for classes residing in code which cannot be modified.; For a complete description of the structure of the *selection XML files*; and the way in which attributes can be set, refer to the `genreflex --help`; command. It is important to observe that *selection XML files* can be used in presence; of `rootcling` invocations instead of `LinkDef` files. ### The `ROOT::Meta::Selection` namespace. Not only `LinkDef` and `selection` files allow to select the classes for which; the dictionaries must be created: a third method is available. This is; represented by the `ROOT::Meta::Selection` namespace. The idea behind this; tec",MatchSource.DOCS,documentation/users-guide/AddingaClass.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md:11449,Availability,toler,tolerate,11449,"ime of the program.; However, most people in HEP who use FORTRAN will have experience of a; memory manager and the act of creating a bank is a good equivalent of; a heap object. For those who know systems like ZEBRA, it will come as; a relief to learn that objects do not move, C++ does not garbage; collect, so there is never a danger that a pointer to an object; becomes invalid for that reason. However, having created an object,; it is the user's responsibility to ensure that it is deleted when no; longer needed, or to pass that responsibility onto to some other; object. Failing to do that will result in a memory leak, one of the; most common and most hard-to-find C++ bugs. To send a message to an object via a pointer to it, you need to use; the ""`->`"" operator e.g.:. ``` {.cpp}; root[] my_objptr->Solve();; ```. Although we chose to call our pointer `my_objptr`, to emphasize that; it is a pointer, heap objects are so common in an object-oriented; program that pointer names rarely reflect the fact - you have to be; careful that you know if you are dealing with an object or its; pointer! Fortunately, the compiler won't tolerate an attempt to do; something like:. ``` {.cpp}; root[] my_objptr.Solve();; ```. As we have seen, heap objects; have to be accessed via pointers, whereas stack objects can be; accessed directly. They can also be accessed via pointers:. ``` {.cpp}; root[] Quad stack_quad(1.,2.,-3.);; root[] Quad *stack_ptr = &stack_quad;; root[] stack_ptr->Solve();; ```. Here we have a `Quad` pointer that has been initialized with the; address of a stack object. Be very careful if you take the address of; stack objects. As we shall see soon, they are deleted automatically,; which could leave you with an illegal pointer. Using it will corrupt; and may as well crash the program!. It is time to look at the destruction of objects. A destructor is a; special C++ function that releases resources for (or destroys) an; object of a class. It is the opposite of a constructor",MatchSource.DOCS,documentation/users-guide/ALittleC++.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md:12220,Deployability,release,releases,12220,"eap objects are so common in an object-oriented; program that pointer names rarely reflect the fact - you have to be; careful that you know if you are dealing with an object or its; pointer! Fortunately, the compiler won't tolerate an attempt to do; something like:. ``` {.cpp}; root[] my_objptr.Solve();; ```. As we have seen, heap objects; have to be accessed via pointers, whereas stack objects can be; accessed directly. They can also be accessed via pointers:. ``` {.cpp}; root[] Quad stack_quad(1.,2.,-3.);; root[] Quad *stack_ptr = &stack_quad;; root[] stack_ptr->Solve();; ```. Here we have a `Quad` pointer that has been initialized with the; address of a stack object. Be very careful if you take the address of; stack objects. As we shall see soon, they are deleted automatically,; which could leave you with an illegal pointer. Using it will corrupt; and may as well crash the program!. It is time to look at the destruction of objects. A destructor is a; special C++ function that releases resources for (or destroys) an; object of a class. It is the opposite of a constructor that creates the; object of a class when it is called. The compiler will provide a; destructor that does nothing if none is provided. We will add one to; our Quad class so that we can see when it is called. The class names; the destructor but with a prefix \~ which is the C++ one's complement; i.e. bit wise complement, and hence has destruction overtones! We; declare it in the .h file and define it in the `.cxx` file. It does; not do much except print out that it has been called (still a useful; debug technique despite today's powerful debuggers!). Now run root, load the Quad class and create a heap object:. ``` {.cpp}; root[] .L Quad.cxx; root[] Quad *my_objptr = new Quad(1.,2.,-3.);; ```. To delete the object:. ``` {.cpp}; root[] delete my_objptr;; root[] my_objptr = 0;; ```. You should see the print out from its destructor. Setting the pointer; to zero afterwards is not strictly necessary (and C",MatchSource.DOCS,documentation/users-guide/ALittleC++.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md:12849,Energy Efficiency,power,powerful,12849,");; ```. Here we have a `Quad` pointer that has been initialized with the; address of a stack object. Be very careful if you take the address of; stack objects. As we shall see soon, they are deleted automatically,; which could leave you with an illegal pointer. Using it will corrupt; and may as well crash the program!. It is time to look at the destruction of objects. A destructor is a; special C++ function that releases resources for (or destroys) an; object of a class. It is the opposite of a constructor that creates the; object of a class when it is called. The compiler will provide a; destructor that does nothing if none is provided. We will add one to; our Quad class so that we can see when it is called. The class names; the destructor but with a prefix \~ which is the C++ one's complement; i.e. bit wise complement, and hence has destruction overtones! We; declare it in the .h file and define it in the `.cxx` file. It does; not do much except print out that it has been called (still a useful; debug technique despite today's powerful debuggers!). Now run root, load the Quad class and create a heap object:. ``` {.cpp}; root[] .L Quad.cxx; root[] Quad *my_objptr = new Quad(1.,2.,-3.);; ```. To delete the object:. ``` {.cpp}; root[] delete my_objptr;; root[] my_objptr = 0;; ```. You should see the print out from its destructor. Setting the pointer; to zero afterwards is not strictly necessary (and Cling does it; automatically), but the object is no more accessible, and any attempt; to use the pointer again will, as has already been stated, cause; grief. So much for heap objects, but how are stack objects deleted? In; C++, a stack object is deleted as soon as control leaves the innermost; compound statement that encloses it. Therefore, it is singularly; futile to do something like:. ``` {.cpp}; root[] { Quad my_object(1.,2.,-3.); }; ```. Cling does not follow this rule; if you type in the above line, you; will not see the destructor message. As explained in the Scri",MatchSource.DOCS,documentation/users-guide/ALittleC++.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md:410,Integrability,rout,routines,410,"# A Little C++; \index{C++}. This chapter introduces you to some useful insights into C++, to allow; you to use some of the most advanced features in ROOT. It is in no case a; full course in C++. ## Classes, Methods and Constructors. C++ extends C with the notion of a class. If you're used to structures; in C, a class is a `struct` that is a group of related variables,; which is extended with functions and routines specific to this; structure (class). What is the interest? Consider a `struct` that is defined this way:. ``` {.cpp}; struct Line {; float x1;; float y1;; float x2;; float y2;; }; ```. This structure represents a line to be drawn in a graphical window.; `(x1,y1)` are the coordinates of the first point, `(x2,y2)` the; coordinates of the second point. In the standard C, if you want to; draw effectively such a line, you first have to define a structure and; initialize the points (you can try this):. ``` {.cpp}; Line firstline;; firstline.x1 = 0.2;; firstline.y1 = 0.2;; firstline.x2 = 0.8;; firstline.y2 = 0.9;; ```. This defines a line going from the point `(0.2,0.2)` to the point; `(0.8,0.9)`. To draw this line, you will have to write a function, say; `LineDraw(Line l)` and call it with your object as argument:. ``` {.cpp}; LineDraw(firstline);; ```. In C++, we would not do that. We would instead define a class like this:. ``` {.cpp}; class TLine {; Double_t x1;; Double_t y1;; Double_t x2;; Double_t y2;; TLine(int x1, int y1, int x2, int y2);; void Draw();; }; ```. Here we added two functions, that we will call methods or member; functions, to the **`TLine`** class. The first method is used for; initializing the line objects we would build. It is called a; constructor. The second one is the `Draw` method itself. Therefore, to; build and draw a line, we have to do:. ``` {.cpp}; TLine l(0.2,0.2,0.8,0.9);; l.Draw();; ```. The first line builds the object `l` by calling its constructor. The; second line calls the **`TLine`**`::Draw()` method of this object. You; ",MatchSource.DOCS,documentation/users-guide/ALittleC++.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md:4631,Integrability,depend,depend,4631,"ect `a` of type **`TArrow`**. When; you want to draw the line, you do:. ``` {.cpp}; l.Draw();; ```. `Draw()` from **`TLine`** is called. If you do:. ``` {.cpp}; a.Draw();; ```. `Draw()` from **`TArrow`** is called and the arrow `a` is drawn. ### Data Encapsulation. We have seen previously the keyword ""`public`"". This keyword means; that every name declared public is seen by the outside world. This is; opposed to ""`private`"" that means only the class where the name was; declared private could see this name. For example, suppose we declare; in **`TArrow`** the variable `ArrowHeadSize` private. ``` {.cpp}; private:; int ArrowHeadSize;; ```. Then, only the methods (i.e. member functions) of **`TArrow`** will be; able to access this variable. Nobody else will see it. Even the; classes that we could derive from **`TArrow`** will not see it. On the; other hand, if we declare the method `Draw()` as public, everybody will; be able to see it and use it. You see that the character public or; private does not depend of the type of argument. It can be a data; member, a member function, or even a class. For example, in the case; of **`TArrow`**, the base class **`TLine`** is declared as public:. ``` {.cpp}; class TArrow : public TLine { ...; ```. This means that all methods of **`TArrow`** will be able to access all; methods of **`TLine`**, but this will be also true for anybody in the; outside world. Of course, this is true if **`TLine`** accepts the; outside world to see its methods/data members. If something is; declared private in **`TLine`**, nobody will see it, not even; **`TArrow`** members, even if **`TLine`** is declared as a public; base class. What if **`TLine`** is declared ""`private`"" instead of ""`public`"" ?; Well, it will behave as any other name declared private in; **`TArrow`**: only the data members and methods of **`TArrow`** will; be able to access **`TLine`**, its methods and data members, nobody; else. This may seem a little bit confusing and readers should re",MatchSource.DOCS,documentation/users-guide/ALittleC++.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md:11007,Integrability,message,message,11007,"n the stack. The heap object will live until the; delete operator is applied to it. There is no FORTRAN parallel to a heap object; variables either come; or go as control passes in and out of a function or subroutine, or,; like a COMMON block variables, live for the lifetime of the program.; However, most people in HEP who use FORTRAN will have experience of a; memory manager and the act of creating a bank is a good equivalent of; a heap object. For those who know systems like ZEBRA, it will come as; a relief to learn that objects do not move, C++ does not garbage; collect, so there is never a danger that a pointer to an object; becomes invalid for that reason. However, having created an object,; it is the user's responsibility to ensure that it is deleted when no; longer needed, or to pass that responsibility onto to some other; object. Failing to do that will result in a memory leak, one of the; most common and most hard-to-find C++ bugs. To send a message to an object via a pointer to it, you need to use; the ""`->`"" operator e.g.:. ``` {.cpp}; root[] my_objptr->Solve();; ```. Although we chose to call our pointer `my_objptr`, to emphasize that; it is a pointer, heap objects are so common in an object-oriented; program that pointer names rarely reflect the fact - you have to be; careful that you know if you are dealing with an object or its; pointer! Fortunately, the compiler won't tolerate an attempt to do; something like:. ``` {.cpp}; root[] my_objptr.Solve();; ```. As we have seen, heap objects; have to be accessed via pointers, whereas stack objects can be; accessed directly. They can also be accessed via pointers:. ``` {.cpp}; root[] Quad stack_quad(1.,2.,-3.);; root[] Quad *stack_ptr = &stack_quad;; root[] stack_ptr->Solve();; ```. Here we have a `Quad` pointer that has been initialized with the; address of a stack object. Be very careful if you take the address of; stack objects. As we shall see soon, they are deleted automatically,; which could leave you w",MatchSource.DOCS,documentation/users-guide/ALittleC++.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md:13771,Integrability,message,message,13771,".cxx` file. It does; not do much except print out that it has been called (still a useful; debug technique despite today's powerful debuggers!). Now run root, load the Quad class and create a heap object:. ``` {.cpp}; root[] .L Quad.cxx; root[] Quad *my_objptr = new Quad(1.,2.,-3.);; ```. To delete the object:. ``` {.cpp}; root[] delete my_objptr;; root[] my_objptr = 0;; ```. You should see the print out from its destructor. Setting the pointer; to zero afterwards is not strictly necessary (and Cling does it; automatically), but the object is no more accessible, and any attempt; to use the pointer again will, as has already been stated, cause; grief. So much for heap objects, but how are stack objects deleted? In; C++, a stack object is deleted as soon as control leaves the innermost; compound statement that encloses it. Therefore, it is singularly; futile to do something like:. ``` {.cpp}; root[] { Quad my_object(1.,2.,-3.); }; ```. Cling does not follow this rule; if you type in the above line, you; will not see the destructor message. As explained in the Script; lesson, you can load in compound statements, which would be a bit; pointless if everything disappeared as soon as it was loaded! Instead,; to reset the stack you have to type:. ``` {.cpp}; root[] gROOT->Reset();; ```. This sends the Reset message via the global pointer to the ROOT; object, which, amongst its many roles, acts as a resource manager.; Start ROOT again and type in the following:. ``` {.cpp}; root[] .L Quad.cxx; root[] Quad my_object(1.,2.,-3.);; root[] Quad *my_objptr = new Quad(4.,5.,-6.);; root[] gROOT->Reset();; ```. You will see that this deletes the first object but not the second. We; have also painted ourselves into a corner, as `my_objptr` was also on; the stack. This command will fail. ``` {.cpp}; root[] my_objptr->Solve();; ```. Cling no longer knows what `my_objptr` is. This is a great example of a; memory leak; the heap object exists but we have lost our way to access; it. In gene",MatchSource.DOCS,documentation/users-guide/ALittleC++.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md:14047,Integrability,message,message,14047,"To delete the object:. ``` {.cpp}; root[] delete my_objptr;; root[] my_objptr = 0;; ```. You should see the print out from its destructor. Setting the pointer; to zero afterwards is not strictly necessary (and Cling does it; automatically), but the object is no more accessible, and any attempt; to use the pointer again will, as has already been stated, cause; grief. So much for heap objects, but how are stack objects deleted? In; C++, a stack object is deleted as soon as control leaves the innermost; compound statement that encloses it. Therefore, it is singularly; futile to do something like:. ``` {.cpp}; root[] { Quad my_object(1.,2.,-3.); }; ```. Cling does not follow this rule; if you type in the above line, you; will not see the destructor message. As explained in the Script; lesson, you can load in compound statements, which would be a bit; pointless if everything disappeared as soon as it was loaded! Instead,; to reset the stack you have to type:. ``` {.cpp}; root[] gROOT->Reset();; ```. This sends the Reset message via the global pointer to the ROOT; object, which, amongst its many roles, acts as a resource manager.; Start ROOT again and type in the following:. ``` {.cpp}; root[] .L Quad.cxx; root[] Quad my_object(1.,2.,-3.);; root[] Quad *my_objptr = new Quad(4.,5.,-6.);; root[] gROOT->Reset();; ```. You will see that this deletes the first object but not the second. We; have also painted ourselves into a corner, as `my_objptr` was also on; the stack. This command will fail. ``` {.cpp}; root[] my_objptr->Solve();; ```. Cling no longer knows what `my_objptr` is. This is a great example of a; memory leak; the heap object exists but we have lost our way to access; it. In general, this is not a problem. If any object will outlive the; compound statement in which it was created then a more permanent; pointer will point to it, which frequently is part of another heap; object. See Resetting the Interpreter Environment in the chapter; ""Cling the C++ Interpreter"".; ",MatchSource.DOCS,documentation/users-guide/ALittleC++.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md:238,Modifiability,extend,extends,238,"# A Little C++; \index{C++}. This chapter introduces you to some useful insights into C++, to allow; you to use some of the most advanced features in ROOT. It is in no case a; full course in C++. ## Classes, Methods and Constructors. C++ extends C with the notion of a class. If you're used to structures; in C, a class is a `struct` that is a group of related variables,; which is extended with functions and routines specific to this; structure (class). What is the interest? Consider a `struct` that is defined this way:. ``` {.cpp}; struct Line {; float x1;; float y1;; float x2;; float y2;; }; ```. This structure represents a line to be drawn in a graphical window.; `(x1,y1)` are the coordinates of the first point, `(x2,y2)` the; coordinates of the second point. In the standard C, if you want to; draw effectively such a line, you first have to define a structure and; initialize the points (you can try this):. ``` {.cpp}; Line firstline;; firstline.x1 = 0.2;; firstline.y1 = 0.2;; firstline.x2 = 0.8;; firstline.y2 = 0.9;; ```. This defines a line going from the point `(0.2,0.2)` to the point; `(0.8,0.9)`. To draw this line, you will have to write a function, say; `LineDraw(Line l)` and call it with your object as argument:. ``` {.cpp}; LineDraw(firstline);; ```. In C++, we would not do that. We would instead define a class like this:. ``` {.cpp}; class TLine {; Double_t x1;; Double_t y1;; Double_t x2;; Double_t y2;; TLine(int x1, int y1, int x2, int y2);; void Draw();; }; ```. Here we added two functions, that we will call methods or member; functions, to the **`TLine`** class. The first method is used for; initializing the line objects we would build. It is called a; constructor. The second one is the `Draw` method itself. Therefore, to; build and draw a line, we have to do:. ``` {.cpp}; TLine l(0.2,0.2,0.8,0.9);; l.Draw();; ```. The first line builds the object `l` by calling its constructor. The; second line calls the **`TLine`**`::Draw()` method of this object. You; ",MatchSource.DOCS,documentation/users-guide/ALittleC++.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md:361,Modifiability,variab,variables,361,"# A Little C++; \index{C++}. This chapter introduces you to some useful insights into C++, to allow; you to use some of the most advanced features in ROOT. It is in no case a; full course in C++. ## Classes, Methods and Constructors. C++ extends C with the notion of a class. If you're used to structures; in C, a class is a `struct` that is a group of related variables,; which is extended with functions and routines specific to this; structure (class). What is the interest? Consider a `struct` that is defined this way:. ``` {.cpp}; struct Line {; float x1;; float y1;; float x2;; float y2;; }; ```. This structure represents a line to be drawn in a graphical window.; `(x1,y1)` are the coordinates of the first point, `(x2,y2)` the; coordinates of the second point. In the standard C, if you want to; draw effectively such a line, you first have to define a structure and; initialize the points (you can try this):. ``` {.cpp}; Line firstline;; firstline.x1 = 0.2;; firstline.y1 = 0.2;; firstline.x2 = 0.8;; firstline.y2 = 0.9;; ```. This defines a line going from the point `(0.2,0.2)` to the point; `(0.8,0.9)`. To draw this line, you will have to write a function, say; `LineDraw(Line l)` and call it with your object as argument:. ``` {.cpp}; LineDraw(firstline);; ```. In C++, we would not do that. We would instead define a class like this:. ``` {.cpp}; class TLine {; Double_t x1;; Double_t y1;; Double_t x2;; Double_t y2;; TLine(int x1, int y1, int x2, int y2);; void Draw();; }; ```. Here we added two functions, that we will call methods or member; functions, to the **`TLine`** class. The first method is used for; initializing the line objects we would build. It is called a; constructor. The second one is the `Draw` method itself. Therefore, to; build and draw a line, we have to do:. ``` {.cpp}; TLine l(0.2,0.2,0.8,0.9);; l.Draw();; ```. The first line builds the object `l` by calling its constructor. The; second line calls the **`TLine`**`::Draw()` method of this object. You; ",MatchSource.DOCS,documentation/users-guide/ALittleC++.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md:382,Modifiability,extend,extended,382,"# A Little C++; \index{C++}. This chapter introduces you to some useful insights into C++, to allow; you to use some of the most advanced features in ROOT. It is in no case a; full course in C++. ## Classes, Methods and Constructors. C++ extends C with the notion of a class. If you're used to structures; in C, a class is a `struct` that is a group of related variables,; which is extended with functions and routines specific to this; structure (class). What is the interest? Consider a `struct` that is defined this way:. ``` {.cpp}; struct Line {; float x1;; float y1;; float x2;; float y2;; }; ```. This structure represents a line to be drawn in a graphical window.; `(x1,y1)` are the coordinates of the first point, `(x2,y2)` the; coordinates of the second point. In the standard C, if you want to; draw effectively such a line, you first have to define a structure and; initialize the points (you can try this):. ``` {.cpp}; Line firstline;; firstline.x1 = 0.2;; firstline.y1 = 0.2;; firstline.x2 = 0.8;; firstline.y2 = 0.9;; ```. This defines a line going from the point `(0.2,0.2)` to the point; `(0.8,0.9)`. To draw this line, you will have to write a function, say; `LineDraw(Line l)` and call it with your object as argument:. ``` {.cpp}; LineDraw(firstline);; ```. In C++, we would not do that. We would instead define a class like this:. ``` {.cpp}; class TLine {; Double_t x1;; Double_t y1;; Double_t x2;; Double_t y2;; TLine(int x1, int y1, int x2, int y2);; void Draw();; }; ```. Here we added two functions, that we will call methods or member; functions, to the **`TLine`** class. The first method is used for; initializing the line objects we would build. It is called a; constructor. The second one is the `Draw` method itself. Therefore, to; build and draw a line, we have to do:. ``` {.cpp}; TLine l(0.2,0.2,0.8,0.9);; l.Draw();; ```. The first line builds the object `l` by calling its constructor. The; second line calls the **`TLine`**`::Draw()` method of this object. You; ",MatchSource.DOCS,documentation/users-guide/ALittleC++.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md:2148,Modifiability,variab,variables,2148,"y; `LineDraw(Line l)` and call it with your object as argument:. ``` {.cpp}; LineDraw(firstline);; ```. In C++, we would not do that. We would instead define a class like this:. ``` {.cpp}; class TLine {; Double_t x1;; Double_t y1;; Double_t x2;; Double_t y2;; TLine(int x1, int y1, int x2, int y2);; void Draw();; }; ```. Here we added two functions, that we will call methods or member; functions, to the **`TLine`** class. The first method is used for; initializing the line objects we would build. It is called a; constructor. The second one is the `Draw` method itself. Therefore, to; build and draw a line, we have to do:. ``` {.cpp}; TLine l(0.2,0.2,0.8,0.9);; l.Draw();; ```. The first line builds the object `l` by calling its constructor. The; second line calls the **`TLine`**`::Draw()` method of this object. You; don't need to pass any parameters to this method since it applies to; the object `l`, which knows the coordinates of the line. These are; internal variables `x1`, `y1`, `x2`, `y2` that were initialized by the; constructor. ## Inheritance and Data Encapsulation. We have defined a **`TLine`** class that contains everything necessary; to draw a line. If we want to draw an arrow, is it so different from; drawing a line? We just have to draw a triangle at one end. It would; be very inefficient to define the class **`TArrow`** from scratch.; Fortunately, inheritance allows a class to be defined from an existing; class. We would write something like:. ``` {.cpp}; class TArrow : public TLine {; int ArrowHeadSize;; void Draw();; void SetArrowSize(int arrowsize);; }; ```. The keyword ""`public`"" will be explained later. The class **`TArrow`**; now contains everything that the class **`TLine`** does, and a couple; of more things, the size of the arrowhead and a function that can; change it. The Draw method of **`TArrow`** will draw the head and call; the draw method of **`TLine`**. We just have to write the code for; drawing the head!. ### Method Overriding. Giving th",MatchSource.DOCS,documentation/users-guide/ALittleC++.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md:2556,Modifiability,inherit,inheritance,2556," **`TLine`** class. The first method is used for; initializing the line objects we would build. It is called a; constructor. The second one is the `Draw` method itself. Therefore, to; build and draw a line, we have to do:. ``` {.cpp}; TLine l(0.2,0.2,0.8,0.9);; l.Draw();; ```. The first line builds the object `l` by calling its constructor. The; second line calls the **`TLine`**`::Draw()` method of this object. You; don't need to pass any parameters to this method since it applies to; the object `l`, which knows the coordinates of the line. These are; internal variables `x1`, `y1`, `x2`, `y2` that were initialized by the; constructor. ## Inheritance and Data Encapsulation. We have defined a **`TLine`** class that contains everything necessary; to draw a line. If we want to draw an arrow, is it so different from; drawing a line? We just have to draw a triangle at one end. It would; be very inefficient to define the class **`TArrow`** from scratch.; Fortunately, inheritance allows a class to be defined from an existing; class. We would write something like:. ``` {.cpp}; class TArrow : public TLine {; int ArrowHeadSize;; void Draw();; void SetArrowSize(int arrowsize);; }; ```. The keyword ""`public`"" will be explained later. The class **`TArrow`**; now contains everything that the class **`TLine`** does, and a couple; of more things, the size of the arrowhead and a function that can; change it. The Draw method of **`TArrow`** will draw the head and call; the draw method of **`TLine`**. We just have to write the code for; drawing the head!. ### Method Overriding. Giving the same name to a method (remember: method = member function; of a class) in the child class (**`TArrow`**) as in the parent; (**`TLine`**) does not give any problem. This is called **overriding**; a method. Draw in **`TArrow`** overrides Draw in **`TLine`**. There is; no possible ambiguity since, when one calls the `Draw()` method; this; applies to an object whose type is known. Suppose we have an objec",MatchSource.DOCS,documentation/users-guide/ALittleC++.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md:4183,Modifiability,variab,variable,4183," the same name to a method (remember: method = member function; of a class) in the child class (**`TArrow`**) as in the parent; (**`TLine`**) does not give any problem. This is called **overriding**; a method. Draw in **`TArrow`** overrides Draw in **`TLine`**. There is; no possible ambiguity since, when one calls the `Draw()` method; this; applies to an object whose type is known. Suppose we have an object; `l` of type **`TLine`** and an object `a` of type **`TArrow`**. When; you want to draw the line, you do:. ``` {.cpp}; l.Draw();; ```. `Draw()` from **`TLine`** is called. If you do:. ``` {.cpp}; a.Draw();; ```. `Draw()` from **`TArrow`** is called and the arrow `a` is drawn. ### Data Encapsulation. We have seen previously the keyword ""`public`"". This keyword means; that every name declared public is seen by the outside world. This is; opposed to ""`private`"" that means only the class where the name was; declared private could see this name. For example, suppose we declare; in **`TArrow`** the variable `ArrowHeadSize` private. ``` {.cpp}; private:; int ArrowHeadSize;; ```. Then, only the methods (i.e. member functions) of **`TArrow`** will be; able to access this variable. Nobody else will see it. Even the; classes that we could derive from **`TArrow`** will not see it. On the; other hand, if we declare the method `Draw()` as public, everybody will; be able to see it and use it. You see that the character public or; private does not depend of the type of argument. It can be a data; member, a member function, or even a class. For example, in the case; of **`TArrow`**, the base class **`TLine`** is declared as public:. ``` {.cpp}; class TArrow : public TLine { ...; ```. This means that all methods of **`TArrow`** will be able to access all; methods of **`TLine`**, but this will be also true for anybody in the; outside world. Of course, this is true if **`TLine`** accepts the; outside world to see its methods/data members. If something is; declared private in **`TLine",MatchSource.DOCS,documentation/users-guide/ALittleC++.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md:4356,Modifiability,variab,variable,4356,"any problem. This is called **overriding**; a method. Draw in **`TArrow`** overrides Draw in **`TLine`**. There is; no possible ambiguity since, when one calls the `Draw()` method; this; applies to an object whose type is known. Suppose we have an object; `l` of type **`TLine`** and an object `a` of type **`TArrow`**. When; you want to draw the line, you do:. ``` {.cpp}; l.Draw();; ```. `Draw()` from **`TLine`** is called. If you do:. ``` {.cpp}; a.Draw();; ```. `Draw()` from **`TArrow`** is called and the arrow `a` is drawn. ### Data Encapsulation. We have seen previously the keyword ""`public`"". This keyword means; that every name declared public is seen by the outside world. This is; opposed to ""`private`"" that means only the class where the name was; declared private could see this name. For example, suppose we declare; in **`TArrow`** the variable `ArrowHeadSize` private. ``` {.cpp}; private:; int ArrowHeadSize;; ```. Then, only the methods (i.e. member functions) of **`TArrow`** will be; able to access this variable. Nobody else will see it. Even the; classes that we could derive from **`TArrow`** will not see it. On the; other hand, if we declare the method `Draw()` as public, everybody will; be able to see it and use it. You see that the character public or; private does not depend of the type of argument. It can be a data; member, a member function, or even a class. For example, in the case; of **`TArrow`**, the base class **`TLine`** is declared as public:. ``` {.cpp}; class TArrow : public TLine { ...; ```. This means that all methods of **`TArrow`** will be able to access all; methods of **`TLine`**, but this will be also true for anybody in the; outside world. Of course, this is true if **`TLine`** accepts the; outside world to see its methods/data members. If something is; declared private in **`TLine`**, nobody will see it, not even; **`TArrow`** members, even if **`TLine`** is declared as a public; base class. What if **`TLine`** is declared ""`private`",MatchSource.DOCS,documentation/users-guide/ALittleC++.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md:8883,Modifiability,variab,variable,8883,"nst;; private:; Float_t fA;; Float_t fB;; Float_t fC;; };; ```. `Quad.cxx`:. ``` {.cpp}; #include <iostream.h>; #include <math.h>; #include ""Quad.h"". Quad::Quad(Float_t a, Float_t b, Float_t c) {; fA = a;; fB = b;; fC = c;; }; Quad::~Quad() {; Cout <<""deleting object with coeffts: ""<< fA << "","" << fB << "",""; << fC << endl;; }; Float_t Quad::Evaluate(Float_t x) const {; return fA*x*x + fB*x + fC;; }; void Quad::Solve() const {; Float_t temp = fB*fB - 4.*fA*fC;; if ( temp > 0. ) {; temp = sqrt( temp );; cout << ""There are two roots: "" << ( -fB - temp ) / (2.*fA); << "" and "" << ( -fB + temp ) / (2.*fA) << endl;; } else {; if ( temp == 0. ) {; cout << ""There are two equal roots: "" << -fB / (2.*fA); << endl;; } else {; cout << ""There are no roots"" << endl;; }; }; }; ```. Let us first look how we create an object. When we create an object; by:. ``` {.cpp}; root[] Quad my_object(1.,2.,-3.);; ```. We are creating an object on the stack. A FORTRAN programmer may be; familiar with the idea; it is not unlike a local variable in a; function or subroutine. Although there are still a few old timers who; do not know it, FORTRAN is under no obligation to save local variables; once the function or subroutine returns unless the SAVE statement is; used. If not then it is likely that FORTRAN will place them on the; stack and they will ""pop off"" when the RETURN statement is reached. To; give an object more permanence it has to be placed on the heap. ``` {.cpp}; root[] .L Quad.cxx; root[] Quad *my_objptr = new Quad(1.,2.,-3.);; ```. The second line declares a pointer to `Quad` called `my_objptr`. From; the syntax point of view, this is just like all the other declarations; we have seen so far, i.e. this is a stack variable. The value of the; pointer is set equal to. ``` {.cpp}; new Quad(1.,2.,-3.);; ```. `new`, despite its looks, is an operator and creates an object or; variable of the type that comes next, `Quad` in this case, on the; heap. Just as with stack objects it has to be initial",MatchSource.DOCS,documentation/users-guide/ALittleC++.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md:9030,Modifiability,variab,variables,9030,"Quad(Float_t a, Float_t b, Float_t c) {; fA = a;; fB = b;; fC = c;; }; Quad::~Quad() {; Cout <<""deleting object with coeffts: ""<< fA << "","" << fB << "",""; << fC << endl;; }; Float_t Quad::Evaluate(Float_t x) const {; return fA*x*x + fB*x + fC;; }; void Quad::Solve() const {; Float_t temp = fB*fB - 4.*fA*fC;; if ( temp > 0. ) {; temp = sqrt( temp );; cout << ""There are two roots: "" << ( -fB - temp ) / (2.*fA); << "" and "" << ( -fB + temp ) / (2.*fA) << endl;; } else {; if ( temp == 0. ) {; cout << ""There are two equal roots: "" << -fB / (2.*fA); << endl;; } else {; cout << ""There are no roots"" << endl;; }; }; }; ```. Let us first look how we create an object. When we create an object; by:. ``` {.cpp}; root[] Quad my_object(1.,2.,-3.);; ```. We are creating an object on the stack. A FORTRAN programmer may be; familiar with the idea; it is not unlike a local variable in a; function or subroutine. Although there are still a few old timers who; do not know it, FORTRAN is under no obligation to save local variables; once the function or subroutine returns unless the SAVE statement is; used. If not then it is likely that FORTRAN will place them on the; stack and they will ""pop off"" when the RETURN statement is reached. To; give an object more permanence it has to be placed on the heap. ``` {.cpp}; root[] .L Quad.cxx; root[] Quad *my_objptr = new Quad(1.,2.,-3.);; ```. The second line declares a pointer to `Quad` called `my_objptr`. From; the syntax point of view, this is just like all the other declarations; we have seen so far, i.e. this is a stack variable. The value of the; pointer is set equal to. ``` {.cpp}; new Quad(1.,2.,-3.);; ```. `new`, despite its looks, is an operator and creates an object or; variable of the type that comes next, `Quad` in this case, on the; heap. Just as with stack objects it has to be initialized by calling; its constructor. The syntax requires that the argument list follows the; type. This one statement has brought two items into existence, one",MatchSource.DOCS,documentation/users-guide/ALittleC++.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md:9584,Modifiability,variab,variable,9584,"se {; cout << ""There are no roots"" << endl;; }; }; }; ```. Let us first look how we create an object. When we create an object; by:. ``` {.cpp}; root[] Quad my_object(1.,2.,-3.);; ```. We are creating an object on the stack. A FORTRAN programmer may be; familiar with the idea; it is not unlike a local variable in a; function or subroutine. Although there are still a few old timers who; do not know it, FORTRAN is under no obligation to save local variables; once the function or subroutine returns unless the SAVE statement is; used. If not then it is likely that FORTRAN will place them on the; stack and they will ""pop off"" when the RETURN statement is reached. To; give an object more permanence it has to be placed on the heap. ``` {.cpp}; root[] .L Quad.cxx; root[] Quad *my_objptr = new Quad(1.,2.,-3.);; ```. The second line declares a pointer to `Quad` called `my_objptr`. From; the syntax point of view, this is just like all the other declarations; we have seen so far, i.e. this is a stack variable. The value of the; pointer is set equal to. ``` {.cpp}; new Quad(1.,2.,-3.);; ```. `new`, despite its looks, is an operator and creates an object or; variable of the type that comes next, `Quad` in this case, on the; heap. Just as with stack objects it has to be initialized by calling; its constructor. The syntax requires that the argument list follows the; type. This one statement has brought two items into existence, one on; the heap and one on the stack. The heap object will live until the; delete operator is applied to it. There is no FORTRAN parallel to a heap object; variables either come; or go as control passes in and out of a function or subroutine, or,; like a COMMON block variables, live for the lifetime of the program.; However, most people in HEP who use FORTRAN will have experience of a; memory manager and the act of creating a bank is a good equivalent of; a heap object. For those who know systems like ZEBRA, it will come as; a relief to learn that objects d",MatchSource.DOCS,documentation/users-guide/ALittleC++.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md:9743,Modifiability,variab,variable,9743,"t(1.,2.,-3.);; ```. We are creating an object on the stack. A FORTRAN programmer may be; familiar with the idea; it is not unlike a local variable in a; function or subroutine. Although there are still a few old timers who; do not know it, FORTRAN is under no obligation to save local variables; once the function or subroutine returns unless the SAVE statement is; used. If not then it is likely that FORTRAN will place them on the; stack and they will ""pop off"" when the RETURN statement is reached. To; give an object more permanence it has to be placed on the heap. ``` {.cpp}; root[] .L Quad.cxx; root[] Quad *my_objptr = new Quad(1.,2.,-3.);; ```. The second line declares a pointer to `Quad` called `my_objptr`. From; the syntax point of view, this is just like all the other declarations; we have seen so far, i.e. this is a stack variable. The value of the; pointer is set equal to. ``` {.cpp}; new Quad(1.,2.,-3.);; ```. `new`, despite its looks, is an operator and creates an object or; variable of the type that comes next, `Quad` in this case, on the; heap. Just as with stack objects it has to be initialized by calling; its constructor. The syntax requires that the argument list follows the; type. This one statement has brought two items into existence, one on; the heap and one on the stack. The heap object will live until the; delete operator is applied to it. There is no FORTRAN parallel to a heap object; variables either come; or go as control passes in and out of a function or subroutine, or,; like a COMMON block variables, live for the lifetime of the program.; However, most people in HEP who use FORTRAN will have experience of a; memory manager and the act of creating a bank is a good equivalent of; a heap object. For those who know systems like ZEBRA, it will come as; a relief to learn that objects do not move, C++ does not garbage; collect, so there is never a danger that a pointer to an object; becomes invalid for that reason. However, having created an object",MatchSource.DOCS,documentation/users-guide/ALittleC++.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md:10173,Modifiability,variab,variables,10173,"ement is reached. To; give an object more permanence it has to be placed on the heap. ``` {.cpp}; root[] .L Quad.cxx; root[] Quad *my_objptr = new Quad(1.,2.,-3.);; ```. The second line declares a pointer to `Quad` called `my_objptr`. From; the syntax point of view, this is just like all the other declarations; we have seen so far, i.e. this is a stack variable. The value of the; pointer is set equal to. ``` {.cpp}; new Quad(1.,2.,-3.);; ```. `new`, despite its looks, is an operator and creates an object or; variable of the type that comes next, `Quad` in this case, on the; heap. Just as with stack objects it has to be initialized by calling; its constructor. The syntax requires that the argument list follows the; type. This one statement has brought two items into existence, one on; the heap and one on the stack. The heap object will live until the; delete operator is applied to it. There is no FORTRAN parallel to a heap object; variables either come; or go as control passes in and out of a function or subroutine, or,; like a COMMON block variables, live for the lifetime of the program.; However, most people in HEP who use FORTRAN will have experience of a; memory manager and the act of creating a bank is a good equivalent of; a heap object. For those who know systems like ZEBRA, it will come as; a relief to learn that objects do not move, C++ does not garbage; collect, so there is never a danger that a pointer to an object; becomes invalid for that reason. However, having created an object,; it is the user's responsibility to ensure that it is deleted when no; longer needed, or to pass that responsibility onto to some other; object. Failing to do that will result in a memory leak, one of the; most common and most hard-to-find C++ bugs. To send a message to an object via a pointer to it, you need to use; the ""`->`"" operator e.g.:. ``` {.cpp}; root[] my_objptr->Solve();; ```. Although we chose to call our pointer `my_objptr`, to emphasize that; it is a pointer, heap",MatchSource.DOCS,documentation/users-guide/ALittleC++.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md:10285,Modifiability,variab,variables,10285,"ement is reached. To; give an object more permanence it has to be placed on the heap. ``` {.cpp}; root[] .L Quad.cxx; root[] Quad *my_objptr = new Quad(1.,2.,-3.);; ```. The second line declares a pointer to `Quad` called `my_objptr`. From; the syntax point of view, this is just like all the other declarations; we have seen so far, i.e. this is a stack variable. The value of the; pointer is set equal to. ``` {.cpp}; new Quad(1.,2.,-3.);; ```. `new`, despite its looks, is an operator and creates an object or; variable of the type that comes next, `Quad` in this case, on the; heap. Just as with stack objects it has to be initialized by calling; its constructor. The syntax requires that the argument list follows the; type. This one statement has brought two items into existence, one on; the heap and one on the stack. The heap object will live until the; delete operator is applied to it. There is no FORTRAN parallel to a heap object; variables either come; or go as control passes in and out of a function or subroutine, or,; like a COMMON block variables, live for the lifetime of the program.; However, most people in HEP who use FORTRAN will have experience of a; memory manager and the act of creating a bank is a good equivalent of; a heap object. For those who know systems like ZEBRA, it will come as; a relief to learn that objects do not move, C++ does not garbage; collect, so there is never a danger that a pointer to an object; becomes invalid for that reason. However, having created an object,; it is the user's responsibility to ensure that it is deleted when no; longer needed, or to pass that responsibility onto to some other; object. Failing to do that will result in a memory leak, one of the; most common and most hard-to-find C++ bugs. To send a message to an object via a pointer to it, you need to use; the ""`->`"" operator e.g.:. ``` {.cpp}; root[] my_objptr->Solve();; ```. Although we chose to call our pointer `my_objptr`, to emphasize that; it is a pointer, heap",MatchSource.DOCS,documentation/users-guide/ALittleC++.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md:12885,Performance,load,load,12885,"ect. Be very careful if you take the address of; stack objects. As we shall see soon, they are deleted automatically,; which could leave you with an illegal pointer. Using it will corrupt; and may as well crash the program!. It is time to look at the destruction of objects. A destructor is a; special C++ function that releases resources for (or destroys) an; object of a class. It is the opposite of a constructor that creates the; object of a class when it is called. The compiler will provide a; destructor that does nothing if none is provided. We will add one to; our Quad class so that we can see when it is called. The class names; the destructor but with a prefix \~ which is the C++ one's complement; i.e. bit wise complement, and hence has destruction overtones! We; declare it in the .h file and define it in the `.cxx` file. It does; not do much except print out that it has been called (still a useful; debug technique despite today's powerful debuggers!). Now run root, load the Quad class and create a heap object:. ``` {.cpp}; root[] .L Quad.cxx; root[] Quad *my_objptr = new Quad(1.,2.,-3.);; ```. To delete the object:. ``` {.cpp}; root[] delete my_objptr;; root[] my_objptr = 0;; ```. You should see the print out from its destructor. Setting the pointer; to zero afterwards is not strictly necessary (and Cling does it; automatically), but the object is no more accessible, and any attempt; to use the pointer again will, as has already been stated, cause; grief. So much for heap objects, but how are stack objects deleted? In; C++, a stack object is deleted as soon as control leaves the innermost; compound statement that encloses it. Therefore, it is singularly; futile to do something like:. ``` {.cpp}; root[] { Quad my_object(1.,2.,-3.); }; ```. Cling does not follow this rule; if you type in the above line, you; will not see the destructor message. As explained in the Script; lesson, you can load in compound statements, which would be a bit; pointless if everything di",MatchSource.DOCS,documentation/users-guide/ALittleC++.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md:13824,Performance,load,load,13824,"ot, load the Quad class and create a heap object:. ``` {.cpp}; root[] .L Quad.cxx; root[] Quad *my_objptr = new Quad(1.,2.,-3.);; ```. To delete the object:. ``` {.cpp}; root[] delete my_objptr;; root[] my_objptr = 0;; ```. You should see the print out from its destructor. Setting the pointer; to zero afterwards is not strictly necessary (and Cling does it; automatically), but the object is no more accessible, and any attempt; to use the pointer again will, as has already been stated, cause; grief. So much for heap objects, but how are stack objects deleted? In; C++, a stack object is deleted as soon as control leaves the innermost; compound statement that encloses it. Therefore, it is singularly; futile to do something like:. ``` {.cpp}; root[] { Quad my_object(1.,2.,-3.); }; ```. Cling does not follow this rule; if you type in the above line, you; will not see the destructor message. As explained in the Script; lesson, you can load in compound statements, which would be a bit; pointless if everything disappeared as soon as it was loaded! Instead,; to reset the stack you have to type:. ``` {.cpp}; root[] gROOT->Reset();; ```. This sends the Reset message via the global pointer to the ROOT; object, which, amongst its many roles, acts as a resource manager.; Start ROOT again and type in the following:. ``` {.cpp}; root[] .L Quad.cxx; root[] Quad my_object(1.,2.,-3.);; root[] Quad *my_objptr = new Quad(4.,5.,-6.);; root[] gROOT->Reset();; ```. You will see that this deletes the first object but not the second. We; have also painted ourselves into a corner, as `my_objptr` was also on; the stack. This command will fail. ``` {.cpp}; root[] my_objptr->Solve();; ```. Cling no longer knows what `my_objptr` is. This is a great example of a; memory leak; the heap object exists but we have lost our way to access; it. In general, this is not a problem. If any object will outlive the; compound statement in which it was created then a more permanent; pointer will point to it, whic",MatchSource.DOCS,documentation/users-guide/ALittleC++.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md:13929,Performance,load,loaded,13929,"ot, load the Quad class and create a heap object:. ``` {.cpp}; root[] .L Quad.cxx; root[] Quad *my_objptr = new Quad(1.,2.,-3.);; ```. To delete the object:. ``` {.cpp}; root[] delete my_objptr;; root[] my_objptr = 0;; ```. You should see the print out from its destructor. Setting the pointer; to zero afterwards is not strictly necessary (and Cling does it; automatically), but the object is no more accessible, and any attempt; to use the pointer again will, as has already been stated, cause; grief. So much for heap objects, but how are stack objects deleted? In; C++, a stack object is deleted as soon as control leaves the innermost; compound statement that encloses it. Therefore, it is singularly; futile to do something like:. ``` {.cpp}; root[] { Quad my_object(1.,2.,-3.); }; ```. Cling does not follow this rule; if you type in the above line, you; will not see the destructor message. As explained in the Script; lesson, you can load in compound statements, which would be a bit; pointless if everything disappeared as soon as it was loaded! Instead,; to reset the stack you have to type:. ``` {.cpp}; root[] gROOT->Reset();; ```. This sends the Reset message via the global pointer to the ROOT; object, which, amongst its many roles, acts as a resource manager.; Start ROOT again and type in the following:. ``` {.cpp}; root[] .L Quad.cxx; root[] Quad my_object(1.,2.,-3.);; root[] Quad *my_objptr = new Quad(4.,5.,-6.);; root[] gROOT->Reset();; ```. You will see that this deletes the first object but not the second. We; have also painted ourselves into a corner, as `my_objptr` was also on; the stack. This command will fail. ``` {.cpp}; root[] my_objptr->Solve();; ```. Cling no longer knows what `my_objptr` is. This is a great example of a; memory leak; the heap object exists but we have lost our way to access; it. In general, this is not a problem. If any object will outlive the; compound statement in which it was created then a more permanent; pointer will point to it, whic",MatchSource.DOCS,documentation/users-guide/ALittleC++.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md:4344,Security,access,access,4344,"any problem. This is called **overriding**; a method. Draw in **`TArrow`** overrides Draw in **`TLine`**. There is; no possible ambiguity since, when one calls the `Draw()` method; this; applies to an object whose type is known. Suppose we have an object; `l` of type **`TLine`** and an object `a` of type **`TArrow`**. When; you want to draw the line, you do:. ``` {.cpp}; l.Draw();; ```. `Draw()` from **`TLine`** is called. If you do:. ``` {.cpp}; a.Draw();; ```. `Draw()` from **`TArrow`** is called and the arrow `a` is drawn. ### Data Encapsulation. We have seen previously the keyword ""`public`"". This keyword means; that every name declared public is seen by the outside world. This is; opposed to ""`private`"" that means only the class where the name was; declared private could see this name. For example, suppose we declare; in **`TArrow`** the variable `ArrowHeadSize` private. ``` {.cpp}; private:; int ArrowHeadSize;; ```. Then, only the methods (i.e. member functions) of **`TArrow`** will be; able to access this variable. Nobody else will see it. Even the; classes that we could derive from **`TArrow`** will not see it. On the; other hand, if we declare the method `Draw()` as public, everybody will; be able to see it and use it. You see that the character public or; private does not depend of the type of argument. It can be a data; member, a member function, or even a class. For example, in the case; of **`TArrow`**, the base class **`TLine`** is declared as public:. ``` {.cpp}; class TArrow : public TLine { ...; ```. This means that all methods of **`TArrow`** will be able to access all; methods of **`TLine`**, but this will be also true for anybody in the; outside world. Of course, this is true if **`TLine`** accepts the; outside world to see its methods/data members. If something is; declared private in **`TLine`**, nobody will see it, not even; **`TArrow`** members, even if **`TLine`** is declared as a public; base class. What if **`TLine`** is declared ""`private`",MatchSource.DOCS,documentation/users-guide/ALittleC++.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md:4931,Security,access,access,4931,"s; that every name declared public is seen by the outside world. This is; opposed to ""`private`"" that means only the class where the name was; declared private could see this name. For example, suppose we declare; in **`TArrow`** the variable `ArrowHeadSize` private. ``` {.cpp}; private:; int ArrowHeadSize;; ```. Then, only the methods (i.e. member functions) of **`TArrow`** will be; able to access this variable. Nobody else will see it. Even the; classes that we could derive from **`TArrow`** will not see it. On the; other hand, if we declare the method `Draw()` as public, everybody will; be able to see it and use it. You see that the character public or; private does not depend of the type of argument. It can be a data; member, a member function, or even a class. For example, in the case; of **`TArrow`**, the base class **`TLine`** is declared as public:. ``` {.cpp}; class TArrow : public TLine { ...; ```. This means that all methods of **`TArrow`** will be able to access all; methods of **`TLine`**, but this will be also true for anybody in the; outside world. Of course, this is true if **`TLine`** accepts the; outside world to see its methods/data members. If something is; declared private in **`TLine`**, nobody will see it, not even; **`TArrow`** members, even if **`TLine`** is declared as a public; base class. What if **`TLine`** is declared ""`private`"" instead of ""`public`"" ?; Well, it will behave as any other name declared private in; **`TArrow`**: only the data members and methods of **`TArrow`** will; be able to access **`TLine`**, its methods and data members, nobody; else. This may seem a little bit confusing and readers should read a; good C++ book if they want more details. Especially since, besides; public and private, a member can be protected. Usually, one puts; private the methods that the class uses internally, like some; utilities classes, and that the programmer does not want to be seen; in the outside world. With ""good"" C++ practice (which we h",MatchSource.DOCS,documentation/users-guide/ALittleC++.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md:5497,Security,access,access,5497,"derive from **`TArrow`** will not see it. On the; other hand, if we declare the method `Draw()` as public, everybody will; be able to see it and use it. You see that the character public or; private does not depend of the type of argument. It can be a data; member, a member function, or even a class. For example, in the case; of **`TArrow`**, the base class **`TLine`** is declared as public:. ``` {.cpp}; class TArrow : public TLine { ...; ```. This means that all methods of **`TArrow`** will be able to access all; methods of **`TLine`**, but this will be also true for anybody in the; outside world. Of course, this is true if **`TLine`** accepts the; outside world to see its methods/data members. If something is; declared private in **`TLine`**, nobody will see it, not even; **`TArrow`** members, even if **`TLine`** is declared as a public; base class. What if **`TLine`** is declared ""`private`"" instead of ""`public`"" ?; Well, it will behave as any other name declared private in; **`TArrow`**: only the data members and methods of **`TArrow`** will; be able to access **`TLine`**, its methods and data members, nobody; else. This may seem a little bit confusing and readers should read a; good C++ book if they want more details. Especially since, besides; public and private, a member can be protected. Usually, one puts; private the methods that the class uses internally, like some; utilities classes, and that the programmer does not want to be seen; in the outside world. With ""good"" C++ practice (which we have tried to use in ROOT), all; data members of a class are private. This is called data encapsulation; and is one of the strongest advantages of Object Oriented Programming; (OOP). Private data members of a class are not visible, except to the; class itself. So, from the outside world, if one wants to access those; data members, one should use so called ""getters"" and ""setters""; methods, which are special methods used only to get or set the data; members. The advantage ",MatchSource.DOCS,documentation/users-guide/ALittleC++.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md:6253,Security,access,access,6253,"s declared ""`private`"" instead of ""`public`"" ?; Well, it will behave as any other name declared private in; **`TArrow`**: only the data members and methods of **`TArrow`** will; be able to access **`TLine`**, its methods and data members, nobody; else. This may seem a little bit confusing and readers should read a; good C++ book if they want more details. Especially since, besides; public and private, a member can be protected. Usually, one puts; private the methods that the class uses internally, like some; utilities classes, and that the programmer does not want to be seen; in the outside world. With ""good"" C++ practice (which we have tried to use in ROOT), all; data members of a class are private. This is called data encapsulation; and is one of the strongest advantages of Object Oriented Programming; (OOP). Private data members of a class are not visible, except to the; class itself. So, from the outside world, if one wants to access those; data members, one should use so called ""getters"" and ""setters""; methods, which are special methods used only to get or set the data; members. The advantage is that if the programmers want to modify the; inner workings of their classes, they can do so without changing what; the user sees. The user does not even have to know that something has; changed (for the better, hopefully). For example, in our **`TArrow`**; class, we would have set the data member `ArrowHeadSize` private. The; setter method is `SetArrowSize()`, we do not need a getter method:. ``` {.cpp}; class TArrow : public TLine {; private:; int ArrowHeadSize;; public:; void Draw();; void SetArrowSize(int arrowsize);; }; ```. To define an arrow object you call the constructor. This will also; call the constructor of **`TLine`**, which is the parent class of; **`TArrow`**, automatically. Then we can call any of the line or arrow; public methods:. ``` {.cpp}; root[] TArrow *myarrow = new TArrow(1,5,89,124);; root[] myarrow->SetArrowSize(10);; root[] myarrow->Draw();; `",MatchSource.DOCS,documentation/users-guide/ALittleC++.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md:11579,Security,access,accessed,11579,"++ does not garbage; collect, so there is never a danger that a pointer to an object; becomes invalid for that reason. However, having created an object,; it is the user's responsibility to ensure that it is deleted when no; longer needed, or to pass that responsibility onto to some other; object. Failing to do that will result in a memory leak, one of the; most common and most hard-to-find C++ bugs. To send a message to an object via a pointer to it, you need to use; the ""`->`"" operator e.g.:. ``` {.cpp}; root[] my_objptr->Solve();; ```. Although we chose to call our pointer `my_objptr`, to emphasize that; it is a pointer, heap objects are so common in an object-oriented; program that pointer names rarely reflect the fact - you have to be; careful that you know if you are dealing with an object or its; pointer! Fortunately, the compiler won't tolerate an attempt to do; something like:. ``` {.cpp}; root[] my_objptr.Solve();; ```. As we have seen, heap objects; have to be accessed via pointers, whereas stack objects can be; accessed directly. They can also be accessed via pointers:. ``` {.cpp}; root[] Quad stack_quad(1.,2.,-3.);; root[] Quad *stack_ptr = &stack_quad;; root[] stack_ptr->Solve();; ```. Here we have a `Quad` pointer that has been initialized with the; address of a stack object. Be very careful if you take the address of; stack objects. As we shall see soon, they are deleted automatically,; which could leave you with an illegal pointer. Using it will corrupt; and may as well crash the program!. It is time to look at the destruction of objects. A destructor is a; special C++ function that releases resources for (or destroys) an; object of a class. It is the opposite of a constructor that creates the; object of a class when it is called. The compiler will provide a; destructor that does nothing if none is provided. We will add one to; our Quad class so that we can see when it is called. The class names; the destructor but with a prefix \~ which is the C++ ",MatchSource.DOCS,documentation/users-guide/ALittleC++.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md:11632,Security,access,accessed,11632,"++ does not garbage; collect, so there is never a danger that a pointer to an object; becomes invalid for that reason. However, having created an object,; it is the user's responsibility to ensure that it is deleted when no; longer needed, or to pass that responsibility onto to some other; object. Failing to do that will result in a memory leak, one of the; most common and most hard-to-find C++ bugs. To send a message to an object via a pointer to it, you need to use; the ""`->`"" operator e.g.:. ``` {.cpp}; root[] my_objptr->Solve();; ```. Although we chose to call our pointer `my_objptr`, to emphasize that; it is a pointer, heap objects are so common in an object-oriented; program that pointer names rarely reflect the fact - you have to be; careful that you know if you are dealing with an object or its; pointer! Fortunately, the compiler won't tolerate an attempt to do; something like:. ``` {.cpp}; root[] my_objptr.Solve();; ```. As we have seen, heap objects; have to be accessed via pointers, whereas stack objects can be; accessed directly. They can also be accessed via pointers:. ``` {.cpp}; root[] Quad stack_quad(1.,2.,-3.);; root[] Quad *stack_ptr = &stack_quad;; root[] stack_ptr->Solve();; ```. Here we have a `Quad` pointer that has been initialized with the; address of a stack object. Be very careful if you take the address of; stack objects. As we shall see soon, they are deleted automatically,; which could leave you with an illegal pointer. Using it will corrupt; and may as well crash the program!. It is time to look at the destruction of objects. A destructor is a; special C++ function that releases resources for (or destroys) an; object of a class. It is the opposite of a constructor that creates the; object of a class when it is called. The compiler will provide a; destructor that does nothing if none is provided. We will add one to; our Quad class so that we can see when it is called. The class names; the destructor but with a prefix \~ which is the C++ ",MatchSource.DOCS,documentation/users-guide/ALittleC++.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md:11668,Security,access,accessed,11668," object; becomes invalid for that reason. However, having created an object,; it is the user's responsibility to ensure that it is deleted when no; longer needed, or to pass that responsibility onto to some other; object. Failing to do that will result in a memory leak, one of the; most common and most hard-to-find C++ bugs. To send a message to an object via a pointer to it, you need to use; the ""`->`"" operator e.g.:. ``` {.cpp}; root[] my_objptr->Solve();; ```. Although we chose to call our pointer `my_objptr`, to emphasize that; it is a pointer, heap objects are so common in an object-oriented; program that pointer names rarely reflect the fact - you have to be; careful that you know if you are dealing with an object or its; pointer! Fortunately, the compiler won't tolerate an attempt to do; something like:. ``` {.cpp}; root[] my_objptr.Solve();; ```. As we have seen, heap objects; have to be accessed via pointers, whereas stack objects can be; accessed directly. They can also be accessed via pointers:. ``` {.cpp}; root[] Quad stack_quad(1.,2.,-3.);; root[] Quad *stack_ptr = &stack_quad;; root[] stack_ptr->Solve();; ```. Here we have a `Quad` pointer that has been initialized with the; address of a stack object. Be very careful if you take the address of; stack objects. As we shall see soon, they are deleted automatically,; which could leave you with an illegal pointer. Using it will corrupt; and may as well crash the program!. It is time to look at the destruction of objects. A destructor is a; special C++ function that releases resources for (or destroys) an; object of a class. It is the opposite of a constructor that creates the; object of a class when it is called. The compiler will provide a; destructor that does nothing if none is provided. We will add one to; our Quad class so that we can see when it is called. The class names; the destructor but with a prefix \~ which is the C++ one's complement; i.e. bit wise complement, and hence has destruction overtone",MatchSource.DOCS,documentation/users-guide/ALittleC++.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md:13283,Security,access,accessible,13283,"f a class. It is the opposite of a constructor that creates the; object of a class when it is called. The compiler will provide a; destructor that does nothing if none is provided. We will add one to; our Quad class so that we can see when it is called. The class names; the destructor but with a prefix \~ which is the C++ one's complement; i.e. bit wise complement, and hence has destruction overtones! We; declare it in the .h file and define it in the `.cxx` file. It does; not do much except print out that it has been called (still a useful; debug technique despite today's powerful debuggers!). Now run root, load the Quad class and create a heap object:. ``` {.cpp}; root[] .L Quad.cxx; root[] Quad *my_objptr = new Quad(1.,2.,-3.);; ```. To delete the object:. ``` {.cpp}; root[] delete my_objptr;; root[] my_objptr = 0;; ```. You should see the print out from its destructor. Setting the pointer; to zero afterwards is not strictly necessary (and Cling does it; automatically), but the object is no more accessible, and any attempt; to use the pointer again will, as has already been stated, cause; grief. So much for heap objects, but how are stack objects deleted? In; C++, a stack object is deleted as soon as control leaves the innermost; compound statement that encloses it. Therefore, it is singularly; futile to do something like:. ``` {.cpp}; root[] { Quad my_object(1.,2.,-3.); }; ```. Cling does not follow this rule; if you type in the above line, you; will not see the destructor message. As explained in the Script; lesson, you can load in compound statements, which would be a bit; pointless if everything disappeared as soon as it was loaded! Instead,; to reset the stack you have to type:. ``` {.cpp}; root[] gROOT->Reset();; ```. This sends the Reset message via the global pointer to the ROOT; object, which, amongst its many roles, acts as a resource manager.; Start ROOT again and type in the following:. ``` {.cpp}; root[] .L Quad.cxx; root[] Quad my_object(1.,2.,-3.);",MatchSource.DOCS,documentation/users-guide/ALittleC++.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md:14707,Security,access,access,14707,"To delete the object:. ``` {.cpp}; root[] delete my_objptr;; root[] my_objptr = 0;; ```. You should see the print out from its destructor. Setting the pointer; to zero afterwards is not strictly necessary (and Cling does it; automatically), but the object is no more accessible, and any attempt; to use the pointer again will, as has already been stated, cause; grief. So much for heap objects, but how are stack objects deleted? In; C++, a stack object is deleted as soon as control leaves the innermost; compound statement that encloses it. Therefore, it is singularly; futile to do something like:. ``` {.cpp}; root[] { Quad my_object(1.,2.,-3.); }; ```. Cling does not follow this rule; if you type in the above line, you; will not see the destructor message. As explained in the Script; lesson, you can load in compound statements, which would be a bit; pointless if everything disappeared as soon as it was loaded! Instead,; to reset the stack you have to type:. ``` {.cpp}; root[] gROOT->Reset();; ```. This sends the Reset message via the global pointer to the ROOT; object, which, amongst its many roles, acts as a resource manager.; Start ROOT again and type in the following:. ``` {.cpp}; root[] .L Quad.cxx; root[] Quad my_object(1.,2.,-3.);; root[] Quad *my_objptr = new Quad(4.,5.,-6.);; root[] gROOT->Reset();; ```. You will see that this deletes the first object but not the second. We; have also painted ourselves into a corner, as `my_objptr` was also on; the stack. This command will fail. ``` {.cpp}; root[] my_objptr->Solve();; ```. Cling no longer knows what `my_objptr` is. This is a great example of a; memory leak; the heap object exists but we have lost our way to access; it. In general, this is not a problem. If any object will outlive the; compound statement in which it was created then a more permanent; pointer will point to it, which frequently is part of another heap; object. See Resetting the Interpreter Environment in the chapter; ""Cling the C++ Interpreter"".; ",MatchSource.DOCS,documentation/users-guide/ALittleC++.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md:10560,Usability,learn,learn,10560,"ue of the; pointer is set equal to. ``` {.cpp}; new Quad(1.,2.,-3.);; ```. `new`, despite its looks, is an operator and creates an object or; variable of the type that comes next, `Quad` in this case, on the; heap. Just as with stack objects it has to be initialized by calling; its constructor. The syntax requires that the argument list follows the; type. This one statement has brought two items into existence, one on; the heap and one on the stack. The heap object will live until the; delete operator is applied to it. There is no FORTRAN parallel to a heap object; variables either come; or go as control passes in and out of a function or subroutine, or,; like a COMMON block variables, live for the lifetime of the program.; However, most people in HEP who use FORTRAN will have experience of a; memory manager and the act of creating a bank is a good equivalent of; a heap object. For those who know systems like ZEBRA, it will come as; a relief to learn that objects do not move, C++ does not garbage; collect, so there is never a danger that a pointer to an object; becomes invalid for that reason. However, having created an object,; it is the user's responsibility to ensure that it is deleted when no; longer needed, or to pass that responsibility onto to some other; object. Failing to do that will result in a memory leak, one of the; most common and most hard-to-find C++ bugs. To send a message to an object via a pointer to it, you need to use; the ""`->`"" operator e.g.:. ``` {.cpp}; root[] my_objptr->Solve();; ```. Although we chose to call our pointer `my_objptr`, to emphasize that; it is a pointer, heap objects are so common in an object-oriented; program that pointer names rarely reflect the fact - you have to be; careful that you know if you are dealing with an object or its; pointer! Fortunately, the compiler won't tolerate an attempt to do; something like:. ``` {.cpp}; root[] my_objptr.Solve();; ```. As we have seen, heap objects; have to be accessed via pointers,",MatchSource.DOCS,documentation/users-guide/ALittleC++.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md:9698,Availability,error,error,9698," ""gone"". Since histograms (and trees) are added to the list of objects; in the current directory, you can always retrieve them to delete them; if needed. ``` {.cpp}; root[] TH1F *h = (TH1F*)gDirectory->Get(""myHist""); // or; root[] TH1F *h = (TH1F*)gDirectory->GetList()->FindObject(""myHist"");; ```. In addition, histograms and trees are automatically deleted when the; current directory is closed. This will automatically take care of the; clean up. See ""Input/Output"". ### Executing a Script From a Script. You may want to execute a script conditionally inside another script.; To do it you need to call the interpreter and you can do that with; `TROOT::ProcessLine()`. The example; `$ROOTSYS/tutorials/tree/cernstaff.C` calls a script to build the root; file if it does not exist:. ``` {.cpp}; void cernstaff() {; if (gSystem->AccessPathName(""cernstaff.root"")) {; gROOT->ProcessLine("".x cernbuild.C"");; }; ```. `ProcessLine` takes a parameter, which is a pointer to an `int` or to; a `TInterpreter::EErrorCode` to let you access the interpreter error; code after an attempt to interpret. This will contain the error; as defined in `enum TInterpreter::EErrorCode` with `TInterpreter::kSuccess` being; the value for a successful execution. ### Executing a Script From the Invocation. Instead if starting ROOT and running a script on the prompt you can also pass; it to ROOT in its invocation:. ```; $ root -l -b 'myCode.C(""some String"", 12)'; ```. The exact kind of quoting depends on your shell; the one shown here works for; bash-like shells. ROOT can evaluate any expression as part of the invocation; another version of; the previous example can be spelled like this:. ```; $ root -l -b -e 'gROOT->ProcessLine("".x myCode.C(\""some String\"", 12)"");'; ```. ## C++ Extensions To Ease Scripting. In the next example, we demonstrate three of the most important; extensions ROOT and Cling make to C++. Start ROOT in the directory; `$ROOTSYS/tutorials` (make sure to have first run `.x hsimple.C`):. ``` {",MatchSource.DOCS,documentation/users-guide/Cling.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md:9763,Availability,error,error,9763,"; root[] TH1F *h = (TH1F*)gDirectory->Get(""myHist""); // or; root[] TH1F *h = (TH1F*)gDirectory->GetList()->FindObject(""myHist"");; ```. In addition, histograms and trees are automatically deleted when the; current directory is closed. This will automatically take care of the; clean up. See ""Input/Output"". ### Executing a Script From a Script. You may want to execute a script conditionally inside another script.; To do it you need to call the interpreter and you can do that with; `TROOT::ProcessLine()`. The example; `$ROOTSYS/tutorials/tree/cernstaff.C` calls a script to build the root; file if it does not exist:. ``` {.cpp}; void cernstaff() {; if (gSystem->AccessPathName(""cernstaff.root"")) {; gROOT->ProcessLine("".x cernbuild.C"");; }; ```. `ProcessLine` takes a parameter, which is a pointer to an `int` or to; a `TInterpreter::EErrorCode` to let you access the interpreter error; code after an attempt to interpret. This will contain the error; as defined in `enum TInterpreter::EErrorCode` with `TInterpreter::kSuccess` being; the value for a successful execution. ### Executing a Script From the Invocation. Instead if starting ROOT and running a script on the prompt you can also pass; it to ROOT in its invocation:. ```; $ root -l -b 'myCode.C(""some String"", 12)'; ```. The exact kind of quoting depends on your shell; the one shown here works for; bash-like shells. ROOT can evaluate any expression as part of the invocation; another version of; the previous example can be spelled like this:. ```; $ root -l -b -e 'gROOT->ProcessLine("".x myCode.C(\""some String\"", 12)"");'; ```. ## C++ Extensions To Ease Scripting. In the next example, we demonstrate three of the most important; extensions ROOT and Cling make to C++. Start ROOT in the directory; `$ROOTSYS/tutorials` (make sure to have first run `.x hsimple.C`):. ``` {.cpp}; root [0] f = new TFile(""hsimple.root""); (class TFile *) 0x4045e690; root [1] f->ls(); TFile** hsimple.root; TFile* hsimple.root; KEY: TH1F hpx;1 This is the",MatchSource.DOCS,documentation/users-guide/Cling.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md:20229,Availability,error,errors,20229,"of your script. The default behavior of `rootcling` is to; not link in (i.e. generate the dictionary for) any of the symbols. In; particular, this means that the following lines are, in the; general case, unnecessary. ``` {.cpp}; #pragma link off all globals;; #pragma link off all classes;; #pragma link off all functions;; ```. This also means that linking the instantiation of a class template:. ``` {.cpp}; #pragma link C++ class mytemplate<int>;; ```. ONLY links this specific class. You need to; request the generation of the iterators explicitly. See the documentation of `rootcling` for details how `pragma` can be; used. NOTE: You should not call ACLiC with a script that has a function; called `main()`. ### Intermediate Steps and Files. ACLiC executes two steps and a third one if needed. These are:. - Calling `rootcling` to create a dictionary using `rootcling`.; - Calling the compiler to build the shared library from the script.; - If there are errors, it calls the compiler to build a dummy; executable to clearly report unresolved symbols. ACLiC makes a shared library with a dictionary containing the; classes and functions declared in the script. It also adds the; classes and functions declared in included files with the same name; as the script file and any of the following extensions: `.h`, `.hh`,; `.hpp`, `.hxx`, `.hPP`, `.hXX`. This means that, by default, you; cannot combine scripts from different files into one library by using; `#include` statements; you will need to compile each script; separately. In a future release, we plan to add the global variables; declared in the script to the dictionary also. If you are curious; about the specific calls, you can raise the ROOT debug level: gDebug=3; and ACLiC will print these steps. If you need to keep the intermediate; files around, for example when debugging the script using gdb, use; gDebug=7. ### Moving between Interpreter and Compiler. The best way to develop portable scripts is to make sure you can; always ru",MatchSource.DOCS,documentation/users-guide/Cling.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md:22402,Availability,avail,available,22402,"ling extensions and program around the Cling; limitations. When it is not possible or desirable to program around; the Cling limitations, you can use the C preprocessor symbols defined; for Cling and `rootcling`. The preprocessor symbol `__CLING__` is defined for both ROOT and; `rootcling`. The symbol `__ROOTCLING__` (and `__MAKECINT__` for backward; compatibility) is only defined in `rootcling`. Use `!defined(__CLING__) || defined(__ROOTCLING__)` to bracket code that; needs to be seen by the compiler and `rootcling`, but will be invisible; to the interpreter. Use `!defined(__CLING__) `to bracket code that should be seen only by; the compiler and not by Cling nor `rootcling. `For example, the following; will hide the declaration and initialization of the array `gArray`; from both Cling and `rootcling`. ``` {.cpp}; #if !defined(__CLING__); int gArray[] = { 2, 3, 4};; #endif; ```. Because ACLiC calls `rootcling` to build a dictionary, the declaration; of `gArray` will not be included in the dictionary, and consequently,; `gArray` will not be available at the command line even if ACLiC is; used. Cling and `rootcling` will ignore all statements between the; `""#if !defined` `(__CLING__)""` and ""`#endif""`. If you want to use; `gArray` in the same script as its declaration, you can do so.; However, if you want use the script in the interpreter you have to; bracket the usage of `gArray` between `#if's,` since the definition is; not visible. If you add the following preprocessor statements:. ``` {.cpp}; #if !defined(__CLING__); int gArray[] = { 2, 3, 4};; #elif defined(__ROOTCLING__); int gArray[];; #endif; ```. `gArray` will be visible to `rootcling` but still not visible to Cling.; If you use ACLiC, `gArray` will be available at the command line and; be initialized properly by the compiled code. We recommend you always write scripts with the needed include; statements. In most cases, the script will still run with the; interpreter. However, a few header files are not handle",MatchSource.DOCS,documentation/users-guide/Cling.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md:23084,Availability,avail,available,23084,"f the array `gArray`; from both Cling and `rootcling`. ``` {.cpp}; #if !defined(__CLING__); int gArray[] = { 2, 3, 4};; #endif; ```. Because ACLiC calls `rootcling` to build a dictionary, the declaration; of `gArray` will not be included in the dictionary, and consequently,; `gArray` will not be available at the command line even if ACLiC is; used. Cling and `rootcling` will ignore all statements between the; `""#if !defined` `(__CLING__)""` and ""`#endif""`. If you want to use; `gArray` in the same script as its declaration, you can do so.; However, if you want use the script in the interpreter you have to; bracket the usage of `gArray` between `#if's,` since the definition is; not visible. If you add the following preprocessor statements:. ``` {.cpp}; #if !defined(__CLING__); int gArray[] = { 2, 3, 4};; #elif defined(__ROOTCLING__); int gArray[];; #endif; ```. `gArray` will be visible to `rootcling` but still not visible to Cling.; If you use ACLiC, `gArray` will be available at the command line and; be initialized properly by the compiled code. We recommend you always write scripts with the needed include; statements. In most cases, the script will still run with the; interpreter. However, a few header files are not handled very well by; Cling. These types of headers can be included in interpreted and compiled; mode:. - The subset of standard C/C++ headers defined in; `$ROOTSYS/Cling/include.`. - Headers of classes defined in a previously loaded library; (including ROOT own). The defined class must have a name known to; ROOT (i.e. a class with a `ClassDef`). Hiding header files from `rootcling` that are necessary for the; compiler but optional for the interpreter can lead to a subtle but; fatal error. For example:. ``` {.cpp}; #ifndef __CLING__; #include ""TTree.h""; #else; class TTree;; #endif. class subTree : public TTree {; };; ```. In this case, `rootcling` does not have enough information about the; `TTree` class to produce the correct dictionary file. If you try; ",MatchSource.DOCS,documentation/users-guide/Cling.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md:23828,Availability,error,error,23828,",` since the definition is; not visible. If you add the following preprocessor statements:. ``` {.cpp}; #if !defined(__CLING__); int gArray[] = { 2, 3, 4};; #elif defined(__ROOTCLING__); int gArray[];; #endif; ```. `gArray` will be visible to `rootcling` but still not visible to Cling.; If you use ACLiC, `gArray` will be available at the command line and; be initialized properly by the compiled code. We recommend you always write scripts with the needed include; statements. In most cases, the script will still run with the; interpreter. However, a few header files are not handled very well by; Cling. These types of headers can be included in interpreted and compiled; mode:. - The subset of standard C/C++ headers defined in; `$ROOTSYS/Cling/include.`. - Headers of classes defined in a previously loaded library; (including ROOT own). The defined class must have a name known to; ROOT (i.e. a class with a `ClassDef`). Hiding header files from `rootcling` that are necessary for the; compiler but optional for the interpreter can lead to a subtle but; fatal error. For example:. ``` {.cpp}; #ifndef __CLING__; #include ""TTree.h""; #else; class TTree;; #endif. class subTree : public TTree {; };; ```. In this case, `rootcling` does not have enough information about the; `TTree` class to produce the correct dictionary file. If you try; this, `rootcling` and compiling will be error free, however,; instantiating a `subTree` object from the Cling command line will cause; a fatal error. In general, it is recommended to let `rootcling` see as; many header files as possible. ## Classes Defined By Scripts. Lets create a small class `TMyClass` and a derived class; `TChild`. The virtual method `TMyClass::Print() `is overridden in; `TChild`. Save this in file called `script4.C`. ``` {.cpp}; #include <iostream.h>. class TMyClass {; private:; float fX; //x position in centimeters; float fY; //y position in centimeters; public:; TMyClass() { fX = fY = -1; }; virtual void Print() const;; void",MatchSource.DOCS,documentation/users-guide/Cling.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md:24146,Availability,error,error,24146,"end you always write scripts with the needed include; statements. In most cases, the script will still run with the; interpreter. However, a few header files are not handled very well by; Cling. These types of headers can be included in interpreted and compiled; mode:. - The subset of standard C/C++ headers defined in; `$ROOTSYS/Cling/include.`. - Headers of classes defined in a previously loaded library; (including ROOT own). The defined class must have a name known to; ROOT (i.e. a class with a `ClassDef`). Hiding header files from `rootcling` that are necessary for the; compiler but optional for the interpreter can lead to a subtle but; fatal error. For example:. ``` {.cpp}; #ifndef __CLING__; #include ""TTree.h""; #else; class TTree;; #endif. class subTree : public TTree {; };; ```. In this case, `rootcling` does not have enough information about the; `TTree` class to produce the correct dictionary file. If you try; this, `rootcling` and compiling will be error free, however,; instantiating a `subTree` object from the Cling command line will cause; a fatal error. In general, it is recommended to let `rootcling` see as; many header files as possible. ## Classes Defined By Scripts. Lets create a small class `TMyClass` and a derived class; `TChild`. The virtual method `TMyClass::Print() `is overridden in; `TChild`. Save this in file called `script4.C`. ``` {.cpp}; #include <iostream.h>. class TMyClass {; private:; float fX; //x position in centimeters; float fY; //y position in centimeters; public:; TMyClass() { fX = fY = -1; }; virtual void Print() const;; void SetX(float x) { fX = x; }; void SetY(float y) { fY = y; }; };; void TMyClass::Print() const // parent print method; {; cout << ""fX = "" << fX << "", fY = "" << fY << endl;; }; class TChild : public TMyClass {; public:; void Print() const;; };; void TChild::Print() const // child print metod; {; cout << ""This is TChild::Print()"" << endl;; TMyClass::Print();; }; ```. To execute `script4.C` do:. ``` {.cpp}; root[] ",MatchSource.DOCS,documentation/users-guide/Cling.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md:24249,Availability,error,error,24249,"end you always write scripts with the needed include; statements. In most cases, the script will still run with the; interpreter. However, a few header files are not handled very well by; Cling. These types of headers can be included in interpreted and compiled; mode:. - The subset of standard C/C++ headers defined in; `$ROOTSYS/Cling/include.`. - Headers of classes defined in a previously loaded library; (including ROOT own). The defined class must have a name known to; ROOT (i.e. a class with a `ClassDef`). Hiding header files from `rootcling` that are necessary for the; compiler but optional for the interpreter can lead to a subtle but; fatal error. For example:. ``` {.cpp}; #ifndef __CLING__; #include ""TTree.h""; #else; class TTree;; #endif. class subTree : public TTree {; };; ```. In this case, `rootcling` does not have enough information about the; `TTree` class to produce the correct dictionary file. If you try; this, `rootcling` and compiling will be error free, however,; instantiating a `subTree` object from the Cling command line will cause; a fatal error. In general, it is recommended to let `rootcling` see as; many header files as possible. ## Classes Defined By Scripts. Lets create a small class `TMyClass` and a derived class; `TChild`. The virtual method `TMyClass::Print() `is overridden in; `TChild`. Save this in file called `script4.C`. ``` {.cpp}; #include <iostream.h>. class TMyClass {; private:; float fX; //x position in centimeters; float fY; //y position in centimeters; public:; TMyClass() { fX = fY = -1; }; virtual void Print() const;; void SetX(float x) { fX = x; }; void SetY(float y) { fY = y; }; };; void TMyClass::Print() const // parent print method; {; cout << ""fX = "" << fX << "", fY = "" << fY << endl;; }; class TChild : public TMyClass {; public:; void Print() const;; };; void TChild::Print() const // child print metod; {; cout << ""This is TChild::Print()"" << endl;; TMyClass::Print();; }; ```. To execute `script4.C` do:. ``` {.cpp}; root[] ",MatchSource.DOCS,documentation/users-guide/Cling.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md:689,Deployability,patch,patches,689,"# The C++ Interpreter Cling; \index{cling}. ROOT has a C++ interpreter called *cling* built in. It is used for the prompt, both C++ and; Python. It also serves as a source of information to store C++ objects, and; provides the back-end for ROOT's signal/slot and plug-in mechanisms. This chapter focuses on the parts of *cling* that you will encounter while; interacting with ROOT. ## The ROOT Prompt. Start up a ROOT session by typing `root` at the system prompt. ``` {.cpp}; $ root; -------------------------------------------------------------------------; | Welcome to ROOT 6.10/01 http://root.cern.ch |; | (c) 1995-2017, The ROOT Team |; | Built for macosx64 |; | From heads/v6-10-00-patches@v6-10-00-25-g9f78c3a, Jul 03 2017, 11:39:44 |; | Try '.help', '.demo', '.license', '.credits', '.quit'/'.q' |; -------------------------------------------------------------------------. root [0]; ```. Now we create a `TLine` object:. ``` {.cpp}; root [1] TLine l;; root [2] l.Print(); TLine X1=0.000000 Y1=0.000000 X2=0.000000 Y2=0.000000; root [3] l.SetX1(10); root [4] l.SetY1(11); root [5] l.Print(); TLine X1=10.000000 Y1=11.000000 X2=0.000000 Y2=0.000000; root [6] .g l; .g l; ROOT_prompt_0 1 (address: NA) class TLine l, size = 72; root [7] l.GetX1();; root [8] l.GetX1(); (Double_t) 1.000000e+01; ```. Note some of the features of the ROOT prompt:; - Terminating with ‘`;`‘ is not required, see ""C++ Extensions To Ease; Scripting"" below.; - `Emacs` style command line editing.; - Raw interpreter commands start with a dot; `.g l` for instance shows the; interpreter information on the global called `l`.; - To show the result of an expression just do not type the trailing `;`. For the further examples we will ""abbreviate"" `root [0]` etc by `root []`. ``` {.cpp}; root [] .class TLine; ===========================================================================; class TLine; SIZE: 72 FILE: TLine.h LINE: 39; Base classes: --------------------------------------------------------; 0x20 public TAt",MatchSource.DOCS,documentation/users-guide/Cling.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md:20814,Deployability,release,release,20814,"ling` for details how `pragma` can be; used. NOTE: You should not call ACLiC with a script that has a function; called `main()`. ### Intermediate Steps and Files. ACLiC executes two steps and a third one if needed. These are:. - Calling `rootcling` to create a dictionary using `rootcling`.; - Calling the compiler to build the shared library from the script.; - If there are errors, it calls the compiler to build a dummy; executable to clearly report unresolved symbols. ACLiC makes a shared library with a dictionary containing the; classes and functions declared in the script. It also adds the; classes and functions declared in included files with the same name; as the script file and any of the following extensions: `.h`, `.hh`,; `.hpp`, `.hxx`, `.hPP`, `.hXX`. This means that, by default, you; cannot combine scripts from different files into one library by using; `#include` statements; you will need to compile each script; separately. In a future release, we plan to add the global variables; declared in the script to the dictionary also. If you are curious; about the specific calls, you can raise the ROOT debug level: gDebug=3; and ACLiC will print these steps. If you need to keep the intermediate; files around, for example when debugging the script using gdb, use; gDebug=7. ### Moving between Interpreter and Compiler. The best way to develop portable scripts is to make sure you can; always run them with both, the interpreter and with ACLiC. To do so,; do not use the Cling extensions and program around the Cling; limitations. When it is not possible or desirable to program around; the Cling limitations, you can use the C preprocessor symbols defined; for Cling and `rootcling`. The preprocessor symbol `__CLING__` is defined for both ROOT and; `rootcling`. The symbol `__ROOTCLING__` (and `__MAKECINT__` for backward; compatibility) is only defined in `rootcling`. Use `!defined(__CLING__) || defined(__ROOTCLING__)` to bracket code that; needs to be seen by the compiler a",MatchSource.DOCS,documentation/users-guide/Cling.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md:10125,Integrability,depend,depends,10125,"om a Script. You may want to execute a script conditionally inside another script.; To do it you need to call the interpreter and you can do that with; `TROOT::ProcessLine()`. The example; `$ROOTSYS/tutorials/tree/cernstaff.C` calls a script to build the root; file if it does not exist:. ``` {.cpp}; void cernstaff() {; if (gSystem->AccessPathName(""cernstaff.root"")) {; gROOT->ProcessLine("".x cernbuild.C"");; }; ```. `ProcessLine` takes a parameter, which is a pointer to an `int` or to; a `TInterpreter::EErrorCode` to let you access the interpreter error; code after an attempt to interpret. This will contain the error; as defined in `enum TInterpreter::EErrorCode` with `TInterpreter::kSuccess` being; the value for a successful execution. ### Executing a Script From the Invocation. Instead if starting ROOT and running a script on the prompt you can also pass; it to ROOT in its invocation:. ```; $ root -l -b 'myCode.C(""some String"", 12)'; ```. The exact kind of quoting depends on your shell; the one shown here works for; bash-like shells. ROOT can evaluate any expression as part of the invocation; another version of; the previous example can be spelled like this:. ```; $ root -l -b -e 'gROOT->ProcessLine("".x myCode.C(\""some String\"", 12)"");'; ```. ## C++ Extensions To Ease Scripting. In the next example, we demonstrate three of the most important; extensions ROOT and Cling make to C++. Start ROOT in the directory; `$ROOTSYS/tutorials` (make sure to have first run `.x hsimple.C`):. ``` {.cpp}; root [0] f = new TFile(""hsimple.root""); (class TFile *) 0x4045e690; root [1] f->ls(); TFile** hsimple.root; TFile* hsimple.root; KEY: TH1F hpx;1 This is the px distribution; KEY: TH2F hpxpy;1 py ps px; KEY: THProfile hprof;1 Profile of pz versus px; KEY: TNtuple ntuple;1 Demo ntuple; root [2] hpx->Draw(); Warning in <MakeDefCanvas>: creating a default canvas with name c1; root [3] .q; ```. The `root [0]` command shows the first extension; the declaration of `f`; may be omitted as a s",MatchSource.DOCS,documentation/users-guide/Cling.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md:14218,Integrability,depend,dependency,14218,"er options that were used to; compile the ROOT executable. You do not have to write a Makefile; remembering the correct compiler options, and you do not have to exit; ROOT. ### Usage. Before you can compile your interpreted script you need to add include; statements for the classes used in the script. Once you did that, you; can build and load a shared library containing your script. To load it; use the command `.L` and append the file name with a `+`. ``` {.cpp}; root[] .L MyScript.C+; ```. The + option generates the shared library and names it by taking; the name of the file ""filename"" but replacing the dot before the; extension by an underscore and by adding the shared library extension; for the current platform. For example on most platforms, `hsimple.cxx`; will generate `hsimple_cxx.so`. The + command rebuild the library only if the script or any of the; files it includes are newer than the library. When checking the; timestamp, ACLiC generates a dependency file which name is the same as; the library name, just replacing the 'so' extension by the extension; 'd'. For example on most platforms, `hsimple.cxx` will generate; `hsimple_cxx.d`. To ensure that the shared library is rebuilt you can use the ++; syntax:. ``` {.cpp}; root[] .L MyScript.C++; ```. To build, load, and execute the function with the same name as the; file you can use the `.x` command. This is the same as executing a; named script; you can also provide parameters. The only; difference is you need to append a + or a ++. ``` {.cpp}; root[] .x MyScript.C+(4000); Creating shared library /home/./MyScript_C.so; ```. You can select whether the script in compiled with debug symbol or; with optimization by appending the letter 'g' or 'O' after the '+' or; '++'. Without the specification, the script is compiled with the same; level of debugging symbol and optimization as the currently running; ROOT executable. For example:. ``` {.cpp}; root[] .L MyScript.C++g; ```. will compile `MyScript.C` with debug sym",MatchSource.DOCS,documentation/users-guide/Cling.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md:18447,Integrability,interface,interface,18447,"rms; like OSF, this does not HAVE to be an executable) containing the; script. It uses the directive `fMakeExe` to do so. For both; directives, before passing them to `TSystem::Exec()`, it expands the; variables `$SourceFiles`, `$SharedLib`, `$LibName`, `$IncludePath`,; `$LinkedLibs`, `$ExeName `and` $ObjectFiles`. See `SetMakeSharedLib()`; for more information on those variables. When the file being passed to; ACLiC is on a read only file system, ACLiC warns the user and creates; the library in a temporary directory:. ``` {.cpp}; root[] .L readonly/t.C++; Warning in <ACLiC>: /scratch/aclic/subs/./readonly is not writable!; Warning in <ACLiC>: Output will be written to /tmp; Info in <TUnixSystem::ACLiC>: creating shared library; /tmp//scratch/aclic/subs/./readonly/t_C.so; ```. To select the temporary directory ACLiC looks at `$TEMP`, `$TEMP_DIR`,; `$TEMPDIR`, `$TMP`, `$TMPDIR`, `$TMP_DIR `or uses `/tmp (`or `C:/)`.; Also, a new interface `TSystem::Get/SetBuildDir` is introduced; to let users select an alternative 'root' for building of the ACLiC; libraries. For `filename/full/path/name/macro.C`, the library is; created as `fBuildDir/full/path/name/macro_C.so.`. ### Dictionary Generation. You can direct what is added to the dictionary generated by ACLiC in; two ways. The simplest way is to add at the end of script (i.e. after; the symbols have been defined) something like:. ``` {.cpp}; #if defined(__ROOTCLING__); #pragma link C++ class MyOtherClass;; #endif; ```. You can also write this portion of code in a file name; `MyScript_linkdef.h` where the suffix `'_linkdef' `is the prefix; defined by the key `‘ACLiC.Linkdef`‘ in the currently used resource; file (usually `.rootrc `or` $ROOTSYS/etc/system.rootrc`) and the; prefix is the name of your script. The default behavior of `rootcling` is to; not link in (i.e. generate the dictionary for) any of the symbols. In; particular, this means that the following lines are, in the; general case, unnecessary. ``` {.cpp}; #pragma ",MatchSource.DOCS,documentation/users-guide/Cling.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md:263,Modifiability,plug-in,plug-in,263,"# The C++ Interpreter Cling; \index{cling}. ROOT has a C++ interpreter called *cling* built in. It is used for the prompt, both C++ and; Python. It also serves as a source of information to store C++ objects, and; provides the back-end for ROOT's signal/slot and plug-in mechanisms. This chapter focuses on the parts of *cling* that you will encounter while; interacting with ROOT. ## The ROOT Prompt. Start up a ROOT session by typing `root` at the system prompt. ``` {.cpp}; $ root; -------------------------------------------------------------------------; | Welcome to ROOT 6.10/01 http://root.cern.ch |; | (c) 1995-2017, The ROOT Team |; | Built for macosx64 |; | From heads/v6-10-00-patches@v6-10-00-25-g9f78c3a, Jul 03 2017, 11:39:44 |; | Try '.help', '.demo', '.license', '.credits', '.quit'/'.q' |; -------------------------------------------------------------------------. root [0]; ```. Now we create a `TLine` object:. ``` {.cpp}; root [1] TLine l;; root [2] l.Print(); TLine X1=0.000000 Y1=0.000000 X2=0.000000 Y2=0.000000; root [3] l.SetX1(10); root [4] l.SetY1(11); root [5] l.Print(); TLine X1=10.000000 Y1=11.000000 X2=0.000000 Y2=0.000000; root [6] .g l; .g l; ROOT_prompt_0 1 (address: NA) class TLine l, size = 72; root [7] l.GetX1();; root [8] l.GetX1(); (Double_t) 1.000000e+01; ```. Note some of the features of the ROOT prompt:; - Terminating with ‘`;`‘ is not required, see ""C++ Extensions To Ease; Scripting"" below.; - `Emacs` style command line editing.; - Raw interpreter commands start with a dot; `.g l` for instance shows the; interpreter information on the global called `l`.; - To show the result of an expression just do not type the trailing `;`. For the further examples we will ""abbreviate"" `root [0]` etc by `root []`. ``` {.cpp}; root [] .class TLine; ===========================================================================; class TLine; SIZE: 72 FILE: TLine.h LINE: 39; Base classes: --------------------------------------------------------; 0x20 public TAt",MatchSource.DOCS,documentation/users-guide/Cling.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md:2025,Modifiability,variab,variables,2025,"00 Y1=0.000000 X2=0.000000 Y2=0.000000; root [3] l.SetX1(10); root [4] l.SetY1(11); root [5] l.Print(); TLine X1=10.000000 Y1=11.000000 X2=0.000000 Y2=0.000000; root [6] .g l; .g l; ROOT_prompt_0 1 (address: NA) class TLine l, size = 72; root [7] l.GetX1();; root [8] l.GetX1(); (Double_t) 1.000000e+01; ```. Note some of the features of the ROOT prompt:; - Terminating with ‘`;`‘ is not required, see ""C++ Extensions To Ease; Scripting"" below.; - `Emacs` style command line editing.; - Raw interpreter commands start with a dot; `.g l` for instance shows the; interpreter information on the global called `l`.; - To show the result of an expression just do not type the trailing `;`. For the further examples we will ""abbreviate"" `root [0]` etc by `root []`. ``` {.cpp}; root [] .class TLine; ===========================================================================; class TLine; SIZE: 72 FILE: TLine.h LINE: 39; Base classes: --------------------------------------------------------; 0x20 public TAttBBox2D; List of member variables --------------------------------------------------; TLine.h 42 0x28 protected: Double_t fX1; TLine.h 43 0x30 protected: Double_t fY1; TLine.h 44 0x38 protected: Double_t fX2; TLine.h 45 0x40 protected: Double_t fY2; TLine.h 50 0x0 public: enum TLine::<anonymous at /home/axel/build/root/trunk/obj/include/TLine.h:49:4> kLineNDC; TLine.h 51 0x0 public: enum TLine::<anonymous at /home/axel/build/root/trunk/obj/include/TLine.h:49:4> kVertical; TLine.h 52 0x0 public: enum TLine::<anonymous at /home/axel/build/root/trunk/obj/include/TLine.h:49:4> kHorizontal; TLine.h 94 0x0 private: static class TClass *fgIsA; List of member functions :---------------------------------------------------; filename line:size busy function type and name; (compiled) (NA):(NA) 0 public: TLine();; (compiled) (NA):(NA) 0 public: TLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2);; (compiled) (NA):(NA) 0 public: TLine(const TLine &line);; (compiled) (NA):(NA) 0 public: virt",MatchSource.DOCS,documentation/users-guide/Cling.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md:17707,Modifiability,variab,variables,17707,"so overwrite the existing include path:. ``` {.cpp}; gSystem->SetIncludePath("" -I$HOME/mypackage/include ""); ```. The `$ROOTSYS/include` directory is automatically appended to the; include path, so you do not have to worry about including it. To add; library that should be used during linking of the shared library use; something like:. ``` {.cpp}; gSystem->AddLinkedLibs(""-L/my/path -lanylib"");; ```. This is especially useful for static libraries. For shared ones you; can also simply load them before trying to compile the script:. ``` {.cpp}; gSystem->Load(""mydir/mylib"");; ```. ACLiC uses the directive `fMakeSharedLibs` to create the shared; library. If loading the shared library fails, it tries to output a; list of missing symbols by creating an executable (on some platforms; like OSF, this does not HAVE to be an executable) containing the; script. It uses the directive `fMakeExe` to do so. For both; directives, before passing them to `TSystem::Exec()`, it expands the; variables `$SourceFiles`, `$SharedLib`, `$LibName`, `$IncludePath`,; `$LinkedLibs`, `$ExeName `and` $ObjectFiles`. See `SetMakeSharedLib()`; for more information on those variables. When the file being passed to; ACLiC is on a read only file system, ACLiC warns the user and creates; the library in a temporary directory:. ``` {.cpp}; root[] .L readonly/t.C++; Warning in <ACLiC>: /scratch/aclic/subs/./readonly is not writable!; Warning in <ACLiC>: Output will be written to /tmp; Info in <TUnixSystem::ACLiC>: creating shared library; /tmp//scratch/aclic/subs/./readonly/t_C.so; ```. To select the temporary directory ACLiC looks at `$TEMP`, `$TEMP_DIR`,; `$TEMPDIR`, `$TMP`, `$TMPDIR`, `$TMP_DIR `or uses `/tmp (`or `C:/)`.; Also, a new interface `TSystem::Get/SetBuildDir` is introduced; to let users select an alternative 'root' for building of the ACLiC; libraries. For `filename/full/path/name/macro.C`, the library is; created as `fBuildDir/full/path/name/macro_C.so.`. ### Dictionary Generation. You can dire",MatchSource.DOCS,documentation/users-guide/Cling.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md:17878,Modifiability,variab,variables,17878,"lude` directory is automatically appended to the; include path, so you do not have to worry about including it. To add; library that should be used during linking of the shared library use; something like:. ``` {.cpp}; gSystem->AddLinkedLibs(""-L/my/path -lanylib"");; ```. This is especially useful for static libraries. For shared ones you; can also simply load them before trying to compile the script:. ``` {.cpp}; gSystem->Load(""mydir/mylib"");; ```. ACLiC uses the directive `fMakeSharedLibs` to create the shared; library. If loading the shared library fails, it tries to output a; list of missing symbols by creating an executable (on some platforms; like OSF, this does not HAVE to be an executable) containing the; script. It uses the directive `fMakeExe` to do so. For both; directives, before passing them to `TSystem::Exec()`, it expands the; variables `$SourceFiles`, `$SharedLib`, `$LibName`, `$IncludePath`,; `$LinkedLibs`, `$ExeName `and` $ObjectFiles`. See `SetMakeSharedLib()`; for more information on those variables. When the file being passed to; ACLiC is on a read only file system, ACLiC warns the user and creates; the library in a temporary directory:. ``` {.cpp}; root[] .L readonly/t.C++; Warning in <ACLiC>: /scratch/aclic/subs/./readonly is not writable!; Warning in <ACLiC>: Output will be written to /tmp; Info in <TUnixSystem::ACLiC>: creating shared library; /tmp//scratch/aclic/subs/./readonly/t_C.so; ```. To select the temporary directory ACLiC looks at `$TEMP`, `$TEMP_DIR`,; `$TEMPDIR`, `$TMP`, `$TMPDIR`, `$TMP_DIR `or uses `/tmp (`or `C:/)`.; Also, a new interface `TSystem::Get/SetBuildDir` is introduced; to let users select an alternative 'root' for building of the ACLiC; libraries. For `filename/full/path/name/macro.C`, the library is; created as `fBuildDir/full/path/name/macro_C.so.`. ### Dictionary Generation. You can direct what is added to the dictionary generated by ACLiC in; two ways. The simplest way is to add at the end of script (i.e. after; th",MatchSource.DOCS,documentation/users-guide/Cling.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md:20849,Modifiability,variab,variables,20849,"ling` for details how `pragma` can be; used. NOTE: You should not call ACLiC with a script that has a function; called `main()`. ### Intermediate Steps and Files. ACLiC executes two steps and a third one if needed. These are:. - Calling `rootcling` to create a dictionary using `rootcling`.; - Calling the compiler to build the shared library from the script.; - If there are errors, it calls the compiler to build a dummy; executable to clearly report unresolved symbols. ACLiC makes a shared library with a dictionary containing the; classes and functions declared in the script. It also adds the; classes and functions declared in included files with the same name; as the script file and any of the following extensions: `.h`, `.hh`,; `.hpp`, `.hxx`, `.hPP`, `.hXX`. This means that, by default, you; cannot combine scripts from different files into one library by using; `#include` statements; you will need to compile each script; separately. In a future release, we plan to add the global variables; declared in the script to the dictionary also. If you are curious; about the specific calls, you can raise the ROOT debug level: gDebug=3; and ACLiC will print these steps. If you need to keep the intermediate; files around, for example when debugging the script using gdb, use; gDebug=7. ### Moving between Interpreter and Compiler. The best way to develop portable scripts is to make sure you can; always run them with both, the interpreter and with ACLiC. To do so,; do not use the Cling extensions and program around the Cling; limitations. When it is not possible or desirable to program around; the Cling limitations, you can use the C preprocessor symbols defined; for Cling and `rootcling`. The preprocessor symbol `__CLING__` is defined for both ROOT and; `rootcling`. The symbol `__ROOTCLING__` (and `__MAKECINT__` for backward; compatibility) is only defined in `rootcling`. Use `!defined(__CLING__) || defined(__ROOTCLING__)` to bracket code that; needs to be seen by the compiler a",MatchSource.DOCS,documentation/users-guide/Cling.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md:21218,Modifiability,portab,portable,21218,"ler to build a dummy; executable to clearly report unresolved symbols. ACLiC makes a shared library with a dictionary containing the; classes and functions declared in the script. It also adds the; classes and functions declared in included files with the same name; as the script file and any of the following extensions: `.h`, `.hh`,; `.hpp`, `.hxx`, `.hPP`, `.hXX`. This means that, by default, you; cannot combine scripts from different files into one library by using; `#include` statements; you will need to compile each script; separately. In a future release, we plan to add the global variables; declared in the script to the dictionary also. If you are curious; about the specific calls, you can raise the ROOT debug level: gDebug=3; and ACLiC will print these steps. If you need to keep the intermediate; files around, for example when debugging the script using gdb, use; gDebug=7. ### Moving between Interpreter and Compiler. The best way to develop portable scripts is to make sure you can; always run them with both, the interpreter and with ACLiC. To do so,; do not use the Cling extensions and program around the Cling; limitations. When it is not possible or desirable to program around; the Cling limitations, you can use the C preprocessor symbols defined; for Cling and `rootcling`. The preprocessor symbol `__CLING__` is defined for both ROOT and; `rootcling`. The symbol `__ROOTCLING__` (and `__MAKECINT__` for backward; compatibility) is only defined in `rootcling`. Use `!defined(__CLING__) || defined(__ROOTCLING__)` to bracket code that; needs to be seen by the compiler and `rootcling`, but will be invisible; to the interpreter. Use `!defined(__CLING__) `to bracket code that should be seen only by; the compiler and not by Cling nor `rootcling. `For example, the following; will hide the declaration and initialization of the array `gArray`; from both Cling and `rootcling`. ``` {.cpp}; #if !defined(__CLING__); int gArray[] = { 2, 3, 4};; #endif; ```. Because ACLiC call",MatchSource.DOCS,documentation/users-guide/Cling.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md:25582,Modifiability,variab,variable,25582,"/y position in centimeters; public:; TMyClass() { fX = fY = -1; }; virtual void Print() const;; void SetX(float x) { fX = x; }; void SetY(float y) { fY = y; }; };; void TMyClass::Print() const // parent print method; {; cout << ""fX = "" << fX << "", fY = "" << fY << endl;; }; class TChild : public TMyClass {; public:; void Print() const;; };; void TChild::Print() const // child print metod; {; cout << ""This is TChild::Print()"" << endl;; TMyClass::Print();; }; ```. To execute `script4.C` do:. ``` {.cpp}; root[] .L script4.C; root[] TMyClass *a = new TChild; root[] a->Print(); This is TChild::Print(); fX = -1, fY = -1; root[] a->SetX(10); root[] a->SetY(12); root[] a->Print(); This is TChild::Print(); fX = 10, fY = 12; root[] .class TMyClass; =====================================================; class TMyClass; size=0x8 FILE:script4.C LINE:3; List of base class-----------------------------------; List of member variable------------------------------; Defined in TMyClass; 0x0 private: float fX; 0x4 private: float fY; List of member function------------------------------; Defined in TMyClass; filename line:size busy function type and name; script4.C 16:5 0 public: class TMyClass TMyClass(void);; script4.C 22:4 0 public: void Print(void);; script4.C 12:1 0 public: void SetX(float x);; script4.C 13:1 0 public: void SetY(float y);; root[] .q; ```. As you can see, an interpreted class behaves just like a compiled; class.; See ""Adding a Class"" for ways how to add a class with a shared library; and with ACLiC. ## Inspecting Objects. An object of a class inheriting from `TObject` can be inspected,; with the `Inspect()` method. The `TObject::Inspect` method creates a; window listing the current values of the objects members. For example,; the next picture is of `TFile`. ``` {.cpp}; root[] TFile f(""staff.root""); root[] f.Inspect(); ```. You can see the pointers are in red and can be clicked on to follow; the pointer to the object. If you clicked on `fList`, the list of; objects in ",MatchSource.DOCS,documentation/users-guide/Cling.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md:26229,Modifiability,inherit,inheriting,26229,"ic TMyClass {; public:; void Print() const;; };; void TChild::Print() const // child print metod; {; cout << ""This is TChild::Print()"" << endl;; TMyClass::Print();; }; ```. To execute `script4.C` do:. ``` {.cpp}; root[] .L script4.C; root[] TMyClass *a = new TChild; root[] a->Print(); This is TChild::Print(); fX = -1, fY = -1; root[] a->SetX(10); root[] a->SetY(12); root[] a->Print(); This is TChild::Print(); fX = 10, fY = 12; root[] .class TMyClass; =====================================================; class TMyClass; size=0x8 FILE:script4.C LINE:3; List of base class-----------------------------------; List of member variable------------------------------; Defined in TMyClass; 0x0 private: float fX; 0x4 private: float fY; List of member function------------------------------; Defined in TMyClass; filename line:size busy function type and name; script4.C 16:5 0 public: class TMyClass TMyClass(void);; script4.C 22:4 0 public: void Print(void);; script4.C 12:1 0 public: void SetX(float x);; script4.C 13:1 0 public: void SetY(float y);; root[] .q; ```. As you can see, an interpreted class behaves just like a compiled; class.; See ""Adding a Class"" for ways how to add a class with a shared library; and with ACLiC. ## Inspecting Objects. An object of a class inheriting from `TObject` can be inspected,; with the `Inspect()` method. The `TObject::Inspect` method creates a; window listing the current values of the objects members. For example,; the next picture is of `TFile`. ``` {.cpp}; root[] TFile f(""staff.root""); root[] f.Inspect(); ```. You can see the pointers are in red and can be clicked on to follow; the pointer to the object. If you clicked on `fList`, the list of; objects in memory and there were none, no new canvas would be shown.; On top of the page are the navigation buttons to see the previous and; next screen. ![ROOT object inspector of TFile](pictures/03000092.png). ![The object inspector of `fKeys`, the list of keys in the memory](pictures/03000093.png); ",MatchSource.DOCS,documentation/users-guide/Cling.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md:7881,Performance,load,loads,7881,"Line X1=0.000000 Y1=1.000000 X2=0.000000 Y2=0.000000; TLine X1=1.000000 Y1=2.000000 X2=0.000000 Y2=0.000000; TLine X1=2.000000 Y1=3.000000 X2=0.000000 Y2=0.000000; TLine X1=3.000000 Y1=4.000000 X2=0.000000 Y2=0.000000; TLine X1=4.000000 Y1=5.000000 X2=0.000000 Y2=0.000000; root [] .q; ```. Here we note:. - A multi-line command starts with a { and ends with a }.; - Inside continuation, every line has to be correctly terminated with a ; (like in ""real''; C++).; - All objects are created in *global* scope.; - There is no way to back up; you are better off writing a script.; - Use `.q` to exit root. ## Feeding Sources Files To ROOT: C++ Scripts. ROOT script files (often called ""Macros"") contain pure C++ code. They can contain a simple; sequence of statements like in the multi command line example given; above, but also arbitrarily complex class and function definitions. The most frequent interaction with the ROOT prompt uses `.x` to ""run"" a file:. ```; root [] .x myScript.C; ```. This loads myScript.C into the interpreter and calls the function `myScript()`.; You can pass arguments using `.x myScript.C(12, ""A String"")`. Alternatively you can load the script and then run a function explicitly:. ```; root [] .L myScript.C; root [] myScript(); ```. The above is equivalent to `.x myScript.C`. In a named script, the objects created on the stack are deleted when; the function exits. In a common scenario you; create a histogram in a named script on the stack. You draw the; histogram, but when the function exits the canvas is empty and the; histogram has disappeared. To avoid the histogram from disappearing you can; create it on the heap (by using new). This will leave the histogram; object intact, but the pointer in the named script scope will be; ""gone"". Since histograms (and trees) are added to the list of objects; in the current directory, you can always retrieve them to delete them; if needed. ``` {.cpp}; root[] TH1F *h = (TH1F*)gDirectory->Get(""myHist""); // or; root[] TH1F",MatchSource.DOCS,documentation/users-guide/Cling.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md:8041,Performance,load,load,8041,"X1=3.000000 Y1=4.000000 X2=0.000000 Y2=0.000000; TLine X1=4.000000 Y1=5.000000 X2=0.000000 Y2=0.000000; root [] .q; ```. Here we note:. - A multi-line command starts with a { and ends with a }.; - Inside continuation, every line has to be correctly terminated with a ; (like in ""real''; C++).; - All objects are created in *global* scope.; - There is no way to back up; you are better off writing a script.; - Use `.q` to exit root. ## Feeding Sources Files To ROOT: C++ Scripts. ROOT script files (often called ""Macros"") contain pure C++ code. They can contain a simple; sequence of statements like in the multi command line example given; above, but also arbitrarily complex class and function definitions. The most frequent interaction with the ROOT prompt uses `.x` to ""run"" a file:. ```; root [] .x myScript.C; ```. This loads myScript.C into the interpreter and calls the function `myScript()`.; You can pass arguments using `.x myScript.C(12, ""A String"")`. Alternatively you can load the script and then run a function explicitly:. ```; root [] .L myScript.C; root [] myScript(); ```. The above is equivalent to `.x myScript.C`. In a named script, the objects created on the stack are deleted when; the function exits. In a common scenario you; create a histogram in a named script on the stack. You draw the; histogram, but when the function exits the canvas is empty and the; histogram has disappeared. To avoid the histogram from disappearing you can; create it on the heap (by using new). This will leave the histogram; object intact, but the pointer in the named script scope will be; ""gone"". Since histograms (and trees) are added to the list of objects; in the current directory, you can always retrieve them to delete them; if needed. ``` {.cpp}; root[] TH1F *h = (TH1F*)gDirectory->Get(""myHist""); // or; root[] TH1F *h = (TH1F*)gDirectory->GetList()->FindObject(""myHist"");; ```. In addition, histograms and trees are automatically deleted when the; current directory is closed. This wi",MatchSource.DOCS,documentation/users-guide/Cling.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md:12704,Performance,load,loaded,12704,"sted; member function. This shortcut is quite natural for an interactive; system and saves much typing. In this example, ROOT searches for `hpx`; and finds it in `hsimple.root.`. The next, fundamental extension is shown below. There is no need to put a semicolon at; the end of a line. When you leave it off the value of the expression will; be printed on the next line. For example:. ``` {.cpp}; root[] 23+5; (int)28; root[] 23+5;; root[] TMath::Sin; (Double_t (*)(Double_t)) Function @0x7ffff7ebb090; at include/TMath.h:418:; inline Double_t TMath::Sin(Double_t x); { return sin(x); }; ```. Be aware that these extensions do not work when a compiler replaces; the interpreter. Your code will not compile, hence when writing large; scripts, it is best to stay away from these shortcuts. It will save; you from having problems compiling your scripts using a real C++; compiler. ## ACLiC: Compiling Scripts Into Libraries. Instead of having Cling interpret your script there is a way to have your; scripts compiled, linked and dynamically loaded using the C++ compiler; and linker. The advantage of this is that your scripts will run with the; speed of compiled C++ and that you can use language constructs that are; not fully supported by Cling. On the other hand, you cannot use any Cling; shortcuts (see ""C++ Extensions To Ease Scripting"" above) and for small scripts, the; overhead of the compile/link cycle might be larger than just executing; the script in the interpreter. ACLiC will build a dictionary and a shared library from your C++; script, using the compiler and the compiler options that were used to; compile the ROOT executable. You do not have to write a Makefile; remembering the correct compiler options, and you do not have to exit; ROOT. ### Usage. Before you can compile your interpreted script you need to add include; statements for the classes used in the script. Once you did that, you; can build and load a shared library containing your script. To load it; use the command ",MatchSource.DOCS,documentation/users-guide/Cling.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md:13593,Performance,load,load,13593,"of having Cling interpret your script there is a way to have your; scripts compiled, linked and dynamically loaded using the C++ compiler; and linker. The advantage of this is that your scripts will run with the; speed of compiled C++ and that you can use language constructs that are; not fully supported by Cling. On the other hand, you cannot use any Cling; shortcuts (see ""C++ Extensions To Ease Scripting"" above) and for small scripts, the; overhead of the compile/link cycle might be larger than just executing; the script in the interpreter. ACLiC will build a dictionary and a shared library from your C++; script, using the compiler and the compiler options that were used to; compile the ROOT executable. You do not have to write a Makefile; remembering the correct compiler options, and you do not have to exit; ROOT. ### Usage. Before you can compile your interpreted script you need to add include; statements for the classes used in the script. Once you did that, you; can build and load a shared library containing your script. To load it; use the command `.L` and append the file name with a `+`. ``` {.cpp}; root[] .L MyScript.C+; ```. The + option generates the shared library and names it by taking; the name of the file ""filename"" but replacing the dot before the; extension by an underscore and by adding the shared library extension; for the current platform. For example on most platforms, `hsimple.cxx`; will generate `hsimple_cxx.so`. The + command rebuild the library only if the script or any of the; files it includes are newer than the library. When checking the; timestamp, ACLiC generates a dependency file which name is the same as; the library name, just replacing the 'so' extension by the extension; 'd'. For example on most platforms, `hsimple.cxx` will generate; `hsimple_cxx.d`. To ensure that the shared library is rebuilt you can use the ++; syntax:. ``` {.cpp}; root[] .L MyScript.C++; ```. To build, load, and execute the function with the same name as the; ",MatchSource.DOCS,documentation/users-guide/Cling.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md:13642,Performance,load,load,13642,"ave your; scripts compiled, linked and dynamically loaded using the C++ compiler; and linker. The advantage of this is that your scripts will run with the; speed of compiled C++ and that you can use language constructs that are; not fully supported by Cling. On the other hand, you cannot use any Cling; shortcuts (see ""C++ Extensions To Ease Scripting"" above) and for small scripts, the; overhead of the compile/link cycle might be larger than just executing; the script in the interpreter. ACLiC will build a dictionary and a shared library from your C++; script, using the compiler and the compiler options that were used to; compile the ROOT executable. You do not have to write a Makefile; remembering the correct compiler options, and you do not have to exit; ROOT. ### Usage. Before you can compile your interpreted script you need to add include; statements for the classes used in the script. Once you did that, you; can build and load a shared library containing your script. To load it; use the command `.L` and append the file name with a `+`. ``` {.cpp}; root[] .L MyScript.C+; ```. The + option generates the shared library and names it by taking; the name of the file ""filename"" but replacing the dot before the; extension by an underscore and by adding the shared library extension; for the current platform. For example on most platforms, `hsimple.cxx`; will generate `hsimple_cxx.so`. The + command rebuild the library only if the script or any of the; files it includes are newer than the library. When checking the; timestamp, ACLiC generates a dependency file which name is the same as; the library name, just replacing the 'so' extension by the extension; 'd'. For example on most platforms, `hsimple.cxx` will generate; `hsimple_cxx.d`. To ensure that the shared library is rebuilt you can use the ++; syntax:. ``` {.cpp}; root[] .L MyScript.C++; ```. To build, load, and execute the function with the same name as the; file you can use the `.x` command. This is the same as exe",MatchSource.DOCS,documentation/users-guide/Cling.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md:14538,Performance,load,load,14538," you; can build and load a shared library containing your script. To load it; use the command `.L` and append the file name with a `+`. ``` {.cpp}; root[] .L MyScript.C+; ```. The + option generates the shared library and names it by taking; the name of the file ""filename"" but replacing the dot before the; extension by an underscore and by adding the shared library extension; for the current platform. For example on most platforms, `hsimple.cxx`; will generate `hsimple_cxx.so`. The + command rebuild the library only if the script or any of the; files it includes are newer than the library. When checking the; timestamp, ACLiC generates a dependency file which name is the same as; the library name, just replacing the 'so' extension by the extension; 'd'. For example on most platforms, `hsimple.cxx` will generate; `hsimple_cxx.d`. To ensure that the shared library is rebuilt you can use the ++; syntax:. ``` {.cpp}; root[] .L MyScript.C++; ```. To build, load, and execute the function with the same name as the; file you can use the `.x` command. This is the same as executing a; named script; you can also provide parameters. The only; difference is you need to append a + or a ++. ``` {.cpp}; root[] .x MyScript.C+(4000); Creating shared library /home/./MyScript_C.so; ```. You can select whether the script in compiled with debug symbol or; with optimization by appending the letter 'g' or 'O' after the '+' or; '++'. Without the specification, the script is compiled with the same; level of debugging symbol and optimization as the currently running; ROOT executable. For example:. ``` {.cpp}; root[] .L MyScript.C++g; ```. will compile `MyScript.C` with debug symbols; usually this means; giving the `-g` option to compiler. ``` {.cpp}; root[] .L MyScript.C++O; ```. will compile `MyScript.C` with optimizations; usually this means; giving the `-O` option to compiler. The syntax:. ``` {.cpp}; root[] .L MyScript.C++; ```. is using the default optimization level. The initial default ",MatchSource.DOCS,documentation/users-guide/Cling.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md:14933,Performance,optimiz,optimization,14933,"d library extension; for the current platform. For example on most platforms, `hsimple.cxx`; will generate `hsimple_cxx.so`. The + command rebuild the library only if the script or any of the; files it includes are newer than the library. When checking the; timestamp, ACLiC generates a dependency file which name is the same as; the library name, just replacing the 'so' extension by the extension; 'd'. For example on most platforms, `hsimple.cxx` will generate; `hsimple_cxx.d`. To ensure that the shared library is rebuilt you can use the ++; syntax:. ``` {.cpp}; root[] .L MyScript.C++; ```. To build, load, and execute the function with the same name as the; file you can use the `.x` command. This is the same as executing a; named script; you can also provide parameters. The only; difference is you need to append a + or a ++. ``` {.cpp}; root[] .x MyScript.C+(4000); Creating shared library /home/./MyScript_C.so; ```. You can select whether the script in compiled with debug symbol or; with optimization by appending the letter 'g' or 'O' after the '+' or; '++'. Without the specification, the script is compiled with the same; level of debugging symbol and optimization as the currently running; ROOT executable. For example:. ``` {.cpp}; root[] .L MyScript.C++g; ```. will compile `MyScript.C` with debug symbols; usually this means; giving the `-g` option to compiler. ``` {.cpp}; root[] .L MyScript.C++O; ```. will compile `MyScript.C` with optimizations; usually this means; giving the `-O` option to compiler. The syntax:. ``` {.cpp}; root[] .L MyScript.C++; ```. is using the default optimization level. The initial default is to; compile with the same level of optimization as the root executable; itself. The default can be changed by:. ``` {.cpp}; root[] gSystem->SetAclicMode(TSystem::kDebug);; root[] gSystem->SetAclicMode(TSystem::kOpt);; ```. Note that the commands:. ``` {.cpp}; root[] .L MyScript.C+g; root[] .L MyScript.C+O; ```. respectively compile `MyScript.C` with debu",MatchSource.DOCS,documentation/users-guide/Cling.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md:15100,Performance,optimiz,optimization,15100,"he library only if the script or any of the; files it includes are newer than the library. When checking the; timestamp, ACLiC generates a dependency file which name is the same as; the library name, just replacing the 'so' extension by the extension; 'd'. For example on most platforms, `hsimple.cxx` will generate; `hsimple_cxx.d`. To ensure that the shared library is rebuilt you can use the ++; syntax:. ``` {.cpp}; root[] .L MyScript.C++; ```. To build, load, and execute the function with the same name as the; file you can use the `.x` command. This is the same as executing a; named script; you can also provide parameters. The only; difference is you need to append a + or a ++. ``` {.cpp}; root[] .x MyScript.C+(4000); Creating shared library /home/./MyScript_C.so; ```. You can select whether the script in compiled with debug symbol or; with optimization by appending the letter 'g' or 'O' after the '+' or; '++'. Without the specification, the script is compiled with the same; level of debugging symbol and optimization as the currently running; ROOT executable. For example:. ``` {.cpp}; root[] .L MyScript.C++g; ```. will compile `MyScript.C` with debug symbols; usually this means; giving the `-g` option to compiler. ``` {.cpp}; root[] .L MyScript.C++O; ```. will compile `MyScript.C` with optimizations; usually this means; giving the `-O` option to compiler. The syntax:. ``` {.cpp}; root[] .L MyScript.C++; ```. is using the default optimization level. The initial default is to; compile with the same level of optimization as the root executable; itself. The default can be changed by:. ``` {.cpp}; root[] gSystem->SetAclicMode(TSystem::kDebug);; root[] gSystem->SetAclicMode(TSystem::kOpt);; ```. Note that the commands:. ``` {.cpp}; root[] .L MyScript.C+g; root[] .L MyScript.C+O; ```. respectively compile `MyScript.C` with debug and optimization if the; library does not exist yet; they will not change the debug and the; optimization level if the library already exist and i",MatchSource.DOCS,documentation/users-guide/Cling.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md:15387,Performance,optimiz,optimizations,15387,"sure that the shared library is rebuilt you can use the ++; syntax:. ``` {.cpp}; root[] .L MyScript.C++; ```. To build, load, and execute the function with the same name as the; file you can use the `.x` command. This is the same as executing a; named script; you can also provide parameters. The only; difference is you need to append a + or a ++. ``` {.cpp}; root[] .x MyScript.C+(4000); Creating shared library /home/./MyScript_C.so; ```. You can select whether the script in compiled with debug symbol or; with optimization by appending the letter 'g' or 'O' after the '+' or; '++'. Without the specification, the script is compiled with the same; level of debugging symbol and optimization as the currently running; ROOT executable. For example:. ``` {.cpp}; root[] .L MyScript.C++g; ```. will compile `MyScript.C` with debug symbols; usually this means; giving the `-g` option to compiler. ``` {.cpp}; root[] .L MyScript.C++O; ```. will compile `MyScript.C` with optimizations; usually this means; giving the `-O` option to compiler. The syntax:. ``` {.cpp}; root[] .L MyScript.C++; ```. is using the default optimization level. The initial default is to; compile with the same level of optimization as the root executable; itself. The default can be changed by:. ``` {.cpp}; root[] gSystem->SetAclicMode(TSystem::kDebug);; root[] gSystem->SetAclicMode(TSystem::kOpt);; ```. Note that the commands:. ``` {.cpp}; root[] .L MyScript.C+g; root[] .L MyScript.C+O; ```. respectively compile `MyScript.C` with debug and optimization if the; library does not exist yet; they will not change the debug and the; optimization level if the library already exist and it is up to date.; To use ACLiC from compiled code or from inside another macro, we; recommend using `gROOT->ProcessLine()`. For; example, in one script you can use ACLiC to compile and load another; script. ``` {.cpp}; gROOT->ProcessLine("".L MyScript.C+""); gROOT->ProcessLine("".L MyScript.C++""); ```. ### Setting the Include Path. You can",MatchSource.DOCS,documentation/users-guide/Cling.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md:15533,Performance,optimiz,optimization,15533,"build, load, and execute the function with the same name as the; file you can use the `.x` command. This is the same as executing a; named script; you can also provide parameters. The only; difference is you need to append a + or a ++. ``` {.cpp}; root[] .x MyScript.C+(4000); Creating shared library /home/./MyScript_C.so; ```. You can select whether the script in compiled with debug symbol or; with optimization by appending the letter 'g' or 'O' after the '+' or; '++'. Without the specification, the script is compiled with the same; level of debugging symbol and optimization as the currently running; ROOT executable. For example:. ``` {.cpp}; root[] .L MyScript.C++g; ```. will compile `MyScript.C` with debug symbols; usually this means; giving the `-g` option to compiler. ``` {.cpp}; root[] .L MyScript.C++O; ```. will compile `MyScript.C` with optimizations; usually this means; giving the `-O` option to compiler. The syntax:. ``` {.cpp}; root[] .L MyScript.C++; ```. is using the default optimization level. The initial default is to; compile with the same level of optimization as the root executable; itself. The default can be changed by:. ``` {.cpp}; root[] gSystem->SetAclicMode(TSystem::kDebug);; root[] gSystem->SetAclicMode(TSystem::kOpt);; ```. Note that the commands:. ``` {.cpp}; root[] .L MyScript.C+g; root[] .L MyScript.C+O; ```. respectively compile `MyScript.C` with debug and optimization if the; library does not exist yet; they will not change the debug and the; optimization level if the library already exist and it is up to date.; To use ACLiC from compiled code or from inside another macro, we; recommend using `gROOT->ProcessLine()`. For; example, in one script you can use ACLiC to compile and load another; script. ``` {.cpp}; gROOT->ProcessLine("".L MyScript.C+""); gROOT->ProcessLine("".L MyScript.C++""); ```. ### Setting the Include Path. You can get the include path by typing:. ``` {.cpp}; root[] .include; ```. You can append to the include path by typing:.",MatchSource.DOCS,documentation/users-guide/Cling.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md:15611,Performance,optimiz,optimization,15611,"u can use the `.x` command. This is the same as executing a; named script; you can also provide parameters. The only; difference is you need to append a + or a ++. ``` {.cpp}; root[] .x MyScript.C+(4000); Creating shared library /home/./MyScript_C.so; ```. You can select whether the script in compiled with debug symbol or; with optimization by appending the letter 'g' or 'O' after the '+' or; '++'. Without the specification, the script is compiled with the same; level of debugging symbol and optimization as the currently running; ROOT executable. For example:. ``` {.cpp}; root[] .L MyScript.C++g; ```. will compile `MyScript.C` with debug symbols; usually this means; giving the `-g` option to compiler. ``` {.cpp}; root[] .L MyScript.C++O; ```. will compile `MyScript.C` with optimizations; usually this means; giving the `-O` option to compiler. The syntax:. ``` {.cpp}; root[] .L MyScript.C++; ```. is using the default optimization level. The initial default is to; compile with the same level of optimization as the root executable; itself. The default can be changed by:. ``` {.cpp}; root[] gSystem->SetAclicMode(TSystem::kDebug);; root[] gSystem->SetAclicMode(TSystem::kOpt);; ```. Note that the commands:. ``` {.cpp}; root[] .L MyScript.C+g; root[] .L MyScript.C+O; ```. respectively compile `MyScript.C` with debug and optimization if the; library does not exist yet; they will not change the debug and the; optimization level if the library already exist and it is up to date.; To use ACLiC from compiled code or from inside another macro, we; recommend using `gROOT->ProcessLine()`. For; example, in one script you can use ACLiC to compile and load another; script. ``` {.cpp}; gROOT->ProcessLine("".L MyScript.C+""); gROOT->ProcessLine("".L MyScript.C++""); ```. ### Setting the Include Path. You can get the include path by typing:. ``` {.cpp}; root[] .include; ```. You can append to the include path by typing:. ``` {.cpp}; root[] .include $HOME/mypackage/include; ```. In a script y",MatchSource.DOCS,documentation/users-guide/Cling.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md:15938,Performance,optimiz,optimization,15938,"hout the specification, the script is compiled with the same; level of debugging symbol and optimization as the currently running; ROOT executable. For example:. ``` {.cpp}; root[] .L MyScript.C++g; ```. will compile `MyScript.C` with debug symbols; usually this means; giving the `-g` option to compiler. ``` {.cpp}; root[] .L MyScript.C++O; ```. will compile `MyScript.C` with optimizations; usually this means; giving the `-O` option to compiler. The syntax:. ``` {.cpp}; root[] .L MyScript.C++; ```. is using the default optimization level. The initial default is to; compile with the same level of optimization as the root executable; itself. The default can be changed by:. ``` {.cpp}; root[] gSystem->SetAclicMode(TSystem::kDebug);; root[] gSystem->SetAclicMode(TSystem::kOpt);; ```. Note that the commands:. ``` {.cpp}; root[] .L MyScript.C+g; root[] .L MyScript.C+O; ```. respectively compile `MyScript.C` with debug and optimization if the; library does not exist yet; they will not change the debug and the; optimization level if the library already exist and it is up to date.; To use ACLiC from compiled code or from inside another macro, we; recommend using `gROOT->ProcessLine()`. For; example, in one script you can use ACLiC to compile and load another; script. ``` {.cpp}; gROOT->ProcessLine("".L MyScript.C+""); gROOT->ProcessLine("".L MyScript.C++""); ```. ### Setting the Include Path. You can get the include path by typing:. ``` {.cpp}; root[] .include; ```. You can append to the include path by typing:. ``` {.cpp}; root[] .include $HOME/mypackage/include; ```. In a script you can append to the include path:. ``` {.cpp}; gSystem->AddIncludePath("" -I$HOME/mypackage/include ""); ```. You can also overwrite the existing include path:. ``` {.cpp}; gSystem->SetIncludePath("" -I$HOME/mypackage/include ""); ```. The `$ROOTSYS/include` directory is automatically appended to the; include path, so you do not have to worry about including it. To add; library that should be used during",MatchSource.DOCS,documentation/users-guide/Cling.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md:16027,Performance,optimiz,optimization,16027,"hout the specification, the script is compiled with the same; level of debugging symbol and optimization as the currently running; ROOT executable. For example:. ``` {.cpp}; root[] .L MyScript.C++g; ```. will compile `MyScript.C` with debug symbols; usually this means; giving the `-g` option to compiler. ``` {.cpp}; root[] .L MyScript.C++O; ```. will compile `MyScript.C` with optimizations; usually this means; giving the `-O` option to compiler. The syntax:. ``` {.cpp}; root[] .L MyScript.C++; ```. is using the default optimization level. The initial default is to; compile with the same level of optimization as the root executable; itself. The default can be changed by:. ``` {.cpp}; root[] gSystem->SetAclicMode(TSystem::kDebug);; root[] gSystem->SetAclicMode(TSystem::kOpt);; ```. Note that the commands:. ``` {.cpp}; root[] .L MyScript.C+g; root[] .L MyScript.C+O; ```. respectively compile `MyScript.C` with debug and optimization if the; library does not exist yet; they will not change the debug and the; optimization level if the library already exist and it is up to date.; To use ACLiC from compiled code or from inside another macro, we; recommend using `gROOT->ProcessLine()`. For; example, in one script you can use ACLiC to compile and load another; script. ``` {.cpp}; gROOT->ProcessLine("".L MyScript.C+""); gROOT->ProcessLine("".L MyScript.C++""); ```. ### Setting the Include Path. You can get the include path by typing:. ``` {.cpp}; root[] .include; ```. You can append to the include path by typing:. ``` {.cpp}; root[] .include $HOME/mypackage/include; ```. In a script you can append to the include path:. ``` {.cpp}; gSystem->AddIncludePath("" -I$HOME/mypackage/include ""); ```. You can also overwrite the existing include path:. ``` {.cpp}; gSystem->SetIncludePath("" -I$HOME/mypackage/include ""); ```. The `$ROOTSYS/include` directory is automatically appended to the; include path, so you do not have to worry about including it. To add; library that should be used during",MatchSource.DOCS,documentation/users-guide/Cling.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md:16265,Performance,load,load,16265,"ebug symbols; usually this means; giving the `-g` option to compiler. ``` {.cpp}; root[] .L MyScript.C++O; ```. will compile `MyScript.C` with optimizations; usually this means; giving the `-O` option to compiler. The syntax:. ``` {.cpp}; root[] .L MyScript.C++; ```. is using the default optimization level. The initial default is to; compile with the same level of optimization as the root executable; itself. The default can be changed by:. ``` {.cpp}; root[] gSystem->SetAclicMode(TSystem::kDebug);; root[] gSystem->SetAclicMode(TSystem::kOpt);; ```. Note that the commands:. ``` {.cpp}; root[] .L MyScript.C+g; root[] .L MyScript.C+O; ```. respectively compile `MyScript.C` with debug and optimization if the; library does not exist yet; they will not change the debug and the; optimization level if the library already exist and it is up to date.; To use ACLiC from compiled code or from inside another macro, we; recommend using `gROOT->ProcessLine()`. For; example, in one script you can use ACLiC to compile and load another; script. ``` {.cpp}; gROOT->ProcessLine("".L MyScript.C+""); gROOT->ProcessLine("".L MyScript.C++""); ```. ### Setting the Include Path. You can get the include path by typing:. ``` {.cpp}; root[] .include; ```. You can append to the include path by typing:. ``` {.cpp}; root[] .include $HOME/mypackage/include; ```. In a script you can append to the include path:. ``` {.cpp}; gSystem->AddIncludePath("" -I$HOME/mypackage/include ""); ```. You can also overwrite the existing include path:. ``` {.cpp}; gSystem->SetIncludePath("" -I$HOME/mypackage/include ""); ```. The `$ROOTSYS/include` directory is automatically appended to the; include path, so you do not have to worry about including it. To add; library that should be used during linking of the shared library use; something like:. ``` {.cpp}; gSystem->AddLinkedLibs(""-L/my/path -lanylib"");; ```. This is especially useful for static libraries. For shared ones you; can also simply load them before trying to compile",MatchSource.DOCS,documentation/users-guide/Cling.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md:17211,Performance,load,load,17211,"e, in one script you can use ACLiC to compile and load another; script. ``` {.cpp}; gROOT->ProcessLine("".L MyScript.C+""); gROOT->ProcessLine("".L MyScript.C++""); ```. ### Setting the Include Path. You can get the include path by typing:. ``` {.cpp}; root[] .include; ```. You can append to the include path by typing:. ``` {.cpp}; root[] .include $HOME/mypackage/include; ```. In a script you can append to the include path:. ``` {.cpp}; gSystem->AddIncludePath("" -I$HOME/mypackage/include ""); ```. You can also overwrite the existing include path:. ``` {.cpp}; gSystem->SetIncludePath("" -I$HOME/mypackage/include ""); ```. The `$ROOTSYS/include` directory is automatically appended to the; include path, so you do not have to worry about including it. To add; library that should be used during linking of the shared library use; something like:. ``` {.cpp}; gSystem->AddLinkedLibs(""-L/my/path -lanylib"");; ```. This is especially useful for static libraries. For shared ones you; can also simply load them before trying to compile the script:. ``` {.cpp}; gSystem->Load(""mydir/mylib"");; ```. ACLiC uses the directive `fMakeSharedLibs` to create the shared; library. If loading the shared library fails, it tries to output a; list of missing symbols by creating an executable (on some platforms; like OSF, this does not HAVE to be an executable) containing the; script. It uses the directive `fMakeExe` to do so. For both; directives, before passing them to `TSystem::Exec()`, it expands the; variables `$SourceFiles`, `$SharedLib`, `$LibName`, `$IncludePath`,; `$LinkedLibs`, `$ExeName `and` $ObjectFiles`. See `SetMakeSharedLib()`; for more information on those variables. When the file being passed to; ACLiC is on a read only file system, ACLiC warns the user and creates; the library in a temporary directory:. ``` {.cpp}; root[] .L readonly/t.C++; Warning in <ACLiC>: /scratch/aclic/subs/./readonly is not writable!; Warning in <ACLiC>: Output will be written to /tmp; Info in <TUnixSystem::ACLiC",MatchSource.DOCS,documentation/users-guide/Cling.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md:17384,Performance,load,loading,17384,"```. You can append to the include path by typing:. ``` {.cpp}; root[] .include $HOME/mypackage/include; ```. In a script you can append to the include path:. ``` {.cpp}; gSystem->AddIncludePath("" -I$HOME/mypackage/include ""); ```. You can also overwrite the existing include path:. ``` {.cpp}; gSystem->SetIncludePath("" -I$HOME/mypackage/include ""); ```. The `$ROOTSYS/include` directory is automatically appended to the; include path, so you do not have to worry about including it. To add; library that should be used during linking of the shared library use; something like:. ``` {.cpp}; gSystem->AddLinkedLibs(""-L/my/path -lanylib"");; ```. This is especially useful for static libraries. For shared ones you; can also simply load them before trying to compile the script:. ``` {.cpp}; gSystem->Load(""mydir/mylib"");; ```. ACLiC uses the directive `fMakeSharedLibs` to create the shared; library. If loading the shared library fails, it tries to output a; list of missing symbols by creating an executable (on some platforms; like OSF, this does not HAVE to be an executable) containing the; script. It uses the directive `fMakeExe` to do so. For both; directives, before passing them to `TSystem::Exec()`, it expands the; variables `$SourceFiles`, `$SharedLib`, `$LibName`, `$IncludePath`,; `$LinkedLibs`, `$ExeName `and` $ObjectFiles`. See `SetMakeSharedLib()`; for more information on those variables. When the file being passed to; ACLiC is on a read only file system, ACLiC warns the user and creates; the library in a temporary directory:. ``` {.cpp}; root[] .L readonly/t.C++; Warning in <ACLiC>: /scratch/aclic/subs/./readonly is not writable!; Warning in <ACLiC>: Output will be written to /tmp; Info in <TUnixSystem::ACLiC>: creating shared library; /tmp//scratch/aclic/subs/./readonly/t_C.so; ```. To select the temporary directory ACLiC looks at `$TEMP`, `$TEMP_DIR`,; `$TEMPDIR`, `$TMP`, `$TMPDIR`, `$TMP_DIR `or uses `/tmp (`or `C:/)`.; Also, a new interface `TSystem::Get/SetBuildDir",MatchSource.DOCS,documentation/users-guide/Cling.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md:23567,Performance,load,loaded,23567,"`. If you want to use; `gArray` in the same script as its declaration, you can do so.; However, if you want use the script in the interpreter you have to; bracket the usage of `gArray` between `#if's,` since the definition is; not visible. If you add the following preprocessor statements:. ``` {.cpp}; #if !defined(__CLING__); int gArray[] = { 2, 3, 4};; #elif defined(__ROOTCLING__); int gArray[];; #endif; ```. `gArray` will be visible to `rootcling` but still not visible to Cling.; If you use ACLiC, `gArray` will be available at the command line and; be initialized properly by the compiled code. We recommend you always write scripts with the needed include; statements. In most cases, the script will still run with the; interpreter. However, a few header files are not handled very well by; Cling. These types of headers can be included in interpreted and compiled; mode:. - The subset of standard C/C++ headers defined in; `$ROOTSYS/Cling/include.`. - Headers of classes defined in a previously loaded library; (including ROOT own). The defined class must have a name known to; ROOT (i.e. a class with a `ClassDef`). Hiding header files from `rootcling` that are necessary for the; compiler but optional for the interpreter can lead to a subtle but; fatal error. For example:. ``` {.cpp}; #ifndef __CLING__; #include ""TTree.h""; #else; class TTree;; #endif. class subTree : public TTree {; };; ```. In this case, `rootcling` does not have enough information about the; `TTree` class to produce the correct dictionary file. If you try; this, `rootcling` and compiling will be error free, however,; instantiating a `subTree` object from the Cling command line will cause; a fatal error. In general, it is recommended to let `rootcling` see as; many header files as possible. ## Classes Defined By Scripts. Lets create a small class `TMyClass` and a derived class; `TChild`. The virtual method `TMyClass::Print() `is overridden in; `TChild`. Save this in file called `script4.C`. ``` {.cpp}; #in",MatchSource.DOCS,documentation/users-guide/Cling.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md:6634,Safety,abort,abort,6634,"0 public: static const char *Class_Name();; (compiled) (NA):(NA) 0 public: static Version_t Class_Version();; (compiled) (NA):(NA) 0 public: static void Dictionary();; (compiled) (NA):(NA) 0 public: virtual class TClass *IsA() const;; (compiled) (NA):(NA) 0 public: virtual void ShowMembers(class TMemberInspector &insp) const;; (compiled) (NA):(NA) 0 public: virtual void Streamer(class TBuffer &);; (compiled) (NA):(NA) 0 public: void StreamerNVirtual(class TBuffer &ClassDef_StreamerNVirtual_b);; (compiled) (NA):(NA) 0 public: static const char *DeclFileName();; (compiled) (NA):(NA) 0 public: static int ImplFileLine();; (compiled) (NA):(NA) 0 public: static const char *ImplFileName();; (compiled) (NA):(NA) 0 public: static int DeclFileLine();; root [] .> test.log; root [] l.Dump();; root [] .>; root [] ?; ```. Here we see:. - Use `.class` as quick help and reference; - Unix like I/O redirection using `.> out.txt` and unredirection with `.>`; - Use `?` to get help on all ‘‘raw'' interpreter commands; - Use @ to abort a multi-line command. Now let us execute a multi-line command:. ``` {.cpp}; root [] {; root [] ? TLine l;; root [] ? for (int i = 0; i < 5; i++) {; root [] ? l.SetX1(i);; root [] ? l.SetY1(i+1);; root [] ? l.Print();; root [] ? }; root [] ? }; TLine X1=0.000000 Y1=1.000000 X2=0.000000 Y2=0.000000; TLine X1=1.000000 Y1=2.000000 X2=0.000000 Y2=0.000000; TLine X1=2.000000 Y1=3.000000 X2=0.000000 Y2=0.000000; TLine X1=3.000000 Y1=4.000000 X2=0.000000 Y2=0.000000; TLine X1=4.000000 Y1=5.000000 X2=0.000000 Y2=0.000000; root [] .q; ```. Here we note:. - A multi-line command starts with a { and ends with a }.; - Inside continuation, every line has to be correctly terminated with a ; (like in ""real''; C++).; - All objects are created in *global* scope.; - There is no way to back up; you are better off writing a script.; - Use `.q` to exit root. ## Feeding Sources Files To ROOT: C++ Scripts. ROOT script files (often called ""Macros"") contain pure C++ code. They can co",MatchSource.DOCS,documentation/users-guide/Cling.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md:8470,Safety,avoid,avoid,8470,"es To ROOT: C++ Scripts. ROOT script files (often called ""Macros"") contain pure C++ code. They can contain a simple; sequence of statements like in the multi command line example given; above, but also arbitrarily complex class and function definitions. The most frequent interaction with the ROOT prompt uses `.x` to ""run"" a file:. ```; root [] .x myScript.C; ```. This loads myScript.C into the interpreter and calls the function `myScript()`.; You can pass arguments using `.x myScript.C(12, ""A String"")`. Alternatively you can load the script and then run a function explicitly:. ```; root [] .L myScript.C; root [] myScript(); ```. The above is equivalent to `.x myScript.C`. In a named script, the objects created on the stack are deleted when; the function exits. In a common scenario you; create a histogram in a named script on the stack. You draw the; histogram, but when the function exits the canvas is empty and the; histogram has disappeared. To avoid the histogram from disappearing you can; create it on the heap (by using new). This will leave the histogram; object intact, but the pointer in the named script scope will be; ""gone"". Since histograms (and trees) are added to the list of objects; in the current directory, you can always retrieve them to delete them; if needed. ``` {.cpp}; root[] TH1F *h = (TH1F*)gDirectory->Get(""myHist""); // or; root[] TH1F *h = (TH1F*)gDirectory->GetList()->FindObject(""myHist"");; ```. In addition, histograms and trees are automatically deleted when the; current directory is closed. This will automatically take care of the; clean up. See ""Input/Output"". ### Executing a Script From a Script. You may want to execute a script conditionally inside another script.; To do it you need to call the interpreter and you can do that with; `TROOT::ProcessLine()`. The example; `$ROOTSYS/tutorials/tree/cernstaff.C` calls a script to build the root; file if it does not exist:. ``` {.cpp}; void cernstaff() {; if (gSystem->AccessPathName(""cernstaff.root",MatchSource.DOCS,documentation/users-guide/Cling.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md:9675,Security,access,access,9675," ""gone"". Since histograms (and trees) are added to the list of objects; in the current directory, you can always retrieve them to delete them; if needed. ``` {.cpp}; root[] TH1F *h = (TH1F*)gDirectory->Get(""myHist""); // or; root[] TH1F *h = (TH1F*)gDirectory->GetList()->FindObject(""myHist"");; ```. In addition, histograms and trees are automatically deleted when the; current directory is closed. This will automatically take care of the; clean up. See ""Input/Output"". ### Executing a Script From a Script. You may want to execute a script conditionally inside another script.; To do it you need to call the interpreter and you can do that with; `TROOT::ProcessLine()`. The example; `$ROOTSYS/tutorials/tree/cernstaff.C` calls a script to build the root; file if it does not exist:. ``` {.cpp}; void cernstaff() {; if (gSystem->AccessPathName(""cernstaff.root"")) {; gROOT->ProcessLine("".x cernbuild.C"");; }; ```. `ProcessLine` takes a parameter, which is a pointer to an `int` or to; a `TInterpreter::EErrorCode` to let you access the interpreter error; code after an attempt to interpret. This will contain the error; as defined in `enum TInterpreter::EErrorCode` with `TInterpreter::kSuccess` being; the value for a successful execution. ### Executing a Script From the Invocation. Instead if starting ROOT and running a script on the prompt you can also pass; it to ROOT in its invocation:. ```; $ root -l -b 'myCode.C(""some String"", 12)'; ```. The exact kind of quoting depends on your shell; the one shown here works for; bash-like shells. ROOT can evaluate any expression as part of the invocation; another version of; the previous example can be spelled like this:. ```; $ root -l -b -e 'gROOT->ProcessLine("".x myCode.C(\""some String\"", 12)"");'; ```. ## C++ Extensions To Ease Scripting. In the next example, we demonstrate three of the most important; extensions ROOT and Cling make to C++. Start ROOT in the directory; `$ROOTSYS/tutorials` (make sure to have first run `.x hsimple.C`):. ``` {",MatchSource.DOCS,documentation/users-guide/Cling.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md:6373,Testability,test,test,6373,"Int_t x);; (compiled) (NA):(NA) 0 public: virtual void SetBBoxY1(const Int_t y);; (compiled) (NA):(NA) 0 public: virtual void SetBBoxY2(const Int_t y);; (compiled) (NA):(NA) 0 public: static class TClass *Class();; (compiled) (NA):(NA) 0 public: static const char *Class_Name();; (compiled) (NA):(NA) 0 public: static Version_t Class_Version();; (compiled) (NA):(NA) 0 public: static void Dictionary();; (compiled) (NA):(NA) 0 public: virtual class TClass *IsA() const;; (compiled) (NA):(NA) 0 public: virtual void ShowMembers(class TMemberInspector &insp) const;; (compiled) (NA):(NA) 0 public: virtual void Streamer(class TBuffer &);; (compiled) (NA):(NA) 0 public: void StreamerNVirtual(class TBuffer &ClassDef_StreamerNVirtual_b);; (compiled) (NA):(NA) 0 public: static const char *DeclFileName();; (compiled) (NA):(NA) 0 public: static int ImplFileLine();; (compiled) (NA):(NA) 0 public: static const char *ImplFileName();; (compiled) (NA):(NA) 0 public: static int DeclFileLine();; root [] .> test.log; root [] l.Dump();; root [] .>; root [] ?; ```. Here we see:. - Use `.class` as quick help and reference; - Unix like I/O redirection using `.> out.txt` and unredirection with `.>`; - Use `?` to get help on all ‘‘raw'' interpreter commands; - Use @ to abort a multi-line command. Now let us execute a multi-line command:. ``` {.cpp}; root [] {; root [] ? TLine l;; root [] ? for (int i = 0; i < 5; i++) {; root [] ? l.SetX1(i);; root [] ? l.SetY1(i+1);; root [] ? l.Print();; root [] ? }; root [] ? }; TLine X1=0.000000 Y1=1.000000 X2=0.000000 Y2=0.000000; TLine X1=1.000000 Y1=2.000000 X2=0.000000 Y2=0.000000; TLine X1=2.000000 Y1=3.000000 X2=0.000000 Y2=0.000000; TLine X1=3.000000 Y1=4.000000 X2=0.000000 Y2=0.000000; TLine X1=4.000000 Y1=5.000000 X2=0.000000 Y2=0.000000; root [] .q; ```. Here we note:. - A multi-line command starts with a { and ends with a }.; - Inside continuation, every line has to be correctly terminated with a ; (like in ""real''; C++).; - All objects are created ",MatchSource.DOCS,documentation/users-guide/Cling.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md:6378,Testability,log,log,6378,"(compiled) (NA):(NA) 0 public: virtual void SetBBoxY1(const Int_t y);; (compiled) (NA):(NA) 0 public: virtual void SetBBoxY2(const Int_t y);; (compiled) (NA):(NA) 0 public: static class TClass *Class();; (compiled) (NA):(NA) 0 public: static const char *Class_Name();; (compiled) (NA):(NA) 0 public: static Version_t Class_Version();; (compiled) (NA):(NA) 0 public: static void Dictionary();; (compiled) (NA):(NA) 0 public: virtual class TClass *IsA() const;; (compiled) (NA):(NA) 0 public: virtual void ShowMembers(class TMemberInspector &insp) const;; (compiled) (NA):(NA) 0 public: virtual void Streamer(class TBuffer &);; (compiled) (NA):(NA) 0 public: void StreamerNVirtual(class TBuffer &ClassDef_StreamerNVirtual_b);; (compiled) (NA):(NA) 0 public: static const char *DeclFileName();; (compiled) (NA):(NA) 0 public: static int ImplFileLine();; (compiled) (NA):(NA) 0 public: static const char *ImplFileName();; (compiled) (NA):(NA) 0 public: static int DeclFileLine();; root [] .> test.log; root [] l.Dump();; root [] .>; root [] ?; ```. Here we see:. - Use `.class` as quick help and reference; - Unix like I/O redirection using `.> out.txt` and unredirection with `.>`; - Use `?` to get help on all ‘‘raw'' interpreter commands; - Use @ to abort a multi-line command. Now let us execute a multi-line command:. ``` {.cpp}; root [] {; root [] ? TLine l;; root [] ? for (int i = 0; i < 5; i++) {; root [] ? l.SetX1(i);; root [] ? l.SetY1(i+1);; root [] ? l.Print();; root [] ? }; root [] ? }; TLine X1=0.000000 Y1=1.000000 X2=0.000000 Y2=0.000000; TLine X1=1.000000 Y1=2.000000 X2=0.000000 Y2=0.000000; TLine X1=2.000000 Y1=3.000000 X2=0.000000 Y2=0.000000; TLine X1=3.000000 Y1=4.000000 X2=0.000000 Y2=0.000000; TLine X1=4.000000 Y1=5.000000 X2=0.000000 Y2=0.000000; root [] .q; ```. Here we note:. - A multi-line command starts with a { and ends with a }.; - Inside continuation, every line has to be correctly terminated with a ; (like in ""real''; C++).; - All objects are created in *global*",MatchSource.DOCS,documentation/users-guide/Cling.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md:7619,Usability,simpl,simple,7619,"a multi-line command:. ``` {.cpp}; root [] {; root [] ? TLine l;; root [] ? for (int i = 0; i < 5; i++) {; root [] ? l.SetX1(i);; root [] ? l.SetY1(i+1);; root [] ? l.Print();; root [] ? }; root [] ? }; TLine X1=0.000000 Y1=1.000000 X2=0.000000 Y2=0.000000; TLine X1=1.000000 Y1=2.000000 X2=0.000000 Y2=0.000000; TLine X1=2.000000 Y1=3.000000 X2=0.000000 Y2=0.000000; TLine X1=3.000000 Y1=4.000000 X2=0.000000 Y2=0.000000; TLine X1=4.000000 Y1=5.000000 X2=0.000000 Y2=0.000000; root [] .q; ```. Here we note:. - A multi-line command starts with a { and ends with a }.; - Inside continuation, every line has to be correctly terminated with a ; (like in ""real''; C++).; - All objects are created in *global* scope.; - There is no way to back up; you are better off writing a script.; - Use `.q` to exit root. ## Feeding Sources Files To ROOT: C++ Scripts. ROOT script files (often called ""Macros"") contain pure C++ code. They can contain a simple; sequence of statements like in the multi command line example given; above, but also arbitrarily complex class and function definitions. The most frequent interaction with the ROOT prompt uses `.x` to ""run"" a file:. ```; root [] .x myScript.C; ```. This loads myScript.C into the interpreter and calls the function `myScript()`.; You can pass arguments using `.x myScript.C(12, ""A String"")`. Alternatively you can load the script and then run a function explicitly:. ```; root [] .L myScript.C; root [] myScript(); ```. The above is equivalent to `.x myScript.C`. In a named script, the objects created on the stack are deleted when; the function exits. In a common scenario you; create a histogram in a named script on the stack. You draw the; histogram, but when the function exits the canvas is empty and the; histogram has disappeared. To avoid the histogram from disappearing you can; create it on the heap (by using new). This will leave the histogram; object intact, but the pointer in the named script scope will be; ""gone"". Since histograms (and",MatchSource.DOCS,documentation/users-guide/Cling.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md:17204,Usability,simpl,simply,17204,"e, in one script you can use ACLiC to compile and load another; script. ``` {.cpp}; gROOT->ProcessLine("".L MyScript.C+""); gROOT->ProcessLine("".L MyScript.C++""); ```. ### Setting the Include Path. You can get the include path by typing:. ``` {.cpp}; root[] .include; ```. You can append to the include path by typing:. ``` {.cpp}; root[] .include $HOME/mypackage/include; ```. In a script you can append to the include path:. ``` {.cpp}; gSystem->AddIncludePath("" -I$HOME/mypackage/include ""); ```. You can also overwrite the existing include path:. ``` {.cpp}; gSystem->SetIncludePath("" -I$HOME/mypackage/include ""); ```. The `$ROOTSYS/include` directory is automatically appended to the; include path, so you do not have to worry about including it. To add; library that should be used during linking of the shared library use; something like:. ``` {.cpp}; gSystem->AddLinkedLibs(""-L/my/path -lanylib"");; ```. This is especially useful for static libraries. For shared ones you; can also simply load them before trying to compile the script:. ``` {.cpp}; gSystem->Load(""mydir/mylib"");; ```. ACLiC uses the directive `fMakeSharedLibs` to create the shared; library. If loading the shared library fails, it tries to output a; list of missing symbols by creating an executable (on some platforms; like OSF, this does not HAVE to be an executable) containing the; script. It uses the directive `fMakeExe` to do so. For both; directives, before passing them to `TSystem::Exec()`, it expands the; variables `$SourceFiles`, `$SharedLib`, `$LibName`, `$IncludePath`,; `$LinkedLibs`, `$ExeName `and` $ObjectFiles`. See `SetMakeSharedLib()`; for more information on those variables. When the file being passed to; ACLiC is on a read only file system, ACLiC warns the user and creates; the library in a temporary directory:. ``` {.cpp}; root[] .L readonly/t.C++; Warning in <ACLiC>: /scratch/aclic/subs/./readonly is not writable!; Warning in <ACLiC>: Output will be written to /tmp; Info in <TUnixSystem::ACLiC",MatchSource.DOCS,documentation/users-guide/Cling.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md:18796,Usability,simpl,simplest,18796,"es`. See `SetMakeSharedLib()`; for more information on those variables. When the file being passed to; ACLiC is on a read only file system, ACLiC warns the user and creates; the library in a temporary directory:. ``` {.cpp}; root[] .L readonly/t.C++; Warning in <ACLiC>: /scratch/aclic/subs/./readonly is not writable!; Warning in <ACLiC>: Output will be written to /tmp; Info in <TUnixSystem::ACLiC>: creating shared library; /tmp//scratch/aclic/subs/./readonly/t_C.so; ```. To select the temporary directory ACLiC looks at `$TEMP`, `$TEMP_DIR`,; `$TEMPDIR`, `$TMP`, `$TMPDIR`, `$TMP_DIR `or uses `/tmp (`or `C:/)`.; Also, a new interface `TSystem::Get/SetBuildDir` is introduced; to let users select an alternative 'root' for building of the ACLiC; libraries. For `filename/full/path/name/macro.C`, the library is; created as `fBuildDir/full/path/name/macro_C.so.`. ### Dictionary Generation. You can direct what is added to the dictionary generated by ACLiC in; two ways. The simplest way is to add at the end of script (i.e. after; the symbols have been defined) something like:. ``` {.cpp}; #if defined(__ROOTCLING__); #pragma link C++ class MyOtherClass;; #endif; ```. You can also write this portion of code in a file name; `MyScript_linkdef.h` where the suffix `'_linkdef' `is the prefix; defined by the key `‘ACLiC.Linkdef`‘ in the currently used resource; file (usually `.rootrc `or` $ROOTSYS/etc/system.rootrc`) and the; prefix is the name of your script. The default behavior of `rootcling` is to; not link in (i.e. generate the dictionary for) any of the symbols. In; particular, this means that the following lines are, in the; general case, unnecessary. ``` {.cpp}; #pragma link off all globals;; #pragma link off all classes;; #pragma link off all functions;; ```. This also means that linking the instantiation of a class template:. ``` {.cpp}; #pragma link C++ class mytemplate<int>;; ```. ONLY links this specific class. You need to; request the generation of the iterators explici",MatchSource.DOCS,documentation/users-guide/Cling.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md:20291,Usability,clear,clearly,20291,"of your script. The default behavior of `rootcling` is to; not link in (i.e. generate the dictionary for) any of the symbols. In; particular, this means that the following lines are, in the; general case, unnecessary. ``` {.cpp}; #pragma link off all globals;; #pragma link off all classes;; #pragma link off all functions;; ```. This also means that linking the instantiation of a class template:. ``` {.cpp}; #pragma link C++ class mytemplate<int>;; ```. ONLY links this specific class. You need to; request the generation of the iterators explicitly. See the documentation of `rootcling` for details how `pragma` can be; used. NOTE: You should not call ACLiC with a script that has a function; called `main()`. ### Intermediate Steps and Files. ACLiC executes two steps and a third one if needed. These are:. - Calling `rootcling` to create a dictionary using `rootcling`.; - Calling the compiler to build the shared library from the script.; - If there are errors, it calls the compiler to build a dummy; executable to clearly report unresolved symbols. ACLiC makes a shared library with a dictionary containing the; classes and functions declared in the script. It also adds the; classes and functions declared in included files with the same name; as the script file and any of the following extensions: `.h`, `.hh`,; `.hpp`, `.hxx`, `.hPP`, `.hXX`. This means that, by default, you; cannot combine scripts from different files into one library by using; `#include` statements; you will need to compile each script; separately. In a future release, we plan to add the global variables; declared in the script to the dictionary also. If you are curious; about the specific calls, you can raise the ROOT debug level: gDebug=3; and ACLiC will print these steps. If you need to keep the intermediate; files around, for example when debugging the script using gdb, use; gDebug=7. ### Moving between Interpreter and Compiler. The best way to develop portable scripts is to make sure you can; always ru",MatchSource.DOCS,documentation/users-guide/Cling.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md:3531,Availability,avail,available,3531,"The user can force a collection to delete its objects, but that is; the user's choice. ### Determining the Class of Contained Objects. Most containers may hold heterogeneous collections of objects and then; it is left to the user to correctly cast the **`TObject`** pointer to; the right class. Casting to the wrong class will give wrong results and; may well crash the program! Therefore, the user has to be very careful.; Often a container only contains one class of objects, but if it really; contains a mixture, it is possible to ask each object about its class; using the `InheritsFrom` method. For example if `myObject` is a **`TObject`** pointer:. ``` {.cpp}; if (myObject->InheritsFrom(""TParticle"") {; printf(""myObject is a TParticlen"");; }; ```. As the name suggests, this test works even if the object is a subclass; of **`TParticle`**. The member function `IsA()` can be used instead of; `InheritsFrom` to make the test exact. The `InheritsFrom` and `IsA`; methods use the extensive Run Time Type Information (RTTI) available via; the ROOT meta-classes. ### Types of Collections. The ROOT system implements the following basic types of collections:; unordered collections, ordered collections and sorted collections. Next; figure shows the inheritance hierarchy for the primary collection; classes. All primary collection classes derive from the abstract base; class **`TCollection`**. ![The inheritance hierarchy of the primary collection classes](pictures/020001A3.jpg). ### Ordered Collections (Sequences). Sequences are collections that are externally ordered because they; maintain internal elements according to the order in which they were; added. The following sequences are available:. - **`TList`**. - **`THashList`**. - **`TOrdCollection`**. - **`TObjArray`**. - **`TClonesArray`**. The **`TOrdCollection`**, **`TObjArray`** as well as the; **`TClonesArray`** can be sorted using their Sort() member function (for; this, the stored objects must provide a comparison function by; ",MatchSource.DOCS,documentation/users-guide/CollectionClasses.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md:4198,Availability,avail,available,4198,"ritsFrom(""TParticle"") {; printf(""myObject is a TParticlen"");; }; ```. As the name suggests, this test works even if the object is a subclass; of **`TParticle`**. The member function `IsA()` can be used instead of; `InheritsFrom` to make the test exact. The `InheritsFrom` and `IsA`; methods use the extensive Run Time Type Information (RTTI) available via; the ROOT meta-classes. ### Types of Collections. The ROOT system implements the following basic types of collections:; unordered collections, ordered collections and sorted collections. Next; figure shows the inheritance hierarchy for the primary collection; classes. All primary collection classes derive from the abstract base; class **`TCollection`**. ![The inheritance hierarchy of the primary collection classes](pictures/020001A3.jpg). ### Ordered Collections (Sequences). Sequences are collections that are externally ordered because they; maintain internal elements according to the order in which they were; added. The following sequences are available:. - **`TList`**. - **`THashList`**. - **`TOrdCollection`**. - **`TObjArray`**. - **`TClonesArray`**. The **`TOrdCollection`**, **`TObjArray`** as well as the; **`TClonesArray`** can be sorted using their Sort() member function (for; this, the stored objects must provide a comparison function by; overriding TObject::Compare() and also must enable sorting by overriding; TObject::IsSortable() to return true). Ordered collections all derive; from the abstract base class **`TSeqCollection`**. Sorted collections; are ordered by an internal (automatic) sorting mechanism. The following; sorted collections are available (the stored items must be sortable):. - **`TSortedList`**. - **`TBtree`**. Unordered collections don't maintain the order in which the elements; were added, i.e. when you iterate over an unordered collection, you are; not likely to retrieve elements in the same order they were added to the; collection. The following unordered collections are available:. - **`T",MatchSource.DOCS,documentation/users-guide/CollectionClasses.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md:4817,Availability,avail,available,4817,"mary collection classes derive from the abstract base; class **`TCollection`**. ![The inheritance hierarchy of the primary collection classes](pictures/020001A3.jpg). ### Ordered Collections (Sequences). Sequences are collections that are externally ordered because they; maintain internal elements according to the order in which they were; added. The following sequences are available:. - **`TList`**. - **`THashList`**. - **`TOrdCollection`**. - **`TObjArray`**. - **`TClonesArray`**. The **`TOrdCollection`**, **`TObjArray`** as well as the; **`TClonesArray`** can be sorted using their Sort() member function (for; this, the stored objects must provide a comparison function by; overriding TObject::Compare() and also must enable sorting by overriding; TObject::IsSortable() to return true). Ordered collections all derive; from the abstract base class **`TSeqCollection`**. Sorted collections; are ordered by an internal (automatic) sorting mechanism. The following; sorted collections are available (the stored items must be sortable):. - **`TSortedList`**. - **`TBtree`**. Unordered collections don't maintain the order in which the elements; were added, i.e. when you iterate over an unordered collection, you are; not likely to retrieve elements in the same order they were added to the; collection. The following unordered collections are available:. - **`THashTable`**. - **`TMap`**. ## Iterators: Processing a Collection. The concept of processing all the members of a collection is generic,; i.e. independent of any specific representation of a collection. To; process each object in a collection one needs some type of cursor that; is initialized and then steps over each member of the collection in; turn. Collection objects could provide this service but there is a snag:; as there is only one collection object per collection there would only; be one cursor. Instead, to permit the use of as many cursors as; required, they are made separate classes called iterator. For each; colle",MatchSource.DOCS,documentation/users-guide/CollectionClasses.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md:5171,Availability,avail,available,5171," were; added. The following sequences are available:. - **`TList`**. - **`THashList`**. - **`TOrdCollection`**. - **`TObjArray`**. - **`TClonesArray`**. The **`TOrdCollection`**, **`TObjArray`** as well as the; **`TClonesArray`** can be sorted using their Sort() member function (for; this, the stored objects must provide a comparison function by; overriding TObject::Compare() and also must enable sorting by overriding; TObject::IsSortable() to return true). Ordered collections all derive; from the abstract base class **`TSeqCollection`**. Sorted collections; are ordered by an internal (automatic) sorting mechanism. The following; sorted collections are available (the stored items must be sortable):. - **`TSortedList`**. - **`TBtree`**. Unordered collections don't maintain the order in which the elements; were added, i.e. when you iterate over an unordered collection, you are; not likely to retrieve elements in the same order they were added to the; collection. The following unordered collections are available:. - **`THashTable`**. - **`TMap`**. ## Iterators: Processing a Collection. The concept of processing all the members of a collection is generic,; i.e. independent of any specific representation of a collection. To; process each object in a collection one needs some type of cursor that; is initialized and then steps over each member of the collection in; turn. Collection objects could provide this service but there is a snag:; as there is only one collection object per collection there would only; be one cursor. Instead, to permit the use of as many cursors as; required, they are made separate classes called iterator. For each; collection class there is an associated iterator class that knows how to; sequentially retrieve each member in turn. The relationship between a; collection and its iterator is very close and may require that the; iterator has full access to the collection (i.e. it is a friend class).; In general iterator will be used via the **`TIter`** w",MatchSource.DOCS,documentation/users-guide/CollectionClasses.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md:15519,Energy Efficiency,efficient,efficient,15519,"**. Methods 2, 3 and 4 can also easily iterate backwards using either a; backward **`TIter`** (using argument `kIterBackward`) or by using; `LastLink()` and `lnk>Prev`() or by using the `Before()` method. ## The TObjArray Collection. A **`TObjArray`** is a collection which supports traditional array; semantics via the overloading of `operator[]`. Objects can be directly; accessed via an index. The array expands automatically when objects are; added. At creation time one specifies the default array size (default =; 16) and lower bound (default = 0). Resizing involves a re-allocation and; a copy of the old array to the new. This can be costly if done too; often. If possible, set initial size close to expected final size. Index; validity is always checked (if you are 100% sure and maximum performance; is needed you can use `UnCheckedAt()` instead of `At()` or; `operator[]`). If the stored objects are sort able the array can be; sorted using `Sort()`. Once sorted, efficient searching is possible via; the `BinarySearch()` method. The figure shows the internal data; structure of a **`TObjArray`**:. ![The internal data structure of a TObjArray](pictures/020001A7.jpg). Iterating can be done using a **`TIter`** iterator or via a simple for; loop:. ``` {.cpp}; for (int i = 0; i <= fArr.GetLast(); i++); if ((track = (TTrack*)fArr[i])) // or fArr.At(i); track->Draw();; ```. Main features of **`TObjArray`** are simple, well-known array semantics.; **Overhead per element**: none, except possible over sizing of `fCont`. ## TClonesArray An Array of Identical Objects. A **`TClonesArray`** is an array of identical (clone) objects. The; memory for the objects stored in the array is allocated only once in the; lifetime of the clones array. All objects must be of the same class. For; the rest this class has the same properties as a **`TObjArray`**. ![The internal data structure of a TClonesArray](pictures/020001A8.jpg). The figure above shows the internal data structure of a; **`TClonesA",MatchSource.DOCS,documentation/users-guide/CollectionClasses.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md:16236,Energy Efficiency,allocate,allocated,16236,"size close to expected final size. Index; validity is always checked (if you are 100% sure and maximum performance; is needed you can use `UnCheckedAt()` instead of `At()` or; `operator[]`). If the stored objects are sort able the array can be; sorted using `Sort()`. Once sorted, efficient searching is possible via; the `BinarySearch()` method. The figure shows the internal data; structure of a **`TObjArray`**:. ![The internal data structure of a TObjArray](pictures/020001A7.jpg). Iterating can be done using a **`TIter`** iterator or via a simple for; loop:. ``` {.cpp}; for (int i = 0; i <= fArr.GetLast(); i++); if ((track = (TTrack*)fArr[i])) // or fArr.At(i); track->Draw();; ```. Main features of **`TObjArray`** are simple, well-known array semantics.; **Overhead per element**: none, except possible over sizing of `fCont`. ## TClonesArray An Array of Identical Objects. A **`TClonesArray`** is an array of identical (clone) objects. The; memory for the objects stored in the array is allocated only once in the; lifetime of the clones array. All objects must be of the same class. For; the rest this class has the same properties as a **`TObjArray`**. ![The internal data structure of a TClonesArray](pictures/020001A8.jpg). The figure above shows the internal data structure of a; **`TClonesArray`**. The class is specially designed for repetitive data; analysis tasks, where in a loop many times the same objects, are created; and deleted. The only supported way to add objects to a; **`TClonesArray`** is via the `new` with placement method. The different; `Add()` methods of **`TObjArray`** and its base classes are not; supported. ### The Idea Behind TClonesArray. To reduce the very large number of new and delete calls in large loops; like this (O(100000) x O(10000) times new/delete):. ``` {.cpp}; TObjArray a(10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000); for (int i = 0; i < ev->Ntracks; i++) { // O(10000); a[i] = new TTrack(x,y,z,...);; ...; }; ...; a.Delete(",MatchSource.DOCS,documentation/users-guide/CollectionClasses.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md:16925,Energy Efficiency,reduce,reduce,16925,"n array semantics.; **Overhead per element**: none, except possible over sizing of `fCont`. ## TClonesArray An Array of Identical Objects. A **`TClonesArray`** is an array of identical (clone) objects. The; memory for the objects stored in the array is allocated only once in the; lifetime of the clones array. All objects must be of the same class. For; the rest this class has the same properties as a **`TObjArray`**. ![The internal data structure of a TClonesArray](pictures/020001A8.jpg). The figure above shows the internal data structure of a; **`TClonesArray`**. The class is specially designed for repetitive data; analysis tasks, where in a loop many times the same objects, are created; and deleted. The only supported way to add objects to a; **`TClonesArray`** is via the `new` with placement method. The different; `Add()` methods of **`TObjArray`** and its base classes are not; supported. ### The Idea Behind TClonesArray. To reduce the very large number of new and delete calls in large loops; like this (O(100000) x O(10000) times new/delete):. ``` {.cpp}; TObjArray a(10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000); for (int i = 0; i < ev->Ntracks; i++) { // O(10000); a[i] = new TTrack(x,y,z,...);; ...; }; ...; a.Delete();; }; ```. You better use a **`TClonesArray`** which reduces the number of; new/delete calls to only O(10000):. ``` {.cpp}; TClonesArray a(""TTrack"", 10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000); for (int i = 0; i < ev->Ntracks; i++) { // O(10000); TTrack *track = (Track*)a.ConstructedAt(i);; track->Set(x,y,z,...);; ...; }; ...; a.Clear(); // Or Clear(""C"") if the track objects must be returned (via Track::Clear) to a default state.; }; ```. Considering that a pair of new/delete calls on average cost about 70 ms,; O(109) new/deletes will save about 19 hours. For the other collections,; see the class reference guide on the web and the test program; `$ROOTSYS/test/tcollex.cxx.`. ## Template Containers and STL. Some peopl",MatchSource.DOCS,documentation/users-guide/CollectionClasses.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md:17293,Energy Efficiency,reduce,reduces,17293,"jects must be of the same class. For; the rest this class has the same properties as a **`TObjArray`**. ![The internal data structure of a TClonesArray](pictures/020001A8.jpg). The figure above shows the internal data structure of a; **`TClonesArray`**. The class is specially designed for repetitive data; analysis tasks, where in a loop many times the same objects, are created; and deleted. The only supported way to add objects to a; **`TClonesArray`** is via the `new` with placement method. The different; `Add()` methods of **`TObjArray`** and its base classes are not; supported. ### The Idea Behind TClonesArray. To reduce the very large number of new and delete calls in large loops; like this (O(100000) x O(10000) times new/delete):. ``` {.cpp}; TObjArray a(10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000); for (int i = 0; i < ev->Ntracks; i++) { // O(10000); a[i] = new TTrack(x,y,z,...);; ...; }; ...; a.Delete();; }; ```. You better use a **`TClonesArray`** which reduces the number of; new/delete calls to only O(10000):. ``` {.cpp}; TClonesArray a(""TTrack"", 10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000); for (int i = 0; i < ev->Ntracks; i++) { // O(10000); TTrack *track = (Track*)a.ConstructedAt(i);; track->Set(x,y,z,...);; ...; }; ...; a.Clear(); // Or Clear(""C"") if the track objects must be returned (via Track::Clear) to a default state.; }; ```. Considering that a pair of new/delete calls on average cost about 70 ms,; O(109) new/deletes will save about 19 hours. For the other collections,; see the class reference guide on the web and the test program; `$ROOTSYS/test/tcollex.cxx.`. ## Template Containers and STL. Some people dislike polymorphic containers because they are not truly; ""type safe"". In the end, the compiler leaves it the user to ensure that; the types are correct. This only leaves the other alternative: creating; a new class each time a new (container organization) / (contained; object) combination is needed. To say the le",MatchSource.DOCS,documentation/users-guide/CollectionClasses.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md:1273,Integrability,interface,interface,1273,", much of this chapter covers; aspects of collections specific to the ROOT system. When you have read; this chapter, you will know. - How to create instances of collections. - The difference between lists, arrays, hash tables, maps, etc. - How to add and remove elements of a collection. - How to search a collection for a specific element. - How to access and modify collection elements. - How to iterate over a collection to access collection elements. - How to manage memory for collections and collection elements. - How collection elements are tested for equality (`IsEqual(`)). - How collection elements are compared (`Compare())` in case of sorted; collections. - How collection elements are hashed (`Hash()`) in hash tables. ## Understanding Collections. A collection is a group of related objects. You will find it easier to; manage a large number of items as a collection. For example, a diagram; editor might manage a collection of points and lines. A set of widgets; for a graphical user interface can be placed in a collection. A; geometrical model can be described by collections of shapes, materials; and rotation matrices. Collections can themselves be placed in; collections. Collections act as flexible alternatives to traditional; data structures of computers science such as arrays, lists and trees. ### General Characteristics. The ROOT collections are polymorphic containers that hold pointers to; `TObjects`, so:. - They can only hold objects that inherit from **`TObject`**. - They return pointers to `TObjects`, that have to be cast back to the; correct subclass. Collections are dynamic; they can grow in size as required. Collections; themselves are descendants of **`TObject`** so can themselves be held in; collections. It is possible to nest one type of collection inside; another to any level to produce structures of arbitrary complexity. Collections do not own the objects they hold for the very good reason; that the same object could be a member of more than one co",MatchSource.DOCS,documentation/users-guide/CollectionClasses.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md:6155,Integrability,wrap,wrapper,6155," following unordered collections are available:. - **`THashTable`**. - **`TMap`**. ## Iterators: Processing a Collection. The concept of processing all the members of a collection is generic,; i.e. independent of any specific representation of a collection. To; process each object in a collection one needs some type of cursor that; is initialized and then steps over each member of the collection in; turn. Collection objects could provide this service but there is a snag:; as there is only one collection object per collection there would only; be one cursor. Instead, to permit the use of as many cursors as; required, they are made separate classes called iterator. For each; collection class there is an associated iterator class that knows how to; sequentially retrieve each member in turn. The relationship between a; collection and its iterator is very close and may require that the; iterator has full access to the collection (i.e. it is a friend class).; In general iterator will be used via the **`TIter`** wrapper class. For; example:. - **`TList`** **`TListIter`**. - **`TMap`** **`TMapIter`**. ## Foundation Classes. All collections are based on the fundamental classes: **`TCollection`**; and **`TIterator`**. They are so generic that it is not possible to; create objects from them; they are only used as base classes for other; classes (i.e. they are abstract base classes). The **`TCollection`** class provides the basic protocol (i.e. the; minimum set of member functions) that all collection classes have to; implement. These include:. - `Add` `Adds another object to the collection.`. - `GetSize` `Returns the number of objects in the collection.`. - `Clear`; `Clears out the collection, but does not delete the removed objects.`. - `Delete`; `Clears out the collection and deletes the removed objects. This should only `; `be used if the collection owns its objects (which are not normally the case).`. - `FindObject` `Finds an object given either its name or address.`. - `Ma",MatchSource.DOCS,documentation/users-guide/CollectionClasses.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md:6576,Integrability,protocol,protocol,6576,"cts could provide this service but there is a snag:; as there is only one collection object per collection there would only; be one cursor. Instead, to permit the use of as many cursors as; required, they are made separate classes called iterator. For each; collection class there is an associated iterator class that knows how to; sequentially retrieve each member in turn. The relationship between a; collection and its iterator is very close and may require that the; iterator has full access to the collection (i.e. it is a friend class).; In general iterator will be used via the **`TIter`** wrapper class. For; example:. - **`TList`** **`TListIter`**. - **`TMap`** **`TMapIter`**. ## Foundation Classes. All collections are based on the fundamental classes: **`TCollection`**; and **`TIterator`**. They are so generic that it is not possible to; create objects from them; they are only used as base classes for other; classes (i.e. they are abstract base classes). The **`TCollection`** class provides the basic protocol (i.e. the; minimum set of member functions) that all collection classes have to; implement. These include:. - `Add` `Adds another object to the collection.`. - `GetSize` `Returns the number of objects in the collection.`. - `Clear`; `Clears out the collection, but does not delete the removed objects.`. - `Delete`; `Clears out the collection and deletes the removed objects. This should only `; `be used if the collection owns its objects (which are not normally the case).`. - `FindObject` `Finds an object given either its name or address.`. - `MakeIterator` `Returns an iterator associated with the collection.`. - `Remove` `Removes an object from the collection.`. The code example below shows a class containing three lists, where the; `fTracks` list is the owning collection and the other two lists are used; to store a sub-set of the track objects. In the destructor of the class,; the method `Delete` is called for the owning collection to delete; correctly its en",MatchSource.DOCS,documentation/users-guide/CollectionClasses.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md:9026,Integrability,depend,depending,9026,"mum set of member functions; that all iterators must support. These include:. - `Next`; `Returns the next member of the collection or 0 if no more members.`. - `Reset` `Resets the iterator so that ` `Next`; ` returns the first object.`. ## A Collectable Class. By default, all objects of **`TObject`** derived classes can be stored; in ROOT containers. However, the **`TObject`** class provides some; member functions that allow you to tune the behavior of objects in; containers. For example, by default two objects are considered equal if; their pointers point to the same address. This might be too strict for; some classes where equality is already achieved if some or all of the; data members are equal. By overriding the following **`TObject`** member; functions, you can change the behavior of objects in collections:. - `IsEqual()`is used by the `FindObject() `collection method. By; default, `IsEqual()` compares the two object pointers. - `Compare()`returns -1, 0 or 1 depending if the object is smaller,; equal or larger than the other object. By default, a **`TObject`**; has not a valid `Compare()` method. - `IsSortable() `returns true if the class is sort able (i.e. if it; has a valid `Compare(`) method). By default, a **`TObject`** is not; sort able. - `Hash() `returns a hash value. It needs to be implemented if an; object has to be stored in a collection using a hashing technique,; like **`THashTable`**, **`THashList`** and **`TMap`**. By default,; `Hash(`) returns the address of the object. It is essential to; choose a good hash function. The example below shows how to use and override these member functions. ``` {.cpp}; class TObjNum : public TObject {; private:; Int_t num; // TObjNum is a simple container for an integer.; public:; TObjNum(Int_t i = 0) : num(i) { }; ~TObjNum() { }; void SetNum(Int_t i) { num = i; }; Int_t GetNum() const { return num; }; void Print(Option_t *) const; { printf(""num = %dn"", num); }; Bool_t IsEqual(TObject *obj) const; { return num == ",MatchSource.DOCS,documentation/users-guide/CollectionClasses.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md:11227,Integrability,wrap,wrapper,11227,"urn 1;; else return 0; }; ULong_t Hash() const { return num; }; };; ```. ## The TIter Generic Iterator. As stated above, the **`TIterator`** class is abstract; it is not; possible to create **`TIterator`** objects. However, it should be; possible to write generic code to process all members of a collection so; there is a need for a generic iterator object. A **`TIter`** object acts; as generic iterator. It provides the same `Next()` and `Reset()` methods; as **`TIterator`** although it has no idea how to support them! It works; as follows:. - To create a **`TIter`** object its constructor must be passed an; object that inherits from **`TCollection`**. The **`TIter`**; constructor calls the `MakeIterator()` method of this collection to; get the appropriate iterator object that inherits from; **`TIterator`**. - The `Next()` and `Reset()` methods of **`TIter`** simply call the; `Next()` and `Reset()` methods of the iterator object. Therefore, **`TIter`** simply acts as a wrapper for an object of a; concrete class inheriting from **`TIterator`**. To see this working in practice, consider the **`TObjArray`**; collection. Its associated iterator is **`TObjArrayIter`**. Suppose; `myarray` is a pointer to a **`TObjArray`** that contains `MyClass`; objects, i.e. ``` {.cpp}; TObjArray *myarray;; ```. To create a **`TIter`** object called `myiter`:. ``` {.cpp}; TIter myiter(myarray);; ```. ![](pictures/020001A4.jpg). As shown in the diagram, this results in several methods being called:. - The **`TIter`** constructor is passed a **`TObjArray`**. - **`TIter`** asks embedded **`TCollection`** to make an iterator. - **`TCollection`** asks **`TObjArray`** to make an iterator. - **`TObjArray`** returns a **`TObjArrayIter`**. Now define a pointer for `MyClass` objects and set it to each member of; the **`TObjArray`**:. ``` {.cpp}; MyClass *myobject;; while ((myobject = (MyClass *)myiter.Next())) {; // process myobject; }; ```. The heart of this is the `myiter.Next()` expression whic",MatchSource.DOCS,documentation/users-guide/CollectionClasses.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md:13071,Integrability,wrap,wrapped,13071,"s *myobject;; while ((myobject = (MyClass *)myiter.Next())) {; // process myobject; }; ```. The heart of this is the `myiter.Next()` expression which does the; following:. - The `Next()` method of the **`TIter`** object `myiter` is called. - The **`TIter`** forwards the call to the **`TIterator`** embedded in; the **`TObjArrayIter`**. - **`TIterator`** forwards the call to the **`TObjArrayIter`**. - **`TObjArrayIter`** finds the next `MyClass` object and returns it. - **`TIter`** passes the `MyClass` object back to the caller. ![](pictures/020001A5.jpg). Sometimes the **`TIter`** object is called next, and then instead of; writing: `next.Next() `which is legal, but looks rather odd, iteration; is written as `next()`. This works because the function `operator()` is; defined for the **`TIter`** class to be equivalent to the `Next()`; method. ## The TList Collection. A **`TList`** is a doubly linked list. Before being inserted into the; list the object pointer is wrapped in a **`TObjLink`** object that; contains, besides the object pointer also a previous and next pointer. Objects are typically added using:. - `Add()`. - `AddFirst(), AddLast()`. - `AddBefore(), AddAfter()`. **Main features of`TList`**: very low cost of adding/removing elements; anywhere in the list. **Overhead per element**: 1 `TObjLink`, i.e. two 4 (or 8) byte pointers; + pointer to `vtable` = 12 (or 24) bytes. Next figure shows the internal data structure of a **`TList`**. ![The internal data structure of a TList](pictures/020001A6.jpg). ### Iterating Over a TList. There are four ways to iterate over a **`TList`**:. - Using the `ForEach` script:. ``` {.cpp}; GetListOfPrimitives()->ForEach(TObject,Draw)();; ```. - Using the **`TList`** iterator **`TListIter`** (via the wrapper; class **`TIter`**):. ``` {.cpp}; TIter next(GetListOfTracks());; while ((TTrack *obj = (TTrack *)next())); obj->Draw();; ```. - Using the **`TObjLink`** list entries (that wrap the; **`TObject`**\*):. ``` {.cpp}; TObjLink *lnk =",MatchSource.DOCS,documentation/users-guide/CollectionClasses.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md:13860,Integrability,wrap,wrapper,13860," function `operator()` is; defined for the **`TIter`** class to be equivalent to the `Next()`; method. ## The TList Collection. A **`TList`** is a doubly linked list. Before being inserted into the; list the object pointer is wrapped in a **`TObjLink`** object that; contains, besides the object pointer also a previous and next pointer. Objects are typically added using:. - `Add()`. - `AddFirst(), AddLast()`. - `AddBefore(), AddAfter()`. **Main features of`TList`**: very low cost of adding/removing elements; anywhere in the list. **Overhead per element**: 1 `TObjLink`, i.e. two 4 (or 8) byte pointers; + pointer to `vtable` = 12 (or 24) bytes. Next figure shows the internal data structure of a **`TList`**. ![The internal data structure of a TList](pictures/020001A6.jpg). ### Iterating Over a TList. There are four ways to iterate over a **`TList`**:. - Using the `ForEach` script:. ``` {.cpp}; GetListOfPrimitives()->ForEach(TObject,Draw)();; ```. - Using the **`TList`** iterator **`TListIter`** (via the wrapper; class **`TIter`**):. ``` {.cpp}; TIter next(GetListOfTracks());; while ((TTrack *obj = (TTrack *)next())); obj->Draw();; ```. - Using the **`TObjLink`** list entries (that wrap the; **`TObject`**\*):. ``` {.cpp}; TObjLink *lnk = GetListOfPrimitives()->FirstLink();; while (lnk) {; lnk->GetObject()->Draw();; lnk = lnk->Next();; }; ```. - Using the **`TList`**'s `After()` and `Before()` member functions:. ``` {.cpp}; TFree *idcur = this;; while (idcur) {; ...; idcur = (TFree*)GetListOfFree()->After(idcur);; }; ```. Method 1 uses internally method 2. Method 2 works for all collection classes. **`TIter`** overloads; `operator()`. Methods 3 and 4 are specific for **`TList`**. Methods 2, 3 and 4 can also easily iterate backwards using either a; backward **`TIter`** (using argument `kIterBackward`) or by using; `LastLink()` and `lnk>Prev`() or by using the `Before()` method. ## The TObjArray Collection. A **`TObjArray`** is a collection which supports traditional array;",MatchSource.DOCS,documentation/users-guide/CollectionClasses.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md:14041,Integrability,wrap,wrap,14041,"ed into the; list the object pointer is wrapped in a **`TObjLink`** object that; contains, besides the object pointer also a previous and next pointer. Objects are typically added using:. - `Add()`. - `AddFirst(), AddLast()`. - `AddBefore(), AddAfter()`. **Main features of`TList`**: very low cost of adding/removing elements; anywhere in the list. **Overhead per element**: 1 `TObjLink`, i.e. two 4 (or 8) byte pointers; + pointer to `vtable` = 12 (or 24) bytes. Next figure shows the internal data structure of a **`TList`**. ![The internal data structure of a TList](pictures/020001A6.jpg). ### Iterating Over a TList. There are four ways to iterate over a **`TList`**:. - Using the `ForEach` script:. ``` {.cpp}; GetListOfPrimitives()->ForEach(TObject,Draw)();; ```. - Using the **`TList`** iterator **`TListIter`** (via the wrapper; class **`TIter`**):. ``` {.cpp}; TIter next(GetListOfTracks());; while ((TTrack *obj = (TTrack *)next())); obj->Draw();; ```. - Using the **`TObjLink`** list entries (that wrap the; **`TObject`**\*):. ``` {.cpp}; TObjLink *lnk = GetListOfPrimitives()->FirstLink();; while (lnk) {; lnk->GetObject()->Draw();; lnk = lnk->Next();; }; ```. - Using the **`TList`**'s `After()` and `Before()` member functions:. ``` {.cpp}; TFree *idcur = this;; while (idcur) {; ...; idcur = (TFree*)GetListOfFree()->After(idcur);; }; ```. Method 1 uses internally method 2. Method 2 works for all collection classes. **`TIter`** overloads; `operator()`. Methods 3 and 4 are specific for **`TList`**. Methods 2, 3 and 4 can also easily iterate backwards using either a; backward **`TIter`** (using argument `kIterBackward`) or by using; `LastLink()` and `lnk>Prev`() or by using the `Before()` method. ## The TObjArray Collection. A **`TObjArray`** is a collection which supports traditional array; semantics via the overloading of `operator[]`. Objects can be directly; accessed via an index. The array expands automatically when objects are; added. At creation time one specifies the",MatchSource.DOCS,documentation/users-guide/CollectionClasses.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md:162,Modifiability,parameteriz,parameterized,162,"# Collection Classes. Collections are a key feature of the ROOT system. Many, if not most, of; the applications you write will use collections. If you have used; parameterized C++ collections or polymorphic collections before, some of; this material will be review. However, much of this chapter covers; aspects of collections specific to the ROOT system. When you have read; this chapter, you will know. - How to create instances of collections. - The difference between lists, arrays, hash tables, maps, etc. - How to add and remove elements of a collection. - How to search a collection for a specific element. - How to access and modify collection elements. - How to iterate over a collection to access collection elements. - How to manage memory for collections and collection elements. - How collection elements are tested for equality (`IsEqual(`)). - How collection elements are compared (`Compare())` in case of sorted; collections. - How collection elements are hashed (`Hash()`) in hash tables. ## Understanding Collections. A collection is a group of related objects. You will find it easier to; manage a large number of items as a collection. For example, a diagram; editor might manage a collection of points and lines. A set of widgets; for a graphical user interface can be placed in a collection. A; geometrical model can be described by collections of shapes, materials; and rotation matrices. Collections can themselves be placed in; collections. Collections act as flexible alternatives to traditional; data structures of computers science such as arrays, lists and trees. ### General Characteristics. The ROOT collections are polymorphic containers that hold pointers to; `TObjects`, so:. - They can only hold objects that inherit from **`TObject`**. - They return pointers to `TObjects`, that have to be cast back to the; correct subclass. Collections are dynamic; they can grow in size as required. Collections; themselves are descendants of **`TObject`** so can themselves be h",MatchSource.DOCS,documentation/users-guide/CollectionClasses.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md:195,Modifiability,polymorphi,polymorphic,195,"# Collection Classes. Collections are a key feature of the ROOT system. Many, if not most, of; the applications you write will use collections. If you have used; parameterized C++ collections or polymorphic collections before, some of; this material will be review. However, much of this chapter covers; aspects of collections specific to the ROOT system. When you have read; this chapter, you will know. - How to create instances of collections. - The difference between lists, arrays, hash tables, maps, etc. - How to add and remove elements of a collection. - How to search a collection for a specific element. - How to access and modify collection elements. - How to iterate over a collection to access collection elements. - How to manage memory for collections and collection elements. - How collection elements are tested for equality (`IsEqual(`)). - How collection elements are compared (`Compare())` in case of sorted; collections. - How collection elements are hashed (`Hash()`) in hash tables. ## Understanding Collections. A collection is a group of related objects. You will find it easier to; manage a large number of items as a collection. For example, a diagram; editor might manage a collection of points and lines. A set of widgets; for a graphical user interface can be placed in a collection. A; geometrical model can be described by collections of shapes, materials; and rotation matrices. Collections can themselves be placed in; collections. Collections act as flexible alternatives to traditional; data structures of computers science such as arrays, lists and trees. ### General Characteristics. The ROOT collections are polymorphic containers that hold pointers to; `TObjects`, so:. - They can only hold objects that inherit from **`TObject`**. - They return pointers to `TObjects`, that have to be cast back to the; correct subclass. Collections are dynamic; they can grow in size as required. Collections; themselves are descendants of **`TObject`** so can themselves be h",MatchSource.DOCS,documentation/users-guide/CollectionClasses.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md:1485,Modifiability,flexible,flexible,1485,"remove elements of a collection. - How to search a collection for a specific element. - How to access and modify collection elements. - How to iterate over a collection to access collection elements. - How to manage memory for collections and collection elements. - How collection elements are tested for equality (`IsEqual(`)). - How collection elements are compared (`Compare())` in case of sorted; collections. - How collection elements are hashed (`Hash()`) in hash tables. ## Understanding Collections. A collection is a group of related objects. You will find it easier to; manage a large number of items as a collection. For example, a diagram; editor might manage a collection of points and lines. A set of widgets; for a graphical user interface can be placed in a collection. A; geometrical model can be described by collections of shapes, materials; and rotation matrices. Collections can themselves be placed in; collections. Collections act as flexible alternatives to traditional; data structures of computers science such as arrays, lists and trees. ### General Characteristics. The ROOT collections are polymorphic containers that hold pointers to; `TObjects`, so:. - They can only hold objects that inherit from **`TObject`**. - They return pointers to `TObjects`, that have to be cast back to the; correct subclass. Collections are dynamic; they can grow in size as required. Collections; themselves are descendants of **`TObject`** so can themselves be held in; collections. It is possible to nest one type of collection inside; another to any level to produce structures of arbitrary complexity. Collections do not own the objects they hold for the very good reason; that the same object could be a member of more than one collection.; Object ownership is important when it comes to deleting objects; if; nobody owns the object it could end up as wasted memory (i.e. a memory; leak) when no longer needed. If a collection is deleted, its objects are; not. The user can force a coll",MatchSource.DOCS,documentation/users-guide/CollectionClasses.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md:1647,Modifiability,polymorphi,polymorphic,1647,"ow to iterate over a collection to access collection elements. - How to manage memory for collections and collection elements. - How collection elements are tested for equality (`IsEqual(`)). - How collection elements are compared (`Compare())` in case of sorted; collections. - How collection elements are hashed (`Hash()`) in hash tables. ## Understanding Collections. A collection is a group of related objects. You will find it easier to; manage a large number of items as a collection. For example, a diagram; editor might manage a collection of points and lines. A set of widgets; for a graphical user interface can be placed in a collection. A; geometrical model can be described by collections of shapes, materials; and rotation matrices. Collections can themselves be placed in; collections. Collections act as flexible alternatives to traditional; data structures of computers science such as arrays, lists and trees. ### General Characteristics. The ROOT collections are polymorphic containers that hold pointers to; `TObjects`, so:. - They can only hold objects that inherit from **`TObject`**. - They return pointers to `TObjects`, that have to be cast back to the; correct subclass. Collections are dynamic; they can grow in size as required. Collections; themselves are descendants of **`TObject`** so can themselves be held in; collections. It is possible to nest one type of collection inside; another to any level to produce structures of arbitrary complexity. Collections do not own the objects they hold for the very good reason; that the same object could be a member of more than one collection.; Object ownership is important when it comes to deleting objects; if; nobody owns the object it could end up as wasted memory (i.e. a memory; leak) when no longer needed. If a collection is deleted, its objects are; not. The user can force a collection to delete its objects, but that is; the user's choice. ### Determining the Class of Contained Objects. Most containers may hold h",MatchSource.DOCS,documentation/users-guide/CollectionClasses.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md:1744,Modifiability,inherit,inherit,1744,"age memory for collections and collection elements. - How collection elements are tested for equality (`IsEqual(`)). - How collection elements are compared (`Compare())` in case of sorted; collections. - How collection elements are hashed (`Hash()`) in hash tables. ## Understanding Collections. A collection is a group of related objects. You will find it easier to; manage a large number of items as a collection. For example, a diagram; editor might manage a collection of points and lines. A set of widgets; for a graphical user interface can be placed in a collection. A; geometrical model can be described by collections of shapes, materials; and rotation matrices. Collections can themselves be placed in; collections. Collections act as flexible alternatives to traditional; data structures of computers science such as arrays, lists and trees. ### General Characteristics. The ROOT collections are polymorphic containers that hold pointers to; `TObjects`, so:. - They can only hold objects that inherit from **`TObject`**. - They return pointers to `TObjects`, that have to be cast back to the; correct subclass. Collections are dynamic; they can grow in size as required. Collections; themselves are descendants of **`TObject`** so can themselves be held in; collections. It is possible to nest one type of collection inside; another to any level to produce structures of arbitrary complexity. Collections do not own the objects they hold for the very good reason; that the same object could be a member of more than one collection.; Object ownership is important when it comes to deleting objects; if; nobody owns the object it could end up as wasted memory (i.e. a memory; leak) when no longer needed. If a collection is deleted, its objects are; not. The user can force a collection to delete its objects, but that is; the user's choice. ### Determining the Class of Contained Objects. Most containers may hold heterogeneous collections of objects and then; it is left to the user to cor",MatchSource.DOCS,documentation/users-guide/CollectionClasses.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md:3755,Modifiability,inherit,inheritance,3755,"inter to; the right class. Casting to the wrong class will give wrong results and; may well crash the program! Therefore, the user has to be very careful.; Often a container only contains one class of objects, but if it really; contains a mixture, it is possible to ask each object about its class; using the `InheritsFrom` method. For example if `myObject` is a **`TObject`** pointer:. ``` {.cpp}; if (myObject->InheritsFrom(""TParticle"") {; printf(""myObject is a TParticlen"");; }; ```. As the name suggests, this test works even if the object is a subclass; of **`TParticle`**. The member function `IsA()` can be used instead of; `InheritsFrom` to make the test exact. The `InheritsFrom` and `IsA`; methods use the extensive Run Time Type Information (RTTI) available via; the ROOT meta-classes. ### Types of Collections. The ROOT system implements the following basic types of collections:; unordered collections, ordered collections and sorted collections. Next; figure shows the inheritance hierarchy for the primary collection; classes. All primary collection classes derive from the abstract base; class **`TCollection`**. ![The inheritance hierarchy of the primary collection classes](pictures/020001A3.jpg). ### Ordered Collections (Sequences). Sequences are collections that are externally ordered because they; maintain internal elements according to the order in which they were; added. The following sequences are available:. - **`TList`**. - **`THashList`**. - **`TOrdCollection`**. - **`TObjArray`**. - **`TClonesArray`**. The **`TOrdCollection`**, **`TObjArray`** as well as the; **`TClonesArray`** can be sorted using their Sort() member function (for; this, the stored objects must provide a comparison function by; overriding TObject::Compare() and also must enable sorting by overriding; TObject::IsSortable() to return true). Ordered collections all derive; from the abstract base class **`TSeqCollection`**. Sorted collections; are ordered by an internal (automatic) sorting mech",MatchSource.DOCS,documentation/users-guide/CollectionClasses.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md:3907,Modifiability,inherit,inheritance,3907,"iner only contains one class of objects, but if it really; contains a mixture, it is possible to ask each object about its class; using the `InheritsFrom` method. For example if `myObject` is a **`TObject`** pointer:. ``` {.cpp}; if (myObject->InheritsFrom(""TParticle"") {; printf(""myObject is a TParticlen"");; }; ```. As the name suggests, this test works even if the object is a subclass; of **`TParticle`**. The member function `IsA()` can be used instead of; `InheritsFrom` to make the test exact. The `InheritsFrom` and `IsA`; methods use the extensive Run Time Type Information (RTTI) available via; the ROOT meta-classes. ### Types of Collections. The ROOT system implements the following basic types of collections:; unordered collections, ordered collections and sorted collections. Next; figure shows the inheritance hierarchy for the primary collection; classes. All primary collection classes derive from the abstract base; class **`TCollection`**. ![The inheritance hierarchy of the primary collection classes](pictures/020001A3.jpg). ### Ordered Collections (Sequences). Sequences are collections that are externally ordered because they; maintain internal elements according to the order in which they were; added. The following sequences are available:. - **`TList`**. - **`THashList`**. - **`TOrdCollection`**. - **`TObjArray`**. - **`TClonesArray`**. The **`TOrdCollection`**, **`TObjArray`** as well as the; **`TClonesArray`** can be sorted using their Sort() member function (for; this, the stored objects must provide a comparison function by; overriding TObject::Compare() and also must enable sorting by overriding; TObject::IsSortable() to return true). Ordered collections all derive; from the abstract base class **`TSeqCollection`**. Sorted collections; are ordered by an internal (automatic) sorting mechanism. The following; sorted collections are available (the stored items must be sortable):. - **`TSortedList`**. - **`TBtree`**. Unordered collections don't maintain th",MatchSource.DOCS,documentation/users-guide/CollectionClasses.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md:10871,Modifiability,inherit,inherits,10871,"TObjNum() { }; void SetNum(Int_t i) { num = i; }; Int_t GetNum() const { return num; }; void Print(Option_t *) const; { printf(""num = %dn"", num); }; Bool_t IsEqual(TObject *obj) const; { return num == ((TObjNum*)obj)->num; }; Bool_t IsSortable() const { return kTRUE; }; Int_t Compare(const TObject *obj) const; { if (num < ((TObjNum*)obj)->num) return -1;; else if (num > ((TObjNum*)obj)->num) return 1;; else return 0; }; ULong_t Hash() const { return num; }; };; ```. ## The TIter Generic Iterator. As stated above, the **`TIterator`** class is abstract; it is not; possible to create **`TIterator`** objects. However, it should be; possible to write generic code to process all members of a collection so; there is a need for a generic iterator object. A **`TIter`** object acts; as generic iterator. It provides the same `Next()` and `Reset()` methods; as **`TIterator`** although it has no idea how to support them! It works; as follows:. - To create a **`TIter`** object its constructor must be passed an; object that inherits from **`TCollection`**. The **`TIter`**; constructor calls the `MakeIterator()` method of this collection to; get the appropriate iterator object that inherits from; **`TIterator`**. - The `Next()` and `Reset()` methods of **`TIter`** simply call the; `Next()` and `Reset()` methods of the iterator object. Therefore, **`TIter`** simply acts as a wrapper for an object of a; concrete class inheriting from **`TIterator`**. To see this working in practice, consider the **`TObjArray`**; collection. Its associated iterator is **`TObjArrayIter`**. Suppose; `myarray` is a pointer to a **`TObjArray`** that contains `MyClass`; objects, i.e. ``` {.cpp}; TObjArray *myarray;; ```. To create a **`TIter`** object called `myiter`:. ``` {.cpp}; TIter myiter(myarray);; ```. ![](pictures/020001A4.jpg). As shown in the diagram, this results in several methods being called:. - The **`TIter`** constructor is passed a **`TObjArray`**. - **`TIter`** asks embedded **`TCollection",MatchSource.DOCS,documentation/users-guide/CollectionClasses.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md:11031,Modifiability,inherit,inherits,11031,"n"", num); }; Bool_t IsEqual(TObject *obj) const; { return num == ((TObjNum*)obj)->num; }; Bool_t IsSortable() const { return kTRUE; }; Int_t Compare(const TObject *obj) const; { if (num < ((TObjNum*)obj)->num) return -1;; else if (num > ((TObjNum*)obj)->num) return 1;; else return 0; }; ULong_t Hash() const { return num; }; };; ```. ## The TIter Generic Iterator. As stated above, the **`TIterator`** class is abstract; it is not; possible to create **`TIterator`** objects. However, it should be; possible to write generic code to process all members of a collection so; there is a need for a generic iterator object. A **`TIter`** object acts; as generic iterator. It provides the same `Next()` and `Reset()` methods; as **`TIterator`** although it has no idea how to support them! It works; as follows:. - To create a **`TIter`** object its constructor must be passed an; object that inherits from **`TCollection`**. The **`TIter`**; constructor calls the `MakeIterator()` method of this collection to; get the appropriate iterator object that inherits from; **`TIterator`**. - The `Next()` and `Reset()` methods of **`TIter`** simply call the; `Next()` and `Reset()` methods of the iterator object. Therefore, **`TIter`** simply acts as a wrapper for an object of a; concrete class inheriting from **`TIterator`**. To see this working in practice, consider the **`TObjArray`**; collection. Its associated iterator is **`TObjArrayIter`**. Suppose; `myarray` is a pointer to a **`TObjArray`** that contains `MyClass`; objects, i.e. ``` {.cpp}; TObjArray *myarray;; ```. To create a **`TIter`** object called `myiter`:. ``` {.cpp}; TIter myiter(myarray);; ```. ![](pictures/020001A4.jpg). As shown in the diagram, this results in several methods being called:. - The **`TIter`** constructor is passed a **`TObjArray`**. - **`TIter`** asks embedded **`TCollection`** to make an iterator. - **`TCollection`** asks **`TObjArray`** to make an iterator. - **`TObjArray`** returns a **`TObjArrayIter`**. ",MatchSource.DOCS,documentation/users-guide/CollectionClasses.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md:11270,Modifiability,inherit,inheriting,11270,"urn 1;; else return 0; }; ULong_t Hash() const { return num; }; };; ```. ## The TIter Generic Iterator. As stated above, the **`TIterator`** class is abstract; it is not; possible to create **`TIterator`** objects. However, it should be; possible to write generic code to process all members of a collection so; there is a need for a generic iterator object. A **`TIter`** object acts; as generic iterator. It provides the same `Next()` and `Reset()` methods; as **`TIterator`** although it has no idea how to support them! It works; as follows:. - To create a **`TIter`** object its constructor must be passed an; object that inherits from **`TCollection`**. The **`TIter`**; constructor calls the `MakeIterator()` method of this collection to; get the appropriate iterator object that inherits from; **`TIterator`**. - The `Next()` and `Reset()` methods of **`TIter`** simply call the; `Next()` and `Reset()` methods of the iterator object. Therefore, **`TIter`** simply acts as a wrapper for an object of a; concrete class inheriting from **`TIterator`**. To see this working in practice, consider the **`TObjArray`**; collection. Its associated iterator is **`TObjArrayIter`**. Suppose; `myarray` is a pointer to a **`TObjArray`** that contains `MyClass`; objects, i.e. ``` {.cpp}; TObjArray *myarray;; ```. To create a **`TIter`** object called `myiter`:. ``` {.cpp}; TIter myiter(myarray);; ```. ![](pictures/020001A4.jpg). As shown in the diagram, this results in several methods being called:. - The **`TIter`** constructor is passed a **`TObjArray`**. - **`TIter`** asks embedded **`TCollection`** to make an iterator. - **`TCollection`** asks **`TObjArray`** to make an iterator. - **`TObjArray`** returns a **`TObjArrayIter`**. Now define a pointer for `MyClass` objects and set it to each member of; the **`TObjArray`**:. ``` {.cpp}; MyClass *myobject;; while ((myobject = (MyClass *)myiter.Next())) {; // process myobject; }; ```. The heart of this is the `myiter.Next()` expression whic",MatchSource.DOCS,documentation/users-guide/CollectionClasses.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md:17993,Modifiability,polymorphi,polymorphic,17993," x O(10000) times new/delete):. ``` {.cpp}; TObjArray a(10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000); for (int i = 0; i < ev->Ntracks; i++) { // O(10000); a[i] = new TTrack(x,y,z,...);; ...; }; ...; a.Delete();; }; ```. You better use a **`TClonesArray`** which reduces the number of; new/delete calls to only O(10000):. ``` {.cpp}; TClonesArray a(""TTrack"", 10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000); for (int i = 0; i < ev->Ntracks; i++) { // O(10000); TTrack *track = (Track*)a.ConstructedAt(i);; track->Set(x,y,z,...);; ...; }; ...; a.Clear(); // Or Clear(""C"") if the track objects must be returned (via Track::Clear) to a default state.; }; ```. Considering that a pair of new/delete calls on average cost about 70 ms,; O(109) new/deletes will save about 19 hours. For the other collections,; see the class reference guide on the web and the test program; `$ROOTSYS/test/tcollex.cxx.`. ## Template Containers and STL. Some people dislike polymorphic containers because they are not truly; ""type safe"". In the end, the compiler leaves it the user to ensure that; the types are correct. This only leaves the other alternative: creating; a new class each time a new (container organization) / (contained; object) combination is needed. To say the least this could be very; tedious. Most people faced with this choice would, for each type of; container:. Define the class leaving a dummy name for the contained object type.; When a particular container was needed, copy the code and then do a; global search and replace for the contained class. C++ has a built in; template scheme that effectively does just this. For example:. ``` {.cpp}; template<class T>; class ArrayContainer {; private:; T *member[10];; ...; };; ```. This is an array container with a 10-element array of pointers to T, it; could hold up to 10 T objects. This array is flawed because it is static; and hard-coded, it should be dynamic. However, the important point is; that the template stat",MatchSource.DOCS,documentation/users-guide/CollectionClasses.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md:19056,Modifiability,parameteriz,parameterized,19056,"ecause they are not truly; ""type safe"". In the end, the compiler leaves it the user to ensure that; the types are correct. This only leaves the other alternative: creating; a new class each time a new (container organization) / (contained; object) combination is needed. To say the least this could be very; tedious. Most people faced with this choice would, for each type of; container:. Define the class leaving a dummy name for the contained object type.; When a particular container was needed, copy the code and then do a; global search and replace for the contained class. C++ has a built in; template scheme that effectively does just this. For example:. ``` {.cpp}; template<class T>; class ArrayContainer {; private:; T *member[10];; ...; };; ```. This is an array container with a 10-element array of pointers to T, it; could hold up to 10 T objects. This array is flawed because it is static; and hard-coded, it should be dynamic. However, the important point is; that the template statement indicates that T is a template, or; parameterized class. If we need an `ArrayContainer` for Track objects,; it can be created by:. ``` {.cpp}; ArrayContainer<Track> MyTrackArrayContainer;; ```. C++ takes the parameter list and substitutes Track for T throughout the; definition of the class `ArrayContainer`, then compiles the code so; generated, effectively doing the same we could do by hand, but with a; lot less effort. This produces code that is type safe, but does have different drawbacks:. - Templates make code harder to read. - At the time of writing this documentation, some compilers can be; very slow when dealing with templates. - It does not solve the problem when a container has to hold a; heterogeneous set of objects. - The system can end up generating a great deal of code; each; container/object combination has its own code, a phenomenon that is; sometimes referred to as *code bloat*. - The Standard Template Library (STL) is part on ANSI C++, and; includes a set of templat",MatchSource.DOCS,documentation/users-guide/CollectionClasses.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md:8483,Performance,tune,tune,8483,"the class,; the method `Delete` is called for the owning collection to delete; correctly its entire track objects. To delete the objects in the; container use `fTrack->Delete()`. To delete the container itself, do; '`delete fTracks'.`. ``` {.cpp}; class TEvent : public TObject {; private:; TList *fTracks; //list of all tracks; TList *fVertex1; //subset of tracks part of vertex1; TList *fVertex2; //subset of tracks part of vertex2; };; TEvent::~TEvent(); {; fTracks->Delete();; delete fTracks;; delete fVertex1;; delete fVertex2;; }; ```. The **`TIterator`** class defines the minimum set of member functions; that all iterators must support. These include:. - `Next`; `Returns the next member of the collection or 0 if no more members.`. - `Reset` `Resets the iterator so that ` `Next`; ` returns the first object.`. ## A Collectable Class. By default, all objects of **`TObject`** derived classes can be stored; in ROOT containers. However, the **`TObject`** class provides some; member functions that allow you to tune the behavior of objects in; containers. For example, by default two objects are considered equal if; their pointers point to the same address. This might be too strict for; some classes where equality is already achieved if some or all of the; data members are equal. By overriding the following **`TObject`** member; functions, you can change the behavior of objects in collections:. - `IsEqual()`is used by the `FindObject() `collection method. By; default, `IsEqual()` compares the two object pointers. - `Compare()`returns -1, 0 or 1 depending if the object is smaller,; equal or larger than the other object. By default, a **`TObject`**; has not a valid `Compare()` method. - `IsSortable() `returns true if the class is sort able (i.e. if it; has a valid `Compare(`) method). By default, a **`TObject`** is not; sort able. - `Hash() `returns a hash value. It needs to be implemented if an; object has to be stored in a collection using a hashing technique,; like **`THas",MatchSource.DOCS,documentation/users-guide/CollectionClasses.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md:15341,Performance,perform,performance,15341,"ListOfFree()->After(idcur);; }; ```. Method 1 uses internally method 2. Method 2 works for all collection classes. **`TIter`** overloads; `operator()`. Methods 3 and 4 are specific for **`TList`**. Methods 2, 3 and 4 can also easily iterate backwards using either a; backward **`TIter`** (using argument `kIterBackward`) or by using; `LastLink()` and `lnk>Prev`() or by using the `Before()` method. ## The TObjArray Collection. A **`TObjArray`** is a collection which supports traditional array; semantics via the overloading of `operator[]`. Objects can be directly; accessed via an index. The array expands automatically when objects are; added. At creation time one specifies the default array size (default =; 16) and lower bound (default = 0). Resizing involves a re-allocation and; a copy of the old array to the new. This can be costly if done too; often. If possible, set initial size close to expected final size. Index; validity is always checked (if you are 100% sure and maximum performance; is needed you can use `UnCheckedAt()` instead of `At()` or; `operator[]`). If the stored objects are sort able the array can be; sorted using `Sort()`. Once sorted, efficient searching is possible via; the `BinarySearch()` method. The figure shows the internal data; structure of a **`TObjArray`**:. ![The internal data structure of a TObjArray](pictures/020001A7.jpg). Iterating can be done using a **`TIter`** iterator or via a simple for; loop:. ``` {.cpp}; for (int i = 0; i <= fArr.GetLast(); i++); if ((track = (TTrack*)fArr[i])) // or fArr.At(i); track->Draw();; ```. Main features of **`TObjArray`** are simple, well-known array semantics.; **Overhead per element**: none, except possible over sizing of `fCont`. ## TClonesArray An Array of Identical Objects. A **`TClonesArray`** is an array of identical (clone) objects. The; memory for the objects stored in the array is allocated only once in the; lifetime of the clones array. All objects must be of the same class. For; the rest thi",MatchSource.DOCS,documentation/users-guide/CollectionClasses.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md:18050,Safety,safe,safe,18050," x O(10000) times new/delete):. ``` {.cpp}; TObjArray a(10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000); for (int i = 0; i < ev->Ntracks; i++) { // O(10000); a[i] = new TTrack(x,y,z,...);; ...; }; ...; a.Delete();; }; ```. You better use a **`TClonesArray`** which reduces the number of; new/delete calls to only O(10000):. ``` {.cpp}; TClonesArray a(""TTrack"", 10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000); for (int i = 0; i < ev->Ntracks; i++) { // O(10000); TTrack *track = (Track*)a.ConstructedAt(i);; track->Set(x,y,z,...);; ...; }; ...; a.Clear(); // Or Clear(""C"") if the track objects must be returned (via Track::Clear) to a default state.; }; ```. Considering that a pair of new/delete calls on average cost about 70 ms,; O(109) new/deletes will save about 19 hours. For the other collections,; see the class reference guide on the web and the test program; `$ROOTSYS/test/tcollex.cxx.`. ## Template Containers and STL. Some people dislike polymorphic containers because they are not truly; ""type safe"". In the end, the compiler leaves it the user to ensure that; the types are correct. This only leaves the other alternative: creating; a new class each time a new (container organization) / (contained; object) combination is needed. To say the least this could be very; tedious. Most people faced with this choice would, for each type of; container:. Define the class leaving a dummy name for the contained object type.; When a particular container was needed, copy the code and then do a; global search and replace for the contained class. C++ has a built in; template scheme that effectively does just this. For example:. ``` {.cpp}; template<class T>; class ArrayContainer {; private:; T *member[10];; ...; };; ```. This is an array container with a 10-element array of pointers to T, it; could hold up to 10 T objects. This array is flawed because it is static; and hard-coded, it should be dynamic. However, the important point is; that the template stat",MatchSource.DOCS,documentation/users-guide/CollectionClasses.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md:19476,Safety,safe,safe,19476,"e not truly; ""type safe"". In the end, the compiler leaves it the user to ensure that; the types are correct. This only leaves the other alternative: creating; a new class each time a new (container organization) / (contained; object) combination is needed. To say the least this could be very; tedious. Most people faced with this choice would, for each type of; container:. Define the class leaving a dummy name for the contained object type.; When a particular container was needed, copy the code and then do a; global search and replace for the contained class. C++ has a built in; template scheme that effectively does just this. For example:. ``` {.cpp}; template<class T>; class ArrayContainer {; private:; T *member[10];; ...; };; ```. This is an array container with a 10-element array of pointers to T, it; could hold up to 10 T objects. This array is flawed because it is static; and hard-coded, it should be dynamic. However, the important point is; that the template statement indicates that T is a template, or; parameterized class. If we need an `ArrayContainer` for Track objects,; it can be created by:. ``` {.cpp}; ArrayContainer<Track> MyTrackArrayContainer;; ```. C++ takes the parameter list and substitutes Track for T throughout the; definition of the class `ArrayContainer`, then compiles the code so; generated, effectively doing the same we could do by hand, but with a; lot less effort. This produces code that is type safe, but does have different drawbacks:. - Templates make code harder to read. - At the time of writing this documentation, some compilers can be; very slow when dealing with templates. - It does not solve the problem when a container has to hold a; heterogeneous set of objects. - The system can end up generating a great deal of code; each; container/object combination has its own code, a phenomenon that is; sometimes referred to as *code bloat*. - The Standard Template Library (STL) is part on ANSI C++, and; includes a set of template containers. ",MatchSource.DOCS,documentation/users-guide/CollectionClasses.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md:487,Security,hash,hash,487,"# Collection Classes. Collections are a key feature of the ROOT system. Many, if not most, of; the applications you write will use collections. If you have used; parameterized C++ collections or polymorphic collections before, some of; this material will be review. However, much of this chapter covers; aspects of collections specific to the ROOT system. When you have read; this chapter, you will know. - How to create instances of collections. - The difference between lists, arrays, hash tables, maps, etc. - How to add and remove elements of a collection. - How to search a collection for a specific element. - How to access and modify collection elements. - How to iterate over a collection to access collection elements. - How to manage memory for collections and collection elements. - How collection elements are tested for equality (`IsEqual(`)). - How collection elements are compared (`Compare())` in case of sorted; collections. - How collection elements are hashed (`Hash()`) in hash tables. ## Understanding Collections. A collection is a group of related objects. You will find it easier to; manage a large number of items as a collection. For example, a diagram; editor might manage a collection of points and lines. A set of widgets; for a graphical user interface can be placed in a collection. A; geometrical model can be described by collections of shapes, materials; and rotation matrices. Collections can themselves be placed in; collections. Collections act as flexible alternatives to traditional; data structures of computers science such as arrays, lists and trees. ### General Characteristics. The ROOT collections are polymorphic containers that hold pointers to; `TObjects`, so:. - They can only hold objects that inherit from **`TObject`**. - They return pointers to `TObjects`, that have to be cast back to the; correct subclass. Collections are dynamic; they can grow in size as required. Collections; themselves are descendants of **`TObject`** so can themselves be h",MatchSource.DOCS,documentation/users-guide/CollectionClasses.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md:623,Security,access,access,623,"# Collection Classes. Collections are a key feature of the ROOT system. Many, if not most, of; the applications you write will use collections. If you have used; parameterized C++ collections or polymorphic collections before, some of; this material will be review. However, much of this chapter covers; aspects of collections specific to the ROOT system. When you have read; this chapter, you will know. - How to create instances of collections. - The difference between lists, arrays, hash tables, maps, etc. - How to add and remove elements of a collection. - How to search a collection for a specific element. - How to access and modify collection elements. - How to iterate over a collection to access collection elements. - How to manage memory for collections and collection elements. - How collection elements are tested for equality (`IsEqual(`)). - How collection elements are compared (`Compare())` in case of sorted; collections. - How collection elements are hashed (`Hash()`) in hash tables. ## Understanding Collections. A collection is a group of related objects. You will find it easier to; manage a large number of items as a collection. For example, a diagram; editor might manage a collection of points and lines. A set of widgets; for a graphical user interface can be placed in a collection. A; geometrical model can be described by collections of shapes, materials; and rotation matrices. Collections can themselves be placed in; collections. Collections act as flexible alternatives to traditional; data structures of computers science such as arrays, lists and trees. ### General Characteristics. The ROOT collections are polymorphic containers that hold pointers to; `TObjects`, so:. - They can only hold objects that inherit from **`TObject`**. - They return pointers to `TObjects`, that have to be cast back to the; correct subclass. Collections are dynamic; they can grow in size as required. Collections; themselves are descendants of **`TObject`** so can themselves be h",MatchSource.DOCS,documentation/users-guide/CollectionClasses.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md:700,Security,access,access,700,"# Collection Classes. Collections are a key feature of the ROOT system. Many, if not most, of; the applications you write will use collections. If you have used; parameterized C++ collections or polymorphic collections before, some of; this material will be review. However, much of this chapter covers; aspects of collections specific to the ROOT system. When you have read; this chapter, you will know. - How to create instances of collections. - The difference between lists, arrays, hash tables, maps, etc. - How to add and remove elements of a collection. - How to search a collection for a specific element. - How to access and modify collection elements. - How to iterate over a collection to access collection elements. - How to manage memory for collections and collection elements. - How collection elements are tested for equality (`IsEqual(`)). - How collection elements are compared (`Compare())` in case of sorted; collections. - How collection elements are hashed (`Hash()`) in hash tables. ## Understanding Collections. A collection is a group of related objects. You will find it easier to; manage a large number of items as a collection. For example, a diagram; editor might manage a collection of points and lines. A set of widgets; for a graphical user interface can be placed in a collection. A; geometrical model can be described by collections of shapes, materials; and rotation matrices. Collections can themselves be placed in; collections. Collections act as flexible alternatives to traditional; data structures of computers science such as arrays, lists and trees. ### General Characteristics. The ROOT collections are polymorphic containers that hold pointers to; `TObjects`, so:. - They can only hold objects that inherit from **`TObject`**. - They return pointers to `TObjects`, that have to be cast back to the; correct subclass. Collections are dynamic; they can grow in size as required. Collections; themselves are descendants of **`TObject`** so can themselves be h",MatchSource.DOCS,documentation/users-guide/CollectionClasses.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md:972,Security,hash,hashed,972,"# Collection Classes. Collections are a key feature of the ROOT system. Many, if not most, of; the applications you write will use collections. If you have used; parameterized C++ collections or polymorphic collections before, some of; this material will be review. However, much of this chapter covers; aspects of collections specific to the ROOT system. When you have read; this chapter, you will know. - How to create instances of collections. - The difference between lists, arrays, hash tables, maps, etc. - How to add and remove elements of a collection. - How to search a collection for a specific element. - How to access and modify collection elements. - How to iterate over a collection to access collection elements. - How to manage memory for collections and collection elements. - How collection elements are tested for equality (`IsEqual(`)). - How collection elements are compared (`Compare())` in case of sorted; collections. - How collection elements are hashed (`Hash()`) in hash tables. ## Understanding Collections. A collection is a group of related objects. You will find it easier to; manage a large number of items as a collection. For example, a diagram; editor might manage a collection of points and lines. A set of widgets; for a graphical user interface can be placed in a collection. A; geometrical model can be described by collections of shapes, materials; and rotation matrices. Collections can themselves be placed in; collections. Collections act as flexible alternatives to traditional; data structures of computers science such as arrays, lists and trees. ### General Characteristics. The ROOT collections are polymorphic containers that hold pointers to; `TObjects`, so:. - They can only hold objects that inherit from **`TObject`**. - They return pointers to `TObjects`, that have to be cast back to the; correct subclass. Collections are dynamic; they can grow in size as required. Collections; themselves are descendants of **`TObject`** so can themselves be h",MatchSource.DOCS,documentation/users-guide/CollectionClasses.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md:993,Security,hash,hash,993,"# Collection Classes. Collections are a key feature of the ROOT system. Many, if not most, of; the applications you write will use collections. If you have used; parameterized C++ collections or polymorphic collections before, some of; this material will be review. However, much of this chapter covers; aspects of collections specific to the ROOT system. When you have read; this chapter, you will know. - How to create instances of collections. - The difference between lists, arrays, hash tables, maps, etc. - How to add and remove elements of a collection. - How to search a collection for a specific element. - How to access and modify collection elements. - How to iterate over a collection to access collection elements. - How to manage memory for collections and collection elements. - How collection elements are tested for equality (`IsEqual(`)). - How collection elements are compared (`Compare())` in case of sorted; collections. - How collection elements are hashed (`Hash()`) in hash tables. ## Understanding Collections. A collection is a group of related objects. You will find it easier to; manage a large number of items as a collection. For example, a diagram; editor might manage a collection of points and lines. A set of widgets; for a graphical user interface can be placed in a collection. A; geometrical model can be described by collections of shapes, materials; and rotation matrices. Collections can themselves be placed in; collections. Collections act as flexible alternatives to traditional; data structures of computers science such as arrays, lists and trees. ### General Characteristics. The ROOT collections are polymorphic containers that hold pointers to; `TObjects`, so:. - They can only hold objects that inherit from **`TObject`**. - They return pointers to `TObjects`, that have to be cast back to the; correct subclass. Collections are dynamic; they can grow in size as required. Collections; themselves are descendants of **`TObject`** so can themselves be h",MatchSource.DOCS,documentation/users-guide/CollectionClasses.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md:6047,Security,access,access,6047,"te over an unordered collection, you are; not likely to retrieve elements in the same order they were added to the; collection. The following unordered collections are available:. - **`THashTable`**. - **`TMap`**. ## Iterators: Processing a Collection. The concept of processing all the members of a collection is generic,; i.e. independent of any specific representation of a collection. To; process each object in a collection one needs some type of cursor that; is initialized and then steps over each member of the collection in; turn. Collection objects could provide this service but there is a snag:; as there is only one collection object per collection there would only; be one cursor. Instead, to permit the use of as many cursors as; required, they are made separate classes called iterator. For each; collection class there is an associated iterator class that knows how to; sequentially retrieve each member in turn. The relationship between a; collection and its iterator is very close and may require that the; iterator has full access to the collection (i.e. it is a friend class).; In general iterator will be used via the **`TIter`** wrapper class. For; example:. - **`TList`** **`TListIter`**. - **`TMap`** **`TMapIter`**. ## Foundation Classes. All collections are based on the fundamental classes: **`TCollection`**; and **`TIterator`**. They are so generic that it is not possible to; create objects from them; they are only used as base classes for other; classes (i.e. they are abstract base classes). The **`TCollection`** class provides the basic protocol (i.e. the; minimum set of member functions) that all collection classes have to; implement. These include:. - `Add` `Adds another object to the collection.`. - `GetSize` `Returns the number of objects in the collection.`. - `Clear`; `Clears out the collection, but does not delete the removed objects.`. - `Delete`; `Clears out the collection and deletes the removed objects. This should only `; `be used if the collect",MatchSource.DOCS,documentation/users-guide/CollectionClasses.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md:9337,Security,hash,hash,9337," of **`TObject`** derived classes can be stored; in ROOT containers. However, the **`TObject`** class provides some; member functions that allow you to tune the behavior of objects in; containers. For example, by default two objects are considered equal if; their pointers point to the same address. This might be too strict for; some classes where equality is already achieved if some or all of the; data members are equal. By overriding the following **`TObject`** member; functions, you can change the behavior of objects in collections:. - `IsEqual()`is used by the `FindObject() `collection method. By; default, `IsEqual()` compares the two object pointers. - `Compare()`returns -1, 0 or 1 depending if the object is smaller,; equal or larger than the other object. By default, a **`TObject`**; has not a valid `Compare()` method. - `IsSortable() `returns true if the class is sort able (i.e. if it; has a valid `Compare(`) method). By default, a **`TObject`** is not; sort able. - `Hash() `returns a hash value. It needs to be implemented if an; object has to be stored in a collection using a hashing technique,; like **`THashTable`**, **`THashList`** and **`TMap`**. By default,; `Hash(`) returns the address of the object. It is essential to; choose a good hash function. The example below shows how to use and override these member functions. ``` {.cpp}; class TObjNum : public TObject {; private:; Int_t num; // TObjNum is a simple container for an integer.; public:; TObjNum(Int_t i = 0) : num(i) { }; ~TObjNum() { }; void SetNum(Int_t i) { num = i; }; Int_t GetNum() const { return num; }; void Print(Option_t *) const; { printf(""num = %dn"", num); }; Bool_t IsEqual(TObject *obj) const; { return num == ((TObjNum*)obj)->num; }; Bool_t IsSortable() const { return kTRUE; }; Int_t Compare(const TObject *obj) const; { if (num < ((TObjNum*)obj)->num) return -1;; else if (num > ((TObjNum*)obj)->num) return 1;; else return 0; }; ULong_t Hash() const { return num; }; };; ```. ## The TIter Ge",MatchSource.DOCS,documentation/users-guide/CollectionClasses.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md:9431,Security,hash,hashing,9431," class provides some; member functions that allow you to tune the behavior of objects in; containers. For example, by default two objects are considered equal if; their pointers point to the same address. This might be too strict for; some classes where equality is already achieved if some or all of the; data members are equal. By overriding the following **`TObject`** member; functions, you can change the behavior of objects in collections:. - `IsEqual()`is used by the `FindObject() `collection method. By; default, `IsEqual()` compares the two object pointers. - `Compare()`returns -1, 0 or 1 depending if the object is smaller,; equal or larger than the other object. By default, a **`TObject`**; has not a valid `Compare()` method. - `IsSortable() `returns true if the class is sort able (i.e. if it; has a valid `Compare(`) method). By default, a **`TObject`** is not; sort able. - `Hash() `returns a hash value. It needs to be implemented if an; object has to be stored in a collection using a hashing technique,; like **`THashTable`**, **`THashList`** and **`TMap`**. By default,; `Hash(`) returns the address of the object. It is essential to; choose a good hash function. The example below shows how to use and override these member functions. ``` {.cpp}; class TObjNum : public TObject {; private:; Int_t num; // TObjNum is a simple container for an integer.; public:; TObjNum(Int_t i = 0) : num(i) { }; ~TObjNum() { }; void SetNum(Int_t i) { num = i; }; Int_t GetNum() const { return num; }; void Print(Option_t *) const; { printf(""num = %dn"", num); }; Bool_t IsEqual(TObject *obj) const; { return num == ((TObjNum*)obj)->num; }; Bool_t IsSortable() const { return kTRUE; }; Int_t Compare(const TObject *obj) const; { if (num < ((TObjNum*)obj)->num) return -1;; else if (num > ((TObjNum*)obj)->num) return 1;; else return 0; }; ULong_t Hash() const { return num; }; };; ```. ## The TIter Generic Iterator. As stated above, the **`TIterator`** class is abstract; it is not; possible to ",MatchSource.DOCS,documentation/users-guide/CollectionClasses.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md:9597,Security,hash,hash,9597,"f; their pointers point to the same address. This might be too strict for; some classes where equality is already achieved if some or all of the; data members are equal. By overriding the following **`TObject`** member; functions, you can change the behavior of objects in collections:. - `IsEqual()`is used by the `FindObject() `collection method. By; default, `IsEqual()` compares the two object pointers. - `Compare()`returns -1, 0 or 1 depending if the object is smaller,; equal or larger than the other object. By default, a **`TObject`**; has not a valid `Compare()` method. - `IsSortable() `returns true if the class is sort able (i.e. if it; has a valid `Compare(`) method). By default, a **`TObject`** is not; sort able. - `Hash() `returns a hash value. It needs to be implemented if an; object has to be stored in a collection using a hashing technique,; like **`THashTable`**, **`THashList`** and **`TMap`**. By default,; `Hash(`) returns the address of the object. It is essential to; choose a good hash function. The example below shows how to use and override these member functions. ``` {.cpp}; class TObjNum : public TObject {; private:; Int_t num; // TObjNum is a simple container for an integer.; public:; TObjNum(Int_t i = 0) : num(i) { }; ~TObjNum() { }; void SetNum(Int_t i) { num = i; }; Int_t GetNum() const { return num; }; void Print(Option_t *) const; { printf(""num = %dn"", num); }; Bool_t IsEqual(TObject *obj) const; { return num == ((TObjNum*)obj)->num; }; Bool_t IsSortable() const { return kTRUE; }; Int_t Compare(const TObject *obj) const; { if (num < ((TObjNum*)obj)->num) return -1;; else if (num > ((TObjNum*)obj)->num) return 1;; else return 0; }; ULong_t Hash() const { return num; }; };; ```. ## The TIter Generic Iterator. As stated above, the **`TIterator`** class is abstract; it is not; possible to create **`TIterator`** objects. However, it should be; possible to write generic code to process all members of a collection so; there is a need for a generic i",MatchSource.DOCS,documentation/users-guide/CollectionClasses.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md:14918,Security,access,accessed,14918,"ListOfTracks());; while ((TTrack *obj = (TTrack *)next())); obj->Draw();; ```. - Using the **`TObjLink`** list entries (that wrap the; **`TObject`**\*):. ``` {.cpp}; TObjLink *lnk = GetListOfPrimitives()->FirstLink();; while (lnk) {; lnk->GetObject()->Draw();; lnk = lnk->Next();; }; ```. - Using the **`TList`**'s `After()` and `Before()` member functions:. ``` {.cpp}; TFree *idcur = this;; while (idcur) {; ...; idcur = (TFree*)GetListOfFree()->After(idcur);; }; ```. Method 1 uses internally method 2. Method 2 works for all collection classes. **`TIter`** overloads; `operator()`. Methods 3 and 4 are specific for **`TList`**. Methods 2, 3 and 4 can also easily iterate backwards using either a; backward **`TIter`** (using argument `kIterBackward`) or by using; `LastLink()` and `lnk>Prev`() or by using the `Before()` method. ## The TObjArray Collection. A **`TObjArray`** is a collection which supports traditional array; semantics via the overloading of `operator[]`. Objects can be directly; accessed via an index. The array expands automatically when objects are; added. At creation time one specifies the default array size (default =; 16) and lower bound (default = 0). Resizing involves a re-allocation and; a copy of the old array to the new. This can be costly if done too; often. If possible, set initial size close to expected final size. Index; validity is always checked (if you are 100% sure and maximum performance; is needed you can use `UnCheckedAt()` instead of `At()` or; `operator[]`). If the stored objects are sort able the array can be; sorted using `Sort()`. Once sorted, efficient searching is possible via; the `BinarySearch()` method. The figure shows the internal data; structure of a **`TObjArray`**:. ![The internal data structure of a TObjArray](pictures/020001A7.jpg). Iterating can be done using a **`TIter`** iterator or via a simple for; loop:. ``` {.cpp}; for (int i = 0; i <= fArr.GetLast(); i++); if ((track = (TTrack*)fArr[i])) // or fArr.At(i); track->D",MatchSource.DOCS,documentation/users-guide/CollectionClasses.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md:822,Testability,test,tested,822,"# Collection Classes. Collections are a key feature of the ROOT system. Many, if not most, of; the applications you write will use collections. If you have used; parameterized C++ collections or polymorphic collections before, some of; this material will be review. However, much of this chapter covers; aspects of collections specific to the ROOT system. When you have read; this chapter, you will know. - How to create instances of collections. - The difference between lists, arrays, hash tables, maps, etc. - How to add and remove elements of a collection. - How to search a collection for a specific element. - How to access and modify collection elements. - How to iterate over a collection to access collection elements. - How to manage memory for collections and collection elements. - How collection elements are tested for equality (`IsEqual(`)). - How collection elements are compared (`Compare())` in case of sorted; collections. - How collection elements are hashed (`Hash()`) in hash tables. ## Understanding Collections. A collection is a group of related objects. You will find it easier to; manage a large number of items as a collection. For example, a diagram; editor might manage a collection of points and lines. A set of widgets; for a graphical user interface can be placed in a collection. A; geometrical model can be described by collections of shapes, materials; and rotation matrices. Collections can themselves be placed in; collections. Collections act as flexible alternatives to traditional; data structures of computers science such as arrays, lists and trees. ### General Characteristics. The ROOT collections are polymorphic containers that hold pointers to; `TObjects`, so:. - They can only hold objects that inherit from **`TObject`**. - They return pointers to `TObjects`, that have to be cast back to the; correct subclass. Collections are dynamic; they can grow in size as required. Collections; themselves are descendants of **`TObject`** so can themselves be h",MatchSource.DOCS,documentation/users-guide/CollectionClasses.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md:3286,Testability,test,test,3286,"important when it comes to deleting objects; if; nobody owns the object it could end up as wasted memory (i.e. a memory; leak) when no longer needed. If a collection is deleted, its objects are; not. The user can force a collection to delete its objects, but that is; the user's choice. ### Determining the Class of Contained Objects. Most containers may hold heterogeneous collections of objects and then; it is left to the user to correctly cast the **`TObject`** pointer to; the right class. Casting to the wrong class will give wrong results and; may well crash the program! Therefore, the user has to be very careful.; Often a container only contains one class of objects, but if it really; contains a mixture, it is possible to ask each object about its class; using the `InheritsFrom` method. For example if `myObject` is a **`TObject`** pointer:. ``` {.cpp}; if (myObject->InheritsFrom(""TParticle"") {; printf(""myObject is a TParticlen"");; }; ```. As the name suggests, this test works even if the object is a subclass; of **`TParticle`**. The member function `IsA()` can be used instead of; `InheritsFrom` to make the test exact. The `InheritsFrom` and `IsA`; methods use the extensive Run Time Type Information (RTTI) available via; the ROOT meta-classes. ### Types of Collections. The ROOT system implements the following basic types of collections:; unordered collections, ordered collections and sorted collections. Next; figure shows the inheritance hierarchy for the primary collection; classes. All primary collection classes derive from the abstract base; class **`TCollection`**. ![The inheritance hierarchy of the primary collection classes](pictures/020001A3.jpg). ### Ordered Collections (Sequences). Sequences are collections that are externally ordered because they; maintain internal elements according to the order in which they were; added. The following sequences are available:. - **`TList`**. - **`THashList`**. - **`TOrdCollection`**. - **`TObjArray`**. - **`TClonesArray",MatchSource.DOCS,documentation/users-guide/CollectionClasses.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md:3430,Testability,test,test,3430,"wasted memory (i.e. a memory; leak) when no longer needed. If a collection is deleted, its objects are; not. The user can force a collection to delete its objects, but that is; the user's choice. ### Determining the Class of Contained Objects. Most containers may hold heterogeneous collections of objects and then; it is left to the user to correctly cast the **`TObject`** pointer to; the right class. Casting to the wrong class will give wrong results and; may well crash the program! Therefore, the user has to be very careful.; Often a container only contains one class of objects, but if it really; contains a mixture, it is possible to ask each object about its class; using the `InheritsFrom` method. For example if `myObject` is a **`TObject`** pointer:. ``` {.cpp}; if (myObject->InheritsFrom(""TParticle"") {; printf(""myObject is a TParticlen"");; }; ```. As the name suggests, this test works even if the object is a subclass; of **`TParticle`**. The member function `IsA()` can be used instead of; `InheritsFrom` to make the test exact. The `InheritsFrom` and `IsA`; methods use the extensive Run Time Type Information (RTTI) available via; the ROOT meta-classes. ### Types of Collections. The ROOT system implements the following basic types of collections:; unordered collections, ordered collections and sorted collections. Next; figure shows the inheritance hierarchy for the primary collection; classes. All primary collection classes derive from the abstract base; class **`TCollection`**. ![The inheritance hierarchy of the primary collection classes](pictures/020001A3.jpg). ### Ordered Collections (Sequences). Sequences are collections that are externally ordered because they; maintain internal elements according to the order in which they were; added. The following sequences are available:. - **`TList`**. - **`THashList`**. - **`TOrdCollection`**. - **`TObjArray`**. - **`TClonesArray`**. The **`TOrdCollection`**, **`TObjArray`** as well as the; **`TClonesArray`** can be sor",MatchSource.DOCS,documentation/users-guide/CollectionClasses.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md:17897,Testability,test,test,17897," supported. ### The Idea Behind TClonesArray. To reduce the very large number of new and delete calls in large loops; like this (O(100000) x O(10000) times new/delete):. ``` {.cpp}; TObjArray a(10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000); for (int i = 0; i < ev->Ntracks; i++) { // O(10000); a[i] = new TTrack(x,y,z,...);; ...; }; ...; a.Delete();; }; ```. You better use a **`TClonesArray`** which reduces the number of; new/delete calls to only O(10000):. ``` {.cpp}; TClonesArray a(""TTrack"", 10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000); for (int i = 0; i < ev->Ntracks; i++) { // O(10000); TTrack *track = (Track*)a.ConstructedAt(i);; track->Set(x,y,z,...);; ...; }; ...; a.Clear(); // Or Clear(""C"") if the track objects must be returned (via Track::Clear) to a default state.; }; ```. Considering that a pair of new/delete calls on average cost about 70 ms,; O(109) new/deletes will save about 19 hours. For the other collections,; see the class reference guide on the web and the test program; `$ROOTSYS/test/tcollex.cxx.`. ## Template Containers and STL. Some people dislike polymorphic containers because they are not truly; ""type safe"". In the end, the compiler leaves it the user to ensure that; the types are correct. This only leaves the other alternative: creating; a new class each time a new (container organization) / (contained; object) combination is needed. To say the least this could be very; tedious. Most people faced with this choice would, for each type of; container:. Define the class leaving a dummy name for the contained object type.; When a particular container was needed, copy the code and then do a; global search and replace for the contained class. C++ has a built in; template scheme that effectively does just this. For example:. ``` {.cpp}; template<class T>; class ArrayContainer {; private:; T *member[10];; ...; };; ```. This is an array container with a 10-element array of pointers to T, it; could hold up to 10 T objects.",MatchSource.DOCS,documentation/users-guide/CollectionClasses.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md:17921,Testability,test,test,17921," supported. ### The Idea Behind TClonesArray. To reduce the very large number of new and delete calls in large loops; like this (O(100000) x O(10000) times new/delete):. ``` {.cpp}; TObjArray a(10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000); for (int i = 0; i < ev->Ntracks; i++) { // O(10000); a[i] = new TTrack(x,y,z,...);; ...; }; ...; a.Delete();; }; ```. You better use a **`TClonesArray`** which reduces the number of; new/delete calls to only O(10000):. ``` {.cpp}; TClonesArray a(""TTrack"", 10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000); for (int i = 0; i < ev->Ntracks; i++) { // O(10000); TTrack *track = (Track*)a.ConstructedAt(i);; track->Set(x,y,z,...);; ...; }; ...; a.Clear(); // Or Clear(""C"") if the track objects must be returned (via Track::Clear) to a default state.; }; ```. Considering that a pair of new/delete calls on average cost about 70 ms,; O(109) new/deletes will save about 19 hours. For the other collections,; see the class reference guide on the web and the test program; `$ROOTSYS/test/tcollex.cxx.`. ## Template Containers and STL. Some people dislike polymorphic containers because they are not truly; ""type safe"". In the end, the compiler leaves it the user to ensure that; the types are correct. This only leaves the other alternative: creating; a new class each time a new (container organization) / (contained; object) combination is needed. To say the least this could be very; tedious. Most people faced with this choice would, for each type of; container:. Define the class leaving a dummy name for the contained object type.; When a particular container was needed, copy the code and then do a; global search and replace for the contained class. C++ has a built in; template scheme that effectively does just this. For example:. ``` {.cpp}; template<class T>; class ArrayContainer {; private:; T *member[10];; ...; };; ```. This is an array container with a 10-element array of pointers to T, it; could hold up to 10 T objects.",MatchSource.DOCS,documentation/users-guide/CollectionClasses.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md:9767,Usability,simpl,simple,9767," are equal. By overriding the following **`TObject`** member; functions, you can change the behavior of objects in collections:. - `IsEqual()`is used by the `FindObject() `collection method. By; default, `IsEqual()` compares the two object pointers. - `Compare()`returns -1, 0 or 1 depending if the object is smaller,; equal or larger than the other object. By default, a **`TObject`**; has not a valid `Compare()` method. - `IsSortable() `returns true if the class is sort able (i.e. if it; has a valid `Compare(`) method). By default, a **`TObject`** is not; sort able. - `Hash() `returns a hash value. It needs to be implemented if an; object has to be stored in a collection using a hashing technique,; like **`THashTable`**, **`THashList`** and **`TMap`**. By default,; `Hash(`) returns the address of the object. It is essential to; choose a good hash function. The example below shows how to use and override these member functions. ``` {.cpp}; class TObjNum : public TObject {; private:; Int_t num; // TObjNum is a simple container for an integer.; public:; TObjNum(Int_t i = 0) : num(i) { }; ~TObjNum() { }; void SetNum(Int_t i) { num = i; }; Int_t GetNum() const { return num; }; void Print(Option_t *) const; { printf(""num = %dn"", num); }; Bool_t IsEqual(TObject *obj) const; { return num == ((TObjNum*)obj)->num; }; Bool_t IsSortable() const { return kTRUE; }; Int_t Compare(const TObject *obj) const; { if (num < ((TObjNum*)obj)->num) return -1;; else if (num > ((TObjNum*)obj)->num) return 1;; else return 0; }; ULong_t Hash() const { return num; }; };; ```. ## The TIter Generic Iterator. As stated above, the **`TIterator`** class is abstract; it is not; possible to create **`TIterator`** objects. However, it should be; possible to write generic code to process all members of a collection so; there is a need for a generic iterator object. A **`TIter`** object acts; as generic iterator. It provides the same `Next()` and `Reset()` methods; as **`TIterator`** although it has no ide",MatchSource.DOCS,documentation/users-guide/CollectionClasses.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md:11115,Usability,simpl,simply,11115,"ompare(const TObject *obj) const; { if (num < ((TObjNum*)obj)->num) return -1;; else if (num > ((TObjNum*)obj)->num) return 1;; else return 0; }; ULong_t Hash() const { return num; }; };; ```. ## The TIter Generic Iterator. As stated above, the **`TIterator`** class is abstract; it is not; possible to create **`TIterator`** objects. However, it should be; possible to write generic code to process all members of a collection so; there is a need for a generic iterator object. A **`TIter`** object acts; as generic iterator. It provides the same `Next()` and `Reset()` methods; as **`TIterator`** although it has no idea how to support them! It works; as follows:. - To create a **`TIter`** object its constructor must be passed an; object that inherits from **`TCollection`**. The **`TIter`**; constructor calls the `MakeIterator()` method of this collection to; get the appropriate iterator object that inherits from; **`TIterator`**. - The `Next()` and `Reset()` methods of **`TIter`** simply call the; `Next()` and `Reset()` methods of the iterator object. Therefore, **`TIter`** simply acts as a wrapper for an object of a; concrete class inheriting from **`TIterator`**. To see this working in practice, consider the **`TObjArray`**; collection. Its associated iterator is **`TObjArrayIter`**. Suppose; `myarray` is a pointer to a **`TObjArray`** that contains `MyClass`; objects, i.e. ``` {.cpp}; TObjArray *myarray;; ```. To create a **`TIter`** object called `myiter`:. ``` {.cpp}; TIter myiter(myarray);; ```. ![](pictures/020001A4.jpg). As shown in the diagram, this results in several methods being called:. - The **`TIter`** constructor is passed a **`TObjArray`**. - **`TIter`** asks embedded **`TCollection`** to make an iterator. - **`TCollection`** asks **`TObjArray`** to make an iterator. - **`TObjArray`** returns a **`TObjArrayIter`**. Now define a pointer for `MyClass` objects and set it to each member of; the **`TObjArray`**:. ``` {.cpp}; MyClass *myobject;; while ((myobje",MatchSource.DOCS,documentation/users-guide/CollectionClasses.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md:11210,Usability,simpl,simply,11210,"urn 1;; else return 0; }; ULong_t Hash() const { return num; }; };; ```. ## The TIter Generic Iterator. As stated above, the **`TIterator`** class is abstract; it is not; possible to create **`TIterator`** objects. However, it should be; possible to write generic code to process all members of a collection so; there is a need for a generic iterator object. A **`TIter`** object acts; as generic iterator. It provides the same `Next()` and `Reset()` methods; as **`TIterator`** although it has no idea how to support them! It works; as follows:. - To create a **`TIter`** object its constructor must be passed an; object that inherits from **`TCollection`**. The **`TIter`**; constructor calls the `MakeIterator()` method of this collection to; get the appropriate iterator object that inherits from; **`TIterator`**. - The `Next()` and `Reset()` methods of **`TIter`** simply call the; `Next()` and `Reset()` methods of the iterator object. Therefore, **`TIter`** simply acts as a wrapper for an object of a; concrete class inheriting from **`TIterator`**. To see this working in practice, consider the **`TObjArray`**; collection. Its associated iterator is **`TObjArrayIter`**. Suppose; `myarray` is a pointer to a **`TObjArray`** that contains `MyClass`; objects, i.e. ``` {.cpp}; TObjArray *myarray;; ```. To create a **`TIter`** object called `myiter`:. ``` {.cpp}; TIter myiter(myarray);; ```. ![](pictures/020001A4.jpg). As shown in the diagram, this results in several methods being called:. - The **`TIter`** constructor is passed a **`TObjArray`**. - **`TIter`** asks embedded **`TCollection`** to make an iterator. - **`TCollection`** asks **`TObjArray`** to make an iterator. - **`TObjArray`** returns a **`TObjArrayIter`**. Now define a pointer for `MyClass` objects and set it to each member of; the **`TObjArray`**:. ``` {.cpp}; MyClass *myobject;; while ((myobject = (MyClass *)myiter.Next())) {; // process myobject; }; ```. The heart of this is the `myiter.Next()` expression whic",MatchSource.DOCS,documentation/users-guide/CollectionClasses.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md:15784,Usability,simpl,simple,15784,"ray Collection. A **`TObjArray`** is a collection which supports traditional array; semantics via the overloading of `operator[]`. Objects can be directly; accessed via an index. The array expands automatically when objects are; added. At creation time one specifies the default array size (default =; 16) and lower bound (default = 0). Resizing involves a re-allocation and; a copy of the old array to the new. This can be costly if done too; often. If possible, set initial size close to expected final size. Index; validity is always checked (if you are 100% sure and maximum performance; is needed you can use `UnCheckedAt()` instead of `At()` or; `operator[]`). If the stored objects are sort able the array can be; sorted using `Sort()`. Once sorted, efficient searching is possible via; the `BinarySearch()` method. The figure shows the internal data; structure of a **`TObjArray`**:. ![The internal data structure of a TObjArray](pictures/020001A7.jpg). Iterating can be done using a **`TIter`** iterator or via a simple for; loop:. ``` {.cpp}; for (int i = 0; i <= fArr.GetLast(); i++); if ((track = (TTrack*)fArr[i])) // or fArr.At(i); track->Draw();; ```. Main features of **`TObjArray`** are simple, well-known array semantics.; **Overhead per element**: none, except possible over sizing of `fCont`. ## TClonesArray An Array of Identical Objects. A **`TClonesArray`** is an array of identical (clone) objects. The; memory for the objects stored in the array is allocated only once in the; lifetime of the clones array. All objects must be of the same class. For; the rest this class has the same properties as a **`TObjArray`**. ![The internal data structure of a TClonesArray](pictures/020001A8.jpg). The figure above shows the internal data structure of a; **`TClonesArray`**. The class is specially designed for repetitive data; analysis tasks, where in a loop many times the same objects, are created; and deleted. The only supported way to add objects to a; **`TClonesArray`** is via",MatchSource.DOCS,documentation/users-guide/CollectionClasses.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md:15966,Usability,simpl,simple,15966,"atically when objects are; added. At creation time one specifies the default array size (default =; 16) and lower bound (default = 0). Resizing involves a re-allocation and; a copy of the old array to the new. This can be costly if done too; often. If possible, set initial size close to expected final size. Index; validity is always checked (if you are 100% sure and maximum performance; is needed you can use `UnCheckedAt()` instead of `At()` or; `operator[]`). If the stored objects are sort able the array can be; sorted using `Sort()`. Once sorted, efficient searching is possible via; the `BinarySearch()` method. The figure shows the internal data; structure of a **`TObjArray`**:. ![The internal data structure of a TObjArray](pictures/020001A7.jpg). Iterating can be done using a **`TIter`** iterator or via a simple for; loop:. ``` {.cpp}; for (int i = 0; i <= fArr.GetLast(); i++); if ((track = (TTrack*)fArr[i])) // or fArr.At(i); track->Draw();; ```. Main features of **`TObjArray`** are simple, well-known array semantics.; **Overhead per element**: none, except possible over sizing of `fCont`. ## TClonesArray An Array of Identical Objects. A **`TClonesArray`** is an array of identical (clone) objects. The; memory for the objects stored in the array is allocated only once in the; lifetime of the clones array. All objects must be of the same class. For; the rest this class has the same properties as a **`TObjArray`**. ![The internal data structure of a TClonesArray](pictures/020001A8.jpg). The figure above shows the internal data structure of a; **`TClonesArray`**. The class is specially designed for repetitive data; analysis tasks, where in a loop many times the same objects, are created; and deleted. The only supported way to add objects to a; **`TClonesArray`** is via the `new` with placement method. The different; `Add()` methods of **`TObjArray`** and its base classes are not; supported. ### The Idea Behind TClonesArray. To reduce the very large number of new and ",MatchSource.DOCS,documentation/users-guide/CollectionClasses.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md:17872,Usability,guid,guide,17872," supported. ### The Idea Behind TClonesArray. To reduce the very large number of new and delete calls in large loops; like this (O(100000) x O(10000) times new/delete):. ``` {.cpp}; TObjArray a(10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000); for (int i = 0; i < ev->Ntracks; i++) { // O(10000); a[i] = new TTrack(x,y,z,...);; ...; }; ...; a.Delete();; }; ```. You better use a **`TClonesArray`** which reduces the number of; new/delete calls to only O(10000):. ``` {.cpp}; TClonesArray a(""TTrack"", 10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000); for (int i = 0; i < ev->Ntracks; i++) { // O(10000); TTrack *track = (Track*)a.ConstructedAt(i);; track->Set(x,y,z,...);; ...; }; ...; a.Clear(); // Or Clear(""C"") if the track objects must be returned (via Track::Clear) to a default state.; }; ```. Considering that a pair of new/delete calls on average cost about 70 ms,; O(109) new/deletes will save about 19 hours. For the other collections,; see the class reference guide on the web and the test program; `$ROOTSYS/test/tcollex.cxx.`. ## Template Containers and STL. Some people dislike polymorphic containers because they are not truly; ""type safe"". In the end, the compiler leaves it the user to ensure that; the types are correct. This only leaves the other alternative: creating; a new class each time a new (container organization) / (contained; object) combination is needed. To say the least this could be very; tedious. Most people faced with this choice would, for each type of; container:. Define the class leaving a dummy name for the contained object type.; When a particular container was needed, copy the code and then do a; global search and replace for the contained class. C++ has a built in; template scheme that effectively does just this. For example:. ``` {.cpp}; template<class T>; class ArrayContainer {; private:; T *member[10];; ...; };; ```. This is an array container with a 10-element array of pointers to T, it; could hold up to 10 T objects.",MatchSource.DOCS,documentation/users-guide/CollectionClasses.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ExampleAnalysis.md:577,Energy Efficiency,efficient,efficient,577,"# Example Analysis. This chapter is an example of a typical physics analysis. Large data; files are chained together and analyzed using the **`TSelector`** class. ## Explanation. This script uses four large data sets from the H1 collaboration at DESY; Hamburg. One can access these data sets (277 Mbytes) from the ROOT web; site at: <ftp://root.cern.ch/root/h1analysis/>. The physics plots generated by this example cannot be produced using; smaller data sets. There are several ways to analyze data stored in a ROOT Tree. - Using `TTree::Draw`:. - This is very convenient and efficient for small tasks. A; **`TTree`**::Draw call produces one histogram at the time. The; histogram is automatically generated. The selection expression may; be specified in the command line. - Using the **`TTreeViewer`**:. - This is a graphical interface to `TTree::Draw` with the same; functionality. - Using the code generated by `TTree::MakeClass`:. - In this case, the user creates an instance of the analysis class. They; have the control over the event loop and can generate an unlimited; number of histograms. - Using the code generated by `TTree::MakeSelector`: Like for the code; generated by **`TTree::MakeClass`**, the user can do complex analysis.; However, they cannot control the event loop. The event loop is; controlled by `TTree::Process` called by the user. This solution is; illustrated by the code below. The advantage of this method is that; it can be run in a parallel environment using PROOF (the Parallel; Root Facility). A chain of four files (originally converted from PAW ntuples) is used to; illustrate the various ways to loop on ROOT data sets. Each contains a; ROOT Tree named ""`h42`"". The class definition in h1analysis.h has been; generated automatically by the ROOT utility **`TTree`**`::MakeSelector`; using one of the files with:. ``` {.cpp}; h42->MakeSelector(""h1analysis"");; ```. This produces two files: h1analysis.h and `h1analysis.C`. A skeleton of; `h1analysis.C` file is made ",MatchSource.DOCS,documentation/users-guide/ExampleAnalysis.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ExampleAnalysis.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ExampleAnalysis.md:827,Integrability,interface,interface,827,"# Example Analysis. This chapter is an example of a typical physics analysis. Large data; files are chained together and analyzed using the **`TSelector`** class. ## Explanation. This script uses four large data sets from the H1 collaboration at DESY; Hamburg. One can access these data sets (277 Mbytes) from the ROOT web; site at: <ftp://root.cern.ch/root/h1analysis/>. The physics plots generated by this example cannot be produced using; smaller data sets. There are several ways to analyze data stored in a ROOT Tree. - Using `TTree::Draw`:. - This is very convenient and efficient for small tasks. A; **`TTree`**::Draw call produces one histogram at the time. The; histogram is automatically generated. The selection expression may; be specified in the command line. - Using the **`TTreeViewer`**:. - This is a graphical interface to `TTree::Draw` with the same; functionality. - Using the code generated by `TTree::MakeClass`:. - In this case, the user creates an instance of the analysis class. They; have the control over the event loop and can generate an unlimited; number of histograms. - Using the code generated by `TTree::MakeSelector`: Like for the code; generated by **`TTree::MakeClass`**, the user can do complex analysis.; However, they cannot control the event loop. The event loop is; controlled by `TTree::Process` called by the user. This solution is; illustrated by the code below. The advantage of this method is that; it can be run in a parallel environment using PROOF (the Parallel; Root Facility). A chain of four files (originally converted from PAW ntuples) is used to; illustrate the various ways to loop on ROOT data sets. Each contains a; ROOT Tree named ""`h42`"". The class definition in h1analysis.h has been; generated automatically by the ROOT utility **`TTree`**`::MakeSelector`; using one of the files with:. ``` {.cpp}; h42->MakeSelector(""h1analysis"");; ```. This produces two files: h1analysis.h and `h1analysis.C`. A skeleton of; `h1analysis.C` file is made ",MatchSource.DOCS,documentation/users-guide/ExampleAnalysis.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ExampleAnalysis.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ExampleAnalysis.md:5201,Performance,perform,perform,5201,"ected; 7525 events out of the 283813 events in the chain of files. (2.65 per; cent). ``` {.cpp}; root[] chain.Process(""h1analysis.C"",""fillList""); ```. *Step D:* Process only entries in the event list. The event list is read; from the file in `elist.root` generated by step C. ``` {.cpp}; root[] chain.Process(""h1analysis.C"",""useList""); ```. *Step E*: The above steps have been executed with the interpreter. You; can repeat the steps B, C, and D using ACLiC by replacing; ""`h1analysis.C`"" by ""`h1analysis.C+`"" or ""`h1analysis.C++`"". *Step F:* If you want to see the differences between the interpreter; speed and ACLiC speed start a new session, create the chain as in step; 1, then execute. ``` {.cpp}; root[] chain.Process(""h1analysis.C+"",""useList""); ```. The commands executed with the four different methods B, C, D and E; produce two canvases shown below:. ![](pictures/030001FD.png) ![](pictures/030001FE.png). ## Script. This is the `h1analsysis.C` file that was generated by; `TTree::MakeSelector` and then modified to perform the analysis. ``` {.cpp}; #include ""h1analysis.h""; #include ""TH2.h""; #include ""TF1.h""; #include ""TStyle.h""; #include ""TCanvas.h""; #include ""TLine.h""; #include ""TEventList.h"". const Double_t dxbin = (0.17-0.13)/40; // Bin-width; const Double_t sigma = 0.0012;; TEventList *elist = 0;; Bool_t useList, fillList;; TH1F *hdmd;; TH2F *h2;. //_________________________________________________________; Double_t fdm5(Double_t *xx, Double_t *par); {; Double_t x = xx[0];; if (x <= 0.13957) return 0;; Double_t xp3 = (x-par[3])*(x-par[3]);; Double_t res = dxbin*(par[0]*TMath::Power(x-0.13957,par[1]); + par[2]/2.5066/par[4]*TMath::Exp(-xp3/2/par[4]/par[4]));; return res;; }. //_________________________________________________________; Double_t fdm2(Double_t *xx, Double_t *par); {; Double_t x = xx[0];; if (x <= 0.13957) return 0;; Double_t xp3 = (x-0.1454)*(x-0.1454);; Double_t res = dxbin*(par[0]*TMath::Power(x-0.13957,0.25); + par[1]/2.5066/sigma*TMath::Exp(-xp3/2/si",MatchSource.DOCS,documentation/users-guide/ExampleAnalysis.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ExampleAnalysis.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ExampleAnalysis.md:6364,Performance,perform,performs,6364,".h""; #include ""TLine.h""; #include ""TEventList.h"". const Double_t dxbin = (0.17-0.13)/40; // Bin-width; const Double_t sigma = 0.0012;; TEventList *elist = 0;; Bool_t useList, fillList;; TH1F *hdmd;; TH2F *h2;. //_________________________________________________________; Double_t fdm5(Double_t *xx, Double_t *par); {; Double_t x = xx[0];; if (x <= 0.13957) return 0;; Double_t xp3 = (x-par[3])*(x-par[3]);; Double_t res = dxbin*(par[0]*TMath::Power(x-0.13957,par[1]); + par[2]/2.5066/par[4]*TMath::Exp(-xp3/2/par[4]/par[4]));; return res;; }. //_________________________________________________________; Double_t fdm2(Double_t *xx, Double_t *par); {; Double_t x = xx[0];; if (x <= 0.13957) return 0;; Double_t xp3 = (x-0.1454)*(x-0.1454);; Double_t res = dxbin*(par[0]*TMath::Power(x-0.13957,0.25); + par[1]/2.5066/sigma*TMath::Exp(-xp3/2/sigma/sigma));; return res;; }. //_________________________________________________________; void h1analysis::Begin(TTree *tree); {; // function called before starting the event loop; // -it performs some cleanup; // -it creates histograms; // -it sets some initialization for the event list. //initialize the Tree branch addresses; Init(tree);. //print the option specified in the Process function; TString option = GetOption();; printf(""Starting h1analysis with process option: %sn"",option.Data());. //Some cleanup in case this function had already been executed; //Delete any previously generated histograms or functions; gDirectory->Delete(""hdmd"");; gDirectory->Delete(""h2*"");; delete gROOT->GetFunction(""f5"");; delete gROOT->GetFunction(""f2"");. //create histograms; hdmd = new TH1F(""hdmd"",""dm_d"",40,0.13,0.17);; h2 = new TH2F(""h2"",""ptD0 vs dm_d"",30,0.135,0.165,30,-3,6);. //process cases with event list; fillList = kFALSE;; useList = kFALSE;; fChain->SetEventList(0);; delete gDirectory->GetList()->FindObject(""elist"");. // case when one creates/fills the event list; if (option.Contains(""fillList"")) {; fillList = kTRUE;; elist = new TEventList(""elist"",""s",MatchSource.DOCS,documentation/users-guide/ExampleAnalysis.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ExampleAnalysis.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ExampleAnalysis.md:8025,Safety,detect,detected,8025,"65,30,-3,6);. //process cases with event list; fillList = kFALSE;; useList = kFALSE;; fChain->SetEventList(0);; delete gDirectory->GetList()->FindObject(""elist"");. // case when one creates/fills the event list; if (option.Contains(""fillList"")) {; fillList = kTRUE;; elist = new TEventList(""elist"",""selection from Cut"",5000);; }; // case when one uses the event list generated in a previous call; if (option.Contains(""useList"")) {; useList = kTRUE;; TFile f(""elist.root"");; elist = (TEventList*)f.Get(""elist"");; if (elist) elist->SetDirectory(0);; //otherwise the file destructor will delete elist; fChain->SetEventList(elist);; }; }; //_________________________________________________________; Bool_t h1analysis::ProcessCut(Int_t entry); { // Selection function to select D* and D0. //in case one event list is given in input,; //the selection has already been done.; if (useList) return kTRUE;; // Read only the necessary branches to select entries.; // return as soon as a bad entry is detected; b_md0_d->GetEntry(entry);; if (TMath::Abs(md0_d-1.8646) >= 0.04) return kFALSE;; b_ptds_d->GetEntry(entry);; if (ptds_d <= 2.5) return kFALSE;; b_etads_d->GetEntry(entry);; if (TMath::Abs(etads_d) >= 1.5) return kFALSE;; b_ik->GetEntry(entry); ik--;; //original ik used f77 convention starting at 1; b_ipi->GetEntry(entry);; ipi--;; b_ntracks->GetEntry(entry);; b_nhitrp->GetEntry(entry);; if (nhitrp[ik]*nhitrp[ipi] <= 1) return kFALSE;; b_rend->GetEntry(entry);; b_rstart->GetEntry(entry);; if (rend[ik]-rstart[ik] <= 22) return kFALSE;; if (rend[ipi]-rstart[ipi] <= 22) return kFALSE;; b_nlhk->GetEntry(entry);; if (nlhk[ik] <= 0.1) return kFALSE;; b_nlhpi->GetEntry(entry);; if (nlhpi[ipi] <= 0.1) return kFALSE;; b_ipis->GetEntry(entry);; ipis--;; if (nlhpi[ipis] <= 0.1) return kFALSE;; b_njets->GetEntry(entry);; if (njets < 1) return kFALSE;. // if option fillList, fill the event list; if (fillList) elist->Enter(fChain->GetChainEntryNumber(entry));. return kTRUE;; }. //_____________________",MatchSource.DOCS,documentation/users-guide/ExampleAnalysis.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ExampleAnalysis.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ExampleAnalysis.md:269,Security,access,access,269,"# Example Analysis. This chapter is an example of a typical physics analysis. Large data; files are chained together and analyzed using the **`TSelector`** class. ## Explanation. This script uses four large data sets from the H1 collaboration at DESY; Hamburg. One can access these data sets (277 Mbytes) from the ROOT web; site at: <ftp://root.cern.ch/root/h1analysis/>. The physics plots generated by this example cannot be produced using; smaller data sets. There are several ways to analyze data stored in a ROOT Tree. - Using `TTree::Draw`:. - This is very convenient and efficient for small tasks. A; **`TTree`**::Draw call produces one histogram at the time. The; histogram is automatically generated. The selection expression may; be specified in the command line. - Using the **`TTreeViewer`**:. - This is a graphical interface to `TTree::Draw` with the same; functionality. - Using the code generated by `TTree::MakeClass`:. - In this case, the user creates an instance of the analysis class. They; have the control over the event loop and can generate an unlimited; number of histograms. - Using the code generated by `TTree::MakeSelector`: Like for the code; generated by **`TTree::MakeClass`**, the user can do complex analysis.; However, they cannot control the event loop. The event loop is; controlled by `TTree::Process` called by the user. This solution is; illustrated by the code below. The advantage of this method is that; it can be run in a parallel environment using PROOF (the Parallel; Root Facility). A chain of four files (originally converted from PAW ntuples) is used to; illustrate the various ways to loop on ROOT data sets. Each contains a; ROOT Tree named ""`h42`"". The class definition in h1analysis.h has been; generated automatically by the ROOT utility **`TTree`**`::MakeSelector`; using one of the files with:. ``` {.cpp}; h42->MakeSelector(""h1analysis"");; ```. This produces two files: h1analysis.h and `h1analysis.C`. A skeleton of; `h1analysis.C` file is made ",MatchSource.DOCS,documentation/users-guide/ExampleAnalysis.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ExampleAnalysis.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ExampleAnalysis.md:9950,Testability,log,loglikelihood,9950,">Enter(fChain->GetChainEntryNumber(entry));. return kTRUE;; }. //_________________________________________________________; void h1analysis::ProcessFill(Int_t entry); { // Function called for selected entries only. // read branches not processed in ProcessCut; b_dm_d->GetEntry(entry);; //read branch holding dm_d; b_rpd0_t->GetEntry(entry);; //read branch holding rpd0_t; b_ptd0_d->GetEntry(entry);; //read branch holding ptd0_d //continued...; //fill some histograms; hdmd->Fill(dm_d);; h2->Fill(dm_d,rpd0_t/0.029979*1.8646/ptd0_d);; }. //_________________________________________________________; void h1analysis::Terminate(); { // Function called at the end of the event loop. //create the canvas for the h1analysis fit; gStyle->SetOptFit();; TCanvas *c1 = new TCanvas(""c1"",""h1analysis analysis"",10,10,800,600);; c1->SetBottomMargin(0.15);; hdmd->GetXaxis()->SetTitle(""m_{K#pi#pi}-m_{K#pi}[GeV/c^{2}]"");; hdmd->GetXaxis()->SetTitleOffset(1.4);. //fit histogram hdmd with function f5 using; //the loglikelihood option; TF1 *f5 = new TF1(""f5"",fdm5,0.139,0.17,5);; f5->SetParameters(1000000,.25,2000,.1454,.001);; hdmd->Fit(""f5"",""lr"");. //create the canvas for tau d0; gStyle->SetOptFit(0);; gStyle->SetOptStat(1100);; TCanvas *c2 = new TCanvas(""c2"",""tauD0"",100,100,800,600);; c2->SetGrid();; c2->SetBottomMargin(0.15);. // Project slices of 2-d histogram h2 along X ,; // then fit each slice with function f2 and make a; // histogram for each fit parameter.; // Note that the generated histograms are added; // to the list of objects in the current directory. TF1 *f2 = new TF1(""f2"",fdm2,0.139,0.17,2);; f2->SetParameters(10000,10);; h2->FitSlicesX(f2,0,0,1,""qln"");; TH1D *h2_1 = (TH1D*)gDirectory->Get(""h2_1"");; h2_1->GetXaxis()->SetTitle(""#tau[ps]"");; h2_1->SetMarkerStyle(21);; h2_1->Draw();; c2->Update();; TLine *line = new TLine(0,0,0,c2->GetUymax());; line->Draw();. // save the event list to a Root file if one was produced; if (fillList) {; TFile efile(""elist.root"",""recreate"");; elist->Wr",MatchSource.DOCS,documentation/users-guide/ExampleAnalysis.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ExampleAnalysis.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:1317,Availability,error,error,1317,"od; `TH1::Fit` is more powerful and is used in scripts and programs. ## The Fit Method. The Fit method is implemented in ROOT for the histogram classes **`TH1`**,; the sparse histogram classes, `THnSparse`, the graph classes, `TGraph`,; `TGraph2D` and `TMultiGraph` for fitting a collection of Graphs with the same function. ### The TH1::Fit Method. To fit a histogram programmatically, you can use the `TH1::Fit`; method. Here is the signatures of `TH1::Fit` and an explanation of the; parameters:. ``` {.cpp}; TFitResultPtr Fit(TF1 *function, Option_t *option, Option_t *goption,; Axis_t xxmin, Axis_t xxmax); ```; - `function` a pointer to the fitted function (the fit model) object.; One can also use the function name. This name may be one of ROOT pre-defined; function names or a user-defined function. See the next paragraph for the list of pre-defined functions. - `*option:` The second parameter is the fitting option. Here is the; list of fitting options:. 	- ""`W`"" Set all weights to 1 for non empty bins; ignore error bars. 	- ""`WW`"" Set all weights to 1 including empty bins; ignore error; bars. 	- ""`I`"" Use integral of function in bin instead of value at bin; center. 	- ""`L`"" Use log likelihood method (default is chi-square method). To be used when; the histogram represents counts. 	- ""`WL`"" Weighted log likelihood method. To be used when the histogram has been filled with; 	weights different than 1. - ""`P`"" Use Pearson chi-square method, using expected errors instead of the observed one given by `TH1::GetBinError` (default case).; The expected error is instead estimated from the square-root of the bin function value. 	- ""`Q`"" Quiet mode (minimum printing). 	- ""`V`"" Verbose mode (default is between Q and V). 	- ""`S`"" The result of the fit is returned in the `TFitResultPtr`. 	- ""`E`"" Perform better errors estimation using the Minos technique. 	- ""`M`"" Improve fit results, by using the *IMPROVE* algorithm of TMinuit. 	- ""`R`"" Use the range specified in the function range.",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:1389,Availability,error,error,1389," The Fit Method. The Fit method is implemented in ROOT for the histogram classes **`TH1`**,; the sparse histogram classes, `THnSparse`, the graph classes, `TGraph`,; `TGraph2D` and `TMultiGraph` for fitting a collection of Graphs with the same function. ### The TH1::Fit Method. To fit a histogram programmatically, you can use the `TH1::Fit`; method. Here is the signatures of `TH1::Fit` and an explanation of the; parameters:. ``` {.cpp}; TFitResultPtr Fit(TF1 *function, Option_t *option, Option_t *goption,; Axis_t xxmin, Axis_t xxmax); ```; - `function` a pointer to the fitted function (the fit model) object.; One can also use the function name. This name may be one of ROOT pre-defined; function names or a user-defined function. See the next paragraph for the list of pre-defined functions. - `*option:` The second parameter is the fitting option. Here is the; list of fitting options:. 	- ""`W`"" Set all weights to 1 for non empty bins; ignore error bars. 	- ""`WW`"" Set all weights to 1 including empty bins; ignore error; bars. 	- ""`I`"" Use integral of function in bin instead of value at bin; center. 	- ""`L`"" Use log likelihood method (default is chi-square method). To be used when; the histogram represents counts. 	- ""`WL`"" Weighted log likelihood method. To be used when the histogram has been filled with; 	weights different than 1. - ""`P`"" Use Pearson chi-square method, using expected errors instead of the observed one given by `TH1::GetBinError` (default case).; The expected error is instead estimated from the square-root of the bin function value. 	- ""`Q`"" Quiet mode (minimum printing). 	- ""`V`"" Verbose mode (default is between Q and V). 	- ""`S`"" The result of the fit is returned in the `TFitResultPtr`. 	- ""`E`"" Perform better errors estimation using the Minos technique. 	- ""`M`"" Improve fit results, by using the *IMPROVE* algorithm of TMinuit. 	- ""`R`"" Use the range specified in the function range. 	- ""`N`"" Do not store the graphics function, do not draw. 	- ""`0`"" Do ",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:1768,Availability,error,errors,1768," parameters:. ``` {.cpp}; TFitResultPtr Fit(TF1 *function, Option_t *option, Option_t *goption,; Axis_t xxmin, Axis_t xxmax); ```; - `function` a pointer to the fitted function (the fit model) object.; One can also use the function name. This name may be one of ROOT pre-defined; function names or a user-defined function. See the next paragraph for the list of pre-defined functions. - `*option:` The second parameter is the fitting option. Here is the; list of fitting options:. 	- ""`W`"" Set all weights to 1 for non empty bins; ignore error bars. 	- ""`WW`"" Set all weights to 1 including empty bins; ignore error; bars. 	- ""`I`"" Use integral of function in bin instead of value at bin; center. 	- ""`L`"" Use log likelihood method (default is chi-square method). To be used when; the histogram represents counts. 	- ""`WL`"" Weighted log likelihood method. To be used when the histogram has been filled with; 	weights different than 1. - ""`P`"" Use Pearson chi-square method, using expected errors instead of the observed one given by `TH1::GetBinError` (default case).; The expected error is instead estimated from the square-root of the bin function value. 	- ""`Q`"" Quiet mode (minimum printing). 	- ""`V`"" Verbose mode (default is between Q and V). 	- ""`S`"" The result of the fit is returned in the `TFitResultPtr`. 	- ""`E`"" Perform better errors estimation using the Minos technique. 	- ""`M`"" Improve fit results, by using the *IMPROVE* algorithm of TMinuit. 	- ""`R`"" Use the range specified in the function range. 	- ""`N`"" Do not store the graphics function, do not draw. 	- ""`0`"" Do not plot the result of the fit. By default the fitted; function is drawn unless the option ""`N`"" above is specified. 	- ""`+`"" Add this new fitted function to the list of fitted functions; (by default, the previous function is deleted and only the last; one is kept). 	- ""`B`""Use this option when you want to fix one or more parameters; and the fitting function is a predefined one, like `polN`, `expo`, `landau`, `g",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:1861,Availability,error,error,1861,"Axis_t xxmax); ```; - `function` a pointer to the fitted function (the fit model) object.; One can also use the function name. This name may be one of ROOT pre-defined; function names or a user-defined function. See the next paragraph for the list of pre-defined functions. - `*option:` The second parameter is the fitting option. Here is the; list of fitting options:. 	- ""`W`"" Set all weights to 1 for non empty bins; ignore error bars. 	- ""`WW`"" Set all weights to 1 including empty bins; ignore error; bars. 	- ""`I`"" Use integral of function in bin instead of value at bin; center. 	- ""`L`"" Use log likelihood method (default is chi-square method). To be used when; the histogram represents counts. 	- ""`WL`"" Weighted log likelihood method. To be used when the histogram has been filled with; 	weights different than 1. - ""`P`"" Use Pearson chi-square method, using expected errors instead of the observed one given by `TH1::GetBinError` (default case).; The expected error is instead estimated from the square-root of the bin function value. 	- ""`Q`"" Quiet mode (minimum printing). 	- ""`V`"" Verbose mode (default is between Q and V). 	- ""`S`"" The result of the fit is returned in the `TFitResultPtr`. 	- ""`E`"" Perform better errors estimation using the Minos technique. 	- ""`M`"" Improve fit results, by using the *IMPROVE* algorithm of TMinuit. 	- ""`R`"" Use the range specified in the function range. 	- ""`N`"" Do not store the graphics function, do not draw. 	- ""`0`"" Do not plot the result of the fit. By default the fitted; function is drawn unless the option ""`N`"" above is specified. 	- ""`+`"" Add this new fitted function to the list of fitted functions; (by default, the previous function is deleted and only the last; one is kept). 	- ""`B`""Use this option when you want to fix one or more parameters; and the fitting function is a predefined one, like `polN`, `expo`, `landau`, `gaus`.; Note that in case of pre-defined functions some default initial values and limits are set. 	- ""`C`""In ca",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:2119,Availability,error,errors,2119," the list of pre-defined functions. - `*option:` The second parameter is the fitting option. Here is the; list of fitting options:. 	- ""`W`"" Set all weights to 1 for non empty bins; ignore error bars. 	- ""`WW`"" Set all weights to 1 including empty bins; ignore error; bars. 	- ""`I`"" Use integral of function in bin instead of value at bin; center. 	- ""`L`"" Use log likelihood method (default is chi-square method). To be used when; the histogram represents counts. 	- ""`WL`"" Weighted log likelihood method. To be used when the histogram has been filled with; 	weights different than 1. - ""`P`"" Use Pearson chi-square method, using expected errors instead of the observed one given by `TH1::GetBinError` (default case).; The expected error is instead estimated from the square-root of the bin function value. 	- ""`Q`"" Quiet mode (minimum printing). 	- ""`V`"" Verbose mode (default is between Q and V). 	- ""`S`"" The result of the fit is returned in the `TFitResultPtr`. 	- ""`E`"" Perform better errors estimation using the Minos technique. 	- ""`M`"" Improve fit results, by using the *IMPROVE* algorithm of TMinuit. 	- ""`R`"" Use the range specified in the function range. 	- ""`N`"" Do not store the graphics function, do not draw. 	- ""`0`"" Do not plot the result of the fit. By default the fitted; function is drawn unless the option ""`N`"" above is specified. 	- ""`+`"" Add this new fitted function to the list of fitted functions; (by default, the previous function is deleted and only the last; one is kept). 	- ""`B`""Use this option when you want to fix one or more parameters; and the fitting function is a predefined one, like `polN`, `expo`, `landau`, `gaus`.; Note that in case of pre-defined functions some default initial values and limits are set. 	- ""`C`""In case of linear fitting, don't calculate the chisquare; (saves time). 	- ""`F`""If fitting a linear function (e.g. `polN`), switch to use the default minimizer (e.g. `Minuit`). By default,; `polN` functions are fitted by the linear fitter. - `",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:3885,Availability,error,errors,3885,"t. 	- ""`C`""In case of linear fitting, don't calculate the chisquare; (saves time). 	- ""`F`""If fitting a linear function (e.g. `polN`), switch to use the default minimizer (e.g. `Minuit`). By default,; `polN` functions are fitted by the linear fitter. - `*goption: `The third parameter is the graphics option that is the; same as in the `TH1::Draw` (see the chapter Draw Options). - `xxmin`, `xxmax:`Thee fourth and fifth parameters specify the; range over which to apply the fit. By default, the fitted function object is added to the histogram and; is drawn in the current pad. ### The TGraph::Fit Method. The signature for fitting a TGraph is exactly the same as for the **`TH1`**. Only some options apply only for fitting histograms,; these are the options ""`L`"", ""`WL`"" and ""`I`"".; These options apply instead only for `TGraph::Fit`, the rest of options (appart from ""`L`"", ""`WL`"" and ""`I`"" are the same). * `TGraph` specific *options*. 	- ""`EX0`"" When fitting a `TGraphErrors` or a `TgraphAsymErrors` the errors on the coordinates are not used in the fit. 	- ""`ROB`"" in case of linear fitting use the Robust fitting. Compute the LTS regression coefficients (robust (resistant) regression),; using the default fraction of good points.; 	- ""`ROB=0.x`"" as above, but compute the LTS regression coefficients, using 0.x as a fraction of good points. ## The `TF1` function class. Here we will show how to create the **`TF1`** class that is used for fitting histograms and graphs. ### Fit with a Predefined Function. To fit a histogram with a predefined function, simply pass the name of; the function in the first parameter of `TH1::Fit`. For example,; this line fits histogram object `hist` with a Gaussian. ``` {.cpp}; root[] hist.Fit(""gaus"");; ```. The initial parameter values (and eventual limits) for pre-defined functions are set; automatically. For overriding the default limits values use the fit option `B`. The list of pre-defined functions that can be used with the `Fit` method is the fol",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:4038,Availability,robust,robust,4038,"inuit`). By default,; `polN` functions are fitted by the linear fitter. - `*goption: `The third parameter is the graphics option that is the; same as in the `TH1::Draw` (see the chapter Draw Options). - `xxmin`, `xxmax:`Thee fourth and fifth parameters specify the; range over which to apply the fit. By default, the fitted function object is added to the histogram and; is drawn in the current pad. ### The TGraph::Fit Method. The signature for fitting a TGraph is exactly the same as for the **`TH1`**. Only some options apply only for fitting histograms,; these are the options ""`L`"", ""`WL`"" and ""`I`"".; These options apply instead only for `TGraph::Fit`, the rest of options (appart from ""`L`"", ""`WL`"" and ""`I`"" are the same). * `TGraph` specific *options*. 	- ""`EX0`"" When fitting a `TGraphErrors` or a `TgraphAsymErrors` the errors on the coordinates are not used in the fit. 	- ""`ROB`"" in case of linear fitting use the Robust fitting. Compute the LTS regression coefficients (robust (resistant) regression),; using the default fraction of good points.; 	- ""`ROB=0.x`"" as above, but compute the LTS regression coefficients, using 0.x as a fraction of good points. ## The `TF1` function class. Here we will show how to create the **`TF1`** class that is used for fitting histograms and graphs. ### Fit with a Predefined Function. To fit a histogram with a predefined function, simply pass the name of; the function in the first parameter of `TH1::Fit`. For example,; this line fits histogram object `hist` with a Gaussian. ``` {.cpp}; root[] hist.Fit(""gaus"");; ```. The initial parameter values (and eventual limits) for pre-defined functions are set; automatically. For overriding the default limits values use the fit option `B`. The list of pre-defined functions that can be used with the `Fit` method is the following:. - ""`gaus`"" Gaussian function with 3 parameters:; `f(x) = p0*exp(-0.5*((x-p1)/p2)^2)`. - ""`expo`""An Exponential with 2 parameters: `f(x) = exp(p0+p1*x)`. - ""`pol`*`N`*"" A p",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:16623,Availability,error,error,16623,"e combination; function:. ``` {.cpp}; // Quadratic background function; Double_t background(Double_t *x, Double_t *par) {; return par[0] + par[1]*x[0] + par[2]*x[0]*x[0];; }. // Lorentzian Peak function; Double_t lorentzianPeak(Double_t *x, Double_t *par) {; return (0.5*par[0]*par[1]/TMath::Pi()) / TMath::Max(1.e-10,; (x[0]-par[2])*(x[0]-par[2])+ .25*par[1]*par[1]);; }. // Sum of background and peak function; Double_t fitFunction(Double_t *x, Double_t *par) {; return background(x,par) + lorentzianPeak(x,&par[3]);; }. void FittingDemo() {; // bevington exercise by P. Malzacher, modified by R. Brun; const int nBins = 60;; Stat_t data[nBins] = { 6, 1,10,12, 6,13,23,22,15,21,; 23,26,36,25,27,35,40,44,66,81,; 75,57,48,45,46,41,35,36,53,32,; 40,37,38,31,36,44,42,37,32,32,; 43,44,35,33,33,39,29,41,32,44,; 26,39,29,35,32,21,21,15,25,15};; TH1F *histo = new TH1F(""example_9_1"",; ""Lorentzian Peak on Quadratic Background"",60,0,3);. for(int i=0; i < nBins; i++) {; // we use these methods to explicitly set the content; // and error instead of using the fill method.; histo->SetBinContent(i+1,data[i]);; histo->SetBinError(i+1,TMath::Sqrt(data[i]));; }; // create a TF1 with the range from 0 to 3 and 6 parameters; TF1 *fitFcn = new TF1(""fitFcn"",fitFunction,0,3,6);. // first try without starting values for the parameters; // this defaults to 1 for each param.; histo->Fit(""fitFcn"");; // this results in an ok fit for the polynomial function however; // the non-linear part (Lorentzian; ```. ![The output of the FittingDemo() example](pictures/03000070.png). ## Result of the fit. Here we will show how to obtain the result of the fit (fitted function, parameter values, errors; and eventually the covariance and correlation matrix). ### Associated Function. One or more objects (typically a **`TF1\*`**) can be added to the list; of functions (`fFunctions`) associated to each histogram. A call to; `TH1::Fit` adds the fitted function to this list. Given a histogram; `h`, one can retrieve the ass",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:17268,Availability,error,errors,17268,",12, 6,13,23,22,15,21,; 23,26,36,25,27,35,40,44,66,81,; 75,57,48,45,46,41,35,36,53,32,; 40,37,38,31,36,44,42,37,32,32,; 43,44,35,33,33,39,29,41,32,44,; 26,39,29,35,32,21,21,15,25,15};; TH1F *histo = new TH1F(""example_9_1"",; ""Lorentzian Peak on Quadratic Background"",60,0,3);. for(int i=0; i < nBins; i++) {; // we use these methods to explicitly set the content; // and error instead of using the fill method.; histo->SetBinContent(i+1,data[i]);; histo->SetBinError(i+1,TMath::Sqrt(data[i]));; }; // create a TF1 with the range from 0 to 3 and 6 parameters; TF1 *fitFcn = new TF1(""fitFcn"",fitFunction,0,3,6);. // first try without starting values for the parameters; // this defaults to 1 for each param.; histo->Fit(""fitFcn"");; // this results in an ok fit for the polynomial function however; // the non-linear part (Lorentzian; ```. ![The output of the FittingDemo() example](pictures/03000070.png). ## Result of the fit. Here we will show how to obtain the result of the fit (fitted function, parameter values, errors; and eventually the covariance and correlation matrix). ### Associated Function. One or more objects (typically a **`TF1\*`**) can be added to the list; of functions (`fFunctions`) associated to each histogram. A call to; `TH1::Fit` adds the fitted function to this list. Given a histogram; `h`, one can retrieve the associated function with:. ``` {.cpp}; TF1 *myfunc = h->GetFunction(""myfunc"");; ```. ### Access to the Fit Parameters and Results. If the histogram (or graph) is made persistent, the list of associated; functions is also persistent. Retrieve a pointer to the function with; the `TH1::GetFunction()` method. Then you can retrieve the fit; parameters from the function (**`TF1`**) with calls such as:. ``` {.cpp}; root[] TF1 *fit = hist->GetFunction(function_name);; root[] Double_t chi2 = fit->GetChisquare();; // value of the first parameter; root[] Double_t p1 = fit->GetParameter(0);; // error of the first parameter; root[] Double_t e1 = fit->GetParError(0);;",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:18182,Availability,error,error,18182,"le](pictures/03000070.png). ## Result of the fit. Here we will show how to obtain the result of the fit (fitted function, parameter values, errors; and eventually the covariance and correlation matrix). ### Associated Function. One or more objects (typically a **`TF1\*`**) can be added to the list; of functions (`fFunctions`) associated to each histogram. A call to; `TH1::Fit` adds the fitted function to this list. Given a histogram; `h`, one can retrieve the associated function with:. ``` {.cpp}; TF1 *myfunc = h->GetFunction(""myfunc"");; ```. ### Access to the Fit Parameters and Results. If the histogram (or graph) is made persistent, the list of associated; functions is also persistent. Retrieve a pointer to the function with; the `TH1::GetFunction()` method. Then you can retrieve the fit; parameters from the function (**`TF1`**) with calls such as:. ``` {.cpp}; root[] TF1 *fit = hist->GetFunction(function_name);; root[] Double_t chi2 = fit->GetChisquare();; // value of the first parameter; root[] Double_t p1 = fit->GetParameter(0);; // error of the first parameter; root[] Double_t e1 = fit->GetParError(0);; ```. Using the fit option `S` one can access the full result of the fit including the covariance and correlation matrix.; See later the paragraph `TFitResult`. ### Associated Errors. By default, for each bin, the sum of weights is computed at fill time.; One can also call `TH1::Sumw2` to force the storage and computation of; the sum of the square of weights per bin. If Sumw2 has been called,; the error per bin is computed as the `sqrt(sum of squares of; weights)`; otherwise, the error is set equal to the; `sqrt(bin content)`. To return the error for a given bin number, do:. ``` {.cpp}; Double_t error = h->GetBinError(bin);; ```. Empty bins are excluded in the fit when using the Chi-square fit method.; When fitting an histogram representing counts (i.e with Poisson statistics) it is recommended to; use the Log-Likelihood method (option ‘`L`' or ""`WL`""), particula",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:18655,Availability,error,error,18655,"eters and Results. If the histogram (or graph) is made persistent, the list of associated; functions is also persistent. Retrieve a pointer to the function with; the `TH1::GetFunction()` method. Then you can retrieve the fit; parameters from the function (**`TF1`**) with calls such as:. ``` {.cpp}; root[] TF1 *fit = hist->GetFunction(function_name);; root[] Double_t chi2 = fit->GetChisquare();; // value of the first parameter; root[] Double_t p1 = fit->GetParameter(0);; // error of the first parameter; root[] Double_t e1 = fit->GetParError(0);; ```. Using the fit option `S` one can access the full result of the fit including the covariance and correlation matrix.; See later the paragraph `TFitResult`. ### Associated Errors. By default, for each bin, the sum of weights is computed at fill time.; One can also call `TH1::Sumw2` to force the storage and computation of; the sum of the square of weights per bin. If Sumw2 has been called,; the error per bin is computed as the `sqrt(sum of squares of; weights)`; otherwise, the error is set equal to the; `sqrt(bin content)`. To return the error for a given bin number, do:. ``` {.cpp}; Double_t error = h->GetBinError(bin);; ```. Empty bins are excluded in the fit when using the Chi-square fit method.; When fitting an histogram representing counts (i.e with Poisson statistics) it is recommended to; use the Log-Likelihood method (option ‘`L`' or ""`WL`""), particularly in case of low statistics.; When the histogram has been filled with weights different than one, a weighted likelihood method can be used; and the errors retrieved from the fit are corrected following a procedure described in paragraph 8.5.2 of the book,; *F. James, Statistical Methods in Experimental Physics, 2nd Edition*. ### Fit Statistics. You can change the statistics box to display the fit parameters with the; `TStyle::SetOptFit(mode)` method. This parameter has four digits:; `mode = pcev` (`default = 0111`). - `p` = 1 print probability; - `c` = 1 print Chi-squ",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:18739,Availability,error,error,18739,"eters and Results. If the histogram (or graph) is made persistent, the list of associated; functions is also persistent. Retrieve a pointer to the function with; the `TH1::GetFunction()` method. Then you can retrieve the fit; parameters from the function (**`TF1`**) with calls such as:. ``` {.cpp}; root[] TF1 *fit = hist->GetFunction(function_name);; root[] Double_t chi2 = fit->GetChisquare();; // value of the first parameter; root[] Double_t p1 = fit->GetParameter(0);; // error of the first parameter; root[] Double_t e1 = fit->GetParError(0);; ```. Using the fit option `S` one can access the full result of the fit including the covariance and correlation matrix.; See later the paragraph `TFitResult`. ### Associated Errors. By default, for each bin, the sum of weights is computed at fill time.; One can also call `TH1::Sumw2` to force the storage and computation of; the sum of the square of weights per bin. If Sumw2 has been called,; the error per bin is computed as the `sqrt(sum of squares of; weights)`; otherwise, the error is set equal to the; `sqrt(bin content)`. To return the error for a given bin number, do:. ``` {.cpp}; Double_t error = h->GetBinError(bin);; ```. Empty bins are excluded in the fit when using the Chi-square fit method.; When fitting an histogram representing counts (i.e with Poisson statistics) it is recommended to; use the Log-Likelihood method (option ‘`L`' or ""`WL`""), particularly in case of low statistics.; When the histogram has been filled with weights different than one, a weighted likelihood method can be used; and the errors retrieved from the fit are corrected following a procedure described in paragraph 8.5.2 of the book,; *F. James, Statistical Methods in Experimental Physics, 2nd Edition*. ### Fit Statistics. You can change the statistics box to display the fit parameters with the; `TStyle::SetOptFit(mode)` method. This parameter has four digits:; `mode = pcev` (`default = 0111`). - `p` = 1 print probability; - `c` = 1 print Chi-squ",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:18801,Availability,error,error,18801,"so persistent. Retrieve a pointer to the function with; the `TH1::GetFunction()` method. Then you can retrieve the fit; parameters from the function (**`TF1`**) with calls such as:. ``` {.cpp}; root[] TF1 *fit = hist->GetFunction(function_name);; root[] Double_t chi2 = fit->GetChisquare();; // value of the first parameter; root[] Double_t p1 = fit->GetParameter(0);; // error of the first parameter; root[] Double_t e1 = fit->GetParError(0);; ```. Using the fit option `S` one can access the full result of the fit including the covariance and correlation matrix.; See later the paragraph `TFitResult`. ### Associated Errors. By default, for each bin, the sum of weights is computed at fill time.; One can also call `TH1::Sumw2` to force the storage and computation of; the sum of the square of weights per bin. If Sumw2 has been called,; the error per bin is computed as the `sqrt(sum of squares of; weights)`; otherwise, the error is set equal to the; `sqrt(bin content)`. To return the error for a given bin number, do:. ``` {.cpp}; Double_t error = h->GetBinError(bin);; ```. Empty bins are excluded in the fit when using the Chi-square fit method.; When fitting an histogram representing counts (i.e with Poisson statistics) it is recommended to; use the Log-Likelihood method (option ‘`L`' or ""`WL`""), particularly in case of low statistics.; When the histogram has been filled with weights different than one, a weighted likelihood method can be used; and the errors retrieved from the fit are corrected following a procedure described in paragraph 8.5.2 of the book,; *F. James, Statistical Methods in Experimental Physics, 2nd Edition*. ### Fit Statistics. You can change the statistics box to display the fit parameters with the; `TStyle::SetOptFit(mode)` method. This parameter has four digits:; `mode = pcev` (`default = 0111`). - `p` = 1 print probability; - `c` = 1 print Chi-square/number of degrees of freedom; - `e` = 1 print errors (if `e=1`, `v` must be 1); - `v` = 1 print name/v",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:18857,Availability,error,error,18857,"the `TH1::GetFunction()` method. Then you can retrieve the fit; parameters from the function (**`TF1`**) with calls such as:. ``` {.cpp}; root[] TF1 *fit = hist->GetFunction(function_name);; root[] Double_t chi2 = fit->GetChisquare();; // value of the first parameter; root[] Double_t p1 = fit->GetParameter(0);; // error of the first parameter; root[] Double_t e1 = fit->GetParError(0);; ```. Using the fit option `S` one can access the full result of the fit including the covariance and correlation matrix.; See later the paragraph `TFitResult`. ### Associated Errors. By default, for each bin, the sum of weights is computed at fill time.; One can also call `TH1::Sumw2` to force the storage and computation of; the sum of the square of weights per bin. If Sumw2 has been called,; the error per bin is computed as the `sqrt(sum of squares of; weights)`; otherwise, the error is set equal to the; `sqrt(bin content)`. To return the error for a given bin number, do:. ``` {.cpp}; Double_t error = h->GetBinError(bin);; ```. Empty bins are excluded in the fit when using the Chi-square fit method.; When fitting an histogram representing counts (i.e with Poisson statistics) it is recommended to; use the Log-Likelihood method (option ‘`L`' or ""`WL`""), particularly in case of low statistics.; When the histogram has been filled with weights different than one, a weighted likelihood method can be used; and the errors retrieved from the fit are corrected following a procedure described in paragraph 8.5.2 of the book,; *F. James, Statistical Methods in Experimental Physics, 2nd Edition*. ### Fit Statistics. You can change the statistics box to display the fit parameters with the; `TStyle::SetOptFit(mode)` method. This parameter has four digits:; `mode = pcev` (`default = 0111`). - `p` = 1 print probability; - `c` = 1 print Chi-square/number of degrees of freedom; - `e` = 1 print errors (if `e=1`, `v` must be 1); - `v` = 1 print name/values of parameters. For example, to print the fit proba",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:19279,Availability,error,errors,19279,"g the fit option `S` one can access the full result of the fit including the covariance and correlation matrix.; See later the paragraph `TFitResult`. ### Associated Errors. By default, for each bin, the sum of weights is computed at fill time.; One can also call `TH1::Sumw2` to force the storage and computation of; the sum of the square of weights per bin. If Sumw2 has been called,; the error per bin is computed as the `sqrt(sum of squares of; weights)`; otherwise, the error is set equal to the; `sqrt(bin content)`. To return the error for a given bin number, do:. ``` {.cpp}; Double_t error = h->GetBinError(bin);; ```. Empty bins are excluded in the fit when using the Chi-square fit method.; When fitting an histogram representing counts (i.e with Poisson statistics) it is recommended to; use the Log-Likelihood method (option ‘`L`' or ""`WL`""), particularly in case of low statistics.; When the histogram has been filled with weights different than one, a weighted likelihood method can be used; and the errors retrieved from the fit are corrected following a procedure described in paragraph 8.5.2 of the book,; *F. James, Statistical Methods in Experimental Physics, 2nd Edition*. ### Fit Statistics. You can change the statistics box to display the fit parameters with the; `TStyle::SetOptFit(mode)` method. This parameter has four digits:; `mode = pcev` (`default = 0111`). - `p` = 1 print probability; - `c` = 1 print Chi-square/number of degrees of freedom; - `e` = 1 print errors (if `e=1`, `v` must be 1); - `v` = 1 print name/values of parameters. For example, to print the fit probability, parameter names/values, and; errors, use:. ``` {.cpp}; gStyle->SetOptFit(1011);; ```. ## The Fit Panel. ![The Fit Panel](pictures/03000061.png). To display the Fit Panel right click on a histogram to pop up the; context menu, and then select the menu entry Fit Panel. The new Fit Panel GUI is available in ROOT v5.14. Its goal is to; replace the old Fit Panel and to provide more user frien",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:19755,Availability,error,errors,19755,"ror is set equal to the; `sqrt(bin content)`. To return the error for a given bin number, do:. ``` {.cpp}; Double_t error = h->GetBinError(bin);; ```. Empty bins are excluded in the fit when using the Chi-square fit method.; When fitting an histogram representing counts (i.e with Poisson statistics) it is recommended to; use the Log-Likelihood method (option ‘`L`' or ""`WL`""), particularly in case of low statistics.; When the histogram has been filled with weights different than one, a weighted likelihood method can be used; and the errors retrieved from the fit are corrected following a procedure described in paragraph 8.5.2 of the book,; *F. James, Statistical Methods in Experimental Physics, 2nd Edition*. ### Fit Statistics. You can change the statistics box to display the fit parameters with the; `TStyle::SetOptFit(mode)` method. This parameter has four digits:; `mode = pcev` (`default = 0111`). - `p` = 1 print probability; - `c` = 1 print Chi-square/number of degrees of freedom; - `e` = 1 print errors (if `e=1`, `v` must be 1); - `v` = 1 print name/values of parameters. For example, to print the fit probability, parameter names/values, and; errors, use:. ``` {.cpp}; gStyle->SetOptFit(1011);; ```. ## The Fit Panel. ![The Fit Panel](pictures/03000061.png). To display the Fit Panel right click on a histogram to pop up the; context menu, and then select the menu entry Fit Panel. The new Fit Panel GUI is available in ROOT v5.14. Its goal is to; replace the old Fit Panel and to provide more user friendly way for; performing, exploring and comparing fits. By design, this user interface is planned to contain two tabs:; ""General"" and ""Minimization"". Currently, the ""General"" tab provides; user interface elements for setting the fit function, fit method and; different fit, draw, print options.; The ""Minimization tab"" provides the option to set the Minimizer to use in the fit and; its specific options. The new fit panel is a modeless dialog, i.e. when opened, it does not; pr",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:19904,Availability,error,errors,19904,"Error(bin);; ```. Empty bins are excluded in the fit when using the Chi-square fit method.; When fitting an histogram representing counts (i.e with Poisson statistics) it is recommended to; use the Log-Likelihood method (option ‘`L`' or ""`WL`""), particularly in case of low statistics.; When the histogram has been filled with weights different than one, a weighted likelihood method can be used; and the errors retrieved from the fit are corrected following a procedure described in paragraph 8.5.2 of the book,; *F. James, Statistical Methods in Experimental Physics, 2nd Edition*. ### Fit Statistics. You can change the statistics box to display the fit parameters with the; `TStyle::SetOptFit(mode)` method. This parameter has four digits:; `mode = pcev` (`default = 0111`). - `p` = 1 print probability; - `c` = 1 print Chi-square/number of degrees of freedom; - `e` = 1 print errors (if `e=1`, `v` must be 1); - `v` = 1 print name/values of parameters. For example, to print the fit probability, parameter names/values, and; errors, use:. ``` {.cpp}; gStyle->SetOptFit(1011);; ```. ## The Fit Panel. ![The Fit Panel](pictures/03000061.png). To display the Fit Panel right click on a histogram to pop up the; context menu, and then select the menu entry Fit Panel. The new Fit Panel GUI is available in ROOT v5.14. Its goal is to; replace the old Fit Panel and to provide more user friendly way for; performing, exploring and comparing fits. By design, this user interface is planned to contain two tabs:; ""General"" and ""Minimization"". Currently, the ""General"" tab provides; user interface elements for setting the fit function, fit method and; different fit, draw, print options.; The ""Minimization tab"" provides the option to set the Minimizer to use in the fit and; its specific options. The new fit panel is a modeless dialog, i.e. when opened, it does not; prevent users from interacting with other windows. Its first prototype; is a singleton application. When the Fit Panel is activated, u",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:20168,Availability,avail,available,20168," the histogram has been filled with weights different than one, a weighted likelihood method can be used; and the errors retrieved from the fit are corrected following a procedure described in paragraph 8.5.2 of the book,; *F. James, Statistical Methods in Experimental Physics, 2nd Edition*. ### Fit Statistics. You can change the statistics box to display the fit parameters with the; `TStyle::SetOptFit(mode)` method. This parameter has four digits:; `mode = pcev` (`default = 0111`). - `p` = 1 print probability; - `c` = 1 print Chi-square/number of degrees of freedom; - `e` = 1 print errors (if `e=1`, `v` must be 1); - `v` = 1 print name/values of parameters. For example, to print the fit probability, parameter names/values, and; errors, use:. ``` {.cpp}; gStyle->SetOptFit(1011);; ```. ## The Fit Panel. ![The Fit Panel](pictures/03000061.png). To display the Fit Panel right click on a histogram to pop up the; context menu, and then select the menu entry Fit Panel. The new Fit Panel GUI is available in ROOT v5.14. Its goal is to; replace the old Fit Panel and to provide more user friendly way for; performing, exploring and comparing fits. By design, this user interface is planned to contain two tabs:; ""General"" and ""Minimization"". Currently, the ""General"" tab provides; user interface elements for setting the fit function, fit method and; different fit, draw, print options.; The ""Minimization tab"" provides the option to set the Minimizer to use in the fit and; its specific options. The new fit panel is a modeless dialog, i.e. when opened, it does not; prevent users from interacting with other windows. Its first prototype; is a singleton application. When the Fit Panel is activated, users can; select an object for fitting in the usual way, i.e. by left-mouse; click on it. If the selected object is suitable for fitting, the fit; panel is connected with this object and users can perform fits by; setting different parameters and options. ### Function Choice and Settings. *‘",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:21737,Availability,error,error,21737,"s not; prevent users from interacting with other windows. Its first prototype; is a singleton application. When the Fit Panel is activated, users can; select an object for fitting in the usual way, i.e. by left-mouse; click on it. If the selected object is suitable for fitting, the fit; panel is connected with this object and users can perform fits by; setting different parameters and options. ### Function Choice and Settings. *‘Predefined' combo box* - contains a list of predefined functions in; ROOT. You have a choice of several polynomials, a Gaussian, a Landau,; and an Exponential function. The default one is Gaussian. *‘Operation' radio button group* defines the selected operational mode; between functions:. *Nop* - no operation (default);. *Add* - addition;. *Conv* - convolution (will be implemented in the future). Users can enter the function expression into the text entry field; below the ‘Predefined' combo box. The entered string is checked after; the Enter key was pressed and an error message shows up, if the; function string is not accepted. ‘*Set Parameters*' button opens a dialog for parameters settings,; which will be explained later. ### Fitter Settings. *‘Method' combo box* currently provides only two fit model choices:; Chi-square and Binned Likelihood. The default one is Chi-square. The; Binned Likelihood is recommended for bins with low statistics. *‘Linear Fit' check button* sets the use of Linear fitter when is; selected. Otherwise the minimization is done by Minuit, i.e. fit; option ""`F`"" is applied. The Linear fitter can be selected only for; functions linear in parameters (for example - `polN)`. *‘Robust' number entry* sets the robust value when fitting graphs. *‘No Chi-square' check button* switch On/Off the fit option ""`C`"" -; do not calculate Chi-square (for Linear fitter). *‘Integral' check button* switch On/Off the option ""`I`"" - use; integral of function instead of value in bin center. *‘Best Errors'* sets On/Off the option ""`E`"" - bette",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:22413,Availability,robust,robust,22413,"ected operational mode; between functions:. *Nop* - no operation (default);. *Add* - addition;. *Conv* - convolution (will be implemented in the future). Users can enter the function expression into the text entry field; below the ‘Predefined' combo box. The entered string is checked after; the Enter key was pressed and an error message shows up, if the; function string is not accepted. ‘*Set Parameters*' button opens a dialog for parameters settings,; which will be explained later. ### Fitter Settings. *‘Method' combo box* currently provides only two fit model choices:; Chi-square and Binned Likelihood. The default one is Chi-square. The; Binned Likelihood is recommended for bins with low statistics. *‘Linear Fit' check button* sets the use of Linear fitter when is; selected. Otherwise the minimization is done by Minuit, i.e. fit; option ""`F`"" is applied. The Linear fitter can be selected only for; functions linear in parameters (for example - `polN)`. *‘Robust' number entry* sets the robust value when fitting graphs. *‘No Chi-square' check button* switch On/Off the fit option ""`C`"" -; do not calculate Chi-square (for Linear fitter). *‘Integral' check button* switch On/Off the option ""`I`"" - use; integral of function instead of value in bin center. *‘Best Errors'* sets On/Off the option ""`E`"" - better errors; estimation by using Minos technique. *‘All weights = 1'* sets On/Off the option ""`W`""- all weights set to 1; excluding empty bins; error bars ignored. *‘Empty bins, weights=1'* sets On/Off the option ""`WW`"" - all weights; equal to 1 including empty bins; error bars ignored. *‘Use range'* sets On/Off the option ""`R`"" - fit only data within the; specified function range. Sliders settings are used if this option is; set to On. Users can change the function range values by pressing the; left mouse button near to the left/right slider edges. It is possible; to change both values simultaneously by pressing the left mouse button; near to the slider center and moving i",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:22736,Availability,error,errors,22736,"and an error message shows up, if the; function string is not accepted. ‘*Set Parameters*' button opens a dialog for parameters settings,; which will be explained later. ### Fitter Settings. *‘Method' combo box* currently provides only two fit model choices:; Chi-square and Binned Likelihood. The default one is Chi-square. The; Binned Likelihood is recommended for bins with low statistics. *‘Linear Fit' check button* sets the use of Linear fitter when is; selected. Otherwise the minimization is done by Minuit, i.e. fit; option ""`F`"" is applied. The Linear fitter can be selected only for; functions linear in parameters (for example - `polN)`. *‘Robust' number entry* sets the robust value when fitting graphs. *‘No Chi-square' check button* switch On/Off the fit option ""`C`"" -; do not calculate Chi-square (for Linear fitter). *‘Integral' check button* switch On/Off the option ""`I`"" - use; integral of function instead of value in bin center. *‘Best Errors'* sets On/Off the option ""`E`"" - better errors; estimation by using Minos technique. *‘All weights = 1'* sets On/Off the option ""`W`""- all weights set to 1; excluding empty bins; error bars ignored. *‘Empty bins, weights=1'* sets On/Off the option ""`WW`"" - all weights; equal to 1 including empty bins; error bars ignored. *‘Use range'* sets On/Off the option ""`R`"" - fit only data within the; specified function range. Sliders settings are used if this option is; set to On. Users can change the function range values by pressing the; left mouse button near to the left/right slider edges. It is possible; to change both values simultaneously by pressing the left mouse button; near to the slider center and moving it to a new position. *‘Improve fit results'* sets On/Off the option ""`M`""- after minimum is; found, search for a new one. *‘Add to list'* sets On/Off the option ""`+`""- add function to the list; without deleting the previous one. When fitting a histogram, the; function is attached to the histogram's list of functions.",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:22875,Availability,error,error,22875,"ialog for parameters settings,; which will be explained later. ### Fitter Settings. *‘Method' combo box* currently provides only two fit model choices:; Chi-square and Binned Likelihood. The default one is Chi-square. The; Binned Likelihood is recommended for bins with low statistics. *‘Linear Fit' check button* sets the use of Linear fitter when is; selected. Otherwise the minimization is done by Minuit, i.e. fit; option ""`F`"" is applied. The Linear fitter can be selected only for; functions linear in parameters (for example - `polN)`. *‘Robust' number entry* sets the robust value when fitting graphs. *‘No Chi-square' check button* switch On/Off the fit option ""`C`"" -; do not calculate Chi-square (for Linear fitter). *‘Integral' check button* switch On/Off the option ""`I`"" - use; integral of function instead of value in bin center. *‘Best Errors'* sets On/Off the option ""`E`"" - better errors; estimation by using Minos technique. *‘All weights = 1'* sets On/Off the option ""`W`""- all weights set to 1; excluding empty bins; error bars ignored. *‘Empty bins, weights=1'* sets On/Off the option ""`WW`"" - all weights; equal to 1 including empty bins; error bars ignored. *‘Use range'* sets On/Off the option ""`R`"" - fit only data within the; specified function range. Sliders settings are used if this option is; set to On. Users can change the function range values by pressing the; left mouse button near to the left/right slider edges. It is possible; to change both values simultaneously by pressing the left mouse button; near to the slider center and moving it to a new position. *‘Improve fit results'* sets On/Off the option ""`M`""- after minimum is; found, search for a new one. *‘Add to list'* sets On/Off the option ""`+`""- add function to the list; without deleting the previous one. When fitting a histogram, the; function is attached to the histogram's list of functions. By default,; the previously fitted function is deleted and replaced with the most; recent one, so the lis",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:22999,Availability,error,error,22999,"ides only two fit model choices:; Chi-square and Binned Likelihood. The default one is Chi-square. The; Binned Likelihood is recommended for bins with low statistics. *‘Linear Fit' check button* sets the use of Linear fitter when is; selected. Otherwise the minimization is done by Minuit, i.e. fit; option ""`F`"" is applied. The Linear fitter can be selected only for; functions linear in parameters (for example - `polN)`. *‘Robust' number entry* sets the robust value when fitting graphs. *‘No Chi-square' check button* switch On/Off the fit option ""`C`"" -; do not calculate Chi-square (for Linear fitter). *‘Integral' check button* switch On/Off the option ""`I`"" - use; integral of function instead of value in bin center. *‘Best Errors'* sets On/Off the option ""`E`"" - better errors; estimation by using Minos technique. *‘All weights = 1'* sets On/Off the option ""`W`""- all weights set to 1; excluding empty bins; error bars ignored. *‘Empty bins, weights=1'* sets On/Off the option ""`WW`"" - all weights; equal to 1 including empty bins; error bars ignored. *‘Use range'* sets On/Off the option ""`R`"" - fit only data within the; specified function range. Sliders settings are used if this option is; set to On. Users can change the function range values by pressing the; left mouse button near to the left/right slider edges. It is possible; to change both values simultaneously by pressing the left mouse button; near to the slider center and moving it to a new position. *‘Improve fit results'* sets On/Off the option ""`M`""- after minimum is; found, search for a new one. *‘Add to list'* sets On/Off the option ""`+`""- add function to the list; without deleting the previous one. When fitting a histogram, the; function is attached to the histogram's list of functions. By default,; the previously fitted function is deleted and replaced with the most; recent one, so the list only contains one function. Setting this; option to On will add the newly fitted function to the existing list; of fu",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:26203,Availability,toler,tolerance,26203," confidence interval of the fitted function as a filled coloured band around its central value.; One can select the desired confidence level for the band to be plotted. ### Print Options. This set of options specifies the amount of feedback printed on the; root command line after performed fits. *‘Verbose'* - prints fit results after each iteration. *‘Quiet'* - no fit information is printed. *‘Default'* - between Verbose and Quiet. ### Command Buttons. *Fit button* - performs a fit taking different option settings via the; Fit Panel interface. *Reset* - sets the GUI elements and related fit settings to the; default ones. *Close* - closes the Fit panel window. ### Minimization Options. With this tab one can select specific options for minimization. These include. * The minimizer library ( *Minuit*, *Minuit2*, *Fumili*, *GSL*, *Genetics* ); * The method (algorithm) for minimization. For example for Minuit one can choose between (*Migrad*, *Simplex* or *Scan*); * Error definition; * Minimization tolerance; * Number of iterations/function calls; * Print Level: (*Default*, *Verbose* or *Quiet*). ## New ROOT::Fit classes. The fitting of the data objects in ROOT, histograms, graphs and tree is performed via some common classes,; which are defined in the `ROOT::Fit` namespace.; These classes can be classified in the following groups:. * User classes driving the fit: `ROOT::Fit::Fitter` for executing the fit, `ROOT::Fit::FitConfig` for configuring the fit,; 	`ROOT::Fit::ParameterSettings` to define the properties of the fit parameters (initial; 	values, bounds, etc..), `ROOT::Fit::FitResult` for storing the result of the fit.; * Data classes containing the data sets used in the fitting. These classes are the`ROOT::Fit::BinData`for describing bin data sets,; 	 thus data points containing both coordinates and a corresponding value/weight; 	 with optionally an error on the value or the coordinate and the `ROOT::Fit::UnBinData` for un-binned data sets,; 	 which consists only of ",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:27076,Availability,error,error,27076,"orithm) for minimization. For example for Minuit one can choose between (*Migrad*, *Simplex* or *Scan*); * Error definition; * Minimization tolerance; * Number of iterations/function calls; * Print Level: (*Default*, *Verbose* or *Quiet*). ## New ROOT::Fit classes. The fitting of the data objects in ROOT, histograms, graphs and tree is performed via some common classes,; which are defined in the `ROOT::Fit` namespace.; These classes can be classified in the following groups:. * User classes driving the fit: `ROOT::Fit::Fitter` for executing the fit, `ROOT::Fit::FitConfig` for configuring the fit,; 	`ROOT::Fit::ParameterSettings` to define the properties of the fit parameters (initial; 	values, bounds, etc..), `ROOT::Fit::FitResult` for storing the result of the fit.; * Data classes containing the data sets used in the fitting. These classes are the`ROOT::Fit::BinData`for describing bin data sets,; 	 thus data points containing both coordinates and a corresponding value/weight; 	 with optionally an error on the value or the coordinate and the `ROOT::Fit::UnBinData` for un-binned data sets,; 	 which consists only of a vector of coordinate values. The coordinate values can be; 	 one-dimensional (i.e. one entry per event) or multi-dimensional (N entries per event).; * Function classes defining the type of fit (the objective function used for fitting):; 	- `ROOT::Fit::Chi2FCN` for chi2 (least-square fits),; 	- `ROOT::Fit::PoissonLikelihoodFCN` for binned likelihood fits of histograms,; 	- `ROOT::Fit::LogLikelihoodFCN` for generic un-binned likelihood fits.; 	These classes are templated on the type of function interface they implement (see later). User convenient typedefs are also provided.; 	They derive from the common generic interface multi-dimensional for function evaluation, `ROOT::Math::IBaseFunctionMultiDim`. In addition the fitter classes make uses of the generic interfaces for parametric function evaluations, `ROOT::Math::IParametricFunctionMultiDim`; to define t",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:29027,Availability,error,errors,29027,"`ROOT::Math::Minimizer` interface to perform the minimization of the objective function.; More information about the function interface and the multi-dimensional minimization in ROOT is given in the Mathematical Library chapter. Here we present a detailed description of the `ROOT::Fit` classes and how to use them.; Using these classes instead of the interface provided directly in the ROOT data objects, like `TH1::Fit` allow are more fine control; to configure and customise the fits. For example, using these classes a combined fit of several histograms can be performed. To understand how these class work, let's go through a simple example, such as fitting an histogram. When fitting an histogram, instead of using `TH1::Fit` we will show in the following hot wo use the `ROOT::Fit` classes.; We will show how to perform the following different type of fits with the histogram data:; * a least square fit using the observed errors (Neyman chi-squared);; * a least square fit using the expected errors from the function (Pearson chi-squared);; * a binned likelihood fit;; * an extended unbinned likelihood fits, if the histogram has been set to store in the buffer the original data used to fill it. Let's go through all the steps required for performing these fits using the `ROOT::Fit::Fitter` class.; These steps are:; 1. Create the input fit data object.; 2. Create the input model function.; 3. Configure the fit.; 4. Perform the data fitting.; 5. Examine the result. ### Creating the input fit data. We have two types of input data, binned data (class `ROOT::Fit::BinData`) used for least square (chi-square) fits of histograms or `TGraph` objects; or un-binned data (class `ROOT::Fit::UnBinData`) used for; fitting vectors of data points (e.g. from a `TTree`). #### Using Binned data. Let's suppose we have an histogram, represented as a **`TH1`** type object (it can be one or multi-dimensional). The following shows how to create and; fill a `ROOT:Fit::BinData` object. ``` {.cpp}; ROOT:",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:29097,Availability,error,errors,29097,"`ROOT::Math::Minimizer` interface to perform the minimization of the objective function.; More information about the function interface and the multi-dimensional minimization in ROOT is given in the Mathematical Library chapter. Here we present a detailed description of the `ROOT::Fit` classes and how to use them.; Using these classes instead of the interface provided directly in the ROOT data objects, like `TH1::Fit` allow are more fine control; to configure and customise the fits. For example, using these classes a combined fit of several histograms can be performed. To understand how these class work, let's go through a simple example, such as fitting an histogram. When fitting an histogram, instead of using `TH1::Fit` we will show in the following hot wo use the `ROOT::Fit` classes.; We will show how to perform the following different type of fits with the histogram data:; * a least square fit using the observed errors (Neyman chi-squared);; * a least square fit using the expected errors from the function (Pearson chi-squared);; * a binned likelihood fit;; * an extended unbinned likelihood fits, if the histogram has been set to store in the buffer the original data used to fill it. Let's go through all the steps required for performing these fits using the `ROOT::Fit::Fitter` class.; These steps are:; 1. Create the input fit data object.; 2. Create the input model function.; 3. Configure the fit.; 4. Perform the data fitting.; 5. Examine the result. ### Creating the input fit data. We have two types of input data, binned data (class `ROOT::Fit::BinData`) used for least square (chi-square) fits of histograms or `TGraph` objects; or un-binned data (class `ROOT::Fit::UnBinData`) used for; fitting vectors of data points (e.g. from a `TTree`). #### Using Binned data. Let's suppose we have an histogram, represented as a **`TH1`** type object (it can be one or multi-dimensional). The following shows how to create and; fill a `ROOT:Fit::BinData` object. ``` {.cpp}; ROOT:",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:31643,Availability,avail,available,31643," like `TH1`, `THnBase`, `TGraph`, `TGraph2D` and `TMultiGraph`; It is possible to specify, when creating the `BinData` object, the data range we want to use and some fitting options we want to apply; to fill in the object and later when fitting.; The fit data options are controlled by the ``ROOT::Fit::DataOptions`` class, the range by the ``ROOT::Fit::DataRange`` class. Here is an example how to specify the input option to use the integral of the function value in the bin instead of using the function value; evaluated at the bin center, when doing the fit and to use a; range beween the 'xmin' and 'xmax' values. ``` {.cpp}; ROOT::Fit::DataOptions opt;; opt.fIntegral = true;; ROOT::Fit::DataRange range(xmin,xmax);; ROOT::Fit::BinData data(opt,range);; // fill the bin data using the histogram; // we can do this using the following helper function from the Hist library; TH1 * h1 = (TH1*) gDirectory->Get(""myHistogram"");; ROOT::Fit::FillData(data, h1);; ```. The list of possible fit options available is the following:; ``` {.cpp}; ROOT::Fit::DataOptions opt;; opt.fIntegral = true; // use integral of bin content instead of bin center (default is false).; opt.fBinVolume = true; // normalize data by the bin volume (default is false).; // This is for fitting density functions in histograms with variable bin sizes.; opt.fUseRange =true; // use the function range when creating the fit data (default is false).; opt.fExpErrors = true; // use the expected errors estimated from the function values; // assuming Poisson statistics and not the observed errors (default is false).; opt.fUseEmpty = true; // use empty bins when fitting (default is false). If fExpErrors; 							 // is not set an arbitrary error = 1 is assigned to those bins.; opt.fErrors1 = true; // Set all measured errors to 1 (default is false).; opt.fCoordErrors = false; // When available coordinate errors are not used in the fit; // (default is true: the errors are used when they are available,; // e.g. fitting a TGraph",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:32108,Availability,error,errors,32108," value; evaluated at the bin center, when doing the fit and to use a; range beween the 'xmin' and 'xmax' values. ``` {.cpp}; ROOT::Fit::DataOptions opt;; opt.fIntegral = true;; ROOT::Fit::DataRange range(xmin,xmax);; ROOT::Fit::BinData data(opt,range);; // fill the bin data using the histogram; // we can do this using the following helper function from the Hist library; TH1 * h1 = (TH1*) gDirectory->Get(""myHistogram"");; ROOT::Fit::FillData(data, h1);; ```. The list of possible fit options available is the following:; ``` {.cpp}; ROOT::Fit::DataOptions opt;; opt.fIntegral = true; // use integral of bin content instead of bin center (default is false).; opt.fBinVolume = true; // normalize data by the bin volume (default is false).; // This is for fitting density functions in histograms with variable bin sizes.; opt.fUseRange =true; // use the function range when creating the fit data (default is false).; opt.fExpErrors = true; // use the expected errors estimated from the function values; // assuming Poisson statistics and not the observed errors (default is false).; opt.fUseEmpty = true; // use empty bins when fitting (default is false). If fExpErrors; 							 // is not set an arbitrary error = 1 is assigned to those bins.; opt.fErrors1 = true; // Set all measured errors to 1 (default is false).; opt.fCoordErrors = false; // When available coordinate errors are not used in the fit; // (default is true: the errors are used when they are available,; // e.g. fitting a TGraphErrors).; opt.fAsymErrors = false; // When available asymmetric errors are considered in the fit; // (default is true, the asymmetric errors are used when they are available,; // e.g. fitting a TGraphAsymmErrors).; ```. The `ROOT::Fit::DataRange` class supports defining multiple rectangular ranges in each dimension, and supports n-dimension.; The function `DataRange::AddRange(icoord,xmin,xmax)` adds a range in; the coordinate `icoord` with lower value `xmin` and upper value `xmax`:. ``` {.cpp}; ROOT:",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:32203,Availability,error,errors,32203," value; evaluated at the bin center, when doing the fit and to use a; range beween the 'xmin' and 'xmax' values. ``` {.cpp}; ROOT::Fit::DataOptions opt;; opt.fIntegral = true;; ROOT::Fit::DataRange range(xmin,xmax);; ROOT::Fit::BinData data(opt,range);; // fill the bin data using the histogram; // we can do this using the following helper function from the Hist library; TH1 * h1 = (TH1*) gDirectory->Get(""myHistogram"");; ROOT::Fit::FillData(data, h1);; ```. The list of possible fit options available is the following:; ``` {.cpp}; ROOT::Fit::DataOptions opt;; opt.fIntegral = true; // use integral of bin content instead of bin center (default is false).; opt.fBinVolume = true; // normalize data by the bin volume (default is false).; // This is for fitting density functions in histograms with variable bin sizes.; opt.fUseRange =true; // use the function range when creating the fit data (default is false).; opt.fExpErrors = true; // use the expected errors estimated from the function values; // assuming Poisson statistics and not the observed errors (default is false).; opt.fUseEmpty = true; // use empty bins when fitting (default is false). If fExpErrors; 							 // is not set an arbitrary error = 1 is assigned to those bins.; opt.fErrors1 = true; // Set all measured errors to 1 (default is false).; opt.fCoordErrors = false; // When available coordinate errors are not used in the fit; // (default is true: the errors are used when they are available,; // e.g. fitting a TGraphErrors).; opt.fAsymErrors = false; // When available asymmetric errors are considered in the fit; // (default is true, the asymmetric errors are used when they are available,; // e.g. fitting a TGraphAsymmErrors).; ```. The `ROOT::Fit::DataRange` class supports defining multiple rectangular ranges in each dimension, and supports n-dimension.; The function `DataRange::AddRange(icoord,xmin,xmax)` adds a range in; the coordinate `icoord` with lower value `xmin` and upper value `xmax`:. ``` {.cpp}; ROOT:",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:32354,Availability,error,error,32354," range(xmin,xmax);; ROOT::Fit::BinData data(opt,range);; // fill the bin data using the histogram; // we can do this using the following helper function from the Hist library; TH1 * h1 = (TH1*) gDirectory->Get(""myHistogram"");; ROOT::Fit::FillData(data, h1);; ```. The list of possible fit options available is the following:; ``` {.cpp}; ROOT::Fit::DataOptions opt;; opt.fIntegral = true; // use integral of bin content instead of bin center (default is false).; opt.fBinVolume = true; // normalize data by the bin volume (default is false).; // This is for fitting density functions in histograms with variable bin sizes.; opt.fUseRange =true; // use the function range when creating the fit data (default is false).; opt.fExpErrors = true; // use the expected errors estimated from the function values; // assuming Poisson statistics and not the observed errors (default is false).; opt.fUseEmpty = true; // use empty bins when fitting (default is false). If fExpErrors; 							 // is not set an arbitrary error = 1 is assigned to those bins.; opt.fErrors1 = true; // Set all measured errors to 1 (default is false).; opt.fCoordErrors = false; // When available coordinate errors are not used in the fit; // (default is true: the errors are used when they are available,; // e.g. fitting a TGraphErrors).; opt.fAsymErrors = false; // When available asymmetric errors are considered in the fit; // (default is true, the asymmetric errors are used when they are available,; // e.g. fitting a TGraphAsymmErrors).; ```. The `ROOT::Fit::DataRange` class supports defining multiple rectangular ranges in each dimension, and supports n-dimension.; The function `DataRange::AddRange(icoord,xmin,xmax)` adds a range in; the coordinate `icoord` with lower value `xmin` and upper value `xmax`:. ``` {.cpp}; ROOT::Fit::DataRange range;; range.AddRange(icoordinate, xmin, xmax);; ```. #### Using Un-Binned data. The unbinned data sets are represented with the `ROOT::Fit::UnBinData` class.; For creating un-binne",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:32433,Availability,error,errors,32433,"the histogram; // we can do this using the following helper function from the Hist library; TH1 * h1 = (TH1*) gDirectory->Get(""myHistogram"");; ROOT::Fit::FillData(data, h1);; ```. The list of possible fit options available is the following:; ``` {.cpp}; ROOT::Fit::DataOptions opt;; opt.fIntegral = true; // use integral of bin content instead of bin center (default is false).; opt.fBinVolume = true; // normalize data by the bin volume (default is false).; // This is for fitting density functions in histograms with variable bin sizes.; opt.fUseRange =true; // use the function range when creating the fit data (default is false).; opt.fExpErrors = true; // use the expected errors estimated from the function values; // assuming Poisson statistics and not the observed errors (default is false).; opt.fUseEmpty = true; // use empty bins when fitting (default is false). If fExpErrors; 							 // is not set an arbitrary error = 1 is assigned to those bins.; opt.fErrors1 = true; // Set all measured errors to 1 (default is false).; opt.fCoordErrors = false; // When available coordinate errors are not used in the fit; // (default is true: the errors are used when they are available,; // e.g. fitting a TGraphErrors).; opt.fAsymErrors = false; // When available asymmetric errors are considered in the fit; // (default is true, the asymmetric errors are used when they are available,; // e.g. fitting a TGraphAsymmErrors).; ```. The `ROOT::Fit::DataRange` class supports defining multiple rectangular ranges in each dimension, and supports n-dimension.; The function `DataRange::AddRange(icoord,xmin,xmax)` adds a range in; the coordinate `icoord` with lower value `xmin` and upper value `xmax`:. ``` {.cpp}; ROOT::Fit::DataRange range;; range.AddRange(icoordinate, xmin, xmax);; ```. #### Using Un-Binned data. The unbinned data sets are represented with the `ROOT::Fit::UnBinData` class.; For creating un-binned data sets, a `ROOT::Fit::UnBinData` object, one has two possibilities:; 1. Copy t",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:32500,Availability,avail,available,32500,"ory->Get(""myHistogram"");; ROOT::Fit::FillData(data, h1);; ```. The list of possible fit options available is the following:; ``` {.cpp}; ROOT::Fit::DataOptions opt;; opt.fIntegral = true; // use integral of bin content instead of bin center (default is false).; opt.fBinVolume = true; // normalize data by the bin volume (default is false).; // This is for fitting density functions in histograms with variable bin sizes.; opt.fUseRange =true; // use the function range when creating the fit data (default is false).; opt.fExpErrors = true; // use the expected errors estimated from the function values; // assuming Poisson statistics and not the observed errors (default is false).; opt.fUseEmpty = true; // use empty bins when fitting (default is false). If fExpErrors; 							 // is not set an arbitrary error = 1 is assigned to those bins.; opt.fErrors1 = true; // Set all measured errors to 1 (default is false).; opt.fCoordErrors = false; // When available coordinate errors are not used in the fit; // (default is true: the errors are used when they are available,; // e.g. fitting a TGraphErrors).; opt.fAsymErrors = false; // When available asymmetric errors are considered in the fit; // (default is true, the asymmetric errors are used when they are available,; // e.g. fitting a TGraphAsymmErrors).; ```. The `ROOT::Fit::DataRange` class supports defining multiple rectangular ranges in each dimension, and supports n-dimension.; The function `DataRange::AddRange(icoord,xmin,xmax)` adds a range in; the coordinate `icoord` with lower value `xmin` and upper value `xmax`:. ``` {.cpp}; ROOT::Fit::DataRange range;; range.AddRange(icoordinate, xmin, xmax);; ```. #### Using Un-Binned data. The unbinned data sets are represented with the `ROOT::Fit::UnBinData` class.; For creating un-binned data sets, a `ROOT::Fit::UnBinData` object, one has two possibilities:; 1. Copy the data inside `ROOT::Fit::UnBinData`. One can create an empty `UnBinData` object, iterate on the data and add the dat",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:32521,Availability,error,errors,32521,"ory->Get(""myHistogram"");; ROOT::Fit::FillData(data, h1);; ```. The list of possible fit options available is the following:; ``` {.cpp}; ROOT::Fit::DataOptions opt;; opt.fIntegral = true; // use integral of bin content instead of bin center (default is false).; opt.fBinVolume = true; // normalize data by the bin volume (default is false).; // This is for fitting density functions in histograms with variable bin sizes.; opt.fUseRange =true; // use the function range when creating the fit data (default is false).; opt.fExpErrors = true; // use the expected errors estimated from the function values; // assuming Poisson statistics and not the observed errors (default is false).; opt.fUseEmpty = true; // use empty bins when fitting (default is false). If fExpErrors; 							 // is not set an arbitrary error = 1 is assigned to those bins.; opt.fErrors1 = true; // Set all measured errors to 1 (default is false).; opt.fCoordErrors = false; // When available coordinate errors are not used in the fit; // (default is true: the errors are used when they are available,; // e.g. fitting a TGraphErrors).; opt.fAsymErrors = false; // When available asymmetric errors are considered in the fit; // (default is true, the asymmetric errors are used when they are available,; // e.g. fitting a TGraphAsymmErrors).; ```. The `ROOT::Fit::DataRange` class supports defining multiple rectangular ranges in each dimension, and supports n-dimension.; The function `DataRange::AddRange(icoord,xmin,xmax)` adds a range in; the coordinate `icoord` with lower value `xmin` and upper value `xmax`:. ``` {.cpp}; ROOT::Fit::DataRange range;; range.AddRange(icoordinate, xmin, xmax);; ```. #### Using Un-Binned data. The unbinned data sets are represented with the `ROOT::Fit::UnBinData` class.; For creating un-binned data sets, a `ROOT::Fit::UnBinData` object, one has two possibilities:; 1. Copy the data inside `ROOT::Fit::UnBinData`. One can create an empty `UnBinData` object, iterate on the data and add the dat",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:32578,Availability,error,errors,32578,"ory->Get(""myHistogram"");; ROOT::Fit::FillData(data, h1);; ```. The list of possible fit options available is the following:; ``` {.cpp}; ROOT::Fit::DataOptions opt;; opt.fIntegral = true; // use integral of bin content instead of bin center (default is false).; opt.fBinVolume = true; // normalize data by the bin volume (default is false).; // This is for fitting density functions in histograms with variable bin sizes.; opt.fUseRange =true; // use the function range when creating the fit data (default is false).; opt.fExpErrors = true; // use the expected errors estimated from the function values; // assuming Poisson statistics and not the observed errors (default is false).; opt.fUseEmpty = true; // use empty bins when fitting (default is false). If fExpErrors; 							 // is not set an arbitrary error = 1 is assigned to those bins.; opt.fErrors1 = true; // Set all measured errors to 1 (default is false).; opt.fCoordErrors = false; // When available coordinate errors are not used in the fit; // (default is true: the errors are used when they are available,; // e.g. fitting a TGraphErrors).; opt.fAsymErrors = false; // When available asymmetric errors are considered in the fit; // (default is true, the asymmetric errors are used when they are available,; // e.g. fitting a TGraphAsymmErrors).; ```. The `ROOT::Fit::DataRange` class supports defining multiple rectangular ranges in each dimension, and supports n-dimension.; The function `DataRange::AddRange(icoord,xmin,xmax)` adds a range in; the coordinate `icoord` with lower value `xmin` and upper value `xmax`:. ``` {.cpp}; ROOT::Fit::DataRange range;; range.AddRange(icoordinate, xmin, xmax);; ```. #### Using Un-Binned data. The unbinned data sets are represented with the `ROOT::Fit::UnBinData` class.; For creating un-binned data sets, a `ROOT::Fit::UnBinData` object, one has two possibilities:; 1. Copy the data inside `ROOT::Fit::UnBinData`. One can create an empty `UnBinData` object, iterate on the data and add the dat",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:32608,Availability,avail,available,32608,"ory->Get(""myHistogram"");; ROOT::Fit::FillData(data, h1);; ```. The list of possible fit options available is the following:; ``` {.cpp}; ROOT::Fit::DataOptions opt;; opt.fIntegral = true; // use integral of bin content instead of bin center (default is false).; opt.fBinVolume = true; // normalize data by the bin volume (default is false).; // This is for fitting density functions in histograms with variable bin sizes.; opt.fUseRange =true; // use the function range when creating the fit data (default is false).; opt.fExpErrors = true; // use the expected errors estimated from the function values; // assuming Poisson statistics and not the observed errors (default is false).; opt.fUseEmpty = true; // use empty bins when fitting (default is false). If fExpErrors; 							 // is not set an arbitrary error = 1 is assigned to those bins.; opt.fErrors1 = true; // Set all measured errors to 1 (default is false).; opt.fCoordErrors = false; // When available coordinate errors are not used in the fit; // (default is true: the errors are used when they are available,; // e.g. fitting a TGraphErrors).; opt.fAsymErrors = false; // When available asymmetric errors are considered in the fit; // (default is true, the asymmetric errors are used when they are available,; // e.g. fitting a TGraphAsymmErrors).; ```. The `ROOT::Fit::DataRange` class supports defining multiple rectangular ranges in each dimension, and supports n-dimension.; The function `DataRange::AddRange(icoord,xmin,xmax)` adds a range in; the coordinate `icoord` with lower value `xmin` and upper value `xmax`:. ``` {.cpp}; ROOT::Fit::DataRange range;; range.AddRange(icoordinate, xmin, xmax);; ```. #### Using Un-Binned data. The unbinned data sets are represented with the `ROOT::Fit::UnBinData` class.; For creating un-binned data sets, a `ROOT::Fit::UnBinData` object, one has two possibilities:; 1. Copy the data inside `ROOT::Fit::UnBinData`. One can create an empty `UnBinData` object, iterate on the data and add the dat",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:32687,Availability,avail,available,32687," integral of bin content instead of bin center (default is false).; opt.fBinVolume = true; // normalize data by the bin volume (default is false).; // This is for fitting density functions in histograms with variable bin sizes.; opt.fUseRange =true; // use the function range when creating the fit data (default is false).; opt.fExpErrors = true; // use the expected errors estimated from the function values; // assuming Poisson statistics and not the observed errors (default is false).; opt.fUseEmpty = true; // use empty bins when fitting (default is false). If fExpErrors; 							 // is not set an arbitrary error = 1 is assigned to those bins.; opt.fErrors1 = true; // Set all measured errors to 1 (default is false).; opt.fCoordErrors = false; // When available coordinate errors are not used in the fit; // (default is true: the errors are used when they are available,; // e.g. fitting a TGraphErrors).; opt.fAsymErrors = false; // When available asymmetric errors are considered in the fit; // (default is true, the asymmetric errors are used when they are available,; // e.g. fitting a TGraphAsymmErrors).; ```. The `ROOT::Fit::DataRange` class supports defining multiple rectangular ranges in each dimension, and supports n-dimension.; The function `DataRange::AddRange(icoord,xmin,xmax)` adds a range in; the coordinate `icoord` with lower value `xmin` and upper value `xmax`:. ``` {.cpp}; ROOT::Fit::DataRange range;; range.AddRange(icoordinate, xmin, xmax);; ```. #### Using Un-Binned data. The unbinned data sets are represented with the `ROOT::Fit::UnBinData` class.; For creating un-binned data sets, a `ROOT::Fit::UnBinData` object, one has two possibilities:; 1. Copy the data inside `ROOT::Fit::UnBinData`. One can create an empty `UnBinData` object, iterate on the data and add the data point one by one, or directly create the `UnBinData`; object from a data iterator. In this case an input `ROOT::Fit::DataRange` object is passed in order to copy the data according to the give",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:32708,Availability,error,errors,32708," integral of bin content instead of bin center (default is false).; opt.fBinVolume = true; // normalize data by the bin volume (default is false).; // This is for fitting density functions in histograms with variable bin sizes.; opt.fUseRange =true; // use the function range when creating the fit data (default is false).; opt.fExpErrors = true; // use the expected errors estimated from the function values; // assuming Poisson statistics and not the observed errors (default is false).; opt.fUseEmpty = true; // use empty bins when fitting (default is false). If fExpErrors; 							 // is not set an arbitrary error = 1 is assigned to those bins.; opt.fErrors1 = true; // Set all measured errors to 1 (default is false).; opt.fCoordErrors = false; // When available coordinate errors are not used in the fit; // (default is true: the errors are used when they are available,; // e.g. fitting a TGraphErrors).; opt.fAsymErrors = false; // When available asymmetric errors are considered in the fit; // (default is true, the asymmetric errors are used when they are available,; // e.g. fitting a TGraphAsymmErrors).; ```. The `ROOT::Fit::DataRange` class supports defining multiple rectangular ranges in each dimension, and supports n-dimension.; The function `DataRange::AddRange(icoord,xmin,xmax)` adds a range in; the coordinate `icoord` with lower value `xmin` and upper value `xmax`:. ``` {.cpp}; ROOT::Fit::DataRange range;; range.AddRange(icoordinate, xmin, xmax);; ```. #### Using Un-Binned data. The unbinned data sets are represented with the `ROOT::Fit::UnBinData` class.; For creating un-binned data sets, a `ROOT::Fit::UnBinData` object, one has two possibilities:; 1. Copy the data inside `ROOT::Fit::UnBinData`. One can create an empty `UnBinData` object, iterate on the data and add the data point one by one, or directly create the `UnBinData`; object from a data iterator. In this case an input `ROOT::Fit::DataRange` object is passed in order to copy the data according to the give",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:32778,Availability,error,errors,32778," integral of bin content instead of bin center (default is false).; opt.fBinVolume = true; // normalize data by the bin volume (default is false).; // This is for fitting density functions in histograms with variable bin sizes.; opt.fUseRange =true; // use the function range when creating the fit data (default is false).; opt.fExpErrors = true; // use the expected errors estimated from the function values; // assuming Poisson statistics and not the observed errors (default is false).; opt.fUseEmpty = true; // use empty bins when fitting (default is false). If fExpErrors; 							 // is not set an arbitrary error = 1 is assigned to those bins.; opt.fErrors1 = true; // Set all measured errors to 1 (default is false).; opt.fCoordErrors = false; // When available coordinate errors are not used in the fit; // (default is true: the errors are used when they are available,; // e.g. fitting a TGraphErrors).; opt.fAsymErrors = false; // When available asymmetric errors are considered in the fit; // (default is true, the asymmetric errors are used when they are available,; // e.g. fitting a TGraphAsymmErrors).; ```. The `ROOT::Fit::DataRange` class supports defining multiple rectangular ranges in each dimension, and supports n-dimension.; The function `DataRange::AddRange(icoord,xmin,xmax)` adds a range in; the coordinate `icoord` with lower value `xmin` and upper value `xmax`:. ``` {.cpp}; ROOT::Fit::DataRange range;; range.AddRange(icoordinate, xmin, xmax);; ```. #### Using Un-Binned data. The unbinned data sets are represented with the `ROOT::Fit::UnBinData` class.; For creating un-binned data sets, a `ROOT::Fit::UnBinData` object, one has two possibilities:; 1. Copy the data inside `ROOT::Fit::UnBinData`. One can create an empty `UnBinData` object, iterate on the data and add the data point one by one, or directly create the `UnBinData`; object from a data iterator. In this case an input `ROOT::Fit::DataRange` object is passed in order to copy the data according to the give",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:32808,Availability,avail,available,32808," integral of bin content instead of bin center (default is false).; opt.fBinVolume = true; // normalize data by the bin volume (default is false).; // This is for fitting density functions in histograms with variable bin sizes.; opt.fUseRange =true; // use the function range when creating the fit data (default is false).; opt.fExpErrors = true; // use the expected errors estimated from the function values; // assuming Poisson statistics and not the observed errors (default is false).; opt.fUseEmpty = true; // use empty bins when fitting (default is false). If fExpErrors; 							 // is not set an arbitrary error = 1 is assigned to those bins.; opt.fErrors1 = true; // Set all measured errors to 1 (default is false).; opt.fCoordErrors = false; // When available coordinate errors are not used in the fit; // (default is true: the errors are used when they are available,; // e.g. fitting a TGraphErrors).; opt.fAsymErrors = false; // When available asymmetric errors are considered in the fit; // (default is true, the asymmetric errors are used when they are available,; // e.g. fitting a TGraphAsymmErrors).; ```. The `ROOT::Fit::DataRange` class supports defining multiple rectangular ranges in each dimension, and supports n-dimension.; The function `DataRange::AddRange(icoord,xmin,xmax)` adds a range in; the coordinate `icoord` with lower value `xmin` and upper value `xmax`:. ``` {.cpp}; ROOT::Fit::DataRange range;; range.AddRange(icoordinate, xmin, xmax);; ```. #### Using Un-Binned data. The unbinned data sets are represented with the `ROOT::Fit::UnBinData` class.; For creating un-binned data sets, a `ROOT::Fit::UnBinData` object, one has two possibilities:; 1. Copy the data inside `ROOT::Fit::UnBinData`. One can create an empty `UnBinData` object, iterate on the data and add the data point one by one, or directly create the `UnBinData`; object from a data iterator. In this case an input `ROOT::Fit::DataRange` object is passed in order to copy the data according to the give",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:36566,Availability,avail,available,36566,"es. For example, when fitting a `k`-dimensional histogram,; the independent variables **`X`** are the bin center coordinates and `Y` is the bin weight. The model function needs to be expressed as function of some unknown parameters. The fitting will find the best parameter value to describe; the observed data. We can use the ROOT **`TF1`** class, the parametric function class, to describe the model function. However the `ROOT::Fit::Fitter` class, to be independent of the ROOT *`Hist`* library,; takes as input a more general parametric function object, the interface (abstract) class `ROOT::Math::IParametricFunctionMultiDim`, which describe a generic one or multi-dimensional function; with parameters. This interface extends the abstract class `ROOT::Math::IBaseFunctionMultiDim`, with methods to set/retrieve parameter values and to evaluate the function given the; independent vector of values **`X`** and vector of parameters `P`.; More information about the different `ROOT::Math` function interfaces is available in the Mathematical Library chapter. An end-user can convert a **`TF1`** object in a `ROOT::Math::IParametricFunctionMultiDim`, using the wrapper class `ROOT::Math::WrapperMultiTF1`:. ``` {.cpp}; TF1 * f1 = new TF1(""f1"",""gaus"");; ROOT::Math::WrappedMultiTF1 fitFunction(f1, f1->GetNdim() );; ROOT::Fit::Fitter fitter;; fitter.SetFunction( fitFunction, false);; ```. When creating the wrapper, the parameter values stored in **`TF1`** will be copied in the `ROOT::Math::WrappedMultiTF1` object.; The function object representing the model function is given to the `ROOT::Fitter` class using the `Fitter::SetFunction` method. The user has also the possibility to provide a function object, which implements the derivatives of the function with respect; to the parameters.; This information might be useful for some types of fits. In this case he needs to provide the function object as a class deriving from the; `ROOT::Math::IParametricGradFunctionMultiDim` interface.; Note th",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:38680,Availability,toler,tolerance,38680,"ss `ROOT::Math::WrappedMultiTF1` implements also the gradient interface, using internally `TF1::GradientPar`,; which is based on numerical differentiation, apart for the case of linear functions (i.e. when `TF1::IsLinear()` is `true`).; The parameter derivatives of the model function can be useful to some minimization algorithms, such as Fumili.; However, in general is better to leave the minimization algorithm (e.g. Minuit) to compute the needed derivatives using its own customised; numerical differentiation algorithm.; In order to not provide to the fitter the parameter derivatives, we explicitly passed in `Fitter::SetFunction` a `false` value. ### Fit Configuration. The configuration of the fit is done via the `ROOT::Fit::FitConfig` class and its contained `ROOT::Fit::ParameterSettings` class.; These are the possible allowed fit configurations:. - setting the initial values of the parameters;; - setting the parameter step sizes;; - setting eventual parameter bounds;; - setting the minimizer library and the particular algorithm to use;; - setting different minimization options (print level, tolerance, max iterations, etc...); - setting the type of parameter errors to compute (parabolic error, Minos errors, re-normalize errors using fitted chi2 values). The initial parameter values can be set directly in the input model function object.; However, for setting parameter bounds and step sizes to values different than the automatically computed ones, one needs to use the `ROOT::Fit::ParameterSetting` class.; This example code will set the lower/upper bounds for the first parameter and a lower bound for the second parameter. ``` {.cpp}; fitter.SetFunction( fitFunction, false);; fitter.Config().ParSettings(0).SetLimits(0,1.E6);; fitter.Config().ParSettings(2).SetLowerLimit(0);; ```. Note that a `ROOT::Fit::ParameterSettings` objects exists for each fit parameter and it created by the `ROOT::Fit::FitConfig` class, after the model function has been set in the Fitter.; Only ",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:38748,Availability,error,errors,38748,"F1::IsLinear()` is `true`).; The parameter derivatives of the model function can be useful to some minimization algorithms, such as Fumili.; However, in general is better to leave the minimization algorithm (e.g. Minuit) to compute the needed derivatives using its own customised; numerical differentiation algorithm.; In order to not provide to the fitter the parameter derivatives, we explicitly passed in `Fitter::SetFunction` a `false` value. ### Fit Configuration. The configuration of the fit is done via the `ROOT::Fit::FitConfig` class and its contained `ROOT::Fit::ParameterSettings` class.; These are the possible allowed fit configurations:. - setting the initial values of the parameters;; - setting the parameter step sizes;; - setting eventual parameter bounds;; - setting the minimizer library and the particular algorithm to use;; - setting different minimization options (print level, tolerance, max iterations, etc...); - setting the type of parameter errors to compute (parabolic error, Minos errors, re-normalize errors using fitted chi2 values). The initial parameter values can be set directly in the input model function object.; However, for setting parameter bounds and step sizes to values different than the automatically computed ones, one needs to use the `ROOT::Fit::ParameterSetting` class.; This example code will set the lower/upper bounds for the first parameter and a lower bound for the second parameter. ``` {.cpp}; fitter.SetFunction( fitFunction, false);; fitter.Config().ParSettings(0).SetLimits(0,1.E6);; fitter.Config().ParSettings(2).SetLowerLimit(0);; ```. Note that a `ROOT::Fit::ParameterSettings` objects exists for each fit parameter and it created by the `ROOT::Fit::FitConfig` class, after the model function has been set in the Fitter.; Only when the function is set, the number of parameter is known and; automatically the `FitConfig` creates the corresponding `ParameterSetting` objects. When fitting, different minimizer can be used. The can be im",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:38777,Availability,error,error,38777,"F1::IsLinear()` is `true`).; The parameter derivatives of the model function can be useful to some minimization algorithms, such as Fumili.; However, in general is better to leave the minimization algorithm (e.g. Minuit) to compute the needed derivatives using its own customised; numerical differentiation algorithm.; In order to not provide to the fitter the parameter derivatives, we explicitly passed in `Fitter::SetFunction` a `false` value. ### Fit Configuration. The configuration of the fit is done via the `ROOT::Fit::FitConfig` class and its contained `ROOT::Fit::ParameterSettings` class.; These are the possible allowed fit configurations:. - setting the initial values of the parameters;; - setting the parameter step sizes;; - setting eventual parameter bounds;; - setting the minimizer library and the particular algorithm to use;; - setting different minimization options (print level, tolerance, max iterations, etc...); - setting the type of parameter errors to compute (parabolic error, Minos errors, re-normalize errors using fitted chi2 values). The initial parameter values can be set directly in the input model function object.; However, for setting parameter bounds and step sizes to values different than the automatically computed ones, one needs to use the `ROOT::Fit::ParameterSetting` class.; This example code will set the lower/upper bounds for the first parameter and a lower bound for the second parameter. ``` {.cpp}; fitter.SetFunction( fitFunction, false);; fitter.Config().ParSettings(0).SetLimits(0,1.E6);; fitter.Config().ParSettings(2).SetLowerLimit(0);; ```. Note that a `ROOT::Fit::ParameterSettings` objects exists for each fit parameter and it created by the `ROOT::Fit::FitConfig` class, after the model function has been set in the Fitter.; Only when the function is set, the number of parameter is known and; automatically the `FitConfig` creates the corresponding `ParameterSetting` objects. When fitting, different minimizer can be used. The can be im",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:38790,Availability,error,errors,38790,"F1::IsLinear()` is `true`).; The parameter derivatives of the model function can be useful to some minimization algorithms, such as Fumili.; However, in general is better to leave the minimization algorithm (e.g. Minuit) to compute the needed derivatives using its own customised; numerical differentiation algorithm.; In order to not provide to the fitter the parameter derivatives, we explicitly passed in `Fitter::SetFunction` a `false` value. ### Fit Configuration. The configuration of the fit is done via the `ROOT::Fit::FitConfig` class and its contained `ROOT::Fit::ParameterSettings` class.; These are the possible allowed fit configurations:. - setting the initial values of the parameters;; - setting the parameter step sizes;; - setting eventual parameter bounds;; - setting the minimizer library and the particular algorithm to use;; - setting different minimization options (print level, tolerance, max iterations, etc...); - setting the type of parameter errors to compute (parabolic error, Minos errors, re-normalize errors using fitted chi2 values). The initial parameter values can be set directly in the input model function object.; However, for setting parameter bounds and step sizes to values different than the automatically computed ones, one needs to use the `ROOT::Fit::ParameterSetting` class.; This example code will set the lower/upper bounds for the first parameter and a lower bound for the second parameter. ``` {.cpp}; fitter.SetFunction( fitFunction, false);; fitter.Config().ParSettings(0).SetLimits(0,1.E6);; fitter.Config().ParSettings(2).SetLowerLimit(0);; ```. Note that a `ROOT::Fit::ParameterSettings` objects exists for each fit parameter and it created by the `ROOT::Fit::FitConfig` class, after the model function has been set in the Fitter.; Only when the function is set, the number of parameter is known and; automatically the `FitConfig` creates the corresponding `ParameterSetting` objects. When fitting, different minimizer can be used. The can be im",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:38811,Availability,error,errors,38811,"F1::IsLinear()` is `true`).; The parameter derivatives of the model function can be useful to some minimization algorithms, such as Fumili.; However, in general is better to leave the minimization algorithm (e.g. Minuit) to compute the needed derivatives using its own customised; numerical differentiation algorithm.; In order to not provide to the fitter the parameter derivatives, we explicitly passed in `Fitter::SetFunction` a `false` value. ### Fit Configuration. The configuration of the fit is done via the `ROOT::Fit::FitConfig` class and its contained `ROOT::Fit::ParameterSettings` class.; These are the possible allowed fit configurations:. - setting the initial values of the parameters;; - setting the parameter step sizes;; - setting eventual parameter bounds;; - setting the minimizer library and the particular algorithm to use;; - setting different minimization options (print level, tolerance, max iterations, etc...); - setting the type of parameter errors to compute (parabolic error, Minos errors, re-normalize errors using fitted chi2 values). The initial parameter values can be set directly in the input model function object.; However, for setting parameter bounds and step sizes to values different than the automatically computed ones, one needs to use the `ROOT::Fit::ParameterSetting` class.; This example code will set the lower/upper bounds for the first parameter and a lower bound for the second parameter. ``` {.cpp}; fitter.SetFunction( fitFunction, false);; fitter.Config().ParSettings(0).SetLimits(0,1.E6);; fitter.Config().ParSettings(2).SetLowerLimit(0);; ```. Note that a `ROOT::Fit::ParameterSettings` objects exists for each fit parameter and it created by the `ROOT::Fit::FitConfig` class, after the model function has been set in the Fitter.; Only when the function is set, the number of parameter is known and; automatically the `FitConfig` creates the corresponding `ParameterSetting` objects. When fitting, different minimizer can be used. The can be im",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:40276,Availability,avail,available,40276,"fitter.Config().ParSettings(2).SetLowerLimit(0);; ```. Note that a `ROOT::Fit::ParameterSettings` objects exists for each fit parameter and it created by the `ROOT::Fit::FitConfig` class, after the model function has been set in the Fitter.; Only when the function is set, the number of parameter is known and; automatically the `FitConfig` creates the corresponding `ParameterSetting` objects. When fitting, different minimizer can be used. The can be implemented in different libraries and loaded ar run time by the plug-in manager system of ROOT.; Each different minimizer (e.g. *Minuit, Minuit2, Fumili,* etc.) consists of a different implementation of the `ROOT::Math::Minimizer` interface.; Within the same minimizer, thus within the same class implementing the `Minimizer` interface, different algorithms can exist.; For example in the case of Minuit, we have *Migrad, Simplex* or *Minimize*. The minimizer and its corresponding algorithm, when available,; can be set by using the function `FitConfig::SetMinimizer(""minimizerName"")` or by using directly the `ROOT:Math::MinimizerOptions` class. If the requested minimizer is not available in ROOT, the default one is used. The default minimizer type and algorithm can be specified by using the; static function `ROOT::Math::MinimizerOptions::SetDefaultMinimizer(""minimizerName"")`. ### Minimizer Libraries and Algorithms. The list of available minimizer libraries currently available in ROOT, with their corresponding available algorithms is the following one.; Some minimizers (e.g. *Minuit*) contain several algorithms that the user can; choose. Others are based on a single algorithm (e.g. *Fumili*). - **`Minuit`** (library *libMinuit*). Old version of Minuit, based on the `TMinuit` class. The list of possible algorithms are:; - *`Migrad`* (default one); 	 - *`Simplex`*; - *`Minimize`* (it is a combination of Migrad and Simplex); - *`MigradImproved`*; 	 - *`Scan`*; 	 - *`Seek`*. - **`Minuit2`** (library *libMinuit2*). New C++ version ",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:40460,Availability,avail,available,40460,"it created by the `ROOT::Fit::FitConfig` class, after the model function has been set in the Fitter.; Only when the function is set, the number of parameter is known and; automatically the `FitConfig` creates the corresponding `ParameterSetting` objects. When fitting, different minimizer can be used. The can be implemented in different libraries and loaded ar run time by the plug-in manager system of ROOT.; Each different minimizer (e.g. *Minuit, Minuit2, Fumili,* etc.) consists of a different implementation of the `ROOT::Math::Minimizer` interface.; Within the same minimizer, thus within the same class implementing the `Minimizer` interface, different algorithms can exist.; For example in the case of Minuit, we have *Migrad, Simplex* or *Minimize*. The minimizer and its corresponding algorithm, when available,; can be set by using the function `FitConfig::SetMinimizer(""minimizerName"")` or by using directly the `ROOT:Math::MinimizerOptions` class. If the requested minimizer is not available in ROOT, the default one is used. The default minimizer type and algorithm can be specified by using the; static function `ROOT::Math::MinimizerOptions::SetDefaultMinimizer(""minimizerName"")`. ### Minimizer Libraries and Algorithms. The list of available minimizer libraries currently available in ROOT, with their corresponding available algorithms is the following one.; Some minimizers (e.g. *Minuit*) contain several algorithms that the user can; choose. Others are based on a single algorithm (e.g. *Fumili*). - **`Minuit`** (library *libMinuit*). Old version of Minuit, based on the `TMinuit` class. The list of possible algorithms are:; - *`Migrad`* (default one); 	 - *`Simplex`*; - *`Minimize`* (it is a combination of Migrad and Simplex); - *`MigradImproved`*; 	 - *`Scan`*; 	 - *`Seek`*. - **`Minuit2`** (library *libMinuit2*). New C++ version of Minuit. The list of possible algorithm is :; - *`Migrad`* (default); - *`Simplex`*; 	 - *`Minimize`*; 	 - *`Scan`*; 	 - *`Fumili`* . This",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:40714,Availability,avail,available,40714,"can be implemented in different libraries and loaded ar run time by the plug-in manager system of ROOT.; Each different minimizer (e.g. *Minuit, Minuit2, Fumili,* etc.) consists of a different implementation of the `ROOT::Math::Minimizer` interface.; Within the same minimizer, thus within the same class implementing the `Minimizer` interface, different algorithms can exist.; For example in the case of Minuit, we have *Migrad, Simplex* or *Minimize*. The minimizer and its corresponding algorithm, when available,; can be set by using the function `FitConfig::SetMinimizer(""minimizerName"")` or by using directly the `ROOT:Math::MinimizerOptions` class. If the requested minimizer is not available in ROOT, the default one is used. The default minimizer type and algorithm can be specified by using the; static function `ROOT::Math::MinimizerOptions::SetDefaultMinimizer(""minimizerName"")`. ### Minimizer Libraries and Algorithms. The list of available minimizer libraries currently available in ROOT, with their corresponding available algorithms is the following one.; Some minimizers (e.g. *Minuit*) contain several algorithms that the user can; choose. Others are based on a single algorithm (e.g. *Fumili*). - **`Minuit`** (library *libMinuit*). Old version of Minuit, based on the `TMinuit` class. The list of possible algorithms are:; - *`Migrad`* (default one); 	 - *`Simplex`*; - *`Minimize`* (it is a combination of Migrad and Simplex); - *`MigradImproved`*; 	 - *`Scan`*; 	 - *`Seek`*. - **`Minuit2`** (library *libMinuit2*). New C++ version of Minuit. The list of possible algorithm is :; - *`Migrad`* (default); - *`Simplex`*; 	 - *`Minimize`*; 	 - *`Scan`*; 	 - *`Fumili`* . This is the same algorithm of `TFumili`, but implemented in the Minuit2 library. - **`Fumili`**. Implement a dedicated minimization algorithm for least-square and likelihood fits. It has requirements on the type of method function to be used.; No specific algorithm exists. - **`GSLMultiMin`** (library *libMath",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:40754,Availability,avail,available,40754,"can be implemented in different libraries and loaded ar run time by the plug-in manager system of ROOT.; Each different minimizer (e.g. *Minuit, Minuit2, Fumili,* etc.) consists of a different implementation of the `ROOT::Math::Minimizer` interface.; Within the same minimizer, thus within the same class implementing the `Minimizer` interface, different algorithms can exist.; For example in the case of Minuit, we have *Migrad, Simplex* or *Minimize*. The minimizer and its corresponding algorithm, when available,; can be set by using the function `FitConfig::SetMinimizer(""minimizerName"")` or by using directly the `ROOT:Math::MinimizerOptions` class. If the requested minimizer is not available in ROOT, the default one is used. The default minimizer type and algorithm can be specified by using the; static function `ROOT::Math::MinimizerOptions::SetDefaultMinimizer(""minimizerName"")`. ### Minimizer Libraries and Algorithms. The list of available minimizer libraries currently available in ROOT, with their corresponding available algorithms is the following one.; Some minimizers (e.g. *Minuit*) contain several algorithms that the user can; choose. Others are based on a single algorithm (e.g. *Fumili*). - **`Minuit`** (library *libMinuit*). Old version of Minuit, based on the `TMinuit` class. The list of possible algorithms are:; - *`Migrad`* (default one); 	 - *`Simplex`*; - *`Minimize`* (it is a combination of Migrad and Simplex); - *`MigradImproved`*; 	 - *`Scan`*; 	 - *`Seek`*. - **`Minuit2`** (library *libMinuit2*). New C++ version of Minuit. The list of possible algorithm is :; - *`Migrad`* (default); - *`Simplex`*; 	 - *`Minimize`*; 	 - *`Scan`*; 	 - *`Fumili`* . This is the same algorithm of `TFumili`, but implemented in the Minuit2 library. - **`Fumili`**. Implement a dedicated minimization algorithm for least-square and likelihood fits. It has requirements on the type of method function to be used.; No specific algorithm exists. - **`GSLMultiMin`** (library *libMath",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:40798,Availability,avail,available,40798,"can be implemented in different libraries and loaded ar run time by the plug-in manager system of ROOT.; Each different minimizer (e.g. *Minuit, Minuit2, Fumili,* etc.) consists of a different implementation of the `ROOT::Math::Minimizer` interface.; Within the same minimizer, thus within the same class implementing the `Minimizer` interface, different algorithms can exist.; For example in the case of Minuit, we have *Migrad, Simplex* or *Minimize*. The minimizer and its corresponding algorithm, when available,; can be set by using the function `FitConfig::SetMinimizer(""minimizerName"")` or by using directly the `ROOT:Math::MinimizerOptions` class. If the requested minimizer is not available in ROOT, the default one is used. The default minimizer type and algorithm can be specified by using the; static function `ROOT::Math::MinimizerOptions::SetDefaultMinimizer(""minimizerName"")`. ### Minimizer Libraries and Algorithms. The list of available minimizer libraries currently available in ROOT, with their corresponding available algorithms is the following one.; Some minimizers (e.g. *Minuit*) contain several algorithms that the user can; choose. Others are based on a single algorithm (e.g. *Fumili*). - **`Minuit`** (library *libMinuit*). Old version of Minuit, based on the `TMinuit` class. The list of possible algorithms are:; - *`Migrad`* (default one); 	 - *`Simplex`*; - *`Minimize`* (it is a combination of Migrad and Simplex); - *`MigradImproved`*; 	 - *`Scan`*; 	 - *`Seek`*. - **`Minuit2`** (library *libMinuit2*). New C++ version of Minuit. The list of possible algorithm is :; - *`Migrad`* (default); - *`Simplex`*; 	 - *`Minimize`*; 	 - *`Scan`*; 	 - *`Fumili`* . This is the same algorithm of `TFumili`, but implemented in the Minuit2 library. - **`Fumili`**. Implement a dedicated minimization algorithm for least-square and likelihood fits. It has requirements on the type of method function to be used.; No specific algorithm exists. - **`GSLMultiMin`** (library *libMath",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:41890,Availability,avail,available,41890,"ossible algorithms are:; - *`Migrad`* (default one); 	 - *`Simplex`*; - *`Minimize`* (it is a combination of Migrad and Simplex); - *`MigradImproved`*; 	 - *`Scan`*; 	 - *`Seek`*. - **`Minuit2`** (library *libMinuit2*). New C++ version of Minuit. The list of possible algorithm is :; - *`Migrad`* (default); - *`Simplex`*; 	 - *`Minimize`*; 	 - *`Scan`*; 	 - *`Fumili`* . This is the same algorithm of `TFumili`, but implemented in the Minuit2 library. - **`Fumili`**. Implement a dedicated minimization algorithm for least-square and likelihood fits. It has requirements on the type of method function to be used.; No specific algorithm exists. - **`GSLMultiMin`** (library *libMathMore*). Minimizer based on the Multidimensional Minimization routines of the Gnu Scientific Library (GSL). The list of available algorithms is; 	- *`BFGS2`* (default) : second version of the vector Broyden-Fletcher-Goldfarb-Shanno (BFGS) algorithm;; 	- *`BFGS`* : old version of the vector Broyden-Fletcher-Goldfarb-Shanno (BFGS) algorithm;; 	- *`ConjugateFR`* : Fletcher-Reeves conjugate gradient algorithm;; 	- *`ConjugatePR`* : Polak-Ribiere conjugate gradient algorithm;; 	- *`SteepestDescent`*: steepest descent algorithm;. - **`GSLMultiFit`** (library *libMathMore*). Minimizer based on the Non-Linear Least-Square routines of GSL. This minimizer can be used only for least-square fits. - **`GSLSimAn`** (library *libMathMore*). Minimizer based on simulated annealing. - **`Genetic`** (library *libGenetic*). Genetic minimizer based on an algorithm implemented in the *TMVA* package. Each minimizer can be configured using the `ROOT::Math::MinimizerOptions` class. The list of possible option that can be set are:. * *Minimizer type* (`MinimizerOptions::SetMinimizerType(const char *)`) .; * *Minimizer algorithm* (`MinimizerOptions::SetMinimizerAlgorithm(const char *)`).; * *Print Level* (`MinimizerOptions::SetPrintLevel(int )`) to set the verbose printing level (default is 0).; * *Tolerance* (`MinimizerOpt",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:43118,Availability,toler,tolerance,43118,"hm;; 	- *`ConjugateFR`* : Fletcher-Reeves conjugate gradient algorithm;; 	- *`ConjugatePR`* : Polak-Ribiere conjugate gradient algorithm;; 	- *`SteepestDescent`*: steepest descent algorithm;. - **`GSLMultiFit`** (library *libMathMore*). Minimizer based on the Non-Linear Least-Square routines of GSL. This minimizer can be used only for least-square fits. - **`GSLSimAn`** (library *libMathMore*). Minimizer based on simulated annealing. - **`Genetic`** (library *libGenetic*). Genetic minimizer based on an algorithm implemented in the *TMVA* package. Each minimizer can be configured using the `ROOT::Math::MinimizerOptions` class. The list of possible option that can be set are:. * *Minimizer type* (`MinimizerOptions::SetMinimizerType(const char *)`) .; * *Minimizer algorithm* (`MinimizerOptions::SetMinimizerAlgorithm(const char *)`).; * *Print Level* (`MinimizerOptions::SetPrintLevel(int )`) to set the verbose printing level (default is 0).; * *Tolerance* (`MinimizerOptions::SetTolerance(double )`) tolerance used to control the iterations.; * *Maximum number of function calls* (`MinimizerOptions::SetMaxFunctionCalls(int )`).; * *Maximum number of iterations* (`MinimizerOptions::SetMaxIterations(int )`). Note that this is not used by *Minuit*; * *FCN Upper value for Error Definition* (`MinimizerOptions::SetErrorDef(double )`). Value in the minimization function used to compute the parameter errors.; The default is to get the uncertainties at the 68% CL is a value of 1 for a chi-squared function minimization and 0.5 for a log-likelihood function.; * *Strategy* (`MinimizerOptions::SetStrategy(int )`), minimization strategy used. For each minimization strategy *Minuit* uses different configuration parameters; (e.g. different requirements in computing derivatives, computing full Hessian (strategy = 2) or an approximate version. The default is a value of 1. In this case the full Hessian matrix; is computed only after the minimization.; * *Precision* (`MinimizerOptions::SetPrec",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:43517,Availability,error,errors,43517,"ry *libMathMore*). Minimizer based on simulated annealing. - **`Genetic`** (library *libGenetic*). Genetic minimizer based on an algorithm implemented in the *TMVA* package. Each minimizer can be configured using the `ROOT::Math::MinimizerOptions` class. The list of possible option that can be set are:. * *Minimizer type* (`MinimizerOptions::SetMinimizerType(const char *)`) .; * *Minimizer algorithm* (`MinimizerOptions::SetMinimizerAlgorithm(const char *)`).; * *Print Level* (`MinimizerOptions::SetPrintLevel(int )`) to set the verbose printing level (default is 0).; * *Tolerance* (`MinimizerOptions::SetTolerance(double )`) tolerance used to control the iterations.; * *Maximum number of function calls* (`MinimizerOptions::SetMaxFunctionCalls(int )`).; * *Maximum number of iterations* (`MinimizerOptions::SetMaxIterations(int )`). Note that this is not used by *Minuit*; * *FCN Upper value for Error Definition* (`MinimizerOptions::SetErrorDef(double )`). Value in the minimization function used to compute the parameter errors.; The default is to get the uncertainties at the 68% CL is a value of 1 for a chi-squared function minimization and 0.5 for a log-likelihood function.; * *Strategy* (`MinimizerOptions::SetStrategy(int )`), minimization strategy used. For each minimization strategy *Minuit* uses different configuration parameters; (e.g. different requirements in computing derivatives, computing full Hessian (strategy = 2) or an approximate version. The default is a value of 1. In this case the full Hessian matrix; is computed only after the minimization.; * *Precision* (`MinimizerOptions::SetPrecision(double )`). Precision value in the evaluation of the minimization function. Default is numerical double precision. Note that not all the options are implemented by all the minimizers.; For example in *Minuit* is possible to set the maximum number of function calls, but not the maximum number of iterations. The Strategy and the Precision options apply instead only for *Mi",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:45278,Availability,avail,available,45278,"ote that not all the options are implemented by all the minimizers.; For example in *Minuit* is possible to set the maximum number of function calls, but not the maximum number of iterations. The Strategy and the Precision options apply instead only for *Minuit* (and; *Minuit2*). The class supports also setting global default values for the options, by using the static functions `MinimizerOptions::SetDefault...` (for example `MinimizerOptions::SetDefaultPrintLevel(int )`). The; static functions can be also used to set the minimizer options when using `TH1::Fit` or `TGraph::Fit`.; The list of the current option values can be inspected by using `MinimizerOptions::Print`.; ```{.cpp}; ROOT::Math::MinimizerOptions() opt;; // print the default minimizer option values; opt.Print();; ```. In addition it is possible to provide extra options which might apply for a particular minimizer `MinimizerOptions::SetExtraOptions(const IOptions & )`.; See the documentation of the particular minimizer to use for the list of possible additional options available. ### Performing the Fit. Here we have now all the required input ingredients for the fit, the data and the function to fit.; Depending on these we have now several different way to perform the fit, using the corresponding methods of the; `ROOT::Fit::Fitter` class and depending on the type of input data. #### Available fit methods. * **Least-square fit**: `Fitter::LeastSquare(const BinData & )` or `Fitter::Fit(const Bindata &)`. It requires the user to pass a `BinData` object. It should be used when the data values follow a; Gaussian distribution. This fit method is implemented using the class `ROOT::Fit::Chi2FCN`.; * **Binned Likelihood fit** : `Fitter::LikelihoodFit(const Bindata & )`. The user needs to pass a `BinData` object. It should be used when the data values follow a Poisson or a multinomial; distribution. The Poisson case (extended fit) is the default and in this case the function normalization is also fit to the data. T",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:49803,Availability,error,errors,49803,"ace class extending; the `ROOT::Math::IBaseFunctionMultiDim` with some extra functionality which can be used when fitting.; This extra functionality is required by dedicated fitting algorithms like *Fumili* or *GSLMultiFit*.; ``` {.cpp}; bool Fitter::SetFCN(const ROOT::Math::FitMethodFunction & f,; const double * initialParameters = 0, unsigned int dataSize=0); ```. * A old-Minuit like FCN interface (i.e. a free function with the signature `fcn(int &npar, double *gin, double &f, double *u, int flag)`.; ``` {.cpp}; typedef void(* MinuitFCN)(int &npar, double *gin, double &f, double *u, int flag); bool Fitter::SetFCN(MinuitFCN fcn, int npar,; const double * initialParameters = 0,; unsigned int dataSize=0, bool isChi2Fit = false); ```. ### Fit Result. The result of the fit is contained in the `ROOT::Fit::Result` object. A reference to the result object is obtained with the function; `Fitter::Result()`.; The `ROOT::Fit::FitResult` class provides an API for retrieving parameter values, errors, covariance and correlation matrix from the fit,; minimum chi2/likelihood values, etc... A `FitResult::Print` method is also available to print the result of the fit. The class has a self-explanatory API so, see its reference documentation for the possible information available after the fit. One extra functionality offered by `ROOT::Fit::FitResult` is the possibility to compute the confidence intervals of the function after the fit.; The function `ROOT::Fit::FitResult::GetConfidenceInterval` given an input data sets (e.g. a `BinData` object) and a confidence level value (e.g. 68%); computes the lower/upper band values of the model function at the given data points. ### TFitResult. `TFitResult` is a class deriving from `ROOT::Fit::Result` and providing in addition some convenient methods to return a; covariance or correlation matrix as a `TMatrixDSym` object. In addition `TFitResult` derives from `TNamed` and can be conveniently; stored in a file. When fitting an histogram ( a **`TH1",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:49935,Availability,avail,available,49935,"xtra functionality is required by dedicated fitting algorithms like *Fumili* or *GSLMultiFit*.; ``` {.cpp}; bool Fitter::SetFCN(const ROOT::Math::FitMethodFunction & f,; const double * initialParameters = 0, unsigned int dataSize=0); ```. * A old-Minuit like FCN interface (i.e. a free function with the signature `fcn(int &npar, double *gin, double &f, double *u, int flag)`.; ``` {.cpp}; typedef void(* MinuitFCN)(int &npar, double *gin, double &f, double *u, int flag); bool Fitter::SetFCN(MinuitFCN fcn, int npar,; const double * initialParameters = 0,; unsigned int dataSize=0, bool isChi2Fit = false); ```. ### Fit Result. The result of the fit is contained in the `ROOT::Fit::Result` object. A reference to the result object is obtained with the function; `Fitter::Result()`.; The `ROOT::Fit::FitResult` class provides an API for retrieving parameter values, errors, covariance and correlation matrix from the fit,; minimum chi2/likelihood values, etc... A `FitResult::Print` method is also available to print the result of the fit. The class has a self-explanatory API so, see its reference documentation for the possible information available after the fit. One extra functionality offered by `ROOT::Fit::FitResult` is the possibility to compute the confidence intervals of the function after the fit.; The function `ROOT::Fit::FitResult::GetConfidenceInterval` given an input data sets (e.g. a `BinData` object) and a confidence level value (e.g. 68%); computes the lower/upper band values of the model function at the given data points. ### TFitResult. `TFitResult` is a class deriving from `ROOT::Fit::Result` and providing in addition some convenient methods to return a; covariance or correlation matrix as a `TMatrixDSym` object. In addition `TFitResult` derives from `TNamed` and can be conveniently; stored in a file. When fitting an histogram ( a **`TH1`** object) or a graph (a `TGraph` object) it is possible to return a `TFitResult` via the `TFitResultPtr` object,; which behaves",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:50079,Availability,avail,available,50079,"cpp}; bool Fitter::SetFCN(const ROOT::Math::FitMethodFunction & f,; const double * initialParameters = 0, unsigned int dataSize=0); ```. * A old-Minuit like FCN interface (i.e. a free function with the signature `fcn(int &npar, double *gin, double &f, double *u, int flag)`.; ``` {.cpp}; typedef void(* MinuitFCN)(int &npar, double *gin, double &f, double *u, int flag); bool Fitter::SetFCN(MinuitFCN fcn, int npar,; const double * initialParameters = 0,; unsigned int dataSize=0, bool isChi2Fit = false); ```. ### Fit Result. The result of the fit is contained in the `ROOT::Fit::Result` object. A reference to the result object is obtained with the function; `Fitter::Result()`.; The `ROOT::Fit::FitResult` class provides an API for retrieving parameter values, errors, covariance and correlation matrix from the fit,; minimum chi2/likelihood values, etc... A `FitResult::Print` method is also available to print the result of the fit. The class has a self-explanatory API so, see its reference documentation for the possible information available after the fit. One extra functionality offered by `ROOT::Fit::FitResult` is the possibility to compute the confidence intervals of the function after the fit.; The function `ROOT::Fit::FitResult::GetConfidenceInterval` given an input data sets (e.g. a `BinData` object) and a confidence level value (e.g. 68%); computes the lower/upper band values of the model function at the given data points. ### TFitResult. `TFitResult` is a class deriving from `ROOT::Fit::Result` and providing in addition some convenient methods to return a; covariance or correlation matrix as a `TMatrixDSym` object. In addition `TFitResult` derives from `TNamed` and can be conveniently; stored in a file. When fitting an histogram ( a **`TH1`** object) or a graph (a `TGraph` object) it is possible to return a `TFitResult` via the `TFitResultPtr` object,; which behaves as a smart pointer to a `TFitResult`.; `TFitResultPtr` is the return object by `TH1::Fit` or `TGraph::",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:51783,Availability,error,error,51783," addition `TFitResult` derives from `TNamed` and can be conveniently; stored in a file. When fitting an histogram ( a **`TH1`** object) or a graph (a `TGraph` object) it is possible to return a `TFitResult` via the `TFitResultPtr` object,; which behaves as a smart pointer to a `TFitResult`.; `TFitResultPtr` is the return object by `TH1::Fit` or `TGraph::Fit`.; By default the TFitResultPtr contains only the status of the fit and can be obtained by an automatic conversion of the TFitResultPtr to an integer. If the fit option *`S`* is instead used, `TFitResultPtr` contains the `TFitResult` and behaves as a smart; pointer to it. This is an example:. ``` {.cpp}; int fitStatus = hist->Fit(myFunction); // TFitResultPtr contains only the fit status. TFitResultPtr r = hist->Fit(myFunction,""S""); // TFitResultPtr contains the TFitResult; TMatrixDSym cov = r->GetCovarianceMatrix(); // to access the covariance matrix; Double_t chi2 = r->Chi2(); // to retrieve the fit chi2; Double_t par0 = r->Parameter(0); // retrieve the value for the parameter 0; Double_t err0 = r->ParError(0); // retrieve the error for the parameter 0; r->Print(""V""); // print full information of fit including covariance matrix; r->Write(); // store the result in a file; ```. ## The Minimization packages. As explained before various minimization packages can be used when fitting in ROOT.; We have seen before how to configure the `Fitter` class to use different minimization packages; and different minimization options.; When using the `Fit` method the minimization package (and its options) can be selected using the; static methods of the `ROOT::Math::MinimizerOptions` class.; For example to select `Minuit2` instead of `Minuit` for fitting an histogram do:. ``` {.cpp}; ROOT::Math::MinimizerOptions::SetDefaultMinimizer(""Minuit2"");; // fit the histogram histo with the gaussian pre-defined function; histo->Fit(""gaus"");; ```. In the following we will give some brief description of the minimization packages.; The packa",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:56025,Availability,down,down,56025,"lti parameter FORTRAN function to; which one must give the generic name `FCN`. In the ROOT; implementation, the function `FCN` is defined via the `Minuit`; `SetFCN` member function when an histogram fitting is invoked. The; value of `FCN` will in general depend on one or more variable; parameters. ### The Transformation of Limited Parameters. For variable parameters with limits, `Minuit` uses the following; transformation:. `Pint = arcsin(2((Pext-a)/(b-a))-1) `. `Pext = a+((b-a)/(2))(sinPint+1)`. so that the internal value `Pint` can take on any value, while the; external value Pext can take on values only between the lower limit a; and the ext upper limit b. Since the transformation is necessarily; non-linear, it would transform a nice linear problem into a nasty; non-linear one, which is the reason why limits should be avoided if; not necessary. In addition, the transformation does require some; computer time, so it slows down the computation a little bit, and more; importantly, it introduces additional numerical inaccuracy into the; problem in addition to what is introduced in the numerical calculation; of the FCN value. The effects of non-linearity and numerical round off; both become more important as the external value gets closer to one of; the limits (expressed as the distance to nearest limit divided by; distance between limits). The user must therefore be aware of the fact; that, for example, if they put limits of (0, 1010) on a parameter, then; the values 0.0 and 1. 0 will be indistinguishable to the accuracy of; most machines. The transformation also affects the parameter error matrix, of course,; so Minuit does a transformation of the error matrix (and the; ''parabolic'' parameter errors) when there are parameter limits. Users; should however realize that the transformation is only a linear; approximation, and that it cannot give a meaningful result if one or; more parameters is very close to a limit, where; $\frac{\partial Pext}{\partial Pint} \neq 0$.",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:56698,Availability,error,error,56698,"t b. Since the transformation is necessarily; non-linear, it would transform a nice linear problem into a nasty; non-linear one, which is the reason why limits should be avoided if; not necessary. In addition, the transformation does require some; computer time, so it slows down the computation a little bit, and more; importantly, it introduces additional numerical inaccuracy into the; problem in addition to what is introduced in the numerical calculation; of the FCN value. The effects of non-linearity and numerical round off; both become more important as the external value gets closer to one of; the limits (expressed as the distance to nearest limit divided by; distance between limits). The user must therefore be aware of the fact; that, for example, if they put limits of (0, 1010) on a parameter, then; the values 0.0 and 1. 0 will be indistinguishable to the accuracy of; most machines. The transformation also affects the parameter error matrix, of course,; so Minuit does a transformation of the error matrix (and the; ''parabolic'' parameter errors) when there are parameter limits. Users; should however realize that the transformation is only a linear; approximation, and that it cannot give a meaningful result if one or; more parameters is very close to a limit, where; $\frac{\partial Pext}{\partial Pint} \neq 0$. Therefore, it is; recommended that:. - Limits on variable parameters should be used only when needed in; order to prevent the parameter from taking on unphysical values. - When a satisfactory minimum has been found using limits, the; limits should then be removed if possible, in order to perform or; re-perform the error analysis without limits. ### How to Get the Right Answer from Minuit. `Minuit` offers the user a choice of several minimization algorithms.; The `MIGRAD` algorithm is in general the best minimized for nearly all; functions. It is a variable-metric method with inexact line search, a; stable metric updating scheme, and checks for positive-de",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:56763,Availability,error,error,56763,"t b. Since the transformation is necessarily; non-linear, it would transform a nice linear problem into a nasty; non-linear one, which is the reason why limits should be avoided if; not necessary. In addition, the transformation does require some; computer time, so it slows down the computation a little bit, and more; importantly, it introduces additional numerical inaccuracy into the; problem in addition to what is introduced in the numerical calculation; of the FCN value. The effects of non-linearity and numerical round off; both become more important as the external value gets closer to one of; the limits (expressed as the distance to nearest limit divided by; distance between limits). The user must therefore be aware of the fact; that, for example, if they put limits of (0, 1010) on a parameter, then; the values 0.0 and 1. 0 will be indistinguishable to the accuracy of; most machines. The transformation also affects the parameter error matrix, of course,; so Minuit does a transformation of the error matrix (and the; ''parabolic'' parameter errors) when there are parameter limits. Users; should however realize that the transformation is only a linear; approximation, and that it cannot give a meaningful result if one or; more parameters is very close to a limit, where; $\frac{\partial Pext}{\partial Pint} \neq 0$. Therefore, it is; recommended that:. - Limits on variable parameters should be used only when needed in; order to prevent the parameter from taking on unphysical values. - When a satisfactory minimum has been found using limits, the; limits should then be removed if possible, in order to perform or; re-perform the error analysis without limits. ### How to Get the Right Answer from Minuit. `Minuit` offers the user a choice of several minimization algorithms.; The `MIGRAD` algorithm is in general the best minimized for nearly all; functions. It is a variable-metric method with inexact line search, a; stable metric updating scheme, and checks for positive-de",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:56810,Availability,error,errors,56810,"t b. Since the transformation is necessarily; non-linear, it would transform a nice linear problem into a nasty; non-linear one, which is the reason why limits should be avoided if; not necessary. In addition, the transformation does require some; computer time, so it slows down the computation a little bit, and more; importantly, it introduces additional numerical inaccuracy into the; problem in addition to what is introduced in the numerical calculation; of the FCN value. The effects of non-linearity and numerical round off; both become more important as the external value gets closer to one of; the limits (expressed as the distance to nearest limit divided by; distance between limits). The user must therefore be aware of the fact; that, for example, if they put limits of (0, 1010) on a parameter, then; the values 0.0 and 1. 0 will be indistinguishable to the accuracy of; most machines. The transformation also affects the parameter error matrix, of course,; so Minuit does a transformation of the error matrix (and the; ''parabolic'' parameter errors) when there are parameter limits. Users; should however realize that the transformation is only a linear; approximation, and that it cannot give a meaningful result if one or; more parameters is very close to a limit, where; $\frac{\partial Pext}{\partial Pint} \neq 0$. Therefore, it is; recommended that:. - Limits on variable parameters should be used only when needed in; order to prevent the parameter from taking on unphysical values. - When a satisfactory minimum has been found using limits, the; limits should then be removed if possible, in order to perform or; re-perform the error analysis without limits. ### How to Get the Right Answer from Minuit. `Minuit` offers the user a choice of several minimization algorithms.; The `MIGRAD` algorithm is in general the best minimized for nearly all; functions. It is a variable-metric method with inexact line search, a; stable metric updating scheme, and checks for positive-de",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:57404,Availability,error,error,57404,"o one of; the limits (expressed as the distance to nearest limit divided by; distance between limits). The user must therefore be aware of the fact; that, for example, if they put limits of (0, 1010) on a parameter, then; the values 0.0 and 1. 0 will be indistinguishable to the accuracy of; most machines. The transformation also affects the parameter error matrix, of course,; so Minuit does a transformation of the error matrix (and the; ''parabolic'' parameter errors) when there are parameter limits. Users; should however realize that the transformation is only a linear; approximation, and that it cannot give a meaningful result if one or; more parameters is very close to a limit, where; $\frac{\partial Pext}{\partial Pint} \neq 0$. Therefore, it is; recommended that:. - Limits on variable parameters should be used only when needed in; order to prevent the parameter from taking on unphysical values. - When a satisfactory minimum has been found using limits, the; limits should then be removed if possible, in order to perform or; re-perform the error analysis without limits. ### How to Get the Right Answer from Minuit. `Minuit` offers the user a choice of several minimization algorithms.; The `MIGRAD` algorithm is in general the best minimized for nearly all; functions. It is a variable-metric method with inexact line search, a; stable metric updating scheme, and checks for positive-definiteness.; Its main weakness is that it depends heavily on knowledge of the first; derivatives, and fails miserably if they are very inaccurate. If parameter limits are needed, in spite of the side effects, then the; user should be aware of the following techniques to alleviate problems; caused by limits:. #### Getting the Right Minimum with Limits. If MIGRAD converges normally to a point where no parameter is near one; of its limits, then the existence of limits has probably not prevented; `Minuit` from finding the right minimum. On the other hand, if one or; more parameters is near it",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:59295,Availability,error,error,59295,"if one or; more parameters is near its limit at the minimum, this may be because; the true minimum is indeed at a limit, or it may be because the; minimized has become ''blocked'' at a limit. This may normally happen; only if the parameter is so close to a limit (internal value at an odd; multiple of $\pm \frac{\pi}{2}$ that `Minuit` prints a warning to this; effect when it prints the parameter values. The minimized can become; blocked at a limit, because at a limit the derivative seen by the; minimized $\frac{\partial F}{\partial Pint}$ is zero no matter what the real; derivative $\frac{\partial F}{\partial Pext}$ is. $$; \left(\frac{\partial F}{\partial Pint}\right) =; \left(\frac{\partial F}{\partial Pext}\right); \left(\frac{\partial Pext}{\partial Pint}\right) =; \left(\frac{\partial F}{\partial Pext}\right) = 0; $$. #### Getting the Right Parameter Errors with Limits. In the best case, where the minimum is far from any limits, `Minuit`; will correctly transform the error matrix, and the parameter errors it; reports should be accurate and very close to those you would have got; without limits. In other cases (which should be more common, since; otherwise you would not need limits), the very meaning of parameter; errors becomes problematic. Mathematically, since the limit is an; absolute constraint on the parameter, a parameter at its limit has no; error, at least in one direction. The error matrix, which can assign; only symmetric errors, then becomes essentially meaningless. #### Interpretation of Parameter Errors. There are two kinds of problems that can arise: the reliability of; `Minuit`'s error estimates, and their statistical interpretation,; assuming they are accurate. #### Statistical Interpretation. For discussion of basic concepts, such as the meaning of the elements; of the error matrix, or setting of exact confidence levels see the; articles:. - F.James. Determining the statistical Significance of experimental; Results. Technical Report DD/81/02 and ",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:59327,Availability,error,errors,59327,"if one or; more parameters is near its limit at the minimum, this may be because; the true minimum is indeed at a limit, or it may be because the; minimized has become ''blocked'' at a limit. This may normally happen; only if the parameter is so close to a limit (internal value at an odd; multiple of $\pm \frac{\pi}{2}$ that `Minuit` prints a warning to this; effect when it prints the parameter values. The minimized can become; blocked at a limit, because at a limit the derivative seen by the; minimized $\frac{\partial F}{\partial Pint}$ is zero no matter what the real; derivative $\frac{\partial F}{\partial Pext}$ is. $$; \left(\frac{\partial F}{\partial Pint}\right) =; \left(\frac{\partial F}{\partial Pext}\right); \left(\frac{\partial Pext}{\partial Pint}\right) =; \left(\frac{\partial F}{\partial Pext}\right) = 0; $$. #### Getting the Right Parameter Errors with Limits. In the best case, where the minimum is far from any limits, `Minuit`; will correctly transform the error matrix, and the parameter errors it; reports should be accurate and very close to those you would have got; without limits. In other cases (which should be more common, since; otherwise you would not need limits), the very meaning of parameter; errors becomes problematic. Mathematically, since the limit is an; absolute constraint on the parameter, a parameter at its limit has no; error, at least in one direction. The error matrix, which can assign; only symmetric errors, then becomes essentially meaningless. #### Interpretation of Parameter Errors. There are two kinds of problems that can arise: the reliability of; `Minuit`'s error estimates, and their statistical interpretation,; assuming they are accurate. #### Statistical Interpretation. For discussion of basic concepts, such as the meaning of the elements; of the error matrix, or setting of exact confidence levels see the; articles:. - F.James. Determining the statistical Significance of experimental; Results. Technical Report DD/81/02 and ",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:59546,Availability,error,errors,59546,"t. This may normally happen; only if the parameter is so close to a limit (internal value at an odd; multiple of $\pm \frac{\pi}{2}$ that `Minuit` prints a warning to this; effect when it prints the parameter values. The minimized can become; blocked at a limit, because at a limit the derivative seen by the; minimized $\frac{\partial F}{\partial Pint}$ is zero no matter what the real; derivative $\frac{\partial F}{\partial Pext}$ is. $$; \left(\frac{\partial F}{\partial Pint}\right) =; \left(\frac{\partial F}{\partial Pext}\right); \left(\frac{\partial Pext}{\partial Pint}\right) =; \left(\frac{\partial F}{\partial Pext}\right) = 0; $$. #### Getting the Right Parameter Errors with Limits. In the best case, where the minimum is far from any limits, `Minuit`; will correctly transform the error matrix, and the parameter errors it; reports should be accurate and very close to those you would have got; without limits. In other cases (which should be more common, since; otherwise you would not need limits), the very meaning of parameter; errors becomes problematic. Mathematically, since the limit is an; absolute constraint on the parameter, a parameter at its limit has no; error, at least in one direction. The error matrix, which can assign; only symmetric errors, then becomes essentially meaningless. #### Interpretation of Parameter Errors. There are two kinds of problems that can arise: the reliability of; `Minuit`'s error estimates, and their statistical interpretation,; assuming they are accurate. #### Statistical Interpretation. For discussion of basic concepts, such as the meaning of the elements; of the error matrix, or setting of exact confidence levels see the; articles:. - F.James. Determining the statistical Significance of experimental; Results. Technical Report DD/81/02 and CERN Report 81-03, CERN,; 1981. - W.T.Eadie, D.Drijard, F.James, M.Roos, and B.Sadoulet.; *Statistical Methods in Experimental Physics. North-Holland, 1971*. ### Reliability of Minuit Error",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:59684,Availability,error,error,59684,"prints a warning to this; effect when it prints the parameter values. The minimized can become; blocked at a limit, because at a limit the derivative seen by the; minimized $\frac{\partial F}{\partial Pint}$ is zero no matter what the real; derivative $\frac{\partial F}{\partial Pext}$ is. $$; \left(\frac{\partial F}{\partial Pint}\right) =; \left(\frac{\partial F}{\partial Pext}\right); \left(\frac{\partial Pext}{\partial Pint}\right) =; \left(\frac{\partial F}{\partial Pext}\right) = 0; $$. #### Getting the Right Parameter Errors with Limits. In the best case, where the minimum is far from any limits, `Minuit`; will correctly transform the error matrix, and the parameter errors it; reports should be accurate and very close to those you would have got; without limits. In other cases (which should be more common, since; otherwise you would not need limits), the very meaning of parameter; errors becomes problematic. Mathematically, since the limit is an; absolute constraint on the parameter, a parameter at its limit has no; error, at least in one direction. The error matrix, which can assign; only symmetric errors, then becomes essentially meaningless. #### Interpretation of Parameter Errors. There are two kinds of problems that can arise: the reliability of; `Minuit`'s error estimates, and their statistical interpretation,; assuming they are accurate. #### Statistical Interpretation. For discussion of basic concepts, such as the meaning of the elements; of the error matrix, or setting of exact confidence levels see the; articles:. - F.James. Determining the statistical Significance of experimental; Results. Technical Report DD/81/02 and CERN Report 81-03, CERN,; 1981. - W.T.Eadie, D.Drijard, F.James, M.Roos, and B.Sadoulet.; *Statistical Methods in Experimental Physics. North-Holland, 1971*. ### Reliability of Minuit Error Estimates. `Minuit` always carries around its own current estimates of the; parameter errors, which it will print out on request, no matter how; ",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:59722,Availability,error,error,59722,"use at a limit the derivative seen by the; minimized $\frac{\partial F}{\partial Pint}$ is zero no matter what the real; derivative $\frac{\partial F}{\partial Pext}$ is. $$; \left(\frac{\partial F}{\partial Pint}\right) =; \left(\frac{\partial F}{\partial Pext}\right); \left(\frac{\partial Pext}{\partial Pint}\right) =; \left(\frac{\partial F}{\partial Pext}\right) = 0; $$. #### Getting the Right Parameter Errors with Limits. In the best case, where the minimum is far from any limits, `Minuit`; will correctly transform the error matrix, and the parameter errors it; reports should be accurate and very close to those you would have got; without limits. In other cases (which should be more common, since; otherwise you would not need limits), the very meaning of parameter; errors becomes problematic. Mathematically, since the limit is an; absolute constraint on the parameter, a parameter at its limit has no; error, at least in one direction. The error matrix, which can assign; only symmetric errors, then becomes essentially meaningless. #### Interpretation of Parameter Errors. There are two kinds of problems that can arise: the reliability of; `Minuit`'s error estimates, and their statistical interpretation,; assuming they are accurate. #### Statistical Interpretation. For discussion of basic concepts, such as the meaning of the elements; of the error matrix, or setting of exact confidence levels see the; articles:. - F.James. Determining the statistical Significance of experimental; Results. Technical Report DD/81/02 and CERN Report 81-03, CERN,; 1981. - W.T.Eadie, D.Drijard, F.James, M.Roos, and B.Sadoulet.; *Statistical Methods in Experimental Physics. North-Holland, 1971*. ### Reliability of Minuit Error Estimates. `Minuit` always carries around its own current estimates of the; parameter errors, which it will print out on request, no matter how; accurate they are at any given point in the execution. For example, at; initialization, these estimates are just the star",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:59769,Availability,error,errors,59769,"use at a limit the derivative seen by the; minimized $\frac{\partial F}{\partial Pint}$ is zero no matter what the real; derivative $\frac{\partial F}{\partial Pext}$ is. $$; \left(\frac{\partial F}{\partial Pint}\right) =; \left(\frac{\partial F}{\partial Pext}\right); \left(\frac{\partial Pext}{\partial Pint}\right) =; \left(\frac{\partial F}{\partial Pext}\right) = 0; $$. #### Getting the Right Parameter Errors with Limits. In the best case, where the minimum is far from any limits, `Minuit`; will correctly transform the error matrix, and the parameter errors it; reports should be accurate and very close to those you would have got; without limits. In other cases (which should be more common, since; otherwise you would not need limits), the very meaning of parameter; errors becomes problematic. Mathematically, since the limit is an; absolute constraint on the parameter, a parameter at its limit has no; error, at least in one direction. The error matrix, which can assign; only symmetric errors, then becomes essentially meaningless. #### Interpretation of Parameter Errors. There are two kinds of problems that can arise: the reliability of; `Minuit`'s error estimates, and their statistical interpretation,; assuming they are accurate. #### Statistical Interpretation. For discussion of basic concepts, such as the meaning of the elements; of the error matrix, or setting of exact confidence levels see the; articles:. - F.James. Determining the statistical Significance of experimental; Results. Technical Report DD/81/02 and CERN Report 81-03, CERN,; 1981. - W.T.Eadie, D.Drijard, F.James, M.Roos, and B.Sadoulet.; *Statistical Methods in Experimental Physics. North-Holland, 1971*. ### Reliability of Minuit Error Estimates. `Minuit` always carries around its own current estimates of the; parameter errors, which it will print out on request, no matter how; accurate they are at any given point in the execution. For example, at; initialization, these estimates are just the star",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:59908,Availability,reliab,reliability,59908,"$$; \left(\frac{\partial F}{\partial Pint}\right) =; \left(\frac{\partial F}{\partial Pext}\right); \left(\frac{\partial Pext}{\partial Pint}\right) =; \left(\frac{\partial F}{\partial Pext}\right) = 0; $$. #### Getting the Right Parameter Errors with Limits. In the best case, where the minimum is far from any limits, `Minuit`; will correctly transform the error matrix, and the parameter errors it; reports should be accurate and very close to those you would have got; without limits. In other cases (which should be more common, since; otherwise you would not need limits), the very meaning of parameter; errors becomes problematic. Mathematically, since the limit is an; absolute constraint on the parameter, a parameter at its limit has no; error, at least in one direction. The error matrix, which can assign; only symmetric errors, then becomes essentially meaningless. #### Interpretation of Parameter Errors. There are two kinds of problems that can arise: the reliability of; `Minuit`'s error estimates, and their statistical interpretation,; assuming they are accurate. #### Statistical Interpretation. For discussion of basic concepts, such as the meaning of the elements; of the error matrix, or setting of exact confidence levels see the; articles:. - F.James. Determining the statistical Significance of experimental; Results. Technical Report DD/81/02 and CERN Report 81-03, CERN,; 1981. - W.T.Eadie, D.Drijard, F.James, M.Roos, and B.Sadoulet.; *Statistical Methods in Experimental Physics. North-Holland, 1971*. ### Reliability of Minuit Error Estimates. `Minuit` always carries around its own current estimates of the; parameter errors, which it will print out on request, no matter how; accurate they are at any given point in the execution. For example, at; initialization, these estimates are just the starting step sizes as; specified by the user. After a `HESSE` step, the errors are usually; quite accurate, unless there has been a problem. `Minuit`, when it; prints out err",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:59935,Availability,error,error,59935,"$$; \left(\frac{\partial F}{\partial Pint}\right) =; \left(\frac{\partial F}{\partial Pext}\right); \left(\frac{\partial Pext}{\partial Pint}\right) =; \left(\frac{\partial F}{\partial Pext}\right) = 0; $$. #### Getting the Right Parameter Errors with Limits. In the best case, where the minimum is far from any limits, `Minuit`; will correctly transform the error matrix, and the parameter errors it; reports should be accurate and very close to those you would have got; without limits. In other cases (which should be more common, since; otherwise you would not need limits), the very meaning of parameter; errors becomes problematic. Mathematically, since the limit is an; absolute constraint on the parameter, a parameter at its limit has no; error, at least in one direction. The error matrix, which can assign; only symmetric errors, then becomes essentially meaningless. #### Interpretation of Parameter Errors. There are two kinds of problems that can arise: the reliability of; `Minuit`'s error estimates, and their statistical interpretation,; assuming they are accurate. #### Statistical Interpretation. For discussion of basic concepts, such as the meaning of the elements; of the error matrix, or setting of exact confidence levels see the; articles:. - F.James. Determining the statistical Significance of experimental; Results. Technical Report DD/81/02 and CERN Report 81-03, CERN,; 1981. - W.T.Eadie, D.Drijard, F.James, M.Roos, and B.Sadoulet.; *Statistical Methods in Experimental Physics. North-Holland, 1971*. ### Reliability of Minuit Error Estimates. `Minuit` always carries around its own current estimates of the; parameter errors, which it will print out on request, no matter how; accurate they are at any given point in the execution. For example, at; initialization, these estimates are just the starting step sizes as; specified by the user. After a `HESSE` step, the errors are usually; quite accurate, unless there has been a problem. `Minuit`, when it; prints out err",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:60130,Availability,error,error,60130,"\right) = 0; $$. #### Getting the Right Parameter Errors with Limits. In the best case, where the minimum is far from any limits, `Minuit`; will correctly transform the error matrix, and the parameter errors it; reports should be accurate and very close to those you would have got; without limits. In other cases (which should be more common, since; otherwise you would not need limits), the very meaning of parameter; errors becomes problematic. Mathematically, since the limit is an; absolute constraint on the parameter, a parameter at its limit has no; error, at least in one direction. The error matrix, which can assign; only symmetric errors, then becomes essentially meaningless. #### Interpretation of Parameter Errors. There are two kinds of problems that can arise: the reliability of; `Minuit`'s error estimates, and their statistical interpretation,; assuming they are accurate. #### Statistical Interpretation. For discussion of basic concepts, such as the meaning of the elements; of the error matrix, or setting of exact confidence levels see the; articles:. - F.James. Determining the statistical Significance of experimental; Results. Technical Report DD/81/02 and CERN Report 81-03, CERN,; 1981. - W.T.Eadie, D.Drijard, F.James, M.Roos, and B.Sadoulet.; *Statistical Methods in Experimental Physics. North-Holland, 1971*. ### Reliability of Minuit Error Estimates. `Minuit` always carries around its own current estimates of the; parameter errors, which it will print out on request, no matter how; accurate they are at any given point in the execution. For example, at; initialization, these estimates are just the starting step sizes as; specified by the user. After a `HESSE` step, the errors are usually; quite accurate, unless there has been a problem. `Minuit`, when it; prints out error values, also gives some indication of how reliable it; thinks they are. For example, those marked `CURRENT GUESS ERROR` are; only working values not to be believed, and `APPROXIMATE ERRO",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:60586,Availability,error,errors,60586,"t is an; absolute constraint on the parameter, a parameter at its limit has no; error, at least in one direction. The error matrix, which can assign; only symmetric errors, then becomes essentially meaningless. #### Interpretation of Parameter Errors. There are two kinds of problems that can arise: the reliability of; `Minuit`'s error estimates, and their statistical interpretation,; assuming they are accurate. #### Statistical Interpretation. For discussion of basic concepts, such as the meaning of the elements; of the error matrix, or setting of exact confidence levels see the; articles:. - F.James. Determining the statistical Significance of experimental; Results. Technical Report DD/81/02 and CERN Report 81-03, CERN,; 1981. - W.T.Eadie, D.Drijard, F.James, M.Roos, and B.Sadoulet.; *Statistical Methods in Experimental Physics. North-Holland, 1971*. ### Reliability of Minuit Error Estimates. `Minuit` always carries around its own current estimates of the; parameter errors, which it will print out on request, no matter how; accurate they are at any given point in the execution. For example, at; initialization, these estimates are just the starting step sizes as; specified by the user. After a `HESSE` step, the errors are usually; quite accurate, unless there has been a problem. `Minuit`, when it; prints out error values, also gives some indication of how reliable it; thinks they are. For example, those marked `CURRENT GUESS ERROR` are; only working values not to be believed, and `APPROXIMATE ERROR` means; that they have been calculated but there is reason to believe that; they may not be accurate. If no mitigating adjective is given, then at least `Minuit` believes; the errors are accurate, although there is always a small chance that; `Minuit` has been fooled. Some visible signs that `Minuit` may have; been fooled:. - Warning messages produced during the minimization or error; analysis. - Failure to find new minimum. - Value of EDM too big (estimated Distance to Mi",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:60835,Availability,error,errors,60835," There are two kinds of problems that can arise: the reliability of; `Minuit`'s error estimates, and their statistical interpretation,; assuming they are accurate. #### Statistical Interpretation. For discussion of basic concepts, such as the meaning of the elements; of the error matrix, or setting of exact confidence levels see the; articles:. - F.James. Determining the statistical Significance of experimental; Results. Technical Report DD/81/02 and CERN Report 81-03, CERN,; 1981. - W.T.Eadie, D.Drijard, F.James, M.Roos, and B.Sadoulet.; *Statistical Methods in Experimental Physics. North-Holland, 1971*. ### Reliability of Minuit Error Estimates. `Minuit` always carries around its own current estimates of the; parameter errors, which it will print out on request, no matter how; accurate they are at any given point in the execution. For example, at; initialization, these estimates are just the starting step sizes as; specified by the user. After a `HESSE` step, the errors are usually; quite accurate, unless there has been a problem. `Minuit`, when it; prints out error values, also gives some indication of how reliable it; thinks they are. For example, those marked `CURRENT GUESS ERROR` are; only working values not to be believed, and `APPROXIMATE ERROR` means; that they have been calculated but there is reason to believe that; they may not be accurate. If no mitigating adjective is given, then at least `Minuit` believes; the errors are accurate, although there is always a small chance that; `Minuit` has been fooled. Some visible signs that `Minuit` may have; been fooled:. - Warning messages produced during the minimization or error; analysis. - Failure to find new minimum. - Value of EDM too big (estimated Distance to Minimum). - Correlation coefficients exactly equal to zero, unless some; parameters are known to be uncorrelated with the others. - Correlation coefficients very close to one (greater than 0.99).; This indicates both an exceptionally difficult problem, ",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:60934,Availability,error,error,60934,"heir statistical interpretation,; assuming they are accurate. #### Statistical Interpretation. For discussion of basic concepts, such as the meaning of the elements; of the error matrix, or setting of exact confidence levels see the; articles:. - F.James. Determining the statistical Significance of experimental; Results. Technical Report DD/81/02 and CERN Report 81-03, CERN,; 1981. - W.T.Eadie, D.Drijard, F.James, M.Roos, and B.Sadoulet.; *Statistical Methods in Experimental Physics. North-Holland, 1971*. ### Reliability of Minuit Error Estimates. `Minuit` always carries around its own current estimates of the; parameter errors, which it will print out on request, no matter how; accurate they are at any given point in the execution. For example, at; initialization, these estimates are just the starting step sizes as; specified by the user. After a `HESSE` step, the errors are usually; quite accurate, unless there has been a problem. `Minuit`, when it; prints out error values, also gives some indication of how reliable it; thinks they are. For example, those marked `CURRENT GUESS ERROR` are; only working values not to be believed, and `APPROXIMATE ERROR` means; that they have been calculated but there is reason to believe that; they may not be accurate. If no mitigating adjective is given, then at least `Minuit` believes; the errors are accurate, although there is always a small chance that; `Minuit` has been fooled. Some visible signs that `Minuit` may have; been fooled:. - Warning messages produced during the minimization or error; analysis. - Failure to find new minimum. - Value of EDM too big (estimated Distance to Minimum). - Correlation coefficients exactly equal to zero, unless some; parameters are known to be uncorrelated with the others. - Correlation coefficients very close to one (greater than 0.99).; This indicates both an exceptionally difficult problem, and one; which has been badly parameterized so that individual errors are; not very meaningful becaus",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:60982,Availability,reliab,reliable,60982,"heir statistical interpretation,; assuming they are accurate. #### Statistical Interpretation. For discussion of basic concepts, such as the meaning of the elements; of the error matrix, or setting of exact confidence levels see the; articles:. - F.James. Determining the statistical Significance of experimental; Results. Technical Report DD/81/02 and CERN Report 81-03, CERN,; 1981. - W.T.Eadie, D.Drijard, F.James, M.Roos, and B.Sadoulet.; *Statistical Methods in Experimental Physics. North-Holland, 1971*. ### Reliability of Minuit Error Estimates. `Minuit` always carries around its own current estimates of the; parameter errors, which it will print out on request, no matter how; accurate they are at any given point in the execution. For example, at; initialization, these estimates are just the starting step sizes as; specified by the user. After a `HESSE` step, the errors are usually; quite accurate, unless there has been a problem. `Minuit`, when it; prints out error values, also gives some indication of how reliable it; thinks they are. For example, those marked `CURRENT GUESS ERROR` are; only working values not to be believed, and `APPROXIMATE ERROR` means; that they have been calculated but there is reason to believe that; they may not be accurate. If no mitigating adjective is given, then at least `Minuit` believes; the errors are accurate, although there is always a small chance that; `Minuit` has been fooled. Some visible signs that `Minuit` may have; been fooled:. - Warning messages produced during the minimization or error; analysis. - Failure to find new minimum. - Value of EDM too big (estimated Distance to Minimum). - Correlation coefficients exactly equal to zero, unless some; parameters are known to be uncorrelated with the others. - Correlation coefficients very close to one (greater than 0.99).; This indicates both an exceptionally difficult problem, and one; which has been badly parameterized so that individual errors are; not very meaningful becaus",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:61304,Availability,error,errors,61304,"RN Report 81-03, CERN,; 1981. - W.T.Eadie, D.Drijard, F.James, M.Roos, and B.Sadoulet.; *Statistical Methods in Experimental Physics. North-Holland, 1971*. ### Reliability of Minuit Error Estimates. `Minuit` always carries around its own current estimates of the; parameter errors, which it will print out on request, no matter how; accurate they are at any given point in the execution. For example, at; initialization, these estimates are just the starting step sizes as; specified by the user. After a `HESSE` step, the errors are usually; quite accurate, unless there has been a problem. `Minuit`, when it; prints out error values, also gives some indication of how reliable it; thinks they are. For example, those marked `CURRENT GUESS ERROR` are; only working values not to be believed, and `APPROXIMATE ERROR` means; that they have been calculated but there is reason to believe that; they may not be accurate. If no mitigating adjective is given, then at least `Minuit` believes; the errors are accurate, although there is always a small chance that; `Minuit` has been fooled. Some visible signs that `Minuit` may have; been fooled:. - Warning messages produced during the minimization or error; analysis. - Failure to find new minimum. - Value of EDM too big (estimated Distance to Minimum). - Correlation coefficients exactly equal to zero, unless some; parameters are known to be uncorrelated with the others. - Correlation coefficients very close to one (greater than 0.99).; This indicates both an exceptionally difficult problem, and one; which has been badly parameterized so that individual errors are; not very meaningful because they are so highly correlated. - Parameter at limit. This condition, signaled by a `Minuit` warning; message, may make both the function minimum and parameter errors; unreliable. See the discussion above ‘Getting the right parameter; errors with limits'. The best way to be absolutely sure of the errors is to use; ''independent'' calculations and compar",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:61509,Availability,error,error,61509,"nuit Error Estimates. `Minuit` always carries around its own current estimates of the; parameter errors, which it will print out on request, no matter how; accurate they are at any given point in the execution. For example, at; initialization, these estimates are just the starting step sizes as; specified by the user. After a `HESSE` step, the errors are usually; quite accurate, unless there has been a problem. `Minuit`, when it; prints out error values, also gives some indication of how reliable it; thinks they are. For example, those marked `CURRENT GUESS ERROR` are; only working values not to be believed, and `APPROXIMATE ERROR` means; that they have been calculated but there is reason to believe that; they may not be accurate. If no mitigating adjective is given, then at least `Minuit` believes; the errors are accurate, although there is always a small chance that; `Minuit` has been fooled. Some visible signs that `Minuit` may have; been fooled:. - Warning messages produced during the minimization or error; analysis. - Failure to find new minimum. - Value of EDM too big (estimated Distance to Minimum). - Correlation coefficients exactly equal to zero, unless some; parameters are known to be uncorrelated with the others. - Correlation coefficients very close to one (greater than 0.99).; This indicates both an exceptionally difficult problem, and one; which has been badly parameterized so that individual errors are; not very meaningful because they are so highly correlated. - Parameter at limit. This condition, signaled by a `Minuit` warning; message, may make both the function minimum and parameter errors; unreliable. See the discussion above ‘Getting the right parameter; errors with limits'. The best way to be absolutely sure of the errors is to use; ''independent'' calculations and compare them, or compare the; calculated errors with a picture of the function. Theoretically, the; covariance matrix for a ''physical'' function must be; positive-definite at the mi",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:61919,Availability,error,errors,61919,"a problem. `Minuit`, when it; prints out error values, also gives some indication of how reliable it; thinks they are. For example, those marked `CURRENT GUESS ERROR` are; only working values not to be believed, and `APPROXIMATE ERROR` means; that they have been calculated but there is reason to believe that; they may not be accurate. If no mitigating adjective is given, then at least `Minuit` believes; the errors are accurate, although there is always a small chance that; `Minuit` has been fooled. Some visible signs that `Minuit` may have; been fooled:. - Warning messages produced during the minimization or error; analysis. - Failure to find new minimum. - Value of EDM too big (estimated Distance to Minimum). - Correlation coefficients exactly equal to zero, unless some; parameters are known to be uncorrelated with the others. - Correlation coefficients very close to one (greater than 0.99).; This indicates both an exceptionally difficult problem, and one; which has been badly parameterized so that individual errors are; not very meaningful because they are so highly correlated. - Parameter at limit. This condition, signaled by a `Minuit` warning; message, may make both the function minimum and parameter errors; unreliable. See the discussion above ‘Getting the right parameter; errors with limits'. The best way to be absolutely sure of the errors is to use; ''independent'' calculations and compare them, or compare the; calculated errors with a picture of the function. Theoretically, the; covariance matrix for a ''physical'' function must be; positive-definite at the minimum, although it may not be so for all; points far away from the minimum, even for a well-determined physical; problem. Therefore, if `MIGRAD` reports that it has found a; non-positive-definite covariance matrix, this may be a sign of one or; more of the following:. #### A Non-physical Region. On its way to the minimum, `MIGRAD` may have traversed a region that; has unphysical behavior, which is of c",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:62118,Availability,error,errors,62118,"ing values not to be believed, and `APPROXIMATE ERROR` means; that they have been calculated but there is reason to believe that; they may not be accurate. If no mitigating adjective is given, then at least `Minuit` believes; the errors are accurate, although there is always a small chance that; `Minuit` has been fooled. Some visible signs that `Minuit` may have; been fooled:. - Warning messages produced during the minimization or error; analysis. - Failure to find new minimum. - Value of EDM too big (estimated Distance to Minimum). - Correlation coefficients exactly equal to zero, unless some; parameters are known to be uncorrelated with the others. - Correlation coefficients very close to one (greater than 0.99).; This indicates both an exceptionally difficult problem, and one; which has been badly parameterized so that individual errors are; not very meaningful because they are so highly correlated. - Parameter at limit. This condition, signaled by a `Minuit` warning; message, may make both the function minimum and parameter errors; unreliable. See the discussion above ‘Getting the right parameter; errors with limits'. The best way to be absolutely sure of the errors is to use; ''independent'' calculations and compare them, or compare the; calculated errors with a picture of the function. Theoretically, the; covariance matrix for a ''physical'' function must be; positive-definite at the minimum, although it may not be so for all; points far away from the minimum, even for a well-determined physical; problem. Therefore, if `MIGRAD` reports that it has found a; non-positive-definite covariance matrix, this may be a sign of one or; more of the following:. #### A Non-physical Region. On its way to the minimum, `MIGRAD` may have traversed a region that; has unphysical behavior, which is of course not a serious problem as; long as it recovers and leaves such a region. #### An Underdetermined Problem. If the matrix is not positive-definite even at the minimum, this may;",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:62193,Availability,error,errors,62193,"e is reason to believe that; they may not be accurate. If no mitigating adjective is given, then at least `Minuit` believes; the errors are accurate, although there is always a small chance that; `Minuit` has been fooled. Some visible signs that `Minuit` may have; been fooled:. - Warning messages produced during the minimization or error; analysis. - Failure to find new minimum. - Value of EDM too big (estimated Distance to Minimum). - Correlation coefficients exactly equal to zero, unless some; parameters are known to be uncorrelated with the others. - Correlation coefficients very close to one (greater than 0.99).; This indicates both an exceptionally difficult problem, and one; which has been badly parameterized so that individual errors are; not very meaningful because they are so highly correlated. - Parameter at limit. This condition, signaled by a `Minuit` warning; message, may make both the function minimum and parameter errors; unreliable. See the discussion above ‘Getting the right parameter; errors with limits'. The best way to be absolutely sure of the errors is to use; ''independent'' calculations and compare them, or compare the; calculated errors with a picture of the function. Theoretically, the; covariance matrix for a ''physical'' function must be; positive-definite at the minimum, although it may not be so for all; points far away from the minimum, even for a well-determined physical; problem. Therefore, if `MIGRAD` reports that it has found a; non-positive-definite covariance matrix, this may be a sign of one or; more of the following:. #### A Non-physical Region. On its way to the minimum, `MIGRAD` may have traversed a region that; has unphysical behavior, which is of course not a serious problem as; long as it recovers and leaves such a region. #### An Underdetermined Problem. If the matrix is not positive-definite even at the minimum, this may; mean that the solution is not well defined, for example that there are; more unknowns than there are",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:62256,Availability,error,errors,62256," the errors are accurate, although there is always a small chance that; `Minuit` has been fooled. Some visible signs that `Minuit` may have; been fooled:. - Warning messages produced during the minimization or error; analysis. - Failure to find new minimum. - Value of EDM too big (estimated Distance to Minimum). - Correlation coefficients exactly equal to zero, unless some; parameters are known to be uncorrelated with the others. - Correlation coefficients very close to one (greater than 0.99).; This indicates both an exceptionally difficult problem, and one; which has been badly parameterized so that individual errors are; not very meaningful because they are so highly correlated. - Parameter at limit. This condition, signaled by a `Minuit` warning; message, may make both the function minimum and parameter errors; unreliable. See the discussion above ‘Getting the right parameter; errors with limits'. The best way to be absolutely sure of the errors is to use; ''independent'' calculations and compare them, or compare the; calculated errors with a picture of the function. Theoretically, the; covariance matrix for a ''physical'' function must be; positive-definite at the minimum, although it may not be so for all; points far away from the minimum, even for a well-determined physical; problem. Therefore, if `MIGRAD` reports that it has found a; non-positive-definite covariance matrix, this may be a sign of one or; more of the following:. #### A Non-physical Region. On its way to the minimum, `MIGRAD` may have traversed a region that; has unphysical behavior, which is of course not a serious problem as; long as it recovers and leaves such a region. #### An Underdetermined Problem. If the matrix is not positive-definite even at the minimum, this may; mean that the solution is not well defined, for example that there are; more unknowns than there are data points, or that the parameterization; of the fit contains a linear dependence. If this is the case, then; `Minuit` (or ",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:62348,Availability,error,errors,62348," the errors are accurate, although there is always a small chance that; `Minuit` has been fooled. Some visible signs that `Minuit` may have; been fooled:. - Warning messages produced during the minimization or error; analysis. - Failure to find new minimum. - Value of EDM too big (estimated Distance to Minimum). - Correlation coefficients exactly equal to zero, unless some; parameters are known to be uncorrelated with the others. - Correlation coefficients very close to one (greater than 0.99).; This indicates both an exceptionally difficult problem, and one; which has been badly parameterized so that individual errors are; not very meaningful because they are so highly correlated. - Parameter at limit. This condition, signaled by a `Minuit` warning; message, may make both the function minimum and parameter errors; unreliable. See the discussion above ‘Getting the right parameter; errors with limits'. The best way to be absolutely sure of the errors is to use; ''independent'' calculations and compare them, or compare the; calculated errors with a picture of the function. Theoretically, the; covariance matrix for a ''physical'' function must be; positive-definite at the minimum, although it may not be so for all; points far away from the minimum, even for a well-determined physical; problem. Therefore, if `MIGRAD` reports that it has found a; non-positive-definite covariance matrix, this may be a sign of one or; more of the following:. #### A Non-physical Region. On its way to the minimum, `MIGRAD` may have traversed a region that; has unphysical behavior, which is of course not a serious problem as; long as it recovers and leaves such a region. #### An Underdetermined Problem. If the matrix is not positive-definite even at the minimum, this may; mean that the solution is not well defined, for example that there are; more unknowns than there are data points, or that the parameterization; of the fit contains a linear dependence. If this is the case, then; `Minuit` (or ",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:62937,Availability,recover,recovers,62937,"n badly parameterized so that individual errors are; not very meaningful because they are so highly correlated. - Parameter at limit. This condition, signaled by a `Minuit` warning; message, may make both the function minimum and parameter errors; unreliable. See the discussion above ‘Getting the right parameter; errors with limits'. The best way to be absolutely sure of the errors is to use; ''independent'' calculations and compare them, or compare the; calculated errors with a picture of the function. Theoretically, the; covariance matrix for a ''physical'' function must be; positive-definite at the minimum, although it may not be so for all; points far away from the minimum, even for a well-determined physical; problem. Therefore, if `MIGRAD` reports that it has found a; non-positive-definite covariance matrix, this may be a sign of one or; more of the following:. #### A Non-physical Region. On its way to the minimum, `MIGRAD` may have traversed a region that; has unphysical behavior, which is of course not a serious problem as; long as it recovers and leaves such a region. #### An Underdetermined Problem. If the matrix is not positive-definite even at the minimum, this may; mean that the solution is not well defined, for example that there are; more unknowns than there are data points, or that the parameterization; of the fit contains a linear dependence. If this is the case, then; `Minuit` (or any other program) cannot solve your problem uniquely.; The error matrix will necessarily be largely meaningless, so the user; must remove the under determinedness by reformulating the; parameterization. `Minuit` cannot do this itself. #### Numerical Inaccuracies. It is possible that the apparent lack of positive-definiteness is due; to excessive round off errors in numerical calculations (in the user; function), or not enough precision. This is unlikely in general, but; becomes more likely if the number of free parameters is very large, or; if the parameters are badly sc",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:63360,Availability,error,error,63360," a ''physical'' function must be; positive-definite at the minimum, although it may not be so for all; points far away from the minimum, even for a well-determined physical; problem. Therefore, if `MIGRAD` reports that it has found a; non-positive-definite covariance matrix, this may be a sign of one or; more of the following:. #### A Non-physical Region. On its way to the minimum, `MIGRAD` may have traversed a region that; has unphysical behavior, which is of course not a serious problem as; long as it recovers and leaves such a region. #### An Underdetermined Problem. If the matrix is not positive-definite even at the minimum, this may; mean that the solution is not well defined, for example that there are; more unknowns than there are data points, or that the parameterization; of the fit contains a linear dependence. If this is the case, then; `Minuit` (or any other program) cannot solve your problem uniquely.; The error matrix will necessarily be largely meaningless, so the user; must remove the under determinedness by reformulating the; parameterization. `Minuit` cannot do this itself. #### Numerical Inaccuracies. It is possible that the apparent lack of positive-definiteness is due; to excessive round off errors in numerical calculations (in the user; function), or not enough precision. This is unlikely in general, but; becomes more likely if the number of free parameters is very large, or; if the parameters are badly scaled (not all of the same order of; magnitude), and correlations are large. In any case, whether the; non-positive-definiteness is real or only numerical is largely; irrelevant, since in both cases the error matrix will be unreliable; and the minimum suspicious. #### An Ill-posed Problem. For questions of parameter dependence, see the discussion above on; positive-definiteness. Possible other mathematical problems are the; following:. - Excessive numerical round off - be especially careful of; exponential and factorial functions which get big ve",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:63659,Availability,error,errors,63659,"s found a; non-positive-definite covariance matrix, this may be a sign of one or; more of the following:. #### A Non-physical Region. On its way to the minimum, `MIGRAD` may have traversed a region that; has unphysical behavior, which is of course not a serious problem as; long as it recovers and leaves such a region. #### An Underdetermined Problem. If the matrix is not positive-definite even at the minimum, this may; mean that the solution is not well defined, for example that there are; more unknowns than there are data points, or that the parameterization; of the fit contains a linear dependence. If this is the case, then; `Minuit` (or any other program) cannot solve your problem uniquely.; The error matrix will necessarily be largely meaningless, so the user; must remove the under determinedness by reformulating the; parameterization. `Minuit` cannot do this itself. #### Numerical Inaccuracies. It is possible that the apparent lack of positive-definiteness is due; to excessive round off errors in numerical calculations (in the user; function), or not enough precision. This is unlikely in general, but; becomes more likely if the number of free parameters is very large, or; if the parameters are badly scaled (not all of the same order of; magnitude), and correlations are large. In any case, whether the; non-positive-definiteness is real or only numerical is largely; irrelevant, since in both cases the error matrix will be unreliable; and the minimum suspicious. #### An Ill-posed Problem. For questions of parameter dependence, see the discussion above on; positive-definiteness. Possible other mathematical problems are the; following:. - Excessive numerical round off - be especially careful of; exponential and factorial functions which get big very quickly and; lose accuracy. - Starting too far from the solution - the function may have; unphysical local minima, especially at infinity in some variables. ## Minuit2 Package. `Minuit2` is a new object-oriented implement",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:64080,Availability,error,error,64080,"en at the minimum, this may; mean that the solution is not well defined, for example that there are; more unknowns than there are data points, or that the parameterization; of the fit contains a linear dependence. If this is the case, then; `Minuit` (or any other program) cannot solve your problem uniquely.; The error matrix will necessarily be largely meaningless, so the user; must remove the under determinedness by reformulating the; parameterization. `Minuit` cannot do this itself. #### Numerical Inaccuracies. It is possible that the apparent lack of positive-definiteness is due; to excessive round off errors in numerical calculations (in the user; function), or not enough precision. This is unlikely in general, but; becomes more likely if the number of free parameters is very large, or; if the parameters are badly scaled (not all of the same order of; magnitude), and correlations are large. In any case, whether the; non-positive-definiteness is real or only numerical is largely; irrelevant, since in both cases the error matrix will be unreliable; and the minimum suspicious. #### An Ill-posed Problem. For questions of parameter dependence, see the discussion above on; positive-definiteness. Possible other mathematical problems are the; following:. - Excessive numerical round off - be especially careful of; exponential and factorial functions which get big very quickly and; lose accuracy. - Starting too far from the solution - the function may have; unphysical local minima, especially at infinity in some variables. ## Minuit2 Package. `Minuit2` is a new object-oriented implementation, written in C++, of; the popular `MINUIT` minimization package. Compared with the; **`TMinuit`** class, which is a direct conversion from FORTRAN to C++,; `Minuit2` is a complete redesign and re-implementation of the package.; This new version provides all the functionality present in the old; FORTRAN version, with almost equivalent numerical accuracy and; computational performances.; ",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:66223,Availability,avail,available,66223," paragraph ""FUMILI Minimization Package""),; which is an optimized method for least square and log; likelihood minimizations. Minuit2 has been originally developed by M.; Winkler and F. James in the SEAL project. More information can be found; on the [MINUIT Web Site](MINUIT Web Site) and in particular at the; following documentation page at; <http://www.cern.ch/minuit/doc/doc.html>. A detailed User Guide for Minuit2 exists, describing the API of the internal classes.; ROOT uses `Minuit2` for fitting via the `Minuit2Minimizer` class which implements; the `ROOT::Math::Minimizer` interface. `Minuit2` is also distributed as an independent package of ROOT and can be built; without any other dependency on the ROOT libraries. Examples on how to use the `Minuit2` and `Fumili2` plug-ins are provided; in the tutorials' directory `$ROOTSYS/tutorials/fit`:; `minuit2FitBench.C`, `minuit2FitBench2D.C` and `minuit2GausFit.C`.; More information on the classes and functions present in `Minuit2` is; available at; [online reference documentation](online reference documentation). Useful information on MINUIT and minimization in general is provided in the; following documents:. F. James, *Minuit Tutorial on Function Minimization* (; <http://seal.cern.ch/documents/minuit/mntutorial.pdf>); F. James, *The; Interpretation of Errors in Minuit* (; <http://seal.cern.ch/documents/minuit/mnerror.pdf>);. ## FUMILI Minimization Package. FUMILI is used to minimize Chi-square function or to search maximum of; likelihood function. Experimentally measured values $F_{i}$ are fitted; with theoretical; functions $f_{i}(\vec{x_{i}},\vec{\theta})$, where $\vec{x_{i}}$ are; coordinates, and $\vec{\theta}$ - vector of parameters.; For better convergence Chi-square function has to be the following form. $$; \frac{\chi^2}{2} = \frac{1}{2} \sum_{i=1}^{n}; \left(\frac{f_{i}(\vec{x_{i}},\vec{\theta}) - F_{i}}; {\sigma_{i}}\right)^{2}; $$. where $\sigma_{i}$ are errors of the measured function. The minimum; condit",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:67174,Availability,error,errors,67174,"asses and functions present in `Minuit2` is; available at; [online reference documentation](online reference documentation). Useful information on MINUIT and minimization in general is provided in the; following documents:. F. James, *Minuit Tutorial on Function Minimization* (; <http://seal.cern.ch/documents/minuit/mntutorial.pdf>); F. James, *The; Interpretation of Errors in Minuit* (; <http://seal.cern.ch/documents/minuit/mnerror.pdf>);. ## FUMILI Minimization Package. FUMILI is used to minimize Chi-square function or to search maximum of; likelihood function. Experimentally measured values $F_{i}$ are fitted; with theoretical; functions $f_{i}(\vec{x_{i}},\vec{\theta})$, where $\vec{x_{i}}$ are; coordinates, and $\vec{\theta}$ - vector of parameters.; For better convergence Chi-square function has to be the following form. $$; \frac{\chi^2}{2} = \frac{1}{2} \sum_{i=1}^{n}; \left(\frac{f_{i}(\vec{x_{i}},\vec{\theta}) - F_{i}}; {\sigma_{i}}\right)^{2}; $$. where $\sigma_{i}$ are errors of the measured function. The minimum; condition is:. $$; \frac{\partial \chi^{2}}{\partial \theta_{i}} =; \sum_{j=1}^{n}; \frac{1}{\sigma_{j}^{2}} . \frac{\partial f_{i}}{\partial \theta_{i}}; \left[ (\vec{x_{j}},\vec{\theta}); - F_{j}\right] = 0, i = 1 ... m; $$. where $m$ is the quantity of parameters. Expanding left part of this; equation over parameter increments and retaining only linear terms one; gets. $$; \left(\frac{\partial \chi^{2}}{\theta_{i}}\right); _{\theta = \vec{\theta}^{0}} +; \sum_{k}; \left(\frac{\partial^{2} \chi^{2}}{\partial \theta_{i}; \partial \theta_{k}}\right); _{\theta = \vec{\theta}^{0}} . (\theta_{k} - \theta_{k}^{0}) = 0; $$. here $\vec{\theta}^{0}$ is some initial value of parameters. In; general case:. $$; {\frac{\partial^2\chi^2}{\partial\theta_i\partial\theta_k}}=; \sum^n_{j=1}{\frac{1}{\sigma^2_j}}; {\frac{\partial f_j}{\theta_i}} {\frac{\partial f_j}{\theta_k}} +; \sum^n_{j=1}{\frac{(f_j - F_j)}{\sigma^2_j}}\cdot; {\frac{\partial^2f_j}{\partial\",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:68501,Availability,down,down,68501,"$. where $m$ is the quantity of parameters. Expanding left part of this; equation over parameter increments and retaining only linear terms one; gets. $$; \left(\frac{\partial \chi^{2}}{\theta_{i}}\right); _{\theta = \vec{\theta}^{0}} +; \sum_{k}; \left(\frac{\partial^{2} \chi^{2}}{\partial \theta_{i}; \partial \theta_{k}}\right); _{\theta = \vec{\theta}^{0}} . (\theta_{k} - \theta_{k}^{0}) = 0; $$. here $\vec{\theta}^{0}$ is some initial value of parameters. In; general case:. $$; {\frac{\partial^2\chi^2}{\partial\theta_i\partial\theta_k}}=; \sum^n_{j=1}{\frac{1}{\sigma^2_j}}; {\frac{\partial f_j}{\theta_i}} {\frac{\partial f_j}{\theta_k}} +; \sum^n_{j=1}{\frac{(f_j - F_j)}{\sigma^2_j}}\cdot; {\frac{\partial^2f_j}{\partial\theta_i\partial\theta_k}}; $$. In FUMILI algorithm for second derivatives of Chi-square approximate; expression is used when last term in previous equation is discarded.; It is often done, not always wittingly, and sometimes causes troubles,; for example, if user wants to limit parameters with positive values by; writing down $\theta_i^2$ instead of $\theta_i$. FUMILI will fail if; one tries minimize $\chi^2 = g^2(\vec\theta)$ where g is arbitrary; function. Approximate value is:. $$; {\frac{\partial^2\chi^2}{\partial\theta_i\partial\theta_k}}\approx Z_{ik}=; \sum^n_{j=1}{\frac{1}{\sigma^2_j}}{\frac{\partial f_j}{\theta_i}}; {\frac{\partial f_j}{\theta_k}}; $$. Then the equations for parameter increments are:. $$; \left(\frac{\partial\chi^2}{\partial\theta_i}\right)_; {\vec\theta={\vec\theta}^0} +\sum_k Z_{ik}\cdot(\theta_k-\theta^0_k) =; 0, \qquad i=1\ldots m; $$. Remarkable feature of algorithm is the technique for step restriction.; For an initial value of parameter ${\vec\theta}^0$ a parallelepiped; $P_0$ is built with the center at ${\vec\theta}^0$ and axes parallel; to coordinate axes $\theta_i$. The lengths of parallelepiped sides; along i-th axis is $2b_i$, where $b_i$ is such a value that the; functions $f_j(\vec\theta)$ are quasi-linear",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:71459,Availability,error,error,71459,"ols for neural; networks studies. ### The MLP. The multilayer perceptron is a simple feed-forward network with the; following structure showed on the left. ![](pictures/0300008D.png). It is made of neurons characterized by a bias and weighted links in; between - let's call those links synapses. The input neurons receive; the inputs, normalize them and forward them to the first hidden layer.; Each neuron in any subsequent layer first computes a linear; combination of the outputs of the previous layer. The output of the; neuron is then function of that combination with f being linear for; output neurons or a sigmoid for hidden layers. Such a structure is very useful because of two theorems:. 1- A linear combination of `sigmoids` can approximate any continuous; function. 2- Trained with `output=1` for the signal and 0 for the background,; the approximated function of inputs `X` is the probability of signal,; knowing `X`. ### Learning Methods. The aim of all learning methods is to minimize the total error on a; set of weighted examples. The error is defined as the sum in quadrate,; divided by two, of the error on each individual output neuron. In all; methods implemented in this library, one needs to compute the first; derivative of that error with respect to the weights. Exploiting the; well-known properties of the derivative, one can express this; derivative as the product of the local partial derivative by the; weighted sum of the outputs derivatives (for a neuron) or as the; product of the input value with the local partial derivative of the; output neuron (for a synapse). This computation is called; ""back-propagation of the errors"". Six learning methods are; implemented. #### Stochastic Minimization. This is the most trivial learning method. The Robbins-Monro stochastic; approximation is applied to multilayer perceptrons. The weights are; updated after each example according to the formula:. $$; w_{ij}(t+1) = w_{ij}(t) + \Delta w_{ij}(t); $$. with:. $$; \Delta w_{ij",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:71501,Availability,error,error,71501,"ork with the; following structure showed on the left. ![](pictures/0300008D.png). It is made of neurons characterized by a bias and weighted links in; between - let's call those links synapses. The input neurons receive; the inputs, normalize them and forward them to the first hidden layer.; Each neuron in any subsequent layer first computes a linear; combination of the outputs of the previous layer. The output of the; neuron is then function of that combination with f being linear for; output neurons or a sigmoid for hidden layers. Such a structure is very useful because of two theorems:. 1- A linear combination of `sigmoids` can approximate any continuous; function. 2- Trained with `output=1` for the signal and 0 for the background,; the approximated function of inputs `X` is the probability of signal,; knowing `X`. ### Learning Methods. The aim of all learning methods is to minimize the total error on a; set of weighted examples. The error is defined as the sum in quadrate,; divided by two, of the error on each individual output neuron. In all; methods implemented in this library, one needs to compute the first; derivative of that error with respect to the weights. Exploiting the; well-known properties of the derivative, one can express this; derivative as the product of the local partial derivative by the; weighted sum of the outputs derivatives (for a neuron) or as the; product of the input value with the local partial derivative of the; output neuron (for a synapse). This computation is called; ""back-propagation of the errors"". Six learning methods are; implemented. #### Stochastic Minimization. This is the most trivial learning method. The Robbins-Monro stochastic; approximation is applied to multilayer perceptrons. The weights are; updated after each example according to the formula:. $$; w_{ij}(t+1) = w_{ij}(t) + \Delta w_{ij}(t); $$. with:. $$; \Delta w_{ij}(t) = - \eta \left(; \frac{\partial e_p}{\partial w_{ij}} + \delta \right) +; \epsilon \Delta w_{ij}(",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:71566,Availability,error,error,71566,"ork with the; following structure showed on the left. ![](pictures/0300008D.png). It is made of neurons characterized by a bias and weighted links in; between - let's call those links synapses. The input neurons receive; the inputs, normalize them and forward them to the first hidden layer.; Each neuron in any subsequent layer first computes a linear; combination of the outputs of the previous layer. The output of the; neuron is then function of that combination with f being linear for; output neurons or a sigmoid for hidden layers. Such a structure is very useful because of two theorems:. 1- A linear combination of `sigmoids` can approximate any continuous; function. 2- Trained with `output=1` for the signal and 0 for the background,; the approximated function of inputs `X` is the probability of signal,; knowing `X`. ### Learning Methods. The aim of all learning methods is to minimize the total error on a; set of weighted examples. The error is defined as the sum in quadrate,; divided by two, of the error on each individual output neuron. In all; methods implemented in this library, one needs to compute the first; derivative of that error with respect to the weights. Exploiting the; well-known properties of the derivative, one can express this; derivative as the product of the local partial derivative by the; weighted sum of the outputs derivatives (for a neuron) or as the; product of the input value with the local partial derivative of the; output neuron (for a synapse). This computation is called; ""back-propagation of the errors"". Six learning methods are; implemented. #### Stochastic Minimization. This is the most trivial learning method. The Robbins-Monro stochastic; approximation is applied to multilayer perceptrons. The weights are; updated after each example according to the formula:. $$; w_{ij}(t+1) = w_{ij}(t) + \Delta w_{ij}(t); $$. with:. $$; \Delta w_{ij}(t) = - \eta \left(; \frac{\partial e_p}{\partial w_{ij}} + \delta \right) +; \epsilon \Delta w_{ij}(",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:71702,Availability,error,error,71702," a bias and weighted links in; between - let's call those links synapses. The input neurons receive; the inputs, normalize them and forward them to the first hidden layer.; Each neuron in any subsequent layer first computes a linear; combination of the outputs of the previous layer. The output of the; neuron is then function of that combination with f being linear for; output neurons or a sigmoid for hidden layers. Such a structure is very useful because of two theorems:. 1- A linear combination of `sigmoids` can approximate any continuous; function. 2- Trained with `output=1` for the signal and 0 for the background,; the approximated function of inputs `X` is the probability of signal,; knowing `X`. ### Learning Methods. The aim of all learning methods is to minimize the total error on a; set of weighted examples. The error is defined as the sum in quadrate,; divided by two, of the error on each individual output neuron. In all; methods implemented in this library, one needs to compute the first; derivative of that error with respect to the weights. Exploiting the; well-known properties of the derivative, one can express this; derivative as the product of the local partial derivative by the; weighted sum of the outputs derivatives (for a neuron) or as the; product of the input value with the local partial derivative of the; output neuron (for a synapse). This computation is called; ""back-propagation of the errors"". Six learning methods are; implemented. #### Stochastic Minimization. This is the most trivial learning method. The Robbins-Monro stochastic; approximation is applied to multilayer perceptrons. The weights are; updated after each example according to the formula:. $$; w_{ij}(t+1) = w_{ij}(t) + \Delta w_{ij}(t); $$. with:. $$; \Delta w_{ij}(t) = - \eta \left(; \frac{\partial e_p}{\partial w_{ij}} + \delta \right) +; \epsilon \Delta w_{ij}(t-1); $$. The parameters for this method are `Eta`, `EtaDecay`, `Delta` and; `Epsilon`. #### Steepest Descent With Fixed",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:72101,Availability,error,errors,72101,"en layers. Such a structure is very useful because of two theorems:. 1- A linear combination of `sigmoids` can approximate any continuous; function. 2- Trained with `output=1` for the signal and 0 for the background,; the approximated function of inputs `X` is the probability of signal,; knowing `X`. ### Learning Methods. The aim of all learning methods is to minimize the total error on a; set of weighted examples. The error is defined as the sum in quadrate,; divided by two, of the error on each individual output neuron. In all; methods implemented in this library, one needs to compute the first; derivative of that error with respect to the weights. Exploiting the; well-known properties of the derivative, one can express this; derivative as the product of the local partial derivative by the; weighted sum of the outputs derivatives (for a neuron) or as the; product of the input value with the local partial derivative of the; output neuron (for a synapse). This computation is called; ""back-propagation of the errors"". Six learning methods are; implemented. #### Stochastic Minimization. This is the most trivial learning method. The Robbins-Monro stochastic; approximation is applied to multilayer perceptrons. The weights are; updated after each example according to the formula:. $$; w_{ij}(t+1) = w_{ij}(t) + \Delta w_{ij}(t); $$. with:. $$; \Delta w_{ij}(t) = - \eta \left(; \frac{\partial e_p}{\partial w_{ij}} + \delta \right) +; \epsilon \Delta w_{ij}(t-1); $$. The parameters for this method are `Eta`, `EtaDecay`, `Delta` and; `Epsilon`. #### Steepest Descent With Fixed Step Size (Batch Learning). It is the same as the stochastic minimization, but the weights are; updated after considering all the examples, with the total derivative; `dEdw`. The parameters for this method are `Eta`, `EtaDecay`, `Delta`; and `Epsilon`. #### Steepest Descent Algorithm. Weights are set to the minimum along the line defined by the gradient.; The only parameter for this method is `Tau`. Low",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:75743,Availability,error,error,75743,"sponding value. Also,; if the string ends with '`!`', output neurons are set up for; classification, i.e. with a sigmoid (1 neuron) or softmax (more; neurons) activation function. Many questions on the good usage of neural network, including rules of; dumb to determine the best network topology are addressed at; <ftp://ftp.sas.com/pub/neural/FAQ.html>. ``` {.cpp}; // a simple network: 2 inputs, 10 hidden and 1 normalized; // output neuron; TMultiLayerPerceptron network(""r,z:10:@Br"",tree);; ```. Expressions are evaluated as for `TTree::Draw()`. Input and outputs; are taken from the **`TTree`** associated with the network. This; **`TTree`** can be given as argument of the constructor or defined; later with `TMultiLayerPerceptron::SetData()`. Events can also be; weighted. The weight expression can be given in the constructor or set; later with the method `SetWeight()` of the class; **`TMultiLayerPerceptron`**. Two datasets must be defined before; learning the network: a training dataset that is used when minimizing; the error, and a test dataset that will avoid bias. Those two datasets; can be built aside and then given to the network, or can be built from; a standard expression. By default, half of the events are put in both; datasets. ``` {.cpp}; // a more complex 4:8:1 network; // the ptsumf branch is used as weigh;; // default event lists are explicit; TMultiLayerPerceptron network(""m,pt,acol,acopl:8:type"",""pt"",tree,; ""Entry$%2"",""Entry$/2"");; ```. The method `TMultiLayerPerceptron::SetLearningMethod()` defines the; learning method. Learning methods are:. ```; TMultiLayerPerceptron::kStochastic,; TMultiLayerPerceptron::kBatch,; TMultiLayerPerceptron::kSteepestDescent,; TMultiLayerPerceptron::kRibierePolak,; TMultiLayerPerceptron::kFletcherReeves,; TMultiLayerPerceptron::kBFGS // default; ```. The training can start with; `TMultiLayerPerceptron::Train(Int_t nepoch,Option_t* options).` The; first argument is the number of epochs while option is a string that; can cont",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:76953,Availability,avail,available,76953," both; datasets. ``` {.cpp}; // a more complex 4:8:1 network; // the ptsumf branch is used as weigh;; // default event lists are explicit; TMultiLayerPerceptron network(""m,pt,acol,acopl:8:type"",""pt"",tree,; ""Entry$%2"",""Entry$/2"");; ```. The method `TMultiLayerPerceptron::SetLearningMethod()` defines the; learning method. Learning methods are:. ```; TMultiLayerPerceptron::kStochastic,; TMultiLayerPerceptron::kBatch,; TMultiLayerPerceptron::kSteepestDescent,; TMultiLayerPerceptron::kRibierePolak,; TMultiLayerPerceptron::kFletcherReeves,; TMultiLayerPerceptron::kBFGS // default; ```. The training can start with; `TMultiLayerPerceptron::Train(Int_t nepoch,Option_t* options).` The; first argument is the number of epochs while option is a string that; can contain ""`text`"" (simple text output), ""`graph`"" (evaluating; graphical training curves), ""`update` `=` `X`"" (step for the; text/graph output update) or ""`+`"" (will skip the randomization and; start from the previous values). All combinations are available. ``` {.cpp}; network.Train(1000,""text,graph,update=10""); // full output every; // 10 epochs; network.Train(100,""text,+""); // 100 more epochs; //starts with existing weights; ```. The weights can be saved to a file (`DumpWeights`) and then reloaded; (`LoadWeights`) to a new compatible network. The output can also be; evaluated (`Evaluate`) for a given output neuron and an array of; double input parameters or the network can be exported (`Export`) as a; standalone code. Up to now, this is only as a C++ or PYTHON class, but; other languages could be implemented. ### Examples. An example of how to use **`TMultiLayerPerceptron`** is the macro; `mlpHiggs.C` in \$ROOTSYS/tutorials. Using some standard simulated; information that could have been obtained at `LEP`, a neural network; is build, which can make the difference between `WW` events and events; containing a Higgs boson. Starting with a **`TFile`** containing two; **`TTree`**s: one for the signal, the other for the backg",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:81350,Availability,recover,recovered,81350,">GetEntry(i);; params[0] = msumf; params[1] = ptsumf;; params[2] = acolin; params[3] = acopl;; bg->Fill(mlp->Evaluate(0,params));; }; for (i = 0; i < signal->GetEntries(); i++) {; signal->GetEntry(i);; params[0] = msumf;; params[1] = ptsumf;; params[2] = acolin;; params[3] = acopl;; sig->Fill(mlp->Evaluate(0,params));; }; TCanvas *cv = new TCanvas(""NNout_cv"",""Neural net output"");; bg->SetFillStyle(3008);; bg->SetFillColor(kBlue);; sig->SetFillStyle(3003);; sig->SetFillColor(kRed);; bg->SetStats(0);; sig->SetStats(0);; bg->Draw();; sig->Draw(""same"");; TLegend *legend = new TLegend(.75,.80,.95,.95);; legend->AddEntry(bg,""Background(WW)"");; legend->AddEntry(sig,""Signal(Higgs)"");; legend->Draw();; ```. The neural net output is then used to display the final difference; between background and signal events. The figure ""The neural net; output"" shows this plot. ![The neural net output](pictures/image144.png). As it can be seen, this is a quite efficient technique. As mentioned; earlier, neural networks are also used for fitting function. For some; application with a cylindrical symmetry, a magnetic field simulation; gives as output the angular component of the potential vector `A`, as; well as the radial and `z` components of the `B` field. One wants to fit those distributions with a function in order to plug; them into the `Geant` simulation code. Polynomial fits could be tried,; but it seems difficult to reach the desired precision over the full; range. One could also use a `spline` interpolation between known; points. In all cases, the resulting field would not be `C`-infinite. An example of output (for Br) is shown. First the initial function can; be seen as the target. Then, the resulting (normalized) neural net; output. In order to ease the learning, the ""normalize output"" was used; here. The initial amplitude can be recovered by multiplying by the; original RMS and then shifting by the original mean. ![The original and the neural net for Br](pictures/image145.jpg); ",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:10234,Deployability,configurat,configuration,10234,"e function object is that it can have a state and reference therefore what-ever other object; the user needs, without using globals. This is an example to define first the function object. ``` {.cpp}; class MyFunctionObject {; public:; // use constructor to customize your function object; MyFunctionObject(......) { ......}. double operator() (double *x, double *p) {; // function implementation using class data members; }; };; ```. and then use it to create the **`TF1`**:. ```{.cpp}; MyFunctionObject fobj(....); // create the function object; TF1 * f = new TF1(""f"",fobj,xmin,xmax,npar); // create TF1 class with n-parameters and range [xmin,xmax]; ```. If using C++11, one can create a **`TF1`** also from a C++ `lambda` function:. ```{.cpp}; // create TF1 class with 2 parameters and range [xmin,xmax] using a lambda; TF1 * f = new TF1(""f"",[](double*x,double*p){return p[0] + p[1]*x[0];},xmin,xmax,2);; ```. ## Configuring the Fit. We will show here some configuration actions that can or must be done; when fitting histogram or graph using the `Fit` method. ### Fixing and Setting Parameters' Bounds. Parameters must be initialized before invoking the `Fit` method. The; setting of the parameter initial values is automatic for the; predefined functions: `poln`, `exp`, `gaus`, and `landau`. You can fix; one or more parameters by specifying the ""B"" option when calling the; `Fit` method. When a function is not predefined, the fit parameters; must be initialized to some value as close as possible to the expected; values before calling the fit function. To set bounds for one parameter, use `TF1::SetParLimits`:. ``` {.cpp}; func->SetParLimits(0,-1,1);; ```. When the lower and upper limits are equal, the parameter is fixed.; Next two statements fix parameter 4 at 10. ``` {.cpp}; func->SetParameter(4,10);; func->SetParLimits(4,10,10);; ```. However, to fix a parameter to 0, one must call the `FixParameter`; function:. ``` {.cpp}; func->SetParameter(4,0);; func->FixParameter(4,0);; ```. ",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:38252,Deployability,configurat,configuration,38252," with respect; to the parameters.; This information might be useful for some types of fits. In this case he needs to provide the function object as a class deriving from the; `ROOT::Math::IParametricGradFunctionMultiDim` interface.; Note that the wrapper class `ROOT::Math::WrappedMultiTF1` implements also the gradient interface, using internally `TF1::GradientPar`,; which is based on numerical differentiation, apart for the case of linear functions (i.e. when `TF1::IsLinear()` is `true`).; The parameter derivatives of the model function can be useful to some minimization algorithms, such as Fumili.; However, in general is better to leave the minimization algorithm (e.g. Minuit) to compute the needed derivatives using its own customised; numerical differentiation algorithm.; In order to not provide to the fitter the parameter derivatives, we explicitly passed in `Fitter::SetFunction` a `false` value. ### Fit Configuration. The configuration of the fit is done via the `ROOT::Fit::FitConfig` class and its contained `ROOT::Fit::ParameterSettings` class.; These are the possible allowed fit configurations:. - setting the initial values of the parameters;; - setting the parameter step sizes;; - setting eventual parameter bounds;; - setting the minimizer library and the particular algorithm to use;; - setting different minimization options (print level, tolerance, max iterations, etc...); - setting the type of parameter errors to compute (parabolic error, Minos errors, re-normalize errors using fitted chi2 values). The initial parameter values can be set directly in the input model function object.; However, for setting parameter bounds and step sizes to values different than the automatically computed ones, one needs to use the `ROOT::Fit::ParameterSetting` class.; This example code will set the lower/upper bounds for the first parameter and a lower bound for the second parameter. ``` {.cpp}; fitter.SetFunction( fitFunction, false);; fitter.Config().ParSettings(0).SetLimit",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:38414,Deployability,configurat,configurations,38414," In this case he needs to provide the function object as a class deriving from the; `ROOT::Math::IParametricGradFunctionMultiDim` interface.; Note that the wrapper class `ROOT::Math::WrappedMultiTF1` implements also the gradient interface, using internally `TF1::GradientPar`,; which is based on numerical differentiation, apart for the case of linear functions (i.e. when `TF1::IsLinear()` is `true`).; The parameter derivatives of the model function can be useful to some minimization algorithms, such as Fumili.; However, in general is better to leave the minimization algorithm (e.g. Minuit) to compute the needed derivatives using its own customised; numerical differentiation algorithm.; In order to not provide to the fitter the parameter derivatives, we explicitly passed in `Fitter::SetFunction` a `false` value. ### Fit Configuration. The configuration of the fit is done via the `ROOT::Fit::FitConfig` class and its contained `ROOT::Fit::ParameterSettings` class.; These are the possible allowed fit configurations:. - setting the initial values of the parameters;; - setting the parameter step sizes;; - setting eventual parameter bounds;; - setting the minimizer library and the particular algorithm to use;; - setting different minimization options (print level, tolerance, max iterations, etc...); - setting the type of parameter errors to compute (parabolic error, Minos errors, re-normalize errors using fitted chi2 values). The initial parameter values can be set directly in the input model function object.; However, for setting parameter bounds and step sizes to values different than the automatically computed ones, one needs to use the `ROOT::Fit::ParameterSetting` class.; This example code will set the lower/upper bounds for the first parameter and a lower bound for the second parameter. ``` {.cpp}; fitter.SetFunction( fitFunction, false);; fitter.Config().ParSettings(0).SetLimits(0,1.E6);; fitter.Config().ParSettings(2).SetLowerLimit(0);; ```. Note that a `ROOT::Fit::P",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:43813,Deployability,configurat,configuration,43813,"mizer type* (`MinimizerOptions::SetMinimizerType(const char *)`) .; * *Minimizer algorithm* (`MinimizerOptions::SetMinimizerAlgorithm(const char *)`).; * *Print Level* (`MinimizerOptions::SetPrintLevel(int )`) to set the verbose printing level (default is 0).; * *Tolerance* (`MinimizerOptions::SetTolerance(double )`) tolerance used to control the iterations.; * *Maximum number of function calls* (`MinimizerOptions::SetMaxFunctionCalls(int )`).; * *Maximum number of iterations* (`MinimizerOptions::SetMaxIterations(int )`). Note that this is not used by *Minuit*; * *FCN Upper value for Error Definition* (`MinimizerOptions::SetErrorDef(double )`). Value in the minimization function used to compute the parameter errors.; The default is to get the uncertainties at the 68% CL is a value of 1 for a chi-squared function minimization and 0.5 for a log-likelihood function.; * *Strategy* (`MinimizerOptions::SetStrategy(int )`), minimization strategy used. For each minimization strategy *Minuit* uses different configuration parameters; (e.g. different requirements in computing derivatives, computing full Hessian (strategy = 2) or an approximate version. The default is a value of 1. In this case the full Hessian matrix; is computed only after the minimization.; * *Precision* (`MinimizerOptions::SetPrecision(double )`). Precision value in the evaluation of the minimization function. Default is numerical double precision. Note that not all the options are implemented by all the minimizers.; For example in *Minuit* is possible to set the maximum number of function calls, but not the maximum number of iterations. The Strategy and the Precision options apply instead only for *Minuit* (and; *Minuit2*). The class supports also setting global default values for the options, by using the static functions `MinimizerOptions::SetDefault...` (for example `MinimizerOptions::SetDefaultPrintLevel(int )`). The; static functions can be also used to set the minimizer options when using `TH1::Fit` o",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:47699,Deployability,configurat,configuration,47699,"nded likelihood fit by passing the optional; *extended* boolean flag as *true*. This method is implemented using the class `LogLikelihoodFCN`; * **Linear Fit**: A linear fit can be selected (no iterative minimization is needed in this case, but using linear algebra algorithms from the *Matrix* library), if the model function is linear in the; parameters. #### Customised Fit methods. Above we described the pre-defined methods used for fitting. A user can also implement its own fitting methods, thus its version of the chi-square or likelihood function he wants to minimize.; In this case, the user does not really need to build as input a `ROOT::Fit` data set and model function as we described before. He can implements its own version of the method function using on its own; data set objects and functions. In this case `ROOT::Fit::Fitter::SetFCN` is used to set the method function and `ROOT::Fit::FitFCN` is used for fitting. The method function can be passed also in `ROOT::Fit::FitFCN`, but in this; case a previously defined fitting configuration is used. The possible type of method functions that are based in `ROOT::Fit::Fitter::SetFCN` are:. * A generic functor object implementing `operator()(const double * p)` where **`p`** is the parameter vectors. In this case one needs to pass the number of parameters,; the function object and optionally a vector of initial parameter values. Other optional parameter include the size of the data sets and a flag specifying if it is a chi2 (least-square fit).; In the last two parameters are given, the `chi2/ndf` can be computed after fitting the data.; ``` {.cpp}; template <class Function>; bool Fitter::SetFCN(unsigned int npar, Function & f,; const double * initialParameters = 0,; unsigned int dataSize=0, bool isChi2Fit = false); ```. * A function object implementing the `ROOT::Math::IBaseFunctionMultiDim` interface:; ``` {.cpp}; bool Fitter::SetFCN(const ROOT::Math::IBaseFunctionMultiDim & f,; const double * initialParameters = 0,; ",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:53074,Deployability,patch,patch,53074,"ng in ROOT.; We have seen before how to configure the `Fitter` class to use different minimization packages; and different minimization options.; When using the `Fit` method the minimization package (and its options) can be selected using the; static methods of the `ROOT::Math::MinimizerOptions` class.; For example to select `Minuit2` instead of `Minuit` for fitting an histogram do:. ``` {.cpp}; ROOT::Math::MinimizerOptions::SetDefaultMinimizer(""Minuit2"");; // fit the histogram histo with the gaussian pre-defined function; histo->Fit(""gaus"");; ```. In the following we will give some brief description of the minimization packages.; The packages all implement the `ROOT::Math::Minimizer` interface which can be use for; finding the minimum of a multi-dimensional function.; The interface is documented in the Mathematical Library Chapter. In addition packages like Minuit or Minuit2 provide their own interfaces. ## MINUIT (Old TMInuit Version). This package was originally written in FORTRAN by Fred James and part; of `PACKLIB` (patch D506). It has been converted to a C++ class by; René Brun. The current implementation in C++ is a straightforward; conversion of the original FORTRAN version. The main changes are:. - The variables in the various `Minuit` labeled common blocks have; been changed to the **`TMinuit`** class data members. - The internal arrays with a maximum dimension depending on the; maximum number of parameters are now data members' arrays with a; dynamic dimension such that one can fit very large problems by; simply initializing the **`TMinuit`** constructor with the maximum; number of parameters. - The include file `Minuit.h` has been commented as much as possible; using existing comments in the code or the printed documentation. - The original `Minuit` subroutines are now member functions. - Constructors and destructor have been added. - Instead of passing the `FCN` function in the argument list, the; addresses of this function is stored as pointer in the d",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:71205,Deployability,continuous,continuous,71205,"classification tasks (signal over background discrimination). A vast; majority of commonly used neural networks are multilayer perceptrons.; This implementation of multilayer perceptrons is inspired from the; `MLPfit` package, which remains one of the fastest tools for neural; networks studies. ### The MLP. The multilayer perceptron is a simple feed-forward network with the; following structure showed on the left. ![](pictures/0300008D.png). It is made of neurons characterized by a bias and weighted links in; between - let's call those links synapses. The input neurons receive; the inputs, normalize them and forward them to the first hidden layer.; Each neuron in any subsequent layer first computes a linear; combination of the outputs of the previous layer. The output of the; neuron is then function of that combination with f being linear for; output neurons or a sigmoid for hidden layers. Such a structure is very useful because of two theorems:. 1- A linear combination of `sigmoids` can approximate any continuous; function. 2- Trained with `output=1` for the signal and 0 for the background,; the approximated function of inputs `X` is the probability of signal,; knowing `X`. ### Learning Methods. The aim of all learning methods is to minimize the total error on a; set of weighted examples. The error is defined as the sum in quadrate,; divided by two, of the error on each individual output neuron. In all; methods implemented in this library, one needs to compute the first; derivative of that error with respect to the weights. Exploiting the; well-known properties of the derivative, one can express this; derivative as the product of the local partial derivative by the; weighted sum of the outputs derivatives (for a neuron) or as the; product of the input value with the local partial derivative of the; output neuron (for a synapse). This computation is called; ""back-propagation of the errors"". Six learning methods are; implemented. #### Stochastic Minimization. This is",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:72320,Deployability,update,updated,72320,"s the probability of signal,; knowing `X`. ### Learning Methods. The aim of all learning methods is to minimize the total error on a; set of weighted examples. The error is defined as the sum in quadrate,; divided by two, of the error on each individual output neuron. In all; methods implemented in this library, one needs to compute the first; derivative of that error with respect to the weights. Exploiting the; well-known properties of the derivative, one can express this; derivative as the product of the local partial derivative by the; weighted sum of the outputs derivatives (for a neuron) or as the; product of the input value with the local partial derivative of the; output neuron (for a synapse). This computation is called; ""back-propagation of the errors"". Six learning methods are; implemented. #### Stochastic Minimization. This is the most trivial learning method. The Robbins-Monro stochastic; approximation is applied to multilayer perceptrons. The weights are; updated after each example according to the formula:. $$; w_{ij}(t+1) = w_{ij}(t) + \Delta w_{ij}(t); $$. with:. $$; \Delta w_{ij}(t) = - \eta \left(; \frac{\partial e_p}{\partial w_{ij}} + \delta \right) +; \epsilon \Delta w_{ij}(t-1); $$. The parameters for this method are `Eta`, `EtaDecay`, `Delta` and; `Epsilon`. #### Steepest Descent With Fixed Step Size (Batch Learning). It is the same as the stochastic minimization, but the weights are; updated after considering all the examples, with the total derivative; `dEdw`. The parameters for this method are `Eta`, `EtaDecay`, `Delta`; and `Epsilon`. #### Steepest Descent Algorithm. Weights are set to the minimum along the line defined by the gradient.; The only parameter for this method is `Tau`. Lower `Tau` = higher; precision = slower search. A value `Tau=3` seems reasonable. #### Conjugate Gradients With the Polak-Ribiere Updating Formula. Weights are set to the minimum along the line defined by the conjugate; gradient. Parameters are `Tau` and `Reset`",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:72768,Deployability,update,updated,72768,"es of the derivative, one can express this; derivative as the product of the local partial derivative by the; weighted sum of the outputs derivatives (for a neuron) or as the; product of the input value with the local partial derivative of the; output neuron (for a synapse). This computation is called; ""back-propagation of the errors"". Six learning methods are; implemented. #### Stochastic Minimization. This is the most trivial learning method. The Robbins-Monro stochastic; approximation is applied to multilayer perceptrons. The weights are; updated after each example according to the formula:. $$; w_{ij}(t+1) = w_{ij}(t) + \Delta w_{ij}(t); $$. with:. $$; \Delta w_{ij}(t) = - \eta \left(; \frac{\partial e_p}{\partial w_{ij}} + \delta \right) +; \epsilon \Delta w_{ij}(t-1); $$. The parameters for this method are `Eta`, `EtaDecay`, `Delta` and; `Epsilon`. #### Steepest Descent With Fixed Step Size (Batch Learning). It is the same as the stochastic minimization, but the weights are; updated after considering all the examples, with the total derivative; `dEdw`. The parameters for this method are `Eta`, `EtaDecay`, `Delta`; and `Epsilon`. #### Steepest Descent Algorithm. Weights are set to the minimum along the line defined by the gradient.; The only parameter for this method is `Tau`. Lower `Tau` = higher; precision = slower search. A value `Tau=3` seems reasonable. #### Conjugate Gradients With the Polak-Ribiere Updating Formula. Weights are set to the minimum along the line defined by the conjugate; gradient. Parameters are `Tau` and `Reset`, which defines the epochs; where the direction is reset to the steepest descent (estimated by; using the Polak-Ribiere formula). #### Conjugate Gradients With the Fletcher-Reeves Updating Formula. Weights are set to the minimum along the line defined by the conjugate; gradient. Parameters are `Tau` and `Reset`, which defines the epochs; where the direction is reset to the steepest descent (estimated by; using the Fletcher-Reeves f",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:76798,Deployability,update,update,76798," avoid bias. Those two datasets; can be built aside and then given to the network, or can be built from; a standard expression. By default, half of the events are put in both; datasets. ``` {.cpp}; // a more complex 4:8:1 network; // the ptsumf branch is used as weigh;; // default event lists are explicit; TMultiLayerPerceptron network(""m,pt,acol,acopl:8:type"",""pt"",tree,; ""Entry$%2"",""Entry$/2"");; ```. The method `TMultiLayerPerceptron::SetLearningMethod()` defines the; learning method. Learning methods are:. ```; TMultiLayerPerceptron::kStochastic,; TMultiLayerPerceptron::kBatch,; TMultiLayerPerceptron::kSteepestDescent,; TMultiLayerPerceptron::kRibierePolak,; TMultiLayerPerceptron::kFletcherReeves,; TMultiLayerPerceptron::kBFGS // default; ```. The training can start with; `TMultiLayerPerceptron::Train(Int_t nepoch,Option_t* options).` The; first argument is the number of epochs while option is a string that; can contain ""`text`"" (simple text output), ""`graph`"" (evaluating; graphical training curves), ""`update` `=` `X`"" (step for the; text/graph output update) or ""`+`"" (will skip the randomization and; start from the previous values). All combinations are available. ``` {.cpp}; network.Train(1000,""text,graph,update=10""); // full output every; // 10 epochs; network.Train(100,""text,+""); // 100 more epochs; //starts with existing weights; ```. The weights can be saved to a file (`DumpWeights`) and then reloaded; (`LoadWeights`) to a new compatible network. The output can also be; evaluated (`Evaluate`) for a given output neuron and an array of; double input parameters or the network can be exported (`Export`) as a; standalone code. Up to now, this is only as a C++ or PYTHON class, but; other languages could be implemented. ### Examples. An example of how to use **`TMultiLayerPerceptron`** is the macro; `mlpHiggs.C` in \$ROOTSYS/tutorials. Using some standard simulated; information that could have been obtained at `LEP`, a neural network; is build, which can make the d",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:76848,Deployability,update,update,76848," avoid bias. Those two datasets; can be built aside and then given to the network, or can be built from; a standard expression. By default, half of the events are put in both; datasets. ``` {.cpp}; // a more complex 4:8:1 network; // the ptsumf branch is used as weigh;; // default event lists are explicit; TMultiLayerPerceptron network(""m,pt,acol,acopl:8:type"",""pt"",tree,; ""Entry$%2"",""Entry$/2"");; ```. The method `TMultiLayerPerceptron::SetLearningMethod()` defines the; learning method. Learning methods are:. ```; TMultiLayerPerceptron::kStochastic,; TMultiLayerPerceptron::kBatch,; TMultiLayerPerceptron::kSteepestDescent,; TMultiLayerPerceptron::kRibierePolak,; TMultiLayerPerceptron::kFletcherReeves,; TMultiLayerPerceptron::kBFGS // default; ```. The training can start with; `TMultiLayerPerceptron::Train(Int_t nepoch,Option_t* options).` The; first argument is the number of epochs while option is a string that; can contain ""`text`"" (simple text output), ""`graph`"" (evaluating; graphical training curves), ""`update` `=` `X`"" (step for the; text/graph output update) or ""`+`"" (will skip the randomization and; start from the previous values). All combinations are available. ``` {.cpp}; network.Train(1000,""text,graph,update=10""); // full output every; // 10 epochs; network.Train(100,""text,+""); // 100 more epochs; //starts with existing weights; ```. The weights can be saved to a file (`DumpWeights`) and then reloaded; (`LoadWeights`) to a new compatible network. The output can also be; evaluated (`Evaluate`) for a given output neuron and an array of; double input parameters or the network can be exported (`Export`) as a; standalone code. Up to now, this is only as a C++ or PYTHON class, but; other languages could be implemented. ### Examples. An example of how to use **`TMultiLayerPerceptron`** is the macro; `mlpHiggs.C` in \$ROOTSYS/tutorials. Using some standard simulated; information that could have been obtained at `LEP`, a neural network; is build, which can make the d",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:77007,Deployability,update,update,77007,"ranch is used as weigh;; // default event lists are explicit; TMultiLayerPerceptron network(""m,pt,acol,acopl:8:type"",""pt"",tree,; ""Entry$%2"",""Entry$/2"");; ```. The method `TMultiLayerPerceptron::SetLearningMethod()` defines the; learning method. Learning methods are:. ```; TMultiLayerPerceptron::kStochastic,; TMultiLayerPerceptron::kBatch,; TMultiLayerPerceptron::kSteepestDescent,; TMultiLayerPerceptron::kRibierePolak,; TMultiLayerPerceptron::kFletcherReeves,; TMultiLayerPerceptron::kBFGS // default; ```. The training can start with; `TMultiLayerPerceptron::Train(Int_t nepoch,Option_t* options).` The; first argument is the number of epochs while option is a string that; can contain ""`text`"" (simple text output), ""`graph`"" (evaluating; graphical training curves), ""`update` `=` `X`"" (step for the; text/graph output update) or ""`+`"" (will skip the randomization and; start from the previous values). All combinations are available. ``` {.cpp}; network.Train(1000,""text,graph,update=10""); // full output every; // 10 epochs; network.Train(100,""text,+""); // 100 more epochs; //starts with existing weights; ```. The weights can be saved to a file (`DumpWeights`) and then reloaded; (`LoadWeights`) to a new compatible network. The output can also be; evaluated (`Evaluate`) for a given output neuron and an array of; double input parameters or the network can be exported (`Export`) as a; standalone code. Up to now, this is only as a C++ or PYTHON class, but; other languages could be implemented. ### Examples. An example of how to use **`TMultiLayerPerceptron`** is the macro; `mlpHiggs.C` in \$ROOTSYS/tutorials. Using some standard simulated; information that could have been obtained at `LEP`, a neural network; is build, which can make the difference between `WW` events and events; containing a Higgs boson. Starting with a **`TFile`** containing two; **`TTree`**s: one for the signal, the other for the background, a; simple script is used:. ``` {.cpp}; void mlpHiggs(Int_t ntrain=100)",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:78929,Deployability,update,update,78929," with a **`TFile`** containing two; **`TTree`**s: one for the signal, the other for the background, a; simple script is used:. ``` {.cpp}; void mlpHiggs(Int_t ntrain=100) {; if (!gROOT->GetClass(""TMultiLayerPerceptron"")); gSystem->Load(""libMLP"");; // prepare inputs - the 2 trees are merged into one, and a; // ""type"" branch, equal to 1 for the signal and 0 for the; // background is added; TFile input(""mlpHiggs.root"");; TTree *signal = (TTree *)input.Get(""sig_filtered"");; TTree *background = (TTree *)input.Get(""bg_filtered"");; TTree *simu = new TTree(""MonteCarlo"",; ""Filtered Monte Carlo Events"");; ...; ```. Since the input is a **`TTree`** and we are starting from two; different **`TTree`**s (with different names), they are first merged; into one, and a ""`type`"" branch is added, that says whether there is; a signal or a background event. Those irrelevant details are skipped; here. ``` {.cpp}; ...; TMultiLayerPerceptron *mlp = new TMultiLayerPerceptron(; ""msumf,ptsumf, acolin, acopl:8:type"",""ptsumf"",simu,; ""Entry$%2"",""Entry$/2"");; mlp->Train(ntrain, ""text,graph,update=10"");; ```. The neural network is instantiated and trained. ""`ptsumf`"" is used as; a weight, and the standard event lists are explicit. The network that; is then build has four input neurons, eight additional ones in the; only hidden layer and one single output neuron. ``` {.cpp}; // Use the NN to plot the results for each sample; TH1F *bg = new TH1F(""bgh"",""NN output"",50,-.5,1.5);; TH1F *sig = new TH1F(""sigh"",""NN output"",50,-.5,1.5);; bg->SetDirectory(0);; sig->SetDirectory(0);; Double_t params[4];; for (i = 0; i < background->GetEntries(); i++) {; background->GetEntry(i);; params[0] = msumf; params[1] = ptsumf;; params[2] = acolin; params[3] = acopl;; bg->Fill(mlp->Evaluate(0,params));; }; for (i = 0; i < signal->GetEntries(); i++) {; signal->GetEntry(i);; params[0] = msumf;; params[1] = ptsumf;; params[2] = acolin;; params[3] = acopl;; sig->Fill(mlp->Evaluate(0,params));; }; TCanvas *cv = new TCanvas(""N",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:316,Energy Efficiency,power,powerful,316,"# Fitting Histograms. To fit a histogram you can use the Fit Panel on a visible histogram; via the context menu, or you can use the `TH1::Fit` method. The; Fit Panel, which is limited, is best for prototyping. The histogram; needs to be drawn in a pad before the Fit Panel is invoked. The method; `TH1::Fit` is more powerful and is used in scripts and programs. ## The Fit Method. The Fit method is implemented in ROOT for the histogram classes **`TH1`**,; the sparse histogram classes, `THnSparse`, the graph classes, `TGraph`,; `TGraph2D` and `TMultiGraph` for fitting a collection of Graphs with the same function. ### The TH1::Fit Method. To fit a histogram programmatically, you can use the `TH1::Fit`; method. Here is the signatures of `TH1::Fit` and an explanation of the; parameters:. ``` {.cpp}; TFitResultPtr Fit(TF1 *function, Option_t *option, Option_t *goption,; Axis_t xxmin, Axis_t xxmax); ```; - `function` a pointer to the fitted function (the fit model) object.; One can also use the function name. This name may be one of ROOT pre-defined; function names or a user-defined function. See the next paragraph for the list of pre-defined functions. - `*option:` The second parameter is the fitting option. Here is the; list of fitting options:. 	- ""`W`"" Set all weights to 1 for non empty bins; ignore error bars. 	- ""`WW`"" Set all weights to 1 including empty bins; ignore error; bars. 	- ""`I`"" Use integral of function in bin instead of value at bin; center. 	- ""`L`"" Use log likelihood method (default is chi-square method). To be used when; the histogram represents counts. 	- ""`WL`"" Weighted log likelihood method. To be used when the histogram has been filled with; 	weights different than 1. - ""`P`"" Use Pearson chi-square method, using expected errors instead of the observed one given by `TH1::GetBinError` (default case).; The expected error is instead estimated from the square-root of the bin function value. 	- ""`Q`"" Quiet mode (minimum printing). 	- ""`V`"" Verbose mode (de",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:5361,Energy Efficiency,adapt,adapted,5361,"tion. To fit a histogram with a predefined function, simply pass the name of; the function in the first parameter of `TH1::Fit`. For example,; this line fits histogram object `hist` with a Gaussian. ``` {.cpp}; root[] hist.Fit(""gaus"");; ```. The initial parameter values (and eventual limits) for pre-defined functions are set; automatically. For overriding the default limits values use the fit option `B`. The list of pre-defined functions that can be used with the `Fit` method is the following:. - ""`gaus`"" Gaussian function with 3 parameters:; `f(x) = p0*exp(-0.5*((x-p1)/p2)^2)`. - ""`expo`""An Exponential with 2 parameters: `f(x) = exp(p0+p1*x)`. - ""`pol`*`N`*"" A polynomial of degree *N*, where N is a number between 0 and 9:; `f(x) = p0 + p1*x + p2*x2 +...`. - ""`chebyshev`*`N`*"" A Chebyshev polynomial of degree *N*, where N is a number between 0 and 9:; `f(x) = p0 + p1*x + p2*(2*x2-1) +...`. - ""`landau`"" Landau function with mean and sigma. This function has; been adapted from the `CERNLIB` routine `G110 denlan` (see `TMath::Landau`). - ""`gausn`"" Normalized form of the gaussian function with 3 parameters; `f(x) = p0*exp(-0.5*((x-p1)/p2)^2)/(p2 *sqrt(2PI))`. ### Creating User-Defined Functions (TF1). You can create a **`TF1`** object and use it in the call the; `TH1::Fit`. The parameter in to the `Fit` method is the NAME of; the **`TF1`** object. There are three ways to create a **`TF1`**. - Using C++ expression using x with a fixed set of operators and; functions defined in **`TFormula`**. - Same as first one, with parameters. - Using a function that you have defined. This can be a free function or; a functor object or a particular member function of a class. #### Creating a TF1 with a Formula. Let's look at the first case. Here we call the **`TF1`** constructor; by giving it the formula: `sin(x)/x`. ``` {.cpp}; root[] TF1 *f1 = new TF1(""f1"",""sin(x)/x"",0,10); ```. You can also use a **`TF1`** object in the constructor of another; **`TF1`**. ``` {.cpp}; root[] TF1 *f2 ",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:73903,Energy Efficiency,power,powerful,73903,"ecay`, `Delta`; and `Epsilon`. #### Steepest Descent Algorithm. Weights are set to the minimum along the line defined by the gradient.; The only parameter for this method is `Tau`. Lower `Tau` = higher; precision = slower search. A value `Tau=3` seems reasonable. #### Conjugate Gradients With the Polak-Ribiere Updating Formula. Weights are set to the minimum along the line defined by the conjugate; gradient. Parameters are `Tau` and `Reset`, which defines the epochs; where the direction is reset to the steepest descent (estimated by; using the Polak-Ribiere formula). #### Conjugate Gradients With the Fletcher-Reeves Updating Formula. Weights are set to the minimum along the line defined by the conjugate; gradient. Parameters are `Tau` and `Reset`, which defines the epochs; where the direction is reset to the steepest descent (estimated by; using the Fletcher-Reeves formula). #### The Broyden, Fletcher, Goldfarb, Shanno (BFGS) Method. It implies the computation of a `NxN` matrix, but seems more powerful; at least for less than 300 weights. Parameters are `Tau` and `Reset`,; which defines the epochs where the direction is reset to the steepest; descent. ### Using the Network. Neural network are build from a set of ""samples"". A sample is a set of; values defining the inputs and the corresponding output that the; network should ideally provide. In ROOT this is a **`TTree`** entry.; The first thing to be decided is the network layout. This layout is; described in a string where the layers are separated by semicolons.; The input/output layers are defined by giving the expression for each; neuron, separated by comas. Hidden layers are just described by the; number of neurons. In addition, input and output layer formulas can be preceded by '@'; (e.g. ""@out"") if one wants to normalize the corresponding value. Also,; if the string ends with '`!`', output neurons are set up for; classification, i.e. with a sigmoid (1 neuron) or softmax (more; neurons) activation function. Many ",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:80453,Energy Efficiency,efficient,efficient,80453,"(i = 0; i < background->GetEntries(); i++) {; background->GetEntry(i);; params[0] = msumf; params[1] = ptsumf;; params[2] = acolin; params[3] = acopl;; bg->Fill(mlp->Evaluate(0,params));; }; for (i = 0; i < signal->GetEntries(); i++) {; signal->GetEntry(i);; params[0] = msumf;; params[1] = ptsumf;; params[2] = acolin;; params[3] = acopl;; sig->Fill(mlp->Evaluate(0,params));; }; TCanvas *cv = new TCanvas(""NNout_cv"",""Neural net output"");; bg->SetFillStyle(3008);; bg->SetFillColor(kBlue);; sig->SetFillStyle(3003);; sig->SetFillColor(kRed);; bg->SetStats(0);; sig->SetStats(0);; bg->Draw();; sig->Draw(""same"");; TLegend *legend = new TLegend(.75,.80,.95,.95);; legend->AddEntry(bg,""Background(WW)"");; legend->AddEntry(sig,""Signal(Higgs)"");; legend->Draw();; ```. The neural net output is then used to display the final difference; between background and signal events. The figure ""The neural net; output"" shows this plot. ![The neural net output](pictures/image144.png). As it can be seen, this is a quite efficient technique. As mentioned; earlier, neural networks are also used for fitting function. For some; application with a cylindrical symmetry, a magnetic field simulation; gives as output the angular component of the potential vector `A`, as; well as the radial and `z` components of the `B` field. One wants to fit those distributions with a function in order to plug; them into the `Geant` simulation code. Polynomial fits could be tried,; but it seems difficult to reach the desired precision over the full; range. One could also use a `spline` interpolation between known; points. In all cases, the resulting field would not be `C`-infinite. An example of output (for Br) is shown. First the initial function can; be seen as the target. Then, the resulting (normalized) neural net; output. In order to ease the learning, the ""normalize output"" was used; here. The initial amplitude can be recovered by multiplying by the; original RMS and then shifting by the original mean. ![The ori",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:5388,Integrability,rout,routine,5388,"tion. To fit a histogram with a predefined function, simply pass the name of; the function in the first parameter of `TH1::Fit`. For example,; this line fits histogram object `hist` with a Gaussian. ``` {.cpp}; root[] hist.Fit(""gaus"");; ```. The initial parameter values (and eventual limits) for pre-defined functions are set; automatically. For overriding the default limits values use the fit option `B`. The list of pre-defined functions that can be used with the `Fit` method is the following:. - ""`gaus`"" Gaussian function with 3 parameters:; `f(x) = p0*exp(-0.5*((x-p1)/p2)^2)`. - ""`expo`""An Exponential with 2 parameters: `f(x) = exp(p0+p1*x)`. - ""`pol`*`N`*"" A polynomial of degree *N*, where N is a number between 0 and 9:; `f(x) = p0 + p1*x + p2*x2 +...`. - ""`chebyshev`*`N`*"" A Chebyshev polynomial of degree *N*, where N is a number between 0 and 9:; `f(x) = p0 + p1*x + p2*(2*x2-1) +...`. - ""`landau`"" Landau function with mean and sigma. This function has; been adapted from the `CERNLIB` routine `G110 denlan` (see `TMath::Landau`). - ""`gausn`"" Normalized form of the gaussian function with 3 parameters; `f(x) = p0*exp(-0.5*((x-p1)/p2)^2)/(p2 *sqrt(2PI))`. ### Creating User-Defined Functions (TF1). You can create a **`TF1`** object and use it in the call the; `TH1::Fit`. The parameter in to the `Fit` method is the NAME of; the **`TF1`** object. There are three ways to create a **`TF1`**. - Using C++ expression using x with a fixed set of operators and; functions defined in **`TFormula`**. - Same as first one, with parameters. - Using a function that you have defined. This can be a free function or; a functor object or a particular member function of a class. #### Creating a TF1 with a Formula. Let's look at the first case. Here we call the **`TF1`** constructor; by giving it the formula: `sin(x)/x`. ``` {.cpp}; root[] TF1 *f1 = new TF1(""f1"",""sin(x)/x"",0,10); ```. You can also use a **`TF1`** object in the constructor of another; **`TF1`**. ``` {.cpp}; root[] TF1 *f2 ",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:20341,Integrability,interface,interface,20341,"h 8.5.2 of the book,; *F. James, Statistical Methods in Experimental Physics, 2nd Edition*. ### Fit Statistics. You can change the statistics box to display the fit parameters with the; `TStyle::SetOptFit(mode)` method. This parameter has four digits:; `mode = pcev` (`default = 0111`). - `p` = 1 print probability; - `c` = 1 print Chi-square/number of degrees of freedom; - `e` = 1 print errors (if `e=1`, `v` must be 1); - `v` = 1 print name/values of parameters. For example, to print the fit probability, parameter names/values, and; errors, use:. ``` {.cpp}; gStyle->SetOptFit(1011);; ```. ## The Fit Panel. ![The Fit Panel](pictures/03000061.png). To display the Fit Panel right click on a histogram to pop up the; context menu, and then select the menu entry Fit Panel. The new Fit Panel GUI is available in ROOT v5.14. Its goal is to; replace the old Fit Panel and to provide more user friendly way for; performing, exploring and comparing fits. By design, this user interface is planned to contain two tabs:; ""General"" and ""Minimization"". Currently, the ""General"" tab provides; user interface elements for setting the fit function, fit method and; different fit, draw, print options.; The ""Minimization tab"" provides the option to set the Minimizer to use in the fit and; its specific options. The new fit panel is a modeless dialog, i.e. when opened, it does not; prevent users from interacting with other windows. Its first prototype; is a singleton application. When the Fit Panel is activated, users can; select an object for fitting in the usual way, i.e. by left-mouse; click on it. If the selected object is suitable for fitting, the fit; panel is connected with this object and users can perform fits by; setting different parameters and options. ### Function Choice and Settings. *‘Predefined' combo box* - contains a list of predefined functions in; ROOT. You have a choice of several polynomials, a Gaussian, a Landau,; and an Exponential function. The default one is Gaussian. *‘",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:20458,Integrability,interface,interface,20458," change the statistics box to display the fit parameters with the; `TStyle::SetOptFit(mode)` method. This parameter has four digits:; `mode = pcev` (`default = 0111`). - `p` = 1 print probability; - `c` = 1 print Chi-square/number of degrees of freedom; - `e` = 1 print errors (if `e=1`, `v` must be 1); - `v` = 1 print name/values of parameters. For example, to print the fit probability, parameter names/values, and; errors, use:. ``` {.cpp}; gStyle->SetOptFit(1011);; ```. ## The Fit Panel. ![The Fit Panel](pictures/03000061.png). To display the Fit Panel right click on a histogram to pop up the; context menu, and then select the menu entry Fit Panel. The new Fit Panel GUI is available in ROOT v5.14. Its goal is to; replace the old Fit Panel and to provide more user friendly way for; performing, exploring and comparing fits. By design, this user interface is planned to contain two tabs:; ""General"" and ""Minimization"". Currently, the ""General"" tab provides; user interface elements for setting the fit function, fit method and; different fit, draw, print options.; The ""Minimization tab"" provides the option to set the Minimizer to use in the fit and; its specific options. The new fit panel is a modeless dialog, i.e. when opened, it does not; prevent users from interacting with other windows. Its first prototype; is a singleton application. When the Fit Panel is activated, users can; select an object for fitting in the usual way, i.e. by left-mouse; click on it. If the selected object is suitable for fitting, the fit; panel is connected with this object and users can perform fits by; setting different parameters and options. ### Function Choice and Settings. *‘Predefined' combo box* - contains a list of predefined functions in; ROOT. You have a choice of several polynomials, a Gaussian, a Landau,; and an Exponential function. The default one is Gaussian. *‘Operation' radio button group* defines the selected operational mode; between functions:. *Nop* - no operation (default)",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:21743,Integrability,message,message,21743,"s not; prevent users from interacting with other windows. Its first prototype; is a singleton application. When the Fit Panel is activated, users can; select an object for fitting in the usual way, i.e. by left-mouse; click on it. If the selected object is suitable for fitting, the fit; panel is connected with this object and users can perform fits by; setting different parameters and options. ### Function Choice and Settings. *‘Predefined' combo box* - contains a list of predefined functions in; ROOT. You have a choice of several polynomials, a Gaussian, a Landau,; and an Exponential function. The default one is Gaussian. *‘Operation' radio button group* defines the selected operational mode; between functions:. *Nop* - no operation (default);. *Add* - addition;. *Conv* - convolution (will be implemented in the future). Users can enter the function expression into the text entry field; below the ‘Predefined' combo box. The entered string is checked after; the Enter key was pressed and an error message shows up, if the; function string is not accepted. ‘*Set Parameters*' button opens a dialog for parameters settings,; which will be explained later. ### Fitter Settings. *‘Method' combo box* currently provides only two fit model choices:; Chi-square and Binned Likelihood. The default one is Chi-square. The; Binned Likelihood is recommended for bins with low statistics. *‘Linear Fit' check button* sets the use of Linear fitter when is; selected. Otherwise the minimization is done by Minuit, i.e. fit; option ""`F`"" is applied. The Linear fitter can be selected only for; functions linear in parameters (for example - `polN)`. *‘Robust' number entry* sets the robust value when fitting graphs. *‘No Chi-square' check button* switch On/Off the fit option ""`C`"" -; do not calculate Chi-square (for Linear fitter). *‘Integral' check button* switch On/Off the option ""`I`"" - use; integral of function instead of value in bin center. *‘Best Errors'* sets On/Off the option ""`E`"" - bette",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:25734,Integrability,interface,interface,25734,"cted by the ""Advanced Drawing Tool"" panel that pops up when clicking the ""Advanced"" button, are:. * *Contour*: to plot the confidence contour of two chosen parameters. One can select the number of points to draw the contour; (more points might require more time to compute it), the parameters and the desired confidence level . * *Scan* : to plot a scan of the minimization function (likelihood or chi-squared) around the minimum as function of the chosen parameter. * *Conf Interval* : to plot the confidence interval of the fitted function as a filled coloured band around its central value.; One can select the desired confidence level for the band to be plotted. ### Print Options. This set of options specifies the amount of feedback printed on the; root command line after performed fits. *‘Verbose'* - prints fit results after each iteration. *‘Quiet'* - no fit information is printed. *‘Default'* - between Verbose and Quiet. ### Command Buttons. *Fit button* - performs a fit taking different option settings via the; Fit Panel interface. *Reset* - sets the GUI elements and related fit settings to the; default ones. *Close* - closes the Fit panel window. ### Minimization Options. With this tab one can select specific options for minimization. These include. * The minimizer library ( *Minuit*, *Minuit2*, *Fumili*, *GSL*, *Genetics* ); * The method (algorithm) for minimization. For example for Minuit one can choose between (*Migrad*, *Simplex* or *Scan*); * Error definition; * Minimization tolerance; * Number of iterations/function calls; * Print Level: (*Default*, *Verbose* or *Quiet*). ## New ROOT::Fit classes. The fitting of the data objects in ROOT, histograms, graphs and tree is performed via some common classes,; which are defined in the `ROOT::Fit` namespace.; These classes can be classified in the following groups:. * User classes driving the fit: `ROOT::Fit::Fitter` for executing the fit, `ROOT::Fit::FitConfig` for configuring the fit,; 	`ROOT::Fit::ParameterSettings",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:27695,Integrability,interface,interface,27695,"eterSettings` to define the properties of the fit parameters (initial; 	values, bounds, etc..), `ROOT::Fit::FitResult` for storing the result of the fit.; * Data classes containing the data sets used in the fitting. These classes are the`ROOT::Fit::BinData`for describing bin data sets,; 	 thus data points containing both coordinates and a corresponding value/weight; 	 with optionally an error on the value or the coordinate and the `ROOT::Fit::UnBinData` for un-binned data sets,; 	 which consists only of a vector of coordinate values. The coordinate values can be; 	 one-dimensional (i.e. one entry per event) or multi-dimensional (N entries per event).; * Function classes defining the type of fit (the objective function used for fitting):; 	- `ROOT::Fit::Chi2FCN` for chi2 (least-square fits),; 	- `ROOT::Fit::PoissonLikelihoodFCN` for binned likelihood fits of histograms,; 	- `ROOT::Fit::LogLikelihoodFCN` for generic un-binned likelihood fits.; 	These classes are templated on the type of function interface they implement (see later). User convenient typedefs are also provided.; 	They derive from the common generic interface multi-dimensional for function evaluation, `ROOT::Math::IBaseFunctionMultiDim`. In addition the fitter classes make uses of the generic interfaces for parametric function evaluations, `ROOT::Math::IParametricFunctionMultiDim`; to define the fit model function and use the `ROOT::Math::Minimizer` interface to perform the minimization of the objective function.; More information about the function interface and the multi-dimensional minimization in ROOT is given in the Mathematical Library chapter. Here we present a detailed description of the `ROOT::Fit` classes and how to use them.; Using these classes instead of the interface provided directly in the ROOT data objects, like `TH1::Fit` allow are more fine control; to configure and customise the fits. For example, using these classes a combined fit of several histograms can be performed. To understand",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:27815,Integrability,interface,interface,27815," * Data classes containing the data sets used in the fitting. These classes are the`ROOT::Fit::BinData`for describing bin data sets,; 	 thus data points containing both coordinates and a corresponding value/weight; 	 with optionally an error on the value or the coordinate and the `ROOT::Fit::UnBinData` for un-binned data sets,; 	 which consists only of a vector of coordinate values. The coordinate values can be; 	 one-dimensional (i.e. one entry per event) or multi-dimensional (N entries per event).; * Function classes defining the type of fit (the objective function used for fitting):; 	- `ROOT::Fit::Chi2FCN` for chi2 (least-square fits),; 	- `ROOT::Fit::PoissonLikelihoodFCN` for binned likelihood fits of histograms,; 	- `ROOT::Fit::LogLikelihoodFCN` for generic un-binned likelihood fits.; 	These classes are templated on the type of function interface they implement (see later). User convenient typedefs are also provided.; 	They derive from the common generic interface multi-dimensional for function evaluation, `ROOT::Math::IBaseFunctionMultiDim`. In addition the fitter classes make uses of the generic interfaces for parametric function evaluations, `ROOT::Math::IParametricFunctionMultiDim`; to define the fit model function and use the `ROOT::Math::Minimizer` interface to perform the minimization of the objective function.; More information about the function interface and the multi-dimensional minimization in ROOT is given in the Mathematical Library chapter. Here we present a detailed description of the `ROOT::Fit` classes and how to use them.; Using these classes instead of the interface provided directly in the ROOT data objects, like `TH1::Fit` allow are more fine control; to configure and customise the fits. For example, using these classes a combined fit of several histograms can be performed. To understand how these class work, let's go through a simple example, such as fitting an histogram. When fitting an histogram, instead of using `TH1::Fit` we will sho",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:27961,Integrability,interface,interfaces,27961,"ue/weight; 	 with optionally an error on the value or the coordinate and the `ROOT::Fit::UnBinData` for un-binned data sets,; 	 which consists only of a vector of coordinate values. The coordinate values can be; 	 one-dimensional (i.e. one entry per event) or multi-dimensional (N entries per event).; * Function classes defining the type of fit (the objective function used for fitting):; 	- `ROOT::Fit::Chi2FCN` for chi2 (least-square fits),; 	- `ROOT::Fit::PoissonLikelihoodFCN` for binned likelihood fits of histograms,; 	- `ROOT::Fit::LogLikelihoodFCN` for generic un-binned likelihood fits.; 	These classes are templated on the type of function interface they implement (see later). User convenient typedefs are also provided.; 	They derive from the common generic interface multi-dimensional for function evaluation, `ROOT::Math::IBaseFunctionMultiDim`. In addition the fitter classes make uses of the generic interfaces for parametric function evaluations, `ROOT::Math::IParametricFunctionMultiDim`; to define the fit model function and use the `ROOT::Math::Minimizer` interface to perform the minimization of the objective function.; More information about the function interface and the multi-dimensional minimization in ROOT is given in the Mathematical Library chapter. Here we present a detailed description of the `ROOT::Fit` classes and how to use them.; Using these classes instead of the interface provided directly in the ROOT data objects, like `TH1::Fit` allow are more fine control; to configure and customise the fits. For example, using these classes a combined fit of several histograms can be performed. To understand how these class work, let's go through a simple example, such as fitting an histogram. When fitting an histogram, instead of using `TH1::Fit` we will show in the following hot wo use the `ROOT::Fit` classes.; We will show how to perform the following different type of fits with the histogram data:; * a least square fit using the observed errors (Neyman chi",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:28121,Integrability,interface,interface,28121,"ue/weight; 	 with optionally an error on the value or the coordinate and the `ROOT::Fit::UnBinData` for un-binned data sets,; 	 which consists only of a vector of coordinate values. The coordinate values can be; 	 one-dimensional (i.e. one entry per event) or multi-dimensional (N entries per event).; * Function classes defining the type of fit (the objective function used for fitting):; 	- `ROOT::Fit::Chi2FCN` for chi2 (least-square fits),; 	- `ROOT::Fit::PoissonLikelihoodFCN` for binned likelihood fits of histograms,; 	- `ROOT::Fit::LogLikelihoodFCN` for generic un-binned likelihood fits.; 	These classes are templated on the type of function interface they implement (see later). User convenient typedefs are also provided.; 	They derive from the common generic interface multi-dimensional for function evaluation, `ROOT::Math::IBaseFunctionMultiDim`. In addition the fitter classes make uses of the generic interfaces for parametric function evaluations, `ROOT::Math::IParametricFunctionMultiDim`; to define the fit model function and use the `ROOT::Math::Minimizer` interface to perform the minimization of the objective function.; More information about the function interface and the multi-dimensional minimization in ROOT is given in the Mathematical Library chapter. Here we present a detailed description of the `ROOT::Fit` classes and how to use them.; Using these classes instead of the interface provided directly in the ROOT data objects, like `TH1::Fit` allow are more fine control; to configure and customise the fits. For example, using these classes a combined fit of several histograms can be performed. To understand how these class work, let's go through a simple example, such as fitting an histogram. When fitting an histogram, instead of using `TH1::Fit` we will show in the following hot wo use the `ROOT::Fit` classes.; We will show how to perform the following different type of fits with the histogram data:; * a least square fit using the observed errors (Neyman chi",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:28223,Integrability,interface,interface,28223," 	 one-dimensional (i.e. one entry per event) or multi-dimensional (N entries per event).; * Function classes defining the type of fit (the objective function used for fitting):; 	- `ROOT::Fit::Chi2FCN` for chi2 (least-square fits),; 	- `ROOT::Fit::PoissonLikelihoodFCN` for binned likelihood fits of histograms,; 	- `ROOT::Fit::LogLikelihoodFCN` for generic un-binned likelihood fits.; 	These classes are templated on the type of function interface they implement (see later). User convenient typedefs are also provided.; 	They derive from the common generic interface multi-dimensional for function evaluation, `ROOT::Math::IBaseFunctionMultiDim`. In addition the fitter classes make uses of the generic interfaces for parametric function evaluations, `ROOT::Math::IParametricFunctionMultiDim`; to define the fit model function and use the `ROOT::Math::Minimizer` interface to perform the minimization of the objective function.; More information about the function interface and the multi-dimensional minimization in ROOT is given in the Mathematical Library chapter. Here we present a detailed description of the `ROOT::Fit` classes and how to use them.; Using these classes instead of the interface provided directly in the ROOT data objects, like `TH1::Fit` allow are more fine control; to configure and customise the fits. For example, using these classes a combined fit of several histograms can be performed. To understand how these class work, let's go through a simple example, such as fitting an histogram. When fitting an histogram, instead of using `TH1::Fit` we will show in the following hot wo use the `ROOT::Fit` classes.; We will show how to perform the following different type of fits with the histogram data:; * a least square fit using the observed errors (Neyman chi-squared);; * a least square fit using the expected errors from the function (Pearson chi-squared);; * a binned likelihood fit;; * an extended unbinned likelihood fits, if the histogram has been set to store in",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:28449,Integrability,interface,interface,28449,":Fit::PoissonLikelihoodFCN` for binned likelihood fits of histograms,; 	- `ROOT::Fit::LogLikelihoodFCN` for generic un-binned likelihood fits.; 	These classes are templated on the type of function interface they implement (see later). User convenient typedefs are also provided.; 	They derive from the common generic interface multi-dimensional for function evaluation, `ROOT::Math::IBaseFunctionMultiDim`. In addition the fitter classes make uses of the generic interfaces for parametric function evaluations, `ROOT::Math::IParametricFunctionMultiDim`; to define the fit model function and use the `ROOT::Math::Minimizer` interface to perform the minimization of the objective function.; More information about the function interface and the multi-dimensional minimization in ROOT is given in the Mathematical Library chapter. Here we present a detailed description of the `ROOT::Fit` classes and how to use them.; Using these classes instead of the interface provided directly in the ROOT data objects, like `TH1::Fit` allow are more fine control; to configure and customise the fits. For example, using these classes a combined fit of several histograms can be performed. To understand how these class work, let's go through a simple example, such as fitting an histogram. When fitting an histogram, instead of using `TH1::Fit` we will show in the following hot wo use the `ROOT::Fit` classes.; We will show how to perform the following different type of fits with the histogram data:; * a least square fit using the observed errors (Neyman chi-squared);; * a least square fit using the expected errors from the function (Pearson chi-squared);; * a binned likelihood fit;; * an extended unbinned likelihood fits, if the histogram has been set to store in the buffer the original data used to fill it. Let's go through all the steps required for performing these fits using the `ROOT::Fit::Fitter` class.; These steps are:; 1. Create the input fit data object.; 2. Create the input model function.;",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:33787,Integrability,wrap,wrapper,33787," used when they are available,; // e.g. fitting a TGraphAsymmErrors).; ```. The `ROOT::Fit::DataRange` class supports defining multiple rectangular ranges in each dimension, and supports n-dimension.; The function `DataRange::AddRange(icoord,xmin,xmax)` adds a range in; the coordinate `icoord` with lower value `xmin` and upper value `xmax`:. ``` {.cpp}; ROOT::Fit::DataRange range;; range.AddRange(icoordinate, xmin, xmax);; ```. #### Using Un-Binned data. The unbinned data sets are represented with the `ROOT::Fit::UnBinData` class.; For creating un-binned data sets, a `ROOT::Fit::UnBinData` object, one has two possibilities:; 1. Copy the data inside `ROOT::Fit::UnBinData`. One can create an empty `UnBinData` object, iterate on the data and add the data point one by one, or directly create the `UnBinData`; object from a data iterator. In this case an input `ROOT::Fit::DataRange` object is passed in order to copy the data according to the given range.; 2. Use `ROOT::Fit::UnBinData` as a wrapper to an external data storage. In this case the `UnBinData` object is created from an iterator or pointers to the data and the data are not copied; inside. In this case the data cannot be selected according to a specified range. All the data points will be included in the fit. The `ROOT::Fit::UnBinData` class supports also weighted data. In addition to the data points (coordinates), which can be of arbitrary `k` dimensions, the class can be constructed from a vector of; weights. This is an example of taking data from an histogram buffer of a **`TH1`** object:. ``` {.cpp}; 	double * buffer = histogram->GetBuffer();; 	// number of entry is first entry in the buffer; 	int n = buffer[0];; 	// when creating the data object it is important to create with the size of the data; 	ROOT::Fit::UnBinData data(n);; 	for (int i = 0; i < n; ++i); 		data.add(buffer[2*i+1]); // the buffer of 1D histogram contains nevt,x1,w1,x2,w2,......; ```. Instead in this example we will create a 2-dim `UnBinData",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:35468,Integrability,depend,dependent,35468,"togram->GetBuffer();; 	// number of entry is first entry in the buffer; 	int n = buffer[0];; 	// when creating the data object it is important to create with the size of the data; 	ROOT::Fit::UnBinData data(n);; 	for (int i = 0; i < n; ++i); 		data.add(buffer[2*i+1]); // the buffer of 1D histogram contains nevt,x1,w1,x2,w2,......; ```. Instead in this example we will create a 2-dim `UnBinData` object with the contents from a ROOT `TTree`. ``` {.cpp}; TFile * file = TFile::Open(""hsimple.root"");; TTree *ntuple = 0; file->GetObject(""ntuple"",ntuple);; 	// select from the tree the data we want to use for fitting; 	// we use TTree::Draw for this; 	int nevt = ntuple->Draw(""px:py"","""",""goff"");; 	double * x = ntuple->GetV1();; 	double * y = ntuple->GetV2();; ROOT::Fit::UnBinData data(nevt, x, y );; ```. ### Creating the Fit model. In order to fit a data sets we need a model to describe our data, e.g. a probability density function describing our observed data or; an hypothetical function describing the relation between the independent variables **`X`** and the single dependent variable `Y`.; We can have an arbitrary number `k` of independent variables. For example, when fitting a `k`-dimensional histogram,; the independent variables **`X`** are the bin center coordinates and `Y` is the bin weight. The model function needs to be expressed as function of some unknown parameters. The fitting will find the best parameter value to describe; the observed data. We can use the ROOT **`TF1`** class, the parametric function class, to describe the model function. However the `ROOT::Fit::Fitter` class, to be independent of the ROOT *`Hist`* library,; takes as input a more general parametric function object, the interface (abstract) class `ROOT::Math::IParametricFunctionMultiDim`, which describe a generic one or multi-dimensional function; with parameters. This interface extends the abstract class `ROOT::Math::IBaseFunctionMultiDim`, with methods to set/retrieve parameter values and to ev",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:36113,Integrability,interface,interface,36113,">GetV1();; 	double * y = ntuple->GetV2();; ROOT::Fit::UnBinData data(nevt, x, y );; ```. ### Creating the Fit model. In order to fit a data sets we need a model to describe our data, e.g. a probability density function describing our observed data or; an hypothetical function describing the relation between the independent variables **`X`** and the single dependent variable `Y`.; We can have an arbitrary number `k` of independent variables. For example, when fitting a `k`-dimensional histogram,; the independent variables **`X`** are the bin center coordinates and `Y` is the bin weight. The model function needs to be expressed as function of some unknown parameters. The fitting will find the best parameter value to describe; the observed data. We can use the ROOT **`TF1`** class, the parametric function class, to describe the model function. However the `ROOT::Fit::Fitter` class, to be independent of the ROOT *`Hist`* library,; takes as input a more general parametric function object, the interface (abstract) class `ROOT::Math::IParametricFunctionMultiDim`, which describe a generic one or multi-dimensional function; with parameters. This interface extends the abstract class `ROOT::Math::IBaseFunctionMultiDim`, with methods to set/retrieve parameter values and to evaluate the function given the; independent vector of values **`X`** and vector of parameters `P`.; More information about the different `ROOT::Math` function interfaces is available in the Mathematical Library chapter. An end-user can convert a **`TF1`** object in a `ROOT::Math::IParametricFunctionMultiDim`, using the wrapper class `ROOT::Math::WrapperMultiTF1`:. ``` {.cpp}; TF1 * f1 = new TF1(""f1"",""gaus"");; ROOT::Math::WrappedMultiTF1 fitFunction(f1, f1->GetNdim() );; ROOT::Fit::Fitter fitter;; fitter.SetFunction( fitFunction, false);; ```. When creating the wrapper, the parameter values stored in **`TF1`** will be copied in the `ROOT::Math::WrappedMultiTF1` object.; The function object representing the mod",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:36265,Integrability,interface,interface,36265,"al function describing the relation between the independent variables **`X`** and the single dependent variable `Y`.; We can have an arbitrary number `k` of independent variables. For example, when fitting a `k`-dimensional histogram,; the independent variables **`X`** are the bin center coordinates and `Y` is the bin weight. The model function needs to be expressed as function of some unknown parameters. The fitting will find the best parameter value to describe; the observed data. We can use the ROOT **`TF1`** class, the parametric function class, to describe the model function. However the `ROOT::Fit::Fitter` class, to be independent of the ROOT *`Hist`* library,; takes as input a more general parametric function object, the interface (abstract) class `ROOT::Math::IParametricFunctionMultiDim`, which describe a generic one or multi-dimensional function; with parameters. This interface extends the abstract class `ROOT::Math::IBaseFunctionMultiDim`, with methods to set/retrieve parameter values and to evaluate the function given the; independent vector of values **`X`** and vector of parameters `P`.; More information about the different `ROOT::Math` function interfaces is available in the Mathematical Library chapter. An end-user can convert a **`TF1`** object in a `ROOT::Math::IParametricFunctionMultiDim`, using the wrapper class `ROOT::Math::WrapperMultiTF1`:. ``` {.cpp}; TF1 * f1 = new TF1(""f1"",""gaus"");; ROOT::Math::WrappedMultiTF1 fitFunction(f1, f1->GetNdim() );; ROOT::Fit::Fitter fitter;; fitter.SetFunction( fitFunction, false);; ```. When creating the wrapper, the parameter values stored in **`TF1`** will be copied in the `ROOT::Math::WrappedMultiTF1` object.; The function object representing the model function is given to the `ROOT::Fitter` class using the `Fitter::SetFunction` method. The user has also the possibility to provide a function object, which implements the derivatives of the function with respect; to the parameters.; This information might be us",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:36552,Integrability,interface,interfaces,36552,"es. For example, when fitting a `k`-dimensional histogram,; the independent variables **`X`** are the bin center coordinates and `Y` is the bin weight. The model function needs to be expressed as function of some unknown parameters. The fitting will find the best parameter value to describe; the observed data. We can use the ROOT **`TF1`** class, the parametric function class, to describe the model function. However the `ROOT::Fit::Fitter` class, to be independent of the ROOT *`Hist`* library,; takes as input a more general parametric function object, the interface (abstract) class `ROOT::Math::IParametricFunctionMultiDim`, which describe a generic one or multi-dimensional function; with parameters. This interface extends the abstract class `ROOT::Math::IBaseFunctionMultiDim`, with methods to set/retrieve parameter values and to evaluate the function given the; independent vector of values **`X`** and vector of parameters `P`.; More information about the different `ROOT::Math` function interfaces is available in the Mathematical Library chapter. An end-user can convert a **`TF1`** object in a `ROOT::Math::IParametricFunctionMultiDim`, using the wrapper class `ROOT::Math::WrapperMultiTF1`:. ``` {.cpp}; TF1 * f1 = new TF1(""f1"",""gaus"");; ROOT::Math::WrappedMultiTF1 fitFunction(f1, f1->GetNdim() );; ROOT::Fit::Fitter fitter;; fitter.SetFunction( fitFunction, false);; ```. When creating the wrapper, the parameter values stored in **`TF1`** will be copied in the `ROOT::Math::WrappedMultiTF1` object.; The function object representing the model function is given to the `ROOT::Fitter` class using the `Fitter::SetFunction` method. The user has also the possibility to provide a function object, which implements the derivatives of the function with respect; to the parameters.; This information might be useful for some types of fits. In this case he needs to provide the function object as a class deriving from the; `ROOT::Math::IParametricGradFunctionMultiDim` interface.; Note th",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:36714,Integrability,wrap,wrapper,36714,"s the bin weight. The model function needs to be expressed as function of some unknown parameters. The fitting will find the best parameter value to describe; the observed data. We can use the ROOT **`TF1`** class, the parametric function class, to describe the model function. However the `ROOT::Fit::Fitter` class, to be independent of the ROOT *`Hist`* library,; takes as input a more general parametric function object, the interface (abstract) class `ROOT::Math::IParametricFunctionMultiDim`, which describe a generic one or multi-dimensional function; with parameters. This interface extends the abstract class `ROOT::Math::IBaseFunctionMultiDim`, with methods to set/retrieve parameter values and to evaluate the function given the; independent vector of values **`X`** and vector of parameters `P`.; More information about the different `ROOT::Math` function interfaces is available in the Mathematical Library chapter. An end-user can convert a **`TF1`** object in a `ROOT::Math::IParametricFunctionMultiDim`, using the wrapper class `ROOT::Math::WrapperMultiTF1`:. ``` {.cpp}; TF1 * f1 = new TF1(""f1"",""gaus"");; ROOT::Math::WrappedMultiTF1 fitFunction(f1, f1->GetNdim() );; ROOT::Fit::Fitter fitter;; fitter.SetFunction( fitFunction, false);; ```. When creating the wrapper, the parameter values stored in **`TF1`** will be copied in the `ROOT::Math::WrappedMultiTF1` object.; The function object representing the model function is given to the `ROOT::Fitter` class using the `Fitter::SetFunction` method. The user has also the possibility to provide a function object, which implements the derivatives of the function with respect; to the parameters.; This information might be useful for some types of fits. In this case he needs to provide the function object as a class deriving from the; `ROOT::Math::IParametricGradFunctionMultiDim` interface.; Note that the wrapper class `ROOT::Math::WrappedMultiTF1` implements also the gradient interface, using internally `TF1::GradientPar`,; which",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:36960,Integrability,wrap,wrapper,36960,"be independent of the ROOT *`Hist`* library,; takes as input a more general parametric function object, the interface (abstract) class `ROOT::Math::IParametricFunctionMultiDim`, which describe a generic one or multi-dimensional function; with parameters. This interface extends the abstract class `ROOT::Math::IBaseFunctionMultiDim`, with methods to set/retrieve parameter values and to evaluate the function given the; independent vector of values **`X`** and vector of parameters `P`.; More information about the different `ROOT::Math` function interfaces is available in the Mathematical Library chapter. An end-user can convert a **`TF1`** object in a `ROOT::Math::IParametricFunctionMultiDim`, using the wrapper class `ROOT::Math::WrapperMultiTF1`:. ``` {.cpp}; TF1 * f1 = new TF1(""f1"",""gaus"");; ROOT::Math::WrappedMultiTF1 fitFunction(f1, f1->GetNdim() );; ROOT::Fit::Fitter fitter;; fitter.SetFunction( fitFunction, false);; ```. When creating the wrapper, the parameter values stored in **`TF1`** will be copied in the `ROOT::Math::WrappedMultiTF1` object.; The function object representing the model function is given to the `ROOT::Fitter` class using the `Fitter::SetFunction` method. The user has also the possibility to provide a function object, which implements the derivatives of the function with respect; to the parameters.; This information might be useful for some types of fits. In this case he needs to provide the function object as a class deriving from the; `ROOT::Math::IParametricGradFunctionMultiDim` interface.; Note that the wrapper class `ROOT::Math::WrappedMultiTF1` implements also the gradient interface, using internally `TF1::GradientPar`,; which is based on numerical differentiation, apart for the case of linear functions (i.e. when `TF1::IsLinear()` is `true`).; The parameter derivatives of the model function can be useful to some minimization algorithms, such as Fumili.; However, in general is better to leave the minimization algorithm (e.g. Minuit) to com",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:37533,Integrability,interface,interface,37533,"of parameters `P`.; More information about the different `ROOT::Math` function interfaces is available in the Mathematical Library chapter. An end-user can convert a **`TF1`** object in a `ROOT::Math::IParametricFunctionMultiDim`, using the wrapper class `ROOT::Math::WrapperMultiTF1`:. ``` {.cpp}; TF1 * f1 = new TF1(""f1"",""gaus"");; ROOT::Math::WrappedMultiTF1 fitFunction(f1, f1->GetNdim() );; ROOT::Fit::Fitter fitter;; fitter.SetFunction( fitFunction, false);; ```. When creating the wrapper, the parameter values stored in **`TF1`** will be copied in the `ROOT::Math::WrappedMultiTF1` object.; The function object representing the model function is given to the `ROOT::Fitter` class using the `Fitter::SetFunction` method. The user has also the possibility to provide a function object, which implements the derivatives of the function with respect; to the parameters.; This information might be useful for some types of fits. In this case he needs to provide the function object as a class deriving from the; `ROOT::Math::IParametricGradFunctionMultiDim` interface.; Note that the wrapper class `ROOT::Math::WrappedMultiTF1` implements also the gradient interface, using internally `TF1::GradientPar`,; which is based on numerical differentiation, apart for the case of linear functions (i.e. when `TF1::IsLinear()` is `true`).; The parameter derivatives of the model function can be useful to some minimization algorithms, such as Fumili.; However, in general is better to leave the minimization algorithm (e.g. Minuit) to compute the needed derivatives using its own customised; numerical differentiation algorithm.; In order to not provide to the fitter the parameter derivatives, we explicitly passed in `Fitter::SetFunction` a `false` value. ### Fit Configuration. The configuration of the fit is done via the `ROOT::Fit::FitConfig` class and its contained `ROOT::Fit::ParameterSettings` class.; These are the possible allowed fit configurations:. - setting the initial values of the parame",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:37559,Integrability,wrap,wrapper,37559," in a `ROOT::Math::IParametricFunctionMultiDim`, using the wrapper class `ROOT::Math::WrapperMultiTF1`:. ``` {.cpp}; TF1 * f1 = new TF1(""f1"",""gaus"");; ROOT::Math::WrappedMultiTF1 fitFunction(f1, f1->GetNdim() );; ROOT::Fit::Fitter fitter;; fitter.SetFunction( fitFunction, false);; ```. When creating the wrapper, the parameter values stored in **`TF1`** will be copied in the `ROOT::Math::WrappedMultiTF1` object.; The function object representing the model function is given to the `ROOT::Fitter` class using the `Fitter::SetFunction` method. The user has also the possibility to provide a function object, which implements the derivatives of the function with respect; to the parameters.; This information might be useful for some types of fits. In this case he needs to provide the function object as a class deriving from the; `ROOT::Math::IParametricGradFunctionMultiDim` interface.; Note that the wrapper class `ROOT::Math::WrappedMultiTF1` implements also the gradient interface, using internally `TF1::GradientPar`,; which is based on numerical differentiation, apart for the case of linear functions (i.e. when `TF1::IsLinear()` is `true`).; The parameter derivatives of the model function can be useful to some minimization algorithms, such as Fumili.; However, in general is better to leave the minimization algorithm (e.g. Minuit) to compute the needed derivatives using its own customised; numerical differentiation algorithm.; In order to not provide to the fitter the parameter derivatives, we explicitly passed in `Fitter::SetFunction` a `false` value. ### Fit Configuration. The configuration of the fit is done via the `ROOT::Fit::FitConfig` class and its contained `ROOT::Fit::ParameterSettings` class.; These are the possible allowed fit configurations:. - setting the initial values of the parameters;; - setting the parameter step sizes;; - setting eventual parameter bounds;; - setting the minimizer library and the particular algorithm to use;; - setting different minimizatio",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:37632,Integrability,interface,interface,37632," in a `ROOT::Math::IParametricFunctionMultiDim`, using the wrapper class `ROOT::Math::WrapperMultiTF1`:. ``` {.cpp}; TF1 * f1 = new TF1(""f1"",""gaus"");; ROOT::Math::WrappedMultiTF1 fitFunction(f1, f1->GetNdim() );; ROOT::Fit::Fitter fitter;; fitter.SetFunction( fitFunction, false);; ```. When creating the wrapper, the parameter values stored in **`TF1`** will be copied in the `ROOT::Math::WrappedMultiTF1` object.; The function object representing the model function is given to the `ROOT::Fitter` class using the `Fitter::SetFunction` method. The user has also the possibility to provide a function object, which implements the derivatives of the function with respect; to the parameters.; This information might be useful for some types of fits. In this case he needs to provide the function object as a class deriving from the; `ROOT::Math::IParametricGradFunctionMultiDim` interface.; Note that the wrapper class `ROOT::Math::WrappedMultiTF1` implements also the gradient interface, using internally `TF1::GradientPar`,; which is based on numerical differentiation, apart for the case of linear functions (i.e. when `TF1::IsLinear()` is `true`).; The parameter derivatives of the model function can be useful to some minimization algorithms, such as Fumili.; However, in general is better to leave the minimization algorithm (e.g. Minuit) to compute the needed derivatives using its own customised; numerical differentiation algorithm.; In order to not provide to the fitter the parameter derivatives, we explicitly passed in `Fitter::SetFunction` a `false` value. ### Fit Configuration. The configuration of the fit is done via the `ROOT::Fit::FitConfig` class and its contained `ROOT::Fit::ParameterSettings` class.; These are the possible allowed fit configurations:. - setting the initial values of the parameters;; - setting the parameter step sizes;; - setting eventual parameter bounds;; - setting the minimizer library and the particular algorithm to use;; - setting different minimizatio",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:40009,Integrability,interface,interface,40009,"sizes to values different than the automatically computed ones, one needs to use the `ROOT::Fit::ParameterSetting` class.; This example code will set the lower/upper bounds for the first parameter and a lower bound for the second parameter. ``` {.cpp}; fitter.SetFunction( fitFunction, false);; fitter.Config().ParSettings(0).SetLimits(0,1.E6);; fitter.Config().ParSettings(2).SetLowerLimit(0);; ```. Note that a `ROOT::Fit::ParameterSettings` objects exists for each fit parameter and it created by the `ROOT::Fit::FitConfig` class, after the model function has been set in the Fitter.; Only when the function is set, the number of parameter is known and; automatically the `FitConfig` creates the corresponding `ParameterSetting` objects. When fitting, different minimizer can be used. The can be implemented in different libraries and loaded ar run time by the plug-in manager system of ROOT.; Each different minimizer (e.g. *Minuit, Minuit2, Fumili,* etc.) consists of a different implementation of the `ROOT::Math::Minimizer` interface.; Within the same minimizer, thus within the same class implementing the `Minimizer` interface, different algorithms can exist.; For example in the case of Minuit, we have *Migrad, Simplex* or *Minimize*. The minimizer and its corresponding algorithm, when available,; can be set by using the function `FitConfig::SetMinimizer(""minimizerName"")` or by using directly the `ROOT:Math::MinimizerOptions` class. If the requested minimizer is not available in ROOT, the default one is used. The default minimizer type and algorithm can be specified by using the; static function `ROOT::Math::MinimizerOptions::SetDefaultMinimizer(""minimizerName"")`. ### Minimizer Libraries and Algorithms. The list of available minimizer libraries currently available in ROOT, with their corresponding available algorithms is the following one.; Some minimizers (e.g. *Minuit*) contain several algorithms that the user can; choose. Others are based on a single algorithm (e.g. *Fumi",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:40104,Integrability,interface,interface,40104,"erSetting` class.; This example code will set the lower/upper bounds for the first parameter and a lower bound for the second parameter. ``` {.cpp}; fitter.SetFunction( fitFunction, false);; fitter.Config().ParSettings(0).SetLimits(0,1.E6);; fitter.Config().ParSettings(2).SetLowerLimit(0);; ```. Note that a `ROOT::Fit::ParameterSettings` objects exists for each fit parameter and it created by the `ROOT::Fit::FitConfig` class, after the model function has been set in the Fitter.; Only when the function is set, the number of parameter is known and; automatically the `FitConfig` creates the corresponding `ParameterSetting` objects. When fitting, different minimizer can be used. The can be implemented in different libraries and loaded ar run time by the plug-in manager system of ROOT.; Each different minimizer (e.g. *Minuit, Minuit2, Fumili,* etc.) consists of a different implementation of the `ROOT::Math::Minimizer` interface.; Within the same minimizer, thus within the same class implementing the `Minimizer` interface, different algorithms can exist.; For example in the case of Minuit, we have *Migrad, Simplex* or *Minimize*. The minimizer and its corresponding algorithm, when available,; can be set by using the function `FitConfig::SetMinimizer(""minimizerName"")` or by using directly the `ROOT:Math::MinimizerOptions` class. If the requested minimizer is not available in ROOT, the default one is used. The default minimizer type and algorithm can be specified by using the; static function `ROOT::Math::MinimizerOptions::SetDefaultMinimizer(""minimizerName"")`. ### Minimizer Libraries and Algorithms. The list of available minimizer libraries currently available in ROOT, with their corresponding available algorithms is the following one.; Some minimizers (e.g. *Minuit*) contain several algorithms that the user can; choose. Others are based on a single algorithm (e.g. *Fumili*). - **`Minuit`** (library *libMinuit*). Old version of Minuit, based on the `TMinuit` class. The list",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:41832,Integrability,rout,routines,41832,"ollowing one.; Some minimizers (e.g. *Minuit*) contain several algorithms that the user can; choose. Others are based on a single algorithm (e.g. *Fumili*). - **`Minuit`** (library *libMinuit*). Old version of Minuit, based on the `TMinuit` class. The list of possible algorithms are:; - *`Migrad`* (default one); 	 - *`Simplex`*; - *`Minimize`* (it is a combination of Migrad and Simplex); - *`MigradImproved`*; 	 - *`Scan`*; 	 - *`Seek`*. - **`Minuit2`** (library *libMinuit2*). New C++ version of Minuit. The list of possible algorithm is :; - *`Migrad`* (default); - *`Simplex`*; 	 - *`Minimize`*; 	 - *`Scan`*; 	 - *`Fumili`* . This is the same algorithm of `TFumili`, but implemented in the Minuit2 library. - **`Fumili`**. Implement a dedicated minimization algorithm for least-square and likelihood fits. It has requirements on the type of method function to be used.; No specific algorithm exists. - **`GSLMultiMin`** (library *libMathMore*). Minimizer based on the Multidimensional Minimization routines of the Gnu Scientific Library (GSL). The list of available algorithms is; 	- *`BFGS2`* (default) : second version of the vector Broyden-Fletcher-Goldfarb-Shanno (BFGS) algorithm;; 	- *`BFGS`* : old version of the vector Broyden-Fletcher-Goldfarb-Shanno (BFGS) algorithm;; 	- *`ConjugateFR`* : Fletcher-Reeves conjugate gradient algorithm;; 	- *`ConjugatePR`* : Polak-Ribiere conjugate gradient algorithm;; 	- *`SteepestDescent`*: steepest descent algorithm;. - **`GSLMultiFit`** (library *libMathMore*). Minimizer based on the Non-Linear Least-Square routines of GSL. This minimizer can be used only for least-square fits. - **`GSLSimAn`** (library *libMathMore*). Minimizer based on simulated annealing. - **`Genetic`** (library *libGenetic*). Genetic minimizer based on an algorithm implemented in the *TMVA* package. Each minimizer can be configured using the `ROOT::Math::MinimizerOptions` class. The list of possible option that can be set are:. * *Minimizer type* (`MinimizerOption",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:42392,Integrability,rout,routines,42392,"Migrad`* (default); - *`Simplex`*; 	 - *`Minimize`*; 	 - *`Scan`*; 	 - *`Fumili`* . This is the same algorithm of `TFumili`, but implemented in the Minuit2 library. - **`Fumili`**. Implement a dedicated minimization algorithm for least-square and likelihood fits. It has requirements on the type of method function to be used.; No specific algorithm exists. - **`GSLMultiMin`** (library *libMathMore*). Minimizer based on the Multidimensional Minimization routines of the Gnu Scientific Library (GSL). The list of available algorithms is; 	- *`BFGS2`* (default) : second version of the vector Broyden-Fletcher-Goldfarb-Shanno (BFGS) algorithm;; 	- *`BFGS`* : old version of the vector Broyden-Fletcher-Goldfarb-Shanno (BFGS) algorithm;; 	- *`ConjugateFR`* : Fletcher-Reeves conjugate gradient algorithm;; 	- *`ConjugatePR`* : Polak-Ribiere conjugate gradient algorithm;; 	- *`SteepestDescent`*: steepest descent algorithm;. - **`GSLMultiFit`** (library *libMathMore*). Minimizer based on the Non-Linear Least-Square routines of GSL. This minimizer can be used only for least-square fits. - **`GSLSimAn`** (library *libMathMore*). Minimizer based on simulated annealing. - **`Genetic`** (library *libGenetic*). Genetic minimizer based on an algorithm implemented in the *TMVA* package. Each minimizer can be configured using the `ROOT::Math::MinimizerOptions` class. The list of possible option that can be set are:. * *Minimizer type* (`MinimizerOptions::SetMinimizerType(const char *)`) .; * *Minimizer algorithm* (`MinimizerOptions::SetMinimizerAlgorithm(const char *)`).; * *Print Level* (`MinimizerOptions::SetPrintLevel(int )`) to set the verbose printing level (default is 0).; * *Tolerance* (`MinimizerOptions::SetTolerance(double )`) tolerance used to control the iterations.; * *Maximum number of function calls* (`MinimizerOptions::SetMaxFunctionCalls(int )`).; * *Maximum number of iterations* (`MinimizerOptions::SetMaxIterations(int )`). Note that this is not used by *Minuit*; * *FCN Up",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:45556,Integrability,depend,depending,45556,"Minuit2*). The class supports also setting global default values for the options, by using the static functions `MinimizerOptions::SetDefault...` (for example `MinimizerOptions::SetDefaultPrintLevel(int )`). The; static functions can be also used to set the minimizer options when using `TH1::Fit` or `TGraph::Fit`.; The list of the current option values can be inspected by using `MinimizerOptions::Print`.; ```{.cpp}; ROOT::Math::MinimizerOptions() opt;; // print the default minimizer option values; opt.Print();; ```. In addition it is possible to provide extra options which might apply for a particular minimizer `MinimizerOptions::SetExtraOptions(const IOptions & )`.; See the documentation of the particular minimizer to use for the list of possible additional options available. ### Performing the Fit. Here we have now all the required input ingredients for the fit, the data and the function to fit.; Depending on these we have now several different way to perform the fit, using the corresponding methods of the; `ROOT::Fit::Fitter` class and depending on the type of input data. #### Available fit methods. * **Least-square fit**: `Fitter::LeastSquare(const BinData & )` or `Fitter::Fit(const Bindata &)`. It requires the user to pass a `BinData` object. It should be used when the data values follow a; Gaussian distribution. This fit method is implemented using the class `ROOT::Fit::Chi2FCN`.; * **Binned Likelihood fit** : `Fitter::LikelihoodFit(const Bindata & )`. The user needs to pass a `BinData` object. It should be used when the data values follow a Poisson or a multinomial; distribution. The Poisson case (extended fit) is the default and in this case the function normalization is also fit to the data. The Multi-nominal case can be selected by passing the optional; *extended* boolean flag as *false*. This method is implemented by the class `ROOT::Fit:::PoissonLikelihoodFCN`.; * **Un-Binned likelihood fit**: `Fitter::LikelihoodFit(const UnBindata &)`. The user needs to ",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:48526,Integrability,interface,interface,48526,"r::SetFCN` is used to set the method function and `ROOT::Fit::FitFCN` is used for fitting. The method function can be passed also in `ROOT::Fit::FitFCN`, but in this; case a previously defined fitting configuration is used. The possible type of method functions that are based in `ROOT::Fit::Fitter::SetFCN` are:. * A generic functor object implementing `operator()(const double * p)` where **`p`** is the parameter vectors. In this case one needs to pass the number of parameters,; the function object and optionally a vector of initial parameter values. Other optional parameter include the size of the data sets and a flag specifying if it is a chi2 (least-square fit).; In the last two parameters are given, the `chi2/ndf` can be computed after fitting the data.; ``` {.cpp}; template <class Function>; bool Fitter::SetFCN(unsigned int npar, Function & f,; const double * initialParameters = 0,; unsigned int dataSize=0, bool isChi2Fit = false); ```. * A function object implementing the `ROOT::Math::IBaseFunctionMultiDim` interface:; ``` {.cpp}; bool Fitter::SetFCN(const ROOT::Math::IBaseFunctionMultiDim & f,; const double * initialParameters = 0,; unsigned int dataSize=0, bool isChi2Fit = false); ```. * A function object implementing the `ROOT::Math::FitMethodFunction` interface. This is an interface class extending; the `ROOT::Math::IBaseFunctionMultiDim` with some extra functionality which can be used when fitting.; This extra functionality is required by dedicated fitting algorithms like *Fumili* or *GSLMultiFit*.; ``` {.cpp}; bool Fitter::SetFCN(const ROOT::Math::FitMethodFunction & f,; const double * initialParameters = 0, unsigned int dataSize=0); ```. * A old-Minuit like FCN interface (i.e. a free function with the signature `fcn(int &npar, double *gin, double &f, double *u, int flag)`.; ``` {.cpp}; typedef void(* MinuitFCN)(int &npar, double *gin, double &f, double *u, int flag); bool Fitter::SetFCN(MinuitFCN fcn, int npar,; const double * initialParameters = 0,; uns",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:48779,Integrability,interface,interface,48779," functions that are based in `ROOT::Fit::Fitter::SetFCN` are:. * A generic functor object implementing `operator()(const double * p)` where **`p`** is the parameter vectors. In this case one needs to pass the number of parameters,; the function object and optionally a vector of initial parameter values. Other optional parameter include the size of the data sets and a flag specifying if it is a chi2 (least-square fit).; In the last two parameters are given, the `chi2/ndf` can be computed after fitting the data.; ``` {.cpp}; template <class Function>; bool Fitter::SetFCN(unsigned int npar, Function & f,; const double * initialParameters = 0,; unsigned int dataSize=0, bool isChi2Fit = false); ```. * A function object implementing the `ROOT::Math::IBaseFunctionMultiDim` interface:; ``` {.cpp}; bool Fitter::SetFCN(const ROOT::Math::IBaseFunctionMultiDim & f,; const double * initialParameters = 0,; unsigned int dataSize=0, bool isChi2Fit = false); ```. * A function object implementing the `ROOT::Math::FitMethodFunction` interface. This is an interface class extending; the `ROOT::Math::IBaseFunctionMultiDim` with some extra functionality which can be used when fitting.; This extra functionality is required by dedicated fitting algorithms like *Fumili* or *GSLMultiFit*.; ``` {.cpp}; bool Fitter::SetFCN(const ROOT::Math::FitMethodFunction & f,; const double * initialParameters = 0, unsigned int dataSize=0); ```. * A old-Minuit like FCN interface (i.e. a free function with the signature `fcn(int &npar, double *gin, double &f, double *u, int flag)`.; ``` {.cpp}; typedef void(* MinuitFCN)(int &npar, double *gin, double &f, double *u, int flag); bool Fitter::SetFCN(MinuitFCN fcn, int npar,; const double * initialParameters = 0,; unsigned int dataSize=0, bool isChi2Fit = false); ```. ### Fit Result. The result of the fit is contained in the `ROOT::Fit::Result` object. A reference to the result object is obtained with the function; `Fitter::Result()`.; The `ROOT::Fit::FitResult` c",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:48801,Integrability,interface,interface,48801,"or()(const double * p)` where **`p`** is the parameter vectors. In this case one needs to pass the number of parameters,; the function object and optionally a vector of initial parameter values. Other optional parameter include the size of the data sets and a flag specifying if it is a chi2 (least-square fit).; In the last two parameters are given, the `chi2/ndf` can be computed after fitting the data.; ``` {.cpp}; template <class Function>; bool Fitter::SetFCN(unsigned int npar, Function & f,; const double * initialParameters = 0,; unsigned int dataSize=0, bool isChi2Fit = false); ```. * A function object implementing the `ROOT::Math::IBaseFunctionMultiDim` interface:; ``` {.cpp}; bool Fitter::SetFCN(const ROOT::Math::IBaseFunctionMultiDim & f,; const double * initialParameters = 0,; unsigned int dataSize=0, bool isChi2Fit = false); ```. * A function object implementing the `ROOT::Math::FitMethodFunction` interface. This is an interface class extending; the `ROOT::Math::IBaseFunctionMultiDim` with some extra functionality which can be used when fitting.; This extra functionality is required by dedicated fitting algorithms like *Fumili* or *GSLMultiFit*.; ``` {.cpp}; bool Fitter::SetFCN(const ROOT::Math::FitMethodFunction & f,; const double * initialParameters = 0, unsigned int dataSize=0); ```. * A old-Minuit like FCN interface (i.e. a free function with the signature `fcn(int &npar, double *gin, double &f, double *u, int flag)`.; ``` {.cpp}; typedef void(* MinuitFCN)(int &npar, double *gin, double &f, double *u, int flag); bool Fitter::SetFCN(MinuitFCN fcn, int npar,; const double * initialParameters = 0,; unsigned int dataSize=0, bool isChi2Fit = false); ```. ### Fit Result. The result of the fit is contained in the `ROOT::Fit::Result` object. A reference to the result object is obtained with the function; `Fitter::Result()`.; The `ROOT::Fit::FitResult` class provides an API for retrieving parameter values, errors, covariance and correlation matrix from the fit,;",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:49200,Integrability,interface,interface,49200,"ters are given, the `chi2/ndf` can be computed after fitting the data.; ``` {.cpp}; template <class Function>; bool Fitter::SetFCN(unsigned int npar, Function & f,; const double * initialParameters = 0,; unsigned int dataSize=0, bool isChi2Fit = false); ```. * A function object implementing the `ROOT::Math::IBaseFunctionMultiDim` interface:; ``` {.cpp}; bool Fitter::SetFCN(const ROOT::Math::IBaseFunctionMultiDim & f,; const double * initialParameters = 0,; unsigned int dataSize=0, bool isChi2Fit = false); ```. * A function object implementing the `ROOT::Math::FitMethodFunction` interface. This is an interface class extending; the `ROOT::Math::IBaseFunctionMultiDim` with some extra functionality which can be used when fitting.; This extra functionality is required by dedicated fitting algorithms like *Fumili* or *GSLMultiFit*.; ``` {.cpp}; bool Fitter::SetFCN(const ROOT::Math::FitMethodFunction & f,; const double * initialParameters = 0, unsigned int dataSize=0); ```. * A old-Minuit like FCN interface (i.e. a free function with the signature `fcn(int &npar, double *gin, double &f, double *u, int flag)`.; ``` {.cpp}; typedef void(* MinuitFCN)(int &npar, double *gin, double &f, double *u, int flag); bool Fitter::SetFCN(MinuitFCN fcn, int npar,; const double * initialParameters = 0,; unsigned int dataSize=0, bool isChi2Fit = false); ```. ### Fit Result. The result of the fit is contained in the `ROOT::Fit::Result` object. A reference to the result object is obtained with the function; `Fitter::Result()`.; The `ROOT::Fit::FitResult` class provides an API for retrieving parameter values, errors, covariance and correlation matrix from the fit,; minimum chi2/likelihood values, etc... A `FitResult::Print` method is also available to print the result of the fit. The class has a self-explanatory API so, see its reference documentation for the possible information available after the fit. One extra functionality offered by `ROOT::Fit::FitResult` is the possibility to compute th",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:52731,Integrability,interface,interface,52731,"err0 = r->ParError(0); // retrieve the error for the parameter 0; r->Print(""V""); // print full information of fit including covariance matrix; r->Write(); // store the result in a file; ```. ## The Minimization packages. As explained before various minimization packages can be used when fitting in ROOT.; We have seen before how to configure the `Fitter` class to use different minimization packages; and different minimization options.; When using the `Fit` method the minimization package (and its options) can be selected using the; static methods of the `ROOT::Math::MinimizerOptions` class.; For example to select `Minuit2` instead of `Minuit` for fitting an histogram do:. ``` {.cpp}; ROOT::Math::MinimizerOptions::SetDefaultMinimizer(""Minuit2"");; // fit the histogram histo with the gaussian pre-defined function; histo->Fit(""gaus"");; ```. In the following we will give some brief description of the minimization packages.; The packages all implement the `ROOT::Math::Minimizer` interface which can be use for; finding the minimum of a multi-dimensional function.; The interface is documented in the Mathematical Library Chapter. In addition packages like Minuit or Minuit2 provide their own interfaces. ## MINUIT (Old TMInuit Version). This package was originally written in FORTRAN by Fred James and part; of `PACKLIB` (patch D506). It has been converted to a C++ class by; René Brun. The current implementation in C++ is a straightforward; conversion of the original FORTRAN version. The main changes are:. - The variables in the various `Minuit` labeled common blocks have; been changed to the **`TMinuit`** class data members. - The internal arrays with a maximum dimension depending on the; maximum number of parameters are now data members' arrays with a; dynamic dimension such that one can fit very large problems by; simply initializing the **`TMinuit`** constructor with the maximum; number of parameters. - The include file `Minuit.h` has been commented as much as possible; using ",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:52821,Integrability,interface,interface,52821,"on of fit including covariance matrix; r->Write(); // store the result in a file; ```. ## The Minimization packages. As explained before various minimization packages can be used when fitting in ROOT.; We have seen before how to configure the `Fitter` class to use different minimization packages; and different minimization options.; When using the `Fit` method the minimization package (and its options) can be selected using the; static methods of the `ROOT::Math::MinimizerOptions` class.; For example to select `Minuit2` instead of `Minuit` for fitting an histogram do:. ``` {.cpp}; ROOT::Math::MinimizerOptions::SetDefaultMinimizer(""Minuit2"");; // fit the histogram histo with the gaussian pre-defined function; histo->Fit(""gaus"");; ```. In the following we will give some brief description of the minimization packages.; The packages all implement the `ROOT::Math::Minimizer` interface which can be use for; finding the minimum of a multi-dimensional function.; The interface is documented in the Mathematical Library Chapter. In addition packages like Minuit or Minuit2 provide their own interfaces. ## MINUIT (Old TMInuit Version). This package was originally written in FORTRAN by Fred James and part; of `PACKLIB` (patch D506). It has been converted to a C++ class by; René Brun. The current implementation in C++ is a straightforward; conversion of the original FORTRAN version. The main changes are:. - The variables in the various `Minuit` labeled common blocks have; been changed to the **`TMinuit`** class data members. - The internal arrays with a maximum dimension depending on the; maximum number of parameters are now data members' arrays with a; dynamic dimension such that one can fit very large problems by; simply initializing the **`TMinuit`** constructor with the maximum; number of parameters. - The include file `Minuit.h` has been commented as much as possible; using existing comments in the code or the printed documentation. - The original `Minuit` subroutines are now",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:52944,Integrability,interface,interfaces,52944," in a file; ```. ## The Minimization packages. As explained before various minimization packages can be used when fitting in ROOT.; We have seen before how to configure the `Fitter` class to use different minimization packages; and different minimization options.; When using the `Fit` method the minimization package (and its options) can be selected using the; static methods of the `ROOT::Math::MinimizerOptions` class.; For example to select `Minuit2` instead of `Minuit` for fitting an histogram do:. ``` {.cpp}; ROOT::Math::MinimizerOptions::SetDefaultMinimizer(""Minuit2"");; // fit the histogram histo with the gaussian pre-defined function; histo->Fit(""gaus"");; ```. In the following we will give some brief description of the minimization packages.; The packages all implement the `ROOT::Math::Minimizer` interface which can be use for; finding the minimum of a multi-dimensional function.; The interface is documented in the Mathematical Library Chapter. In addition packages like Minuit or Minuit2 provide their own interfaces. ## MINUIT (Old TMInuit Version). This package was originally written in FORTRAN by Fred James and part; of `PACKLIB` (patch D506). It has been converted to a C++ class by; René Brun. The current implementation in C++ is a straightforward; conversion of the original FORTRAN version. The main changes are:. - The variables in the various `Minuit` labeled common blocks have; been changed to the **`TMinuit`** class data members. - The internal arrays with a maximum dimension depending on the; maximum number of parameters are now data members' arrays with a; dynamic dimension such that one can fit very large problems by; simply initializing the **`TMinuit`** constructor with the maximum; number of parameters. - The include file `Minuit.h` has been commented as much as possible; using existing comments in the code or the printed documentation. - The original `Minuit` subroutines are now member functions. - Constructors and destructor have been added. - In",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:53431,Integrability,depend,depending,53431," with the gaussian pre-defined function; histo->Fit(""gaus"");; ```. In the following we will give some brief description of the minimization packages.; The packages all implement the `ROOT::Math::Minimizer` interface which can be use for; finding the minimum of a multi-dimensional function.; The interface is documented in the Mathematical Library Chapter. In addition packages like Minuit or Minuit2 provide their own interfaces. ## MINUIT (Old TMInuit Version). This package was originally written in FORTRAN by Fred James and part; of `PACKLIB` (patch D506). It has been converted to a C++ class by; René Brun. The current implementation in C++ is a straightforward; conversion of the original FORTRAN version. The main changes are:. - The variables in the various `Minuit` labeled common blocks have; been changed to the **`TMinuit`** class data members. - The internal arrays with a maximum dimension depending on the; maximum number of parameters are now data members' arrays with a; dynamic dimension such that one can fit very large problems by; simply initializing the **`TMinuit`** constructor with the maximum; number of parameters. - The include file `Minuit.h` has been commented as much as possible; using existing comments in the code or the printed documentation. - The original `Minuit` subroutines are now member functions. - Constructors and destructor have been added. - Instead of passing the `FCN` function in the argument list, the; addresses of this function is stored as pointer in the data; members of the class. This is by far more elegant and flexible in; an interactive environment. The member function `SetFCN` can be; used to define this pointer. - The ROOT static function `Printf` is provided to replace all; format statements and to print on currently defined output file. - The functions `SetObjectFit/GetObjectFit` can be used inside the; `FCN` function to set/get a referenced object instead of using; global variables. - By default `fGraphicsMode` is true. When c",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:55342,Integrability,depend,depend,55342,"ns `SetObjectFit/GetObjectFit` can be used inside the; `FCN` function to set/get a referenced object instead of using; global variables. - By default `fGraphicsMode` is true. When calling the `Minuit`; functions such as `mncont`, `mnscan`, or any `Minuit` command; invoking `mnplot`, `TMinuit::mnplot()` produces a **`TGraph`**; object pointed by `fPlot`. One can retrieve this object with; **`TMinuit`**`::GetPlot().` For example:. ``` {.cpp}; h->Fit(""gaus"");; gMinuit->Command(""SCAn 1"");; TGraph *gr = (TGraph*)gMinuit->GetPlot();; gr->SetMarkerStyle(21);; gr->Draw(""alp"");; ```. - To set `Minuit` in no graphics mode, call. ``` {.cpp}; gMinuit->SetGraphicsMode(kFALSE);; ```. ### Basic Concepts of Minuit. The `Minuit` package acts on a multi parameter FORTRAN function to; which one must give the generic name `FCN`. In the ROOT; implementation, the function `FCN` is defined via the `Minuit`; `SetFCN` member function when an histogram fitting is invoked. The; value of `FCN` will in general depend on one or more variable; parameters. ### The Transformation of Limited Parameters. For variable parameters with limits, `Minuit` uses the following; transformation:. `Pint = arcsin(2((Pext-a)/(b-a))-1) `. `Pext = a+((b-a)/(2))(sinPint+1)`. so that the internal value `Pint` can take on any value, while the; external value Pext can take on values only between the lower limit a; and the ext upper limit b. Since the transformation is necessarily; non-linear, it would transform a nice linear problem into a nasty; non-linear one, which is the reason why limits should be avoided if; not necessary. In addition, the transformation does require some; computer time, so it slows down the computation a little bit, and more; importantly, it introduces additional numerical inaccuracy into the; problem in addition to what is introduced in the numerical calculation; of the FCN value. The effects of non-linearity and numerical round off; both become more important as the external value gets closer t",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:57793,Integrability,depend,depends,57793,"are parameter limits. Users; should however realize that the transformation is only a linear; approximation, and that it cannot give a meaningful result if one or; more parameters is very close to a limit, where; $\frac{\partial Pext}{\partial Pint} \neq 0$. Therefore, it is; recommended that:. - Limits on variable parameters should be used only when needed in; order to prevent the parameter from taking on unphysical values. - When a satisfactory minimum has been found using limits, the; limits should then be removed if possible, in order to perform or; re-perform the error analysis without limits. ### How to Get the Right Answer from Minuit. `Minuit` offers the user a choice of several minimization algorithms.; The `MIGRAD` algorithm is in general the best minimized for nearly all; functions. It is a variable-metric method with inexact line search, a; stable metric updating scheme, and checks for positive-definiteness.; Its main weakness is that it depends heavily on knowledge of the first; derivatives, and fails miserably if they are very inaccurate. If parameter limits are needed, in spite of the side effects, then the; user should be aware of the following techniques to alleviate problems; caused by limits:. #### Getting the Right Minimum with Limits. If MIGRAD converges normally to a point where no parameter is near one; of its limits, then the existence of limits has probably not prevented; `Minuit` from finding the right minimum. On the other hand, if one or; more parameters is near its limit at the minimum, this may be because; the true minimum is indeed at a limit, or it may be because the; minimized has become ''blocked'' at a limit. This may normally happen; only if the parameter is so close to a limit (internal value at an odd; multiple of $\pm \frac{\pi}{2}$ that `Minuit` prints a warning to this; effect when it prints the parameter values. The minimized can become; blocked at a limit, because at a limit the derivative seen by the; minimized $\frac{\part",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:61464,Integrability,message,messages,61464,"nuit Error Estimates. `Minuit` always carries around its own current estimates of the; parameter errors, which it will print out on request, no matter how; accurate they are at any given point in the execution. For example, at; initialization, these estimates are just the starting step sizes as; specified by the user. After a `HESSE` step, the errors are usually; quite accurate, unless there has been a problem. `Minuit`, when it; prints out error values, also gives some indication of how reliable it; thinks they are. For example, those marked `CURRENT GUESS ERROR` are; only working values not to be believed, and `APPROXIMATE ERROR` means; that they have been calculated but there is reason to believe that; they may not be accurate. If no mitigating adjective is given, then at least `Minuit` believes; the errors are accurate, although there is always a small chance that; `Minuit` has been fooled. Some visible signs that `Minuit` may have; been fooled:. - Warning messages produced during the minimization or error; analysis. - Failure to find new minimum. - Value of EDM too big (estimated Distance to Minimum). - Correlation coefficients exactly equal to zero, unless some; parameters are known to be uncorrelated with the others. - Correlation coefficients very close to one (greater than 0.99).; This indicates both an exceptionally difficult problem, and one; which has been badly parameterized so that individual errors are; not very meaningful because they are so highly correlated. - Parameter at limit. This condition, signaled by a `Minuit` warning; message, may make both the function minimum and parameter errors; unreliable. See the discussion above ‘Getting the right parameter; errors with limits'. The best way to be absolutely sure of the errors is to use; ''independent'' calculations and compare them, or compare the; calculated errors with a picture of the function. Theoretically, the; covariance matrix for a ''physical'' function must be; positive-definite at the mi",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:62060,Integrability,message,message,62060,"ing values not to be believed, and `APPROXIMATE ERROR` means; that they have been calculated but there is reason to believe that; they may not be accurate. If no mitigating adjective is given, then at least `Minuit` believes; the errors are accurate, although there is always a small chance that; `Minuit` has been fooled. Some visible signs that `Minuit` may have; been fooled:. - Warning messages produced during the minimization or error; analysis. - Failure to find new minimum. - Value of EDM too big (estimated Distance to Minimum). - Correlation coefficients exactly equal to zero, unless some; parameters are known to be uncorrelated with the others. - Correlation coefficients very close to one (greater than 0.99).; This indicates both an exceptionally difficult problem, and one; which has been badly parameterized so that individual errors are; not very meaningful because they are so highly correlated. - Parameter at limit. This condition, signaled by a `Minuit` warning; message, may make both the function minimum and parameter errors; unreliable. See the discussion above ‘Getting the right parameter; errors with limits'. The best way to be absolutely sure of the errors is to use; ''independent'' calculations and compare them, or compare the; calculated errors with a picture of the function. Theoretically, the; covariance matrix for a ''physical'' function must be; positive-definite at the minimum, although it may not be so for all; points far away from the minimum, even for a well-determined physical; problem. Therefore, if `MIGRAD` reports that it has found a; non-positive-definite covariance matrix, this may be a sign of one or; more of the following:. #### A Non-physical Region. On its way to the minimum, `MIGRAD` may have traversed a region that; has unphysical behavior, which is of course not a serious problem as; long as it recovers and leaves such a region. #### An Underdetermined Problem. If the matrix is not positive-definite even at the minimum, this may;",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:63248,Integrability,depend,dependence,63248,"iable. See the discussion above ‘Getting the right parameter; errors with limits'. The best way to be absolutely sure of the errors is to use; ''independent'' calculations and compare them, or compare the; calculated errors with a picture of the function. Theoretically, the; covariance matrix for a ''physical'' function must be; positive-definite at the minimum, although it may not be so for all; points far away from the minimum, even for a well-determined physical; problem. Therefore, if `MIGRAD` reports that it has found a; non-positive-definite covariance matrix, this may be a sign of one or; more of the following:. #### A Non-physical Region. On its way to the minimum, `MIGRAD` may have traversed a region that; has unphysical behavior, which is of course not a serious problem as; long as it recovers and leaves such a region. #### An Underdetermined Problem. If the matrix is not positive-definite even at the minimum, this may; mean that the solution is not well defined, for example that there are; more unknowns than there are data points, or that the parameterization; of the fit contains a linear dependence. If this is the case, then; `Minuit` (or any other program) cannot solve your problem uniquely.; The error matrix will necessarily be largely meaningless, so the user; must remove the under determinedness by reformulating the; parameterization. `Minuit` cannot do this itself. #### Numerical Inaccuracies. It is possible that the apparent lack of positive-definiteness is due; to excessive round off errors in numerical calculations (in the user; function), or not enough precision. This is unlikely in general, but; becomes more likely if the number of free parameters is very large, or; if the parameters are badly scaled (not all of the same order of; magnitude), and correlations are large. In any case, whether the; non-positive-definiteness is real or only numerical is largely; irrelevant, since in both cases the error matrix will be unreliable; and the minimum sus",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:64195,Integrability,depend,dependence,64195,"ation; of the fit contains a linear dependence. If this is the case, then; `Minuit` (or any other program) cannot solve your problem uniquely.; The error matrix will necessarily be largely meaningless, so the user; must remove the under determinedness by reformulating the; parameterization. `Minuit` cannot do this itself. #### Numerical Inaccuracies. It is possible that the apparent lack of positive-definiteness is due; to excessive round off errors in numerical calculations (in the user; function), or not enough precision. This is unlikely in general, but; becomes more likely if the number of free parameters is very large, or; if the parameters are badly scaled (not all of the same order of; magnitude), and correlations are large. In any case, whether the; non-positive-definiteness is real or only numerical is largely; irrelevant, since in both cases the error matrix will be unreliable; and the minimum suspicious. #### An Ill-posed Problem. For questions of parameter dependence, see the discussion above on; positive-definiteness. Possible other mathematical problems are the; following:. - Excessive numerical round off - be especially careful of; exponential and factorial functions which get big very quickly and; lose accuracy. - Starting too far from the solution - the function may have; unphysical local minima, especially at infinity in some variables. ## Minuit2 Package. `Minuit2` is a new object-oriented implementation, written in C++, of; the popular `MINUIT` minimization package. Compared with the; **`TMinuit`** class, which is a direct conversion from FORTRAN to C++,; `Minuit2` is a complete redesign and re-implementation of the package.; This new version provides all the functionality present in the old; FORTRAN version, with almost equivalent numerical accuracy and; computational performances.; Furthermore, it contains some fixes and small improvements and this new functionality:; * The possibility to set single side parameter limits; * the FUMILI algorithm ",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:65810,Integrability,interface,interface,65810,"ass, which is a direct conversion from FORTRAN to C++,; `Minuit2` is a complete redesign and re-implementation of the package.; This new version provides all the functionality present in the old; FORTRAN version, with almost equivalent numerical accuracy and; computational performances.; Furthermore, it contains some fixes and small improvements and this new functionality:; * The possibility to set single side parameter limits; * the FUMILI algorithm (see the next paragraph ""FUMILI Minimization Package""),; which is an optimized method for least square and log; likelihood minimizations. Minuit2 has been originally developed by M.; Winkler and F. James in the SEAL project. More information can be found; on the [MINUIT Web Site](MINUIT Web Site) and in particular at the; following documentation page at; <http://www.cern.ch/minuit/doc/doc.html>. A detailed User Guide for Minuit2 exists, describing the API of the internal classes.; ROOT uses `Minuit2` for fitting via the `Minuit2Minimizer` class which implements; the `ROOT::Math::Minimizer` interface. `Minuit2` is also distributed as an independent package of ROOT and can be built; without any other dependency on the ROOT libraries. Examples on how to use the `Minuit2` and `Fumili2` plug-ins are provided; in the tutorials' directory `$ROOTSYS/tutorials/fit`:; `minuit2FitBench.C`, `minuit2FitBench2D.C` and `minuit2GausFit.C`.; More information on the classes and functions present in `Minuit2` is; available at; [online reference documentation](online reference documentation). Useful information on MINUIT and minimization in general is provided in the; following documents:. F. James, *Minuit Tutorial on Function Minimization* (; <http://seal.cern.ch/documents/minuit/mntutorial.pdf>); F. James, *The; Interpretation of Errors in Minuit* (; <http://seal.cern.ch/documents/minuit/mnerror.pdf>);. ## FUMILI Minimization Package. FUMILI is used to minimize Chi-square function or to search maximum of; likelihood function. Experimenta",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:65921,Integrability,depend,dependency,65921,"his new version provides all the functionality present in the old; FORTRAN version, with almost equivalent numerical accuracy and; computational performances.; Furthermore, it contains some fixes and small improvements and this new functionality:; * The possibility to set single side parameter limits; * the FUMILI algorithm (see the next paragraph ""FUMILI Minimization Package""),; which is an optimized method for least square and log; likelihood minimizations. Minuit2 has been originally developed by M.; Winkler and F. James in the SEAL project. More information can be found; on the [MINUIT Web Site](MINUIT Web Site) and in particular at the; following documentation page at; <http://www.cern.ch/minuit/doc/doc.html>. A detailed User Guide for Minuit2 exists, describing the API of the internal classes.; ROOT uses `Minuit2` for fitting via the `Minuit2Minimizer` class which implements; the `ROOT::Math::Minimizer` interface. `Minuit2` is also distributed as an independent package of ROOT and can be built; without any other dependency on the ROOT libraries. Examples on how to use the `Minuit2` and `Fumili2` plug-ins are provided; in the tutorials' directory `$ROOTSYS/tutorials/fit`:; `minuit2FitBench.C`, `minuit2FitBench2D.C` and `minuit2GausFit.C`.; More information on the classes and functions present in `Minuit2` is; available at; [online reference documentation](online reference documentation). Useful information on MINUIT and minimization in general is provided in the; following documents:. F. James, *Minuit Tutorial on Function Minimization* (; <http://seal.cern.ch/documents/minuit/mntutorial.pdf>); F. James, *The; Interpretation of Errors in Minuit* (; <http://seal.cern.ch/documents/minuit/mnerror.pdf>);. ## FUMILI Minimization Package. FUMILI is used to minimize Chi-square function or to search maximum of; likelihood function. Experimentally measured values $F_{i}$ are fitted; with theoretical; functions $f_{i}(\vec{x_{i}},\vec{\theta})$, where $\vec{x_{i}}$ are; ",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:5361,Modifiability,adapt,adapted,5361,"tion. To fit a histogram with a predefined function, simply pass the name of; the function in the first parameter of `TH1::Fit`. For example,; this line fits histogram object `hist` with a Gaussian. ``` {.cpp}; root[] hist.Fit(""gaus"");; ```. The initial parameter values (and eventual limits) for pre-defined functions are set; automatically. For overriding the default limits values use the fit option `B`. The list of pre-defined functions that can be used with the `Fit` method is the following:. - ""`gaus`"" Gaussian function with 3 parameters:; `f(x) = p0*exp(-0.5*((x-p1)/p2)^2)`. - ""`expo`""An Exponential with 2 parameters: `f(x) = exp(p0+p1*x)`. - ""`pol`*`N`*"" A polynomial of degree *N*, where N is a number between 0 and 9:; `f(x) = p0 + p1*x + p2*x2 +...`. - ""`chebyshev`*`N`*"" A Chebyshev polynomial of degree *N*, where N is a number between 0 and 9:; `f(x) = p0 + p1*x + p2*(2*x2-1) +...`. - ""`landau`"" Landau function with mean and sigma. This function has; been adapted from the `CERNLIB` routine `G110 denlan` (see `TMath::Landau`). - ""`gausn`"" Normalized form of the gaussian function with 3 parameters; `f(x) = p0*exp(-0.5*((x-p1)/p2)^2)/(p2 *sqrt(2PI))`. ### Creating User-Defined Functions (TF1). You can create a **`TF1`** object and use it in the call the; `TH1::Fit`. The parameter in to the `Fit` method is the NAME of; the **`TF1`** object. There are three ways to create a **`TF1`**. - Using C++ expression using x with a fixed set of operators and; functions defined in **`TFormula`**. - Same as first one, with parameters. - Using a function that you have defined. This can be a free function or; a functor object or a particular member function of a class. #### Creating a TF1 with a Formula. Let's look at the first case. Here we call the **`TF1`** constructor; by giving it the formula: `sin(x)/x`. ``` {.cpp}; root[] TF1 *f1 = new TF1(""f1"",""sin(x)/x"",0,10); ```. You can also use a **`TF1`** object in the constructor of another; **`TF1`**. ``` {.cpp}; root[] TF1 *f2 ",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:10234,Modifiability,config,configuration,10234,"e function object is that it can have a state and reference therefore what-ever other object; the user needs, without using globals. This is an example to define first the function object. ``` {.cpp}; class MyFunctionObject {; public:; // use constructor to customize your function object; MyFunctionObject(......) { ......}. double operator() (double *x, double *p) {; // function implementation using class data members; }; };; ```. and then use it to create the **`TF1`**:. ```{.cpp}; MyFunctionObject fobj(....); // create the function object; TF1 * f = new TF1(""f"",fobj,xmin,xmax,npar); // create TF1 class with n-parameters and range [xmin,xmax]; ```. If using C++11, one can create a **`TF1`** also from a C++ `lambda` function:. ```{.cpp}; // create TF1 class with 2 parameters and range [xmin,xmax] using a lambda; TF1 * f = new TF1(""f"",[](double*x,double*p){return p[0] + p[1]*x[0];},xmin,xmax,2);; ```. ## Configuring the Fit. We will show here some configuration actions that can or must be done; when fitting histogram or graph using the `Fit` method. ### Fixing and Setting Parameters' Bounds. Parameters must be initialized before invoking the `Fit` method. The; setting of the parameter initial values is automatic for the; predefined functions: `poln`, `exp`, `gaus`, and `landau`. You can fix; one or more parameters by specifying the ""B"" option when calling the; `Fit` method. When a function is not predefined, the fit parameters; must be initialized to some value as close as possible to the expected; values before calling the fit function. To set bounds for one parameter, use `TF1::SetParLimits`:. ``` {.cpp}; func->SetParLimits(0,-1,1);; ```. When the lower and upper limits are equal, the parameter is fixed.; Next two statements fix parameter 4 at 10. ``` {.cpp}; func->SetParameter(4,10);; func->SetParLimits(4,10,10);; ```. However, to fix a parameter to 0, one must call the `FixParameter`; function:. ``` {.cpp}; func->SetParameter(4,0);; func->FixParameter(4,0);; ```. ",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:26646,Modifiability,config,configuring,26646,"ton* - performs a fit taking different option settings via the; Fit Panel interface. *Reset* - sets the GUI elements and related fit settings to the; default ones. *Close* - closes the Fit panel window. ### Minimization Options. With this tab one can select specific options for minimization. These include. * The minimizer library ( *Minuit*, *Minuit2*, *Fumili*, *GSL*, *Genetics* ); * The method (algorithm) for minimization. For example for Minuit one can choose between (*Migrad*, *Simplex* or *Scan*); * Error definition; * Minimization tolerance; * Number of iterations/function calls; * Print Level: (*Default*, *Verbose* or *Quiet*). ## New ROOT::Fit classes. The fitting of the data objects in ROOT, histograms, graphs and tree is performed via some common classes,; which are defined in the `ROOT::Fit` namespace.; These classes can be classified in the following groups:. * User classes driving the fit: `ROOT::Fit::Fitter` for executing the fit, `ROOT::Fit::FitConfig` for configuring the fit,; 	`ROOT::Fit::ParameterSettings` to define the properties of the fit parameters (initial; 	values, bounds, etc..), `ROOT::Fit::FitResult` for storing the result of the fit.; * Data classes containing the data sets used in the fitting. These classes are the`ROOT::Fit::BinData`for describing bin data sets,; 	 thus data points containing both coordinates and a corresponding value/weight; 	 with optionally an error on the value or the coordinate and the `ROOT::Fit::UnBinData` for un-binned data sets,; 	 which consists only of a vector of coordinate values. The coordinate values can be; 	 one-dimensional (i.e. one entry per event) or multi-dimensional (N entries per event).; * Function classes defining the type of fit (the objective function used for fitting):; 	- `ROOT::Fit::Chi2FCN` for chi2 (least-square fits),; 	- `ROOT::Fit::PoissonLikelihoodFCN` for binned likelihood fits of histograms,; 	- `ROOT::Fit::LogLikelihoodFCN` for generic un-binned likelihood fits.; 	These classes are ",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:28551,Modifiability,config,configure,28551,":Fit::PoissonLikelihoodFCN` for binned likelihood fits of histograms,; 	- `ROOT::Fit::LogLikelihoodFCN` for generic un-binned likelihood fits.; 	These classes are templated on the type of function interface they implement (see later). User convenient typedefs are also provided.; 	They derive from the common generic interface multi-dimensional for function evaluation, `ROOT::Math::IBaseFunctionMultiDim`. In addition the fitter classes make uses of the generic interfaces for parametric function evaluations, `ROOT::Math::IParametricFunctionMultiDim`; to define the fit model function and use the `ROOT::Math::Minimizer` interface to perform the minimization of the objective function.; More information about the function interface and the multi-dimensional minimization in ROOT is given in the Mathematical Library chapter. Here we present a detailed description of the `ROOT::Fit` classes and how to use them.; Using these classes instead of the interface provided directly in the ROOT data objects, like `TH1::Fit` allow are more fine control; to configure and customise the fits. For example, using these classes a combined fit of several histograms can be performed. To understand how these class work, let's go through a simple example, such as fitting an histogram. When fitting an histogram, instead of using `TH1::Fit` we will show in the following hot wo use the `ROOT::Fit` classes.; We will show how to perform the following different type of fits with the histogram data:; * a least square fit using the observed errors (Neyman chi-squared);; * a least square fit using the expected errors from the function (Pearson chi-squared);; * a binned likelihood fit;; * an extended unbinned likelihood fits, if the histogram has been set to store in the buffer the original data used to fill it. Let's go through all the steps required for performing these fits using the `ROOT::Fit::Fitter` class.; These steps are:; 1. Create the input fit data object.; 2. Create the input model function.;",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:29179,Modifiability,extend,extended,29179,"`ROOT::Math::Minimizer` interface to perform the minimization of the objective function.; More information about the function interface and the multi-dimensional minimization in ROOT is given in the Mathematical Library chapter. Here we present a detailed description of the `ROOT::Fit` classes and how to use them.; Using these classes instead of the interface provided directly in the ROOT data objects, like `TH1::Fit` allow are more fine control; to configure and customise the fits. For example, using these classes a combined fit of several histograms can be performed. To understand how these class work, let's go through a simple example, such as fitting an histogram. When fitting an histogram, instead of using `TH1::Fit` we will show in the following hot wo use the `ROOT::Fit` classes.; We will show how to perform the following different type of fits with the histogram data:; * a least square fit using the observed errors (Neyman chi-squared);; * a least square fit using the expected errors from the function (Pearson chi-squared);; * a binned likelihood fit;; * an extended unbinned likelihood fits, if the histogram has been set to store in the buffer the original data used to fill it. Let's go through all the steps required for performing these fits using the `ROOT::Fit::Fitter` class.; These steps are:; 1. Create the input fit data object.; 2. Create the input model function.; 3. Configure the fit.; 4. Perform the data fitting.; 5. Examine the result. ### Creating the input fit data. We have two types of input data, binned data (class `ROOT::Fit::BinData`) used for least square (chi-square) fits of histograms or `TGraph` objects; or un-binned data (class `ROOT::Fit::UnBinData`) used for; fitting vectors of data points (e.g. from a `TTree`). #### Using Binned data. Let's suppose we have an histogram, represented as a **`TH1`** type object (it can be one or multi-dimensional). The following shows how to create and; fill a `ROOT:Fit::BinData` object. ``` {.cpp}; ROOT:",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:31949,Modifiability,variab,variable,31949,"y the ``ROOT::Fit::DataOptions`` class, the range by the ``ROOT::Fit::DataRange`` class. Here is an example how to specify the input option to use the integral of the function value in the bin instead of using the function value; evaluated at the bin center, when doing the fit and to use a; range beween the 'xmin' and 'xmax' values. ``` {.cpp}; ROOT::Fit::DataOptions opt;; opt.fIntegral = true;; ROOT::Fit::DataRange range(xmin,xmax);; ROOT::Fit::BinData data(opt,range);; // fill the bin data using the histogram; // we can do this using the following helper function from the Hist library; TH1 * h1 = (TH1*) gDirectory->Get(""myHistogram"");; ROOT::Fit::FillData(data, h1);; ```. The list of possible fit options available is the following:; ``` {.cpp}; ROOT::Fit::DataOptions opt;; opt.fIntegral = true; // use integral of bin content instead of bin center (default is false).; opt.fBinVolume = true; // normalize data by the bin volume (default is false).; // This is for fitting density functions in histograms with variable bin sizes.; opt.fUseRange =true; // use the function range when creating the fit data (default is false).; opt.fExpErrors = true; // use the expected errors estimated from the function values; // assuming Poisson statistics and not the observed errors (default is false).; opt.fUseEmpty = true; // use empty bins when fitting (default is false). If fExpErrors; 							 // is not set an arbitrary error = 1 is assigned to those bins.; opt.fErrors1 = true; // Set all measured errors to 1 (default is false).; opt.fCoordErrors = false; // When available coordinate errors are not used in the fit; // (default is true: the errors are used when they are available,; // e.g. fitting a TGraphErrors).; opt.fAsymErrors = false; // When available asymmetric errors are considered in the fit; // (default is true, the asymmetric errors are used when they are available,; // e.g. fitting a TGraphAsymmErrors).; ```. The `ROOT::Fit::DataRange` class supports defining multiple rect",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:35435,Modifiability,variab,variables,35435,"togram->GetBuffer();; 	// number of entry is first entry in the buffer; 	int n = buffer[0];; 	// when creating the data object it is important to create with the size of the data; 	ROOT::Fit::UnBinData data(n);; 	for (int i = 0; i < n; ++i); 		data.add(buffer[2*i+1]); // the buffer of 1D histogram contains nevt,x1,w1,x2,w2,......; ```. Instead in this example we will create a 2-dim `UnBinData` object with the contents from a ROOT `TTree`. ``` {.cpp}; TFile * file = TFile::Open(""hsimple.root"");; TTree *ntuple = 0; file->GetObject(""ntuple"",ntuple);; 	// select from the tree the data we want to use for fitting; 	// we use TTree::Draw for this; 	int nevt = ntuple->Draw(""px:py"","""",""goff"");; 	double * x = ntuple->GetV1();; 	double * y = ntuple->GetV2();; ROOT::Fit::UnBinData data(nevt, x, y );; ```. ### Creating the Fit model. In order to fit a data sets we need a model to describe our data, e.g. a probability density function describing our observed data or; an hypothetical function describing the relation between the independent variables **`X`** and the single dependent variable `Y`.; We can have an arbitrary number `k` of independent variables. For example, when fitting a `k`-dimensional histogram,; the independent variables **`X`** are the bin center coordinates and `Y` is the bin weight. The model function needs to be expressed as function of some unknown parameters. The fitting will find the best parameter value to describe; the observed data. We can use the ROOT **`TF1`** class, the parametric function class, to describe the model function. However the `ROOT::Fit::Fitter` class, to be independent of the ROOT *`Hist`* library,; takes as input a more general parametric function object, the interface (abstract) class `ROOT::Math::IParametricFunctionMultiDim`, which describe a generic one or multi-dimensional function; with parameters. This interface extends the abstract class `ROOT::Math::IBaseFunctionMultiDim`, with methods to set/retrieve parameter values and to ev",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:35478,Modifiability,variab,variable,35478,"togram->GetBuffer();; 	// number of entry is first entry in the buffer; 	int n = buffer[0];; 	// when creating the data object it is important to create with the size of the data; 	ROOT::Fit::UnBinData data(n);; 	for (int i = 0; i < n; ++i); 		data.add(buffer[2*i+1]); // the buffer of 1D histogram contains nevt,x1,w1,x2,w2,......; ```. Instead in this example we will create a 2-dim `UnBinData` object with the contents from a ROOT `TTree`. ``` {.cpp}; TFile * file = TFile::Open(""hsimple.root"");; TTree *ntuple = 0; file->GetObject(""ntuple"",ntuple);; 	// select from the tree the data we want to use for fitting; 	// we use TTree::Draw for this; 	int nevt = ntuple->Draw(""px:py"","""",""goff"");; 	double * x = ntuple->GetV1();; 	double * y = ntuple->GetV2();; ROOT::Fit::UnBinData data(nevt, x, y );; ```. ### Creating the Fit model. In order to fit a data sets we need a model to describe our data, e.g. a probability density function describing our observed data or; an hypothetical function describing the relation between the independent variables **`X`** and the single dependent variable `Y`.; We can have an arbitrary number `k` of independent variables. For example, when fitting a `k`-dimensional histogram,; the independent variables **`X`** are the bin center coordinates and `Y` is the bin weight. The model function needs to be expressed as function of some unknown parameters. The fitting will find the best parameter value to describe; the observed data. We can use the ROOT **`TF1`** class, the parametric function class, to describe the model function. However the `ROOT::Fit::Fitter` class, to be independent of the ROOT *`Hist`* library,; takes as input a more general parametric function object, the interface (abstract) class `ROOT::Math::IParametricFunctionMultiDim`, which describe a generic one or multi-dimensional function; with parameters. This interface extends the abstract class `ROOT::Math::IBaseFunctionMultiDim`, with methods to set/retrieve parameter values and to ev",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:35544,Modifiability,variab,variables,35544,"t is important to create with the size of the data; 	ROOT::Fit::UnBinData data(n);; 	for (int i = 0; i < n; ++i); 		data.add(buffer[2*i+1]); // the buffer of 1D histogram contains nevt,x1,w1,x2,w2,......; ```. Instead in this example we will create a 2-dim `UnBinData` object with the contents from a ROOT `TTree`. ``` {.cpp}; TFile * file = TFile::Open(""hsimple.root"");; TTree *ntuple = 0; file->GetObject(""ntuple"",ntuple);; 	// select from the tree the data we want to use for fitting; 	// we use TTree::Draw for this; 	int nevt = ntuple->Draw(""px:py"","""",""goff"");; 	double * x = ntuple->GetV1();; 	double * y = ntuple->GetV2();; ROOT::Fit::UnBinData data(nevt, x, y );; ```. ### Creating the Fit model. In order to fit a data sets we need a model to describe our data, e.g. a probability density function describing our observed data or; an hypothetical function describing the relation between the independent variables **`X`** and the single dependent variable `Y`.; We can have an arbitrary number `k` of independent variables. For example, when fitting a `k`-dimensional histogram,; the independent variables **`X`** are the bin center coordinates and `Y` is the bin weight. The model function needs to be expressed as function of some unknown parameters. The fitting will find the best parameter value to describe; the observed data. We can use the ROOT **`TF1`** class, the parametric function class, to describe the model function. However the `ROOT::Fit::Fitter` class, to be independent of the ROOT *`Hist`* library,; takes as input a more general parametric function object, the interface (abstract) class `ROOT::Math::IParametricFunctionMultiDim`, which describe a generic one or multi-dimensional function; with parameters. This interface extends the abstract class `ROOT::Math::IBaseFunctionMultiDim`, with methods to set/retrieve parameter values and to evaluate the function given the; independent vector of values **`X`** and vector of parameters `P`.; More information about the dif",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:35627,Modifiability,variab,variables,35627,"; ++i); 		data.add(buffer[2*i+1]); // the buffer of 1D histogram contains nevt,x1,w1,x2,w2,......; ```. Instead in this example we will create a 2-dim `UnBinData` object with the contents from a ROOT `TTree`. ``` {.cpp}; TFile * file = TFile::Open(""hsimple.root"");; TTree *ntuple = 0; file->GetObject(""ntuple"",ntuple);; 	// select from the tree the data we want to use for fitting; 	// we use TTree::Draw for this; 	int nevt = ntuple->Draw(""px:py"","""",""goff"");; 	double * x = ntuple->GetV1();; 	double * y = ntuple->GetV2();; ROOT::Fit::UnBinData data(nevt, x, y );; ```. ### Creating the Fit model. In order to fit a data sets we need a model to describe our data, e.g. a probability density function describing our observed data or; an hypothetical function describing the relation between the independent variables **`X`** and the single dependent variable `Y`.; We can have an arbitrary number `k` of independent variables. For example, when fitting a `k`-dimensional histogram,; the independent variables **`X`** are the bin center coordinates and `Y` is the bin weight. The model function needs to be expressed as function of some unknown parameters. The fitting will find the best parameter value to describe; the observed data. We can use the ROOT **`TF1`** class, the parametric function class, to describe the model function. However the `ROOT::Fit::Fitter` class, to be independent of the ROOT *`Hist`* library,; takes as input a more general parametric function object, the interface (abstract) class `ROOT::Math::IParametricFunctionMultiDim`, which describe a generic one or multi-dimensional function; with parameters. This interface extends the abstract class `ROOT::Math::IBaseFunctionMultiDim`, with methods to set/retrieve parameter values and to evaluate the function given the; independent vector of values **`X`** and vector of parameters `P`.; More information about the different `ROOT::Math` function interfaces is available in the Mathematical Library chapter. An end-user can",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:36275,Modifiability,extend,extends,36275,"al function describing the relation between the independent variables **`X`** and the single dependent variable `Y`.; We can have an arbitrary number `k` of independent variables. For example, when fitting a `k`-dimensional histogram,; the independent variables **`X`** are the bin center coordinates and `Y` is the bin weight. The model function needs to be expressed as function of some unknown parameters. The fitting will find the best parameter value to describe; the observed data. We can use the ROOT **`TF1`** class, the parametric function class, to describe the model function. However the `ROOT::Fit::Fitter` class, to be independent of the ROOT *`Hist`* library,; takes as input a more general parametric function object, the interface (abstract) class `ROOT::Math::IParametricFunctionMultiDim`, which describe a generic one or multi-dimensional function; with parameters. This interface extends the abstract class `ROOT::Math::IBaseFunctionMultiDim`, with methods to set/retrieve parameter values and to evaluate the function given the; independent vector of values **`X`** and vector of parameters `P`.; More information about the different `ROOT::Math` function interfaces is available in the Mathematical Library chapter. An end-user can convert a **`TF1`** object in a `ROOT::Math::IParametricFunctionMultiDim`, using the wrapper class `ROOT::Math::WrapperMultiTF1`:. ``` {.cpp}; TF1 * f1 = new TF1(""f1"",""gaus"");; ROOT::Math::WrappedMultiTF1 fitFunction(f1, f1->GetNdim() );; ROOT::Fit::Fitter fitter;; fitter.SetFunction( fitFunction, false);; ```. When creating the wrapper, the parameter values stored in **`TF1`** will be copied in the `ROOT::Math::WrappedMultiTF1` object.; The function object representing the model function is given to the `ROOT::Fitter` class using the `Fitter::SetFunction` method. The user has also the possibility to provide a function object, which implements the derivatives of the function with respect; to the parameters.; This information might be us",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:38252,Modifiability,config,configuration,38252," with respect; to the parameters.; This information might be useful for some types of fits. In this case he needs to provide the function object as a class deriving from the; `ROOT::Math::IParametricGradFunctionMultiDim` interface.; Note that the wrapper class `ROOT::Math::WrappedMultiTF1` implements also the gradient interface, using internally `TF1::GradientPar`,; which is based on numerical differentiation, apart for the case of linear functions (i.e. when `TF1::IsLinear()` is `true`).; The parameter derivatives of the model function can be useful to some minimization algorithms, such as Fumili.; However, in general is better to leave the minimization algorithm (e.g. Minuit) to compute the needed derivatives using its own customised; numerical differentiation algorithm.; In order to not provide to the fitter the parameter derivatives, we explicitly passed in `Fitter::SetFunction` a `false` value. ### Fit Configuration. The configuration of the fit is done via the `ROOT::Fit::FitConfig` class and its contained `ROOT::Fit::ParameterSettings` class.; These are the possible allowed fit configurations:. - setting the initial values of the parameters;; - setting the parameter step sizes;; - setting eventual parameter bounds;; - setting the minimizer library and the particular algorithm to use;; - setting different minimization options (print level, tolerance, max iterations, etc...); - setting the type of parameter errors to compute (parabolic error, Minos errors, re-normalize errors using fitted chi2 values). The initial parameter values can be set directly in the input model function object.; However, for setting parameter bounds and step sizes to values different than the automatically computed ones, one needs to use the `ROOT::Fit::ParameterSetting` class.; This example code will set the lower/upper bounds for the first parameter and a lower bound for the second parameter. ``` {.cpp}; fitter.SetFunction( fitFunction, false);; fitter.Config().ParSettings(0).SetLimit",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:38414,Modifiability,config,configurations,38414," In this case he needs to provide the function object as a class deriving from the; `ROOT::Math::IParametricGradFunctionMultiDim` interface.; Note that the wrapper class `ROOT::Math::WrappedMultiTF1` implements also the gradient interface, using internally `TF1::GradientPar`,; which is based on numerical differentiation, apart for the case of linear functions (i.e. when `TF1::IsLinear()` is `true`).; The parameter derivatives of the model function can be useful to some minimization algorithms, such as Fumili.; However, in general is better to leave the minimization algorithm (e.g. Minuit) to compute the needed derivatives using its own customised; numerical differentiation algorithm.; In order to not provide to the fitter the parameter derivatives, we explicitly passed in `Fitter::SetFunction` a `false` value. ### Fit Configuration. The configuration of the fit is done via the `ROOT::Fit::FitConfig` class and its contained `ROOT::Fit::ParameterSettings` class.; These are the possible allowed fit configurations:. - setting the initial values of the parameters;; - setting the parameter step sizes;; - setting eventual parameter bounds;; - setting the minimizer library and the particular algorithm to use;; - setting different minimization options (print level, tolerance, max iterations, etc...); - setting the type of parameter errors to compute (parabolic error, Minos errors, re-normalize errors using fitted chi2 values). The initial parameter values can be set directly in the input model function object.; However, for setting parameter bounds and step sizes to values different than the automatically computed ones, one needs to use the `ROOT::Fit::ParameterSetting` class.; This example code will set the lower/upper bounds for the first parameter and a lower bound for the second parameter. ``` {.cpp}; fitter.SetFunction( fitFunction, false);; fitter.Config().ParSettings(0).SetLimits(0,1.E6);; fitter.Config().ParSettings(2).SetLowerLimit(0);; ```. Note that a `ROOT::Fit::P",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:39842,Modifiability,plug-in,plug-in,39842,"sing fitted chi2 values). The initial parameter values can be set directly in the input model function object.; However, for setting parameter bounds and step sizes to values different than the automatically computed ones, one needs to use the `ROOT::Fit::ParameterSetting` class.; This example code will set the lower/upper bounds for the first parameter and a lower bound for the second parameter. ``` {.cpp}; fitter.SetFunction( fitFunction, false);; fitter.Config().ParSettings(0).SetLimits(0,1.E6);; fitter.Config().ParSettings(2).SetLowerLimit(0);; ```. Note that a `ROOT::Fit::ParameterSettings` objects exists for each fit parameter and it created by the `ROOT::Fit::FitConfig` class, after the model function has been set in the Fitter.; Only when the function is set, the number of parameter is known and; automatically the `FitConfig` creates the corresponding `ParameterSetting` objects. When fitting, different minimizer can be used. The can be implemented in different libraries and loaded ar run time by the plug-in manager system of ROOT.; Each different minimizer (e.g. *Minuit, Minuit2, Fumili,* etc.) consists of a different implementation of the `ROOT::Math::Minimizer` interface.; Within the same minimizer, thus within the same class implementing the `Minimizer` interface, different algorithms can exist.; For example in the case of Minuit, we have *Migrad, Simplex* or *Minimize*. The minimizer and its corresponding algorithm, when available,; can be set by using the function `FitConfig::SetMinimizer(""minimizerName"")` or by using directly the `ROOT:Math::MinimizerOptions` class. If the requested minimizer is not available in ROOT, the default one is used. The default minimizer type and algorithm can be specified by using the; static function `ROOT::Math::MinimizerOptions::SetDefaultMinimizer(""minimizerName"")`. ### Minimizer Libraries and Algorithms. The list of available minimizer libraries currently available in ROOT, with their corresponding available algorithms ",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:42683,Modifiability,config,configured,42683,d.; No specific algorithm exists. - **`GSLMultiMin`** (library *libMathMore*). Minimizer based on the Multidimensional Minimization routines of the Gnu Scientific Library (GSL). The list of available algorithms is; 	- *`BFGS2`* (default) : second version of the vector Broyden-Fletcher-Goldfarb-Shanno (BFGS) algorithm;; 	- *`BFGS`* : old version of the vector Broyden-Fletcher-Goldfarb-Shanno (BFGS) algorithm;; 	- *`ConjugateFR`* : Fletcher-Reeves conjugate gradient algorithm;; 	- *`ConjugatePR`* : Polak-Ribiere conjugate gradient algorithm;; 	- *`SteepestDescent`*: steepest descent algorithm;. - **`GSLMultiFit`** (library *libMathMore*). Minimizer based on the Non-Linear Least-Square routines of GSL. This minimizer can be used only for least-square fits. - **`GSLSimAn`** (library *libMathMore*). Minimizer based on simulated annealing. - **`Genetic`** (library *libGenetic*). Genetic minimizer based on an algorithm implemented in the *TMVA* package. Each minimizer can be configured using the `ROOT::Math::MinimizerOptions` class. The list of possible option that can be set are:. * *Minimizer type* (`MinimizerOptions::SetMinimizerType(const char *)`) .; * *Minimizer algorithm* (`MinimizerOptions::SetMinimizerAlgorithm(const char *)`).; * *Print Level* (`MinimizerOptions::SetPrintLevel(int )`) to set the verbose printing level (default is 0).; * *Tolerance* (`MinimizerOptions::SetTolerance(double )`) tolerance used to control the iterations.; * *Maximum number of function calls* (`MinimizerOptions::SetMaxFunctionCalls(int )`).; * *Maximum number of iterations* (`MinimizerOptions::SetMaxIterations(int )`). Note that this is not used by *Minuit*; * *FCN Upper value for Error Definition* (`MinimizerOptions::SetErrorDef(double )`). Value in the minimization function used to compute the parameter errors.; The default is to get the uncertainties at the 68% CL is a value of 1 for a chi-squared function minimization and 0.5 for a log-likelihood function.; * *Strategy* (`MinimizerO,MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:43813,Modifiability,config,configuration,43813,"mizer type* (`MinimizerOptions::SetMinimizerType(const char *)`) .; * *Minimizer algorithm* (`MinimizerOptions::SetMinimizerAlgorithm(const char *)`).; * *Print Level* (`MinimizerOptions::SetPrintLevel(int )`) to set the verbose printing level (default is 0).; * *Tolerance* (`MinimizerOptions::SetTolerance(double )`) tolerance used to control the iterations.; * *Maximum number of function calls* (`MinimizerOptions::SetMaxFunctionCalls(int )`).; * *Maximum number of iterations* (`MinimizerOptions::SetMaxIterations(int )`). Note that this is not used by *Minuit*; * *FCN Upper value for Error Definition* (`MinimizerOptions::SetErrorDef(double )`). Value in the minimization function used to compute the parameter errors.; The default is to get the uncertainties at the 68% CL is a value of 1 for a chi-squared function minimization and 0.5 for a log-likelihood function.; * *Strategy* (`MinimizerOptions::SetStrategy(int )`), minimization strategy used. For each minimization strategy *Minuit* uses different configuration parameters; (e.g. different requirements in computing derivatives, computing full Hessian (strategy = 2) or an approximate version. The default is a value of 1. In this case the full Hessian matrix; is computed only after the minimization.; * *Precision* (`MinimizerOptions::SetPrecision(double )`). Precision value in the evaluation of the minimization function. Default is numerical double precision. Note that not all the options are implemented by all the minimizers.; For example in *Minuit* is possible to set the maximum number of function calls, but not the maximum number of iterations. The Strategy and the Precision options apply instead only for *Minuit* (and; *Minuit2*). The class supports also setting global default values for the options, by using the static functions `MinimizerOptions::SetDefault...` (for example `MinimizerOptions::SetDefaultPrintLevel(int )`). The; static functions can be also used to set the minimizer options when using `TH1::Fit` o",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:46133,Modifiability,extend,extended,46133,")`.; See the documentation of the particular minimizer to use for the list of possible additional options available. ### Performing the Fit. Here we have now all the required input ingredients for the fit, the data and the function to fit.; Depending on these we have now several different way to perform the fit, using the corresponding methods of the; `ROOT::Fit::Fitter` class and depending on the type of input data. #### Available fit methods. * **Least-square fit**: `Fitter::LeastSquare(const BinData & )` or `Fitter::Fit(const Bindata &)`. It requires the user to pass a `BinData` object. It should be used when the data values follow a; Gaussian distribution. This fit method is implemented using the class `ROOT::Fit::Chi2FCN`.; * **Binned Likelihood fit** : `Fitter::LikelihoodFit(const Bindata & )`. The user needs to pass a `BinData` object. It should be used when the data values follow a Poisson or a multinomial; distribution. The Poisson case (extended fit) is the default and in this case the function normalization is also fit to the data. The Multi-nominal case can be selected by passing the optional; *extended* boolean flag as *false*. This method is implemented by the class `ROOT::Fit:::PoissonLikelihoodFCN`.; * **Un-Binned likelihood fit**: `Fitter::LikelihoodFit(const UnBindata &)`. The user needs to pass an `UnBinData` object. By default the fit is not extended (i.e. the normalization is not fitted to the; data). As above the user can select an extended likelihood fit by passing the optional; *extended* boolean flag as *true*. This method is implemented using the class `LogLikelihoodFCN`; * **Linear Fit**: A linear fit can be selected (no iterative minimization is needed in this case, but using linear algebra algorithms from the *Matrix* library), if the model function is linear in the; parameters. #### Customised Fit methods. Above we described the pre-defined methods used for fitting. A user can also implement its own fitting methods, thus its version of ",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:46296,Modifiability,extend,extended,46296,"ailable. ### Performing the Fit. Here we have now all the required input ingredients for the fit, the data and the function to fit.; Depending on these we have now several different way to perform the fit, using the corresponding methods of the; `ROOT::Fit::Fitter` class and depending on the type of input data. #### Available fit methods. * **Least-square fit**: `Fitter::LeastSquare(const BinData & )` or `Fitter::Fit(const Bindata &)`. It requires the user to pass a `BinData` object. It should be used when the data values follow a; Gaussian distribution. This fit method is implemented using the class `ROOT::Fit::Chi2FCN`.; * **Binned Likelihood fit** : `Fitter::LikelihoodFit(const Bindata & )`. The user needs to pass a `BinData` object. It should be used when the data values follow a Poisson or a multinomial; distribution. The Poisson case (extended fit) is the default and in this case the function normalization is also fit to the data. The Multi-nominal case can be selected by passing the optional; *extended* boolean flag as *false*. This method is implemented by the class `ROOT::Fit:::PoissonLikelihoodFCN`.; * **Un-Binned likelihood fit**: `Fitter::LikelihoodFit(const UnBindata &)`. The user needs to pass an `UnBinData` object. By default the fit is not extended (i.e. the normalization is not fitted to the; data). As above the user can select an extended likelihood fit by passing the optional; *extended* boolean flag as *true*. This method is implemented using the class `LogLikelihoodFCN`; * **Linear Fit**: A linear fit can be selected (no iterative minimization is needed in this case, but using linear algebra algorithms from the *Matrix* library), if the model function is linear in the; parameters. #### Customised Fit methods. Above we described the pre-defined methods used for fitting. A user can also implement its own fitting methods, thus its version of the chi-square or likelihood function he wants to minimize.; In this case, the user does not really need to ",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:46556,Modifiability,extend,extended,46556,"ass and depending on the type of input data. #### Available fit methods. * **Least-square fit**: `Fitter::LeastSquare(const BinData & )` or `Fitter::Fit(const Bindata &)`. It requires the user to pass a `BinData` object. It should be used when the data values follow a; Gaussian distribution. This fit method is implemented using the class `ROOT::Fit::Chi2FCN`.; * **Binned Likelihood fit** : `Fitter::LikelihoodFit(const Bindata & )`. The user needs to pass a `BinData` object. It should be used when the data values follow a Poisson or a multinomial; distribution. The Poisson case (extended fit) is the default and in this case the function normalization is also fit to the data. The Multi-nominal case can be selected by passing the optional; *extended* boolean flag as *false*. This method is implemented by the class `ROOT::Fit:::PoissonLikelihoodFCN`.; * **Un-Binned likelihood fit**: `Fitter::LikelihoodFit(const UnBindata &)`. The user needs to pass an `UnBinData` object. By default the fit is not extended (i.e. the normalization is not fitted to the; data). As above the user can select an extended likelihood fit by passing the optional; *extended* boolean flag as *true*. This method is implemented using the class `LogLikelihoodFCN`; * **Linear Fit**: A linear fit can be selected (no iterative minimization is needed in this case, but using linear algebra algorithms from the *Matrix* library), if the model function is linear in the; parameters. #### Customised Fit methods. Above we described the pre-defined methods used for fitting. A user can also implement its own fitting methods, thus its version of the chi-square or likelihood function he wants to minimize.; In this case, the user does not really need to build as input a `ROOT::Fit` data set and model function as we described before. He can implements its own version of the method function using on its own; data set objects and functions. In this case `ROOT::Fit::Fitter::SetFCN` is used to set the method function and `",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:46650,Modifiability,extend,extended,46650,"Data & )` or `Fitter::Fit(const Bindata &)`. It requires the user to pass a `BinData` object. It should be used when the data values follow a; Gaussian distribution. This fit method is implemented using the class `ROOT::Fit::Chi2FCN`.; * **Binned Likelihood fit** : `Fitter::LikelihoodFit(const Bindata & )`. The user needs to pass a `BinData` object. It should be used when the data values follow a Poisson or a multinomial; distribution. The Poisson case (extended fit) is the default and in this case the function normalization is also fit to the data. The Multi-nominal case can be selected by passing the optional; *extended* boolean flag as *false*. This method is implemented by the class `ROOT::Fit:::PoissonLikelihoodFCN`.; * **Un-Binned likelihood fit**: `Fitter::LikelihoodFit(const UnBindata &)`. The user needs to pass an `UnBinData` object. By default the fit is not extended (i.e. the normalization is not fitted to the; data). As above the user can select an extended likelihood fit by passing the optional; *extended* boolean flag as *true*. This method is implemented using the class `LogLikelihoodFCN`; * **Linear Fit**: A linear fit can be selected (no iterative minimization is needed in this case, but using linear algebra algorithms from the *Matrix* library), if the model function is linear in the; parameters. #### Customised Fit methods. Above we described the pre-defined methods used for fitting. A user can also implement its own fitting methods, thus its version of the chi-square or likelihood function he wants to minimize.; In this case, the user does not really need to build as input a `ROOT::Fit` data set and model function as we described before. He can implements its own version of the method function using on its own; data set objects and functions. In this case `ROOT::Fit::Fitter::SetFCN` is used to set the method function and `ROOT::Fit::FitFCN` is used for fitting. The method function can be passed also in `ROOT::Fit::FitFCN`, but in this; case a pre",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:46700,Modifiability,extend,extended,46700,"Data & )` or `Fitter::Fit(const Bindata &)`. It requires the user to pass a `BinData` object. It should be used when the data values follow a; Gaussian distribution. This fit method is implemented using the class `ROOT::Fit::Chi2FCN`.; * **Binned Likelihood fit** : `Fitter::LikelihoodFit(const Bindata & )`. The user needs to pass a `BinData` object. It should be used when the data values follow a Poisson or a multinomial; distribution. The Poisson case (extended fit) is the default and in this case the function normalization is also fit to the data. The Multi-nominal case can be selected by passing the optional; *extended* boolean flag as *false*. This method is implemented by the class `ROOT::Fit:::PoissonLikelihoodFCN`.; * **Un-Binned likelihood fit**: `Fitter::LikelihoodFit(const UnBindata &)`. The user needs to pass an `UnBinData` object. By default the fit is not extended (i.e. the normalization is not fitted to the; data). As above the user can select an extended likelihood fit by passing the optional; *extended* boolean flag as *true*. This method is implemented using the class `LogLikelihoodFCN`; * **Linear Fit**: A linear fit can be selected (no iterative minimization is needed in this case, but using linear algebra algorithms from the *Matrix* library), if the model function is linear in the; parameters. #### Customised Fit methods. Above we described the pre-defined methods used for fitting. A user can also implement its own fitting methods, thus its version of the chi-square or likelihood function he wants to minimize.; In this case, the user does not really need to build as input a `ROOT::Fit` data set and model function as we described before. He can implements its own version of the method function using on its own; data set objects and functions. In this case `ROOT::Fit::Fitter::SetFCN` is used to set the method function and `ROOT::Fit::FitFCN` is used for fitting. The method function can be passed also in `ROOT::Fit::FitFCN`, but in this; case a pre",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:47699,Modifiability,config,configuration,47699,"nded likelihood fit by passing the optional; *extended* boolean flag as *true*. This method is implemented using the class `LogLikelihoodFCN`; * **Linear Fit**: A linear fit can be selected (no iterative minimization is needed in this case, but using linear algebra algorithms from the *Matrix* library), if the model function is linear in the; parameters. #### Customised Fit methods. Above we described the pre-defined methods used for fitting. A user can also implement its own fitting methods, thus its version of the chi-square or likelihood function he wants to minimize.; In this case, the user does not really need to build as input a `ROOT::Fit` data set and model function as we described before. He can implements its own version of the method function using on its own; data set objects and functions. In this case `ROOT::Fit::Fitter::SetFCN` is used to set the method function and `ROOT::Fit::FitFCN` is used for fitting. The method function can be passed also in `ROOT::Fit::FitFCN`, but in this; case a previously defined fitting configuration is used. The possible type of method functions that are based in `ROOT::Fit::Fitter::SetFCN` are:. * A generic functor object implementing `operator()(const double * p)` where **`p`** is the parameter vectors. In this case one needs to pass the number of parameters,; the function object and optionally a vector of initial parameter values. Other optional parameter include the size of the data sets and a flag specifying if it is a chi2 (least-square fit).; In the last two parameters are given, the `chi2/ndf` can be computed after fitting the data.; ``` {.cpp}; template <class Function>; bool Fitter::SetFCN(unsigned int npar, Function & f,; const double * initialParameters = 0,; unsigned int dataSize=0, bool isChi2Fit = false); ```. * A function object implementing the `ROOT::Math::IBaseFunctionMultiDim` interface:; ``` {.cpp}; bool Fitter::SetFCN(const ROOT::Math::IBaseFunctionMultiDim & f,; const double * initialParameters = 0,; ",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:48817,Modifiability,extend,extending,48817,"or()(const double * p)` where **`p`** is the parameter vectors. In this case one needs to pass the number of parameters,; the function object and optionally a vector of initial parameter values. Other optional parameter include the size of the data sets and a flag specifying if it is a chi2 (least-square fit).; In the last two parameters are given, the `chi2/ndf` can be computed after fitting the data.; ``` {.cpp}; template <class Function>; bool Fitter::SetFCN(unsigned int npar, Function & f,; const double * initialParameters = 0,; unsigned int dataSize=0, bool isChi2Fit = false); ```. * A function object implementing the `ROOT::Math::IBaseFunctionMultiDim` interface:; ``` {.cpp}; bool Fitter::SetFCN(const ROOT::Math::IBaseFunctionMultiDim & f,; const double * initialParameters = 0,; unsigned int dataSize=0, bool isChi2Fit = false); ```. * A function object implementing the `ROOT::Math::FitMethodFunction` interface. This is an interface class extending; the `ROOT::Math::IBaseFunctionMultiDim` with some extra functionality which can be used when fitting.; This extra functionality is required by dedicated fitting algorithms like *Fumili* or *GSLMultiFit*.; ``` {.cpp}; bool Fitter::SetFCN(const ROOT::Math::FitMethodFunction & f,; const double * initialParameters = 0, unsigned int dataSize=0); ```. * A old-Minuit like FCN interface (i.e. a free function with the signature `fcn(int &npar, double *gin, double &f, double *u, int flag)`.; ``` {.cpp}; typedef void(* MinuitFCN)(int &npar, double *gin, double &f, double *u, int flag); bool Fitter::SetFCN(MinuitFCN fcn, int npar,; const double * initialParameters = 0,; unsigned int dataSize=0, bool isChi2Fit = false); ```. ### Fit Result. The result of the fit is contained in the `ROOT::Fit::Result` object. A reference to the result object is obtained with the function; `Fitter::Result()`.; The `ROOT::Fit::FitResult` class provides an API for retrieving parameter values, errors, covariance and correlation matrix from the fit,;",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:52077,Modifiability,config,configure,52077,"d can be obtained by an automatic conversion of the TFitResultPtr to an integer. If the fit option *`S`* is instead used, `TFitResultPtr` contains the `TFitResult` and behaves as a smart; pointer to it. This is an example:. ``` {.cpp}; int fitStatus = hist->Fit(myFunction); // TFitResultPtr contains only the fit status. TFitResultPtr r = hist->Fit(myFunction,""S""); // TFitResultPtr contains the TFitResult; TMatrixDSym cov = r->GetCovarianceMatrix(); // to access the covariance matrix; Double_t chi2 = r->Chi2(); // to retrieve the fit chi2; Double_t par0 = r->Parameter(0); // retrieve the value for the parameter 0; Double_t err0 = r->ParError(0); // retrieve the error for the parameter 0; r->Print(""V""); // print full information of fit including covariance matrix; r->Write(); // store the result in a file; ```. ## The Minimization packages. As explained before various minimization packages can be used when fitting in ROOT.; We have seen before how to configure the `Fitter` class to use different minimization packages; and different minimization options.; When using the `Fit` method the minimization package (and its options) can be selected using the; static methods of the `ROOT::Math::MinimizerOptions` class.; For example to select `Minuit2` instead of `Minuit` for fitting an histogram do:. ``` {.cpp}; ROOT::Math::MinimizerOptions::SetDefaultMinimizer(""Minuit2"");; // fit the histogram histo with the gaussian pre-defined function; histo->Fit(""gaus"");; ```. In the following we will give some brief description of the minimization packages.; The packages all implement the `ROOT::Math::Minimizer` interface which can be use for; finding the minimum of a multi-dimensional function.; The interface is documented in the Mathematical Library Chapter. In addition packages like Minuit or Minuit2 provide their own interfaces. ## MINUIT (Old TMInuit Version). This package was originally written in FORTRAN by Fred James and part; of `PACKLIB` (patch D506). It has been converted to a C",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:53268,Modifiability,variab,variables,53268,"zerOptions` class.; For example to select `Minuit2` instead of `Minuit` for fitting an histogram do:. ``` {.cpp}; ROOT::Math::MinimizerOptions::SetDefaultMinimizer(""Minuit2"");; // fit the histogram histo with the gaussian pre-defined function; histo->Fit(""gaus"");; ```. In the following we will give some brief description of the minimization packages.; The packages all implement the `ROOT::Math::Minimizer` interface which can be use for; finding the minimum of a multi-dimensional function.; The interface is documented in the Mathematical Library Chapter. In addition packages like Minuit or Minuit2 provide their own interfaces. ## MINUIT (Old TMInuit Version). This package was originally written in FORTRAN by Fred James and part; of `PACKLIB` (patch D506). It has been converted to a C++ class by; René Brun. The current implementation in C++ is a straightforward; conversion of the original FORTRAN version. The main changes are:. - The variables in the various `Minuit` labeled common blocks have; been changed to the **`TMinuit`** class data members. - The internal arrays with a maximum dimension depending on the; maximum number of parameters are now data members' arrays with a; dynamic dimension such that one can fit very large problems by; simply initializing the **`TMinuit`** constructor with the maximum; number of parameters. - The include file `Minuit.h` has been commented as much as possible; using existing comments in the code or the printed documentation. - The original `Minuit` subroutines are now member functions. - Constructors and destructor have been added. - Instead of passing the `FCN` function in the argument list, the; addresses of this function is stored as pointer in the data; members of the class. This is by far more elegant and flexible in; an interactive environment. The member function `SetFCN` can be; used to define this pointer. - The ROOT static function `Printf` is provided to replace all; format statements and to print on currently defined out",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:54096,Modifiability,flexible,flexible,54096,"converted to a C++ class by; René Brun. The current implementation in C++ is a straightforward; conversion of the original FORTRAN version. The main changes are:. - The variables in the various `Minuit` labeled common blocks have; been changed to the **`TMinuit`** class data members. - The internal arrays with a maximum dimension depending on the; maximum number of parameters are now data members' arrays with a; dynamic dimension such that one can fit very large problems by; simply initializing the **`TMinuit`** constructor with the maximum; number of parameters. - The include file `Minuit.h` has been commented as much as possible; using existing comments in the code or the printed documentation. - The original `Minuit` subroutines are now member functions. - Constructors and destructor have been added. - Instead of passing the `FCN` function in the argument list, the; addresses of this function is stored as pointer in the data; members of the class. This is by far more elegant and flexible in; an interactive environment. The member function `SetFCN` can be; used to define this pointer. - The ROOT static function `Printf` is provided to replace all; format statements and to print on currently defined output file. - The functions `SetObjectFit/GetObjectFit` can be used inside the; `FCN` function to set/get a referenced object instead of using; global variables. - By default `fGraphicsMode` is true. When calling the `Minuit`; functions such as `mncont`, `mnscan`, or any `Minuit` command; invoking `mnplot`, `TMinuit::mnplot()` produces a **`TGraph`**; object pointed by `fPlot`. One can retrieve this object with; **`TMinuit`**`::GetPlot().` For example:. ``` {.cpp}; h->Fit(""gaus"");; gMinuit->Command(""SCAn 1"");; TGraph *gr = (TGraph*)gMinuit->GetPlot();; gr->SetMarkerStyle(21);; gr->Draw(""alp"");; ```. - To set `Minuit` in no graphics mode, call. ``` {.cpp}; gMinuit->SetGraphicsMode(kFALSE);; ```. ### Basic Concepts of Minuit. The `Minuit` package acts on a multi parameter",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:54471,Modifiability,variab,variables,54471,"with a maximum dimension depending on the; maximum number of parameters are now data members' arrays with a; dynamic dimension such that one can fit very large problems by; simply initializing the **`TMinuit`** constructor with the maximum; number of parameters. - The include file `Minuit.h` has been commented as much as possible; using existing comments in the code or the printed documentation. - The original `Minuit` subroutines are now member functions. - Constructors and destructor have been added. - Instead of passing the `FCN` function in the argument list, the; addresses of this function is stored as pointer in the data; members of the class. This is by far more elegant and flexible in; an interactive environment. The member function `SetFCN` can be; used to define this pointer. - The ROOT static function `Printf` is provided to replace all; format statements and to print on currently defined output file. - The functions `SetObjectFit/GetObjectFit` can be used inside the; `FCN` function to set/get a referenced object instead of using; global variables. - By default `fGraphicsMode` is true. When calling the `Minuit`; functions such as `mncont`, `mnscan`, or any `Minuit` command; invoking `mnplot`, `TMinuit::mnplot()` produces a **`TGraph`**; object pointed by `fPlot`. One can retrieve this object with; **`TMinuit`**`::GetPlot().` For example:. ``` {.cpp}; h->Fit(""gaus"");; gMinuit->Command(""SCAn 1"");; TGraph *gr = (TGraph*)gMinuit->GetPlot();; gr->SetMarkerStyle(21);; gr->Draw(""alp"");; ```. - To set `Minuit` in no graphics mode, call. ``` {.cpp}; gMinuit->SetGraphicsMode(kFALSE);; ```. ### Basic Concepts of Minuit. The `Minuit` package acts on a multi parameter FORTRAN function to; which one must give the generic name `FCN`. In the ROOT; implementation, the function `FCN` is defined via the `Minuit`; `SetFCN` member function when an histogram fitting is invoked. The; value of `FCN` will in general depend on one or more variable; parameters. ### The Transformati",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:55364,Modifiability,variab,variable,55364,"ns `SetObjectFit/GetObjectFit` can be used inside the; `FCN` function to set/get a referenced object instead of using; global variables. - By default `fGraphicsMode` is true. When calling the `Minuit`; functions such as `mncont`, `mnscan`, or any `Minuit` command; invoking `mnplot`, `TMinuit::mnplot()` produces a **`TGraph`**; object pointed by `fPlot`. One can retrieve this object with; **`TMinuit`**`::GetPlot().` For example:. ``` {.cpp}; h->Fit(""gaus"");; gMinuit->Command(""SCAn 1"");; TGraph *gr = (TGraph*)gMinuit->GetPlot();; gr->SetMarkerStyle(21);; gr->Draw(""alp"");; ```. - To set `Minuit` in no graphics mode, call. ``` {.cpp}; gMinuit->SetGraphicsMode(kFALSE);; ```. ### Basic Concepts of Minuit. The `Minuit` package acts on a multi parameter FORTRAN function to; which one must give the generic name `FCN`. In the ROOT; implementation, the function `FCN` is defined via the `Minuit`; `SetFCN` member function when an histogram fitting is invoked. The; value of `FCN` will in general depend on one or more variable; parameters. ### The Transformation of Limited Parameters. For variable parameters with limits, `Minuit` uses the following; transformation:. `Pint = arcsin(2((Pext-a)/(b-a))-1) `. `Pext = a+((b-a)/(2))(sinPint+1)`. so that the internal value `Pint` can take on any value, while the; external value Pext can take on values only between the lower limit a; and the ext upper limit b. Since the transformation is necessarily; non-linear, it would transform a nice linear problem into a nasty; non-linear one, which is the reason why limits should be avoided if; not necessary. In addition, the transformation does require some; computer time, so it slows down the computation a little bit, and more; importantly, it introduces additional numerical inaccuracy into the; problem in addition to what is introduced in the numerical calculation; of the FCN value. The effects of non-linearity and numerical round off; both become more important as the external value gets closer t",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:55436,Modifiability,variab,variable,55436,"ariables. - By default `fGraphicsMode` is true. When calling the `Minuit`; functions such as `mncont`, `mnscan`, or any `Minuit` command; invoking `mnplot`, `TMinuit::mnplot()` produces a **`TGraph`**; object pointed by `fPlot`. One can retrieve this object with; **`TMinuit`**`::GetPlot().` For example:. ``` {.cpp}; h->Fit(""gaus"");; gMinuit->Command(""SCAn 1"");; TGraph *gr = (TGraph*)gMinuit->GetPlot();; gr->SetMarkerStyle(21);; gr->Draw(""alp"");; ```. - To set `Minuit` in no graphics mode, call. ``` {.cpp}; gMinuit->SetGraphicsMode(kFALSE);; ```. ### Basic Concepts of Minuit. The `Minuit` package acts on a multi parameter FORTRAN function to; which one must give the generic name `FCN`. In the ROOT; implementation, the function `FCN` is defined via the `Minuit`; `SetFCN` member function when an histogram fitting is invoked. The; value of `FCN` will in general depend on one or more variable; parameters. ### The Transformation of Limited Parameters. For variable parameters with limits, `Minuit` uses the following; transformation:. `Pint = arcsin(2((Pext-a)/(b-a))-1) `. `Pext = a+((b-a)/(2))(sinPint+1)`. so that the internal value `Pint` can take on any value, while the; external value Pext can take on values only between the lower limit a; and the ext upper limit b. Since the transformation is necessarily; non-linear, it would transform a nice linear problem into a nasty; non-linear one, which is the reason why limits should be avoided if; not necessary. In addition, the transformation does require some; computer time, so it slows down the computation a little bit, and more; importantly, it introduces additional numerical inaccuracy into the; problem in addition to what is introduced in the numerical calculation; of the FCN value. The effects of non-linearity and numerical round off; both become more important as the external value gets closer to one of; the limits (expressed as the distance to nearest limit divided by; distance between limits). The user must therefore b",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:57137,Modifiability,variab,variable,57137,"merical calculation; of the FCN value. The effects of non-linearity and numerical round off; both become more important as the external value gets closer to one of; the limits (expressed as the distance to nearest limit divided by; distance between limits). The user must therefore be aware of the fact; that, for example, if they put limits of (0, 1010) on a parameter, then; the values 0.0 and 1. 0 will be indistinguishable to the accuracy of; most machines. The transformation also affects the parameter error matrix, of course,; so Minuit does a transformation of the error matrix (and the; ''parabolic'' parameter errors) when there are parameter limits. Users; should however realize that the transformation is only a linear; approximation, and that it cannot give a meaningful result if one or; more parameters is very close to a limit, where; $\frac{\partial Pext}{\partial Pint} \neq 0$. Therefore, it is; recommended that:. - Limits on variable parameters should be used only when needed in; order to prevent the parameter from taking on unphysical values. - When a satisfactory minimum has been found using limits, the; limits should then be removed if possible, in order to perform or; re-perform the error analysis without limits. ### How to Get the Right Answer from Minuit. `Minuit` offers the user a choice of several minimization algorithms.; The `MIGRAD` algorithm is in general the best minimized for nearly all; functions. It is a variable-metric method with inexact line search, a; stable metric updating scheme, and checks for positive-definiteness.; Its main weakness is that it depends heavily on knowledge of the first; derivatives, and fails miserably if they are very inaccurate. If parameter limits are needed, in spite of the side effects, then the; user should be aware of the following techniques to alleviate problems; caused by limits:. #### Getting the Right Minimum with Limits. If MIGRAD converges normally to a point where no parameter is near one; of its limits,",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:57642,Modifiability,variab,variable-metric,57642," error matrix, of course,; so Minuit does a transformation of the error matrix (and the; ''parabolic'' parameter errors) when there are parameter limits. Users; should however realize that the transformation is only a linear; approximation, and that it cannot give a meaningful result if one or; more parameters is very close to a limit, where; $\frac{\partial Pext}{\partial Pint} \neq 0$. Therefore, it is; recommended that:. - Limits on variable parameters should be used only when needed in; order to prevent the parameter from taking on unphysical values. - When a satisfactory minimum has been found using limits, the; limits should then be removed if possible, in order to perform or; re-perform the error analysis without limits. ### How to Get the Right Answer from Minuit. `Minuit` offers the user a choice of several minimization algorithms.; The `MIGRAD` algorithm is in general the best minimized for nearly all; functions. It is a variable-metric method with inexact line search, a; stable metric updating scheme, and checks for positive-definiteness.; Its main weakness is that it depends heavily on knowledge of the first; derivatives, and fails miserably if they are very inaccurate. If parameter limits are needed, in spite of the side effects, then the; user should be aware of the following techniques to alleviate problems; caused by limits:. #### Getting the Right Minimum with Limits. If MIGRAD converges normally to a point where no parameter is near one; of its limits, then the existence of limits has probably not prevented; `Minuit` from finding the right minimum. On the other hand, if one or; more parameters is near its limit at the minimum, this may be because; the true minimum is indeed at a limit, or it may be because the; minimized has become ''blocked'' at a limit. This may normally happen; only if the parameter is so close to a limit (internal value at an odd; multiple of $\pm \frac{\pi}{2}$ that `Minuit` prints a warning to this; effect when it prints the p",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:61886,Modifiability,parameteriz,parameterized,61886,"a problem. `Minuit`, when it; prints out error values, also gives some indication of how reliable it; thinks they are. For example, those marked `CURRENT GUESS ERROR` are; only working values not to be believed, and `APPROXIMATE ERROR` means; that they have been calculated but there is reason to believe that; they may not be accurate. If no mitigating adjective is given, then at least `Minuit` believes; the errors are accurate, although there is always a small chance that; `Minuit` has been fooled. Some visible signs that `Minuit` may have; been fooled:. - Warning messages produced during the minimization or error; analysis. - Failure to find new minimum. - Value of EDM too big (estimated Distance to Minimum). - Correlation coefficients exactly equal to zero, unless some; parameters are known to be uncorrelated with the others. - Correlation coefficients very close to one (greater than 0.99).; This indicates both an exceptionally difficult problem, and one; which has been badly parameterized so that individual errors are; not very meaningful because they are so highly correlated. - Parameter at limit. This condition, signaled by a `Minuit` warning; message, may make both the function minimum and parameter errors; unreliable. See the discussion above ‘Getting the right parameter; errors with limits'. The best way to be absolutely sure of the errors is to use; ''independent'' calculations and compare them, or compare the; calculated errors with a picture of the function. Theoretically, the; covariance matrix for a ''physical'' function must be; positive-definite at the minimum, although it may not be so for all; points far away from the minimum, even for a well-determined physical; problem. Therefore, if `MIGRAD` reports that it has found a; non-positive-definite covariance matrix, this may be a sign of one or; more of the following:. #### A Non-physical Region. On its way to the minimum, `MIGRAD` may have traversed a region that; has unphysical behavior, which is of c",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:63201,Modifiability,parameteriz,parameterization,63201,"iable. See the discussion above ‘Getting the right parameter; errors with limits'. The best way to be absolutely sure of the errors is to use; ''independent'' calculations and compare them, or compare the; calculated errors with a picture of the function. Theoretically, the; covariance matrix for a ''physical'' function must be; positive-definite at the minimum, although it may not be so for all; points far away from the minimum, even for a well-determined physical; problem. Therefore, if `MIGRAD` reports that it has found a; non-positive-definite covariance matrix, this may be a sign of one or; more of the following:. #### A Non-physical Region. On its way to the minimum, `MIGRAD` may have traversed a region that; has unphysical behavior, which is of course not a serious problem as; long as it recovers and leaves such a region. #### An Underdetermined Problem. If the matrix is not positive-definite even at the minimum, this may; mean that the solution is not well defined, for example that there are; more unknowns than there are data points, or that the parameterization; of the fit contains a linear dependence. If this is the case, then; `Minuit` (or any other program) cannot solve your problem uniquely.; The error matrix will necessarily be largely meaningless, so the user; must remove the under determinedness by reformulating the; parameterization. `Minuit` cannot do this itself. #### Numerical Inaccuracies. It is possible that the apparent lack of positive-definiteness is due; to excessive round off errors in numerical calculations (in the user; function), or not enough precision. This is unlikely in general, but; becomes more likely if the number of free parameters is very large, or; if the parameters are badly scaled (not all of the same order of; magnitude), and correlations are large. In any case, whether the; non-positive-definiteness is real or only numerical is largely; irrelevant, since in both cases the error matrix will be unreliable; and the minimum sus",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:63486,Modifiability,parameteriz,parameterization,63486," a ''physical'' function must be; positive-definite at the minimum, although it may not be so for all; points far away from the minimum, even for a well-determined physical; problem. Therefore, if `MIGRAD` reports that it has found a; non-positive-definite covariance matrix, this may be a sign of one or; more of the following:. #### A Non-physical Region. On its way to the minimum, `MIGRAD` may have traversed a region that; has unphysical behavior, which is of course not a serious problem as; long as it recovers and leaves such a region. #### An Underdetermined Problem. If the matrix is not positive-definite even at the minimum, this may; mean that the solution is not well defined, for example that there are; more unknowns than there are data points, or that the parameterization; of the fit contains a linear dependence. If this is the case, then; `Minuit` (or any other program) cannot solve your problem uniquely.; The error matrix will necessarily be largely meaningless, so the user; must remove the under determinedness by reformulating the; parameterization. `Minuit` cannot do this itself. #### Numerical Inaccuracies. It is possible that the apparent lack of positive-definiteness is due; to excessive round off errors in numerical calculations (in the user; function), or not enough precision. This is unlikely in general, but; becomes more likely if the number of free parameters is very large, or; if the parameters are badly scaled (not all of the same order of; magnitude), and correlations are large. In any case, whether the; non-positive-definiteness is real or only numerical is largely; irrelevant, since in both cases the error matrix will be unreliable; and the minimum suspicious. #### An Ill-posed Problem. For questions of parameter dependence, see the discussion above on; positive-definiteness. Possible other mathematical problems are the; following:. - Excessive numerical round off - be especially careful of; exponential and factorial functions which get big ve",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:64578,Modifiability,variab,variables,64578,"this itself. #### Numerical Inaccuracies. It is possible that the apparent lack of positive-definiteness is due; to excessive round off errors in numerical calculations (in the user; function), or not enough precision. This is unlikely in general, but; becomes more likely if the number of free parameters is very large, or; if the parameters are badly scaled (not all of the same order of; magnitude), and correlations are large. In any case, whether the; non-positive-definiteness is real or only numerical is largely; irrelevant, since in both cases the error matrix will be unreliable; and the minimum suspicious. #### An Ill-posed Problem. For questions of parameter dependence, see the discussion above on; positive-definiteness. Possible other mathematical problems are the; following:. - Excessive numerical round off - be especially careful of; exponential and factorial functions which get big very quickly and; lose accuracy. - Starting too far from the solution - the function may have; unphysical local minima, especially at infinity in some variables. ## Minuit2 Package. `Minuit2` is a new object-oriented implementation, written in C++, of; the popular `MINUIT` minimization package. Compared with the; **`TMinuit`** class, which is a direct conversion from FORTRAN to C++,; `Minuit2` is a complete redesign and re-implementation of the package.; This new version provides all the functionality present in the old; FORTRAN version, with almost equivalent numerical accuracy and; computational performances.; Furthermore, it contains some fixes and small improvements and this new functionality:; * The possibility to set single side parameter limits; * the FUMILI algorithm (see the next paragraph ""FUMILI Minimization Package""),; which is an optimized method for least square and log; likelihood minimizations. Minuit2 has been originally developed by M.; Winkler and F. James in the SEAL project. More information can be found; on the [MINUIT Web Site](MINUIT Web Site) and in partic",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:66006,Modifiability,plug-in,plug-ins,66006,"onal performances.; Furthermore, it contains some fixes and small improvements and this new functionality:; * The possibility to set single side parameter limits; * the FUMILI algorithm (see the next paragraph ""FUMILI Minimization Package""),; which is an optimized method for least square and log; likelihood minimizations. Minuit2 has been originally developed by M.; Winkler and F. James in the SEAL project. More information can be found; on the [MINUIT Web Site](MINUIT Web Site) and in particular at the; following documentation page at; <http://www.cern.ch/minuit/doc/doc.html>. A detailed User Guide for Minuit2 exists, describing the API of the internal classes.; ROOT uses `Minuit2` for fitting via the `Minuit2Minimizer` class which implements; the `ROOT::Math::Minimizer` interface. `Minuit2` is also distributed as an independent package of ROOT and can be built; without any other dependency on the ROOT libraries. Examples on how to use the `Minuit2` and `Fumili2` plug-ins are provided; in the tutorials' directory `$ROOTSYS/tutorials/fit`:; `minuit2FitBench.C`, `minuit2FitBench2D.C` and `minuit2GausFit.C`.; More information on the classes and functions present in `Minuit2` is; available at; [online reference documentation](online reference documentation). Useful information on MINUIT and minimization in general is provided in the; following documents:. F. James, *Minuit Tutorial on Function Minimization* (; <http://seal.cern.ch/documents/minuit/mntutorial.pdf>); F. James, *The; Interpretation of Errors in Minuit* (; <http://seal.cern.ch/documents/minuit/mnerror.pdf>);. ## FUMILI Minimization Package. FUMILI is used to minimize Chi-square function or to search maximum of; likelihood function. Experimentally measured values $F_{i}$ are fitted; with theoretical; functions $f_{i}(\vec{x_{i}},\vec{\theta})$, where $\vec{x_{i}}$ are; coordinates, and $\vec{\theta}$ - vector of parameters.; For better convergence Chi-square function has to be the following form. $$; \frac{\",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:71081,Modifiability,layers,layers,71081,"ysis, financial movements'; predictions and analysis, or sales forecast and product shipping; optimization. In particles physics neural networks are mainly used for; classification tasks (signal over background discrimination). A vast; majority of commonly used neural networks are multilayer perceptrons.; This implementation of multilayer perceptrons is inspired from the; `MLPfit` package, which remains one of the fastest tools for neural; networks studies. ### The MLP. The multilayer perceptron is a simple feed-forward network with the; following structure showed on the left. ![](pictures/0300008D.png). It is made of neurons characterized by a bias and weighted links in; between - let's call those links synapses. The input neurons receive; the inputs, normalize them and forward them to the first hidden layer.; Each neuron in any subsequent layer first computes a linear; combination of the outputs of the previous layer. The output of the; neuron is then function of that combination with f being linear for; output neurons or a sigmoid for hidden layers. Such a structure is very useful because of two theorems:. 1- A linear combination of `sigmoids` can approximate any continuous; function. 2- Trained with `output=1` for the signal and 0 for the background,; the approximated function of inputs `X` is the probability of signal,; knowing `X`. ### Learning Methods. The aim of all learning methods is to minimize the total error on a; set of weighted examples. The error is defined as the sum in quadrate,; divided by two, of the error on each individual output neuron. In all; methods implemented in this library, one needs to compute the first; derivative of that error with respect to the weights. Exploiting the; well-known properties of the derivative, one can express this; derivative as the product of the local partial derivative by the; weighted sum of the outputs derivatives (for a neuron) or as the; product of the input value with the local partial derivative of the; outp",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:74396,Modifiability,layers,layers,74396,"reset to the steepest descent (estimated by; using the Polak-Ribiere formula). #### Conjugate Gradients With the Fletcher-Reeves Updating Formula. Weights are set to the minimum along the line defined by the conjugate; gradient. Parameters are `Tau` and `Reset`, which defines the epochs; where the direction is reset to the steepest descent (estimated by; using the Fletcher-Reeves formula). #### The Broyden, Fletcher, Goldfarb, Shanno (BFGS) Method. It implies the computation of a `NxN` matrix, but seems more powerful; at least for less than 300 weights. Parameters are `Tau` and `Reset`,; which defines the epochs where the direction is reset to the steepest; descent. ### Using the Network. Neural network are build from a set of ""samples"". A sample is a set of; values defining the inputs and the corresponding output that the; network should ideally provide. In ROOT this is a **`TTree`** entry.; The first thing to be decided is the network layout. This layout is; described in a string where the layers are separated by semicolons.; The input/output layers are defined by giving the expression for each; neuron, separated by comas. Hidden layers are just described by the; number of neurons. In addition, input and output layer formulas can be preceded by '@'; (e.g. ""@out"") if one wants to normalize the corresponding value. Also,; if the string ends with '`!`', output neurons are set up for; classification, i.e. with a sigmoid (1 neuron) or softmax (more; neurons) activation function. Many questions on the good usage of neural network, including rules of; dumb to determine the best network topology are addressed at; <ftp://ftp.sas.com/pub/neural/FAQ.html>. ``` {.cpp}; // a simple network: 2 inputs, 10 hidden and 1 normalized; // output neuron; TMultiLayerPerceptron network(""r,z:10:@Br"",tree);; ```. Expressions are evaluated as for `TTree::Draw()`. Input and outputs; are taken from the **`TTree`** associated with the network. This; **`TTree`** can be given as argument of the ",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:74450,Modifiability,layers,layers,74450,"e Gradients With the Fletcher-Reeves Updating Formula. Weights are set to the minimum along the line defined by the conjugate; gradient. Parameters are `Tau` and `Reset`, which defines the epochs; where the direction is reset to the steepest descent (estimated by; using the Fletcher-Reeves formula). #### The Broyden, Fletcher, Goldfarb, Shanno (BFGS) Method. It implies the computation of a `NxN` matrix, but seems more powerful; at least for less than 300 weights. Parameters are `Tau` and `Reset`,; which defines the epochs where the direction is reset to the steepest; descent. ### Using the Network. Neural network are build from a set of ""samples"". A sample is a set of; values defining the inputs and the corresponding output that the; network should ideally provide. In ROOT this is a **`TTree`** entry.; The first thing to be decided is the network layout. This layout is; described in a string where the layers are separated by semicolons.; The input/output layers are defined by giving the expression for each; neuron, separated by comas. Hidden layers are just described by the; number of neurons. In addition, input and output layer formulas can be preceded by '@'; (e.g. ""@out"") if one wants to normalize the corresponding value. Also,; if the string ends with '`!`', output neurons are set up for; classification, i.e. with a sigmoid (1 neuron) or softmax (more; neurons) activation function. Many questions on the good usage of neural network, including rules of; dumb to determine the best network topology are addressed at; <ftp://ftp.sas.com/pub/neural/FAQ.html>. ``` {.cpp}; // a simple network: 2 inputs, 10 hidden and 1 normalized; // output neuron; TMultiLayerPerceptron network(""r,z:10:@Br"",tree);; ```. Expressions are evaluated as for `TTree::Draw()`. Input and outputs; are taken from the **`TTree`** associated with the network. This; **`TTree`** can be given as argument of the constructor or defined; later with `TMultiLayerPerceptron::SetData()`. Events can also be; w",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:74539,Modifiability,layers,layers,74539,"nimum along the line defined by the conjugate; gradient. Parameters are `Tau` and `Reset`, which defines the epochs; where the direction is reset to the steepest descent (estimated by; using the Fletcher-Reeves formula). #### The Broyden, Fletcher, Goldfarb, Shanno (BFGS) Method. It implies the computation of a `NxN` matrix, but seems more powerful; at least for less than 300 weights. Parameters are `Tau` and `Reset`,; which defines the epochs where the direction is reset to the steepest; descent. ### Using the Network. Neural network are build from a set of ""samples"". A sample is a set of; values defining the inputs and the corresponding output that the; network should ideally provide. In ROOT this is a **`TTree`** entry.; The first thing to be decided is the network layout. This layout is; described in a string where the layers are separated by semicolons.; The input/output layers are defined by giving the expression for each; neuron, separated by comas. Hidden layers are just described by the; number of neurons. In addition, input and output layer formulas can be preceded by '@'; (e.g. ""@out"") if one wants to normalize the corresponding value. Also,; if the string ends with '`!`', output neurons are set up for; classification, i.e. with a sigmoid (1 neuron) or softmax (more; neurons) activation function. Many questions on the good usage of neural network, including rules of; dumb to determine the best network topology are addressed at; <ftp://ftp.sas.com/pub/neural/FAQ.html>. ``` {.cpp}; // a simple network: 2 inputs, 10 hidden and 1 normalized; // output neuron; TMultiLayerPerceptron network(""r,z:10:@Br"",tree);; ```. Expressions are evaluated as for `TTree::Draw()`. Input and outputs; are taken from the **`TTree`** associated with the network. This; **`TTree`** can be given as argument of the constructor or defined; later with `TMultiLayerPerceptron::SetData()`. Events can also be; weighted. The weight expression can be given in the constructor or set; later wit",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:20278,Performance,perform,performing,20278,"od can be used; and the errors retrieved from the fit are corrected following a procedure described in paragraph 8.5.2 of the book,; *F. James, Statistical Methods in Experimental Physics, 2nd Edition*. ### Fit Statistics. You can change the statistics box to display the fit parameters with the; `TStyle::SetOptFit(mode)` method. This parameter has four digits:; `mode = pcev` (`default = 0111`). - `p` = 1 print probability; - `c` = 1 print Chi-square/number of degrees of freedom; - `e` = 1 print errors (if `e=1`, `v` must be 1); - `v` = 1 print name/values of parameters. For example, to print the fit probability, parameter names/values, and; errors, use:. ``` {.cpp}; gStyle->SetOptFit(1011);; ```. ## The Fit Panel. ![The Fit Panel](pictures/03000061.png). To display the Fit Panel right click on a histogram to pop up the; context menu, and then select the menu entry Fit Panel. The new Fit Panel GUI is available in ROOT v5.14. Its goal is to; replace the old Fit Panel and to provide more user friendly way for; performing, exploring and comparing fits. By design, this user interface is planned to contain two tabs:; ""General"" and ""Minimization"". Currently, the ""General"" tab provides; user interface elements for setting the fit function, fit method and; different fit, draw, print options.; The ""Minimization tab"" provides the option to set the Minimizer to use in the fit and; its specific options. The new fit panel is a modeless dialog, i.e. when opened, it does not; prevent users from interacting with other windows. Its first prototype; is a singleton application. When the Fit Panel is activated, users can; select an object for fitting in the usual way, i.e. by left-mouse; click on it. If the selected object is suitable for fitting, the fit; panel is connected with this object and users can perform fits by; setting different parameters and options. ### Function Choice and Settings. *‘Predefined' combo box* - contains a list of predefined functions in; ROOT. You have a choi",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:21071,Performance,perform,perform,21071,"ight click on a histogram to pop up the; context menu, and then select the menu entry Fit Panel. The new Fit Panel GUI is available in ROOT v5.14. Its goal is to; replace the old Fit Panel and to provide more user friendly way for; performing, exploring and comparing fits. By design, this user interface is planned to contain two tabs:; ""General"" and ""Minimization"". Currently, the ""General"" tab provides; user interface elements for setting the fit function, fit method and; different fit, draw, print options.; The ""Minimization tab"" provides the option to set the Minimizer to use in the fit and; its specific options. The new fit panel is a modeless dialog, i.e. when opened, it does not; prevent users from interacting with other windows. Its first prototype; is a singleton application. When the Fit Panel is activated, users can; select an object for fitting in the usual way, i.e. by left-mouse; click on it. If the selected object is suitable for fitting, the fit; panel is connected with this object and users can perform fits by; setting different parameters and options. ### Function Choice and Settings. *‘Predefined' combo box* - contains a list of predefined functions in; ROOT. You have a choice of several polynomials, a Gaussian, a Landau,; and an Exponential function. The default one is Gaussian. *‘Operation' radio button group* defines the selected operational mode; between functions:. *Nop* - no operation (default);. *Add* - addition;. *Conv* - convolution (will be implemented in the future). Users can enter the function expression into the text entry field; below the ‘Predefined' combo box. The entered string is checked after; the Enter key was pressed and an error message shows up, if the; function string is not accepted. ‘*Set Parameters*' button opens a dialog for parameters settings,; which will be explained later. ### Fitter Settings. *‘Method' combo box* currently provides only two fit model choices:; Chi-square and Binned Likelihood. The default one is Chi",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:24551,Performance,perform,performed,24551,"""`+`""- add function to the list; without deleting the previous one. When fitting a histogram, the; function is attached to the histogram's list of functions. By default,; the previously fitted function is deleted and replaced with the most; recent one, so the list only contains one function. Setting this; option to On will add the newly fitted function to the existing list; of functions for the histogram. Note that the fitted functions are; saved with the histogram when it is written to a ROOT file. By; default, the function is drawn on the pad displaying the histogram. ### Draw Options. *‘SAME'* sets On/Off function drawing on the same pad. When a fit is; executed, the image of the function is drawn on the current pad. *‘No drawing'* sets On/Off the option ""`0`""- do not draw the fit; results. *‘Do not store/draw'* sets On/Off option ""`N`""- do not store the; function and do not draw it. ### Advances Options. The advance option button is enabled only after having performed the fit and provides; additional drawing options that can be used after having done the fit. These new drawing tools,; which can be selected by the ""Advanced Drawing Tool"" panel that pops up when clicking the ""Advanced"" button, are:. * *Contour*: to plot the confidence contour of two chosen parameters. One can select the number of points to draw the contour; (more points might require more time to compute it), the parameters and the desired confidence level . * *Scan* : to plot a scan of the minimization function (likelihood or chi-squared) around the minimum as function of the chosen parameter. * *Conf Interval* : to plot the confidence interval of the fitted function as a filled coloured band around its central value.; One can select the desired confidence level for the band to be plotted. ### Print Options. This set of options specifies the amount of feedback printed on the; root command line after performed fits. *‘Verbose'* - prints fit results after each iteration. *‘Quiet'* - no fit informat",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:25476,Performance,perform,performed,25476,"ore the; function and do not draw it. ### Advances Options. The advance option button is enabled only after having performed the fit and provides; additional drawing options that can be used after having done the fit. These new drawing tools,; which can be selected by the ""Advanced Drawing Tool"" panel that pops up when clicking the ""Advanced"" button, are:. * *Contour*: to plot the confidence contour of two chosen parameters. One can select the number of points to draw the contour; (more points might require more time to compute it), the parameters and the desired confidence level . * *Scan* : to plot a scan of the minimization function (likelihood or chi-squared) around the minimum as function of the chosen parameter. * *Conf Interval* : to plot the confidence interval of the fitted function as a filled coloured band around its central value.; One can select the desired confidence level for the band to be plotted. ### Print Options. This set of options specifies the amount of feedback printed on the; root command line after performed fits. *‘Verbose'* - prints fit results after each iteration. *‘Quiet'* - no fit information is printed. *‘Default'* - between Verbose and Quiet. ### Command Buttons. *Fit button* - performs a fit taking different option settings via the; Fit Panel interface. *Reset* - sets the GUI elements and related fit settings to the; default ones. *Close* - closes the Fit panel window. ### Minimization Options. With this tab one can select specific options for minimization. These include. * The minimizer library ( *Minuit*, *Minuit2*, *Fumili*, *GSL*, *Genetics* ); * The method (algorithm) for minimization. For example for Minuit one can choose between (*Migrad*, *Simplex* or *Scan*); * Error definition; * Minimization tolerance; * Number of iterations/function calls; * Print Level: (*Default*, *Verbose* or *Quiet*). ## New ROOT::Fit classes. The fitting of the data objects in ROOT, histograms, graphs and tree is performed via some common classes,; ",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:25667,Performance,perform,performs,25667,"cted by the ""Advanced Drawing Tool"" panel that pops up when clicking the ""Advanced"" button, are:. * *Contour*: to plot the confidence contour of two chosen parameters. One can select the number of points to draw the contour; (more points might require more time to compute it), the parameters and the desired confidence level . * *Scan* : to plot a scan of the minimization function (likelihood or chi-squared) around the minimum as function of the chosen parameter. * *Conf Interval* : to plot the confidence interval of the fitted function as a filled coloured band around its central value.; One can select the desired confidence level for the band to be plotted. ### Print Options. This set of options specifies the amount of feedback printed on the; root command line after performed fits. *‘Verbose'* - prints fit results after each iteration. *‘Quiet'* - no fit information is printed. *‘Default'* - between Verbose and Quiet. ### Command Buttons. *Fit button* - performs a fit taking different option settings via the; Fit Panel interface. *Reset* - sets the GUI elements and related fit settings to the; default ones. *Close* - closes the Fit panel window. ### Minimization Options. With this tab one can select specific options for minimization. These include. * The minimizer library ( *Minuit*, *Minuit2*, *Fumili*, *GSL*, *Genetics* ); * The method (algorithm) for minimization. For example for Minuit one can choose between (*Migrad*, *Simplex* or *Scan*); * Error definition; * Minimization tolerance; * Number of iterations/function calls; * Print Level: (*Default*, *Verbose* or *Quiet*). ## New ROOT::Fit classes. The fitting of the data objects in ROOT, histograms, graphs and tree is performed via some common classes,; which are defined in the `ROOT::Fit` namespace.; These classes can be classified in the following groups:. * User classes driving the fit: `ROOT::Fit::Fitter` for executing the fit, `ROOT::Fit::FitConfig` for configuring the fit,; 	`ROOT::Fit::ParameterSettings",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:26401,Performance,perform,performed,26401,"cifies the amount of feedback printed on the; root command line after performed fits. *‘Verbose'* - prints fit results after each iteration. *‘Quiet'* - no fit information is printed. *‘Default'* - between Verbose and Quiet. ### Command Buttons. *Fit button* - performs a fit taking different option settings via the; Fit Panel interface. *Reset* - sets the GUI elements and related fit settings to the; default ones. *Close* - closes the Fit panel window. ### Minimization Options. With this tab one can select specific options for minimization. These include. * The minimizer library ( *Minuit*, *Minuit2*, *Fumili*, *GSL*, *Genetics* ); * The method (algorithm) for minimization. For example for Minuit one can choose between (*Migrad*, *Simplex* or *Scan*); * Error definition; * Minimization tolerance; * Number of iterations/function calls; * Print Level: (*Default*, *Verbose* or *Quiet*). ## New ROOT::Fit classes. The fitting of the data objects in ROOT, histograms, graphs and tree is performed via some common classes,; which are defined in the `ROOT::Fit` namespace.; These classes can be classified in the following groups:. * User classes driving the fit: `ROOT::Fit::Fitter` for executing the fit, `ROOT::Fit::FitConfig` for configuring the fit,; 	`ROOT::Fit::ParameterSettings` to define the properties of the fit parameters (initial; 	values, bounds, etc..), `ROOT::Fit::FitResult` for storing the result of the fit.; * Data classes containing the data sets used in the fitting. These classes are the`ROOT::Fit::BinData`for describing bin data sets,; 	 thus data points containing both coordinates and a corresponding value/weight; 	 with optionally an error on the value or the coordinate and the `ROOT::Fit::UnBinData` for un-binned data sets,; 	 which consists only of a vector of coordinate values. The coordinate values can be; 	 one-dimensional (i.e. one entry per event) or multi-dimensional (N entries per event).; * Function classes defining the type of fit (the objective f",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:28134,Performance,perform,perform,28134,"ue/weight; 	 with optionally an error on the value or the coordinate and the `ROOT::Fit::UnBinData` for un-binned data sets,; 	 which consists only of a vector of coordinate values. The coordinate values can be; 	 one-dimensional (i.e. one entry per event) or multi-dimensional (N entries per event).; * Function classes defining the type of fit (the objective function used for fitting):; 	- `ROOT::Fit::Chi2FCN` for chi2 (least-square fits),; 	- `ROOT::Fit::PoissonLikelihoodFCN` for binned likelihood fits of histograms,; 	- `ROOT::Fit::LogLikelihoodFCN` for generic un-binned likelihood fits.; 	These classes are templated on the type of function interface they implement (see later). User convenient typedefs are also provided.; 	They derive from the common generic interface multi-dimensional for function evaluation, `ROOT::Math::IBaseFunctionMultiDim`. In addition the fitter classes make uses of the generic interfaces for parametric function evaluations, `ROOT::Math::IParametricFunctionMultiDim`; to define the fit model function and use the `ROOT::Math::Minimizer` interface to perform the minimization of the objective function.; More information about the function interface and the multi-dimensional minimization in ROOT is given in the Mathematical Library chapter. Here we present a detailed description of the `ROOT::Fit` classes and how to use them.; Using these classes instead of the interface provided directly in the ROOT data objects, like `TH1::Fit` allow are more fine control; to configure and customise the fits. For example, using these classes a combined fit of several histograms can be performed. To understand how these class work, let's go through a simple example, such as fitting an histogram. When fitting an histogram, instead of using `TH1::Fit` we will show in the following hot wo use the `ROOT::Fit` classes.; We will show how to perform the following different type of fits with the histogram data:; * a least square fit using the observed errors (Neyman chi",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:28662,Performance,perform,performed,28662,"lihood fits.; 	These classes are templated on the type of function interface they implement (see later). User convenient typedefs are also provided.; 	They derive from the common generic interface multi-dimensional for function evaluation, `ROOT::Math::IBaseFunctionMultiDim`. In addition the fitter classes make uses of the generic interfaces for parametric function evaluations, `ROOT::Math::IParametricFunctionMultiDim`; to define the fit model function and use the `ROOT::Math::Minimizer` interface to perform the minimization of the objective function.; More information about the function interface and the multi-dimensional minimization in ROOT is given in the Mathematical Library chapter. Here we present a detailed description of the `ROOT::Fit` classes and how to use them.; Using these classes instead of the interface provided directly in the ROOT data objects, like `TH1::Fit` allow are more fine control; to configure and customise the fits. For example, using these classes a combined fit of several histograms can be performed. To understand how these class work, let's go through a simple example, such as fitting an histogram. When fitting an histogram, instead of using `TH1::Fit` we will show in the following hot wo use the `ROOT::Fit` classes.; We will show how to perform the following different type of fits with the histogram data:; * a least square fit using the observed errors (Neyman chi-squared);; * a least square fit using the expected errors from the function (Pearson chi-squared);; * a binned likelihood fit;; * an extended unbinned likelihood fits, if the histogram has been set to store in the buffer the original data used to fill it. Let's go through all the steps required for performing these fits using the `ROOT::Fit::Fitter` class.; These steps are:; 1. Create the input fit data object.; 2. Create the input model function.; 3. Configure the fit.; 4. Perform the data fitting.; 5. Examine the result. ### Creating the input fit data. We have two types of",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:28916,Performance,perform,perform,28916,"`ROOT::Math::Minimizer` interface to perform the minimization of the objective function.; More information about the function interface and the multi-dimensional minimization in ROOT is given in the Mathematical Library chapter. Here we present a detailed description of the `ROOT::Fit` classes and how to use them.; Using these classes instead of the interface provided directly in the ROOT data objects, like `TH1::Fit` allow are more fine control; to configure and customise the fits. For example, using these classes a combined fit of several histograms can be performed. To understand how these class work, let's go through a simple example, such as fitting an histogram. When fitting an histogram, instead of using `TH1::Fit` we will show in the following hot wo use the `ROOT::Fit` classes.; We will show how to perform the following different type of fits with the histogram data:; * a least square fit using the observed errors (Neyman chi-squared);; * a least square fit using the expected errors from the function (Pearson chi-squared);; * a binned likelihood fit;; * an extended unbinned likelihood fits, if the histogram has been set to store in the buffer the original data used to fill it. Let's go through all the steps required for performing these fits using the `ROOT::Fit::Fitter` class.; These steps are:; 1. Create the input fit data object.; 2. Create the input model function.; 3. Configure the fit.; 4. Perform the data fitting.; 5. Examine the result. ### Creating the input fit data. We have two types of input data, binned data (class `ROOT::Fit::BinData`) used for least square (chi-square) fits of histograms or `TGraph` objects; or un-binned data (class `ROOT::Fit::UnBinData`) used for; fitting vectors of data points (e.g. from a `TTree`). #### Using Binned data. Let's suppose we have an histogram, represented as a **`TH1`** type object (it can be one or multi-dimensional). The following shows how to create and; fill a `ROOT:Fit::BinData` object. ``` {.cpp}; ROOT:",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:29346,Performance,perform,performing,29346," description of the `ROOT::Fit` classes and how to use them.; Using these classes instead of the interface provided directly in the ROOT data objects, like `TH1::Fit` allow are more fine control; to configure and customise the fits. For example, using these classes a combined fit of several histograms can be performed. To understand how these class work, let's go through a simple example, such as fitting an histogram. When fitting an histogram, instead of using `TH1::Fit` we will show in the following hot wo use the `ROOT::Fit` classes.; We will show how to perform the following different type of fits with the histogram data:; * a least square fit using the observed errors (Neyman chi-squared);; * a least square fit using the expected errors from the function (Pearson chi-squared);; * a binned likelihood fit;; * an extended unbinned likelihood fits, if the histogram has been set to store in the buffer the original data used to fill it. Let's go through all the steps required for performing these fits using the `ROOT::Fit::Fitter` class.; These steps are:; 1. Create the input fit data object.; 2. Create the input model function.; 3. Configure the fit.; 4. Perform the data fitting.; 5. Examine the result. ### Creating the input fit data. We have two types of input data, binned data (class `ROOT::Fit::BinData`) used for least square (chi-square) fits of histograms or `TGraph` objects; or un-binned data (class `ROOT::Fit::UnBinData`) used for; fitting vectors of data points (e.g. from a `TTree`). #### Using Binned data. Let's suppose we have an histogram, represented as a **`TH1`** type object (it can be one or multi-dimensional). The following shows how to create and; fill a `ROOT:Fit::BinData` object. ``` {.cpp}; ROOT::Fit::DataOptions opt;; opt.fIntegral = true;; ROOT::Fit::BinData data(opt);; // fill the bin data using the histogram; // we can do this using the following helper function from the Hist library; TH1 * h1 = (TH1*) gDirectory->Get(""myHistogram"");; ROOT::F",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:39816,Performance,load,loaded,39816,"sing fitted chi2 values). The initial parameter values can be set directly in the input model function object.; However, for setting parameter bounds and step sizes to values different than the automatically computed ones, one needs to use the `ROOT::Fit::ParameterSetting` class.; This example code will set the lower/upper bounds for the first parameter and a lower bound for the second parameter. ``` {.cpp}; fitter.SetFunction( fitFunction, false);; fitter.Config().ParSettings(0).SetLimits(0,1.E6);; fitter.Config().ParSettings(2).SetLowerLimit(0);; ```. Note that a `ROOT::Fit::ParameterSettings` objects exists for each fit parameter and it created by the `ROOT::Fit::FitConfig` class, after the model function has been set in the Fitter.; Only when the function is set, the number of parameter is known and; automatically the `FitConfig` creates the corresponding `ParameterSetting` objects. When fitting, different minimizer can be used. The can be implemented in different libraries and loaded ar run time by the plug-in manager system of ROOT.; Each different minimizer (e.g. *Minuit, Minuit2, Fumili,* etc.) consists of a different implementation of the `ROOT::Math::Minimizer` interface.; Within the same minimizer, thus within the same class implementing the `Minimizer` interface, different algorithms can exist.; For example in the case of Minuit, we have *Migrad, Simplex* or *Minimize*. The minimizer and its corresponding algorithm, when available,; can be set by using the function `FitConfig::SetMinimizer(""minimizerName"")` or by using directly the `ROOT:Math::MinimizerOptions` class. If the requested minimizer is not available in ROOT, the default one is used. The default minimizer type and algorithm can be specified by using the; static function `ROOT::Math::MinimizerOptions::SetDefaultMinimizer(""minimizerName"")`. ### Minimizer Libraries and Algorithms. The list of available minimizer libraries currently available in ROOT, with their corresponding available algorithms ",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:45469,Performance,perform,perform,45469,"Minuit2*). The class supports also setting global default values for the options, by using the static functions `MinimizerOptions::SetDefault...` (for example `MinimizerOptions::SetDefaultPrintLevel(int )`). The; static functions can be also used to set the minimizer options when using `TH1::Fit` or `TGraph::Fit`.; The list of the current option values can be inspected by using `MinimizerOptions::Print`.; ```{.cpp}; ROOT::Math::MinimizerOptions() opt;; // print the default minimizer option values; opt.Print();; ```. In addition it is possible to provide extra options which might apply for a particular minimizer `MinimizerOptions::SetExtraOptions(const IOptions & )`.; See the documentation of the particular minimizer to use for the list of possible additional options available. ### Performing the Fit. Here we have now all the required input ingredients for the fit, the data and the function to fit.; Depending on these we have now several different way to perform the fit, using the corresponding methods of the; `ROOT::Fit::Fitter` class and depending on the type of input data. #### Available fit methods. * **Least-square fit**: `Fitter::LeastSquare(const BinData & )` or `Fitter::Fit(const Bindata &)`. It requires the user to pass a `BinData` object. It should be used when the data values follow a; Gaussian distribution. This fit method is implemented using the class `ROOT::Fit::Chi2FCN`.; * **Binned Likelihood fit** : `Fitter::LikelihoodFit(const Bindata & )`. The user needs to pass a `BinData` object. It should be used when the data values follow a Poisson or a multinomial; distribution. The Poisson case (extended fit) is the default and in this case the function normalization is also fit to the data. The Multi-nominal case can be selected by passing the optional; *extended* boolean flag as *false*. This method is implemented by the class `ROOT::Fit:::PoissonLikelihoodFCN`.; * **Un-Binned likelihood fit**: `Fitter::LikelihoodFit(const UnBindata &)`. The user needs to ",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:57377,Performance,perform,perform,57377,"o one of; the limits (expressed as the distance to nearest limit divided by; distance between limits). The user must therefore be aware of the fact; that, for example, if they put limits of (0, 1010) on a parameter, then; the values 0.0 and 1. 0 will be indistinguishable to the accuracy of; most machines. The transformation also affects the parameter error matrix, of course,; so Minuit does a transformation of the error matrix (and the; ''parabolic'' parameter errors) when there are parameter limits. Users; should however realize that the transformation is only a linear; approximation, and that it cannot give a meaningful result if one or; more parameters is very close to a limit, where; $\frac{\partial Pext}{\partial Pint} \neq 0$. Therefore, it is; recommended that:. - Limits on variable parameters should be used only when needed in; order to prevent the parameter from taking on unphysical values. - When a satisfactory minimum has been found using limits, the; limits should then be removed if possible, in order to perform or; re-perform the error analysis without limits. ### How to Get the Right Answer from Minuit. `Minuit` offers the user a choice of several minimization algorithms.; The `MIGRAD` algorithm is in general the best minimized for nearly all; functions. It is a variable-metric method with inexact line search, a; stable metric updating scheme, and checks for positive-definiteness.; Its main weakness is that it depends heavily on knowledge of the first; derivatives, and fails miserably if they are very inaccurate. If parameter limits are needed, in spite of the side effects, then the; user should be aware of the following techniques to alleviate problems; caused by limits:. #### Getting the Right Minimum with Limits. If MIGRAD converges normally to a point where no parameter is near one; of its limits, then the existence of limits has probably not prevented; `Minuit` from finding the right minimum. On the other hand, if one or; more parameters is near it",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:57392,Performance,perform,perform,57392,"o one of; the limits (expressed as the distance to nearest limit divided by; distance between limits). The user must therefore be aware of the fact; that, for example, if they put limits of (0, 1010) on a parameter, then; the values 0.0 and 1. 0 will be indistinguishable to the accuracy of; most machines. The transformation also affects the parameter error matrix, of course,; so Minuit does a transformation of the error matrix (and the; ''parabolic'' parameter errors) when there are parameter limits. Users; should however realize that the transformation is only a linear; approximation, and that it cannot give a meaningful result if one or; more parameters is very close to a limit, where; $\frac{\partial Pext}{\partial Pint} \neq 0$. Therefore, it is; recommended that:. - Limits on variable parameters should be used only when needed in; order to prevent the parameter from taking on unphysical values. - When a satisfactory minimum has been found using limits, the; limits should then be removed if possible, in order to perform or; re-perform the error analysis without limits. ### How to Get the Right Answer from Minuit. `Minuit` offers the user a choice of several minimization algorithms.; The `MIGRAD` algorithm is in general the best minimized for nearly all; functions. It is a variable-metric method with inexact line search, a; stable metric updating scheme, and checks for positive-definiteness.; Its main weakness is that it depends heavily on knowledge of the first; derivatives, and fails miserably if they are very inaccurate. If parameter limits are needed, in spite of the side effects, then the; user should be aware of the following techniques to alleviate problems; caused by limits:. #### Getting the Right Minimum with Limits. If MIGRAD converges normally to a point where no parameter is near one; of its limits, then the existence of limits has probably not prevented; `Minuit` from finding the right minimum. On the other hand, if one or; more parameters is near it",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:65032,Performance,perform,performances,65032,"e, whether the; non-positive-definiteness is real or only numerical is largely; irrelevant, since in both cases the error matrix will be unreliable; and the minimum suspicious. #### An Ill-posed Problem. For questions of parameter dependence, see the discussion above on; positive-definiteness. Possible other mathematical problems are the; following:. - Excessive numerical round off - be especially careful of; exponential and factorial functions which get big very quickly and; lose accuracy. - Starting too far from the solution - the function may have; unphysical local minima, especially at infinity in some variables. ## Minuit2 Package. `Minuit2` is a new object-oriented implementation, written in C++, of; the popular `MINUIT` minimization package. Compared with the; **`TMinuit`** class, which is a direct conversion from FORTRAN to C++,; `Minuit2` is a complete redesign and re-implementation of the package.; This new version provides all the functionality present in the old; FORTRAN version, with almost equivalent numerical accuracy and; computational performances.; Furthermore, it contains some fixes and small improvements and this new functionality:; * The possibility to set single side parameter limits; * the FUMILI algorithm (see the next paragraph ""FUMILI Minimization Package""),; which is an optimized method for least square and log; likelihood minimizations. Minuit2 has been originally developed by M.; Winkler and F. James in the SEAL project. More information can be found; on the [MINUIT Web Site](MINUIT Web Site) and in particular at the; following documentation page at; <http://www.cern.ch/minuit/doc/doc.html>. A detailed User Guide for Minuit2 exists, describing the API of the internal classes.; ROOT uses `Minuit2` for fitting via the `Minuit2Minimizer` class which implements; the `ROOT::Math::Minimizer` interface. `Minuit2` is also distributed as an independent package of ROOT and can be built; without any other dependency on the ROOT libraries. Examples o",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:65282,Performance,optimiz,optimized,65282,"pendence, see the discussion above on; positive-definiteness. Possible other mathematical problems are the; following:. - Excessive numerical round off - be especially careful of; exponential and factorial functions which get big very quickly and; lose accuracy. - Starting too far from the solution - the function may have; unphysical local minima, especially at infinity in some variables. ## Minuit2 Package. `Minuit2` is a new object-oriented implementation, written in C++, of; the popular `MINUIT` minimization package. Compared with the; **`TMinuit`** class, which is a direct conversion from FORTRAN to C++,; `Minuit2` is a complete redesign and re-implementation of the package.; This new version provides all the functionality present in the old; FORTRAN version, with almost equivalent numerical accuracy and; computational performances.; Furthermore, it contains some fixes and small improvements and this new functionality:; * The possibility to set single side parameter limits; * the FUMILI algorithm (see the next paragraph ""FUMILI Minimization Package""),; which is an optimized method for least square and log; likelihood minimizations. Minuit2 has been originally developed by M.; Winkler and F. James in the SEAL project. More information can be found; on the [MINUIT Web Site](MINUIT Web Site) and in particular at the; following documentation page at; <http://www.cern.ch/minuit/doc/doc.html>. A detailed User Guide for Minuit2 exists, describing the API of the internal classes.; ROOT uses `Minuit2` for fitting via the `Minuit2Minimizer` class which implements; the `ROOT::Math::Minimizer` interface. `Minuit2` is also distributed as an independent package of ROOT and can be built; without any other dependency on the ROOT libraries. Examples on how to use the `Minuit2` and `Fumili2` plug-ins are provided; in the tutorials' directory `$ROOTSYS/tutorials/fit`:; `minuit2FitBench.C`, `minuit2FitBench2D.C` and `minuit2GausFit.C`.; More information on the classes and functions ",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:70114,Performance,optimiz,optimization,70114,"; $$. Remarkable feature of algorithm is the technique for step restriction.; For an initial value of parameter ${\vec\theta}^0$ a parallelepiped; $P_0$ is built with the center at ${\vec\theta}^0$ and axes parallel; to coordinate axes $\theta_i$. The lengths of parallelepiped sides; along i-th axis is $2b_i$, where $b_i$ is such a value that the; functions $f_j(\vec\theta)$ are quasi-linear all over the; parallelepiped. FUMILI takes into account simple linear inequalities in the form:. $$ \theta_i^{min}\le\theta_i\le\theta^{max}_i$$. They form parallelepiped $P$ ($P_0$ may be deformed by $P$). Very; similar step formulae are used in FUMILI for negative logarithm of; the likelihood function with the same idea - linearization of function; argument. ## Neural Networks. ### Introduction. Neural Networks are used in various fields for data analysis and; classification, both for research and commercial institutions. Some; randomly chosen examples are image analysis, financial movements'; predictions and analysis, or sales forecast and product shipping; optimization. In particles physics neural networks are mainly used for; classification tasks (signal over background discrimination). A vast; majority of commonly used neural networks are multilayer perceptrons.; This implementation of multilayer perceptrons is inspired from the; `MLPfit` package, which remains one of the fastest tools for neural; networks studies. ### The MLP. The multilayer perceptron is a simple feed-forward network with the; following structure showed on the left. ![](pictures/0300008D.png). It is made of neurons characterized by a bias and weighted links in; between - let's call those links synapses. The input neurons receive; the inputs, normalize them and forward them to the first hidden layer.; Each neuron in any subsequent layer first computes a linear; combination of the outputs of the previous layer. The output of the; neuron is then function of that combination with f being linear for; output ne",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:55920,Safety,avoid,avoided,55920,"TGraph*)gMinuit->GetPlot();; gr->SetMarkerStyle(21);; gr->Draw(""alp"");; ```. - To set `Minuit` in no graphics mode, call. ``` {.cpp}; gMinuit->SetGraphicsMode(kFALSE);; ```. ### Basic Concepts of Minuit. The `Minuit` package acts on a multi parameter FORTRAN function to; which one must give the generic name `FCN`. In the ROOT; implementation, the function `FCN` is defined via the `Minuit`; `SetFCN` member function when an histogram fitting is invoked. The; value of `FCN` will in general depend on one or more variable; parameters. ### The Transformation of Limited Parameters. For variable parameters with limits, `Minuit` uses the following; transformation:. `Pint = arcsin(2((Pext-a)/(b-a))-1) `. `Pext = a+((b-a)/(2))(sinPint+1)`. so that the internal value `Pint` can take on any value, while the; external value Pext can take on values only between the lower limit a; and the ext upper limit b. Since the transformation is necessarily; non-linear, it would transform a nice linear problem into a nasty; non-linear one, which is the reason why limits should be avoided if; not necessary. In addition, the transformation does require some; computer time, so it slows down the computation a little bit, and more; importantly, it introduces additional numerical inaccuracy into the; problem in addition to what is introduced in the numerical calculation; of the FCN value. The effects of non-linearity and numerical round off; both become more important as the external value gets closer to one of; the limits (expressed as the distance to nearest limit divided by; distance between limits). The user must therefore be aware of the fact; that, for example, if they put limits of (0, 1010) on a parameter, then; the values 0.0 and 1. 0 will be indistinguishable to the accuracy of; most machines. The transformation also affects the parameter error matrix, of course,; so Minuit does a transformation of the error matrix (and the; ''parabolic'' parameter errors) when there are parameter limits.",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:62937,Safety,recover,recovers,62937,"n badly parameterized so that individual errors are; not very meaningful because they are so highly correlated. - Parameter at limit. This condition, signaled by a `Minuit` warning; message, may make both the function minimum and parameter errors; unreliable. See the discussion above ‘Getting the right parameter; errors with limits'. The best way to be absolutely sure of the errors is to use; ''independent'' calculations and compare them, or compare the; calculated errors with a picture of the function. Theoretically, the; covariance matrix for a ''physical'' function must be; positive-definite at the minimum, although it may not be so for all; points far away from the minimum, even for a well-determined physical; problem. Therefore, if `MIGRAD` reports that it has found a; non-positive-definite covariance matrix, this may be a sign of one or; more of the following:. #### A Non-physical Region. On its way to the minimum, `MIGRAD` may have traversed a region that; has unphysical behavior, which is of course not a serious problem as; long as it recovers and leaves such a region. #### An Underdetermined Problem. If the matrix is not positive-definite even at the minimum, this may; mean that the solution is not well defined, for example that there are; more unknowns than there are data points, or that the parameterization; of the fit contains a linear dependence. If this is the case, then; `Minuit` (or any other program) cannot solve your problem uniquely.; The error matrix will necessarily be largely meaningless, so the user; must remove the under determinedness by reformulating the; parameterization. `Minuit` cannot do this itself. #### Numerical Inaccuracies. It is possible that the apparent lack of positive-definiteness is due; to excessive round off errors in numerical calculations (in the user; function), or not enough precision. This is unlikely in general, but; becomes more likely if the number of free parameters is very large, or; if the parameters are badly sc",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:70048,Safety,predict,predictions,70048,"; $$. Remarkable feature of algorithm is the technique for step restriction.; For an initial value of parameter ${\vec\theta}^0$ a parallelepiped; $P_0$ is built with the center at ${\vec\theta}^0$ and axes parallel; to coordinate axes $\theta_i$. The lengths of parallelepiped sides; along i-th axis is $2b_i$, where $b_i$ is such a value that the; functions $f_j(\vec\theta)$ are quasi-linear all over the; parallelepiped. FUMILI takes into account simple linear inequalities in the form:. $$ \theta_i^{min}\le\theta_i\le\theta^{max}_i$$. They form parallelepiped $P$ ($P_0$ may be deformed by $P$). Very; similar step formulae are used in FUMILI for negative logarithm of; the likelihood function with the same idea - linearization of function; argument. ## Neural Networks. ### Introduction. Neural Networks are used in various fields for data analysis and; classification, both for research and commercial institutions. Some; randomly chosen examples are image analysis, financial movements'; predictions and analysis, or sales forecast and product shipping; optimization. In particles physics neural networks are mainly used for; classification tasks (signal over background discrimination). A vast; majority of commonly used neural networks are multilayer perceptrons.; This implementation of multilayer perceptrons is inspired from the; `MLPfit` package, which remains one of the fastest tools for neural; networks studies. ### The MLP. The multilayer perceptron is a simple feed-forward network with the; following structure showed on the left. ![](pictures/0300008D.png). It is made of neurons characterized by a bias and weighted links in; between - let's call those links synapses. The input neurons receive; the inputs, normalize them and forward them to the first hidden layer.; Each neuron in any subsequent layer first computes a linear; combination of the outputs of the previous layer. The output of the; neuron is then function of that combination with f being linear for; output ne",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:75779,Safety,avoid,avoid,75779,"sponding value. Also,; if the string ends with '`!`', output neurons are set up for; classification, i.e. with a sigmoid (1 neuron) or softmax (more; neurons) activation function. Many questions on the good usage of neural network, including rules of; dumb to determine the best network topology are addressed at; <ftp://ftp.sas.com/pub/neural/FAQ.html>. ``` {.cpp}; // a simple network: 2 inputs, 10 hidden and 1 normalized; // output neuron; TMultiLayerPerceptron network(""r,z:10:@Br"",tree);; ```. Expressions are evaluated as for `TTree::Draw()`. Input and outputs; are taken from the **`TTree`** associated with the network. This; **`TTree`** can be given as argument of the constructor or defined; later with `TMultiLayerPerceptron::SetData()`. Events can also be; weighted. The weight expression can be given in the constructor or set; later with the method `SetWeight()` of the class; **`TMultiLayerPerceptron`**. Two datasets must be defined before; learning the network: a training dataset that is used when minimizing; the error, and a test dataset that will avoid bias. Those two datasets; can be built aside and then given to the network, or can be built from; a standard expression. By default, half of the events are put in both; datasets. ``` {.cpp}; // a more complex 4:8:1 network; // the ptsumf branch is used as weigh;; // default event lists are explicit; TMultiLayerPerceptron network(""m,pt,acol,acopl:8:type"",""pt"",tree,; ""Entry$%2"",""Entry$/2"");; ```. The method `TMultiLayerPerceptron::SetLearningMethod()` defines the; learning method. Learning methods are:. ```; TMultiLayerPerceptron::kStochastic,; TMultiLayerPerceptron::kBatch,; TMultiLayerPerceptron::kSteepestDescent,; TMultiLayerPerceptron::kRibierePolak,; TMultiLayerPerceptron::kFletcherReeves,; TMultiLayerPerceptron::kBFGS // default; ```. The training can start with; `TMultiLayerPerceptron::Train(Int_t nepoch,Option_t* options).` The; first argument is the number of epochs while option is a string that; can cont",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:81350,Safety,recover,recovered,81350,">GetEntry(i);; params[0] = msumf; params[1] = ptsumf;; params[2] = acolin; params[3] = acopl;; bg->Fill(mlp->Evaluate(0,params));; }; for (i = 0; i < signal->GetEntries(); i++) {; signal->GetEntry(i);; params[0] = msumf;; params[1] = ptsumf;; params[2] = acolin;; params[3] = acopl;; sig->Fill(mlp->Evaluate(0,params));; }; TCanvas *cv = new TCanvas(""NNout_cv"",""Neural net output"");; bg->SetFillStyle(3008);; bg->SetFillColor(kBlue);; sig->SetFillStyle(3003);; sig->SetFillColor(kRed);; bg->SetStats(0);; sig->SetStats(0);; bg->Draw();; sig->Draw(""same"");; TLegend *legend = new TLegend(.75,.80,.95,.95);; legend->AddEntry(bg,""Background(WW)"");; legend->AddEntry(sig,""Signal(Higgs)"");; legend->Draw();; ```. The neural net output is then used to display the final difference; between background and signal events. The figure ""The neural net; output"" shows this plot. ![The neural net output](pictures/image144.png). As it can be seen, this is a quite efficient technique. As mentioned; earlier, neural networks are also used for fitting function. For some; application with a cylindrical symmetry, a magnetic field simulation; gives as output the angular component of the potential vector `A`, as; well as the radial and `z` components of the `B` field. One wants to fit those distributions with a function in order to plug; them into the `Geant` simulation code. Polynomial fits could be tried,; but it seems difficult to reach the desired precision over the full; range. One could also use a `spline` interpolation between known; points. In all cases, the resulting field would not be `C`-infinite. An example of output (for Br) is shown. First the initial function can; be seen as the target. Then, the resulting (normalized) neural net; output. In order to ease the learning, the ""normalize output"" was used; here. The initial amplitude can be recovered by multiplying by the; original RMS and then shifting by the original mean. ![The original and the neural net for Br](pictures/image145.jpg); ",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:18293,Security,access,access,18293,"tion matrix). ### Associated Function. One or more objects (typically a **`TF1\*`**) can be added to the list; of functions (`fFunctions`) associated to each histogram. A call to; `TH1::Fit` adds the fitted function to this list. Given a histogram; `h`, one can retrieve the associated function with:. ``` {.cpp}; TF1 *myfunc = h->GetFunction(""myfunc"");; ```. ### Access to the Fit Parameters and Results. If the histogram (or graph) is made persistent, the list of associated; functions is also persistent. Retrieve a pointer to the function with; the `TH1::GetFunction()` method. Then you can retrieve the fit; parameters from the function (**`TF1`**) with calls such as:. ``` {.cpp}; root[] TF1 *fit = hist->GetFunction(function_name);; root[] Double_t chi2 = fit->GetChisquare();; // value of the first parameter; root[] Double_t p1 = fit->GetParameter(0);; // error of the first parameter; root[] Double_t e1 = fit->GetParError(0);; ```. Using the fit option `S` one can access the full result of the fit including the covariance and correlation matrix.; See later the paragraph `TFitResult`. ### Associated Errors. By default, for each bin, the sum of weights is computed at fill time.; One can also call `TH1::Sumw2` to force the storage and computation of; the sum of the square of weights per bin. If Sumw2 has been called,; the error per bin is computed as the `sqrt(sum of squares of; weights)`; otherwise, the error is set equal to the; `sqrt(bin content)`. To return the error for a given bin number, do:. ``` {.cpp}; Double_t error = h->GetBinError(bin);; ```. Empty bins are excluded in the fit when using the Chi-square fit method.; When fitting an histogram representing counts (i.e with Poisson statistics) it is recommended to; use the Log-Likelihood method (option ‘`L`' or ""`WL`""), particularly in case of low statistics.; When the histogram has been filled with weights different than one, a weighted likelihood method can be used; and the errors retrieved from the fit are corr",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:51573,Security,access,access,51573," addition `TFitResult` derives from `TNamed` and can be conveniently; stored in a file. When fitting an histogram ( a **`TH1`** object) or a graph (a `TGraph` object) it is possible to return a `TFitResult` via the `TFitResultPtr` object,; which behaves as a smart pointer to a `TFitResult`.; `TFitResultPtr` is the return object by `TH1::Fit` or `TGraph::Fit`.; By default the TFitResultPtr contains only the status of the fit and can be obtained by an automatic conversion of the TFitResultPtr to an integer. If the fit option *`S`* is instead used, `TFitResultPtr` contains the `TFitResult` and behaves as a smart; pointer to it. This is an example:. ``` {.cpp}; int fitStatus = hist->Fit(myFunction); // TFitResultPtr contains only the fit status. TFitResultPtr r = hist->Fit(myFunction,""S""); // TFitResultPtr contains the TFitResult; TMatrixDSym cov = r->GetCovarianceMatrix(); // to access the covariance matrix; Double_t chi2 = r->Chi2(); // to retrieve the fit chi2; Double_t par0 = r->Parameter(0); // retrieve the value for the parameter 0; Double_t err0 = r->ParError(0); // retrieve the error for the parameter 0; r->Print(""V""); // print full information of fit including covariance matrix; r->Write(); // store the result in a file; ```. ## The Minimization packages. As explained before various minimization packages can be used when fitting in ROOT.; We have seen before how to configure the `Fitter` class to use different minimization packages; and different minimization options.; When using the `Fit` method the minimization package (and its options) can be selected using the; static methods of the `ROOT::Math::MinimizerOptions` class.; For example to select `Minuit2` instead of `Minuit` for fitting an histogram do:. ``` {.cpp}; ROOT::Math::MinimizerOptions::SetDefaultMinimizer(""Minuit2"");; // fit the histogram histo with the gaussian pre-defined function; histo->Fit(""gaus"");; ```. In the following we will give some brief description of the minimization packages.; The packa",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:1489,Testability,log,log,1489,"h classes, `TGraph`,; `TGraph2D` and `TMultiGraph` for fitting a collection of Graphs with the same function. ### The TH1::Fit Method. To fit a histogram programmatically, you can use the `TH1::Fit`; method. Here is the signatures of `TH1::Fit` and an explanation of the; parameters:. ``` {.cpp}; TFitResultPtr Fit(TF1 *function, Option_t *option, Option_t *goption,; Axis_t xxmin, Axis_t xxmax); ```; - `function` a pointer to the fitted function (the fit model) object.; One can also use the function name. This name may be one of ROOT pre-defined; function names or a user-defined function. See the next paragraph for the list of pre-defined functions. - `*option:` The second parameter is the fitting option. Here is the; list of fitting options:. 	- ""`W`"" Set all weights to 1 for non empty bins; ignore error bars. 	- ""`WW`"" Set all weights to 1 including empty bins; ignore error; bars. 	- ""`I`"" Use integral of function in bin instead of value at bin; center. 	- ""`L`"" Use log likelihood method (default is chi-square method). To be used when; the histogram represents counts. 	- ""`WL`"" Weighted log likelihood method. To be used when the histogram has been filled with; 	weights different than 1. - ""`P`"" Use Pearson chi-square method, using expected errors instead of the observed one given by `TH1::GetBinError` (default case).; The expected error is instead estimated from the square-root of the bin function value. 	- ""`Q`"" Quiet mode (minimum printing). 	- ""`V`"" Verbose mode (default is between Q and V). 	- ""`S`"" The result of the fit is returned in the `TFitResultPtr`. 	- ""`E`"" Perform better errors estimation using the Minos technique. 	- ""`M`"" Improve fit results, by using the *IMPROVE* algorithm of TMinuit. 	- ""`R`"" Use the range specified in the function range. 	- ""`N`"" Do not store the graphics function, do not draw. 	- ""`0`"" Do not plot the result of the fit. By default the fitted; function is drawn unless the option ""`N`"" above is specified. 	- ""`+`"" Add this new fitte",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:1612,Testability,log,log,1612,"ion. ### The TH1::Fit Method. To fit a histogram programmatically, you can use the `TH1::Fit`; method. Here is the signatures of `TH1::Fit` and an explanation of the; parameters:. ``` {.cpp}; TFitResultPtr Fit(TF1 *function, Option_t *option, Option_t *goption,; Axis_t xxmin, Axis_t xxmax); ```; - `function` a pointer to the fitted function (the fit model) object.; One can also use the function name. This name may be one of ROOT pre-defined; function names or a user-defined function. See the next paragraph for the list of pre-defined functions. - `*option:` The second parameter is the fitting option. Here is the; list of fitting options:. 	- ""`W`"" Set all weights to 1 for non empty bins; ignore error bars. 	- ""`WW`"" Set all weights to 1 including empty bins; ignore error; bars. 	- ""`I`"" Use integral of function in bin instead of value at bin; center. 	- ""`L`"" Use log likelihood method (default is chi-square method). To be used when; the histogram represents counts. 	- ""`WL`"" Weighted log likelihood method. To be used when the histogram has been filled with; 	weights different than 1. - ""`P`"" Use Pearson chi-square method, using expected errors instead of the observed one given by `TH1::GetBinError` (default case).; The expected error is instead estimated from the square-root of the bin function value. 	- ""`Q`"" Quiet mode (minimum printing). 	- ""`V`"" Verbose mode (default is between Q and V). 	- ""`S`"" The result of the fit is returned in the `TFitResultPtr`. 	- ""`E`"" Perform better errors estimation using the Minos technique. 	- ""`M`"" Improve fit results, by using the *IMPROVE* algorithm of TMinuit. 	- ""`R`"" Use the range specified in the function range. 	- ""`N`"" Do not store the graphics function, do not draw. 	- ""`0`"" Do not plot the result of the fit. By default the fitted; function is drawn unless the option ""`N`"" above is specified. 	- ""`+`"" Add this new fitted function to the list of fitted functions; (by default, the previous function is deleted and only the l",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:43650,Testability,log,log-likelihood,43650,"e. Each minimizer can be configured using the `ROOT::Math::MinimizerOptions` class. The list of possible option that can be set are:. * *Minimizer type* (`MinimizerOptions::SetMinimizerType(const char *)`) .; * *Minimizer algorithm* (`MinimizerOptions::SetMinimizerAlgorithm(const char *)`).; * *Print Level* (`MinimizerOptions::SetPrintLevel(int )`) to set the verbose printing level (default is 0).; * *Tolerance* (`MinimizerOptions::SetTolerance(double )`) tolerance used to control the iterations.; * *Maximum number of function calls* (`MinimizerOptions::SetMaxFunctionCalls(int )`).; * *Maximum number of iterations* (`MinimizerOptions::SetMaxIterations(int )`). Note that this is not used by *Minuit*; * *FCN Upper value for Error Definition* (`MinimizerOptions::SetErrorDef(double )`). Value in the minimization function used to compute the parameter errors.; The default is to get the uncertainties at the 68% CL is a value of 1 for a chi-squared function minimization and 0.5 for a log-likelihood function.; * *Strategy* (`MinimizerOptions::SetStrategy(int )`), minimization strategy used. For each minimization strategy *Minuit* uses different configuration parameters; (e.g. different requirements in computing derivatives, computing full Hessian (strategy = 2) or an approximate version. The default is a value of 1. In this case the full Hessian matrix; is computed only after the minimization.; * *Precision* (`MinimizerOptions::SetPrecision(double )`). Precision value in the evaluation of the minimization function. Default is numerical double precision. Note that not all the options are implemented by all the minimizers.; For example in *Minuit* is possible to set the maximum number of function calls, but not the maximum number of iterations. The Strategy and the Precision options apply instead only for *Minuit* (and; *Minuit2*). The class supports also setting global default values for the options, by using the static functions `MinimizerOptions::SetDefault...` (for exampl",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:65320,Testability,log,log,65320,"pendence, see the discussion above on; positive-definiteness. Possible other mathematical problems are the; following:. - Excessive numerical round off - be especially careful of; exponential and factorial functions which get big very quickly and; lose accuracy. - Starting too far from the solution - the function may have; unphysical local minima, especially at infinity in some variables. ## Minuit2 Package. `Minuit2` is a new object-oriented implementation, written in C++, of; the popular `MINUIT` minimization package. Compared with the; **`TMinuit`** class, which is a direct conversion from FORTRAN to C++,; `Minuit2` is a complete redesign and re-implementation of the package.; This new version provides all the functionality present in the old; FORTRAN version, with almost equivalent numerical accuracy and; computational performances.; Furthermore, it contains some fixes and small improvements and this new functionality:; * The possibility to set single side parameter limits; * the FUMILI algorithm (see the next paragraph ""FUMILI Minimization Package""),; which is an optimized method for least square and log; likelihood minimizations. Minuit2 has been originally developed by M.; Winkler and F. James in the SEAL project. More information can be found; on the [MINUIT Web Site](MINUIT Web Site) and in particular at the; following documentation page at; <http://www.cern.ch/minuit/doc/doc.html>. A detailed User Guide for Minuit2 exists, describing the API of the internal classes.; ROOT uses `Minuit2` for fitting via the `Minuit2Minimizer` class which implements; the `ROOT::Math::Minimizer` interface. `Minuit2` is also distributed as an independent package of ROOT and can be built; without any other dependency on the ROOT libraries. Examples on how to use the `Minuit2` and `Fumili2` plug-ins are provided; in the tutorials' directory `$ROOTSYS/tutorials/fit`:; `minuit2FitBench.C`, `minuit2FitBench2D.C` and `minuit2GausFit.C`.; More information on the classes and functions ",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:69712,Testability,log,logarithm,69712,"pprox Z_{ik}=; \sum^n_{j=1}{\frac{1}{\sigma^2_j}}{\frac{\partial f_j}{\theta_i}}; {\frac{\partial f_j}{\theta_k}}; $$. Then the equations for parameter increments are:. $$; \left(\frac{\partial\chi^2}{\partial\theta_i}\right)_; {\vec\theta={\vec\theta}^0} +\sum_k Z_{ik}\cdot(\theta_k-\theta^0_k) =; 0, \qquad i=1\ldots m; $$. Remarkable feature of algorithm is the technique for step restriction.; For an initial value of parameter ${\vec\theta}^0$ a parallelepiped; $P_0$ is built with the center at ${\vec\theta}^0$ and axes parallel; to coordinate axes $\theta_i$. The lengths of parallelepiped sides; along i-th axis is $2b_i$, where $b_i$ is such a value that the; functions $f_j(\vec\theta)$ are quasi-linear all over the; parallelepiped. FUMILI takes into account simple linear inequalities in the form:. $$ \theta_i^{min}\le\theta_i\le\theta^{max}_i$$. They form parallelepiped $P$ ($P_0$ may be deformed by $P$). Very; similar step formulae are used in FUMILI for negative logarithm of; the likelihood function with the same idea - linearization of function; argument. ## Neural Networks. ### Introduction. Neural Networks are used in various fields for data analysis and; classification, both for research and commercial institutions. Some; randomly chosen examples are image analysis, financial movements'; predictions and analysis, or sales forecast and product shipping; optimization. In particles physics neural networks are mainly used for; classification tasks (signal over background discrimination). A vast; majority of commonly used neural networks are multilayer perceptrons.; This implementation of multilayer perceptrons is inspired from the; `MLPfit` package, which remains one of the fastest tools for neural; networks studies. ### The MLP. The multilayer perceptron is a simple feed-forward network with the; following structure showed on the left. ![](pictures/0300008D.png). It is made of neurons characterized by a bias and weighted links in; between - let's call those l",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:75756,Testability,test,test,75756,"sponding value. Also,; if the string ends with '`!`', output neurons are set up for; classification, i.e. with a sigmoid (1 neuron) or softmax (more; neurons) activation function. Many questions on the good usage of neural network, including rules of; dumb to determine the best network topology are addressed at; <ftp://ftp.sas.com/pub/neural/FAQ.html>. ``` {.cpp}; // a simple network: 2 inputs, 10 hidden and 1 normalized; // output neuron; TMultiLayerPerceptron network(""r,z:10:@Br"",tree);; ```. Expressions are evaluated as for `TTree::Draw()`. Input and outputs; are taken from the **`TTree`** associated with the network. This; **`TTree`** can be given as argument of the constructor or defined; later with `TMultiLayerPerceptron::SetData()`. Events can also be; weighted. The weight expression can be given in the constructor or set; later with the method `SetWeight()` of the class; **`TMultiLayerPerceptron`**. Two datasets must be defined before; learning the network: a training dataset that is used when minimizing; the error, and a test dataset that will avoid bias. Those two datasets; can be built aside and then given to the network, or can be built from; a standard expression. By default, half of the events are put in both; datasets. ``` {.cpp}; // a more complex 4:8:1 network; // the ptsumf branch is used as weigh;; // default event lists are explicit; TMultiLayerPerceptron network(""m,pt,acol,acopl:8:type"",""pt"",tree,; ""Entry$%2"",""Entry$/2"");; ```. The method `TMultiLayerPerceptron::SetLearningMethod()` defines the; learning method. Learning methods are:. ```; TMultiLayerPerceptron::kStochastic,; TMultiLayerPerceptron::kBatch,; TMultiLayerPerceptron::kSteepestDescent,; TMultiLayerPerceptron::kRibierePolak,; TMultiLayerPerceptron::kFletcherReeves,; TMultiLayerPerceptron::kBFGS // default; ```. The training can start with; `TMultiLayerPerceptron::Train(Int_t nepoch,Option_t* options).` The; first argument is the number of epochs while option is a string that; can cont",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:4437,Usability,simpl,simply,4437,"ad. ### The TGraph::Fit Method. The signature for fitting a TGraph is exactly the same as for the **`TH1`**. Only some options apply only for fitting histograms,; these are the options ""`L`"", ""`WL`"" and ""`I`"".; These options apply instead only for `TGraph::Fit`, the rest of options (appart from ""`L`"", ""`WL`"" and ""`I`"" are the same). * `TGraph` specific *options*. 	- ""`EX0`"" When fitting a `TGraphErrors` or a `TgraphAsymErrors` the errors on the coordinates are not used in the fit. 	- ""`ROB`"" in case of linear fitting use the Robust fitting. Compute the LTS regression coefficients (robust (resistant) regression),; using the default fraction of good points.; 	- ""`ROB=0.x`"" as above, but compute the LTS regression coefficients, using 0.x as a fraction of good points. ## The `TF1` function class. Here we will show how to create the **`TF1`** class that is used for fitting histograms and graphs. ### Fit with a Predefined Function. To fit a histogram with a predefined function, simply pass the name of; the function in the first parameter of `TH1::Fit`. For example,; this line fits histogram object `hist` with a Gaussian. ``` {.cpp}; root[] hist.Fit(""gaus"");; ```. The initial parameter values (and eventual limits) for pre-defined functions are set; automatically. For overriding the default limits values use the fit option `B`. The list of pre-defined functions that can be used with the `Fit` method is the following:. - ""`gaus`"" Gaussian function with 3 parameters:; `f(x) = p0*exp(-0.5*((x-p1)/p2)^2)`. - ""`expo`""An Exponential with 2 parameters: `f(x) = exp(p0+p1*x)`. - ""`pol`*`N`*"" A polynomial of degree *N*, where N is a number between 0 and 9:; `f(x) = p0 + p1*x + p2*x2 +...`. - ""`chebyshev`*`N`*"" A Chebyshev polynomial of degree *N*, where N is a number between 0 and 9:; `f(x) = p0 + p1*x + p2*(2*x2-1) +...`. - ""`landau`"" Landau function with mean and sigma. This function has; been adapted from the `CERNLIB` routine `G110 denlan` (see `TMath::Landau`). - ""`gausn`"" Normal",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:13459,Usability,simpl,simple,13459,"arate sub ranges of the same histogram. To use a Gaussian, or; any other ROOT built in function, on a sub range you need to define a; new **`TF1`**. Each is 'derived' from the canned function `gaus`. ![Fitting a histogram with several Gaussian; functions](pictures/03000062.png). First, four **`TF1`** objects are created - one for each sub-range:. ``` {.cpp}; g1 = new TF1(""m1"",""gaus"",85,95);; g2 = new TF1(""m2"",""gaus"",98,108);; g3 = new TF1(""m3"",""gaus"",110,121);; // The total is the sum of the three, each has 3 parameters; total = new TF1(""mstotal"",""gaus(0)+gaus(3)+gaus(6)"",85,125);; ```. Next, we fill a histogram with bins defined in the array x. ``` {.cpp}; // Create a histogram and set it's contents; h = new TH1F(""g1"",""Example of several fits in subranges"",; np,85,134);; h->SetMaximum(7);; for (int i=0; i<np; i++) {; h->SetBinContent(i+1,x[i]);; }; // Define the parameter array for the total function; Double_t par[9];; ```. When fitting simple functions, such as a Gaussian, the initial values; of the parameters are automatically computed by ROOT. In the more; complicated case of the sum of 3 Gaussian functions, the initial; values of parameters must be set. In this particular case, the initial; values are taken from the result of the individual fits. The use of; the ""+"" sign is explained below:. ``` {.cpp}; // Fit each function and add it to the list of functions; h->Fit(g1,""R"");; h->Fit(g2,""R+"");; h->Fit(g3,""R+"");. // Get the parameters from the fit; g1->GetParameters(&par[0]);; g2->GetParameters(&par[3]);; g3->GetParameters(&par[6]);. // Use the parameters on the sum; total->SetParameters(par);; h->Fit(total,""R+"");; ```. ### Adding Functions to the List. The example `$ROOTSYS/tutorials/fit/multifit.C` also illustrates how; to fit several functions on the same histogram. By default a Fit; command deletes the previously fitted function in the histogram; object. You can specify the option ""+"" in the second parameter to add; the newly fitted function to the existing l",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:25427,Usability,feedback,feedback,25427,"ore the; function and do not draw it. ### Advances Options. The advance option button is enabled only after having performed the fit and provides; additional drawing options that can be used after having done the fit. These new drawing tools,; which can be selected by the ""Advanced Drawing Tool"" panel that pops up when clicking the ""Advanced"" button, are:. * *Contour*: to plot the confidence contour of two chosen parameters. One can select the number of points to draw the contour; (more points might require more time to compute it), the parameters and the desired confidence level . * *Scan* : to plot a scan of the minimization function (likelihood or chi-squared) around the minimum as function of the chosen parameter. * *Conf Interval* : to plot the confidence interval of the fitted function as a filled coloured band around its central value.; One can select the desired confidence level for the band to be plotted. ### Print Options. This set of options specifies the amount of feedback printed on the; root command line after performed fits. *‘Verbose'* - prints fit results after each iteration. *‘Quiet'* - no fit information is printed. *‘Default'* - between Verbose and Quiet. ### Command Buttons. *Fit button* - performs a fit taking different option settings via the; Fit Panel interface. *Reset* - sets the GUI elements and related fit settings to the; default ones. *Close* - closes the Fit panel window. ### Minimization Options. With this tab one can select specific options for minimization. These include. * The minimizer library ( *Minuit*, *Minuit2*, *Fumili*, *GSL*, *Genetics* ); * The method (algorithm) for minimization. For example for Minuit one can choose between (*Migrad*, *Simplex* or *Scan*); * Error definition; * Minimization tolerance; * Number of iterations/function calls; * Print Level: (*Default*, *Verbose* or *Quiet*). ## New ROOT::Fit classes. The fitting of the data objects in ROOT, histograms, graphs and tree is performed via some common classes,; ",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:28728,Usability,simpl,simple,28728,"ee later). User convenient typedefs are also provided.; 	They derive from the common generic interface multi-dimensional for function evaluation, `ROOT::Math::IBaseFunctionMultiDim`. In addition the fitter classes make uses of the generic interfaces for parametric function evaluations, `ROOT::Math::IParametricFunctionMultiDim`; to define the fit model function and use the `ROOT::Math::Minimizer` interface to perform the minimization of the objective function.; More information about the function interface and the multi-dimensional minimization in ROOT is given in the Mathematical Library chapter. Here we present a detailed description of the `ROOT::Fit` classes and how to use them.; Using these classes instead of the interface provided directly in the ROOT data objects, like `TH1::Fit` allow are more fine control; to configure and customise the fits. For example, using these classes a combined fit of several histograms can be performed. To understand how these class work, let's go through a simple example, such as fitting an histogram. When fitting an histogram, instead of using `TH1::Fit` we will show in the following hot wo use the `ROOT::Fit` classes.; We will show how to perform the following different type of fits with the histogram data:; * a least square fit using the observed errors (Neyman chi-squared);; * a least square fit using the expected errors from the function (Pearson chi-squared);; * a binned likelihood fit;; * an extended unbinned likelihood fits, if the histogram has been set to store in the buffer the original data used to fill it. Let's go through all the steps required for performing these fits using the `ROOT::Fit::Fitter` class.; These steps are:; 1. Create the input fit data object.; 2. Create the input model function.; 3. Configure the fit.; 4. Perform the data fitting.; 5. Examine the result. ### Creating the input fit data. We have two types of input data, binned data (class `ROOT::Fit::BinData`) used for least square (chi-square) fits o",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:53579,Usability,simpl,simply,53579," with the gaussian pre-defined function; histo->Fit(""gaus"");; ```. In the following we will give some brief description of the minimization packages.; The packages all implement the `ROOT::Math::Minimizer` interface which can be use for; finding the minimum of a multi-dimensional function.; The interface is documented in the Mathematical Library Chapter. In addition packages like Minuit or Minuit2 provide their own interfaces. ## MINUIT (Old TMInuit Version). This package was originally written in FORTRAN by Fred James and part; of `PACKLIB` (patch D506). It has been converted to a C++ class by; René Brun. The current implementation in C++ is a straightforward; conversion of the original FORTRAN version. The main changes are:. - The variables in the various `Minuit` labeled common blocks have; been changed to the **`TMinuit`** class data members. - The internal arrays with a maximum dimension depending on the; maximum number of parameters are now data members' arrays with a; dynamic dimension such that one can fit very large problems by; simply initializing the **`TMinuit`** constructor with the maximum; number of parameters. - The include file `Minuit.h` has been commented as much as possible; using existing comments in the code or the printed documentation. - The original `Minuit` subroutines are now member functions. - Constructors and destructor have been added. - Instead of passing the `FCN` function in the argument list, the; addresses of this function is stored as pointer in the data; members of the class. This is by far more elegant and flexible in; an interactive environment. The member function `SetFCN` can be; used to define this pointer. - The ROOT static function `Printf` is provided to replace all; format statements and to print on currently defined output file. - The functions `SetObjectFit/GetObjectFit` can be used inside the; `FCN` function to set/get a referenced object instead of using; global variables. - By default `fGraphicsMode` is true. When c",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:69501,Usability,simpl,simple,69501,"\theta_i^2$ instead of $\theta_i$. FUMILI will fail if; one tries minimize $\chi^2 = g^2(\vec\theta)$ where g is arbitrary; function. Approximate value is:. $$; {\frac{\partial^2\chi^2}{\partial\theta_i\partial\theta_k}}\approx Z_{ik}=; \sum^n_{j=1}{\frac{1}{\sigma^2_j}}{\frac{\partial f_j}{\theta_i}}; {\frac{\partial f_j}{\theta_k}}; $$. Then the equations for parameter increments are:. $$; \left(\frac{\partial\chi^2}{\partial\theta_i}\right)_; {\vec\theta={\vec\theta}^0} +\sum_k Z_{ik}\cdot(\theta_k-\theta^0_k) =; 0, \qquad i=1\ldots m; $$. Remarkable feature of algorithm is the technique for step restriction.; For an initial value of parameter ${\vec\theta}^0$ a parallelepiped; $P_0$ is built with the center at ${\vec\theta}^0$ and axes parallel; to coordinate axes $\theta_i$. The lengths of parallelepiped sides; along i-th axis is $2b_i$, where $b_i$ is such a value that the; functions $f_j(\vec\theta)$ are quasi-linear all over the; parallelepiped. FUMILI takes into account simple linear inequalities in the form:. $$ \theta_i^{min}\le\theta_i\le\theta^{max}_i$$. They form parallelepiped $P$ ($P_0$ may be deformed by $P$). Very; similar step formulae are used in FUMILI for negative logarithm of; the likelihood function with the same idea - linearization of function; argument. ## Neural Networks. ### Introduction. Neural Networks are used in various fields for data analysis and; classification, both for research and commercial institutions. Some; randomly chosen examples are image analysis, financial movements'; predictions and analysis, or sales forecast and product shipping; optimization. In particles physics neural networks are mainly used for; classification tasks (signal over background discrimination). A vast; majority of commonly used neural networks are multilayer perceptrons.; This implementation of multilayer perceptrons is inspired from the; `MLPfit` package, which remains one of the fastest tools for neural; networks studies. ### The MLP. The multilaye",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:70526,Usability,simpl,simple,70526,"eta_i^{min}\le\theta_i\le\theta^{max}_i$$. They form parallelepiped $P$ ($P_0$ may be deformed by $P$). Very; similar step formulae are used in FUMILI for negative logarithm of; the likelihood function with the same idea - linearization of function; argument. ## Neural Networks. ### Introduction. Neural Networks are used in various fields for data analysis and; classification, both for research and commercial institutions. Some; randomly chosen examples are image analysis, financial movements'; predictions and analysis, or sales forecast and product shipping; optimization. In particles physics neural networks are mainly used for; classification tasks (signal over background discrimination). A vast; majority of commonly used neural networks are multilayer perceptrons.; This implementation of multilayer perceptrons is inspired from the; `MLPfit` package, which remains one of the fastest tools for neural; networks studies. ### The MLP. The multilayer perceptron is a simple feed-forward network with the; following structure showed on the left. ![](pictures/0300008D.png). It is made of neurons characterized by a bias and weighted links in; between - let's call those links synapses. The input neurons receive; the inputs, normalize them and forward them to the first hidden layer.; Each neuron in any subsequent layer first computes a linear; combination of the outputs of the previous layer. The output of the; neuron is then function of that combination with f being linear for; output neurons or a sigmoid for hidden layers. Such a structure is very useful because of two theorems:. 1- A linear combination of `sigmoids` can approximate any continuous; function. 2- Trained with `output=1` for the signal and 0 for the background,; the approximated function of inputs `X` is the probability of signal,; knowing `X`. ### Learning Methods. The aim of all learning methods is to minimize the total error on a; set of weighted examples. The error is defined as the sum in quadrate,; divide",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:71417,Usability,learn,learning,71417,"ols for neural; networks studies. ### The MLP. The multilayer perceptron is a simple feed-forward network with the; following structure showed on the left. ![](pictures/0300008D.png). It is made of neurons characterized by a bias and weighted links in; between - let's call those links synapses. The input neurons receive; the inputs, normalize them and forward them to the first hidden layer.; Each neuron in any subsequent layer first computes a linear; combination of the outputs of the previous layer. The output of the; neuron is then function of that combination with f being linear for; output neurons or a sigmoid for hidden layers. Such a structure is very useful because of two theorems:. 1- A linear combination of `sigmoids` can approximate any continuous; function. 2- Trained with `output=1` for the signal and 0 for the background,; the approximated function of inputs `X` is the probability of signal,; knowing `X`. ### Learning Methods. The aim of all learning methods is to minimize the total error on a; set of weighted examples. The error is defined as the sum in quadrate,; divided by two, of the error on each individual output neuron. In all; methods implemented in this library, one needs to compute the first; derivative of that error with respect to the weights. Exploiting the; well-known properties of the derivative, one can express this; derivative as the product of the local partial derivative by the; weighted sum of the outputs derivatives (for a neuron) or as the; product of the input value with the local partial derivative of the; output neuron (for a synapse). This computation is called; ""back-propagation of the errors"". Six learning methods are; implemented. #### Stochastic Minimization. This is the most trivial learning method. The Robbins-Monro stochastic; approximation is applied to multilayer perceptrons. The weights are; updated after each example according to the formula:. $$; w_{ij}(t+1) = w_{ij}(t) + \Delta w_{ij}(t); $$. with:. $$; \Delta w_{ij",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:72114,Usability,learn,learning,72114," of two theorems:. 1- A linear combination of `sigmoids` can approximate any continuous; function. 2- Trained with `output=1` for the signal and 0 for the background,; the approximated function of inputs `X` is the probability of signal,; knowing `X`. ### Learning Methods. The aim of all learning methods is to minimize the total error on a; set of weighted examples. The error is defined as the sum in quadrate,; divided by two, of the error on each individual output neuron. In all; methods implemented in this library, one needs to compute the first; derivative of that error with respect to the weights. Exploiting the; well-known properties of the derivative, one can express this; derivative as the product of the local partial derivative by the; weighted sum of the outputs derivatives (for a neuron) or as the; product of the input value with the local partial derivative of the; output neuron (for a synapse). This computation is called; ""back-propagation of the errors"". Six learning methods are; implemented. #### Stochastic Minimization. This is the most trivial learning method. The Robbins-Monro stochastic; approximation is applied to multilayer perceptrons. The weights are; updated after each example according to the formula:. $$; w_{ij}(t+1) = w_{ij}(t) + \Delta w_{ij}(t); $$. with:. $$; \Delta w_{ij}(t) = - \eta \left(; \frac{\partial e_p}{\partial w_{ij}} + \delta \right) +; \epsilon \Delta w_{ij}(t-1); $$. The parameters for this method are `Eta`, `EtaDecay`, `Delta` and; `Epsilon`. #### Steepest Descent With Fixed Step Size (Batch Learning). It is the same as the stochastic minimization, but the weights are; updated after considering all the examples, with the total derivative; `dEdw`. The parameters for this method are `Eta`, `EtaDecay`, `Delta`; and `Epsilon`. #### Steepest Descent Algorithm. Weights are set to the minimum along the line defined by the gradient.; The only parameter for this method is `Tau`. Lower `Tau` = higher; precision = slower search. A val",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:72204,Usability,learn,learning,72204,"e any continuous; function. 2- Trained with `output=1` for the signal and 0 for the background,; the approximated function of inputs `X` is the probability of signal,; knowing `X`. ### Learning Methods. The aim of all learning methods is to minimize the total error on a; set of weighted examples. The error is defined as the sum in quadrate,; divided by two, of the error on each individual output neuron. In all; methods implemented in this library, one needs to compute the first; derivative of that error with respect to the weights. Exploiting the; well-known properties of the derivative, one can express this; derivative as the product of the local partial derivative by the; weighted sum of the outputs derivatives (for a neuron) or as the; product of the input value with the local partial derivative of the; output neuron (for a synapse). This computation is called; ""back-propagation of the errors"". Six learning methods are; implemented. #### Stochastic Minimization. This is the most trivial learning method. The Robbins-Monro stochastic; approximation is applied to multilayer perceptrons. The weights are; updated after each example according to the formula:. $$; w_{ij}(t+1) = w_{ij}(t) + \Delta w_{ij}(t); $$. with:. $$; \Delta w_{ij}(t) = - \eta \left(; \frac{\partial e_p}{\partial w_{ij}} + \delta \right) +; \epsilon \Delta w_{ij}(t-1); $$. The parameters for this method are `Eta`, `EtaDecay`, `Delta` and; `Epsilon`. #### Steepest Descent With Fixed Step Size (Batch Learning). It is the same as the stochastic minimization, but the weights are; updated after considering all the examples, with the total derivative; `dEdw`. The parameters for this method are `Eta`, `EtaDecay`, `Delta`; and `Epsilon`. #### Steepest Descent Algorithm. Weights are set to the minimum along the line defined by the gradient.; The only parameter for this method is `Tau`. Lower `Tau` = higher; precision = slower search. A value `Tau=3` seems reasonable. #### Conjugate Gradients With the Polak-R",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:75082,Usability,simpl,simple,75082,"ample is a set of; values defining the inputs and the corresponding output that the; network should ideally provide. In ROOT this is a **`TTree`** entry.; The first thing to be decided is the network layout. This layout is; described in a string where the layers are separated by semicolons.; The input/output layers are defined by giving the expression for each; neuron, separated by comas. Hidden layers are just described by the; number of neurons. In addition, input and output layer formulas can be preceded by '@'; (e.g. ""@out"") if one wants to normalize the corresponding value. Also,; if the string ends with '`!`', output neurons are set up for; classification, i.e. with a sigmoid (1 neuron) or softmax (more; neurons) activation function. Many questions on the good usage of neural network, including rules of; dumb to determine the best network topology are addressed at; <ftp://ftp.sas.com/pub/neural/FAQ.html>. ``` {.cpp}; // a simple network: 2 inputs, 10 hidden and 1 normalized; // output neuron; TMultiLayerPerceptron network(""r,z:10:@Br"",tree);; ```. Expressions are evaluated as for `TTree::Draw()`. Input and outputs; are taken from the **`TTree`** associated with the network. This; **`TTree`** can be given as argument of the constructor or defined; later with `TMultiLayerPerceptron::SetData()`. Events can also be; weighted. The weight expression can be given in the constructor or set; later with the method `SetWeight()` of the class; **`TMultiLayerPerceptron`**. Two datasets must be defined before; learning the network: a training dataset that is used when minimizing; the error, and a test dataset that will avoid bias. Those two datasets; can be built aside and then given to the network, or can be built from; a standard expression. By default, half of the events are put in both; datasets. ``` {.cpp}; // a more complex 4:8:1 network; // the ptsumf branch is used as weigh;; // default event lists are explicit; TMultiLayerPerceptron network(""m,pt,acol,acopl:8:type""",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:75668,Usability,learn,learning,75668,"sponding value. Also,; if the string ends with '`!`', output neurons are set up for; classification, i.e. with a sigmoid (1 neuron) or softmax (more; neurons) activation function. Many questions on the good usage of neural network, including rules of; dumb to determine the best network topology are addressed at; <ftp://ftp.sas.com/pub/neural/FAQ.html>. ``` {.cpp}; // a simple network: 2 inputs, 10 hidden and 1 normalized; // output neuron; TMultiLayerPerceptron network(""r,z:10:@Br"",tree);; ```. Expressions are evaluated as for `TTree::Draw()`. Input and outputs; are taken from the **`TTree`** associated with the network. This; **`TTree`** can be given as argument of the constructor or defined; later with `TMultiLayerPerceptron::SetData()`. Events can also be; weighted. The weight expression can be given in the constructor or set; later with the method `SetWeight()` of the class; **`TMultiLayerPerceptron`**. Two datasets must be defined before; learning the network: a training dataset that is used when minimizing; the error, and a test dataset that will avoid bias. Those two datasets; can be built aside and then given to the network, or can be built from; a standard expression. By default, half of the events are put in both; datasets. ``` {.cpp}; // a more complex 4:8:1 network; // the ptsumf branch is used as weigh;; // default event lists are explicit; TMultiLayerPerceptron network(""m,pt,acol,acopl:8:type"",""pt"",tree,; ""Entry$%2"",""Entry$/2"");; ```. The method `TMultiLayerPerceptron::SetLearningMethod()` defines the; learning method. Learning methods are:. ```; TMultiLayerPerceptron::kStochastic,; TMultiLayerPerceptron::kBatch,; TMultiLayerPerceptron::kSteepestDescent,; TMultiLayerPerceptron::kRibierePolak,; TMultiLayerPerceptron::kFletcherReeves,; TMultiLayerPerceptron::kBFGS // default; ```. The training can start with; `TMultiLayerPerceptron::Train(Int_t nepoch,Option_t* options).` The; first argument is the number of epochs while option is a string that; can cont",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:76252,Usability,learn,learning,76252," evaluated as for `TTree::Draw()`. Input and outputs; are taken from the **`TTree`** associated with the network. This; **`TTree`** can be given as argument of the constructor or defined; later with `TMultiLayerPerceptron::SetData()`. Events can also be; weighted. The weight expression can be given in the constructor or set; later with the method `SetWeight()` of the class; **`TMultiLayerPerceptron`**. Two datasets must be defined before; learning the network: a training dataset that is used when minimizing; the error, and a test dataset that will avoid bias. Those two datasets; can be built aside and then given to the network, or can be built from; a standard expression. By default, half of the events are put in both; datasets. ``` {.cpp}; // a more complex 4:8:1 network; // the ptsumf branch is used as weigh;; // default event lists are explicit; TMultiLayerPerceptron network(""m,pt,acol,acopl:8:type"",""pt"",tree,; ""Entry$%2"",""Entry$/2"");; ```. The method `TMultiLayerPerceptron::SetLearningMethod()` defines the; learning method. Learning methods are:. ```; TMultiLayerPerceptron::kStochastic,; TMultiLayerPerceptron::kBatch,; TMultiLayerPerceptron::kSteepestDescent,; TMultiLayerPerceptron::kRibierePolak,; TMultiLayerPerceptron::kFletcherReeves,; TMultiLayerPerceptron::kBFGS // default; ```. The training can start with; `TMultiLayerPerceptron::Train(Int_t nepoch,Option_t* options).` The; first argument is the number of epochs while option is a string that; can contain ""`text`"" (simple text output), ""`graph`"" (evaluating; graphical training curves), ""`update` `=` `X`"" (step for the; text/graph output update) or ""`+`"" (will skip the randomization and; start from the previous values). All combinations are available. ``` {.cpp}; network.Train(1000,""text,graph,update=10""); // full output every; // 10 epochs; network.Train(100,""text,+""); // 100 more epochs; //starts with existing weights; ```. The weights can be saved to a file (`DumpWeights`) and then reloaded; (`LoadWeights",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:76724,Usability,simpl,simple,76724," avoid bias. Those two datasets; can be built aside and then given to the network, or can be built from; a standard expression. By default, half of the events are put in both; datasets. ``` {.cpp}; // a more complex 4:8:1 network; // the ptsumf branch is used as weigh;; // default event lists are explicit; TMultiLayerPerceptron network(""m,pt,acol,acopl:8:type"",""pt"",tree,; ""Entry$%2"",""Entry$/2"");; ```. The method `TMultiLayerPerceptron::SetLearningMethod()` defines the; learning method. Learning methods are:. ```; TMultiLayerPerceptron::kStochastic,; TMultiLayerPerceptron::kBatch,; TMultiLayerPerceptron::kSteepestDescent,; TMultiLayerPerceptron::kRibierePolak,; TMultiLayerPerceptron::kFletcherReeves,; TMultiLayerPerceptron::kBFGS // default; ```. The training can start with; `TMultiLayerPerceptron::Train(Int_t nepoch,Option_t* options).` The; first argument is the number of epochs while option is a string that; can contain ""`text`"" (simple text output), ""`graph`"" (evaluating; graphical training curves), ""`update` `=` `X`"" (step for the; text/graph output update) or ""`+`"" (will skip the randomization and; start from the previous values). All combinations are available. ``` {.cpp}; network.Train(1000,""text,graph,update=10""); // full output every; // 10 epochs; network.Train(100,""text,+""); // 100 more epochs; //starts with existing weights; ```. The weights can be saved to a file (`DumpWeights`) and then reloaded; (`LoadWeights`) to a new compatible network. The output can also be; evaluated (`Evaluate`) for a given output neuron and an array of; double input parameters or the network can be exported (`Export`) as a; standalone code. Up to now, this is only as a C++ or PYTHON class, but; other languages could be implemented. ### Examples. An example of how to use **`TMultiLayerPerceptron`** is the macro; `mlpHiggs.C` in \$ROOTSYS/tutorials. Using some standard simulated; information that could have been obtained at `LEP`, a neural network; is build, which can make the d",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:77957,Usability,simpl,simple,77957,"e previous values). All combinations are available. ``` {.cpp}; network.Train(1000,""text,graph,update=10""); // full output every; // 10 epochs; network.Train(100,""text,+""); // 100 more epochs; //starts with existing weights; ```. The weights can be saved to a file (`DumpWeights`) and then reloaded; (`LoadWeights`) to a new compatible network. The output can also be; evaluated (`Evaluate`) for a given output neuron and an array of; double input parameters or the network can be exported (`Export`) as a; standalone code. Up to now, this is only as a C++ or PYTHON class, but; other languages could be implemented. ### Examples. An example of how to use **`TMultiLayerPerceptron`** is the macro; `mlpHiggs.C` in \$ROOTSYS/tutorials. Using some standard simulated; information that could have been obtained at `LEP`, a neural network; is build, which can make the difference between `WW` events and events; containing a Higgs boson. Starting with a **`TFile`** containing two; **`TTree`**s: one for the signal, the other for the background, a; simple script is used:. ``` {.cpp}; void mlpHiggs(Int_t ntrain=100) {; if (!gROOT->GetClass(""TMultiLayerPerceptron"")); gSystem->Load(""libMLP"");; // prepare inputs - the 2 trees are merged into one, and a; // ""type"" branch, equal to 1 for the signal and 0 for the; // background is added; TFile input(""mlpHiggs.root"");; TTree *signal = (TTree *)input.Get(""sig_filtered"");; TTree *background = (TTree *)input.Get(""bg_filtered"");; TTree *simu = new TTree(""MonteCarlo"",; ""Filtered Monte Carlo Events"");; ...; ```. Since the input is a **`TTree`** and we are starting from two; different **`TTree`**s (with different names), they are first merged; into one, and a ""`type`"" branch is added, that says whether there is; a signal or a background event. Those irrelevant details are skipped; here. ``` {.cpp}; ...; TMultiLayerPerceptron *mlp = new TMultiLayerPerceptron(; ""msumf,ptsumf, acolin, acopl:8:type"",""ptsumf"",simu,; ""Entry$%2"",""Entry$/2"");; mlp->Train(ntra",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:81272,Usability,learn,learning,81272,">GetEntry(i);; params[0] = msumf; params[1] = ptsumf;; params[2] = acolin; params[3] = acopl;; bg->Fill(mlp->Evaluate(0,params));; }; for (i = 0; i < signal->GetEntries(); i++) {; signal->GetEntry(i);; params[0] = msumf;; params[1] = ptsumf;; params[2] = acolin;; params[3] = acopl;; sig->Fill(mlp->Evaluate(0,params));; }; TCanvas *cv = new TCanvas(""NNout_cv"",""Neural net output"");; bg->SetFillStyle(3008);; bg->SetFillColor(kBlue);; sig->SetFillStyle(3003);; sig->SetFillColor(kRed);; bg->SetStats(0);; sig->SetStats(0);; bg->Draw();; sig->Draw(""same"");; TLegend *legend = new TLegend(.75,.80,.95,.95);; legend->AddEntry(bg,""Background(WW)"");; legend->AddEntry(sig,""Signal(Higgs)"");; legend->Draw();; ```. The neural net output is then used to display the final difference; between background and signal events. The figure ""The neural net; output"" shows this plot. ![The neural net output](pictures/image144.png). As it can be seen, this is a quite efficient technique. As mentioned; earlier, neural networks are also used for fitting function. For some; application with a cylindrical symmetry, a magnetic field simulation; gives as output the angular component of the potential vector `A`, as; well as the radial and `z` components of the `B` field. One wants to fit those distributions with a function in order to plug; them into the `Geant` simulation code. Polynomial fits could be tried,; but it seems difficult to reach the desired precision over the full; range. One could also use a `spline` interpolation between known; points. In all cases, the resulting field would not be `C`-infinite. An example of output (for Br) is shown. First the initial function can; be seen as the target. Then, the resulting (normalized) neural net; output. In order to ease the learning, the ""normalize output"" was used; here. The initial amplitude can be recovered by multiplying by the; original RMS and then shifting by the original mean. ![The original and the neural net for Br](pictures/image145.jpg); ",MatchSource.DOCS,documentation/users-guide/FittingHistograms.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FoldersTasks.md:3536,Deployability,configurat,configuration,3536,"lder::AddFolder`** method. This method takes two parameters: the; name and title of the folder to be added. It returns a pointer of the; newly created folder. The code below creates the folder hierarchy shown in the browser. In; this macro, the folder is also added to the list of browsable. This way,; it is visible in the browser on the top level. ``` {.cpp}; {; // Add the top folder of my hierary to //root; TFolder *aliroot=gROOT->GetRootFolder()->AddFolder(""aliroot"",; ""aliroot top level folders"");; // Add the hierarchy to the list of browsables; gROOT->GetListOfBrowsables()->Add(aliroot,""aliroot"");. // Create and add the constants folder; TFolder *constants=aliroot->AddFolder(""Constants"",; ""Detector constants"");. // Create and add the pdg folder to pdg; TFolder *pdg = constants->AddFolder(""DatabasePDG"",""PDG database"");. // Create and add the run folder; TFolder *run = aliroot->AddFolder(""Run"",""Run dependent folders"");. // Create and add the configuration folder to run; TFolder *configuration = run->AddFolder(""Configuration"",; ""Run configuration"");. // Create and add the run_mc folder; TFolder *run_mc = aliroot->AddFolder(""RunMC"",; ""MonteCarlo run dependent folders"");. // Create and add the configuration_mc folder to run_mc; TFolder *configuration_mc = run_mc->AddFolder(""Configuration"",; ""MonteCarlo run configuration"");; }; ```. ### Posting Data to a Folder (Producer). ![](pictures/030000E4.png). A **`TFolder`** can contain other folders as shown above or any; **`TObject`** descendents. In general, users will not post a single; object to a folder; they will store a collection or multiple collections; in a folder. For example, to add an array to a folder:. ``` {.cpp}; TObjArray *array;; run_mc->Add(array);; ```. ### Reading Data from a Folder (Consumer). One can search for a folder or an object in a folder using the; `TROOT::FindObjectAny` method. It analyzes the string passed as its; argument and searches in the hierarchy until it finds an object or; folder matchin",MatchSource.DOCS,documentation/users-guide/FoldersTasks.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FoldersTasks.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FoldersTasks.md:3574,Deployability,configurat,configuration,3574,"lder::AddFolder`** method. This method takes two parameters: the; name and title of the folder to be added. It returns a pointer of the; newly created folder. The code below creates the folder hierarchy shown in the browser. In; this macro, the folder is also added to the list of browsable. This way,; it is visible in the browser on the top level. ``` {.cpp}; {; // Add the top folder of my hierary to //root; TFolder *aliroot=gROOT->GetRootFolder()->AddFolder(""aliroot"",; ""aliroot top level folders"");; // Add the hierarchy to the list of browsables; gROOT->GetListOfBrowsables()->Add(aliroot,""aliroot"");. // Create and add the constants folder; TFolder *constants=aliroot->AddFolder(""Constants"",; ""Detector constants"");. // Create and add the pdg folder to pdg; TFolder *pdg = constants->AddFolder(""DatabasePDG"",""PDG database"");. // Create and add the run folder; TFolder *run = aliroot->AddFolder(""Run"",""Run dependent folders"");. // Create and add the configuration folder to run; TFolder *configuration = run->AddFolder(""Configuration"",; ""Run configuration"");. // Create and add the run_mc folder; TFolder *run_mc = aliroot->AddFolder(""RunMC"",; ""MonteCarlo run dependent folders"");. // Create and add the configuration_mc folder to run_mc; TFolder *configuration_mc = run_mc->AddFolder(""Configuration"",; ""MonteCarlo run configuration"");; }; ```. ### Posting Data to a Folder (Producer). ![](pictures/030000E4.png). A **`TFolder`** can contain other folders as shown above or any; **`TObject`** descendents. In general, users will not post a single; object to a folder; they will store a collection or multiple collections; in a folder. For example, to add an array to a folder:. ``` {.cpp}; TObjArray *array;; run_mc->Add(array);; ```. ### Reading Data from a Folder (Consumer). One can search for a folder or an object in a folder using the; `TROOT::FindObjectAny` method. It analyzes the string passed as its; argument and searches in the hierarchy until it finds an object or; folder matchin",MatchSource.DOCS,documentation/users-guide/FoldersTasks.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FoldersTasks.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FoldersTasks.md:3628,Deployability,configurat,configuration,3628,"lder::AddFolder`** method. This method takes two parameters: the; name and title of the folder to be added. It returns a pointer of the; newly created folder. The code below creates the folder hierarchy shown in the browser. In; this macro, the folder is also added to the list of browsable. This way,; it is visible in the browser on the top level. ``` {.cpp}; {; // Add the top folder of my hierary to //root; TFolder *aliroot=gROOT->GetRootFolder()->AddFolder(""aliroot"",; ""aliroot top level folders"");; // Add the hierarchy to the list of browsables; gROOT->GetListOfBrowsables()->Add(aliroot,""aliroot"");. // Create and add the constants folder; TFolder *constants=aliroot->AddFolder(""Constants"",; ""Detector constants"");. // Create and add the pdg folder to pdg; TFolder *pdg = constants->AddFolder(""DatabasePDG"",""PDG database"");. // Create and add the run folder; TFolder *run = aliroot->AddFolder(""Run"",""Run dependent folders"");. // Create and add the configuration folder to run; TFolder *configuration = run->AddFolder(""Configuration"",; ""Run configuration"");. // Create and add the run_mc folder; TFolder *run_mc = aliroot->AddFolder(""RunMC"",; ""MonteCarlo run dependent folders"");. // Create and add the configuration_mc folder to run_mc; TFolder *configuration_mc = run_mc->AddFolder(""Configuration"",; ""MonteCarlo run configuration"");; }; ```. ### Posting Data to a Folder (Producer). ![](pictures/030000E4.png). A **`TFolder`** can contain other folders as shown above or any; **`TObject`** descendents. In general, users will not post a single; object to a folder; they will store a collection or multiple collections; in a folder. For example, to add an array to a folder:. ``` {.cpp}; TObjArray *array;; run_mc->Add(array);; ```. ### Reading Data from a Folder (Consumer). One can search for a folder or an object in a folder using the; `TROOT::FindObjectAny` method. It analyzes the string passed as its; argument and searches in the hierarchy until it finds an object or; folder matchin",MatchSource.DOCS,documentation/users-guide/FoldersTasks.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FoldersTasks.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FoldersTasks.md:3905,Deployability,configurat,configuration,3905,"the list of browsable. This way,; it is visible in the browser on the top level. ``` {.cpp}; {; // Add the top folder of my hierary to //root; TFolder *aliroot=gROOT->GetRootFolder()->AddFolder(""aliroot"",; ""aliroot top level folders"");; // Add the hierarchy to the list of browsables; gROOT->GetListOfBrowsables()->Add(aliroot,""aliroot"");. // Create and add the constants folder; TFolder *constants=aliroot->AddFolder(""Constants"",; ""Detector constants"");. // Create and add the pdg folder to pdg; TFolder *pdg = constants->AddFolder(""DatabasePDG"",""PDG database"");. // Create and add the run folder; TFolder *run = aliroot->AddFolder(""Run"",""Run dependent folders"");. // Create and add the configuration folder to run; TFolder *configuration = run->AddFolder(""Configuration"",; ""Run configuration"");. // Create and add the run_mc folder; TFolder *run_mc = aliroot->AddFolder(""RunMC"",; ""MonteCarlo run dependent folders"");. // Create and add the configuration_mc folder to run_mc; TFolder *configuration_mc = run_mc->AddFolder(""Configuration"",; ""MonteCarlo run configuration"");; }; ```. ### Posting Data to a Folder (Producer). ![](pictures/030000E4.png). A **`TFolder`** can contain other folders as shown above or any; **`TObject`** descendents. In general, users will not post a single; object to a folder; they will store a collection or multiple collections; in a folder. For example, to add an array to a folder:. ``` {.cpp}; TObjArray *array;; run_mc->Add(array);; ```. ### Reading Data from a Folder (Consumer). One can search for a folder or an object in a folder using the; `TROOT::FindObjectAny` method. It analyzes the string passed as its; argument and searches in the hierarchy until it finds an object or; folder matching the name. With `FindObjectAny`, you can give the full; path name, or the name of the folder. If only the name of the folder is; given, it will return the first instance of that name. A string-based; search is time consuming. If the retrieved object is used frequently ",MatchSource.DOCS,documentation/users-guide/FoldersTasks.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FoldersTasks.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FoldersTasks.md:526,Energy Efficiency,reduce,reduce,526,"# Folders and Tasks. ## Folders. ![](pictures/030000E1.png). A **`TFolder`** is a collection of objects; visible and expandable in the ROOT object browser. Folders have a name; and a title and are identified in the folder hierarchy by an ""UNIX-like""; naming convention. The base of all folders is `//root`. It is visible at; the top of the left panel in the browser. The browser shows several; folders under `//root`. New folders can be added and removed to/from a folder. ## Why Use Folders?. One reason to use folders is to reduce class dependencies and improve; modularity. Each set of data has a producer class and one or many; consumer classes. When using folders, the producer class places a; pointer to the data into a folder, and the consumer class retrieves a; reference to the folder. The consumer can access the objects in a folder by specifying the path; name of the folder. Here is an example of a folder's path name:. `//root/Event/Hits/TCP`. One does not have to specify the full path name. If the partial path; name is unique, it will find it; otherwise it will return the first; occurrence of the path. The first diagram shows a system without folders. The objects have; pointers to each other to access each other's data. Pointers are an; efficient way to share data between classes. However, a direct pointer; creates a direct coupling between classes. This design can become a very; tangled web of dependencies in a system with a large number of classes. ![](pictures/020000E2.jpg). In the second diagram, a reference to the data is in the folder and the; consumers refer to the folder rather than each other to access the data.; The naming and search service provided by the ROOT folders hierarchy; provides an alternative. It loosely couples the classes and greatly; enhances I/O operations. In this way, folders separate the data from the; algorithms and greatly improve the modularity of an application by; minimizing the class dependencies. ![](pictures/020000E3.jpg). In addi",MatchSource.DOCS,documentation/users-guide/FoldersTasks.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FoldersTasks.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FoldersTasks.md:1257,Energy Efficiency,efficient,efficient,1257,"The base of all folders is `//root`. It is visible at; the top of the left panel in the browser. The browser shows several; folders under `//root`. New folders can be added and removed to/from a folder. ## Why Use Folders?. One reason to use folders is to reduce class dependencies and improve; modularity. Each set of data has a producer class and one or many; consumer classes. When using folders, the producer class places a; pointer to the data into a folder, and the consumer class retrieves a; reference to the folder. The consumer can access the objects in a folder by specifying the path; name of the folder. Here is an example of a folder's path name:. `//root/Event/Hits/TCP`. One does not have to specify the full path name. If the partial path; name is unique, it will find it; otherwise it will return the first; occurrence of the path. The first diagram shows a system without folders. The objects have; pointers to each other to access each other's data. Pointers are an; efficient way to share data between classes. However, a direct pointer; creates a direct coupling between classes. This design can become a very; tangled web of dependencies in a system with a large number of classes. ![](pictures/020000E2.jpg). In the second diagram, a reference to the data is in the folder and the; consumers refer to the folder rather than each other to access the data.; The naming and search service provided by the ROOT folders hierarchy; provides an alternative. It loosely couples the classes and greatly; enhances I/O operations. In this way, folders separate the data from the; algorithms and greatly improve the modularity of an application by; minimizing the class dependencies. ![](pictures/020000E3.jpg). In addition, the folder hierarchy creates a picture of the data; organization. This is useful when discussing data design issues or when; learning the data organization. The example below illustrates this; point. ## How to Use Folders. Using folders means to build a hierarchy",MatchSource.DOCS,documentation/users-guide/FoldersTasks.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FoldersTasks.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FoldersTasks.md:539,Integrability,depend,dependencies,539,"# Folders and Tasks. ## Folders. ![](pictures/030000E1.png). A **`TFolder`** is a collection of objects; visible and expandable in the ROOT object browser. Folders have a name; and a title and are identified in the folder hierarchy by an ""UNIX-like""; naming convention. The base of all folders is `//root`. It is visible at; the top of the left panel in the browser. The browser shows several; folders under `//root`. New folders can be added and removed to/from a folder. ## Why Use Folders?. One reason to use folders is to reduce class dependencies and improve; modularity. Each set of data has a producer class and one or many; consumer classes. When using folders, the producer class places a; pointer to the data into a folder, and the consumer class retrieves a; reference to the folder. The consumer can access the objects in a folder by specifying the path; name of the folder. Here is an example of a folder's path name:. `//root/Event/Hits/TCP`. One does not have to specify the full path name. If the partial path; name is unique, it will find it; otherwise it will return the first; occurrence of the path. The first diagram shows a system without folders. The objects have; pointers to each other to access each other's data. Pointers are an; efficient way to share data between classes. However, a direct pointer; creates a direct coupling between classes. This design can become a very; tangled web of dependencies in a system with a large number of classes. ![](pictures/020000E2.jpg). In the second diagram, a reference to the data is in the folder and the; consumers refer to the folder rather than each other to access the data.; The naming and search service provided by the ROOT folders hierarchy; provides an alternative. It loosely couples the classes and greatly; enhances I/O operations. In this way, folders separate the data from the; algorithms and greatly improve the modularity of an application by; minimizing the class dependencies. ![](pictures/020000E3.jpg). In addi",MatchSource.DOCS,documentation/users-guide/FoldersTasks.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FoldersTasks.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FoldersTasks.md:1418,Integrability,depend,dependencies,1418,"folders can be added and removed to/from a folder. ## Why Use Folders?. One reason to use folders is to reduce class dependencies and improve; modularity. Each set of data has a producer class and one or many; consumer classes. When using folders, the producer class places a; pointer to the data into a folder, and the consumer class retrieves a; reference to the folder. The consumer can access the objects in a folder by specifying the path; name of the folder. Here is an example of a folder's path name:. `//root/Event/Hits/TCP`. One does not have to specify the full path name. If the partial path; name is unique, it will find it; otherwise it will return the first; occurrence of the path. The first diagram shows a system without folders. The objects have; pointers to each other to access each other's data. Pointers are an; efficient way to share data between classes. However, a direct pointer; creates a direct coupling between classes. This design can become a very; tangled web of dependencies in a system with a large number of classes. ![](pictures/020000E2.jpg). In the second diagram, a reference to the data is in the folder and the; consumers refer to the folder rather than each other to access the data.; The naming and search service provided by the ROOT folders hierarchy; provides an alternative. It loosely couples the classes and greatly; enhances I/O operations. In this way, folders separate the data from the; algorithms and greatly improve the modularity of an application by; minimizing the class dependencies. ![](pictures/020000E3.jpg). In addition, the folder hierarchy creates a picture of the data; organization. This is useful when discussing data design issues or when; learning the data organization. The example below illustrates this; point. ## How to Use Folders. Using folders means to build a hierarchy of folders, posting the; reference to the data in the folder by the producer, and creating a; reference to the folder by the user. ### Creating a Folder",MatchSource.DOCS,documentation/users-guide/FoldersTasks.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FoldersTasks.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FoldersTasks.md:1952,Integrability,depend,dependencies,1952,"re is an example of a folder's path name:. `//root/Event/Hits/TCP`. One does not have to specify the full path name. If the partial path; name is unique, it will find it; otherwise it will return the first; occurrence of the path. The first diagram shows a system without folders. The objects have; pointers to each other to access each other's data. Pointers are an; efficient way to share data between classes. However, a direct pointer; creates a direct coupling between classes. This design can become a very; tangled web of dependencies in a system with a large number of classes. ![](pictures/020000E2.jpg). In the second diagram, a reference to the data is in the folder and the; consumers refer to the folder rather than each other to access the data.; The naming and search service provided by the ROOT folders hierarchy; provides an alternative. It loosely couples the classes and greatly; enhances I/O operations. In this way, folders separate the data from the; algorithms and greatly improve the modularity of an application by; minimizing the class dependencies. ![](pictures/020000E3.jpg). In addition, the folder hierarchy creates a picture of the data; organization. This is useful when discussing data design issues or when; learning the data organization. The example below illustrates this; point. ## How to Use Folders. Using folders means to build a hierarchy of folders, posting the; reference to the data in the folder by the producer, and creating a; reference to the folder by the user. ### Creating a Folder Hierarchy. To create a folder hierarchy you add the top folder of your hierarchy to; `//root`. Then you add a folder to an existing folder with the; **`TFolder::AddFolder`** method. This method takes two parameters: the; name and title of the folder to be added. It returns a pointer of the; newly created folder. The code below creates the folder hierarchy shown in the browser. In; this macro, the folder is also added to the list of browsable. This way,; it is v",MatchSource.DOCS,documentation/users-guide/FoldersTasks.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FoldersTasks.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FoldersTasks.md:3492,Integrability,depend,dependent,3492,"y you add the top folder of your hierarchy to; `//root`. Then you add a folder to an existing folder with the; **`TFolder::AddFolder`** method. This method takes two parameters: the; name and title of the folder to be added. It returns a pointer of the; newly created folder. The code below creates the folder hierarchy shown in the browser. In; this macro, the folder is also added to the list of browsable. This way,; it is visible in the browser on the top level. ``` {.cpp}; {; // Add the top folder of my hierary to //root; TFolder *aliroot=gROOT->GetRootFolder()->AddFolder(""aliroot"",; ""aliroot top level folders"");; // Add the hierarchy to the list of browsables; gROOT->GetListOfBrowsables()->Add(aliroot,""aliroot"");. // Create and add the constants folder; TFolder *constants=aliroot->AddFolder(""Constants"",; ""Detector constants"");. // Create and add the pdg folder to pdg; TFolder *pdg = constants->AddFolder(""DatabasePDG"",""PDG database"");. // Create and add the run folder; TFolder *run = aliroot->AddFolder(""Run"",""Run dependent folders"");. // Create and add the configuration folder to run; TFolder *configuration = run->AddFolder(""Configuration"",; ""Run configuration"");. // Create and add the run_mc folder; TFolder *run_mc = aliroot->AddFolder(""RunMC"",; ""MonteCarlo run dependent folders"");. // Create and add the configuration_mc folder to run_mc; TFolder *configuration_mc = run_mc->AddFolder(""Configuration"",; ""MonteCarlo run configuration"");; }; ```. ### Posting Data to a Folder (Producer). ![](pictures/030000E4.png). A **`TFolder`** can contain other folders as shown above or any; **`TObject`** descendents. In general, users will not post a single; object to a folder; they will store a collection or multiple collections; in a folder. For example, to add an array to a folder:. ``` {.cpp}; TObjArray *array;; run_mc->Add(array);; ```. ### Reading Data from a Folder (Consumer). One can search for a folder or an object in a folder using the; `TROOT::FindObjectAny` method. It a",MatchSource.DOCS,documentation/users-guide/FoldersTasks.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FoldersTasks.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FoldersTasks.md:3746,Integrability,depend,dependent,3746,"r of the; newly created folder. The code below creates the folder hierarchy shown in the browser. In; this macro, the folder is also added to the list of browsable. This way,; it is visible in the browser on the top level. ``` {.cpp}; {; // Add the top folder of my hierary to //root; TFolder *aliroot=gROOT->GetRootFolder()->AddFolder(""aliroot"",; ""aliroot top level folders"");; // Add the hierarchy to the list of browsables; gROOT->GetListOfBrowsables()->Add(aliroot,""aliroot"");. // Create and add the constants folder; TFolder *constants=aliroot->AddFolder(""Constants"",; ""Detector constants"");. // Create and add the pdg folder to pdg; TFolder *pdg = constants->AddFolder(""DatabasePDG"",""PDG database"");. // Create and add the run folder; TFolder *run = aliroot->AddFolder(""Run"",""Run dependent folders"");. // Create and add the configuration folder to run; TFolder *configuration = run->AddFolder(""Configuration"",; ""Run configuration"");. // Create and add the run_mc folder; TFolder *run_mc = aliroot->AddFolder(""RunMC"",; ""MonteCarlo run dependent folders"");. // Create and add the configuration_mc folder to run_mc; TFolder *configuration_mc = run_mc->AddFolder(""Configuration"",; ""MonteCarlo run configuration"");; }; ```. ### Posting Data to a Folder (Producer). ![](pictures/030000E4.png). A **`TFolder`** can contain other folders as shown above or any; **`TObject`** descendents. In general, users will not post a single; object to a folder; they will store a collection or multiple collections; in a folder. For example, to add an array to a folder:. ``` {.cpp}; TObjArray *array;; run_mc->Add(array);; ```. ### Reading Data from a Folder (Consumer). One can search for a folder or an object in a folder using the; `TROOT::FindObjectAny` method. It analyzes the string passed as its; argument and searches in the hierarchy until it finds an object or; folder matching the name. With `FindObjectAny`, you can give the full; path name, or the name of the folder. If only the name of the folder i",MatchSource.DOCS,documentation/users-guide/FoldersTasks.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FoldersTasks.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FoldersTasks.md:1346,Modifiability,coupling,coupling,1346,"the left panel in the browser. The browser shows several; folders under `//root`. New folders can be added and removed to/from a folder. ## Why Use Folders?. One reason to use folders is to reduce class dependencies and improve; modularity. Each set of data has a producer class and one or many; consumer classes. When using folders, the producer class places a; pointer to the data into a folder, and the consumer class retrieves a; reference to the folder. The consumer can access the objects in a folder by specifying the path; name of the folder. Here is an example of a folder's path name:. `//root/Event/Hits/TCP`. One does not have to specify the full path name. If the partial path; name is unique, it will find it; otherwise it will return the first; occurrence of the path. The first diagram shows a system without folders. The objects have; pointers to each other to access each other's data. Pointers are an; efficient way to share data between classes. However, a direct pointer; creates a direct coupling between classes. This design can become a very; tangled web of dependencies in a system with a large number of classes. ![](pictures/020000E2.jpg). In the second diagram, a reference to the data is in the folder and the; consumers refer to the folder rather than each other to access the data.; The naming and search service provided by the ROOT folders hierarchy; provides an alternative. It loosely couples the classes and greatly; enhances I/O operations. In this way, folders separate the data from the; algorithms and greatly improve the modularity of an application by; minimizing the class dependencies. ![](pictures/020000E3.jpg). In addition, the folder hierarchy creates a picture of the data; organization. This is useful when discussing data design issues or when; learning the data organization. The example below illustrates this; point. ## How to Use Folders. Using folders means to build a hierarchy of folders, posting the; reference to the data in the folder by t",MatchSource.DOCS,documentation/users-guide/FoldersTasks.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FoldersTasks.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FoldersTasks.md:1789,Modifiability,enhance,enhances,1789,"e to the folder. The consumer can access the objects in a folder by specifying the path; name of the folder. Here is an example of a folder's path name:. `//root/Event/Hits/TCP`. One does not have to specify the full path name. If the partial path; name is unique, it will find it; otherwise it will return the first; occurrence of the path. The first diagram shows a system without folders. The objects have; pointers to each other to access each other's data. Pointers are an; efficient way to share data between classes. However, a direct pointer; creates a direct coupling between classes. This design can become a very; tangled web of dependencies in a system with a large number of classes. ![](pictures/020000E2.jpg). In the second diagram, a reference to the data is in the folder and the; consumers refer to the folder rather than each other to access the data.; The naming and search service provided by the ROOT folders hierarchy; provides an alternative. It loosely couples the classes and greatly; enhances I/O operations. In this way, folders separate the data from the; algorithms and greatly improve the modularity of an application by; minimizing the class dependencies. ![](pictures/020000E3.jpg). In addition, the folder hierarchy creates a picture of the data; organization. This is useful when discussing data design issues or when; learning the data organization. The example below illustrates this; point. ## How to Use Folders. Using folders means to build a hierarchy of folders, posting the; reference to the data in the folder by the producer, and creating a; reference to the folder by the user. ### Creating a Folder Hierarchy. To create a folder hierarchy you add the top folder of your hierarchy to; `//root`. Then you add a folder to an existing folder with the; **`TFolder::AddFolder`** method. This method takes two parameters: the; name and title of the folder to be added. It returns a pointer of the; newly created folder. The code below creates the folder hierarc",MatchSource.DOCS,documentation/users-guide/FoldersTasks.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FoldersTasks.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FoldersTasks.md:3536,Modifiability,config,configuration,3536,"lder::AddFolder`** method. This method takes two parameters: the; name and title of the folder to be added. It returns a pointer of the; newly created folder. The code below creates the folder hierarchy shown in the browser. In; this macro, the folder is also added to the list of browsable. This way,; it is visible in the browser on the top level. ``` {.cpp}; {; // Add the top folder of my hierary to //root; TFolder *aliroot=gROOT->GetRootFolder()->AddFolder(""aliroot"",; ""aliroot top level folders"");; // Add the hierarchy to the list of browsables; gROOT->GetListOfBrowsables()->Add(aliroot,""aliroot"");. // Create and add the constants folder; TFolder *constants=aliroot->AddFolder(""Constants"",; ""Detector constants"");. // Create and add the pdg folder to pdg; TFolder *pdg = constants->AddFolder(""DatabasePDG"",""PDG database"");. // Create and add the run folder; TFolder *run = aliroot->AddFolder(""Run"",""Run dependent folders"");. // Create and add the configuration folder to run; TFolder *configuration = run->AddFolder(""Configuration"",; ""Run configuration"");. // Create and add the run_mc folder; TFolder *run_mc = aliroot->AddFolder(""RunMC"",; ""MonteCarlo run dependent folders"");. // Create and add the configuration_mc folder to run_mc; TFolder *configuration_mc = run_mc->AddFolder(""Configuration"",; ""MonteCarlo run configuration"");; }; ```. ### Posting Data to a Folder (Producer). ![](pictures/030000E4.png). A **`TFolder`** can contain other folders as shown above or any; **`TObject`** descendents. In general, users will not post a single; object to a folder; they will store a collection or multiple collections; in a folder. For example, to add an array to a folder:. ``` {.cpp}; TObjArray *array;; run_mc->Add(array);; ```. ### Reading Data from a Folder (Consumer). One can search for a folder or an object in a folder using the; `TROOT::FindObjectAny` method. It analyzes the string passed as its; argument and searches in the hierarchy until it finds an object or; folder matchin",MatchSource.DOCS,documentation/users-guide/FoldersTasks.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FoldersTasks.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FoldersTasks.md:3574,Modifiability,config,configuration,3574,"lder::AddFolder`** method. This method takes two parameters: the; name and title of the folder to be added. It returns a pointer of the; newly created folder. The code below creates the folder hierarchy shown in the browser. In; this macro, the folder is also added to the list of browsable. This way,; it is visible in the browser on the top level. ``` {.cpp}; {; // Add the top folder of my hierary to //root; TFolder *aliroot=gROOT->GetRootFolder()->AddFolder(""aliroot"",; ""aliroot top level folders"");; // Add the hierarchy to the list of browsables; gROOT->GetListOfBrowsables()->Add(aliroot,""aliroot"");. // Create and add the constants folder; TFolder *constants=aliroot->AddFolder(""Constants"",; ""Detector constants"");. // Create and add the pdg folder to pdg; TFolder *pdg = constants->AddFolder(""DatabasePDG"",""PDG database"");. // Create and add the run folder; TFolder *run = aliroot->AddFolder(""Run"",""Run dependent folders"");. // Create and add the configuration folder to run; TFolder *configuration = run->AddFolder(""Configuration"",; ""Run configuration"");. // Create and add the run_mc folder; TFolder *run_mc = aliroot->AddFolder(""RunMC"",; ""MonteCarlo run dependent folders"");. // Create and add the configuration_mc folder to run_mc; TFolder *configuration_mc = run_mc->AddFolder(""Configuration"",; ""MonteCarlo run configuration"");; }; ```. ### Posting Data to a Folder (Producer). ![](pictures/030000E4.png). A **`TFolder`** can contain other folders as shown above or any; **`TObject`** descendents. In general, users will not post a single; object to a folder; they will store a collection or multiple collections; in a folder. For example, to add an array to a folder:. ``` {.cpp}; TObjArray *array;; run_mc->Add(array);; ```. ### Reading Data from a Folder (Consumer). One can search for a folder or an object in a folder using the; `TROOT::FindObjectAny` method. It analyzes the string passed as its; argument and searches in the hierarchy until it finds an object or; folder matchin",MatchSource.DOCS,documentation/users-guide/FoldersTasks.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FoldersTasks.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FoldersTasks.md:3628,Modifiability,config,configuration,3628,"lder::AddFolder`** method. This method takes two parameters: the; name and title of the folder to be added. It returns a pointer of the; newly created folder. The code below creates the folder hierarchy shown in the browser. In; this macro, the folder is also added to the list of browsable. This way,; it is visible in the browser on the top level. ``` {.cpp}; {; // Add the top folder of my hierary to //root; TFolder *aliroot=gROOT->GetRootFolder()->AddFolder(""aliroot"",; ""aliroot top level folders"");; // Add the hierarchy to the list of browsables; gROOT->GetListOfBrowsables()->Add(aliroot,""aliroot"");. // Create and add the constants folder; TFolder *constants=aliroot->AddFolder(""Constants"",; ""Detector constants"");. // Create and add the pdg folder to pdg; TFolder *pdg = constants->AddFolder(""DatabasePDG"",""PDG database"");. // Create and add the run folder; TFolder *run = aliroot->AddFolder(""Run"",""Run dependent folders"");. // Create and add the configuration folder to run; TFolder *configuration = run->AddFolder(""Configuration"",; ""Run configuration"");. // Create and add the run_mc folder; TFolder *run_mc = aliroot->AddFolder(""RunMC"",; ""MonteCarlo run dependent folders"");. // Create and add the configuration_mc folder to run_mc; TFolder *configuration_mc = run_mc->AddFolder(""Configuration"",; ""MonteCarlo run configuration"");; }; ```. ### Posting Data to a Folder (Producer). ![](pictures/030000E4.png). A **`TFolder`** can contain other folders as shown above or any; **`TObject`** descendents. In general, users will not post a single; object to a folder; they will store a collection or multiple collections; in a folder. For example, to add an array to a folder:. ``` {.cpp}; TObjArray *array;; run_mc->Add(array);; ```. ### Reading Data from a Folder (Consumer). One can search for a folder or an object in a folder using the; `TROOT::FindObjectAny` method. It analyzes the string passed as its; argument and searches in the hierarchy until it finds an object or; folder matchin",MatchSource.DOCS,documentation/users-guide/FoldersTasks.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FoldersTasks.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FoldersTasks.md:3905,Modifiability,config,configuration,3905,"the list of browsable. This way,; it is visible in the browser on the top level. ``` {.cpp}; {; // Add the top folder of my hierary to //root; TFolder *aliroot=gROOT->GetRootFolder()->AddFolder(""aliroot"",; ""aliroot top level folders"");; // Add the hierarchy to the list of browsables; gROOT->GetListOfBrowsables()->Add(aliroot,""aliroot"");. // Create and add the constants folder; TFolder *constants=aliroot->AddFolder(""Constants"",; ""Detector constants"");. // Create and add the pdg folder to pdg; TFolder *pdg = constants->AddFolder(""DatabasePDG"",""PDG database"");. // Create and add the run folder; TFolder *run = aliroot->AddFolder(""Run"",""Run dependent folders"");. // Create and add the configuration folder to run; TFolder *configuration = run->AddFolder(""Configuration"",; ""Run configuration"");. // Create and add the run_mc folder; TFolder *run_mc = aliroot->AddFolder(""RunMC"",; ""MonteCarlo run dependent folders"");. // Create and add the configuration_mc folder to run_mc; TFolder *configuration_mc = run_mc->AddFolder(""Configuration"",; ""MonteCarlo run configuration"");; }; ```. ### Posting Data to a Folder (Producer). ![](pictures/030000E4.png). A **`TFolder`** can contain other folders as shown above or any; **`TObject`** descendents. In general, users will not post a single; object to a folder; they will store a collection or multiple collections; in a folder. For example, to add an array to a folder:. ``` {.cpp}; TObjArray *array;; run_mc->Add(array);; ```. ### Reading Data from a Folder (Consumer). One can search for a folder or an object in a folder using the; `TROOT::FindObjectAny` method. It analyzes the string passed as its; argument and searches in the hierarchy until it finds an object or; folder matching the name. With `FindObjectAny`, you can give the full; path name, or the name of the folder. If only the name of the folder is; given, it will return the first instance of that name. A string-based; search is time consuming. If the retrieved object is used frequently ",MatchSource.DOCS,documentation/users-guide/FoldersTasks.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FoldersTasks.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FoldersTasks.md:9545,Performance,load,loads,9545,"ation"");; TTask *tracker = new MyTracker(""tracker"",""Tracker manager"");; TTask *tpc = new MyRecTPC(""tpc"",""TPC Reconstruction"");; TTask *its = new MyRecITS(""its"",""ITS Reconstruction"");; TTask *muon = new MyRecMUON(""muon"",""MUON Reconstruction"");; TTask *phos = new MyRecPHOS(""phos"",""PHOS Reconstruction"");; TTask *rich = new MyRecRICH(""rich"",""RICH Reconstruction"");; TTask *trd = new MyRecTRD(""trd"",""TRD Reconstruction"");; TTask *global = new MyRecGlobal(""global"",""Global Reconstruction"");. // Create a hierarchy by adding sub tasks; run->Add(geomInit);; run->Add(matInit);; run->Add(event);; event->Add(tracker);; event->Add(global);; tracker->Add(tpc);; tracker->Add(its);; tracker->Add(muon);; tracker->Add(phos);; tracker->Add(rich);; tracker->Add(trd);. // Add the top level task; gROOT->GetListOfTasks()->Add(run);. // Add the task to the browser; gROOT->GetListOfBrowsables()->Add(run);; new TBrowser;; }; ```. ![Tasks in the ROOT browser](pictures/030000E5.png). Note that the first line loads the class definitions in `MyTasks.cxx`; with ACLiC. ACLiC builds a shared library and adds the classes to the; Cling dictionary. See ""Adding a Class with ACLiC"". To execute a **`TTask`**, you call the `ExecuteTask` method.; `ExecuteTask` will recursively call:. - the `TTask::Exec `method of the derived class;. - the `TTask::ExecuteTasks` to execute for each task the list of its; subtasks;. If the top level task is added to the list of ROOT browsable objects,; the tree of tasks can be seen in the ROOT browser. To add it to the; browser, get the list of browsable objects first and add it to the; collection. ``` {.cpp}; gROOT->GetListOfBrowsables()->Add(run);; ```. The first parameter of the `Add` method is a pointer to a **`TTask`**,; the second parameter is the string to show in the browser. If the string; is left out, the name of the task is used. After executing, the script above the browser will look like in this; figure. ## Execute and Debug Tasks. The browser can be used to start a ",MatchSource.DOCS,documentation/users-guide/FoldersTasks.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FoldersTasks.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FoldersTasks.md:812,Security,access,access,812,"# Folders and Tasks. ## Folders. ![](pictures/030000E1.png). A **`TFolder`** is a collection of objects; visible and expandable in the ROOT object browser. Folders have a name; and a title and are identified in the folder hierarchy by an ""UNIX-like""; naming convention. The base of all folders is `//root`. It is visible at; the top of the left panel in the browser. The browser shows several; folders under `//root`. New folders can be added and removed to/from a folder. ## Why Use Folders?. One reason to use folders is to reduce class dependencies and improve; modularity. Each set of data has a producer class and one or many; consumer classes. When using folders, the producer class places a; pointer to the data into a folder, and the consumer class retrieves a; reference to the folder. The consumer can access the objects in a folder by specifying the path; name of the folder. Here is an example of a folder's path name:. `//root/Event/Hits/TCP`. One does not have to specify the full path name. If the partial path; name is unique, it will find it; otherwise it will return the first; occurrence of the path. The first diagram shows a system without folders. The objects have; pointers to each other to access each other's data. Pointers are an; efficient way to share data between classes. However, a direct pointer; creates a direct coupling between classes. This design can become a very; tangled web of dependencies in a system with a large number of classes. ![](pictures/020000E2.jpg). In the second diagram, a reference to the data is in the folder and the; consumers refer to the folder rather than each other to access the data.; The naming and search service provided by the ROOT folders hierarchy; provides an alternative. It loosely couples the classes and greatly; enhances I/O operations. In this way, folders separate the data from the; algorithms and greatly improve the modularity of an application by; minimizing the class dependencies. ![](pictures/020000E3.jpg). In addi",MatchSource.DOCS,documentation/users-guide/FoldersTasks.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FoldersTasks.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FoldersTasks.md:1214,Security,access,access,1214,"ied in the folder hierarchy by an ""UNIX-like""; naming convention. The base of all folders is `//root`. It is visible at; the top of the left panel in the browser. The browser shows several; folders under `//root`. New folders can be added and removed to/from a folder. ## Why Use Folders?. One reason to use folders is to reduce class dependencies and improve; modularity. Each set of data has a producer class and one or many; consumer classes. When using folders, the producer class places a; pointer to the data into a folder, and the consumer class retrieves a; reference to the folder. The consumer can access the objects in a folder by specifying the path; name of the folder. Here is an example of a folder's path name:. `//root/Event/Hits/TCP`. One does not have to specify the full path name. If the partial path; name is unique, it will find it; otherwise it will return the first; occurrence of the path. The first diagram shows a system without folders. The objects have; pointers to each other to access each other's data. Pointers are an; efficient way to share data between classes. However, a direct pointer; creates a direct coupling between classes. This design can become a very; tangled web of dependencies in a system with a large number of classes. ![](pictures/020000E2.jpg). In the second diagram, a reference to the data is in the folder and the; consumers refer to the folder rather than each other to access the data.; The naming and search service provided by the ROOT folders hierarchy; provides an alternative. It loosely couples the classes and greatly; enhances I/O operations. In this way, folders separate the data from the; algorithms and greatly improve the modularity of an application by; minimizing the class dependencies. ![](pictures/020000E3.jpg). In addition, the folder hierarchy creates a picture of the data; organization. This is useful when discussing data design issues or when; learning the data organization. The example below illustrates this; poin",MatchSource.DOCS,documentation/users-guide/FoldersTasks.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FoldersTasks.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FoldersTasks.md:1632,Security,access,access,1632,". Each set of data has a producer class and one or many; consumer classes. When using folders, the producer class places a; pointer to the data into a folder, and the consumer class retrieves a; reference to the folder. The consumer can access the objects in a folder by specifying the path; name of the folder. Here is an example of a folder's path name:. `//root/Event/Hits/TCP`. One does not have to specify the full path name. If the partial path; name is unique, it will find it; otherwise it will return the first; occurrence of the path. The first diagram shows a system without folders. The objects have; pointers to each other to access each other's data. Pointers are an; efficient way to share data between classes. However, a direct pointer; creates a direct coupling between classes. This design can become a very; tangled web of dependencies in a system with a large number of classes. ![](pictures/020000E2.jpg). In the second diagram, a reference to the data is in the folder and the; consumers refer to the folder rather than each other to access the data.; The naming and search service provided by the ROOT folders hierarchy; provides an alternative. It loosely couples the classes and greatly; enhances I/O operations. In this way, folders separate the data from the; algorithms and greatly improve the modularity of an application by; minimizing the class dependencies. ![](pictures/020000E3.jpg). In addition, the folder hierarchy creates a picture of the data; organization. This is useful when discussing data design issues or when; learning the data organization. The example below illustrates this; point. ## How to Use Folders. Using folders means to build a hierarchy of folders, posting the; reference to the data in the folder by the producer, and creating a; reference to the folder by the user. ### Creating a Folder Hierarchy. To create a folder hierarchy you add the top folder of your hierarchy to; `//root`. Then you add a folder to an existing folder with the; **",MatchSource.DOCS,documentation/users-guide/FoldersTasks.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FoldersTasks.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FoldersTasks.md:2132,Usability,learn,learning,2132,"h. The first diagram shows a system without folders. The objects have; pointers to each other to access each other's data. Pointers are an; efficient way to share data between classes. However, a direct pointer; creates a direct coupling between classes. This design can become a very; tangled web of dependencies in a system with a large number of classes. ![](pictures/020000E2.jpg). In the second diagram, a reference to the data is in the folder and the; consumers refer to the folder rather than each other to access the data.; The naming and search service provided by the ROOT folders hierarchy; provides an alternative. It loosely couples the classes and greatly; enhances I/O operations. In this way, folders separate the data from the; algorithms and greatly improve the modularity of an application by; minimizing the class dependencies. ![](pictures/020000E3.jpg). In addition, the folder hierarchy creates a picture of the data; organization. This is useful when discussing data design issues or when; learning the data organization. The example below illustrates this; point. ## How to Use Folders. Using folders means to build a hierarchy of folders, posting the; reference to the data in the folder by the producer, and creating a; reference to the folder by the user. ### Creating a Folder Hierarchy. To create a folder hierarchy you add the top folder of your hierarchy to; `//root`. Then you add a folder to an existing folder with the; **`TFolder::AddFolder`** method. This method takes two parameters: the; name and title of the folder to be added. It returns a pointer of the; newly created folder. The code below creates the folder hierarchy shown in the browser. In; this macro, the folder is also added to the list of browsable. This way,; it is visible in the browser on the top level. ``` {.cpp}; {; // Add the top folder of my hierary to //root; TFolder *aliroot=gROOT->GetRootFolder()->AddFolder(""aliroot"",; ""aliroot top level folders"");; // Add the hierarchy to the list ",MatchSource.DOCS,documentation/users-guide/FoldersTasks.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FoldersTasks.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FoldersTasks.md:10773,Usability,resume,resumed,10773,"on"");. // Create a hierarchy by adding sub tasks; run->Add(geomInit);; run->Add(matInit);; run->Add(event);; event->Add(tracker);; event->Add(global);; tracker->Add(tpc);; tracker->Add(its);; tracker->Add(muon);; tracker->Add(phos);; tracker->Add(rich);; tracker->Add(trd);. // Add the top level task; gROOT->GetListOfTasks()->Add(run);. // Add the task to the browser; gROOT->GetListOfBrowsables()->Add(run);; new TBrowser;; }; ```. ![Tasks in the ROOT browser](pictures/030000E5.png). Note that the first line loads the class definitions in `MyTasks.cxx`; with ACLiC. ACLiC builds a shared library and adds the classes to the; Cling dictionary. See ""Adding a Class with ACLiC"". To execute a **`TTask`**, you call the `ExecuteTask` method.; `ExecuteTask` will recursively call:. - the `TTask::Exec `method of the derived class;. - the `TTask::ExecuteTasks` to execute for each task the list of its; subtasks;. If the top level task is added to the list of ROOT browsable objects,; the tree of tasks can be seen in the ROOT browser. To add it to the; browser, get the list of browsable objects first and add it to the; collection. ``` {.cpp}; gROOT->GetListOfBrowsables()->Add(run);; ```. The first parameter of the `Add` method is a pointer to a **`TTask`**,; the second parameter is the string to show in the browser. If the string; is left out, the name of the task is used. After executing, the script above the browser will look like in this; figure. ## Execute and Debug Tasks. The browser can be used to start a task, set break points at the; beginning of a task or when the task has completed. At a breakpoint,; data structures generated by the execution up this point may be; inspected asynchronously and then the execution can be resumed by; selecting the ""`Continue`"" function of a task. A task may be active or inactive (controlled by `TTask::SetActive`).; When a task is inactive, its sub tasks are not executed. A task tree may; be made persistent, saving the status of all the tasks.; ",MatchSource.DOCS,documentation/users-guide/FoldersTasks.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FoldersTasks.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:8971,Availability,avail,available,8971,"creation of a hierarchical link between two volumes. As it will be; described further on in this document, there are few other methods; performing similar actions, but let us keep things simple for the time; being. In addition, notice that there are some visualization-related; calls in the example followed by a final `TGeoVolume::Draw() `call for; the top volume. These are explained in details in the section; ""Visualization Settings and Attributes"". At this point, you will; probably like to see how this geometry looks like. You just need to run; the example and you will get the following picture that you can rotate; using the mouse; or you can zoom / move it around (see what the Help; menu of the GL window displays). ``` {.cpp}; % root rootgeom.C; ```. ![](pictures/020001B1.jpg). Now let us browse the hierarchy that was just created. Start a browser; and double-click on the item simple1 representing the; ***`gGeoManager`*** object. Note that right click opens the context menu; of the manager class where several global methods are available. ``` {.cpp}; root[] new TBrowser;; ```. ![](pictures/020001B2.jpg). The folders `Materials`, `Media` and `Local transformations` are in fact; the containers where the geometry manager stores the corresponding; objects. The `Illegal overlaps` folder is empty but can be filled after; performing a geometry validity check (see section: ""Checking the; Geometry""). If tracking is performed using **`TGeo`**, the folder; `Tracks` might contain user-defined tracks that can be; visualized/animated in the geometry context (see section: ""Creating and; Visualizing Tracks""). Since for the time being we are interested more in; the geometrical hierarchy, we will focus on the last two displayed items; `TOP `and `TOP_1`. These are the top volume and the corresponding top; node in the hierarchy. Double clicking on the `TOP` volume will unfold all different volumes; contained by the top volume. In the right panel, we will see all the; volumes contained",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:43055,Availability,down,down,43055,"Boolean operations that; result in non-infinite composite shapes (see also ""Composite Shapes""; below). A half space has to be defined using the constructor:. ``` {.cpp}; TGeoHalfSpace (const char *name, Double_t *point[3],; Double_t *norm[3]);; ```. ### Composite Shapes. Composite shapes are Boolean combinations of two or more shape; components. The supported Boolean operations are union (+), intersection; (\*) and subtraction(-). Composite shapes derive from the base; **`TGeoShape`** class, therefore providing all shape features:; computation of bounding box, finding if a given point is inside or; outside the combination, as well as computing the distance to; entering/exiting. They can be directly used for creating volumes or used; in the definition of other composite shapes. Composite shapes are provided in order to complement and extend the set; of basic shape primitives. They have a binary tree internal structure,; therefore all shape-related geometry queries are signals propagated from; top level down to the final leaves, while the provided answers are; assembled and interpreted back at top. This `CSG`; `(composite solid geometry)` hierarchy is effective for small number of; components, while performance drops dramatically for large structures.; Building a complete geometry in this style is virtually possible but; highly not recommended. #### The Structure of Composite Shapes. A composite shape can always be looked as the result of a Boolean; operation between only two shape components. All information identifying; these two components as well as their positions with respect to the; frame of the composite is represented by an object called Boolean node.; A composite shape has a pointer to such a Boolean node. Since the shape; components may also be composites, they will also contain binary Boolean; nodes branching out other two shapes in the hierarchy. Any such branch; ends-up when the final leaves are no longer composite shapes, but basic; primitives. The figu",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:56257,Availability,error,error,56257,"f the corresponding class name; (e.g. ""`tubs`"" will match **`TGeoTubeSeg`**, ""`bbox`"" will match; **`TGeoBBox`**); - `nmed:` the medium number. This will create a special volume that will not be directly used in the; geometry, but whenever positioned will require a list of actual; parameters for the current shape that will be created in this process.; Such volumes having shape parameters known only when used have to be; positioned only with **`TGeoManager::Node()` method (see ‘Creating and; Positioning Volumes').**. Other case when shape parameterizations are quite useful is scaling; geometry structures. Imagine that we would like to enlarge/shrink a; detector structure on one or more axes. This happens quite often in real; life and is handled by ""fitting mother"" parameters. This is accomplished; by defining shapes with one or more invalid (negative) parameters. For; instance, defining a box having `dx=10.`, `dy=10.`, and `dz=-1` will not; generate an error but will be interpreted in a different way: A special; volume **`TGeoVolumeMulti`** will be created. Whenever positioned inside; a mother volume, this will create a normal **`TGeoVolume`** object; having as shape a box with `dz` fitting the corresponding `dz `of the; mother shape. Generally, this type of parameterization is used when; positioning volumes in containers having a matching shape, but it works; also for most reasonable combinations. ## Geometry Creation. A given geometry can be built in various ways, but one has to follow; some mandatory steps. Even if we might use some terms that will be; explained later, here are few general rules:. - Volumes need media and shapes in order to be created.; - Both containers and contained volumes must be created before linking; them together, and the relative transformation matrix must be; provided.; - Any volume have to be positioned somewhere otherwise it will not be; considered as part of the geometry.; - Visibility or tracking properties of volumes can be provided ",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:85481,Availability,error,error,85481," - `1, 2, 3 mean X, Y, Z; for `tube`, `tubs`, `cone`,; `cons - `1 means `Rxy`, 2 means `phi` and 3 means Z; for `pcon` and; `pgon` - 2 means `phi` and 3 means Z; for spheres 1 means `R `and 2; means `phi.`. In fact, the division operation has the same effect as positioning; volumes in a given order inside the divided container - the advantage; being that the navigation in such a structure is much faster. When a; volume is divided, a volume family corresponding to the slices is; created. In case all slices can be represented by a single shape, only; one volume is added to the family and positioned N times inside the; divided volume, otherwise, each slice will be represented by a distinct; volume in the family. Divisions can be also performed in a given range of one axis. For that,; one has to specify also the starting coordinate value and the step:. ``` {.cpp}; TGeoVolume *slicex = box->Divide(""SLICEX"",1,N,start,step);; ```. A check is always done on the resulting division range: if not fitting; into the container limits, an error message is posted. If we will browse; the divided volume we will notice that it will contain N nodes starting; with index 1 up to N. The first one has the lower X limit at `START`; position, while the last one will have the upper X limit at; `START+N*STEP`. The resulting slices cannot be positioned inside another; volume (they are by default positioned inside the divided one) but can; be further divided and may contain other volumes:. ``` {.cpp}; TGeoVolume *slicey = slicex->Divide(""SLICEY"",2,N1);; slicey->AddNode(other_vol,index,some_matrix);; ```. When doing that, we have to remember that `SLICEY` represents a family,; therefore all members of the family will be divided on Y and the other; volume will be added as node inside all. In the example above all the resulting slices had the same shape as the; divided volume (box). This is not always the case. For instance,; dividing a volume with `TUBE` shape on `PHI `axis will create equal; slice",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:98404,Availability,error,error,98404," added or subtracted. ``` {.cpp}; TGeoTranslation t1;; t1->SetTranslation(-5,10,4);; TGeoTranslation *t2 = new TGeoTranslation(4,3,10);; t2->Subtract(&t1);; ```. - Rotations (**`TGeoRotation`** class) represent a pure rotation. Data; members are `Double_t fRotationMatrix[3*3]`. Rotations can be; defined either by Euler angles, either, by GEANT3 angles:. ``` {.cpp}; TGeoRotation *r1 = new TGeoRotation();; r1->SetAngles(phi,theta,psi); // all angles in degrees; ```. This represents the composition of: first a rotation about Z axis with; angle phi, then a rotation with theta about the rotated X axis, and; finally a rotation with `psi `about the new Z axis. ``` {.cpp}; r1->SetAngles(th1,phi1,th2,phi2,th3,phi3); ```. This is a rotation defined in GEANT3 style. Theta and phi are the; spherical angles of each axis of the rotated coordinate system with; respect to the initial one. This construction allows definition of; malformed rotations, e.g. not orthogonal. A check is performed and an; error message is issued in this case. Specific utilities: determinant, inverse. - Scale transformations (**`TGeoScale`** class) - represent a scaled; shrinking/enlargement, possibly different on all axes. Data members:; `Double_t fScale[3]`. Not implemented yet.; - Combined transformations - represent a rotation followed by a; translation. Data members:; `Double_t fTranslation[3], `**`TGeoRotation *fRotation`.**. ``` {.cpp}; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;; ...; TGeoCombiTrans *c1 = new TGeoCombiTrans(trans,rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot); ```. - General transformations: (**`TGeoHMatrix`** class) represent; combined transformations in any order.; - Identity transformation: (**`TGeoIdentity`** class) is a generic; identity transformation represented by a singleton class object; **`gGeoIdentity`**. ### Ownership of Geometry Objects. The class **`TGeoManager`** class contains the entire API needed for; build",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:121375,Availability,avail,available,121375,"tep is limited by geometrical; reasons (a boundary crossing) or is an arbitrary step. The flag cross; can be used in case the step is made on a boundary and specifies if user; wants to cross or not the boundary. The returned node represents the new; current node after the step was made. - Making a geometrically contained step with boundary crossing; (`is_geom=kTRUE`, `cross=kTRUE`) - This is the default method; behavior. In this case, the step size is supposed to be already set; by a previous `TGeoManager::FindNextBoundary()` call. Due to; floating-point boundary uncertainties, making a step corresponding; `exactly` to the distance to next boundary does not insure boundary; crossing. If the method is called with this purpose, an extra small; step will be made in order to make the crossing the most probable; event (`epsil=10-6cm`). Even with this extra small step cannot; insure 100% boundary crossing for specific crossed shapes at big; incident angles. After such a step is made, additional cross-checks; become available:. ``` {.cpp}; gGeoManager->FindNextBoundary(pstep);; Double_t snext = gGeoManager->GetStep();; // The geometrical step is taken; TGeoNode *newNode = gGeoManager->Step();; // The step=snext+epsil is made; Bool_t hasCrossed = gGeoManager->IsEntering();; // Is the boundary crossed or not?; Bool_t isOnBoundary = gGeoManager->IsOnBoundary(); // The proposed; // geometrically limited step to be made was smaller; // than epsil value.; Bool_t isOutside = gGeoManager->IsOutside();; //Did we exit geometry ?; ```. In case the desired end-point of the step should be in the same starting; volume, the input flag `cross` should be set to `kFALSE`. In this case,; the `epsil` value will be subtracted from the current step. - Making a step of arbitrary value (`is_geom=kFALSE`, `cross=`no; matter). In this case, the step to be made can be either resulting; from a `next` computation, either set by hand:. ``` {.cpp}; gGeoManager->SetStep(stepvalue);; gGeoManager->Step(kFAL",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:123957,Availability,avail,available,123957,"he following convention: we define; as `normal` ($\vec{n}$) the unit vector perpendicular; to a surface in the `next crossing point`, having the orientation such; that: $\vec{n}.\vec{d}>0$. Here $\vec{d}$; represents the current direction. The next crossing point represents the; point where a ray shot from the current point along the current; direction crosses the surface. ``` {.cpp}; Double_t *TGeoManager::FindNormal(Bool_t forward=kTRUE);; ```. The method above computes the normal to the next crossed surface in; forward or backward direction (i.e. the current one), assuming the state; corresponding to a current arbitrary point is initialized. An example of; usage of normal computation is ray tracing. The two most important features of the geometrical modeller concerning; tracking are scalability and performance as function of the total number; of physical nodes. The first refers to the possibility to make use of; the available memory resources and at the same time be able to resolve; any geometrical query, while the second defines the capability of the; modeller to respond quickly even for huge geometries. These parameters; can become critical when simulating big experiments like those at LHC. ### Creating and Visualizing Tracks. In case the modeller is interfaced with a tracking engine, one might; consider quite useful being able to store and visualize at least a part; of the tracks in the context of the geometry. The base class; **`TVirtualGeoTrack`** provides this functionality. It currently has one; implementation inside the drawing package (**`TGeoTrack`** class). A; track can be defined like:. ``` {.cpp}; TVirtualGeoTrack(Int_t id,Int_t pdg,TVirtualGeoTrack *parent=0,; TObject *particle=0);; ```. Where: `id` is user-defined id of the track, `pdg` - `pdg` code,; `parent` - a pointer to parent track, `particle` - a pointer to an; arbitrary particle object (may be a **`TParticle`**). A track has a list of daughters that have to be filled using the; following met",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:132138,Availability,error,errors,132138,"e the same container. The owner of such regions; cannot be determined based on hierarchical considerations; therefore; they will be considered as belonging to the node from which the current; track is coming from. When coming from their container, the ownership is totally; unpredictable. Again, the ownership of overlapping regions highly; depends on the current track parameters. We must say that even the overlaps of type A) and B) are allowed in case; the corresponding nodes are created using; **`TGeoVolume`**`::AddNodeOverlap()` method. Navigation is performed in such; cases by giving priority to the non-overlapping nodes. The modeller has; to perform an additional search through the overlapping candidates.; These are detected automatically during the geometry closing procedure; in order to optimize the algorithm, but we will stress that extensive; usage of this feature leads to a drastic deterioration of performance.; In the following we will focus on the non-declared overlaps of type A); and B) since this is the main source of errors during tracking. These; are generally non-intended overlaps due to coding mistakes or bad; geometry design. The checking package is loaded together with the; painter classes and contains an automated overlap checker.**. ![Overlap checking](pictures/030001DF.png). This can be activated both at volume level (checking for illegal; overlaps only one level inside a given volume) and from the geometry; manager level (checking full geometry):. ``` {.cpp}; myVolume->CheckOverlaps(precision, option);; gGeoManager->CheckOverlaps(precision);; myNode->CheckOverlaps(precision);; ```. Here precision represents the desired maximum accepted overlap value in; centimeters (default value is 0.1). This tool checks all possible; significant pairs of candidates inside a given volume (not declared as; overlapping or division volumes). The check is performed by verifying; the mesh representation of one candidate against the shape of the other.; This sort of ",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:133257,Availability,reliab,reliability,133257," ![Overlap checking](pictures/030001DF.png). This can be activated both at volume level (checking for illegal; overlaps only one level inside a given volume) and from the geometry; manager level (checking full geometry):. ``` {.cpp}; myVolume->CheckOverlaps(precision, option);; gGeoManager->CheckOverlaps(precision);; myNode->CheckOverlaps(precision);; ```. Here precision represents the desired maximum accepted overlap value in; centimeters (default value is 0.1). This tool checks all possible; significant pairs of candidates inside a given volume (not declared as; overlapping or division volumes). The check is performed by verifying; the mesh representation of one candidate against the shape of the other.; This sort of check cannot identify all possible overlapping topologies,; but it works for more than 95% and is much faster than the usual; shape-to-shape comparison. For a 100% reliability, one can perform the; check at the level of a single volume by using `option`=""`d`"" or; `option`=""`d<number>`"" to perform overlap checking by sampling the; volume with \<`number`\> random points (default 1 million). This; produces also a picture showing in red the overlapping region and; estimates the volume of the overlaps. An extrusion A) is declared in any of the following cases:. - At least one of the vertices of the daughter mesh representation is; outside the mother volume (in fact its shape) and having a safety; distance to the mother greater than the desired value;; - At least one of the mother vertices is contained also by one of its; daughters, in the same conditions. An overlap B) is declared if:. - At least one vertex of a positioned volume mesh is contained (having; a safety bigger than the accepted maximum value) by other positioned; volume inside the same container. The check is performed also by; inverting the candidates. The code is highly optimized to avoid checking candidates that are far; away in space by performing a fast check on their bounding boxes. Once; ",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:135500,Availability,down,down,135500,"Illegal overlaps inside a **`TBrowser`**) held; by the manager class will be filled with **`TGeoOverlap`** objects; containing a full description of the detected overlaps. The list is; sorted in the decreasing order of the overlapping distance, extrusions; coming first. An overlap object name represents the full description of; the overlap, containing both candidate node names and a letter; (x-extrusion, o-overlap) representing the type. Double-clicking an; overlap item in a **`TBrowser`** produces a picture of the overlap; containing only the two overlapping nodes (one in blue and one in green); and having the critical vertices represented by red points. The picture; can be rotated/zoomed or drawn in X3d as any other view. Calling; `gGeoManager->PrintOverlaps()` prints the list of overlaps. ### Graphical Checking Methods. ![Safety computation checking](pictures/030001E0.png). In order to check a given point, `CheckPoint(x,y,z)` method of; **`TGeoManager`** draws the daughters of the volume containing the point; one level down, printing the path to the deepest physical node holding; this point. It also computes the closest distance to any boundary. ![Random points](pictures/030001E1.png). A method to check the validity of a given geometry is shooting random; points. This can be called with the method; **`TGeoVolume`**`::RandomPoints()` and it draws a volume with the current; visualization settings. Random points are generated in the bounding box; of the drawn volume. The points are drawn with the color of their; deepest container. Only points inside visible nodes are drawn. ![Random rays](pictures/030001E2.png). A ray tracing method can be called `TGeoVolume::RandomRays()`. This; shoots rays from a given point in the local reference frame with random; directions. The intersections with displayed nodes appear as segments; having the color of the touched node. ## The Drawing Package. ![](pictures/030001E3.png)The modeller provides a powerful drawing; package, supporti",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:136985,Availability,avail,available,136985,"t container. Only points inside visible nodes are drawn. ![Random rays](pictures/030001E2.png). A ray tracing method can be called `TGeoVolume::RandomRays()`. This; shoots rays from a given point in the local reference frame with random; directions. The intersections with displayed nodes appear as segments; having the color of the touched node. ## The Drawing Package. ![](pictures/030001E3.png)The modeller provides a powerful drawing; package, supporting several different options of visualization. A; library separated from the main one provides all functionality being; linked with the underlying ROOT visualization system. This library is; dynamically loaded by the plug-in manager only when drawing features are; requested. The geometrical structures that can be visualized are volumes; and volume hierarchies. The main component of the visualization system is volume primitive; painting in a ROOT pad. Starting from this one, several specific options; or subsystems are available, like: X3D viewing using hidden line and; surface removal algorithms, OpenGL viewing\* or ray tracing. The method `TGeoManager::GetGeomPainter()`loads the painting library in; memory. This is generally not needed since it is called automatically by; `TGeoVolume::Draw()` as well as by few other methods setting; visualization attributes. ### Drawing Volumes and Hierarchies of Volumes. The first thing one would like to do after building some geometry is to; visualize the volume tree. This provides the fastest validation check; for most common coding or design mistakes. As soon as the geometry is; successfully closed, one should draw it starting from the top-level; volume:. ``` {.cpp}; //... code for geometry building; root[] gGeoManager->CloseGeometry();; root[] gGeoManager->GetMasterVolume()->Draw();; ```. Doing this ensures that the original top-level volume of the geometry is; drawn, even if another volume is currently the geometry `root`. OK, I; suppose you already did that with your simple geome",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:138544,Availability,down,down,138544,"idation check; for most common coding or design mistakes. As soon as the geometry is; successfully closed, one should draw it starting from the top-level; volume:. ``` {.cpp}; //... code for geometry building; root[] gGeoManager->CloseGeometry();; root[] gGeoManager->GetMasterVolume()->Draw();; ```. Doing this ensures that the original top-level volume of the geometry is; drawn, even if another volume is currently the geometry `root`. OK, I; suppose you already did that with your simple geometry and immediately; noticed a new ROOT canvas popping-up and having some more or less; strange picture inside. Here are few questions that might come:. ***`Q:`*** ""The picture is strangely rotated; where are the coordinate axes?"". ***`A:`*** If drawn in a new canvas, any view has some default; viewpoint, center of view and size. One can then perform mouse/keyboard; actions to change them:. - Mouse left-click and drag will rotate the view;. - Some keys can be pressed when the view canvas is selected: J/K; zoom/un-zoom, U/I move up/down, L/H move left/right. The coordinate axes; display as well as changing top or side viewpoints can be activated from; the **`TView`** context menu: right-click on the picture when no object; is selected;. ***`Q:`*** ""Every line is black! I cannot figure out what is what..."". ***`A:`*** Volumes can have different colors (those known by ROOT of; course). Think at using them after each volume creation:; `myvolume->SetLineColor(Int_t color);` otherwise everything is by; default black. ***`Q:`*** ""The top volume of my geometry is a box but I see only its content."". ***`A:`*** By default the drawn volume is not displayed just because we; do not want to hide its content when changing the view to HLR or solid; mode. In order to see it in the default wire frame picture one has to; call **`TGeoManager::SetTopVisible()`.**. ***`Q:`*** ""I do not see all volumes in my tree but just something inside."". ***`A:`*** By default, **`TGeoVolume`**`::Draw()` paints the ",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:139551,Availability,down,down,139551," selected: J/K; zoom/un-zoom, U/I move up/down, L/H move left/right. The coordinate axes; display as well as changing top or side viewpoints can be activated from; the **`TView`** context menu: right-click on the picture when no object; is selected;. ***`Q:`*** ""Every line is black! I cannot figure out what is what..."". ***`A:`*** Volumes can have different colors (those known by ROOT of; course). Think at using them after each volume creation:; `myvolume->SetLineColor(Int_t color);` otherwise everything is by; default black. ***`Q:`*** ""The top volume of my geometry is a box but I see only its content."". ***`A:`*** By default the drawn volume is not displayed just because we; do not want to hide its content when changing the view to HLR or solid; mode. In order to see it in the default wire frame picture one has to; call **`TGeoManager::SetTopVisible()`.**. ***`Q:`*** ""I do not see all volumes in my tree but just something inside."". ***`A:`*** By default, **`TGeoVolume`**`::Draw()` paints the content of; a given volume three levels down. You can change this by using:; ***`gGeoManager`***`::SetVisLevel(n);`. Not only that, but none of the volumes at intermediate levels (0-2) are; visible on the drawing unless they are final ‘leaves' on their branch; (e.g. have no other volumes positioned inside). This behavior is the; default one and corresponds to ‘leaves' global visualization mode; (**`TGeoManager::fVisOption = 1`). In order to see on the screen the; intermediate containers, one can change this mode:; `gGeoManager->SetVisOption(0)`.**. ***`Q:`*** ""Volumes are highlighted when moving the mouse over their vertices. What does it mean?"". ***`A:`*** Indeed, moving the mouse close to some volume vertices; selects it. By checking the `Event Status` entry in the root canvas; `Options` menu, you will see exactly which is the selected node in the; bottom right. Right-clicking when a volume is selected will open its; context menu where several actions can be performed (e.g. d",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:140936,Availability,avail,available,140936,"alization mode; (**`TGeoManager::fVisOption = 1`). In order to see on the screen the; intermediate containers, one can change this mode:; `gGeoManager->SetVisOption(0)`.**. ***`Q:`*** ""Volumes are highlighted when moving the mouse over their vertices. What does it mean?"". ***`A:`*** Indeed, moving the mouse close to some volume vertices; selects it. By checking the `Event Status` entry in the root canvas; `Options` menu, you will see exactly which is the selected node in the; bottom right. Right-clicking when a volume is selected will open its; context menu where several actions can be performed (e.g. drawing it). ***`Q:`*** ""OK, but now I do not want to see all the geometry, but just a particular volume and its content. How can I do this?"". ***`A:`*** Once you have set a convenient global visualization option; and level, what you need is just call the `Draw()` method of your; interesting volume. You can do this either by interacting with the; expanded tree of volumes in a ROOT browser (where the context menu of; any volume is available), either by getting a pointer to it (e.g. by; name): `gGeoManager->GetVolume(""vol_name"")->Draw();`. ### Visualization Settings and Attributes. Supposing you now understand the basic things to do for drawing the; geometry or parts of it, you still might be not happy and wishing to; have more control on it. We will describe below how you can fine-tune some; settings. Since the corresponding attributes are flags belonging to; volume and node objects, you can change them at any time (even when the; picture is already drawn) and see immediately the result. #### Colors and Line Styles. We have already described how to change the line colors for volumes. In; fact, volume objects inherit from TAttLine class so the line style or; width can also be changed:. ``` {.cpp}; myVolume->SetLineColor(kRed);; myVolume->SetLineWith(2);; myVolume->SetLineStyle(kDotted);; ```. When drawing in solid mode, the color of the drawn volume corresponds to; the li",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:142447,Availability,down,down,142447," can change them at any time (even when the; picture is already drawn) and see immediately the result. #### Colors and Line Styles. We have already described how to change the line colors for volumes. In; fact, volume objects inherit from TAttLine class so the line style or; width can also be changed:. ``` {.cpp}; myVolume->SetLineColor(kRed);; myVolume->SetLineWith(2);; myVolume->SetLineStyle(kDotted);; ```. When drawing in solid mode, the color of the drawn volume corresponds to; the line color. #### Visibility Settings. The way geometry is build forces the definition of several volumes that; does not represent real objects, but just virtual containers used for; grouping and positioning volumes together. One would not want to see; them in the picture. Since every volume is by default visible, one has; to do this sort of tuning by its own:. ``` {.cpp}; myVolumeContainer->SetVisibility(kFALSE);; ```. As described before, the drawing package supports two main global; options: 1 (default) - only final volume leaves; 0 - all volumes down; the drawn one appear on the screen. The global visible level put a; limitation on the maximum applied depth. Combined with visibility; settings per volume, these can tune quite well what should appear on the; screen. However, there are situations when users want to see a volume; branch displayed down to the maximum depth, keeping at the same time a; limitation or even suppressing others. In order to accomplish that, one; should use the volume attribute: `Visible daughters`. By default, all; daughters of all volumes are displayed if there is no limitation related; with their level depth with respect to the top drawn volume. ### Ray Tracing. Ray tracing is a quite known drawing technique based on tracking rays; from the eye position through all pixels of a view port device. The; pixel color is derived from the properties of the first crossed surface,; according some illumination model and material optical properties. While; there are cu",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:142750,Availability,down,down,142750,"->SetLineWith(2);; myVolume->SetLineStyle(kDotted);; ```. When drawing in solid mode, the color of the drawn volume corresponds to; the line color. #### Visibility Settings. The way geometry is build forces the definition of several volumes that; does not represent real objects, but just virtual containers used for; grouping and positioning volumes together. One would not want to see; them in the picture. Since every volume is by default visible, one has; to do this sort of tuning by its own:. ``` {.cpp}; myVolumeContainer->SetVisibility(kFALSE);; ```. As described before, the drawing package supports two main global; options: 1 (default) - only final volume leaves; 0 - all volumes down; the drawn one appear on the screen. The global visible level put a; limitation on the maximum applied depth. Combined with visibility; settings per volume, these can tune quite well what should appear on the; screen. However, there are situations when users want to see a volume; branch displayed down to the maximum depth, keeping at the same time a; limitation or even suppressing others. In order to accomplish that, one; should use the volume attribute: `Visible daughters`. By default, all; daughters of all volumes are displayed if there is no limitation related; with their level depth with respect to the top drawn volume. ### Ray Tracing. Ray tracing is a quite known drawing technique based on tracking rays; from the eye position through all pixels of a view port device. The; pixel color is derived from the properties of the first crossed surface,; according some illumination model and material optical properties. While; there are currently existing quite sophisticated ray tracing models,; **`TGeo`** is currently using a very simple approach where the light; source is matching the eye position (no shadows or back-tracing of the; reflected ray). In future we are considering providing a base class in; order to be able to derive more complex models. Due to the fact that the number of ",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:157225,Availability,down,down,157225,"n our case let us suppose it is *B\_3*). Since a node is just a; positioned volume, we can then get a pointer to the volume, medium or; material objects related to it. *Deepest* means that *B\_3* still; contains point *P* (as well as *A\_1* and *TOP\_1*), but none of the; daughters of volume **B** does. After finding out the node containing; the particle, one can check if the geometry state is different compared; to the last located point:. ``` {.cpp}; Bool_t *TGeoManager::IsSameLocation(); ```. The algorithm for finding where a point is located in geometry is; presented in the figure 17-36. It always starts by checking if the last computed modeller state is the; answer. This optimizes the search when continuously tracking a particle.; The main actions performed are:. - moving up and down in the logical node tree while updating the; current node and its global matrix; - converting the global position into the local frame of the current; node/volume; - checking whether the local position lies within the geometrical; shape of the current volume - if this is the case continue the; search downwards for the daughters of the current node, otherwise; search upwards its containers until the top level is reached.; - the number of candidate nodes to be checked at a given level is; minimized by an additional optimization structure: voxels. This is; effective even in case there is only one daughter of the current; volume.; - in case the current node is declared as possibly overlapping, the; method FindInCluster() is invoked. This method checks all different; possibilities within the cluster of overlapping candidates. One of; the candidates is prioritized if one of the following conditions id; fulfilled (in order):; - Is declared as non-overlapping (these are anyway searched first); - Has at least one daughter that contains the current point; - Was already declared as containing the point at a previous step. ![Finding the location of a point in the geometry hierarchy](pictures/08",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:157532,Availability,down,downwards,157532,"n our case let us suppose it is *B\_3*). Since a node is just a; positioned volume, we can then get a pointer to the volume, medium or; material objects related to it. *Deepest* means that *B\_3* still; contains point *P* (as well as *A\_1* and *TOP\_1*), but none of the; daughters of volume **B** does. After finding out the node containing; the particle, one can check if the geometry state is different compared; to the last located point:. ``` {.cpp}; Bool_t *TGeoManager::IsSameLocation(); ```. The algorithm for finding where a point is located in geometry is; presented in the figure 17-36. It always starts by checking if the last computed modeller state is the; answer. This optimizes the search when continuously tracking a particle.; The main actions performed are:. - moving up and down in the logical node tree while updating the; current node and its global matrix; - converting the global position into the local frame of the current; node/volume; - checking whether the local position lies within the geometrical; shape of the current volume - if this is the case continue the; search downwards for the daughters of the current node, otherwise; search upwards its containers until the top level is reached.; - the number of candidate nodes to be checked at a given level is; minimized by an additional optimization structure: voxels. This is; effective even in case there is only one daughter of the current; volume.; - in case the current node is declared as possibly overlapping, the; method FindInCluster() is invoked. This method checks all different; possibilities within the cluster of overlapping candidates. One of; the candidates is prioritized if one of the following conditions id; fulfilled (in order):; - Is declared as non-overlapping (these are anyway searched first); - Has at least one daughter that contains the current point; - Was already declared as containing the point at a previous step. ![Finding the location of a point in the geometry hierarchy](pictures/08",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:173037,Availability,down,down,173037,"t parameters. This is the case for all shapes; (except composite shapes) and matrices. For all the other objects the; interface forces the selection of components before creating the object. ### Editing Volumes. Volumes are hierarchical components in the geometry, therefore their; editor is more complex. It provides the following functionalities:. - *General*. This category allows changing the name of the volume and; selecting other shape or medium among existing ones. - *Daughters*. The category allows removing existing daughter nodes or; adding new ones. The button ""*Position*"" allows editing the; positioning matrix of a given node. ![Setting volume properties and modifying volume hierarchy](pictures/020001F5.jpg); ![Setting volume properties and modifying volume hierarchy](pictures/020001F6.jpg). - *Visualization*. This category allows changing the visibility of the; edited volume or for its daughters, as well as other visualization; settings. The radio button ""*All*"" allows viewing all volumes down; to the selected depth. ""*Leaves*"" will draw only the deepest nodes; that have the selected depth or lower level ones that have no; daughters inside. ""*Only*"" will allow drawing only the edited; volume. The check button ""*Raytrace*"" will just draw the current; selection in solid mode using the ray-tracing algorithm provided by; TGeo. ![Volume visualisation settings and division interface for volumes](pictures/020001F7.jpg); ![Volume visualisation settings and division interface for volumes](pictures/020001F8.jpg). - *Division*. Allows dividing the edited volume according a given; pattern. The division axes that are allowed are presented in a; radio-button group. The number entries labeled ""*From*"", ""*Step*""; and ""*Nslices*"" correspond to the divisioning parameters on the; selected axis. The range of the division is between `start` and; `start+ndiv*step` values and its validity is checked upon changing; one of the values. NOTE: When changing a value in a number entry by",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:72138,Deployability,A/B,A/B,72138,"used by; navigation algorithms to optimize tracking. These must geometrically; contain their belongings (positioned volumes) so that these do not; extrude its shape boundaries. Not respecting this rule generally leads; to unpredictable results. Therefore `A` and `B` together must fit into; `C` that has to fit also into `D,E,` and `F`. This is not always; straightforward to accomplish, especially when instead of `A` and `B` we; have many more volumes. In order to avoid these problems, one can use for the difficult cases; the class **`TGeoVolumeAssembly`**, representing an assembly of volumes.; This behaves like a normal container volume supporting other volumes; positioned inside, but it has neither shape nor medium. It cannot be; used directly as a piece of the geometry, but just as a temporary; structure helping temporary assembling and positioning volumes. If we define now `C` as an assembly containing `A` and `B`, positioning; the assembly into `D,E` and `F` will actually position only `A` and; `B `directly into these volumes, taking into account their combined; transformations `A/B` to `C` and `C` to `D/E/F`. This looks much nicer,; is it? In fact, it is and it is not. Of course, we managed to get rid of; the ‘unnecessary' volume `C` in our geometry, but we end-up with a more; flat structure for `D,E` and `F` (more daughters inside). This can get; much worse when extensively used, as in the case: assemblies of; assemblies. For deciding what to choose between using virtual containers or; assemblies for a specific case, one can use for both cases, after the; geometry was closed:. ``` {.cpp}; gGeoManager->SetTopVolume(ptr_D);; gGeoManager->Test();; gGeoManager->RestoreMasterVolume();; ```. The `ptr_D` is a pointer to volume `D` containing the interesting; structure. The test will provide the timing for classifying 1 million; random points inside `D`. #### Examples of Volume Positioning. Now let us make a simple volume representing a copper wire. We suppose; that a ",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:128369,Deployability,update,updated,128369,"ep made by the current track, one is able to add control points; to either primary or secondary:. ``` {.cpp}; track->AddPoint(x,y,z,t);; ```. After tracks were defined and filled during tracking, one will be able; to browse directly the list of tracks held by the manager class. Any; track can be drawn using its `Draw()` and `Animate()` methods, but there; are also global methods for drawing or animation that can be accessed; from **`TGeoManager`** context menu:. ``` {.cpp}; TGeoManager::DrawTracks(Option_t *option);; TGeoManager::AnimateTracks(Double_t tmin=0.,Double_t tmax=1E-8,; Int_t nframes=200,Option_t *option="""");; ```. The drawing/animation time range is a global variable that can be; directly set:. ``` {.cpp}; gGeoManager->SetTminTmax(tmin, tmax);; // without arguments resets the time range to the maximum value; ```. Once set, the time range will be active both for individual or global; track drawing. For animation, this range is divided to the desired; number of frames and will be automatically updated at each frame in; order to get the animation effect. The option provided to all track-drawing methods can trigger different; track selections:. `default: `A track (or all primary tracks) drawn without daughters. `/D:` Track and first level descendents only are drawn. `/*: ` Track and all descendents are drawn. `/Ntype:` All tracks having `name=type` are drawn. Generally several options can be concatenated in the same string (E.g.; `""/D /Npion-""`). For animating tracks, additional options can be added:. `/G:`Geometry animate. Generally when drawing or animating tracks, one; has to first perform a normal drawing of the geometry as convenient. The; tracks will be drawn over the geometry. The geometry itself will be; animated (camera moving and rotating in order to ""catch"" the majority of; current track segments.). `/S:`Save all frames in gif format in the current folder. This option; allows creating a movie based on individual frames. ## Checking the Geometry. Se",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:153370,Deployability,update,update,153370," painter and checker objects are not written,; as well as the temporary current navigation properties: current node; path, point or direction. On the other hand, all objects belonging to; the geometrical hierarchy will always be written. The idea is to be able; to retrieve the geometry in a ready state, ignoring what the state; variables that can be always re-initialized. When the code is generated; for a given **`TGeoVolume`** in the geometry, just the branch starting; with that volume will be saved in the file. Executing the generated code; will create a geometry that has `MyVolume` as top volume. In this case,; only the materials/media/matrices used effectively in the `MyVolume`; branch are exported to file. Volumes can be made persistent in the same way the full geometry is.; Exporting is straightforward (module1, 2 are pointers to; **`TGeoVolume`** objects):. ``` {.cpp}; module1->Export(""file.root"");; // by default file is overwritten; module2->Export(""file.root"","""",""update"");; // to the same file; ```. Importing will append the volume to the current TGeoManager or will; create one:. ``` {.cpp}; TGeoManager *geom = new TGeoManager(""myGeom"", """");; TGeoVolume *top = geom->MakeBox(...);; geom->SetTopVolume(top);; //name of volume or key (depending on export usage); TGeoVolume *module1 = TGeoVolume::Import(""file.root"", ""MOD1"");; TGeoVolume *module2 = TGeoVolume::Import(""file.root"", ""MOD2"");; top->AddNode(module1, 1, new TGeoTranslation(0,0,100));; top->AddNode(module2, 1, new TGeoTranslation(0,0,-100));; // One should close oneself the geometry; geom->CloseGeometry();; ```. ### GDML. Few lines above word GDML was used. GDML stands for **G**eometry; **D**escription **M**arkup **L**anguage. It is an application-independent; geometry description format based on XML. It is mainly used for geometry; interchange between ROOT and Geant4 framework. More details about this; project can be found http://gdml.web.cern.ch. This feature; (importing/exporting from/to gdml file fo",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:154421,Deployability,install,installation,154421," // to the same file; ```. Importing will append the volume to the current TGeoManager or will; create one:. ``` {.cpp}; TGeoManager *geom = new TGeoManager(""myGeom"", """");; TGeoVolume *top = geom->MakeBox(...);; geom->SetTopVolume(top);; //name of volume or key (depending on export usage); TGeoVolume *module1 = TGeoVolume::Import(""file.root"", ""MOD1"");; TGeoVolume *module2 = TGeoVolume::Import(""file.root"", ""MOD2"");; top->AddNode(module1, 1, new TGeoTranslation(0,0,100));; top->AddNode(module2, 1, new TGeoTranslation(0,0,-100));; // One should close oneself the geometry; geom->CloseGeometry();; ```. ### GDML. Few lines above word GDML was used. GDML stands for **G**eometry; **D**escription **M**arkup **L**anguage. It is an application-independent; geometry description format based on XML. It is mainly used for geometry; interchange between ROOT and Geant4 framework. More details about this; project can be found http://gdml.web.cern.ch. This feature; (importing/exporting from/to gdml file format) is disabled by default in; ROOT installation. To enable this feature add `--enable-gdml` option to; `./configure` script call. ## Navigation Algorithms. This section will describe the main methods and algorithms used for; implementing the navigation features within the geometrical modeller.; This includes navigation queries at shape level, global geometrical; queries and optimization mechanisms. ### Finding the State Corresponding to a Location (x,y,z). For reminder, a geometry state is a ‘touchable' object in the geometry; hierarchy. It is represented by a path like: **/TOP\_1/A\_1/B\_3/C\_1**,; where **B\_3** for instance is a copy of volume **B** positioned inside; volume **A**. A state is always associated to a transformation matrix; **M** of the touchable with respect to the global reference frame; (obtained by piling-up all local transformations of nodes in the branch; with respect to their containers). The current state and the; corresponding global matrix are updated wh",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:155371,Deployability,update,updated,155371,"om/to gdml file format) is disabled by default in; ROOT installation. To enable this feature add `--enable-gdml` option to; `./configure` script call. ## Navigation Algorithms. This section will describe the main methods and algorithms used for; implementing the navigation features within the geometrical modeller.; This includes navigation queries at shape level, global geometrical; queries and optimization mechanisms. ### Finding the State Corresponding to a Location (x,y,z). For reminder, a geometry state is a ‘touchable' object in the geometry; hierarchy. It is represented by a path like: **/TOP\_1/A\_1/B\_3/C\_1**,; where **B\_3** for instance is a copy of volume **B** positioned inside; volume **A**. A state is always associated to a transformation matrix; **M** of the touchable with respect to the global reference frame; (obtained by piling-up all local transformations of nodes in the branch; with respect to their containers). The current state and the; corresponding global matrix are updated whenever the geometry depth is; modified. The global transformations corresponding to all nodes in the; current branch are kept in an array: (**MTOP\_1, MA\_1, MB\_3, ...**). ![Navigation in the geometry hierarchy](pictures/080001E6.png). The elementary operations for changing the state are:. ``` {.cpp}; TGeoManager::CdUp();; TGeoManager::CdDown(i);; TGeoManager::CdTop(); ```. The current state accounting and global matrix handling after these; operations are depicted in the figure below. Now let us suppose that we; have a particle at position *P(x,y,z)*. The first thing needed for; transporting it is the current object our particle is into, so that we; can retrieve its material properties. This task is done by:. ``` {.cpp}; TGeoNode *TGeoManager::FindNode(x,y,z); ```. Note that the current particle position can be set using; **`SetCurrentPosition(x,y,z)`** method of the manager class, in which; case **`FindNode()`** can be called without arguments. The method; returns a p",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:157141,Deployability,continuous,continuously,157141,"Node(x,y,z); ```. Note that the current particle position can be set using; **`SetCurrentPosition(x,y,z)`** method of the manager class, in which; case **`FindNode()`** can be called without arguments. The method; returns a pointer to the *deepest node* that geometrically contains *P*; (in our case let us suppose it is *B\_3*). Since a node is just a; positioned volume, we can then get a pointer to the volume, medium or; material objects related to it. *Deepest* means that *B\_3* still; contains point *P* (as well as *A\_1* and *TOP\_1*), but none of the; daughters of volume **B** does. After finding out the node containing; the particle, one can check if the geometry state is different compared; to the last located point:. ``` {.cpp}; Bool_t *TGeoManager::IsSameLocation(); ```. The algorithm for finding where a point is located in geometry is; presented in the figure 17-36. It always starts by checking if the last computed modeller state is the; answer. This optimizes the search when continuously tracking a particle.; The main actions performed are:. - moving up and down in the logical node tree while updating the; current node and its global matrix; - converting the global position into the local frame of the current; node/volume; - checking whether the local position lies within the geometrical; shape of the current volume - if this is the case continue the; search downwards for the daughters of the current node, otherwise; search upwards its containers until the top level is reached.; - the number of candidate nodes to be checked at a given level is; minimized by an additional optimization structure: voxels. This is; effective even in case there is only one daughter of the current; volume.; - in case the current node is declared as possibly overlapping, the; method FindInCluster() is invoked. This method checks all different; possibilities within the cluster of overlapping candidates. One of; the candidates is prioritized if one of the following conditions id; fu",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:163678,Deployability,update,updated,163678,"lue; is again compared to the maximum allowed step (the proposed one) and in; case the distance is safe no other action is performed and the proposed; step is approved. In case the boundary is closer, the computed distance; is taken as maximum allowed step. For optimization purposed, for; particles starting very close to the current volume boundary (less than; 0.01 microns) and exiting the algorithm stops here. After computing the distance to exit the current node, the distance to; the daughter of the current volume which is crossed next is computed by; **`TGeoManager`**`::FindNextDaughterBoundary().` This computes the; distance to all daughter candidates that can be possibly crossed by; using volume voxelization. The algorithm is efficient in average only in; case the number of daughters is greater than 4. For fewer nodes, a; simple loop is performed and the minimum distance (from a point outside; each shape) is taken and compared to the maximum allowed step. The step; value is again updated if `step<stepmax` . A special case is when the current node is declared as possibly; overlapping with something else. If this is the case, the distance is; computed for all possibly overlapping candidates, taking into account; the overlapping priorities (see also: "" Overlapping volumes ""). The global matrix describing the next crossed physical node is; systematically computed in case the value of the proposed step is; negative. In this case, one can subsequently call; `TGeoManager::ComputeNormalFast()` to get the normal vector to the; crossed surface, after propagating the current point with the; `TGeoManager::GetStep()` value. This propagation can be done like:. ``` {.cpp}; Double_t *current_point = gGeoManager->GetCurrentPoint();; Double_t *current_dir = gGeoManager->GetCurrentDirection();; for (Int_t i=0; i<3; i++); current_point[i] += step * current_dir[I];; ```. Note: The method `TGeoManager::FindNextBoundary()` does not modify the; current point/direction nor the current v",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:14140,Energy Efficiency,charge,charge,14140,"e creating the volume; itself, so we will describe the bits and pieces needed for making the; geometry before moving to an architectural point of view. As far as materials are concerned, they represent the physical; properties of the solid from which a volume is made. Materials are just; a support for the data that has to be provided to the tracking engine; that uses this geometry package. Due to this fact, the; **`TGeoMaterial`** class is more like a thin data structure needed for; building the corresponding native materials of the Monte-Carlo tracking; code that uses **`TGeo`**. ### Elements, Materials and Mixtures. In order to make easier material and mixture creation, one can use the; pre-built table of elements owned by **`TGeoManager`** class:. ``` {.cpp}; TGeoElementTable *table = gGeoManager->GetElementTable();; TGeoElement *element1 = table->GetElement(Int_t Z);; TGeoElement *element2 = table->FindElement(""Copper"");; ```. Materials made of single elements can be defined by their atomic mass; (`A`), charge (`Z`) and density (`rh`o). One can also create a material; by specifying the element that it is made of. Optionally the radiation; and absorption lengths can be also provided; otherwise they can be; computed on-demand [`G3`]. The class representing them is; **`TGeoMaterial`**:. ``` {.cpp}; TGeoMaterial(const char *name,Double_t a,Double_t z,; Double_t density, Double_t radlen=0,Double_t intlen=0);; TGeoMaterial(const char *name, TGeoElement *elem,; Double_t density);; TGeoMaterial(const char* name, Double_t a, Double_t z,; Double_t rho,; TGeoMaterial::EGeoMaterialState state,; Double_t temperature = STP_temperature,; Double_t pressure = STP_pressure); ```. Any material or derived class is automatically indexed after creation.; The assigned index is corresponding to the last entry in the list of; materials owned by **`TGeoManager`** class. This can be changed using; the **`TGeoMaterial`**`::SetIndex()` method, however it is not; recommended while using the ",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:16789,Energy Efficiency,charge,charge,16789," properties. Another hook for material shading properties is currently; not in use. Mixtures are materials made of several elements. They are; represented by the class **`TGeoMixture`**, deriving from; **`TGeoMaterial`** and defined by their number of components and the; density:. ``` {.cpp}; TGeoMixture(const char *name,Int_t nel,Double_t rho);; ```. Elements have to be further defined one by one:. ``` {.cpp}; void TGeoMixture::DefineElement(Int_t iel,Double_t a,Double_t z,; Double_t weigth);; void TGeoMixture::DefineElement(Int_t iel, TGeoElement *elem,; Double_t weight);; void TGeoMixture::DefineElement(Int_t iel, Int_t z, Int_t natoms);; ```. or:. ``` {.cpp}; void AddElement(TGeoMaterial* mat, Double_t weight);; void AddElement(TGeoElement* elem, Double_t weight);; void AddElement(TGeoElement* elem, Int_t natoms);; void AddElement(Double_t a, Double_t z, Double_t weight); ```. - `iel:` index of the element` [0,nel-1]`; - `a` and `z:` the atomic mass and charge; - `weight:` proportion by mass of the elements; - `natoms`: number of atoms of the element in the molecule making the; mixture. The radiation length is automatically computed when all elements are; defined. Since tracking MC provide several other ways to create; materials/mixtures, the materials classes are likely to evolve as the; interfaces to these engines are being developed. Generally in the; process of tracking material properties are not enough and more specific; media properties have to be defined. These highly depend on the MC; performing tracking and sometimes allow the definition of different; media properties (e.g. energy or range cuts) for the same material. ### Radionuclides. A new class **`TGeoElementRN`** was introduced in this version to; provide support for radioactive nuclides and their decays. A database of; 3162 radionuclides can be loaded on demand via the table of elements; (**`TGeoElementTable`** class). One can make then materials/mixtures; based on these radionuclides and use the",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:17432,Energy Efficiency,energy,energy,17432,"t_t natoms);; ```. or:. ``` {.cpp}; void AddElement(TGeoMaterial* mat, Double_t weight);; void AddElement(TGeoElement* elem, Double_t weight);; void AddElement(TGeoElement* elem, Int_t natoms);; void AddElement(Double_t a, Double_t z, Double_t weight); ```. - `iel:` index of the element` [0,nel-1]`; - `a` and `z:` the atomic mass and charge; - `weight:` proportion by mass of the elements; - `natoms`: number of atoms of the element in the molecule making the; mixture. The radiation length is automatically computed when all elements are; defined. Since tracking MC provide several other ways to create; materials/mixtures, the materials classes are likely to evolve as the; interfaces to these engines are being developed. Generally in the; process of tracking material properties are not enough and more specific; media properties have to be defined. These highly depend on the MC; performing tracking and sometimes allow the definition of different; media properties (e.g. energy or range cuts) for the same material. ### Radionuclides. A new class **`TGeoElementRN`** was introduced in this version to; provide support for radioactive nuclides and their decays. A database of; 3162 radionuclides can be loaded on demand via the table of elements; (**`TGeoElementTable`** class). One can make then materials/mixtures; based on these radionuclides and use them in a geometry. ``` {.cpp}; root[] TGeoManager *geom = new TGeoManager(""geom"",""radionuclides"");; root[] TGeoElementTable *table = geom->GetElementTable();; root[] TGeoElementRN *c14 = table->GetElementRN(14,6); // A,Z; root[] c14->Print();; 6-C-014 ENDF=60140; A=14; Z=6; Iso=0; Level=0[MeV]; Dmass=3.0199[MeV];; Hlife=1.81e+11[s] J/P=0+; Abund=0; Htox=5.8e-10; Itox=5.8e-10; Stat=0; Decay modes:; BetaMinus Diso: 0 BR: 100.000% Qval: 0.1565; ```. One can make materials or mixtures from radionuclides:. ``` {.cpp}; root[] TGeoMaterial *mat = new TGeoMaterial(""C14"", c14, 2.0);; ```. The following properties of radionuclides can be cur",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:18536,Energy Efficiency,charge,charge,18536," version to; provide support for radioactive nuclides and their decays. A database of; 3162 radionuclides can be loaded on demand via the table of elements; (**`TGeoElementTable`** class). One can make then materials/mixtures; based on these radionuclides and use them in a geometry. ``` {.cpp}; root[] TGeoManager *geom = new TGeoManager(""geom"",""radionuclides"");; root[] TGeoElementTable *table = geom->GetElementTable();; root[] TGeoElementRN *c14 = table->GetElementRN(14,6); // A,Z; root[] c14->Print();; 6-C-014 ENDF=60140; A=14; Z=6; Iso=0; Level=0[MeV]; Dmass=3.0199[MeV];; Hlife=1.81e+11[s] J/P=0+; Abund=0; Htox=5.8e-10; Itox=5.8e-10; Stat=0; Decay modes:; BetaMinus Diso: 0 BR: 100.000% Qval: 0.1565; ```. One can make materials or mixtures from radionuclides:. ``` {.cpp}; root[] TGeoMaterial *mat = new TGeoMaterial(""C14"", c14, 2.0);; ```. The following properties of radionuclides can be currently accessed via; getters in the **`TGeoElementRN`** class:. Atomic number and charge (from the base class **`TGeoElement`**). - Isomeric number (`ISO`); - ENDF code - following the convention: `ENDF=10000*Z+100*A+ISO`; - Isomeric energy level [`MeV`]; - Mass excess [`MeV`]; - Half life [`s`]; - Spin/Parity - can be retrieved with: `TGeoElementRN::GetTitle()`; - Hynalation and ingestion toxicities; - List of decays - `TGeoElementRN::GetDecays()`. The radioactive decays of a radionuclide are represented by the class; **`TGeoDecayChannel`** and they are stored in a **`TObjArray`**. Decay; provides:. - Decay mode; - Variation of isomeric number; - `Q` value for the decay [`GeV`]; - Parent element; - Daughter element. Radionuclides are linked one to each other via their decays, until the; last element in the decay chain which must be stable. One can iterate; decay chains using the iterator **`TGeoElemIter`**:. ``` {.cpp}; root[] TGeoElemIter next(c14);; root[] TGeoElementRN *elem;; root[] while ((elem=next())) next.Print();; 6-C-014 (100% BetaMinus) T1/2=1.81e+11; 7-N-014 stable; ",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:18688,Energy Efficiency,energy,energy,18688,"n make then materials/mixtures; based on these radionuclides and use them in a geometry. ``` {.cpp}; root[] TGeoManager *geom = new TGeoManager(""geom"",""radionuclides"");; root[] TGeoElementTable *table = geom->GetElementTable();; root[] TGeoElementRN *c14 = table->GetElementRN(14,6); // A,Z; root[] c14->Print();; 6-C-014 ENDF=60140; A=14; Z=6; Iso=0; Level=0[MeV]; Dmass=3.0199[MeV];; Hlife=1.81e+11[s] J/P=0+; Abund=0; Htox=5.8e-10; Itox=5.8e-10; Stat=0; Decay modes:; BetaMinus Diso: 0 BR: 100.000% Qval: 0.1565; ```. One can make materials or mixtures from radionuclides:. ``` {.cpp}; root[] TGeoMaterial *mat = new TGeoMaterial(""C14"", c14, 2.0);; ```. The following properties of radionuclides can be currently accessed via; getters in the **`TGeoElementRN`** class:. Atomic number and charge (from the base class **`TGeoElement`**). - Isomeric number (`ISO`); - ENDF code - following the convention: `ENDF=10000*Z+100*A+ISO`; - Isomeric energy level [`MeV`]; - Mass excess [`MeV`]; - Half life [`s`]; - Spin/Parity - can be retrieved with: `TGeoElementRN::GetTitle()`; - Hynalation and ingestion toxicities; - List of decays - `TGeoElementRN::GetDecays()`. The radioactive decays of a radionuclide are represented by the class; **`TGeoDecayChannel`** and they are stored in a **`TObjArray`**. Decay; provides:. - Decay mode; - Variation of isomeric number; - `Q` value for the decay [`GeV`]; - Parent element; - Daughter element. Radionuclides are linked one to each other via their decays, until the; last element in the decay chain which must be stable. One can iterate; decay chains using the iterator **`TGeoElemIter`**:. ``` {.cpp}; root[] TGeoElemIter next(c14);; root[] TGeoElementRN *elem;; root[] while ((elem=next())) next.Print();; 6-C-014 (100% BetaMinus) T1/2=1.81e+11; 7-N-014 stable; ```. To create a radioactive material based on a radionuclide, one should; use the constructor:. ``` {.cpp}; TGeoMaterial(const char *name, TGeoElement *elem, Double_t density); ```. To create a ",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:65970,Energy Efficiency,reduce,reduce,65970,"s(""VNAME"",ptrMed,rmin,rmax,; dz,phi1,phi2);. // See class TGeoManager for the rest of shapes.; // Making a volume with a given shape with a unique prototype; TGeoVolume *vol = gGeoManager->Volume(""VNAME"",""XXXX"",nmed,upar,; npar);. // Where XXXX stands for the first 4 letters of the specific shape; // classes, nmed is the medium number, upar is an Double_t * array; // of the shape parameters and npar is the number of parameters.; // This prototype allows (npar = 0) to define volumes with shape; // defined only at positioning time (volumes defined in this way; // need to be positioned using TGeoManager::Node() method); ```. #### Positioned Volumes (Nodes). Geometrical modeling is a difficult task when the number of different; geometrical objects is 106-108. This is more or less the case for; detector geometries of complex experiments, where a ‘flat' CSG model; description cannot scale with the current CPU performances. This is the; reason why models like GEANT [1] introduced an additional dimension; (depth) in order to reduce the complexity of the problem. This concept; is also preserved by the ROOT modeller and introduces a pure geometrical; constraint between objects (volumes in our case) - containment. This; means in fact that any positioned volume has to be contained by another.; Now what means contained and positioned?. - We will say that a volume `contains` a point if this is inside the; shape associated to the volume. For instance, a volume having a box; shape will contain all points `P=(X,Y,Z)` verifying the conditions:; `Abs(Pi)dXi`. The points on the shape boundaries are considered as; inside the volume. The volume contains a daughter if it contains all; the points contained by the daughter.; - The definition of containment works of course only with points; defined in the local coordinate system of the considered volume.; `Positioning` a volume inside another have to introduce a; geometrical transformation between the two. If `M` defines this; transformation",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:80266,Energy Efficiency,efficient,efficient,80266,"tion(0.2,0,0));; chamber->AddNode(wire_co,2,new TGeoTranslation(0.2,0,0));; ```. The 2 nodes that we have created inside chamber will both point to a; `wire_co` object, but will be completely distinct: `WIRE_CO_1` and; `WIRE_CO_2`. We will want now to place symmetrically 1000 chambers on a; pad, following a pattern of 20 rows and 50 columns. One way to do this; will be to replicate our chamber by positioning it 1000 times in; different positions of the pad. Unfortunately, this is far from being; the optimal way of doing what we want. Imagine that we would like to; find out which of the 1000 chambers is containing a `(x,y,z)` point; defined in the pad reference. You will never have to do that, since the; modeller will take care of it for you, but let's guess what it has to; do. The most simple algorithm will just loop over all daughters, convert; the point from mother to local reference and check if the current; chamber contains the point or not. This might be efficient for pads with; few chambers, but definitely not for 1000. Fortunately the modeller is; smarter than that and creates for each volume some optimization; structures called `voxels` to minimize the penalty having too many; daughters, but if you have 100 pads like this in your geometry you will; anyway lose a lot in your tracking performance. The way out when; volumes can be arranged according to simple patterns is the usage of; divisions. We will describe them in detail later on. Let's think now at; a different situation: instead of 1000 chambers of the same type, we may; have several types of chambers. Let's say all chambers are cylindrical; and have a wire inside, but their dimensions are different. However, we; would like all to be represented by a single volume family, since they; have the same properties. #### Volume Families. A volume family is represented by the class **`TGeoVolumeMulti`**. It; represents a class of volumes having the same shape type and each member; will be identified by the same",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:135058,Energy Efficiency,green,green,135058,"positioned volume mesh is contained (having; a safety bigger than the accepted maximum value) by other positioned; volume inside the same container. The check is performed also by; inverting the candidates. The code is highly optimized to avoid checking candidates that are far; away in space by performing a fast check on their bounding boxes. Once; the checking tool is fired-up inside a volume or at top level, the list; of overlaps (visible as Illegal overlaps inside a **`TBrowser`**) held; by the manager class will be filled with **`TGeoOverlap`** objects; containing a full description of the detected overlaps. The list is; sorted in the decreasing order of the overlapping distance, extrusions; coming first. An overlap object name represents the full description of; the overlap, containing both candidate node names and a letter; (x-extrusion, o-overlap) representing the type. Double-clicking an; overlap item in a **`TBrowser`** produces a picture of the overlap; containing only the two overlapping nodes (one in blue and one in green); and having the critical vertices represented by red points. The picture; can be rotated/zoomed or drawn in X3d as any other view. Calling; `gGeoManager->PrintOverlaps()` prints the list of overlaps. ### Graphical Checking Methods. ![Safety computation checking](pictures/030001E0.png). In order to check a given point, `CheckPoint(x,y,z)` method of; **`TGeoManager`** draws the daughters of the volume containing the point; one level down, printing the path to the deepest physical node holding; this point. It also computes the closest distance to any boundary. ![Random points](pictures/030001E1.png). A method to check the validity of a given geometry is shooting random; points. This can be called with the method; **`TGeoVolume`**`::RandomPoints()` and it draws a volume with the current; visualization settings. Random points are generated in the bounding box; of the drawn volume. The points are drawn with the color of their; deepest contai",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:136427,Energy Efficiency,power,powerful,136427," of the volume containing the point; one level down, printing the path to the deepest physical node holding; this point. It also computes the closest distance to any boundary. ![Random points](pictures/030001E1.png). A method to check the validity of a given geometry is shooting random; points. This can be called with the method; **`TGeoVolume`**`::RandomPoints()` and it draws a volume with the current; visualization settings. Random points are generated in the bounding box; of the drawn volume. The points are drawn with the color of their; deepest container. Only points inside visible nodes are drawn. ![Random rays](pictures/030001E2.png). A ray tracing method can be called `TGeoVolume::RandomRays()`. This; shoots rays from a given point in the local reference frame with random; directions. The intersections with displayed nodes appear as segments; having the color of the touched node. ## The Drawing Package. ![](pictures/030001E3.png)The modeller provides a powerful drawing; package, supporting several different options of visualization. A; library separated from the main one provides all functionality being; linked with the underlying ROOT visualization system. This library is; dynamically loaded by the plug-in manager only when drawing features are; requested. The geometrical structures that can be visualized are volumes; and volume hierarchies. The main component of the visualization system is volume primitive; painting in a ROOT pad. Starting from this one, several specific options; or subsystems are available, like: X3D viewing using hidden line and; surface removal algorithms, OpenGL viewing\* or ray tracing. The method `TGeoManager::GetGeomPainter()`loads the painting library in; memory. This is generally not needed since it is called automatically by; `TGeoVolume::Draw()` as well as by few other methods setting; visualization attributes. ### Drawing Volumes and Hierarchies of Volumes. The first thing one would like to do after building some geometry is to; ",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:149066,Energy Efficiency,consumption,consumption,149066,"corresponds; to the level 0 in the stored array, while the last node will correspond; to level `n`. For each level, the node, volume and global matrix can be; retrieved using corresponding getters:. ``` {.cpp}; TGeoHMatrix *GetMatrix(Int_t level=-1) const; TGeoNode *GetNode(Int_t level=-1) const; TGeoShape *GetShape(Int_t level=-1) const; TGeoVolume *GetVolume(Int_t level=-1) const; ```. By default the object at level n is retrieved (the align-able object). Once created, a physical node can be misaligned, meaning that its; positioning matrix or even the shape.:. ``` {.cpp}; void Align(TGeoMatrix* newmat=0, TGeoShape* newshape=0,; Bool_t check=kFALSE); ```. The convention used is that newmat represents the new local matrix of; the last node in the branch with respect to its mother volume. The; `Align()` method will actually duplicate the corresponding branch within; the logical hierarchy, creating new volumes and nodes. This is mandatory; in order to avoid problems due to replicated volumes and can create; exhaustive memory consumption if used abusively. Once aligned, a physical node is ready to be tracked. The operation can; be done only after the geometry was closed. Important NOTE: Calling the `Align()` method for a physical node changes; the node pointers for the stored node branch in the active geometry, Due; to this the other defined physical nodes containing elements of this; path will be invalid. Example:. ``` {.cpp}; TGeoPhysicalNode *pn1 =; gGeoManager->MakePhysicalNode(""/A_1/B_1/C_2"");; TGeoPhysicalNode *pn2 =; gGeoManager->MakePhysicalNode(""/A_1/B_1/C_3"");; ...; pn1->Align(...);; ```. The call to `pn1->Align()` will invalidate the pointer to the node `B_1`; in `pn2` object.. The way out is to either call `pn1->Align()` before; the creation of `pn2`, either to use a global method that will correct; all existing physical nodes:. ``` {.cpp}; void RefreshPhysicalNodes(Bool_t lock = kTRUE); ```. The method above will optionally lock the possibility of doing any",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:163419,Energy Efficiency,efficient,efficient,163419,"for the current point.; Therefore, the first step is to convert the global current point and; direction in the local reference frame of the current volume and to; compute the distance to exit its shape from inside. The returned value; is again compared to the maximum allowed step (the proposed one) and in; case the distance is safe no other action is performed and the proposed; step is approved. In case the boundary is closer, the computed distance; is taken as maximum allowed step. For optimization purposed, for; particles starting very close to the current volume boundary (less than; 0.01 microns) and exiting the algorithm stops here. After computing the distance to exit the current node, the distance to; the daughter of the current volume which is crossed next is computed by; **`TGeoManager`**`::FindNextDaughterBoundary().` This computes the; distance to all daughter candidates that can be possibly crossed by; using volume voxelization. The algorithm is efficient in average only in; case the number of daughters is greater than 4. For fewer nodes, a; simple loop is performed and the minimum distance (from a point outside; each shape) is taken and compared to the maximum allowed step. The step; value is again updated if `step<stepmax` . A special case is when the current node is declared as possibly; overlapping with something else. If this is the case, the distance is; computed for all possibly overlapping candidates, taking into account; the overlapping priorities (see also: "" Overlapping volumes ""). The global matrix describing the next crossed physical node is; systematically computed in case the value of the proposed step is; negative. In this case, one can subsequently call; `TGeoManager::ComputeNormalFast()` to get the normal vector to the; crossed surface, after propagating the current point with the; `TGeoManager::GetStep()` value. This propagation can be done like:. ``` {.cpp}; Double_t *current_point = gGeoManager->GetCurrentPoint();; Double_t *current_di",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:2462,Integrability,interface,interface,2462,"ARS)`. Going; on and opening our packs, we will obviously find out some empty ones,; otherwise, something is very wrong... We will call these leaves (by; analogy with a tree structure). On the other hand, any volume is a small world by itself - what we need; to do is to take it out and to ignore all the rest since it is a; self-contained object. In fact, the modeller can act like this,; considering a given volume as temporary MARS, but we will describe this; feature later on. Let us focus on the biggest pack - it is mandatory to; define one. Consider the simplest geometry that is made of a single box.; Here is an example on how to build it:. ### Example 1: Creating the World. We first need to load the geometry library. This is not needed if one; does `make map` in root folder. ``` {.cpp}; root[] gSystem->Load(""libGeom"");; ```. Second, we have to create an instance of the geometry manager class.; This takes care of all the modeller components, performing several tasks; to insure geometry validity and containing the user interface for; building and interacting with the geometry. After its creation, the; geometry manager class can be accessed with the global; ***`gGeoManager`***:. ``` {.cpp}; root[] new TGeoManager(""world"", ""the simplest geometry"");; ```. We want to create a single volume in our geometry, but since any volume; needs to have an associated medium, we will create a dummy one. You can; safely ignore the following lines for the time being, since materials; and media will be explained in detail later on. ``` {.cpp}; root[] TGeoMaterial *mat = new TGeoMaterial(""Vacuum"",0,0,0);; root[] TGeoMedium *med = new TGeoMedium(""Vacuum"",1,mat);; ```. We can finally make our volume having a box shape. Note that the world; volume does not need to be a box - it can be any other shape. Generally,; boxes and tubes are the most recommendable shapes for this purpose due; to their fast navigation algorithms. ``` {.cpp}; root[] TGeoVolume *top=gGeoManager->MakeBox(""Top"",med,10.,",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:3825,Integrability,message,messages,3825,"; safely ignore the following lines for the time being, since materials; and media will be explained in detail later on. ``` {.cpp}; root[] TGeoMaterial *mat = new TGeoMaterial(""Vacuum"",0,0,0);; root[] TGeoMedium *med = new TGeoMedium(""Vacuum"",1,mat);; ```. We can finally make our volume having a box shape. Note that the world; volume does not need to be a box - it can be any other shape. Generally,; boxes and tubes are the most recommendable shapes for this purpose due; to their fast navigation algorithms. ``` {.cpp}; root[] TGeoVolume *top=gGeoManager->MakeBox(""Top"",med,10.,10.,10.);; ```. The default units are in centimeters. Now we want to make this volume; our world. We have to do this operation **before** closing the geometry. ``` {.cpp}; root[] gGeoManager->SetTopVolume(top);; ```. This should be enough, but it is not since always after defining some; geometry hierarchy, **`TGeo`** needs to build some optimization; structures and perform some checks. Note the messages posted after the; statement is executed. We will describe the corresponding operations; later. ``` {.cpp}; root[] gGeoManager->CloseGeometry();; ```. Now we are really done with geometry building stage, but we would like; to see our simple world:. ``` {.cpp}; root[] top->SetLineColor(kMagenta);; root[] gGeoManager->SetTopVisible(); // the TOP is invisible; root[] top->Draw();; ```. ### Example 2: A Geometrical Hierarchy Look and Feel. Before going further, let us get a look and feel of interacting with the; modeller. For this, we will use one of the examples illustrating the; geometry package. To get an idea on the geometry structure created in; this example, just look at the link:; <http://root.cern.ch/root/html/tutorials/geom/rootgeom.C.html>. You will; notice that this is a bit more complex that just creating the ""world""; since several other volumes are created and put together in a hierarchy.; The purpose here is just to learn how to interact with a geometry that; is already built, but just f",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:15134,Integrability,interface,interfaced,15134,"ingle elements can be defined by their atomic mass; (`A`), charge (`Z`) and density (`rh`o). One can also create a material; by specifying the element that it is made of. Optionally the radiation; and absorption lengths can be also provided; otherwise they can be; computed on-demand [`G3`]. The class representing them is; **`TGeoMaterial`**:. ``` {.cpp}; TGeoMaterial(const char *name,Double_t a,Double_t z,; Double_t density, Double_t radlen=0,Double_t intlen=0);; TGeoMaterial(const char *name, TGeoElement *elem,; Double_t density);; TGeoMaterial(const char* name, Double_t a, Double_t z,; Double_t rho,; TGeoMaterial::EGeoMaterialState state,; Double_t temperature = STP_temperature,; Double_t pressure = STP_pressure); ```. Any material or derived class is automatically indexed after creation.; The assigned index is corresponding to the last entry in the list of; materials owned by **`TGeoManager`** class. This can be changed using; the **`TGeoMaterial`**`::SetIndex()` method, however it is not; recommended while using the geometry package interfaced with a transport; MC. Radiation and absorption lengths can be set using:. ``` {.cpp}; TGeoMaterial::SetRadLen(Double_t radlen, Double_t intlen);; ```. - `radlen:` radiation length. If `radlen<=0` the value is computed; using GSMATE algorithm in GEANT3; - `intlen:` absorption length. Material state, temperature and pressure can be changed via setters.; Another material property is transparency. It can be defined and used; while viewing the geometry with OpenGL. ``` {.cpp}; void SetTransparency (Char_t transparency = 0); ```. - `transparency:` between 0 (opaque default) to 100 (fully; transparent). One can attach to a material a user-defined object storing Cerenkov; properties. Another hook for material shading properties is currently; not in use. Mixtures are materials made of several elements. They are; represented by the class **`TGeoMixture`**, deriving from; **`TGeoMaterial`** and defined by their number of components an",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:17131,Integrability,interface,interfaces,17131,"nsity:. ``` {.cpp}; TGeoMixture(const char *name,Int_t nel,Double_t rho);; ```. Elements have to be further defined one by one:. ``` {.cpp}; void TGeoMixture::DefineElement(Int_t iel,Double_t a,Double_t z,; Double_t weigth);; void TGeoMixture::DefineElement(Int_t iel, TGeoElement *elem,; Double_t weight);; void TGeoMixture::DefineElement(Int_t iel, Int_t z, Int_t natoms);; ```. or:. ``` {.cpp}; void AddElement(TGeoMaterial* mat, Double_t weight);; void AddElement(TGeoElement* elem, Double_t weight);; void AddElement(TGeoElement* elem, Int_t natoms);; void AddElement(Double_t a, Double_t z, Double_t weight); ```. - `iel:` index of the element` [0,nel-1]`; - `a` and `z:` the atomic mass and charge; - `weight:` proportion by mass of the elements; - `natoms`: number of atoms of the element in the molecule making the; mixture. The radiation length is automatically computed when all elements are; defined. Since tracking MC provide several other ways to create; materials/mixtures, the materials classes are likely to evolve as the; interfaces to these engines are being developed. Generally in the; process of tracking material properties are not enough and more specific; media properties have to be defined. These highly depend on the MC; performing tracking and sometimes allow the definition of different; media properties (e.g. energy or range cuts) for the same material. ### Radionuclides. A new class **`TGeoElementRN`** was introduced in this version to; provide support for radioactive nuclides and their decays. A database of; 3162 radionuclides can be loaded on demand via the table of elements; (**`TGeoElementTable`** class). One can make then materials/mixtures; based on these radionuclides and use them in a geometry. ``` {.cpp}; root[] TGeoManager *geom = new TGeoManager(""geom"",""radionuclides"");; root[] TGeoElementTable *table = geom->GetElementTable();; root[] TGeoElementRN *c14 = table->GetElementRN(14,6); // A,Z; root[] c14->Print();; 6-C-014 ENDF=60140; A=14; Z=6; I",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:17322,Integrability,depend,depend,17322,"ent *elem,; Double_t weight);; void TGeoMixture::DefineElement(Int_t iel, Int_t z, Int_t natoms);; ```. or:. ``` {.cpp}; void AddElement(TGeoMaterial* mat, Double_t weight);; void AddElement(TGeoElement* elem, Double_t weight);; void AddElement(TGeoElement* elem, Int_t natoms);; void AddElement(Double_t a, Double_t z, Double_t weight); ```. - `iel:` index of the element` [0,nel-1]`; - `a` and `z:` the atomic mass and charge; - `weight:` proportion by mass of the elements; - `natoms`: number of atoms of the element in the molecule making the; mixture. The radiation length is automatically computed when all elements are; defined. Since tracking MC provide several other ways to create; materials/mixtures, the materials classes are likely to evolve as the; interfaces to these engines are being developed. Generally in the; process of tracking material properties are not enough and more specific; media properties have to be defined. These highly depend on the MC; performing tracking and sometimes allow the definition of different; media properties (e.g. energy or range cuts) for the same material. ### Radionuclides. A new class **`TGeoElementRN`** was introduced in this version to; provide support for radioactive nuclides and their decays. A database of; 3162 radionuclides can be loaded on demand via the table of elements; (**`TGeoElementTable`** class). One can make then materials/mixtures; based on these radionuclides and use them in a geometry. ``` {.cpp}; root[] TGeoManager *geom = new TGeoManager(""geom"",""radionuclides"");; root[] TGeoElementTable *table = geom->GetElementTable();; root[] TGeoElementRN *c14 = table->GetElementRN(14,6); // A,Z; root[] c14->Print();; 6-C-014 ENDF=60140; A=14; Z=6; Iso=0; Level=0[MeV]; Dmass=3.0199[MeV];; Hlife=1.81e+11[s] J/P=0+; Abund=0; Htox=5.8e-10; Itox=5.8e-10; Stat=0; Decay modes:; BetaMinus Diso: 0 BR: 100.000% Qval: 0.1565; ```. One can make materials or mixtures from radionuclides:. ``` {.cpp}; root[] TGeoMaterial *mat = new TGeo",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:20649,Integrability,depend,depending,20649," the constructor:. ``` {.cpp}; TGeoMaterial(const char *name, TGeoElement *elem, Double_t density); ```. To create a radioactive mixture, one can use radionuclides as well as; stable elements:. ``` {.cpp}; TGeoMixture(const char *name, Int_t nelements, Double_t density);; TGeoMixture::AddElement(TGeoElement *elem,; Double_t weight_fraction);; ```. Once defined, one can retrieve the time evolution for the radioactive; materials/mixtures by using one of the next two methods:. 1. `TGeoMaterial::FillMaterialEvolution(TObjArray *population,`; ` Double_t precision=0.001)`. To use this method, one has to provide an empty **`TObjArray`** object; that will be filled with all elements coming from the decay chain of the; initial radionuclides contained by the material/mixture. The precision; represent the cumulative branching ratio for which decay products are; still considered. ![Concentration of C14 derived elements](pictures/030001B3.png). The population list may contain stable elements as well as; radionuclides, depending on the initial elements. To test if an element; is a radionuclide:. ``` {.cpp}; Bool_t TGeoElement::IsRadioNuclide() const; ```. All radionuclides in the output population list have attached objects; that represent the time evolution of their fraction of nuclei with; respect to the top radionuclide in the decay chain. These objects; (Bateman solutions) can be retrieved and drawn:. ``` {.cpp}; TGeoBatemanSol *TGeoElementRN::Ratio();; void TGeoBatemanSol::Draw();; ```. Another method allows to create the evolution of a given radioactive; material/mixture at a given moment in time:. 2. `TGeoMaterial::DecayMaterial(Double_t time, Double_t precision=0.001)`. The method will create the mixture that result from the decay of a; initial material/mixture at time, while all resulting elements having a; fractional weight less than precision are excluded. A demo macro for radioactive material features is; `$ROOTSYS/tutorials/geom/RadioNuclides.C` It demonstrates also ",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:22505,Integrability,interface,interface,22505,"ight less than precision are excluded. A demo macro for radioactive material features is; `$ROOTSYS/tutorials/geom/RadioNuclides.C` It demonstrates also the decay; of a mixture made of radionuclides. ![Concentracion of elements derived; fromCa53+Sr78](pictures/030001B4.png). ### Tracking Media. The class **`TGeoMedium`** describes tracking media properties. This has; a pointer to a material and the additional data members representing the; properties related to tracking. ``` {.cpp}; TGeoMedium(const char *name,Int_t numed,TGeoMaterial *mat,; Double_t *params=0);; ```. - `name:` name assigned to the medium; - `mat:` pointer to a material; - `params:` array of additional parameters. Another constructor allows effectively defining tracking parameters in; GEANT3 style:. ``` {.cpp}; TGeoMedium(const char *name,Int_t numed,Int_t imat,Int_t ifield,; Double_t fieldm,Double_t tmaxfd,Double_t stemax,; Double_t deemax,Double_t epsil,Double_t stmin);; ```. This constructor is reserved for creating tracking media from the VMC; interface [...]:. - `numed:` user-defined medium index; - `imat:` unique ID of the material; - `others:` see G3 documentation. Looking at our simple world example, one can see that for creating; volumes one needs to create tracking media before. The way to proceed; for those not interested in performing tracking with external MC's is to; define and use only one `dummy tracking medium` as in the example (or a; `NULL` pointer). ### User Interface for Handling Materials and Media. The **`TGeoManager`** class contains the API for accessing and handling; defined materials:. ``` {.cpp}; TGeoManager::GetMaterial(name);; ```. ## Shapes. Shapes are geometrical objects that provide the basic modeling; functionality. They provide the definition of the `local` coordinate; system of the volume. Any volume must have a shape. Any shape recognized; by the modeller has to derive from the base **`TGeoShape`** class,; providing methods for:. - Finding out if a point defined ",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:25657,Integrability,interface,interface,25657," of different shape topologies and combinations. You can; have a look and run the tutorial:; <http://root.cern.ch/root/html/examples/geodemo.C.html>. ![Primitive Shapes - the general inheritance scheme](pictures/030001B5.png). Shapes are named objects and all primitives have constructors like:. ``` {.cpp}; TGeoXXX(const char *name,<type> param1,<type> param2, ...);; TGeoXXX(<type> param1,<type> param2, ...);; ```. Naming shape primitive is mandatory only for the primitives used in; Boolean composites (see ""Composite Shapes""). For the sake of simplicity,; we will describe only the constructors in the second form. ### Units. The length units used in the geometry are **arbitrary**. However, there; are certain functionalities that work with the assumption that the used; lengths are expressed in centimeters. This is the case for shape; capacity or volume weight computation. The same is valid when using the; ROOT geometry as navigator for an external transport MC package (e.g.; GEANT) via the VMC interface. Other units in use: All angles used for defining rotation matrices or; some shape parameters are expressed in **degrees**. Material density is; expressed in [**g/cm3**]. ### Primitive Shapes. #### Boxes - TGeoBBox Class. Normally a box has to be built only with 3 parameters: `DX,DY,DZ`; representing the half-lengths on X, Y and Z-axes. In this case, the; origin of the box will match the one of its reference frame and the box; will range from: `-DX` to `DX` on X-axis, from `-DY` to `DY` on Y and; from `-DZ` to `DZ` on Z. On the other hand, any other shape needs to; compute and store the parameters of their minimal bounding box. The; bounding boxes are essential to optimize navigation algorithms.; Therefore all other primitives derive from **`TGeoBBox`**. Since the; minimal bounding box is not necessary centered in the origin, any box; allows an origin translation `(Ox`,`Oy`,`Oz)`. All primitive; constructors automatically compute the bounding box parameters. Users; shoul",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:30996,Integrability,depend,dependent,30996,"but; that is twisted along the Z-axis. The twist is defined as the rotation; angle between the lower and the higher Z faces. ``` {.cpp}; TGeoGtra(Double_t dz,Double_t theta,Double_t phi,Double_t twist,; Double_t h1,Double_t bl1,Double_t tl1,Double_t alpha1,; Double_t h2,Double_t bl2,Double_t tl2,Double_t alpha2 );; ```. ![TGeoGtra class](pictures/060001BB.png). #### Arbitrary 8 vertices shapes - TGeoArb8 class. An `Arb8` is defined by two quadrilaterals sitting on parallel planes,; at `dZ`. These are defined each by 4 vertices having the coordinates; `(Xi,Yi,+/-dZ)`,` i=0`,` 3`. The lateral surface of the `Arb8` is; defined by the 4 pairs of edges corresponding to vertices (`i,i+1`) on; both `-dZ` and `+dZ`. If M and M' are the middles of the segments; `(i,i+1)` at `-dZ` and `+dZ`, a lateral surface is obtained by sweeping; the edge at `-dZ` along MM' so that it will match the corresponding one; at `+dZ`. Since the points defining the edges are arbitrary, the lateral; surfaces are not necessary planes - but twisted planes having a twist; angle linear-dependent on Z. ``` {.cpp}; TGeoArb8::TGeoArb8(Double_t dz,Double_t ivert);; ```. - `dz:` half-length in Z;; - `ivert = [0,7]`. Vertices have to be defined clockwise in the XY pane, both at `+dz` and; `-dz`. The quadrilateral at `-dz` is defined by indices [0,3], whereas; the one at `+dz` by vertices [4,7]. The vertex with `index=7` has to be; defined last, since it triggers the computation of the bounding box of; the shape. Any two or more vertices in each Z plane can have the same; (X,Y) coordinates. It this case, the top and bottom quadrilaterals; become triangles, segments or points. The lateral surfaces are not; necessary defined by a pair of segments, but by pair segment-point; (making a triangle) or point-point (making a line). Any choice is valid; as long as at one of the end-caps is at least a triangle. ![TGeoArb8 class](pictures/080001BC.png). #### Tubes - TGeoTube Class. Tubes have Z as their symmetry axis. T",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:33999,Integrability,rout,rout,33999,",Double_t nzlow, Double_t nxhi,; Double_t nyhi,Double_t nzhi);; ```. ![TGeoCtub Class](pictures/060001BF.png). A cut tube is a tube segment cut with two planes. The centers of the 2; sections are positioned at `dZ`. Each cut plane is therefore defined by; a point `(0,0,dZ)` and its normal unit vector pointing outside the; shape:. `Nlow=(Nx,Ny,Nz<0)`, `Nhigh=(Nx',Ny',Nz'>0)`. #### Elliptical Tubes - TGeoEltu Class. An elliptical tube is defined by the two semi-axes A and B. It ranges; from `-dZ` to `+dZ` as all other tubes:. ``` {.cpp}; TGeoEltu(Double_t a,Double_t b,Double_t dz);; ```. ![TGeoEltu Class](pictures/060001C0.png). #### Hyperboloids - TGeoHype Class. A hyperboloid is represented as a solid limited by two planes; perpendicular to the Z axis (top and bottom planes) and two hyperbolic; surfaces of revolution about Z axis (inner and outer surfaces). The; class describing hyperboloids is **`TGeoHype`** has 5 input parameters:. ``` {.cpp}; TGeoHype(Double_t rin,Double_t stin,Double_t rout,; Double_t stout,Double_t dz);; ```. ![TGeoHype Class](pictures/080001C1.png). The hyperbolic surface equation is taken in the form:. ``` {.cpp}; r2 - z2tan2() = r2min; ```. - `r,z:` cylindrical coordinates for a point on the surface; - `:` stereo angle between the hyperbola asymptotic lines and Z axis; - `r2min:` minimum distance between hyperbola and Z axis (at `z=0`). The input parameters represent:. - `rin, stin:` minimum radius and tangent of stereo angle for inner; surface; - `rout, stout:` minimum radius and tangent of stereo angle for outer; surface; - `dz:` half length in Z (bounding planes positions at `+/-dz`). The following conditions are mandatory in order to avoid intersections; between the inner and outer hyperbolic surfaces in the range `+/-dz`:. - `rin<rout`; - `rout>0`; - `rin2 + dz2*stin2 > rout2 + dz2*stout2`. Particular cases:. - `rin=0, stin0:` the inner surface is conical; - `stin=0 / stout=0:` cylindrical surface(s). #### Cones - TGeoCone Class. The co",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:34492,Integrability,rout,rout,34492,":. ``` {.cpp}; TGeoEltu(Double_t a,Double_t b,Double_t dz);; ```. ![TGeoEltu Class](pictures/060001C0.png). #### Hyperboloids - TGeoHype Class. A hyperboloid is represented as a solid limited by two planes; perpendicular to the Z axis (top and bottom planes) and two hyperbolic; surfaces of revolution about Z axis (inner and outer surfaces). The; class describing hyperboloids is **`TGeoHype`** has 5 input parameters:. ``` {.cpp}; TGeoHype(Double_t rin,Double_t stin,Double_t rout,; Double_t stout,Double_t dz);; ```. ![TGeoHype Class](pictures/080001C1.png). The hyperbolic surface equation is taken in the form:. ``` {.cpp}; r2 - z2tan2() = r2min; ```. - `r,z:` cylindrical coordinates for a point on the surface; - `:` stereo angle between the hyperbola asymptotic lines and Z axis; - `r2min:` minimum distance between hyperbola and Z axis (at `z=0`). The input parameters represent:. - `rin, stin:` minimum radius and tangent of stereo angle for inner; surface; - `rout, stout:` minimum radius and tangent of stereo angle for outer; surface; - `dz:` half length in Z (bounding planes positions at `+/-dz`). The following conditions are mandatory in order to avoid intersections; between the inner and outer hyperbolic surfaces in the range `+/-dz`:. - `rin<rout`; - `rout>0`; - `rin2 + dz2*stin2 > rout2 + dz2*stout2`. Particular cases:. - `rin=0, stin0:` the inner surface is conical; - `stin=0 / stout=0:` cylindrical surface(s). #### Cones - TGeoCone Class. The cones are defined by 5 parameters:. ``` {.cpp}; TGeoCone(Double_t dz,Double_t rmin1,Double_t rmax1,; Double_t rmin2,Double_t rmax2);; ```. - `rmin1:` internal radius at Z is `-dz`; - `rmax1:` external radius at Z is `-dz`; - `rmin2:` internal radius at Z is `+dz`; - `rmax2:` external radius at Z is `+dz`; - `dz:` half length in Z (a cone ranges from `-dz` to +`dz`). A cone has Z-axis as its symmetry axis. ![TGeoCone Class](pictures/060001C2.png). #### Cone Segments - TGeoConeSeg Class. A cone segment is a cone having a range",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:34784,Integrability,rout,rout,34784,"f revolution about Z axis (inner and outer surfaces). The; class describing hyperboloids is **`TGeoHype`** has 5 input parameters:. ``` {.cpp}; TGeoHype(Double_t rin,Double_t stin,Double_t rout,; Double_t stout,Double_t dz);; ```. ![TGeoHype Class](pictures/080001C1.png). The hyperbolic surface equation is taken in the form:. ``` {.cpp}; r2 - z2tan2() = r2min; ```. - `r,z:` cylindrical coordinates for a point on the surface; - `:` stereo angle between the hyperbola asymptotic lines and Z axis; - `r2min:` minimum distance between hyperbola and Z axis (at `z=0`). The input parameters represent:. - `rin, stin:` minimum radius and tangent of stereo angle for inner; surface; - `rout, stout:` minimum radius and tangent of stereo angle for outer; surface; - `dz:` half length in Z (bounding planes positions at `+/-dz`). The following conditions are mandatory in order to avoid intersections; between the inner and outer hyperbolic surfaces in the range `+/-dz`:. - `rin<rout`; - `rout>0`; - `rin2 + dz2*stin2 > rout2 + dz2*stout2`. Particular cases:. - `rin=0, stin0:` the inner surface is conical; - `stin=0 / stout=0:` cylindrical surface(s). #### Cones - TGeoCone Class. The cones are defined by 5 parameters:. ``` {.cpp}; TGeoCone(Double_t dz,Double_t rmin1,Double_t rmax1,; Double_t rmin2,Double_t rmax2);; ```. - `rmin1:` internal radius at Z is `-dz`; - `rmax1:` external radius at Z is `-dz`; - `rmin2:` internal radius at Z is `+dz`; - `rmax2:` external radius at Z is `+dz`; - `dz:` half length in Z (a cone ranges from `-dz` to +`dz`). A cone has Z-axis as its symmetry axis. ![TGeoCone Class](pictures/060001C2.png). #### Cone Segments - TGeoConeSeg Class. A cone segment is a cone having a range in `phi.` The cone segment class; derives from **`TGeoCone`**, having two extra parameters: `phi1` and; `phi2`. ``` {.cpp}; TGeoConeSeg(Double_t dz,Double_t rmin1,Double_t rmax1,; Double_t rmin2,Double_t rmax2,Double_t phi1,Double_t phi2);; ```. Parameters` phi1` and `phi2` have the same",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:34794,Integrability,rout,rout,34794,"f revolution about Z axis (inner and outer surfaces). The; class describing hyperboloids is **`TGeoHype`** has 5 input parameters:. ``` {.cpp}; TGeoHype(Double_t rin,Double_t stin,Double_t rout,; Double_t stout,Double_t dz);; ```. ![TGeoHype Class](pictures/080001C1.png). The hyperbolic surface equation is taken in the form:. ``` {.cpp}; r2 - z2tan2() = r2min; ```. - `r,z:` cylindrical coordinates for a point on the surface; - `:` stereo angle between the hyperbola asymptotic lines and Z axis; - `r2min:` minimum distance between hyperbola and Z axis (at `z=0`). The input parameters represent:. - `rin, stin:` minimum radius and tangent of stereo angle for inner; surface; - `rout, stout:` minimum radius and tangent of stereo angle for outer; surface; - `dz:` half length in Z (bounding planes positions at `+/-dz`). The following conditions are mandatory in order to avoid intersections; between the inner and outer hyperbolic surfaces in the range `+/-dz`:. - `rin<rout`; - `rout>0`; - `rin2 + dz2*stin2 > rout2 + dz2*stout2`. Particular cases:. - `rin=0, stin0:` the inner surface is conical; - `stin=0 / stout=0:` cylindrical surface(s). #### Cones - TGeoCone Class. The cones are defined by 5 parameters:. ``` {.cpp}; TGeoCone(Double_t dz,Double_t rmin1,Double_t rmax1,; Double_t rmin2,Double_t rmax2);; ```. - `rmin1:` internal radius at Z is `-dz`; - `rmax1:` external radius at Z is `-dz`; - `rmin2:` internal radius at Z is `+dz`; - `rmax2:` external radius at Z is `+dz`; - `dz:` half length in Z (a cone ranges from `-dz` to +`dz`). A cone has Z-axis as its symmetry axis. ![TGeoCone Class](pictures/060001C2.png). #### Cone Segments - TGeoConeSeg Class. A cone segment is a cone having a range in `phi.` The cone segment class; derives from **`TGeoCone`**, having two extra parameters: `phi1` and; `phi2`. ``` {.cpp}; TGeoConeSeg(Double_t dz,Double_t rmin1,Double_t rmax1,; Double_t rmin2,Double_t rmax2,Double_t phi1,Double_t phi2);; ```. Parameters` phi1` and `phi2` have the same",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:44358,Integrability,interface,interface,44358,"n this style is virtually possible but; highly not recommended. #### The Structure of Composite Shapes. A composite shape can always be looked as the result of a Boolean; operation between only two shape components. All information identifying; these two components as well as their positions with respect to the; frame of the composite is represented by an object called Boolean node.; A composite shape has a pointer to such a Boolean node. Since the shape; components may also be composites, they will also contain binary Boolean; nodes branching out other two shapes in the hierarchy. Any such branch; ends-up when the final leaves are no longer composite shapes, but basic; primitives. The figure shows the composite shapes structure. ![The composite shapes structure](pictures/080001CA.png). Suppose that A, B, C and D represent basic shapes, we will illustrate; how the internal representation of few combinations look like. We do; this only for understanding how to create them in a proper way, since; the user interface for this purpose is in fact very simple. We will; ignore for the time being the positioning of components. The definition; of a composite shape takes an expression where the identifiers are shape; names. The expression is parsed and decomposed in 2 sub-expressions and; the top-level Boolean operator. 1. Union: `A+B+C`. Just to illustrate the Boolean expression parsing and the composite; shape structure, let's take a simple example. We will describe the union; of A, B and C. Both union operators are at the same level. Since:. `A+B+C = (A+B)+C = A+(B+C)`. The first` (+)` is taken as separator, hence the expression split in:; `A` and `(B+C)`. A Boolean node of type **`TGeoUnion`**`(""A"",""B+C"")` is; created. This tries to replace the 2 expressions by actual pointers to; corresponding shapes. The first expression (A) contains no operators; therefore is interpreted as representing a shape. The shape named ""A"" is; searched into the list of shapes handled by the man",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:85487,Integrability,message,message,85487," - `1, 2, 3 mean X, Y, Z; for `tube`, `tubs`, `cone`,; `cons - `1 means `Rxy`, 2 means `phi` and 3 means Z; for `pcon` and; `pgon` - 2 means `phi` and 3 means Z; for spheres 1 means `R `and 2; means `phi.`. In fact, the division operation has the same effect as positioning; volumes in a given order inside the divided container - the advantage; being that the navigation in such a structure is much faster. When a; volume is divided, a volume family corresponding to the slices is; created. In case all slices can be represented by a single shape, only; one volume is added to the family and positioned N times inside the; divided volume, otherwise, each slice will be represented by a distinct; volume in the family. Divisions can be also performed in a given range of one axis. For that,; one has to specify also the starting coordinate value and the step:. ``` {.cpp}; TGeoVolume *slicex = box->Divide(""SLICEX"",1,N,start,step);; ```. A check is always done on the resulting division range: if not fitting; into the container limits, an error message is posted. If we will browse; the divided volume we will notice that it will contain N nodes starting; with index 1 up to N. The first one has the lower X limit at `START`; position, while the last one will have the upper X limit at; `START+N*STEP`. The resulting slices cannot be positioned inside another; volume (they are by default positioned inside the divided one) but can; be further divided and may contain other volumes:. ``` {.cpp}; TGeoVolume *slicey = slicex->Divide(""SLICEY"",2,N1);; slicey->AddNode(other_vol,index,some_matrix);; ```. When doing that, we have to remember that `SLICEY` represents a family,; therefore all members of the family will be divided on Y and the other; volume will be added as node inside all. In the example above all the resulting slices had the same shape as the; divided volume (box). This is not always the case. For instance,; dividing a volume with `TUBE` shape on `PHI `axis will create equal; slice",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:94434,Integrability,interface,interface,94434,"y}; \right|$. - $r_{ij}$ are the 3x3 rotation matrix components; - $t_x$,$t_y$,$t_z$ are the translation components; - $s_x$, $s_y$, $s_z$ are arbitrary scale constants on each axis. The disadvantage in using this approach is that computation for 4x4; matrices is expensive. Even combining two translations would become a; multiplication of their corresponding matrices, which is quite an; undesired effect. On the other hand, it is not a good idea to store a; translation as a block of 16 numbers. We have therefore chosen to; implement each basic transformation type as a class deriving from the; same basic abstract class and handling its specific data and; point/vector transformation algorithms. The base class **`TGeoMatrix`** defines abstract methods for:. - Translation, rotation and scale getters. Every derived class stores; only its specific data, e.g. a translation stores an array of 3; doubles and a rotation an array of 9. However, getting the; **`TGeoTranslation`** rotation array through the base; **`TGeoMatrix`** interface is a legal operation. The answer in this; case is a pointer to a global constant array representing an; identity rotation. ``` {.cpp}; Double_t *TGeoMatrix::GetTranslation() const;; Double_t *TGeoMatrix::GetRotation() const;; Double_t *TGeoMatrix::GetScale() const;; ```. - Master-to-local and local-to-master point and vector transformations; :. ``` {.cpp}; void TGeoMatrix::MasterToLocal(const Double_t *master,; Double_t *local); void TGeoMatrix::LocalToMaster(const Double_t *local,; Double_t *master); void TGeoMatrix::MasterToLocalVect(const Double_t *master,; Double_t *local); void TGeoMatrix::LocalToMasterVect(const Double_t *local,; Double_t *master); ```. Here `master` and `local` are arrays of size 3. These methods allow; correct conversion also for reflections. - Transformation type finding:. ``` {.cpp}; Bool_t TGeoMatrix::IsIdentity() const;; Bool_t TGeoMatrix::IsTranslation() const;; Bool_t TGeoMatrix::IsRotation() const;; Bool_t TGeoMa",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:98410,Integrability,message,message,98410," added or subtracted. ``` {.cpp}; TGeoTranslation t1;; t1->SetTranslation(-5,10,4);; TGeoTranslation *t2 = new TGeoTranslation(4,3,10);; t2->Subtract(&t1);; ```. - Rotations (**`TGeoRotation`** class) represent a pure rotation. Data; members are `Double_t fRotationMatrix[3*3]`. Rotations can be; defined either by Euler angles, either, by GEANT3 angles:. ``` {.cpp}; TGeoRotation *r1 = new TGeoRotation();; r1->SetAngles(phi,theta,psi); // all angles in degrees; ```. This represents the composition of: first a rotation about Z axis with; angle phi, then a rotation with theta about the rotated X axis, and; finally a rotation with `psi `about the new Z axis. ``` {.cpp}; r1->SetAngles(th1,phi1,th2,phi2,th3,phi3); ```. This is a rotation defined in GEANT3 style. Theta and phi are the; spherical angles of each axis of the rotated coordinate system with; respect to the initial one. This construction allows definition of; malformed rotations, e.g. not orthogonal. A check is performed and an; error message is issued in this case. Specific utilities: determinant, inverse. - Scale transformations (**`TGeoScale`** class) - represent a scaled; shrinking/enlargement, possibly different on all axes. Data members:; `Double_t fScale[3]`. Not implemented yet.; - Combined transformations - represent a rotation followed by a; translation. Data members:; `Double_t fTranslation[3], `**`TGeoRotation *fRotation`.**. ``` {.cpp}; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;; ...; TGeoCombiTrans *c1 = new TGeoCombiTrans(trans,rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot); ```. - General transformations: (**`TGeoHMatrix`** class) represent; combined transformations in any order.; - Identity transformation: (**`TGeoIdentity`** class) is a generic; identity transformation represented by a singleton class object; **`gGeoIdentity`**. ### Ownership of Geometry Objects. The class **`TGeoManager`** class contains the entire API needed for; build",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:101728,Integrability,interface,interface,101728,"inter`** client). This; is linked with ROOT graphical libraries loaded on demand in order to; control visualization actions. ## Navigation and Tracking. Tracking is the feature allowing the transport of a given particle; knowing its kinematics. A state is determined by any combination of the; position $\vec{r}$ and direction $\vec{n}$ with respect to the world; reference frame. The direction $\vec{n}$ must be a unit vector having as; components the director cosines. The full classification of a given; state will provide the following information: the deepest physical node; containing the position vector, the distance to the closest boundary; along the direction vector, the next physical node after propagating the; current point with this distance and the safety distance to the nearest; boundary. This information allows the propagation of particles inside a; detector geometry by taking into account both geometrical and physical; constraints. We will hereby describe the user interface of **`TGeo`** to access; tracking functionality. This allows either developing a tracker for; simple navigation within a given geometry, either interfacing to an; external tracking engine such as GEANT. Note that the abstract interface; for external trackers can be found in `$ROOTSYS/vmc` folder and it can; be used to run GEANT3, GEANT4 and FLUKA-based simulations (\*) by using; directly a geometry described with ROOT. The interface methods related to tracking are incorporated into; **`TGeoManager`** class and implemented in the navigator class; **`TGeoNavigator`**. In order to be able to start tracking, one has to; define the initial state providing the starting point $\vec{r_0}$; and direction $\vec{n_0}$ .; There are several ways of doing that. ### TGeoNavigator Class. One geometry may have several independent navigators to query to; localize points or compute distances. The geometry manager holds a list; of active navigators accessible via:. ``` {.cpp}; TObjArray *navigators = gGeoMa",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:101964,Integrability,interface,interface,101964,"}$ and direction $\vec{n}$ with respect to the world; reference frame. The direction $\vec{n}$ must be a unit vector having as; components the director cosines. The full classification of a given; state will provide the following information: the deepest physical node; containing the position vector, the distance to the closest boundary; along the direction vector, the next physical node after propagating the; current point with this distance and the safety distance to the nearest; boundary. This information allows the propagation of particles inside a; detector geometry by taking into account both geometrical and physical; constraints. We will hereby describe the user interface of **`TGeo`** to access; tracking functionality. This allows either developing a tracker for; simple navigation within a given geometry, either interfacing to an; external tracking engine such as GEANT. Note that the abstract interface; for external trackers can be found in `$ROOTSYS/vmc` folder and it can; be used to run GEANT3, GEANT4 and FLUKA-based simulations (\*) by using; directly a geometry described with ROOT. The interface methods related to tracking are incorporated into; **`TGeoManager`** class and implemented in the navigator class; **`TGeoNavigator`**. In order to be able to start tracking, one has to; define the initial state providing the starting point $\vec{r_0}$; and direction $\vec{n_0}$ .; There are several ways of doing that. ### TGeoNavigator Class. One geometry may have several independent navigators to query to; localize points or compute distances. The geometry manager holds a list; of active navigators accessible via:. ``` {.cpp}; TObjArray *navigators = gGeoManager->GetListOfNavigators();; ```. Upon closing the geometry a default navigator is provided as first one; in this list, but one may add its own via:. ``` {.cpp}; TGeoNavigator *navig = new TGeoNavigator(gGeoManager);; // Store the index of the user navigator; Int_t inav = gGeoManager->AddNavigator(navig);; ",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:102165,Integrability,interface,interface,102165,"of a given; state will provide the following information: the deepest physical node; containing the position vector, the distance to the closest boundary; along the direction vector, the next physical node after propagating the; current point with this distance and the safety distance to the nearest; boundary. This information allows the propagation of particles inside a; detector geometry by taking into account both geometrical and physical; constraints. We will hereby describe the user interface of **`TGeo`** to access; tracking functionality. This allows either developing a tracker for; simple navigation within a given geometry, either interfacing to an; external tracking engine such as GEANT. Note that the abstract interface; for external trackers can be found in `$ROOTSYS/vmc` folder and it can; be used to run GEANT3, GEANT4 and FLUKA-based simulations (\*) by using; directly a geometry described with ROOT. The interface methods related to tracking are incorporated into; **`TGeoManager`** class and implemented in the navigator class; **`TGeoNavigator`**. In order to be able to start tracking, one has to; define the initial state providing the starting point $\vec{r_0}$; and direction $\vec{n_0}$ .; There are several ways of doing that. ### TGeoNavigator Class. One geometry may have several independent navigators to query to; localize points or compute distances. The geometry manager holds a list; of active navigators accessible via:. ``` {.cpp}; TObjArray *navigators = gGeoManager->GetListOfNavigators();; ```. Upon closing the geometry a default navigator is provided as first one; in this list, but one may add its own via:. ``` {.cpp}; TGeoNavigator *navig = new TGeoNavigator(gGeoManager);; // Store the index of the user navigator; Int_t inav = gGeoManager->AddNavigator(navig);; // Make its own navigator the active one; gGeoManager->SetCurrentNavigator(inav);; // Switch between navigators; gGeoManager->SetCurrentNavigator(0);; ```. A navigator holds several var",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:103918,Integrability,interface,interfaced,103918,"`` {.cpp}; TGeoNavigator *navig = new TGeoNavigator(gGeoManager);; // Store the index of the user navigator; Int_t inav = gGeoManager->AddNavigator(navig);; // Make its own navigator the active one; gGeoManager->SetCurrentNavigator(inav);; // Switch between navigators; gGeoManager->SetCurrentNavigator(0);; ```. A navigator holds several variables describing the current navigation; state: current point position, current direction distance to next; boundary, isotropic safety, pointer to current and next nods as well as; several tracking flags related to volume boundary conditions or other; properties required for track propagation in geometry. Each geometry; query affects these variables, so the only way in testing several; navigation alternatives and remembering the active navigation state is; to use parallel navigation. The following paragraphs will describe the; usage of a single navigator. All setters/getters for navigation state; parameters as well as navigation queries provided by **`TGeoNavigator`**; are interfaced by **`TGeoManager`** and will act on the current; navigator. ### Initializing the Starting Point. The current point (`x,y,z`) known by the modeller is stored as; `Double_t fCurrentPoint[3]` by the navigator class. This array of the; three coordinates is defined in the current global reference system and; can be retrieved any time:. ``` {.cpp}; Const Double_t *cpoint = gGeoManager->GetCurrentPoint();; ```. Initializing this point can be done like:. ``` {.cpp}; gGeoManager->SetCurrentPoint(x,y,z);; // or:; gGeoManager->SetCurrentPoint(Double_t *point[3]);; ```. ### Initializing the Direction. In order to move inside geometry starting with the current point, the; modeller needs to know the current direction `(nx,ny,nz)`. This; direction is stored as `Double_t fCurrentDirection[3]` by the navigator; and it represents a direction in the global frame. It can be retrieved; with:. ``` {.cpp}; Const Double_t *cdir = gGeoManager->GetCurrentDirection();; ```. T",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:107502,Integrability,interface,interface,107502,"p}; gGeoManager->FindNode();; ```. In order to have more flexibility, there are in fact several alternative; ways of initializing a modeller state:. ``` {.cpp}; // Setting the point and finding the state in one step:; gGeoManager->FindNode(Double_t x,Double_t y,Double_t z);; gGeoManager->FindNode(Double_t *point[3]);; // Setting both initial point and direction and finding the state:; gGeoManager->InitTrack(Double_t x,Double_t y,Double_t z,; Double_t nx, Double_t ny, Double_t nz);; gGeoManager->InitTrack(Double_t *point[3],Double_t *dir[3]);; ```. Note that the current point coordinates can be changed and the state; re-initialized at any time. This represents the `‘Where am I?'`; geometrical query representing the basic navigation functionality; provided by the modeller. ### Checking the Current State. The current state and all variables related to this are essential during; tracking and have to be checked several times. Besides the current point; and direction, the following additional information can be retrieved; from **`TGeoManager`** interface:. - The `current path`. This represents a string containing the names; and copy numbers of all positioned objects in the current `branch`; written in the /folder/folder/.../folder/file fashion. The final node; pointed by the path is the deepest object containing the current; point and is representative for the current state. All intermediate; `folders` in the path are in fact also nodes ""touched"" by the; current point, but having some ""touched"" containment. The current; path can be retrieved only after the state was initialized and is; useful for getting an idea of the current point location. ``` {.cpp}; const char *path = gGeoManager->GetPath();; cout << ""Current path is: "" << path << endl;; /A_1/B_34/C_3/D_1; ```. - The `current node`***`, `***`volume` and `material`. In order to; take decisions on post-step or further stepping actions, one has to; know these. In order to get a pointer to the current node one can; do:. ",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:111944,Integrability,interface,interfaces,111944,"rent node for 2 different states. The; numbering order of states is therefore not important, but it can be; used as in the following lines:. ``` {.cpp}; gGeoManager->InitTrack(pt,dir); // anything to initialize a state; Int_t istate = gGeoManager->GetCurrentNodeId(); // in fact state Id; {; //... code changing the current state; }; gGeoManager->CdNode(istate); // forces state's re-initialization; ```. - Current `global transformation`. This represents the transformation; from `MARS` to the local reference of the current node, being the; product of all local mother-daughter transformations in the branch.; The global transformation can be referenced or copied:. ``` {.cpp}; const TGeoHMatrix *global = gGeoManager->GetCurrentMatrix();; TGeoHMatrix *copy = new TGeoHMatrix(*global);; ```. - One often needs to perform `master-to-local` and `local-to-master`; point and vector conversions to get from `MARS` to the local node; coordinates. This can be done by using the global transformation or; directly the **`TGeoManager`** corresponding interfaces:. ``` {.cpp}; Double_t *glob_pt = gGeoManager->GetCurrentPoint();; Double_t *glob_dir = gGeoManager->GetCurrentDirection();; Double_t loc_pt[3], loc_dir[3];; // Go from MARS to local coordinates:; gGeoManager->MasterToLocal(glob_pt,loc_pt); // or:; global->MasterToLocal(glob_pt,loc_pt); // will be omitted from now; ```. ### Saving and Restoring the Current State. As we already described, saving and restoring modeller states can be; quite useful during tracking and is a feature extensively used by; external tracking engines. We will call this navigation history; management, which in most of the cases can be performed by handling the; state identifiers. For quite big geometries, state indexing is not; possible anymore and will be automatically disabled by the modeller.; Fortunately there is a backup solution working in any condition: the; modeller maintains a stack of states that is internally used by its own; navigation algorithms,",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:124300,Integrability,interface,interfaced,124300,"direction crosses the surface. ``` {.cpp}; Double_t *TGeoManager::FindNormal(Bool_t forward=kTRUE);; ```. The method above computes the normal to the next crossed surface in; forward or backward direction (i.e. the current one), assuming the state; corresponding to a current arbitrary point is initialized. An example of; usage of normal computation is ray tracing. The two most important features of the geometrical modeller concerning; tracking are scalability and performance as function of the total number; of physical nodes. The first refers to the possibility to make use of; the available memory resources and at the same time be able to resolve; any geometrical query, while the second defines the capability of the; modeller to respond quickly even for huge geometries. These parameters; can become critical when simulating big experiments like those at LHC. ### Creating and Visualizing Tracks. In case the modeller is interfaced with a tracking engine, one might; consider quite useful being able to store and visualize at least a part; of the tracks in the context of the geometry. The base class; **`TVirtualGeoTrack`** provides this functionality. It currently has one; implementation inside the drawing package (**`TGeoTrack`** class). A; track can be defined like:. ``` {.cpp}; TVirtualGeoTrack(Int_t id,Int_t pdg,TVirtualGeoTrack *parent=0,; TObject *particle=0);; ```. Where: `id` is user-defined id of the track, `pdg` - `pdg` code,; `parent` - a pointer to parent track, `particle` - a pointer to an; arbitrary particle object (may be a **`TParticle`**). A track has a list of daughters that have to be filled using the; following method:. ``` {.cpp}; TVirtualGeoTrack *TVirtualGeoTrack::AddDaughter(Int_t id,Int_t pdg,; TObject *particle=0);; ```. The method above is pure virtual and have to create a track daughter; object. Tracks are fully customizable objects when inheriting from; **`TVirtualGeoTrack`** class. We will describe the structure and; functionality provided by ",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:130921,Integrability,depend,dependent,130921,"side a volume have to be also contained by the; mother therefore are overlapping in that sense. This category of; overlaps is ignored due to the fact that any such point is treated as; belonging to the deepest node in the hierarchy. ![Extruding volumes](pictures/030001DE.png). A volume containment region is in fact the result of the subtraction of; all daughters. On the other hand, there are two other categories of; overlaps that are considered illegal since they lead to unpredictable; results during tracking. A) If a positioned volume contains points that are not also contained; by its mother, we will call the corresponding region as an `extrusion`.; When navigating from outside to inside (trying to enter such a node); these regions are invisible since the current track has not yet reached; its mother. This is not the case when going the other way since the; track has first to exit the extruding node before checking the mother.; In other words, an extrusion behavior is dependent on the track; parameters, which is a highly undesirable effect. B) We will call ***`overlaps`*** only the regions in space contained by; more than one node inside the same container. The owner of such regions; cannot be determined based on hierarchical considerations; therefore; they will be considered as belonging to the node from which the current; track is coming from. When coming from their container, the ownership is totally; unpredictable. Again, the ownership of overlapping regions highly; depends on the current track parameters. We must say that even the overlaps of type A) and B) are allowed in case; the corresponding nodes are created using; **`TGeoVolume`**`::AddNodeOverlap()` method. Navigation is performed in such; cases by giving priority to the non-overlapping nodes. The modeller has; to perform an additional search through the overlapping candidates.; These are detected automatically during the geometry closing procedure; in order to optimize the algorithm, but we will stres",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:131433,Integrability,depend,depends,131433," results during tracking. A) If a positioned volume contains points that are not also contained; by its mother, we will call the corresponding region as an `extrusion`.; When navigating from outside to inside (trying to enter such a node); these regions are invisible since the current track has not yet reached; its mother. This is not the case when going the other way since the; track has first to exit the extruding node before checking the mother.; In other words, an extrusion behavior is dependent on the track; parameters, which is a highly undesirable effect. B) We will call ***`overlaps`*** only the regions in space contained by; more than one node inside the same container. The owner of such regions; cannot be determined based on hierarchical considerations; therefore; they will be considered as belonging to the node from which the current; track is coming from. When coming from their container, the ownership is totally; unpredictable. Again, the ownership of overlapping regions highly; depends on the current track parameters. We must say that even the overlaps of type A) and B) are allowed in case; the corresponding nodes are created using; **`TGeoVolume`**`::AddNodeOverlap()` method. Navigation is performed in such; cases by giving priority to the non-overlapping nodes. The modeller has; to perform an additional search through the overlapping candidates.; These are detected automatically during the geometry closing procedure; in order to optimize the algorithm, but we will stress that extensive; usage of this feature leads to a drastic deterioration of performance.; In the following we will focus on the non-declared overlaps of type A); and B) since this is the main source of errors during tracking. These; are generally non-intended overlaps due to coding mistakes or bad; geometry design. The checking package is loaded together with the; painter classes and contains an automated overlap checker.**. ![Overlap checking](pictures/030001DF.png). This can be activa",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:153643,Integrability,depend,depending,153643,"eve the geometry in a ready state, ignoring what the state; variables that can be always re-initialized. When the code is generated; for a given **`TGeoVolume`** in the geometry, just the branch starting; with that volume will be saved in the file. Executing the generated code; will create a geometry that has `MyVolume` as top volume. In this case,; only the materials/media/matrices used effectively in the `MyVolume`; branch are exported to file. Volumes can be made persistent in the same way the full geometry is.; Exporting is straightforward (module1, 2 are pointers to; **`TGeoVolume`** objects):. ``` {.cpp}; module1->Export(""file.root"");; // by default file is overwritten; module2->Export(""file.root"","""",""update"");; // to the same file; ```. Importing will append the volume to the current TGeoManager or will; create one:. ``` {.cpp}; TGeoManager *geom = new TGeoManager(""myGeom"", """");; TGeoVolume *top = geom->MakeBox(...);; geom->SetTopVolume(top);; //name of volume or key (depending on export usage); TGeoVolume *module1 = TGeoVolume::Import(""file.root"", ""MOD1"");; TGeoVolume *module2 = TGeoVolume::Import(""file.root"", ""MOD2"");; top->AddNode(module1, 1, new TGeoTranslation(0,0,100));; top->AddNode(module2, 1, new TGeoTranslation(0,0,-100));; // One should close oneself the geometry; geom->CloseGeometry();; ```. ### GDML. Few lines above word GDML was used. GDML stands for **G**eometry; **D**escription **M**arkup **L**anguage. It is an application-independent; geometry description format based on XML. It is mainly used for geometry; interchange between ROOT and Geant4 framework. More details about this; project can be found http://gdml.web.cern.ch. This feature; (importing/exporting from/to gdml file format) is disabled by default in; ROOT installation. To enable this feature add `--enable-gdml` option to; `./configure` script call. ## Navigation Algorithms. This section will describe the main methods and algorithms used for; implementing the navigation features withi",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:165496,Integrability,interface,interface,165496,"rrentDirection();; for (Int_t i=0; i<3; i++); current_point[i] += step * current_dir[I];; ```. Note: The method `TGeoManager::FindNextBoundary()` does not modify the; current point/direction nor the current volume/state. The returned node; is the next crossed one, but the physical path (state) AFTER crossing; the boundary is not determined. In order to find out this new state, one; has to propagate the point with a distance slightly bigger that the; computed step value (which is accurate within numerical precision). A; method that performs this task finding the next location is; `TGeoManager::Step()`, described in "" Making a Step "", but users may; implement more precise methods to insure post-step boundary crossing. ## Geometry Graphical User Interface. The geombuilder package allows you to create and edit geometries. The; package provides a library of all GUI classes related to geometry. Each; editable geometry class **`TGeoXXX`** have a correspondent editor; **`TGeoXXXEditor`** that provides a graphics user interface allowing to; edit some (or all) parameters of a geometry object. The editable objects; are geometry manager, volumes, nodes, shapes, media, materials and; matrices. The interfaces provide also access to specific functionality; of geometry objects. The editing mechanism is based on ROOT GED; (Graphics Editors) functionality and the library is loaded using the; plug-in mechanism. ### Editing a Geometry. There are two different use cases having different ways of invoking the; geometry editors. The first one applies when starting with geometry from; scratch and using the builder functionality to create new geometry; objects. In this case, one should use the sequence:. ``` {.cpp}; root[] TGeoManager *geom = new TGeoManager(""MyGeom"",; ""Test builder"");; root[] geom->Edit(Option_t *option="""");; ```. The lines above will create a new **`TGeoManager`** class, create an; empty canvas and start the editor in the left-sided editor frame; attached to the canvas. To",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:165675,Integrability,interface,interfaces,165675,"is the next crossed one, but the physical path (state) AFTER crossing; the boundary is not determined. In order to find out this new state, one; has to propagate the point with a distance slightly bigger that the; computed step value (which is accurate within numerical precision). A; method that performs this task finding the next location is; `TGeoManager::Step()`, described in "" Making a Step "", but users may; implement more precise methods to insure post-step boundary crossing. ## Geometry Graphical User Interface. The geombuilder package allows you to create and edit geometries. The; package provides a library of all GUI classes related to geometry. Each; editable geometry class **`TGeoXXX`** have a correspondent editor; **`TGeoXXXEditor`** that provides a graphics user interface allowing to; edit some (or all) parameters of a geometry object. The editable objects; are geometry manager, volumes, nodes, shapes, media, materials and; matrices. The interfaces provide also access to specific functionality; of geometry objects. The editing mechanism is based on ROOT GED; (Graphics Editors) functionality and the library is loaded using the; plug-in mechanism. ### Editing a Geometry. There are two different use cases having different ways of invoking the; geometry editors. The first one applies when starting with geometry from; scratch and using the builder functionality to create new geometry; objects. In this case, one should use the sequence:. ``` {.cpp}; root[] TGeoManager *geom = new TGeoManager(""MyGeom"",; ""Test builder"");; root[] geom->Edit(Option_t *option="""");; ```. The lines above will create a new **`TGeoManager`** class, create an; empty canvas and start the editor in the left-sided editor frame; attached to the canvas. To open the editor in a separate frame one; should provide a non-empty string as option to the `Edit()` method. ![The geometry manager editor](pictures/030001E9.png). ### The Geometry Manager Editor. ![Accessing/creating different categories o",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:167714,Integrability,interface,interface,167714,"ing different; categories of editable objects](pictures/020001EB.jpg); ![Accessing/creating different categories of editable; objects](pictures/020001EC.jpg) ![Accessing/creating different; categories of editable objects](pictures/020001ED.jpg); ![Accessing/creating different categories of editable; objects](pictures/020001EE.jpg). The second use case applies when starting to edit an existing geometry.; Supposing the geometry was loaded into memory, besides the first method; that still applies one can also edit drawn geometry objects. For this,; the menu entry View/Editor of the canvas containing for instance a drawn; volume must be activated. For starting the volume editor one can click; on a volume. The GUI of the **`TGeoManager`** class can be started by; clicking on the top-right `40x40` pixels corner of the pad with a drawn; geometry. This is the main entry point for editing the geometry or creating new; objects. Once the interface is created (using one of the methods; described above), several categories can be accessed via a shutter GUI; widget:. - *General.* This allows changing the name/title of the geometry,; setting the top volume, closing the geometry and saving the geometry; in a file. The file name is formed by `geometry_name.C` or `.root`; depending if the geometry need to be saved as a `C` macro or a; `.root` file.; - *Shapes.* The category provides buttons for creation of all; supported shapes. The new shape name is chosen by the interface, but; can be changed from the shape editor GUI. Existing shapes can be; browsed and edited from the same category.; - *Volumes.* The category allows the creation of a new volume having a; given name, shape and medium. For creating a volume assembly only; the name is relevant. Existing volumes can be browsed or edited from; this category.; - *Materials.* Allows creation of new materials/mixtures or editing; existing ones.; - *Media.* The same for creation/editing of tracking media (materials; having a set of proper",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:168048,Integrability,depend,depending,168048,"ects](pictures/020001EE.jpg). The second use case applies when starting to edit an existing geometry.; Supposing the geometry was loaded into memory, besides the first method; that still applies one can also edit drawn geometry objects. For this,; the menu entry View/Editor of the canvas containing for instance a drawn; volume must be activated. For starting the volume editor one can click; on a volume. The GUI of the **`TGeoManager`** class can be started by; clicking on the top-right `40x40` pixels corner of the pad with a drawn; geometry. This is the main entry point for editing the geometry or creating new; objects. Once the interface is created (using one of the methods; described above), several categories can be accessed via a shutter GUI; widget:. - *General.* This allows changing the name/title of the geometry,; setting the top volume, closing the geometry and saving the geometry; in a file. The file name is formed by `geometry_name.C` or `.root`; depending if the geometry need to be saved as a `C` macro or a; `.root` file.; - *Shapes.* The category provides buttons for creation of all; supported shapes. The new shape name is chosen by the interface, but; can be changed from the shape editor GUI. Existing shapes can be; browsed and edited from the same category.; - *Volumes.* The category allows the creation of a new volume having a; given name, shape and medium. For creating a volume assembly only; the name is relevant. Existing volumes can be browsed or edited from; this category.; - *Materials.* Allows creation of new materials/mixtures or editing; existing ones.; - *Media.* The same for creation/editing of tracking media (materials; having a set of properties related to tracking); - *Matrices.* Allows creation of translations, rotations or combined; transformations. Existing matrices can also be browser/edited. ### Editing Existing Objects. For editing an existing object from one of the categories described; above, the interface imposes first a selection",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:168244,Integrability,interface,interface,168244,"hat still applies one can also edit drawn geometry objects. For this,; the menu entry View/Editor of the canvas containing for instance a drawn; volume must be activated. For starting the volume editor one can click; on a volume. The GUI of the **`TGeoManager`** class can be started by; clicking on the top-right `40x40` pixels corner of the pad with a drawn; geometry. This is the main entry point for editing the geometry or creating new; objects. Once the interface is created (using one of the methods; described above), several categories can be accessed via a shutter GUI; widget:. - *General.* This allows changing the name/title of the geometry,; setting the top volume, closing the geometry and saving the geometry; in a file. The file name is formed by `geometry_name.C` or `.root`; depending if the geometry need to be saved as a `C` macro or a; `.root` file.; - *Shapes.* The category provides buttons for creation of all; supported shapes. The new shape name is chosen by the interface, but; can be changed from the shape editor GUI. Existing shapes can be; browsed and edited from the same category.; - *Volumes.* The category allows the creation of a new volume having a; given name, shape and medium. For creating a volume assembly only; the name is relevant. Existing volumes can be browsed or edited from; this category.; - *Materials.* Allows creation of new materials/mixtures or editing; existing ones.; - *Media.* The same for creation/editing of tracking media (materials; having a set of properties related to tracking); - *Matrices.* Allows creation of translations, rotations or combined; transformations. Existing matrices can also be browser/edited. ### Editing Existing Objects. For editing an existing object from one of the categories described; above, the interface imposes first a selection among all objects of the; corresponding type stored in the geometry. This can be done by clicking; the button next to the blue label *Select \<object\>*. The dialog; interface",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:169043,Integrability,interface,interface,169043,"ing if the geometry need to be saved as a `C` macro or a; `.root` file.; - *Shapes.* The category provides buttons for creation of all; supported shapes. The new shape name is chosen by the interface, but; can be changed from the shape editor GUI. Existing shapes can be; browsed and edited from the same category.; - *Volumes.* The category allows the creation of a new volume having a; given name, shape and medium. For creating a volume assembly only; the name is relevant. Existing volumes can be browsed or edited from; this category.; - *Materials.* Allows creation of new materials/mixtures or editing; existing ones.; - *Media.* The same for creation/editing of tracking media (materials; having a set of properties related to tracking); - *Matrices.* Allows creation of translations, rotations or combined; transformations. Existing matrices can also be browser/edited. ### Editing Existing Objects. For editing an existing object from one of the categories described; above, the interface imposes first a selection among all objects of the; corresponding type stored in the geometry. This can be done by clicking; the button next to the blue label *Select \<object\>*. The dialog; interfaces are generally different for different types of objects. The; volume selection dialog offers the possibility to select either a volume; already connected to the geometry hierarchy or non-connected ones.; Selection for shapes and matrices is split into categories represented; by top-level list tree items for: boxes, tubes, translations, rotations,; etc. ![Selection dialogs for different TGeo objects](pictures/030001EF.png). Once a selection is made and the dialog is closed, the selected item; name will appear in the corresponding label and the button Edit will; start the object editor in a transient frame. Closing these transient; frames will not delete, but just hide existing opened editors for later; reuse. Their lifetime is determined by the canvas to which the manager; editor is attache",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:169245,Integrability,interface,interfaces,169245,"ged from the shape editor GUI. Existing shapes can be; browsed and edited from the same category.; - *Volumes.* The category allows the creation of a new volume having a; given name, shape and medium. For creating a volume assembly only; the name is relevant. Existing volumes can be browsed or edited from; this category.; - *Materials.* Allows creation of new materials/mixtures or editing; existing ones.; - *Media.* The same for creation/editing of tracking media (materials; having a set of properties related to tracking); - *Matrices.* Allows creation of translations, rotations or combined; transformations. Existing matrices can also be browser/edited. ### Editing Existing Objects. For editing an existing object from one of the categories described; above, the interface imposes first a selection among all objects of the; corresponding type stored in the geometry. This can be done by clicking; the button next to the blue label *Select \<object\>*. The dialog; interfaces are generally different for different types of objects. The; volume selection dialog offers the possibility to select either a volume; already connected to the geometry hierarchy or non-connected ones.; Selection for shapes and matrices is split into categories represented; by top-level list tree items for: boxes, tubes, translations, rotations,; etc. ![Selection dialogs for different TGeo objects](pictures/030001EF.png). Once a selection is made and the dialog is closed, the selected item; name will appear in the corresponding label and the button Edit will; start the object editor in a transient frame. Closing these transient; frames will not delete, but just hide existing opened editors for later; reuse. Their lifetime is determined by the canvas to which the manager; editor is attached to, since these will be destroyed together. ![Editors for shapes, materials, media, matrices](pictures/020001F0.jpg); ![Editors for shapes, materials, media, matrices](pictures/020001F1.jpg); ![Editors for shapes, m",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:171961,Integrability,depend,depend,171961,"his version the ""*Undo*"" does not allow restoring an; intermediate state of the parameters that was applied - it will always; restore the parameters at the moment the shape was edited. All material properties changes are undoable. The mixture editor; currently allows adding elements one by one in the mixture composition.; This can be done either by element weight fraction or by number of; atoms. Once an element was added using one method the other method is not; selectable anymore. Summing component fractions up to 1 in the final; mixture is the user responsibility. Adding materials as components of a; mixture is not supported in this version. The elements that were added to the mixture appear in the bottom of the; mixture editor. The operations performed on mixture are not undoable. ### Creation of New Objects. As described above, all geometry object creators are accessible within; the geometry manager editor frame. Generally, if the new object that; needs to be created does not depend on other objects, it will be built; with a set of default parameters. This is the case for all shapes; (except composite shapes) and matrices. For all the other objects the; interface forces the selection of components before creating the object. ### Editing Volumes. Volumes are hierarchical components in the geometry, therefore their; editor is more complex. It provides the following functionalities:. - *General*. This category allows changing the name of the volume and; selecting other shape or medium among existing ones. - *Daughters*. The category allows removing existing daughter nodes or; adding new ones. The button ""*Position*"" allows editing the; positioning matrix of a given node. ![Setting volume properties and modifying volume hierarchy](pictures/020001F5.jpg); ![Setting volume properties and modifying volume hierarchy](pictures/020001F6.jpg). - *Visualization*. This category allows changing the visibility of the; edited volume or for its daughters, as well as other visuali",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:172142,Integrability,interface,interface,172142,"l properties changes are undoable. The mixture editor; currently allows adding elements one by one in the mixture composition.; This can be done either by element weight fraction or by number of; atoms. Once an element was added using one method the other method is not; selectable anymore. Summing component fractions up to 1 in the final; mixture is the user responsibility. Adding materials as components of a; mixture is not supported in this version. The elements that were added to the mixture appear in the bottom of the; mixture editor. The operations performed on mixture are not undoable. ### Creation of New Objects. As described above, all geometry object creators are accessible within; the geometry manager editor frame. Generally, if the new object that; needs to be created does not depend on other objects, it will be built; with a set of default parameters. This is the case for all shapes; (except composite shapes) and matrices. For all the other objects the; interface forces the selection of components before creating the object. ### Editing Volumes. Volumes are hierarchical components in the geometry, therefore their; editor is more complex. It provides the following functionalities:. - *General*. This category allows changing the name of the volume and; selecting other shape or medium among existing ones. - *Daughters*. The category allows removing existing daughter nodes or; adding new ones. The button ""*Position*"" allows editing the; positioning matrix of a given node. ![Setting volume properties and modifying volume hierarchy](pictures/020001F5.jpg); ![Setting volume properties and modifying volume hierarchy](pictures/020001F6.jpg). - *Visualization*. This category allows changing the visibility of the; edited volume or for its daughters, as well as other visualization; settings. The radio button ""*All*"" allows viewing all volumes down; to the selected depth. ""*Leaves*"" will draw only the deepest nodes; that have the selected depth or lower level ones th",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:173423,Integrability,interface,interface,173423," name of the volume and; selecting other shape or medium among existing ones. - *Daughters*. The category allows removing existing daughter nodes or; adding new ones. The button ""*Position*"" allows editing the; positioning matrix of a given node. ![Setting volume properties and modifying volume hierarchy](pictures/020001F5.jpg); ![Setting volume properties and modifying volume hierarchy](pictures/020001F6.jpg). - *Visualization*. This category allows changing the visibility of the; edited volume or for its daughters, as well as other visualization; settings. The radio button ""*All*"" allows viewing all volumes down; to the selected depth. ""*Leaves*"" will draw only the deepest nodes; that have the selected depth or lower level ones that have no; daughters inside. ""*Only*"" will allow drawing only the edited; volume. The check button ""*Raytrace*"" will just draw the current; selection in solid mode using the ray-tracing algorithm provided by; TGeo. ![Volume visualisation settings and division interface for volumes](pictures/020001F7.jpg); ![Volume visualisation settings and division interface for volumes](pictures/020001F8.jpg). - *Division*. Allows dividing the edited volume according a given; pattern. The division axes that are allowed are presented in a; radio-button group. The number entries labeled ""*From*"", ""*Step*""; and ""*Nslices*"" correspond to the divisioning parameters on the; selected axis. The range of the division is between `start` and; `start+ndiv*step` values and its validity is checked upon changing; one of the values. NOTE: When changing a value in a number entry by typing a number, press; ENTER at the end to validate. This applies for taking into account and; validation of any number change in the geometry editors. ### How to Create a Valid Geometry with Geometry Editors. 1. Create a new geometry manager and start the editor as described at; the beginning. 2. Create at least one material from the ""*Materials*"" shutter item; category. Generally, for crea",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:173515,Integrability,interface,interface,173515,"*. The category allows removing existing daughter nodes or; adding new ones. The button ""*Position*"" allows editing the; positioning matrix of a given node. ![Setting volume properties and modifying volume hierarchy](pictures/020001F5.jpg); ![Setting volume properties and modifying volume hierarchy](pictures/020001F6.jpg). - *Visualization*. This category allows changing the visibility of the; edited volume or for its daughters, as well as other visualization; settings. The radio button ""*All*"" allows viewing all volumes down; to the selected depth. ""*Leaves*"" will draw only the deepest nodes; that have the selected depth or lower level ones that have no; daughters inside. ""*Only*"" will allow drawing only the edited; volume. The check button ""*Raytrace*"" will just draw the current; selection in solid mode using the ray-tracing algorithm provided by; TGeo. ![Volume visualisation settings and division interface for volumes](pictures/020001F7.jpg); ![Volume visualisation settings and division interface for volumes](pictures/020001F8.jpg). - *Division*. Allows dividing the edited volume according a given; pattern. The division axes that are allowed are presented in a; radio-button group. The number entries labeled ""*From*"", ""*Step*""; and ""*Nslices*"" correspond to the divisioning parameters on the; selected axis. The range of the division is between `start` and; `start+ndiv*step` values and its validity is checked upon changing; one of the values. NOTE: When changing a value in a number entry by typing a number, press; ENTER at the end to validate. This applies for taking into account and; validation of any number change in the geometry editors. ### How to Create a Valid Geometry with Geometry Editors. 1. Create a new geometry manager and start the editor as described at; the beginning. 2. Create at least one material from the ""*Materials*"" shutter item; category. Generally, for creating objects, the interface is always in; the **`TGeoManagerEditor`** in different catego",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:174439,Integrability,interface,interface,174439,"ation settings and division interface for volumes](pictures/020001F8.jpg). - *Division*. Allows dividing the edited volume according a given; pattern. The division axes that are allowed are presented in a; radio-button group. The number entries labeled ""*From*"", ""*Step*""; and ""*Nslices*"" correspond to the divisioning parameters on the; selected axis. The range of the division is between `start` and; `start+ndiv*step` values and its validity is checked upon changing; one of the values. NOTE: When changing a value in a number entry by typing a number, press; ENTER at the end to validate. This applies for taking into account and; validation of any number change in the geometry editors. ### How to Create a Valid Geometry with Geometry Editors. 1. Create a new geometry manager and start the editor as described at; the beginning. 2. Create at least one material from the ""*Materials*"" shutter item; category. Generally, for creating objects, the interface is always in; the **`TGeoManagerEditor`** in different categories - one should just; provide a name and requested parameters. 3. Create a shape that will be used for the top volume within the; ""*Shapes*"" category. For the moment, the shapes that have editors are; Box, Para, Trd1, Trd2, Tube, Tube segment, Cone, Cone segment, Hype,; Pcon, Torus and Sphere. 4. Create a medium from one of the existing materials from the; ""*Medium*"" category. You will notice that some categories as ""*Volume*""; and ""*Medium*"" are inactive at the beginning because at that time there; is no material yet (for making a medium) and no shape (for making a; volume). These categories are dynamically activated once all the; required components are defined. 5. Create a volume from the ""*Volumes*"" category. You will notice that; contrary to the other editors, the volume editor is opened in a tab, not; transient - this is because it is more complex. 6. Go back to ""*General*"" category and select the newly created volume; as the top one (you can do it also fr",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:175685,Integrability,interface,interface,175685,"ues and its validity is checked upon changing; one of the values. NOTE: When changing a value in a number entry by typing a number, press; ENTER at the end to validate. This applies for taking into account and; validation of any number change in the geometry editors. ### How to Create a Valid Geometry with Geometry Editors. 1. Create a new geometry manager and start the editor as described at; the beginning. 2. Create at least one material from the ""*Materials*"" shutter item; category. Generally, for creating objects, the interface is always in; the **`TGeoManagerEditor`** in different categories - one should just; provide a name and requested parameters. 3. Create a shape that will be used for the top volume within the; ""*Shapes*"" category. For the moment, the shapes that have editors are; Box, Para, Trd1, Trd2, Tube, Tube segment, Cone, Cone segment, Hype,; Pcon, Torus and Sphere. 4. Create a medium from one of the existing materials from the; ""*Medium*"" category. You will notice that some categories as ""*Volume*""; and ""*Medium*"" are inactive at the beginning because at that time there; is no material yet (for making a medium) and no shape (for making a; volume). These categories are dynamically activated once all the; required components are defined. 5. Create a volume from the ""*Volumes*"" category. You will notice that; contrary to the other editors, the volume editor is opened in a tab, not; transient - this is because it is more complex. 6. Go back to ""*General*"" category and select the newly created volume; as the top one (you can do it also from the volume category). This is; just for starting. To create some hierarchy, one has to create several; other volumes and the matrices to position them. Once this is done, use; the volume editor interface to:; - add/remove daughters, change shape, edit position of daughters; - change visualization settings; - divide the volume (only if there are no daughters yet). 7. Close the geometry from the ""*General*"" category.; ",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:17116,Modifiability,evolve,evolve,17116,"nsity:. ``` {.cpp}; TGeoMixture(const char *name,Int_t nel,Double_t rho);; ```. Elements have to be further defined one by one:. ``` {.cpp}; void TGeoMixture::DefineElement(Int_t iel,Double_t a,Double_t z,; Double_t weigth);; void TGeoMixture::DefineElement(Int_t iel, TGeoElement *elem,; Double_t weight);; void TGeoMixture::DefineElement(Int_t iel, Int_t z, Int_t natoms);; ```. or:. ``` {.cpp}; void AddElement(TGeoMaterial* mat, Double_t weight);; void AddElement(TGeoElement* elem, Double_t weight);; void AddElement(TGeoElement* elem, Int_t natoms);; void AddElement(Double_t a, Double_t z, Double_t weight); ```. - `iel:` index of the element` [0,nel-1]`; - `a` and `z:` the atomic mass and charge; - `weight:` proportion by mass of the elements; - `natoms`: number of atoms of the element in the molecule making the; mixture. The radiation length is automatically computed when all elements are; defined. Since tracking MC provide several other ways to create; materials/mixtures, the materials classes are likely to evolve as the; interfaces to these engines are being developed. Generally in the; process of tracking material properties are not enough and more specific; media properties have to be defined. These highly depend on the MC; performing tracking and sometimes allow the definition of different; media properties (e.g. energy or range cuts) for the same material. ### Radionuclides. A new class **`TGeoElementRN`** was introduced in this version to; provide support for radioactive nuclides and their decays. A database of; 3162 radionuclides can be loaded on demand via the table of elements; (**`TGeoElementTable`** class). One can make then materials/mixtures; based on these radionuclides and use them in a geometry. ``` {.cpp}; root[] TGeoManager *geom = new TGeoManager(""geom"",""radionuclides"");; root[] TGeoElementTable *table = geom->GetElementTable();; root[] TGeoElementRN *c14 = table->GetElementRN(14,6); // A,Z; root[] c14->Print();; 6-C-014 ENDF=60140; A=14; Z=6; I",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:24834,Modifiability,inherit,inheritance,24834,"ape; surface, given a starting local point and an ongoing direction. All the features above are globally managed by the modeller in order to; provide navigation functionality. In addition to those, shapes have also; to implement additional specific abstract methods:. - Computation of the minimal box bounding the shape, given that this; box have to be aligned with the local coordinates;; - Algorithms for dividing the shape along a given axis. The modeller currently provides a set of 20 basic shapes, which we will; call `primitives`. It also provides a special class allowing the; creation of shapes as a result of Boolean operations between primitives.; These are called `composite shapes` and the composition operation can be; recursive (combined composites). This allows the creation of a quite; large number of different shape topologies and combinations. You can; have a look and run the tutorial:; <http://root.cern.ch/root/html/examples/geodemo.C.html>. ![Primitive Shapes - the general inheritance scheme](pictures/030001B5.png). Shapes are named objects and all primitives have constructors like:. ``` {.cpp}; TGeoXXX(const char *name,<type> param1,<type> param2, ...);; TGeoXXX(<type> param1,<type> param2, ...);; ```. Naming shape primitive is mandatory only for the primitives used in; Boolean composites (see ""Composite Shapes""). For the sake of simplicity,; we will describe only the constructors in the second form. ### Units. The length units used in the geometry are **arbitrary**. However, there; are certain functionalities that work with the assumption that the used; lengths are expressed in centimeters. This is the case for shape; capacity or volume weight computation. The same is valid when using the; ROOT geometry as navigator for an external transport MC package (e.g.; GEANT) via the VMC interface. Other units in use: All angles used for defining rotation matrices or; some shape parameters are expressed in **degrees**. Material density is; expressed in [**g/cm3**]",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:42883,Modifiability,extend,extend,42883,"ion. The point lies on the plane and the normal vector; points outside the half space. The half space is the only shape; which is infinite and can be used only in Boolean operations that; result in non-infinite composite shapes (see also ""Composite Shapes""; below). A half space has to be defined using the constructor:. ``` {.cpp}; TGeoHalfSpace (const char *name, Double_t *point[3],; Double_t *norm[3]);; ```. ### Composite Shapes. Composite shapes are Boolean combinations of two or more shape; components. The supported Boolean operations are union (+), intersection; (\*) and subtraction(-). Composite shapes derive from the base; **`TGeoShape`** class, therefore providing all shape features:; computation of bounding box, finding if a given point is inside or; outside the combination, as well as computing the distance to; entering/exiting. They can be directly used for creating volumes or used; in the definition of other composite shapes. Composite shapes are provided in order to complement and extend the set; of basic shape primitives. They have a binary tree internal structure,; therefore all shape-related geometry queries are signals propagated from; top level down to the final leaves, while the provided answers are; assembled and interpreted back at top. This `CSG`; `(composite solid geometry)` hierarchy is effective for small number of; components, while performance drops dramatically for large structures.; Building a complete geometry in this style is virtually possible but; highly not recommended. #### The Structure of Composite Shapes. A composite shape can always be looked as the result of a Boolean; operation between only two shape components. All information identifying; these two components as well as their positions with respect to the; frame of the composite is represented by an object called Boolean node.; A composite shape has a pointer to such a Boolean node. Since the shape; components may also be composites, they will also contain binary Boolean; no",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:54717,Modifiability,parameteriz,parameterizations,54717,":; `X`, `Y`, `Z`, `Rxy`, `Phi`, `Rxyz`. A given shape cannot be divided; however on any axis. The general rule is that that divisions are; possible on whatever axis that produces still known shapes as slices.; The division of shapes are performed by the call `TGeoShape::Divide()`,; but this operation can be done only via `TGeoVolume::Divide()` method.; In other words, the algorithm for dividing a specific shape is known by; the shape object, but is always invoked in a generic way from the volume; level. Details on how to do that can be found in the paragraph ‘Dividing; volumes'. One can see how all division options are interpreted and which; their result inside specific shape classes is. ### Parametric Shapes. Shapes generally have a set of parameters that is well defined at build; time. In fact, when the final geometrical hierarchy is assembled and the; geometry is closed, all constituent shapes `MUST`**have well defined and; valid parameters. In order to ease-up geometry creation, some; parameterizations are however allowed. For instance let's suppose that we need to define several volumes having; exactly the same properties but different sizes. A way to do this would; be to create as many different volumes and shapes. The modeller allows; however the definition of a single volume having undefined shape; parameters. ``` {.cpp}; TGeoManager::Volume(const char *name,const char *shape,Int_t nmed);; ```. - `name:` the name of the newly created volume;; - `shape:`the type of the associated shape. This has to contain the; case-insensitive first 4 letters of the corresponding class name; (e.g. ""`tubs`"" will match **`TGeoTubeSeg`**, ""`bbox`"" will match; **`TGeoBBox`**); - `nmed:` the medium number. This will create a special volume that will not be directly used in the; geometry, but whenever positioned will require a list of actual; parameters for the current shape that will be created in this process.; Such volumes having shape parameters known only when used have to be",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:55835,Modifiability,parameteriz,parameterizations,55835," but different sizes. A way to do this would; be to create as many different volumes and shapes. The modeller allows; however the definition of a single volume having undefined shape; parameters. ``` {.cpp}; TGeoManager::Volume(const char *name,const char *shape,Int_t nmed);; ```. - `name:` the name of the newly created volume;; - `shape:`the type of the associated shape. This has to contain the; case-insensitive first 4 letters of the corresponding class name; (e.g. ""`tubs`"" will match **`TGeoTubeSeg`**, ""`bbox`"" will match; **`TGeoBBox`**); - `nmed:` the medium number. This will create a special volume that will not be directly used in the; geometry, but whenever positioned will require a list of actual; parameters for the current shape that will be created in this process.; Such volumes having shape parameters known only when used have to be; positioned only with **`TGeoManager::Node()` method (see ‘Creating and; Positioning Volumes').**. Other case when shape parameterizations are quite useful is scaling; geometry structures. Imagine that we would like to enlarge/shrink a; detector structure on one or more axes. This happens quite often in real; life and is handled by ""fitting mother"" parameters. This is accomplished; by defining shapes with one or more invalid (negative) parameters. For; instance, defining a box having `dx=10.`, `dy=10.`, and `dz=-1` will not; generate an error but will be interpreted in a different way: A special; volume **`TGeoVolumeMulti`** will be created. Whenever positioned inside; a mother volume, this will create a normal **`TGeoVolume`** object; having as shape a box with `dz` fitting the corresponding `dz `of the; mother shape. Generally, this type of parameterization is used when; positioning volumes in containers having a matching shape, but it works; also for most reasonable combinations. ## Geometry Creation. A given geometry can be built in various ways, but one has to follow; some mandatory steps. Even if we might use some terms",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:56569,Modifiability,parameteriz,parameterization,56569,"in this process.; Such volumes having shape parameters known only when used have to be; positioned only with **`TGeoManager::Node()` method (see ‘Creating and; Positioning Volumes').**. Other case when shape parameterizations are quite useful is scaling; geometry structures. Imagine that we would like to enlarge/shrink a; detector structure on one or more axes. This happens quite often in real; life and is handled by ""fitting mother"" parameters. This is accomplished; by defining shapes with one or more invalid (negative) parameters. For; instance, defining a box having `dx=10.`, `dy=10.`, and `dz=-1` will not; generate an error but will be interpreted in a different way: A special; volume **`TGeoVolumeMulti`** will be created. Whenever positioned inside; a mother volume, this will create a normal **`TGeoVolume`** object; having as shape a box with `dz` fitting the corresponding `dz `of the; mother shape. Generally, this type of parameterization is used when; positioning volumes in containers having a matching shape, but it works; also for most reasonable combinations. ## Geometry Creation. A given geometry can be built in various ways, but one has to follow; some mandatory steps. Even if we might use some terms that will be; explained later, here are few general rules:. - Volumes need media and shapes in order to be created.; - Both containers and contained volumes must be created before linking; them together, and the relative transformation matrix must be; provided.; - Any volume have to be positioned somewhere otherwise it will not be; considered as part of the geometry.; - Visibility or tracking properties of volumes can be provided both at; build time or after geometry is closed, but global visualization; settings (see section: ""The Drawing Package"") should not be provided; at build time, otherwise the drawing package will be loaded. There is also a list of specific rules:. - Positioned volumes should not extrude their container or intersect; with others within ",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:69945,Modifiability,inherit,inherit,69945," other nodes:. ``` {.cpp}; void RemoveNode(TGeoNode* node); TGeoNode*ReplaceNode(TGeoNode* nodeorig, TGeoShape* newshape = 0,; TGeoMatrix* newpos = 0, TGeoMedium* newmed = 0); ```. The last method allows replacing an existing daughter of a volume with; another one. Providing only the node to be replaced will just create a; new volume for the node but having exactly the same parameters as the; old one. This helps in case of divisions for decoupling a node from the; logical hierarchy so getting new content/properties. For non-divided; volumes, one can change the shape and/or the position of the daughter. #### Virtual Containers and Assemblies of Volumes. Virtual containers are volumes that do not represent real objects, but; they are needed for grouping and positioning together other volumes.; Such grouping helps not only geometry creation, but also optimizes; tracking performance; therefore, it is highly recommended. Virtual; volumes need to inherit material/medium properties from the volume they; are placed into in order to be ""invisible"" at tracking time. Let us suppose that we need to group together two volumes `A` and `B`; into a structure and position this into several other volumes `D,E,` and; `F`. What we need to do is to create a virtual container volume `C`; holding `A` and `B`, then position `C` in the other volumes. Note that `C` is a volume having a determined medium. Since it is not a; real volume, we need to manually set its medium the same as that of; `D,E` or `F` in order to make it ‘invisible' (same physics properties).; In other words, the limitation in proceeding this way is that `D,E,` and; `F` must point to the same medium. If this was not the case, we would; have to define different virtual volumes for each placement: `C`, `C'`; and `C""`, having the same shape but different media matching the; corresponding containers. This might not happen so often, but when it; does, it forces the creation of several extra virtual volumes. Other; limitation com",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:103232,Modifiability,variab,variables,103232,"initial state providing the starting point $\vec{r_0}$; and direction $\vec{n_0}$ .; There are several ways of doing that. ### TGeoNavigator Class. One geometry may have several independent navigators to query to; localize points or compute distances. The geometry manager holds a list; of active navigators accessible via:. ``` {.cpp}; TObjArray *navigators = gGeoManager->GetListOfNavigators();; ```. Upon closing the geometry a default navigator is provided as first one; in this list, but one may add its own via:. ``` {.cpp}; TGeoNavigator *navig = new TGeoNavigator(gGeoManager);; // Store the index of the user navigator; Int_t inav = gGeoManager->AddNavigator(navig);; // Make its own navigator the active one; gGeoManager->SetCurrentNavigator(inav);; // Switch between navigators; gGeoManager->SetCurrentNavigator(0);; ```. A navigator holds several variables describing the current navigation; state: current point position, current direction distance to next; boundary, isotropic safety, pointer to current and next nods as well as; several tracking flags related to volume boundary conditions or other; properties required for track propagation in geometry. Each geometry; query affects these variables, so the only way in testing several; navigation alternatives and remembering the active navigation state is; to use parallel navigation. The following paragraphs will describe the; usage of a single navigator. All setters/getters for navigation state; parameters as well as navigation queries provided by **`TGeoNavigator`**; are interfaced by **`TGeoManager`** and will act on the current; navigator. ### Initializing the Starting Point. The current point (`x,y,z`) known by the modeller is stored as; `Double_t fCurrentPoint[3]` by the navigator class. This array of the; three coordinates is defined in the current global reference system and; can be retrieved any time:. ``` {.cpp}; Const Double_t *cpoint = gGeoManager->GetCurrentPoint();; ```. Initializing this point can be done ",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:103578,Modifiability,variab,variables,103578,"etry manager holds a list; of active navigators accessible via:. ``` {.cpp}; TObjArray *navigators = gGeoManager->GetListOfNavigators();; ```. Upon closing the geometry a default navigator is provided as first one; in this list, but one may add its own via:. ``` {.cpp}; TGeoNavigator *navig = new TGeoNavigator(gGeoManager);; // Store the index of the user navigator; Int_t inav = gGeoManager->AddNavigator(navig);; // Make its own navigator the active one; gGeoManager->SetCurrentNavigator(inav);; // Switch between navigators; gGeoManager->SetCurrentNavigator(0);; ```. A navigator holds several variables describing the current navigation; state: current point position, current direction distance to next; boundary, isotropic safety, pointer to current and next nods as well as; several tracking flags related to volume boundary conditions or other; properties required for track propagation in geometry. Each geometry; query affects these variables, so the only way in testing several; navigation alternatives and remembering the active navigation state is; to use parallel navigation. The following paragraphs will describe the; usage of a single navigator. All setters/getters for navigation state; parameters as well as navigation queries provided by **`TGeoNavigator`**; are interfaced by **`TGeoManager`** and will act on the current; navigator. ### Initializing the Starting Point. The current point (`x,y,z`) known by the modeller is stored as; `Double_t fCurrentPoint[3]` by the navigator class. This array of the; three coordinates is defined in the current global reference system and; can be retrieved any time:. ``` {.cpp}; Const Double_t *cpoint = gGeoManager->GetCurrentPoint();; ```. Initializing this point can be done like:. ``` {.cpp}; gGeoManager->SetCurrentPoint(x,y,z);; // or:; gGeoManager->SetCurrentPoint(Double_t *point[3]);; ```. ### Initializing the Direction. In order to move inside geometry starting with the current point, the; modeller needs to know the current ",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:107287,Modifiability,variab,variables,107287,"t point inside the hierarchy; of nodes, after setting this point it is mandatory to call the; `‘Where am I?'` method:. ``` {.cpp}; gGeoManager->FindNode();; ```. In order to have more flexibility, there are in fact several alternative; ways of initializing a modeller state:. ``` {.cpp}; // Setting the point and finding the state in one step:; gGeoManager->FindNode(Double_t x,Double_t y,Double_t z);; gGeoManager->FindNode(Double_t *point[3]);; // Setting both initial point and direction and finding the state:; gGeoManager->InitTrack(Double_t x,Double_t y,Double_t z,; Double_t nx, Double_t ny, Double_t nz);; gGeoManager->InitTrack(Double_t *point[3],Double_t *dir[3]);; ```. Note that the current point coordinates can be changed and the state; re-initialized at any time. This represents the `‘Where am I?'`; geometrical query representing the basic navigation functionality; provided by the modeller. ### Checking the Current State. The current state and all variables related to this are essential during; tracking and have to be checked several times. Besides the current point; and direction, the following additional information can be retrieved; from **`TGeoManager`** interface:. - The `current path`. This represents a string containing the names; and copy numbers of all positioned objects in the current `branch`; written in the /folder/folder/.../folder/file fashion. The final node; pointed by the path is the deepest object containing the current; point and is representative for the current state. All intermediate; `folders` in the path are in fact also nodes ""touched"" by the; current point, but having some ""touched"" containment. The current; path can be retrieved only after the state was initialized and is; useful for getting an idea of the current point location. ``` {.cpp}; const char *path = gGeoManager->GetPath();; cout << ""Current path is: "" << path << endl;; /A_1/B_34/C_3/D_1; ```. - The `current node`***`, `***`volume` and `material`. In order to; take decisions ",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:125261,Modifiability,inherit,inheriting,125261,"izing Tracks. In case the modeller is interfaced with a tracking engine, one might; consider quite useful being able to store and visualize at least a part; of the tracks in the context of the geometry. The base class; **`TVirtualGeoTrack`** provides this functionality. It currently has one; implementation inside the drawing package (**`TGeoTrack`** class). A; track can be defined like:. ``` {.cpp}; TVirtualGeoTrack(Int_t id,Int_t pdg,TVirtualGeoTrack *parent=0,; TObject *particle=0);; ```. Where: `id` is user-defined id of the track, `pdg` - `pdg` code,; `parent` - a pointer to parent track, `particle` - a pointer to an; arbitrary particle object (may be a **`TParticle`**). A track has a list of daughters that have to be filled using the; following method:. ``` {.cpp}; TVirtualGeoTrack *TVirtualGeoTrack::AddDaughter(Int_t id,Int_t pdg,; TObject *particle=0);; ```. The method above is pure virtual and have to create a track daughter; object. Tracks are fully customizable objects when inheriting from; **`TVirtualGeoTrack`** class. We will describe the structure and; functionality provided by the default implementation of these, which are; **`TGeoTrack`** objects. A **`TGeoTrack`** is storing a list of `control points` `(x,y,z)`; belonging to the track, having also time information `(t)`. The painting; algorithm of such tracks allows drawing them in any time interval after; their creation. The track position at a given time is computed by; interpolation between control points. ``` {.cpp}; myTrack->AddPoint(x,y,z,t);; ```. The creation and management of tracks is in fact fully controlled by the; **`TGeoManager`** class. This holds a list of `primary tracks` that is; also visible during browsing as `Tracks` folder. Primary tracks are; tracks having no parent in the tracking history (for instance the output; of particle generators may be considered as primaries from tracking; point of view). The manager class holds; in**` TGeoManager::fCurrentTrack` a pointer to the curr",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:128029,Modifiability,variab,variable,128029,"d);; ptrTrack = gGeoManager->GetTrack(index);; ```. Supposing a particle represented by a primary track decays or interacts,; one should not create new primaries as described before, but rather add; them as secondary:. ``` {.cpp}; TVirtualGeoTrack *secondary =; ptrTrack->AddTrack(secondId,pdg,secondParticle);; ```. At any step made by the current track, one is able to add control points; to either primary or secondary:. ``` {.cpp}; track->AddPoint(x,y,z,t);; ```. After tracks were defined and filled during tracking, one will be able; to browse directly the list of tracks held by the manager class. Any; track can be drawn using its `Draw()` and `Animate()` methods, but there; are also global methods for drawing or animation that can be accessed; from **`TGeoManager`** context menu:. ``` {.cpp}; TGeoManager::DrawTracks(Option_t *option);; TGeoManager::AnimateTracks(Double_t tmin=0.,Double_t tmax=1E-8,; Int_t nframes=200,Option_t *option="""");; ```. The drawing/animation time range is a global variable that can be; directly set:. ``` {.cpp}; gGeoManager->SetTminTmax(tmin, tmax);; // without arguments resets the time range to the maximum value; ```. Once set, the time range will be active both for individual or global; track drawing. For animation, this range is divided to the desired; number of frames and will be automatically updated at each frame in; order to get the animation effect. The option provided to all track-drawing methods can trigger different; track selections:. `default: `A track (or all primary tracks) drawn without daughters. `/D:` Track and first level descendents only are drawn. `/*: ` Track and all descendents are drawn. `/Ntype:` All tracks having `name=type` are drawn. Generally several options can be concatenated in the same string (E.g.; `""/D /Npion-""`). For animating tracks, additional options can be added:. `/G:`Geometry animate. Generally when drawing or animating tracks, one; has to first perform a normal drawing of the geometry as convenient",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:136679,Modifiability,plug-in,plug-in,136679,"k the validity of a given geometry is shooting random; points. This can be called with the method; **`TGeoVolume`**`::RandomPoints()` and it draws a volume with the current; visualization settings. Random points are generated in the bounding box; of the drawn volume. The points are drawn with the color of their; deepest container. Only points inside visible nodes are drawn. ![Random rays](pictures/030001E2.png). A ray tracing method can be called `TGeoVolume::RandomRays()`. This; shoots rays from a given point in the local reference frame with random; directions. The intersections with displayed nodes appear as segments; having the color of the touched node. ## The Drawing Package. ![](pictures/030001E3.png)The modeller provides a powerful drawing; package, supporting several different options of visualization. A; library separated from the main one provides all functionality being; linked with the underlying ROOT visualization system. This library is; dynamically loaded by the plug-in manager only when drawing features are; requested. The geometrical structures that can be visualized are volumes; and volume hierarchies. The main component of the visualization system is volume primitive; painting in a ROOT pad. Starting from this one, several specific options; or subsystems are available, like: X3D viewing using hidden line and; surface removal algorithms, OpenGL viewing\* or ray tracing. The method `TGeoManager::GetGeomPainter()`loads the painting library in; memory. This is generally not needed since it is called automatically by; `TGeoVolume::Draw()` as well as by few other methods setting; visualization attributes. ### Drawing Volumes and Hierarchies of Volumes. The first thing one would like to do after building some geometry is to; visualize the volume tree. This provides the fastest validation check; for most common coding or design mistakes. As soon as the geometry is; successfully closed, one should draw it starting from the top-level; volume:. ``` {.cpp}; ",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:141627,Modifiability,inherit,inherit,141627,"*** Once you have set a convenient global visualization option; and level, what you need is just call the `Draw()` method of your; interesting volume. You can do this either by interacting with the; expanded tree of volumes in a ROOT browser (where the context menu of; any volume is available), either by getting a pointer to it (e.g. by; name): `gGeoManager->GetVolume(""vol_name"")->Draw();`. ### Visualization Settings and Attributes. Supposing you now understand the basic things to do for drawing the; geometry or parts of it, you still might be not happy and wishing to; have more control on it. We will describe below how you can fine-tune some; settings. Since the corresponding attributes are flags belonging to; volume and node objects, you can change them at any time (even when the; picture is already drawn) and see immediately the result. #### Colors and Line Styles. We have already described how to change the line colors for volumes. In; fact, volume objects inherit from TAttLine class so the line style or; width can also be changed:. ``` {.cpp}; myVolume->SetLineColor(kRed);; myVolume->SetLineWith(2);; myVolume->SetLineStyle(kDotted);; ```. When drawing in solid mode, the color of the drawn volume corresponds to; the line color. #### Visibility Settings. The way geometry is build forces the definition of several volumes that; does not represent real objects, but just virtual containers used for; grouping and positioning volumes together. One would not want to see; them in the picture. Since every volume is by default visible, one has; to do this sort of tuning by its own:. ``` {.cpp}; myVolumeContainer->SetVisibility(kFALSE);; ```. As described before, the drawing package supports two main global; options: 1 (default) - only final volume leaves; 0 - all volumes down; the drawn one appear on the screen. The global visible level put a; limitation on the maximum applied depth. Combined with visibility; settings per volume, these can tune quite well what should appear",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:152713,Modifiability,variab,variables,152713,"; ```. Example:. ``` {.cpp}; // Writing to a file geometry definition ending with:; root[] gGeoManager->CloseGeometry();; // geometry is ready; root[] gGeoManager->Export(""MyGeom.root"");; // file MyGeom.root produced; root[] gGeoManager->Export(""MyGeom.C"");; // C++ macro MyGeom.C produced; root[] gGeoManager->Export(""MyGeom.gdml"");; // GDML file MyGeom.gdml produced; root[] myVolume->SaveAs(""MyVolume.C"");; // C++ macro for the branch starting; // with MyVolume; // Reading from a file; root[] gSystem->Load(""libGeom"");; root[] TGeoManager::Import(""MyGeom.root""); // geometry is ready; ```. Note that not all-current information held by the modeller is written on; the file. For instance, the painter and checker objects are not written,; as well as the temporary current navigation properties: current node; path, point or direction. On the other hand, all objects belonging to; the geometrical hierarchy will always be written. The idea is to be able; to retrieve the geometry in a ready state, ignoring what the state; variables that can be always re-initialized. When the code is generated; for a given **`TGeoVolume`** in the geometry, just the branch starting; with that volume will be saved in the file. Executing the generated code; will create a geometry that has `MyVolume` as top volume. In this case,; only the materials/media/matrices used effectively in the `MyVolume`; branch are exported to file. Volumes can be made persistent in the same way the full geometry is.; Exporting is straightforward (module1, 2 are pointers to; **`TGeoVolume`** objects):. ``` {.cpp}; module1->Export(""file.root"");; // by default file is overwritten; module2->Export(""file.root"","""",""update"");; // to the same file; ```. Importing will append the volume to the current TGeoManager or will; create one:. ``` {.cpp}; TGeoManager *geom = new TGeoManager(""myGeom"", """");; TGeoVolume *top = geom->MakeBox(...);; geom->SetTopVolume(top);; //name of volume or key (depending on export usage); TGeoVolume *module",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:154492,Modifiability,config,configure,154492,"eoManager *geom = new TGeoManager(""myGeom"", """");; TGeoVolume *top = geom->MakeBox(...);; geom->SetTopVolume(top);; //name of volume or key (depending on export usage); TGeoVolume *module1 = TGeoVolume::Import(""file.root"", ""MOD1"");; TGeoVolume *module2 = TGeoVolume::Import(""file.root"", ""MOD2"");; top->AddNode(module1, 1, new TGeoTranslation(0,0,100));; top->AddNode(module2, 1, new TGeoTranslation(0,0,-100));; // One should close oneself the geometry; geom->CloseGeometry();; ```. ### GDML. Few lines above word GDML was used. GDML stands for **G**eometry; **D**escription **M**arkup **L**anguage. It is an application-independent; geometry description format based on XML. It is mainly used for geometry; interchange between ROOT and Geant4 framework. More details about this; project can be found http://gdml.web.cern.ch. This feature; (importing/exporting from/to gdml file format) is disabled by default in; ROOT installation. To enable this feature add `--enable-gdml` option to; `./configure` script call. ## Navigation Algorithms. This section will describe the main methods and algorithms used for; implementing the navigation features within the geometrical modeller.; This includes navigation queries at shape level, global geometrical; queries and optimization mechanisms. ### Finding the State Corresponding to a Location (x,y,z). For reminder, a geometry state is a ‘touchable' object in the geometry; hierarchy. It is represented by a path like: **/TOP\_1/A\_1/B\_3/C\_1**,; where **B\_3** for instance is a copy of volume **B** positioned inside; volume **A**. A state is always associated to a transformation matrix; **M** of the touchable with respect to the global reference frame; (obtained by piling-up all local transformations of nodes in the branch; with respect to their containers). The current state and the; corresponding global matrix are updated whenever the geometry depth is; modified. The global transformations corresponding to all nodes in the; current branch are k",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:165868,Modifiability,plug-in,plug-in,165868,"der to find out this new state, one; has to propagate the point with a distance slightly bigger that the; computed step value (which is accurate within numerical precision). A; method that performs this task finding the next location is; `TGeoManager::Step()`, described in "" Making a Step "", but users may; implement more precise methods to insure post-step boundary crossing. ## Geometry Graphical User Interface. The geombuilder package allows you to create and edit geometries. The; package provides a library of all GUI classes related to geometry. Each; editable geometry class **`TGeoXXX`** have a correspondent editor; **`TGeoXXXEditor`** that provides a graphics user interface allowing to; edit some (or all) parameters of a geometry object. The editable objects; are geometry manager, volumes, nodes, shapes, media, materials and; matrices. The interfaces provide also access to specific functionality; of geometry objects. The editing mechanism is based on ROOT GED; (Graphics Editors) functionality and the library is loaded using the; plug-in mechanism. ### Editing a Geometry. There are two different use cases having different ways of invoking the; geometry editors. The first one applies when starting with geometry from; scratch and using the builder functionality to create new geometry; objects. In this case, one should use the sequence:. ``` {.cpp}; root[] TGeoManager *geom = new TGeoManager(""MyGeom"",; ""Test builder"");; root[] geom->Edit(Option_t *option="""");; ```. The lines above will create a new **`TGeoManager`** class, create an; empty canvas and start the editor in the left-sided editor frame; attached to the canvas. To open the editor in a separate frame one; should provide a non-empty string as option to the `Edit()` method. ![The geometry manager editor](pictures/030001E9.png). ### The Geometry Manager Editor. ![Accessing/creating different categories of editable; objects](pictures/020001EA.jpg) ![Accessing/creating different; categories of editable objects](",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:373,Performance,optimiz,optimize,373,"# The Geometry Package; \index{Geometry}. The new ROOT geometry package is a tool for building, browsing,; navigating and visualizing detector geometries. The code works; standalone with respect to any tracking Monte-Carlo engine; therefore,; it does not contain any constraints related to physics. However, the; navigation features provided by the package are designed to optimize; particle transport through complex geometries, working in correlation; with simulation packages such as GEANT3, GEANT4 and FLUKA. ## Quick Start: Creating the ""world"". This chapter will provide a detailed description on how to build valid; geometries as well as the ways to optimize them. There are several; components gluing together the geometrical model, but for the time being; let us get used with the most basic concepts. The basic bricks for building-up the model are called; `volumes`**.**These represent the un-positioned pieces of the geometry; puzzle. The difference is just that the relationship between the pieces; is not defined by neighbors, but by `containment`. In other words,; volumes are put one inside another making an in-depth hierarchy. From; outside, the whole thing looks like a big pack that you can open finding; out other smaller packs nicely arranged waiting to be opened at their; turn. The biggest one containing all others defines the ""`world`"" of the; model. We will often call this `master reference system (MARS)`. Going; on and opening our packs, we will obviously find out some empty ones,; otherwise, something is very wrong... We will call these leaves (by; analogy with a tree structure). On the other hand, any volume is a small world by itself - what we need; to do is to take it out and to ignore all the rest since it is a; self-contained object. In fact, the modeller can act like this,; considering a given volume as temporary MARS, but we will describe this; feature later on. Let us focus on the biggest pack - it is mandatory to; define one. Consider the simplest geom",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:657,Performance,optimiz,optimize,657,"# The Geometry Package; \index{Geometry}. The new ROOT geometry package is a tool for building, browsing,; navigating and visualizing detector geometries. The code works; standalone with respect to any tracking Monte-Carlo engine; therefore,; it does not contain any constraints related to physics. However, the; navigation features provided by the package are designed to optimize; particle transport through complex geometries, working in correlation; with simulation packages such as GEANT3, GEANT4 and FLUKA. ## Quick Start: Creating the ""world"". This chapter will provide a detailed description on how to build valid; geometries as well as the ways to optimize them. There are several; components gluing together the geometrical model, but for the time being; let us get used with the most basic concepts. The basic bricks for building-up the model are called; `volumes`**.**These represent the un-positioned pieces of the geometry; puzzle. The difference is just that the relationship between the pieces; is not defined by neighbors, but by `containment`. In other words,; volumes are put one inside another making an in-depth hierarchy. From; outside, the whole thing looks like a big pack that you can open finding; out other smaller packs nicely arranged waiting to be opened at their; turn. The biggest one containing all others defines the ""`world`"" of the; model. We will often call this `master reference system (MARS)`. Going; on and opening our packs, we will obviously find out some empty ones,; otherwise, something is very wrong... We will call these leaves (by; analogy with a tree structure). On the other hand, any volume is a small world by itself - what we need; to do is to take it out and to ignore all the rest since it is a; self-contained object. In fact, the modeller can act like this,; considering a given volume as temporary MARS, but we will describe this; feature later on. Let us focus on the biggest pack - it is mandatory to; define one. Consider the simplest geom",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:2129,Performance,load,load,2129,"hierarchy. From; outside, the whole thing looks like a big pack that you can open finding; out other smaller packs nicely arranged waiting to be opened at their; turn. The biggest one containing all others defines the ""`world`"" of the; model. We will often call this `master reference system (MARS)`. Going; on and opening our packs, we will obviously find out some empty ones,; otherwise, something is very wrong... We will call these leaves (by; analogy with a tree structure). On the other hand, any volume is a small world by itself - what we need; to do is to take it out and to ignore all the rest since it is a; self-contained object. In fact, the modeller can act like this,; considering a given volume as temporary MARS, but we will describe this; feature later on. Let us focus on the biggest pack - it is mandatory to; define one. Consider the simplest geometry that is made of a single box.; Here is an example on how to build it:. ### Example 1: Creating the World. We first need to load the geometry library. This is not needed if one; does `make map` in root folder. ``` {.cpp}; root[] gSystem->Load(""libGeom"");; ```. Second, we have to create an instance of the geometry manager class.; This takes care of all the modeller components, performing several tasks; to insure geometry validity and containing the user interface for; building and interacting with the geometry. After its creation, the; geometry manager class can be accessed with the global; ***`gGeoManager`***:. ``` {.cpp}; root[] new TGeoManager(""world"", ""the simplest geometry"");; ```. We want to create a single volume in our geometry, but since any volume; needs to have an associated medium, we will create a dummy one. You can; safely ignore the following lines for the time being, since materials; and media will be explained in detail later on. ``` {.cpp}; root[] TGeoMaterial *mat = new TGeoMaterial(""Vacuum"",0,0,0);; root[] TGeoMedium *med = new TGeoMedium(""Vacuum"",1,mat);; ```. We can finally make our volume ",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:2384,Performance,perform,performing,2384,"ARS)`. Going; on and opening our packs, we will obviously find out some empty ones,; otherwise, something is very wrong... We will call these leaves (by; analogy with a tree structure). On the other hand, any volume is a small world by itself - what we need; to do is to take it out and to ignore all the rest since it is a; self-contained object. In fact, the modeller can act like this,; considering a given volume as temporary MARS, but we will describe this; feature later on. Let us focus on the biggest pack - it is mandatory to; define one. Consider the simplest geometry that is made of a single box.; Here is an example on how to build it:. ### Example 1: Creating the World. We first need to load the geometry library. This is not needed if one; does `make map` in root folder. ``` {.cpp}; root[] gSystem->Load(""libGeom"");; ```. Second, we have to create an instance of the geometry manager class.; This takes care of all the modeller components, performing several tasks; to insure geometry validity and containing the user interface for; building and interacting with the geometry. After its creation, the; geometry manager class can be accessed with the global; ***`gGeoManager`***:. ``` {.cpp}; root[] new TGeoManager(""world"", ""the simplest geometry"");; ```. We want to create a single volume in our geometry, but since any volume; needs to have an associated medium, we will create a dummy one. You can; safely ignore the following lines for the time being, since materials; and media will be explained in detail later on. ``` {.cpp}; root[] TGeoMaterial *mat = new TGeoMaterial(""Vacuum"",0,0,0);; root[] TGeoMedium *med = new TGeoMedium(""Vacuum"",1,mat);; ```. We can finally make our volume having a box shape. Note that the world; volume does not need to be a box - it can be any other shape. Generally,; boxes and tubes are the most recommendable shapes for this purpose due; to their fast navigation algorithms. ``` {.cpp}; root[] TGeoVolume *top=gGeoManager->MakeBox(""Top"",med,10.,",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:3766,Performance,optimiz,optimization,3766,"lume in our geometry, but since any volume; needs to have an associated medium, we will create a dummy one. You can; safely ignore the following lines for the time being, since materials; and media will be explained in detail later on. ``` {.cpp}; root[] TGeoMaterial *mat = new TGeoMaterial(""Vacuum"",0,0,0);; root[] TGeoMedium *med = new TGeoMedium(""Vacuum"",1,mat);; ```. We can finally make our volume having a box shape. Note that the world; volume does not need to be a box - it can be any other shape. Generally,; boxes and tubes are the most recommendable shapes for this purpose due; to their fast navigation algorithms. ``` {.cpp}; root[] TGeoVolume *top=gGeoManager->MakeBox(""Top"",med,10.,10.,10.);; ```. The default units are in centimeters. Now we want to make this volume; our world. We have to do this operation **before** closing the geometry. ``` {.cpp}; root[] gGeoManager->SetTopVolume(top);; ```. This should be enough, but it is not since always after defining some; geometry hierarchy, **`TGeo`** needs to build some optimization; structures and perform some checks. Note the messages posted after the; statement is executed. We will describe the corresponding operations; later. ``` {.cpp}; root[] gGeoManager->CloseGeometry();; ```. Now we are really done with geometry building stage, but we would like; to see our simple world:. ``` {.cpp}; root[] top->SetLineColor(kMagenta);; root[] gGeoManager->SetTopVisible(); // the TOP is invisible; root[] top->Draw();; ```. ### Example 2: A Geometrical Hierarchy Look and Feel. Before going further, let us get a look and feel of interacting with the; modeller. For this, we will use one of the examples illustrating the; geometry package. To get an idea on the geometry structure created in; this example, just look at the link:; <http://root.cern.ch/root/html/tutorials/geom/rootgeom.C.html>. You will; notice that this is a bit more complex that just creating the ""world""; since several other volumes are created and put together i",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:3795,Performance,perform,perform,3795,"lume in our geometry, but since any volume; needs to have an associated medium, we will create a dummy one. You can; safely ignore the following lines for the time being, since materials; and media will be explained in detail later on. ``` {.cpp}; root[] TGeoMaterial *mat = new TGeoMaterial(""Vacuum"",0,0,0);; root[] TGeoMedium *med = new TGeoMedium(""Vacuum"",1,mat);; ```. We can finally make our volume having a box shape. Note that the world; volume does not need to be a box - it can be any other shape. Generally,; boxes and tubes are the most recommendable shapes for this purpose due; to their fast navigation algorithms. ``` {.cpp}; root[] TGeoVolume *top=gGeoManager->MakeBox(""Top"",med,10.,10.,10.);; ```. The default units are in centimeters. Now we want to make this volume; our world. We have to do this operation **before** closing the geometry. ``` {.cpp}; root[] gGeoManager->SetTopVolume(top);; ```. This should be enough, but it is not since always after defining some; geometry hierarchy, **`TGeo`** needs to build some optimization; structures and perform some checks. Note the messages posted after the; statement is executed. We will describe the corresponding operations; later. ``` {.cpp}; root[] gGeoManager->CloseGeometry();; ```. Now we are really done with geometry building stage, but we would like; to see our simple world:. ``` {.cpp}; root[] top->SetLineColor(kMagenta);; root[] gGeoManager->SetTopVisible(); // the TOP is invisible; root[] top->Draw();; ```. ### Example 2: A Geometrical Hierarchy Look and Feel. Before going further, let us get a look and feel of interacting with the; modeller. For this, we will use one of the examples illustrating the; geometry package. To get an idea on the geometry structure created in; this example, just look at the link:; <http://root.cern.ch/root/html/tutorials/geom/rootgeom.C.html>. You will; notice that this is a bit more complex that just creating the ""world""; since several other volumes are created and put together i",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:5120,Performance,load,load,5120,"a);; root[] gGeoManager->SetTopVisible(); // the TOP is invisible; root[] top->Draw();; ```. ### Example 2: A Geometrical Hierarchy Look and Feel. Before going further, let us get a look and feel of interacting with the; modeller. For this, we will use one of the examples illustrating the; geometry package. To get an idea on the geometry structure created in; this example, just look at the link:; <http://root.cern.ch/root/html/tutorials/geom/rootgeom.C.html>. You will; notice that this is a bit more complex that just creating the ""world""; since several other volumes are created and put together in a hierarchy.; The purpose here is just to learn how to interact with a geometry that; is already built, but just few hints on the building steps in this; example might be useful. The geometry here represents the word ROOT that; is replicated in some symmetric manner. You might for instance ask some; questions after having a first look:. ***`Q:`*** ""OK, I understand the first lines that load the libGeom library and create; a geometry manager object. I also recognize from the previous example the following; lines creating some materials and media, but what about the geometrical transformations below?"". ***`A:`*** As explained before, the model that we are trying to create; is a hierarchy of volumes based on ***`containment`***. This is; accomplished by ***`positioning`*** some volumes ***`inside`*** others.; Any volume is an un-positioned object in the sense that it defines only; a ***`local frame`*** (matching the one of its ***`shape`***). In order; to fully define the mother-daughter relationship between two volumes one; has to specify how the daughter will be positioned inside. This is; accomplished by defining a ***`local geometrical transformation`*** of; the daughter with respect to the mother coordinate system. These; transformations will be subsequently used in the example. ***`Q:`*** ""I see the lines defining the top level volume as in the previous example,; but wh",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:8061,Performance,perform,performing,8061,"make an R?"". ***`A:`*** Well, in real life some objects have much more complex shapes; that an ***`R`***. The modeller cannot just know all of them; the idea; is to make a complex object by using elementary building blocks that; have known shapes (called ***`primitive shapes`***). Gluing these; together in the appropriate way is the user responsibility. ***`Q:`*** ""I am getting the global picture but not making much out of it... There; are also a lot of calls to TGeoVolume::AddNode() that I do not understand."". ***`A:`*** A volume is positioned inside another one by using this; method. The relative geometrical transformation as well as a copy number; must be specified. When positioned, a volume becomes a ***`node`*** of; its container and a new object of the class **`TGeoNode`** is; automatically created. This method is therefore the key element for the; creation of a hierarchical link between two volumes. As it will be; described further on in this document, there are few other methods; performing similar actions, but let us keep things simple for the time; being. In addition, notice that there are some visualization-related; calls in the example followed by a final `TGeoVolume::Draw() `call for; the top volume. These are explained in details in the section; ""Visualization Settings and Attributes"". At this point, you will; probably like to see how this geometry looks like. You just need to run; the example and you will get the following picture that you can rotate; using the mouse; or you can zoom / move it around (see what the Help; menu of the GL window displays). ``` {.cpp}; % root rootgeom.C; ```. ![](pictures/020001B1.jpg). Now let us browse the hierarchy that was just created. Start a browser; and double-click on the item simple1 representing the; ***`gGeoManager`*** object. Note that right click opens the context menu; of the manager class where several global methods are available. ``` {.cpp}; root[] new TBrowser;; ```. ![](pictures/020001B2.jpg). The folde",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:9264,Performance,perform,performing,9264,"for; the top volume. These are explained in details in the section; ""Visualization Settings and Attributes"". At this point, you will; probably like to see how this geometry looks like. You just need to run; the example and you will get the following picture that you can rotate; using the mouse; or you can zoom / move it around (see what the Help; menu of the GL window displays). ``` {.cpp}; % root rootgeom.C; ```. ![](pictures/020001B1.jpg). Now let us browse the hierarchy that was just created. Start a browser; and double-click on the item simple1 representing the; ***`gGeoManager`*** object. Note that right click opens the context menu; of the manager class where several global methods are available. ``` {.cpp}; root[] new TBrowser;; ```. ![](pictures/020001B2.jpg). The folders `Materials`, `Media` and `Local transformations` are in fact; the containers where the geometry manager stores the corresponding; objects. The `Illegal overlaps` folder is empty but can be filled after; performing a geometry validity check (see section: ""Checking the; Geometry""). If tracking is performed using **`TGeo`**, the folder; `Tracks` might contain user-defined tracks that can be; visualized/animated in the geometry context (see section: ""Creating and; Visualizing Tracks""). Since for the time being we are interested more in; the geometrical hierarchy, we will focus on the last two displayed items; `TOP `and `TOP_1`. These are the top volume and the corresponding top; node in the hierarchy. Double clicking on the `TOP` volume will unfold all different volumes; contained by the top volume. In the right panel, we will see all the; volumes contained by `TOP` (if the same is positioned 4 times we will; get 4 identical items). This rule will apply to any clicked volume in; the hierarchy. Note that right clicking a volume item activates the; volume context menu containing several specific methods. We will call; the volume hierarchy developed in this way as the; `logical geometry graph`. Th",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:9357,Performance,perform,performed,9357,"ooks like. You just need to run; the example and you will get the following picture that you can rotate; using the mouse; or you can zoom / move it around (see what the Help; menu of the GL window displays). ``` {.cpp}; % root rootgeom.C; ```. ![](pictures/020001B1.jpg). Now let us browse the hierarchy that was just created. Start a browser; and double-click on the item simple1 representing the; ***`gGeoManager`*** object. Note that right click opens the context menu; of the manager class where several global methods are available. ``` {.cpp}; root[] new TBrowser;; ```. ![](pictures/020001B2.jpg). The folders `Materials`, `Media` and `Local transformations` are in fact; the containers where the geometry manager stores the corresponding; objects. The `Illegal overlaps` folder is empty but can be filled after; performing a geometry validity check (see section: ""Checking the; Geometry""). If tracking is performed using **`TGeo`**, the folder; `Tracks` might contain user-defined tracks that can be; visualized/animated in the geometry context (see section: ""Creating and; Visualizing Tracks""). Since for the time being we are interested more in; the geometrical hierarchy, we will focus on the last two displayed items; `TOP `and `TOP_1`. These are the top volume and the corresponding top; node in the hierarchy. Double clicking on the `TOP` volume will unfold all different volumes; contained by the top volume. In the right panel, we will see all the; volumes contained by `TOP` (if the same is positioned 4 times we will; get 4 identical items). This rule will apply to any clicked volume in; the hierarchy. Note that right clicking a volume item activates the; volume context menu containing several specific methods. We will call; the volume hierarchy developed in this way as the; `logical geometry graph`. The volume objects are nodes inside this graph; and the same volume can be accessed starting from different branches. On the other hand, the real geometrical objects that are s",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:11492,Performance,perform,performed,11492,"picted in the `TOP_1` branch.; These are the nodes of the `physical` `tree` of positioned volumes; represented by **`TGeoNode`** objects. This hierarchy is a tree since a; node can have only one parent and several daughters. For a better; understanding of the hierarchy, have a look at; <https://root.cern.ch/doc/master/classTGeoManager.html>. Just close now the `X3D` window and focus at the wire frame picture; drawn in a pad. Activate Options/Event Status. Moving the mouse in the; pad, you will notice that objects are sometimes changing color to red.; Volumes are highlighted in this way whenever the mouse pointer is close; enough to one of its vertices. When this happens, the corresponding; volume is selected and you will see in the bottom right size of the ROOT; canvas its name, shape type and corresponding path in the physical tree.; Right clicking on the screen when a volume is selected will also open; its context menu (picking). Note that there are several actions that can; be performed both at view (no volume selected) and volume level. **`TView`** (mouse not selecting any volume):. - Click-and-drag rotates the view.; - Pressing some keys perform different actions:; - J/K - zoom / unzoom; - H, L, U, I - move the viewpoint; - Right click + `SetParallel` `()/SetPerspective` `()` - switch from; parallel to perspective view.; - Right click + `ShowAxis()` - show coordinate axes.; - Right click + `Centered/Left/Side/Top` - change view direction. **`TGeoVolume`** (mouse selecting a volume):. - Double click will focus the corresponding volume.; - Right click + `CheckOverlaps()` - run overlap checker on current; volume.; - Right click + `Draw` `()` - draw that volume according current; global visualization options; - Right click + `DrawOnly()`***` - `***draw only the selected volume.; - Right click + `InspectShape/Material()` - print info about shape or; material.; - Right click + `Raytrace()` - initiate a ray tracing algorithm on; current view.; - Right click + `RandomPo",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:11658,Performance,perform,perform,11658,"erstanding of the hierarchy, have a look at; <https://root.cern.ch/doc/master/classTGeoManager.html>. Just close now the `X3D` window and focus at the wire frame picture; drawn in a pad. Activate Options/Event Status. Moving the mouse in the; pad, you will notice that objects are sometimes changing color to red.; Volumes are highlighted in this way whenever the mouse pointer is close; enough to one of its vertices. When this happens, the corresponding; volume is selected and you will see in the bottom right size of the ROOT; canvas its name, shape type and corresponding path in the physical tree.; Right clicking on the screen when a volume is selected will also open; its context menu (picking). Note that there are several actions that can; be performed both at view (no volume selected) and volume level. **`TView`** (mouse not selecting any volume):. - Click-and-drag rotates the view.; - Pressing some keys perform different actions:; - J/K - zoom / unzoom; - H, L, U, I - move the viewpoint; - Right click + `SetParallel` `()/SetPerspective` `()` - switch from; parallel to perspective view.; - Right click + `ShowAxis()` - show coordinate axes.; - Right click + `Centered/Left/Side/Top` - change view direction. **`TGeoVolume`** (mouse selecting a volume):. - Double click will focus the corresponding volume.; - Right click + `CheckOverlaps()` - run overlap checker on current; volume.; - Right click + `Draw` `()` - draw that volume according current; global visualization options; - Right click + `DrawOnly()`***` - `***draw only the selected volume.; - Right click + `InspectShape/Material()` - print info about shape or; material.; - Right click + `Raytrace()` - initiate a ray tracing algorithm on; current view.; - Right click + `RandomPoints/Rays()` - shoot random points or rays; inside the bounding box of the clicked volume and display only those; inside visible volumes.; - Right click + `Weight()` - estimates the weight of a volume within a; given precision. Note that the",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:17340,Performance,perform,performing,17340,"ent *elem,; Double_t weight);; void TGeoMixture::DefineElement(Int_t iel, Int_t z, Int_t natoms);; ```. or:. ``` {.cpp}; void AddElement(TGeoMaterial* mat, Double_t weight);; void AddElement(TGeoElement* elem, Double_t weight);; void AddElement(TGeoElement* elem, Int_t natoms);; void AddElement(Double_t a, Double_t z, Double_t weight); ```. - `iel:` index of the element` [0,nel-1]`; - `a` and `z:` the atomic mass and charge; - `weight:` proportion by mass of the elements; - `natoms`: number of atoms of the element in the molecule making the; mixture. The radiation length is automatically computed when all elements are; defined. Since tracking MC provide several other ways to create; materials/mixtures, the materials classes are likely to evolve as the; interfaces to these engines are being developed. Generally in the; process of tracking material properties are not enough and more specific; media properties have to be defined. These highly depend on the MC; performing tracking and sometimes allow the definition of different; media properties (e.g. energy or range cuts) for the same material. ### Radionuclides. A new class **`TGeoElementRN`** was introduced in this version to; provide support for radioactive nuclides and their decays. A database of; 3162 radionuclides can be loaded on demand via the table of elements; (**`TGeoElementTable`** class). One can make then materials/mixtures; based on these radionuclides and use them in a geometry. ``` {.cpp}; root[] TGeoManager *geom = new TGeoManager(""geom"",""radionuclides"");; root[] TGeoElementTable *table = geom->GetElementTable();; root[] TGeoElementRN *c14 = table->GetElementRN(14,6); // A,Z; root[] c14->Print();; 6-C-014 ENDF=60140; A=14; Z=6; Iso=0; Level=0[MeV]; Dmass=3.0199[MeV];; Hlife=1.81e+11[s] J/P=0+; Abund=0; Htox=5.8e-10; Itox=5.8e-10; Stat=0; Decay modes:; BetaMinus Diso: 0 BR: 100.000% Qval: 0.1565; ```. One can make materials or mixtures from radionuclides:. ``` {.cpp}; root[] TGeoMaterial *mat = new TGeo",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:17663,Performance,load,loaded,17663,"ble_t z, Double_t weight); ```. - `iel:` index of the element` [0,nel-1]`; - `a` and `z:` the atomic mass and charge; - `weight:` proportion by mass of the elements; - `natoms`: number of atoms of the element in the molecule making the; mixture. The radiation length is automatically computed when all elements are; defined. Since tracking MC provide several other ways to create; materials/mixtures, the materials classes are likely to evolve as the; interfaces to these engines are being developed. Generally in the; process of tracking material properties are not enough and more specific; media properties have to be defined. These highly depend on the MC; performing tracking and sometimes allow the definition of different; media properties (e.g. energy or range cuts) for the same material. ### Radionuclides. A new class **`TGeoElementRN`** was introduced in this version to; provide support for radioactive nuclides and their decays. A database of; 3162 radionuclides can be loaded on demand via the table of elements; (**`TGeoElementTable`** class). One can make then materials/mixtures; based on these radionuclides and use them in a geometry. ``` {.cpp}; root[] TGeoManager *geom = new TGeoManager(""geom"",""radionuclides"");; root[] TGeoElementTable *table = geom->GetElementTable();; root[] TGeoElementRN *c14 = table->GetElementRN(14,6); // A,Z; root[] c14->Print();; 6-C-014 ENDF=60140; A=14; Z=6; Iso=0; Level=0[MeV]; Dmass=3.0199[MeV];; Hlife=1.81e+11[s] J/P=0+; Abund=0; Htox=5.8e-10; Itox=5.8e-10; Stat=0; Decay modes:; BetaMinus Diso: 0 BR: 100.000% Qval: 0.1565; ```. One can make materials or mixtures from radionuclides:. ``` {.cpp}; root[] TGeoMaterial *mat = new TGeoMaterial(""C14"", c14, 2.0);; ```. The following properties of radionuclides can be currently accessed via; getters in the **`TGeoElementRN`** class:. Atomic number and charge (from the base class **`TGeoElement`**). - Isomeric number (`ISO`); - ENDF code - following the convention: `ENDF=10000*Z+100*A+ISO`; - I",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:22799,Performance,perform,performing,22799,"s; a pointer to a material and the additional data members representing the; properties related to tracking. ``` {.cpp}; TGeoMedium(const char *name,Int_t numed,TGeoMaterial *mat,; Double_t *params=0);; ```. - `name:` name assigned to the medium; - `mat:` pointer to a material; - `params:` array of additional parameters. Another constructor allows effectively defining tracking parameters in; GEANT3 style:. ``` {.cpp}; TGeoMedium(const char *name,Int_t numed,Int_t imat,Int_t ifield,; Double_t fieldm,Double_t tmaxfd,Double_t stemax,; Double_t deemax,Double_t epsil,Double_t stmin);; ```. This constructor is reserved for creating tracking media from the VMC; interface [...]:. - `numed:` user-defined medium index; - `imat:` unique ID of the material; - `others:` see G3 documentation. Looking at our simple world example, one can see that for creating; volumes one needs to create tracking media before. The way to proceed; for those not interested in performing tracking with external MC's is to; define and use only one `dummy tracking medium` as in the example (or a; `NULL` pointer). ### User Interface for Handling Materials and Media. The **`TGeoManager`** class contains the API for accessing and handling; defined materials:. ``` {.cpp}; TGeoManager::GetMaterial(name);; ```. ## Shapes. Shapes are geometrical objects that provide the basic modeling; functionality. They provide the definition of the `local` coordinate; system of the volume. Any volume must have a shape. Any shape recognized; by the modeller has to derive from the base **`TGeoShape`** class,; providing methods for:. - Finding out if a point defined in their local frame is contained or; not by the shape;; - Computing the distance to enter/exit the shape from a local point,; given a known direction;; - Computing the maximum distance in any direction from a local point; that does NOT result in a boundary crossing of the shape (safe; distance);; - Computing the cosines of the normal vector to the crossed shape; s",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:26340,Performance,optimiz,optimize,26340,"*. However, there; are certain functionalities that work with the assumption that the used; lengths are expressed in centimeters. This is the case for shape; capacity or volume weight computation. The same is valid when using the; ROOT geometry as navigator for an external transport MC package (e.g.; GEANT) via the VMC interface. Other units in use: All angles used for defining rotation matrices or; some shape parameters are expressed in **degrees**. Material density is; expressed in [**g/cm3**]. ### Primitive Shapes. #### Boxes - TGeoBBox Class. Normally a box has to be built only with 3 parameters: `DX,DY,DZ`; representing the half-lengths on X, Y and Z-axes. In this case, the; origin of the box will match the one of its reference frame and the box; will range from: `-DX` to `DX` on X-axis, from `-DY` to `DY` on Y and; from `-DZ` to `DZ` on Z. On the other hand, any other shape needs to; compute and store the parameters of their minimal bounding box. The; bounding boxes are essential to optimize navigation algorithms.; Therefore all other primitives derive from **`TGeoBBox`**. Since the; minimal bounding box is not necessary centered in the origin, any box; allows an origin translation `(Ox`,`Oy`,`Oz)`. All primitive; constructors automatically compute the bounding box parameters. Users; should be aware that building a translated box that will represent a; primitive shape by itself would affect any further positioning of other; shapes inside. Therefore it is highly recommendable to build; non-translated boxes as primitives and translate/rotate their; corresponding volumes only during positioning stage. ``` {.cpp}; TGeoBBox(Double_t dx,Double_t dy,Double_t dz,Double_t *origin=0);; ```. ![TGeoBBox class](pictures/060001B6.png). #### Parallelepiped - TGeoPara class. A parallelepiped is a shape having 3 pairs of parallel faces out of; which one is parallel with the XY plane (Z faces). All faces are; parallelograms in the general case. The Z faces have 2 edges parallel;",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:43255,Performance,perform,performance,43255,"char *name, Double_t *point[3],; Double_t *norm[3]);; ```. ### Composite Shapes. Composite shapes are Boolean combinations of two or more shape; components. The supported Boolean operations are union (+), intersection; (\*) and subtraction(-). Composite shapes derive from the base; **`TGeoShape`** class, therefore providing all shape features:; computation of bounding box, finding if a given point is inside or; outside the combination, as well as computing the distance to; entering/exiting. They can be directly used for creating volumes or used; in the definition of other composite shapes. Composite shapes are provided in order to complement and extend the set; of basic shape primitives. They have a binary tree internal structure,; therefore all shape-related geometry queries are signals propagated from; top level down to the final leaves, while the provided answers are; assembled and interpreted back at top. This `CSG`; `(composite solid geometry)` hierarchy is effective for small number of; components, while performance drops dramatically for large structures.; Building a complete geometry in this style is virtually possible but; highly not recommended. #### The Structure of Composite Shapes. A composite shape can always be looked as the result of a Boolean; operation between only two shape components. All information identifying; these two components as well as their positions with respect to the; frame of the composite is represented by an object called Boolean node.; A composite shape has a pointer to such a Boolean node. Since the shape; components may also be composites, they will also contain binary Boolean; nodes branching out other two shapes in the hierarchy. Any such branch; ends-up when the final leaves are no longer composite shapes, but basic; primitives. The figure shows the composite shapes structure. ![The composite shapes structure](pictures/080001CA.png). Suppose that A, B, C and D represent basic shapes, we will illustrate; how the internal repr",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:50074,Performance,perform,performed,50074,"isualize it with ray tracing; top->Raytrace();; ```. ![A composite shape example](pictures/080001CD.png). Composite shapes can be subsequently used for defining volumes.; Moreover, these volumes contain other volumes, following the general; criteria. Volumes created based on composite shapes cannot be divided. ### Navigation Methods Performed By Shapes. Shapes are named objects and register themselves to the `manager class`; at creation time. This is responsible for their final deletion. Shapes; can be created without name if their retrieval by name is no needed.; Generally shapes are objects that are useful only at geometry creation; stage. The pointer to a shape is in fact needed only when referring to a; given volume and it is always accessible at that level. Several volumes; may reference a single shape; therefore its deletion is not possible; once volumes were defined based on it. The navigation features related for instance to tracking particles are; performed in the following way: Each shape implement its specific; algorithms for all required tasks in its local reference system. Note; that the manager class handles global queries related to geometry.; However, shape-related queries might be sometimes useful:. ``` {.cpp}; Bool_t TGeoShape::Contains(Double_t *point[3]);; ```. The method above returns `kTRUE` if the point \*point is actually inside; the shape. The point has to be defined in the local shape reference. For; instance, for a box having `DX,DY` and `DZ `half-lengths a point will be; considered inside if:. `-DX <= point[0] <= DX`. `-DY <= point[1] <= DY`. `-DZ <= point[2] <= DZ`. ``` {.cpp}; Double_t TGeoShape::DistFromInside(Double_t *point[3],; Double_t *dir[3], Int_t iact,Double_t step,Double_t *safe);; ```. The method computes the distance to exiting a shape from a given point; `inside`, along a given direction. This direction is given by its; director cosines with respect to the local shape coordinate system. This; method provides additional info",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:53950,Performance,perform,performed,53950,"A specific shape can be created; stand-alone:. ``` {.cpp}; TGeoBBox *box = new TGeoBBox(""s_box"",halfX,halfY,halfZ); // named; TGeoTube *tub = new TGeoTube(rmin,rmax,halfZ); // no name; //... (See all specific shape constructors); ```. Sometimes it is much easier to create a volume having a given shape in; one step, since shapes are not directly linked in the geometrical tree; but volumes are:. ``` {.cpp}; TGeoVolume *vol_box = gGeoManager->MakeBox(""BOX_VOL"",pmed,halfX,; halfY,halfZ);; TGeoVolume *vol_tub = gGeoManager->MakeTube(""TUB_VOL"",pmed,rmin,; rmax,halfZ);; // ...(See MakeXXX() utilities in TGeoManager class); ```. ### Dividing Shapes. Shapes can generally be divided along a given axis. Supported axes are:; `X`, `Y`, `Z`, `Rxy`, `Phi`, `Rxyz`. A given shape cannot be divided; however on any axis. The general rule is that that divisions are; possible on whatever axis that produces still known shapes as slices.; The division of shapes are performed by the call `TGeoShape::Divide()`,; but this operation can be done only via `TGeoVolume::Divide()` method.; In other words, the algorithm for dividing a specific shape is known by; the shape object, but is always invoked in a generic way from the volume; level. Details on how to do that can be found in the paragraph ‘Dividing; volumes'. One can see how all division options are interpreted and which; their result inside specific shape classes is. ### Parametric Shapes. Shapes generally have a set of parameters that is well defined at build; time. In fact, when the final geometrical hierarchy is assembled and the; geometry is closed, all constituent shapes `MUST`**have well defined and; valid parameters. In order to ease-up geometry creation, some; parameterizations are however allowed. For instance let's suppose that we need to define several volumes having; exactly the same properties but different sizes. A way to do this would; be to create as many different volumes and shapes. The modeller allows; however the definit",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:57490,Performance,load,loaded,57490,". Whenever positioned inside; a mother volume, this will create a normal **`TGeoVolume`** object; having as shape a box with `dz` fitting the corresponding `dz `of the; mother shape. Generally, this type of parameterization is used when; positioning volumes in containers having a matching shape, but it works; also for most reasonable combinations. ## Geometry Creation. A given geometry can be built in various ways, but one has to follow; some mandatory steps. Even if we might use some terms that will be; explained later, here are few general rules:. - Volumes need media and shapes in order to be created.; - Both containers and contained volumes must be created before linking; them together, and the relative transformation matrix must be; provided.; - Any volume have to be positioned somewhere otherwise it will not be; considered as part of the geometry.; - Visibility or tracking properties of volumes can be provided both at; build time or after geometry is closed, but global visualization; settings (see section: ""The Drawing Package"") should not be provided; at build time, otherwise the drawing package will be loaded. There is also a list of specific rules:. - Positioned volumes should not extrude their container or intersect; with others within this unless it is specified (see section:; Overlapping Volumes).; - The top volume (containing all geometry trees) must be specified; before closing the geometry and must not be positioned - it; represents the global reference frame.; - After building the full geometry tree, the geometry must be closed; (see the method **`TGeoManager`**`::CloseGeometry()`). Voxelization; can be redone per volume after this process. The list is much bigger and we will describe in more detail the geometry; creation procedure in the following sections. Provided that geometry was; successfully built and closed, the **`TGeoManager`** class will register; itself to ROOT and the logical/physical structures will become; immediately browsable. ### Th",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:62922,Performance,perform,perform,62922,"an be asked for at a given moment, but; rather represented by the combination: current node/current global; matrix. However, physical nodes have unique ID's that can be retrieved; for a given modeller state. These can be fed back to the modeller in; order to force a physical node to become current. The advantage of this; comes from the fact that all navigation queries check first the current; node; therefore the location of a point in the geometry can be saved as; a starting state for later use. Nodes can be declared as `overlapping` in case they do overlap with; other nodes inside the same container or extrude this container (see; also ‘Checking the Geometry'). Non-overlapping nodes can be created; with:. ``` {.cpp}; TGeoVolume::AddNode(TGeoVolume *daughter,Int_t copy_No,; TGeoMatrix *matr);; ```. The creation of overlapping nodes can be done with a similar prototype:. ``` {.cpp}; TGeoVolume::AddNodeOverlap(/*same arguments*/);; ```. When closing the geometry, overlapping nodes perform a check of possible; overlaps with their neighbors. These are stored and checked all the time; during navigation; therefore, navigation is slower when embedding such; nodes into geometry. Nodes have visualization attributes as the volume; has. When undefined by users, painting a node on a pad will take the; corresponding volume attributes. ### Creating and Positioning Volumes. #### Making Volumes. As mentioned before, volumes are the basic objects used in building the; geometrical hierarchy. They represent objects that are not positioned,; but store all information about the placement of the other volumes they; may contain. Therefore a volume can be replicated several times in the; geometry. As it was explained, in order to create a volume, one has to; put together a shape and a medium, which are already defined. Volumes have to be named by users at creation time. Every different name; may represent a unique volume object, but may also represent more; general a family (class) of volum",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:65854,Performance,perform,performances,65854," Making a volume with a given shape in one step; TGeoVolume *vol = gGeoManager->MakeBox(""VNAME"",ptrMed,dx,dy,dz);; TGeoVolume *vol = gGeoManager->MakeTubs(""VNAME"",ptrMed,rmin,rmax,; dz,phi1,phi2);. // See class TGeoManager for the rest of shapes.; // Making a volume with a given shape with a unique prototype; TGeoVolume *vol = gGeoManager->Volume(""VNAME"",""XXXX"",nmed,upar,; npar);. // Where XXXX stands for the first 4 letters of the specific shape; // classes, nmed is the medium number, upar is an Double_t * array; // of the shape parameters and npar is the number of parameters.; // This prototype allows (npar = 0) to define volumes with shape; // defined only at positioning time (volumes defined in this way; // need to be positioned using TGeoManager::Node() method); ```. #### Positioned Volumes (Nodes). Geometrical modeling is a difficult task when the number of different; geometrical objects is 106-108. This is more or less the case for; detector geometries of complex experiments, where a ‘flat' CSG model; description cannot scale with the current CPU performances. This is the; reason why models like GEANT [1] introduced an additional dimension; (depth) in order to reduce the complexity of the problem. This concept; is also preserved by the ROOT modeller and introduces a pure geometrical; constraint between objects (volumes in our case) - containment. This; means in fact that any positioned volume has to be contained by another.; Now what means contained and positioned?. - We will say that a volume `contains` a point if this is inside the; shape associated to the volume. For instance, a volume having a box; shape will contain all points `P=(X,Y,Z)` verifying the conditions:; `Abs(Pi)dXi`. The points on the shape boundaries are considered as; inside the volume. The volume contains a daughter if it contains all; the points contained by the daughter.; - The definition of containment works of course only with points; defined in the local coordinate system of the consid",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:68511,Performance,optimiz,optimization,68511,"trix=gGeoIdentity); ```. The objects referencing a volume and a transformation are called `NODES`; and their creation is fully handled by the modeller. They represent the; link elements in the hierarchy of volumes. Nodes are unique and distinct; geometrical objects ONLY from their container point of view. Since; volumes can be replicated in the geometry, the same node may be found on; different branches. In order to provide navigation features, volumes have to be able to find; the proper container of any point defined in the local reference frame.; This can be the volume itself, one of its positioned daughter volumes or; none if the point is actually outside. On the other hand, volumes have; to provide also other navigation methods such as finding the distances; to its shape boundaries or which daughter will be crossed first. The; implementation of these features is done at shape level, but the local; mother-daughters management is handled by volumes. These build; additional optimization structures upon geometry closure. In order to; have navigation features properly working one has to follow some rules; for building a valid geometry. - The daughter volume(s) must not extrude the mother shape. They are; allowed however to have a common boundaries.; - The volumes positioned in the same container must not overlap with; each other. They may touch on one boundaries or shape vertex. The daughter nodes of a volume can be also removed or replaced with; other nodes:. ``` {.cpp}; void RemoveNode(TGeoNode* node); TGeoNode*ReplaceNode(TGeoNode* nodeorig, TGeoShape* newshape = 0,; TGeoMatrix* newpos = 0, TGeoMedium* newmed = 0); ```. The last method allows replacing an existing daughter of a volume with; another one. Providing only the node to be replaced will just create a; new volume for the node but having exactly the same parameters as the; old one. This helps in case of divisions for decoupling a node from the; logical hierarchy so getting new content/properties. For non-di",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:69850,Performance,optimiz,optimizes,69850,"ith; each other. They may touch on one boundaries or shape vertex. The daughter nodes of a volume can be also removed or replaced with; other nodes:. ``` {.cpp}; void RemoveNode(TGeoNode* node); TGeoNode*ReplaceNode(TGeoNode* nodeorig, TGeoShape* newshape = 0,; TGeoMatrix* newpos = 0, TGeoMedium* newmed = 0); ```. The last method allows replacing an existing daughter of a volume with; another one. Providing only the node to be replaced will just create a; new volume for the node but having exactly the same parameters as the; old one. This helps in case of divisions for decoupling a node from the; logical hierarchy so getting new content/properties. For non-divided; volumes, one can change the shape and/or the position of the daughter. #### Virtual Containers and Assemblies of Volumes. Virtual containers are volumes that do not represent real objects, but; they are needed for grouping and positioning together other volumes.; Such grouping helps not only geometry creation, but also optimizes; tracking performance; therefore, it is highly recommended. Virtual; volumes need to inherit material/medium properties from the volume they; are placed into in order to be ""invisible"" at tracking time. Let us suppose that we need to group together two volumes `A` and `B`; into a structure and position this into several other volumes `D,E,` and; `F`. What we need to do is to create a virtual container volume `C`; holding `A` and `B`, then position `C` in the other volumes. Note that `C` is a volume having a determined medium. Since it is not a; real volume, we need to manually set its medium the same as that of; `D,E` or `F` in order to make it ‘invisible' (same physics properties).; In other words, the limitation in proceeding this way is that `D,E,` and; `F` must point to the same medium. If this was not the case, we would; have to define different virtual volumes for each placement: `C`, `C'`; and `C""`, having the same shape but different media matching the; corresponding conta",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:69870,Performance,perform,performance,69870,"ith; each other. They may touch on one boundaries or shape vertex. The daughter nodes of a volume can be also removed or replaced with; other nodes:. ``` {.cpp}; void RemoveNode(TGeoNode* node); TGeoNode*ReplaceNode(TGeoNode* nodeorig, TGeoShape* newshape = 0,; TGeoMatrix* newpos = 0, TGeoMedium* newmed = 0); ```. The last method allows replacing an existing daughter of a volume with; another one. Providing only the node to be replaced will just create a; new volume for the node but having exactly the same parameters as the; old one. This helps in case of divisions for decoupling a node from the; logical hierarchy so getting new content/properties. For non-divided; volumes, one can change the shape and/or the position of the daughter. #### Virtual Containers and Assemblies of Volumes. Virtual containers are volumes that do not represent real objects, but; they are needed for grouping and positioning together other volumes.; Such grouping helps not only geometry creation, but also optimizes; tracking performance; therefore, it is highly recommended. Virtual; volumes need to inherit material/medium properties from the volume they; are placed into in order to be ""invisible"" at tracking time. Let us suppose that we need to group together two volumes `A` and `B`; into a structure and position this into several other volumes `D,E,` and; `F`. What we need to do is to create a virtual container volume `C`; holding `A` and `B`, then position `C` in the other volumes. Note that `C` is a volume having a determined medium. Since it is not a; real volume, we need to manually set its medium the same as that of; `D,E` or `F` in order to make it ‘invisible' (same physics properties).; In other words, the limitation in proceeding this way is that `D,E,` and; `F` must point to the same medium. If this was not the case, we would; have to define different virtual volumes for each placement: `C`, `C'`; and `C""`, having the same shape but different media matching the; corresponding conta",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:71073,Performance,optimiz,optimize,71073,"be ""invisible"" at tracking time. Let us suppose that we need to group together two volumes `A` and `B`; into a structure and position this into several other volumes `D,E,` and; `F`. What we need to do is to create a virtual container volume `C`; holding `A` and `B`, then position `C` in the other volumes. Note that `C` is a volume having a determined medium. Since it is not a; real volume, we need to manually set its medium the same as that of; `D,E` or `F` in order to make it ‘invisible' (same physics properties).; In other words, the limitation in proceeding this way is that `D,E,` and; `F` must point to the same medium. If this was not the case, we would; have to define different virtual volumes for each placement: `C`, `C'`; and `C""`, having the same shape but different media matching the; corresponding containers. This might not happen so often, but when it; does, it forces the creation of several extra virtual volumes. Other; limitation comes from the fact that any container is directly used by; navigation algorithms to optimize tracking. These must geometrically; contain their belongings (positioned volumes) so that these do not; extrude its shape boundaries. Not respecting this rule generally leads; to unpredictable results. Therefore `A` and `B` together must fit into; `C` that has to fit also into `D,E,` and `F`. This is not always; straightforward to accomplish, especially when instead of `A` and `B` we; have many more volumes. In order to avoid these problems, one can use for the difficult cases; the class **`TGeoVolumeAssembly`**, representing an assembly of volumes.; This behaves like a normal container volume supporting other volumes; positioned inside, but it has neither shape nor medium. It cannot be; used directly as a piece of the geometry, but just as a temporary; structure helping temporary assembling and positioning volumes. If we define now `C` as an assembly containing `A` and `B`, positioning; the assembly into `D,E` and `F` will actually p",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:80414,Performance,optimiz,optimization,80414,"ompletely distinct: `WIRE_CO_1` and; `WIRE_CO_2`. We will want now to place symmetrically 1000 chambers on a; pad, following a pattern of 20 rows and 50 columns. One way to do this; will be to replicate our chamber by positioning it 1000 times in; different positions of the pad. Unfortunately, this is far from being; the optimal way of doing what we want. Imagine that we would like to; find out which of the 1000 chambers is containing a `(x,y,z)` point; defined in the pad reference. You will never have to do that, since the; modeller will take care of it for you, but let's guess what it has to; do. The most simple algorithm will just loop over all daughters, convert; the point from mother to local reference and check if the current; chamber contains the point or not. This might be efficient for pads with; few chambers, but definitely not for 1000. Fortunately the modeller is; smarter than that and creates for each volume some optimization; structures called `voxels` to minimize the penalty having too many; daughters, but if you have 100 pads like this in your geometry you will; anyway lose a lot in your tracking performance. The way out when; volumes can be arranged according to simple patterns is the usage of; divisions. We will describe them in detail later on. Let's think now at; a different situation: instead of 1000 chambers of the same type, we may; have several types of chambers. Let's say all chambers are cylindrical; and have a wire inside, but their dimensions are different. However, we; would like all to be represented by a single volume family, since they; have the same properties. #### Volume Families. A volume family is represented by the class **`TGeoVolumeMulti`**. It; represents a class of volumes having the same shape type and each member; will be identified by the same name and volume ID. Any operation applied; to a **`TGeoVolumeMulti`** equally affects all volumes in that family.; The creation of a family is generally not a user task, but can be f",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:80604,Performance,perform,performance,80604,"ompletely distinct: `WIRE_CO_1` and; `WIRE_CO_2`. We will want now to place symmetrically 1000 chambers on a; pad, following a pattern of 20 rows and 50 columns. One way to do this; will be to replicate our chamber by positioning it 1000 times in; different positions of the pad. Unfortunately, this is far from being; the optimal way of doing what we want. Imagine that we would like to; find out which of the 1000 chambers is containing a `(x,y,z)` point; defined in the pad reference. You will never have to do that, since the; modeller will take care of it for you, but let's guess what it has to; do. The most simple algorithm will just loop over all daughters, convert; the point from mother to local reference and check if the current; chamber contains the point or not. This might be efficient for pads with; few chambers, but definitely not for 1000. Fortunately the modeller is; smarter than that and creates for each volume some optimization; structures called `voxels` to minimize the penalty having too many; daughters, but if you have 100 pads like this in your geometry you will; anyway lose a lot in your tracking performance. The way out when; volumes can be arranged according to simple patterns is the usage of; divisions. We will describe them in detail later on. Let's think now at; a different situation: instead of 1000 chambers of the same type, we may; have several types of chambers. Let's say all chambers are cylindrical; and have a wire inside, but their dimensions are different. However, we; would like all to be represented by a single volume family, since they; have the same properties. #### Volume Families. A volume family is represented by the class **`TGeoVolumeMulti`**. It; represents a class of volumes having the same shape type and each member; will be identified by the same name and volume ID. Any operation applied; to a **`TGeoVolumeMulti`** equally affects all volumes in that family.; The creation of a family is generally not a user task, but can be f",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:85182,Performance,perform,performed,85182,"de(""SLICEX"",1,N);; ```. Here `SLICEX` is the name of the new family representing all slices and; 1 is the slicing axis. The meaning of the axis index is the following:; for all volumes having shapes like `box`, `trd1`, `trd2`, `trap`,; `gtra `or` para - `1, 2, 3 mean X, Y, Z; for `tube`, `tubs`, `cone`,; `cons - `1 means `Rxy`, 2 means `phi` and 3 means Z; for `pcon` and; `pgon` - 2 means `phi` and 3 means Z; for spheres 1 means `R `and 2; means `phi.`. In fact, the division operation has the same effect as positioning; volumes in a given order inside the divided container - the advantage; being that the navigation in such a structure is much faster. When a; volume is divided, a volume family corresponding to the slices is; created. In case all slices can be represented by a single shape, only; one volume is added to the family and positioned N times inside the; divided volume, otherwise, each slice will be represented by a distinct; volume in the family. Divisions can be also performed in a given range of one axis. For that,; one has to specify also the starting coordinate value and the step:. ``` {.cpp}; TGeoVolume *slicex = box->Divide(""SLICEX"",1,N,start,step);; ```. A check is always done on the resulting division range: if not fitting; into the container limits, an error message is posted. If we will browse; the divided volume we will notice that it will contain N nodes starting; with index 1 up to N. The first one has the lower X limit at `START`; position, while the last one will have the upper X limit at; `START+N*STEP`. The resulting slices cannot be positioned inside another; volume (they are by default positioned inside the divided one) but can; be further divided and may contain other volumes:. ``` {.cpp}; TGeoVolume *slicey = slicex->Divide(""SLICEY"",2,N1);; slicey->AddNode(other_vol,index,some_matrix);; ```. When doing that, we have to remember that `SLICEY` represents a family,; therefore all members of the family will be divided on Y and the other; vo",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:89043,Performance,perform,performance,89043," together, for different possible reasons. One; of these is that the structure has to be replicated in several parts of; the geometry, or it may simply happen that they really represent a; single object, too complex to be described by a primitive shape. Usually handling structures like these can be easily done by positioning; all components in the same container volume, then positioning the; container itself. However, there are many practical cases when defining; such a container is not straightforward or even possible without; generating overlaps with the rest of the geometry. There are few ways; out of this:. - Defining the container for the structure as ""overlapping"" (see also; "" Overlapping Volumes **""**); - Representing the container as a composite shape - the Boolean union; of all components (see also "" Composite Shapes ""); - Using an assembly volume - this will be described in the following. The first two approaches have the disadvantage of penalizing the; navigation performance with a factor increasing more than linear of the; number of components in the structure. The best solution is the third; one because it uses all volume-related navigation optimizations. The; class **`TGeoVolumeAssembly`** represents an assembly volume. Its shape; is represented by **`TGeoShapeAssembly`** class that is the union of all; components. It uses volume voxelization to perform navigation tasks. An assembly volume creates a hierarchical level and it geometrically; insulates the structure from the rest (as a normal volume). Physically,; a point that is INSIDE a **`TGeoShapeAssembly`** is always inside one of; the components, so a **`TGeoVolumeAssembly`** does not need to have a; medium. Due to the self-containment of assemblies, they are very; practical to use when a container is hard to define due to possible; overlaps during positioning. For instance, it is very easy creating; honeycomb structures. A very useful example for creating and using; assemblies can be found at:; <ht",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:89226,Performance,optimiz,optimizations,89226," it may simply happen that they really represent a; single object, too complex to be described by a primitive shape. Usually handling structures like these can be easily done by positioning; all components in the same container volume, then positioning the; container itself. However, there are many practical cases when defining; such a container is not straightforward or even possible without; generating overlaps with the rest of the geometry. There are few ways; out of this:. - Defining the container for the structure as ""overlapping"" (see also; "" Overlapping Volumes **""**); - Representing the container as a composite shape - the Boolean union; of all components (see also "" Composite Shapes ""); - Using an assembly volume - this will be described in the following. The first two approaches have the disadvantage of penalizing the; navigation performance with a factor increasing more than linear of the; number of components in the structure. The best solution is the third; one because it uses all volume-related navigation optimizations. The; class **`TGeoVolumeAssembly`** represents an assembly volume. Its shape; is represented by **`TGeoShapeAssembly`** class that is the union of all; components. It uses volume voxelization to perform navigation tasks. An assembly volume creates a hierarchical level and it geometrically; insulates the structure from the rest (as a normal volume). Physically,; a point that is INSIDE a **`TGeoShapeAssembly`** is always inside one of; the components, so a **`TGeoVolumeAssembly`** does not need to have a; medium. Due to the self-containment of assemblies, they are very; practical to use when a container is hard to define due to possible; overlaps during positioning. For instance, it is very easy creating; honeycomb structures. A very useful example for creating and using; assemblies can be found at:; <http://root.cern.ch/root/html/examples/assembly.C.html>`.`. Creation of an assembly is very easy: one has just to create a; **`TGeoVolumeAss",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:89436,Performance,perform,perform,89436,"positioning the; container itself. However, there are many practical cases when defining; such a container is not straightforward or even possible without; generating overlaps with the rest of the geometry. There are few ways; out of this:. - Defining the container for the structure as ""overlapping"" (see also; "" Overlapping Volumes **""**); - Representing the container as a composite shape - the Boolean union; of all components (see also "" Composite Shapes ""); - Using an assembly volume - this will be described in the following. The first two approaches have the disadvantage of penalizing the; navigation performance with a factor increasing more than linear of the; number of components in the structure. The best solution is the third; one because it uses all volume-related navigation optimizations. The; class **`TGeoVolumeAssembly`** represents an assembly volume. Its shape; is represented by **`TGeoShapeAssembly`** class that is the union of all; components. It uses volume voxelization to perform navigation tasks. An assembly volume creates a hierarchical level and it geometrically; insulates the structure from the rest (as a normal volume). Physically,; a point that is INSIDE a **`TGeoShapeAssembly`** is always inside one of; the components, so a **`TGeoVolumeAssembly`** does not need to have a; medium. Due to the self-containment of assemblies, they are very; practical to use when a container is hard to define due to possible; overlaps during positioning. For instance, it is very easy creating; honeycomb structures. A very useful example for creating and using; assemblies can be found at:; <http://root.cern.ch/root/html/examples/assembly.C.html>`.`. Creation of an assembly is very easy: one has just to create a; **`TGeoVolumeAssembly`** object and position the components inside as; for any volume:. ``` {.cpp}; TGeoVolume *vol = new TGeoVolumeAssembly(name);; vol->AddNode(vdaughter1, cpy1, matrix1);; vol->AddNode(vdaughter2, cpy2, matrix2);; ```. Note that component",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:90629,Performance,optimiz,optimizing,90629,"me). Physically,; a point that is INSIDE a **`TGeoShapeAssembly`** is always inside one of; the components, so a **`TGeoVolumeAssembly`** does not need to have a; medium. Due to the self-containment of assemblies, they are very; practical to use when a container is hard to define due to possible; overlaps during positioning. For instance, it is very easy creating; honeycomb structures. A very useful example for creating and using; assemblies can be found at:; <http://root.cern.ch/root/html/examples/assembly.C.html>`.`. Creation of an assembly is very easy: one has just to create a; **`TGeoVolumeAssembly`** object and position the components inside as; for any volume:. ``` {.cpp}; TGeoVolume *vol = new TGeoVolumeAssembly(name);; vol->AddNode(vdaughter1, cpy1, matrix1);; vol->AddNode(vdaughter2, cpy2, matrix2);; ```. Note that components cannot be declared as ""overlapping"" and that a; component can be an assembly volume. For existing flat volume; structures, one can define assemblies to force a hierarchical structure; therefore optimizing the performance. Usage of assemblies does NOT imply; penalties in performance, but in some cases, it can be observed that it; is not as performing as bounding the structure in a container volume; with a simple shape. Choosing a normal container is therefore; recommended whenever possible. ![Assemblies of volumes](pictures/080001CF.png). ### Geometrical Transformations. All geometrical transformations handled by the modeller are provided as; a built-in package. This was designed to minimize memory requirements; and optimize performance of point/vector master-to-local and; local-to-master computation. We need to have in mind that a; transformation in **`TGeo`** has two major use-cases. The first one is; for defining the placement of a volume with respect to its container; reference frame. This frame will be called 'master' and the frame of the; positioned volume - 'local'. If `T` is a transformation used for; positioning volume daughter",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:90644,Performance,perform,performance,90644,"me). Physically,; a point that is INSIDE a **`TGeoShapeAssembly`** is always inside one of; the components, so a **`TGeoVolumeAssembly`** does not need to have a; medium. Due to the self-containment of assemblies, they are very; practical to use when a container is hard to define due to possible; overlaps during positioning. For instance, it is very easy creating; honeycomb structures. A very useful example for creating and using; assemblies can be found at:; <http://root.cern.ch/root/html/examples/assembly.C.html>`.`. Creation of an assembly is very easy: one has just to create a; **`TGeoVolumeAssembly`** object and position the components inside as; for any volume:. ``` {.cpp}; TGeoVolume *vol = new TGeoVolumeAssembly(name);; vol->AddNode(vdaughter1, cpy1, matrix1);; vol->AddNode(vdaughter2, cpy2, matrix2);; ```. Note that components cannot be declared as ""overlapping"" and that a; component can be an assembly volume. For existing flat volume; structures, one can define assemblies to force a hierarchical structure; therefore optimizing the performance. Usage of assemblies does NOT imply; penalties in performance, but in some cases, it can be observed that it; is not as performing as bounding the structure in a container volume; with a simple shape. Choosing a normal container is therefore; recommended whenever possible. ![Assemblies of volumes](pictures/080001CF.png). ### Geometrical Transformations. All geometrical transformations handled by the modeller are provided as; a built-in package. This was designed to minimize memory requirements; and optimize performance of point/vector master-to-local and; local-to-master computation. We need to have in mind that a; transformation in **`TGeo`** has two major use-cases. The first one is; for defining the placement of a volume with respect to its container; reference frame. This frame will be called 'master' and the frame of the; positioned volume - 'local'. If `T` is a transformation used for; positioning volume daughter",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:90706,Performance,perform,performance,90706,". Due to the self-containment of assemblies, they are very; practical to use when a container is hard to define due to possible; overlaps during positioning. For instance, it is very easy creating; honeycomb structures. A very useful example for creating and using; assemblies can be found at:; <http://root.cern.ch/root/html/examples/assembly.C.html>`.`. Creation of an assembly is very easy: one has just to create a; **`TGeoVolumeAssembly`** object and position the components inside as; for any volume:. ``` {.cpp}; TGeoVolume *vol = new TGeoVolumeAssembly(name);; vol->AddNode(vdaughter1, cpy1, matrix1);; vol->AddNode(vdaughter2, cpy2, matrix2);; ```. Note that components cannot be declared as ""overlapping"" and that a; component can be an assembly volume. For existing flat volume; structures, one can define assemblies to force a hierarchical structure; therefore optimizing the performance. Usage of assemblies does NOT imply; penalties in performance, but in some cases, it can be observed that it; is not as performing as bounding the structure in a container volume; with a simple shape. Choosing a normal container is therefore; recommended whenever possible. ![Assemblies of volumes](pictures/080001CF.png). ### Geometrical Transformations. All geometrical transformations handled by the modeller are provided as; a built-in package. This was designed to minimize memory requirements; and optimize performance of point/vector master-to-local and; local-to-master computation. We need to have in mind that a; transformation in **`TGeo`** has two major use-cases. The first one is; for defining the placement of a volume with respect to its container; reference frame. This frame will be called 'master' and the frame of the; positioned volume - 'local'. If `T` is a transformation used for; positioning volume daughters, then: `MASTER = T * LOCAL`. Therefore `T `is used to perform a local to master conversion, while; `T-1` for a master to local conversion. The second use case is the;",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:90776,Performance,perform,performing,90776,". Due to the self-containment of assemblies, they are very; practical to use when a container is hard to define due to possible; overlaps during positioning. For instance, it is very easy creating; honeycomb structures. A very useful example for creating and using; assemblies can be found at:; <http://root.cern.ch/root/html/examples/assembly.C.html>`.`. Creation of an assembly is very easy: one has just to create a; **`TGeoVolumeAssembly`** object and position the components inside as; for any volume:. ``` {.cpp}; TGeoVolume *vol = new TGeoVolumeAssembly(name);; vol->AddNode(vdaughter1, cpy1, matrix1);; vol->AddNode(vdaughter2, cpy2, matrix2);; ```. Note that components cannot be declared as ""overlapping"" and that a; component can be an assembly volume. For existing flat volume; structures, one can define assemblies to force a hierarchical structure; therefore optimizing the performance. Usage of assemblies does NOT imply; penalties in performance, but in some cases, it can be observed that it; is not as performing as bounding the structure in a container volume; with a simple shape. Choosing a normal container is therefore; recommended whenever possible. ![Assemblies of volumes](pictures/080001CF.png). ### Geometrical Transformations. All geometrical transformations handled by the modeller are provided as; a built-in package. This was designed to minimize memory requirements; and optimize performance of point/vector master-to-local and; local-to-master computation. We need to have in mind that a; transformation in **`TGeo`** has two major use-cases. The first one is; for defining the placement of a volume with respect to its container; reference frame. This frame will be called 'master' and the frame of the; positioned volume - 'local'. If `T` is a transformation used for; positioning volume daughters, then: `MASTER = T * LOCAL`. Therefore `T `is used to perform a local to master conversion, while; `T-1` for a master to local conversion. The second use case is the;",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:91160,Performance,optimiz,optimize,91160," **`TGeoVolumeAssembly`** object and position the components inside as; for any volume:. ``` {.cpp}; TGeoVolume *vol = new TGeoVolumeAssembly(name);; vol->AddNode(vdaughter1, cpy1, matrix1);; vol->AddNode(vdaughter2, cpy2, matrix2);; ```. Note that components cannot be declared as ""overlapping"" and that a; component can be an assembly volume. For existing flat volume; structures, one can define assemblies to force a hierarchical structure; therefore optimizing the performance. Usage of assemblies does NOT imply; penalties in performance, but in some cases, it can be observed that it; is not as performing as bounding the structure in a container volume; with a simple shape. Choosing a normal container is therefore; recommended whenever possible. ![Assemblies of volumes](pictures/080001CF.png). ### Geometrical Transformations. All geometrical transformations handled by the modeller are provided as; a built-in package. This was designed to minimize memory requirements; and optimize performance of point/vector master-to-local and; local-to-master computation. We need to have in mind that a; transformation in **`TGeo`** has two major use-cases. The first one is; for defining the placement of a volume with respect to its container; reference frame. This frame will be called 'master' and the frame of the; positioned volume - 'local'. If `T` is a transformation used for; positioning volume daughters, then: `MASTER = T * LOCAL`. Therefore `T `is used to perform a local to master conversion, while; `T-1` for a master to local conversion. The second use case is the; computation of the global transformation of a given object in the; geometry. Since the geometry is built as 'volumes-inside-volumes', the; global transformation represents the pile-up of all local; transformations in the corresponding branch. Once a given object in the; hierarchy becomes the current one, the conversion from master to local; coordinates or the other way around can be done from the manager class. A g",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:91169,Performance,perform,performance,91169," **`TGeoVolumeAssembly`** object and position the components inside as; for any volume:. ``` {.cpp}; TGeoVolume *vol = new TGeoVolumeAssembly(name);; vol->AddNode(vdaughter1, cpy1, matrix1);; vol->AddNode(vdaughter2, cpy2, matrix2);; ```. Note that components cannot be declared as ""overlapping"" and that a; component can be an assembly volume. For existing flat volume; structures, one can define assemblies to force a hierarchical structure; therefore optimizing the performance. Usage of assemblies does NOT imply; penalties in performance, but in some cases, it can be observed that it; is not as performing as bounding the structure in a container volume; with a simple shape. Choosing a normal container is therefore; recommended whenever possible. ![Assemblies of volumes](pictures/080001CF.png). ### Geometrical Transformations. All geometrical transformations handled by the modeller are provided as; a built-in package. This was designed to minimize memory requirements; and optimize performance of point/vector master-to-local and; local-to-master computation. We need to have in mind that a; transformation in **`TGeo`** has two major use-cases. The first one is; for defining the placement of a volume with respect to its container; reference frame. This frame will be called 'master' and the frame of the; positioned volume - 'local'. If `T` is a transformation used for; positioning volume daughters, then: `MASTER = T * LOCAL`. Therefore `T `is used to perform a local to master conversion, while; `T-1` for a master to local conversion. The second use case is the; computation of the global transformation of a given object in the; geometry. Since the geometry is built as 'volumes-inside-volumes', the; global transformation represents the pile-up of all local; transformations in the corresponding branch. Once a given object in the; hierarchy becomes the current one, the conversion from master to local; coordinates or the other way around can be done from the manager class. A g",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:91644,Performance,perform,perform,91644,"ies does NOT imply; penalties in performance, but in some cases, it can be observed that it; is not as performing as bounding the structure in a container volume; with a simple shape. Choosing a normal container is therefore; recommended whenever possible. ![Assemblies of volumes](pictures/080001CF.png). ### Geometrical Transformations. All geometrical transformations handled by the modeller are provided as; a built-in package. This was designed to minimize memory requirements; and optimize performance of point/vector master-to-local and; local-to-master computation. We need to have in mind that a; transformation in **`TGeo`** has two major use-cases. The first one is; for defining the placement of a volume with respect to its container; reference frame. This frame will be called 'master' and the frame of the; positioned volume - 'local'. If `T` is a transformation used for; positioning volume daughters, then: `MASTER = T * LOCAL`. Therefore `T `is used to perform a local to master conversion, while; `T-1` for a master to local conversion. The second use case is the; computation of the global transformation of a given object in the; geometry. Since the geometry is built as 'volumes-inside-volumes', the; global transformation represents the pile-up of all local; transformations in the corresponding branch. Once a given object in the; hierarchy becomes the current one, the conversion from master to local; coordinates or the other way around can be done from the manager class. A general homogenous transformation is defined as a 4x4 matrix embedding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous; matrix, composition being performed as simple matrix multiplication. Rotation:; $\left|\begin{array}{cccc}; r_{11} & r_{12} & r_{13} & 0 \\; r_{21} & r_{22} & r_{23} & 0 \\; r_{31} & r_{32} & r_{33} & 0 \\; 0 & 0 & 0 & 1; \end{array}; \right|$; Translation:; $\left|\begin{array}{ccc",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:92416,Performance,perform,performed,92416,"cement of a volume with respect to its container; reference frame. This frame will be called 'master' and the frame of the; positioned volume - 'local'. If `T` is a transformation used for; positioning volume daughters, then: `MASTER = T * LOCAL`. Therefore `T `is used to perform a local to master conversion, while; `T-1` for a master to local conversion. The second use case is the; computation of the global transformation of a given object in the; geometry. Since the geometry is built as 'volumes-inside-volumes', the; global transformation represents the pile-up of all local; transformations in the corresponding branch. Once a given object in the; hierarchy becomes the current one, the conversion from master to local; coordinates or the other way around can be done from the manager class. A general homogenous transformation is defined as a 4x4 matrix embedding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous; matrix, composition being performed as simple matrix multiplication. Rotation:; $\left|\begin{array}{cccc}; r_{11} & r_{12} & r_{13} & 0 \\; r_{21} & r_{22} & r_{23} & 0 \\; r_{31} & r_{32} & r_{33} & 0 \\; 0 & 0 & 0 & 1; \end{array}; \right|$; Translation:; $\left|\begin{array}{cccc}; 1 & 0 & 0 & 0 \\; 0 & 1 & 0 & 0 \\; 0 & 0 & 1 & 0 \\; t_x & t_y & t_z & 1; \end{array}; \right|$; Scale:; $\left|\begin{array}{cccc}; s_x & 0 & 0 & 0 \\; 0 & s_y & 0 & 0 \\; 0 & 0 & s_z & 0 \\; 0 & 0 & 0 & 1; \end{array}; \right|$. Inverse rotation:; $\left|\begin{array}{cccc}; r_{11} & r_{21} & r_{31} & 0 \\; r_{12} & r_{22} & r_{32} & 0 \\; r_{13} & r_{23} & r_{33} & 0 \\; 0 & 0 & 0 & 1; \end{array}; \right|$; Inverse translation:; $\left|\begin{array}{cccc}; 1 & 0 & 0 & 0 \\; 0 & 1 & 0 & 0 \\; 0 & 0 & 1 & 0 \\; -t_x & -t_y & -t_z & 1; \end{array}; \right|$; Inverse scale:; $\left|\begin{array}{cccc}; \frac{1}{s_x} & 0 & 0 & 0 \\; 0 & \frac{1}{s_y} & 0 & 0 \\; 0 & 0 & \frac{1}{s_z} &",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:98386,Performance,perform,performed,98386," added or subtracted. ``` {.cpp}; TGeoTranslation t1;; t1->SetTranslation(-5,10,4);; TGeoTranslation *t2 = new TGeoTranslation(4,3,10);; t2->Subtract(&t1);; ```. - Rotations (**`TGeoRotation`** class) represent a pure rotation. Data; members are `Double_t fRotationMatrix[3*3]`. Rotations can be; defined either by Euler angles, either, by GEANT3 angles:. ``` {.cpp}; TGeoRotation *r1 = new TGeoRotation();; r1->SetAngles(phi,theta,psi); // all angles in degrees; ```. This represents the composition of: first a rotation about Z axis with; angle phi, then a rotation with theta about the rotated X axis, and; finally a rotation with `psi `about the new Z axis. ``` {.cpp}; r1->SetAngles(th1,phi1,th2,phi2,th3,phi3); ```. This is a rotation defined in GEANT3 style. Theta and phi are the; spherical angles of each axis of the rotated coordinate system with; respect to the initial one. This construction allows definition of; malformed rotations, e.g. not orthogonal. A check is performed and an; error message is issued in this case. Specific utilities: determinant, inverse. - Scale transformations (**`TGeoScale`** class) - represent a scaled; shrinking/enlargement, possibly different on all axes. Data members:; `Double_t fScale[3]`. Not implemented yet.; - Combined transformations - represent a rotation followed by a; translation. Data members:; `Double_t fTranslation[3], `**`TGeoRotation *fRotation`.**. ``` {.cpp}; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;; ...; TGeoCombiTrans *c1 = new TGeoCombiTrans(trans,rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot); ```. - General transformations: (**`TGeoHMatrix`** class) represent; combined transformations in any order.; - Identity transformation: (**`TGeoIdentity`** class) is a generic; identity transformation represented by a singleton class object; **`gGeoIdentity`**. ### Ownership of Geometry Objects. The class **`TGeoManager`** class contains the entire API needed for; build",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:100620,Performance,cache,cache,100620,"ed in a; session; therefore, users must not try to control their deletion. It; contains lists of media, materials, transformations, shapes and volumes.; A special case is the one of geometrical transformations. When creating; a matrix or a translation, this is by default owned by external objects.; The manager class becomes owner of all transformations used for; positioning volumes. In order to force the ownership for other; transformations, one can use `TGeoMatrix::RegisterYourself()` method. Do; not be therefore surprised that some transformations cannot be found by; name when creating a composite shape for instance if you did not; register them after creation. Logical nodes (positioned volumes) are created and destroyed by the; **`TGeoVolume`** class. Physical nodes and their global transformations; are subjected to a caching mechanism due to the sometimes very large; memory requirements of logical graph expansion. The total number of; physical instances of volumes triggers the caching mechanism and the; cache manager is a client of **`TGeoManager`**. The manager class also; controls the drawing/checking package (**`TGeoPainter`** client). This; is linked with ROOT graphical libraries loaded on demand in order to; control visualization actions. ## Navigation and Tracking. Tracking is the feature allowing the transport of a given particle; knowing its kinematics. A state is determined by any combination of the; position $\vec{r}$ and direction $\vec{n}$ with respect to the world; reference frame. The direction $\vec{n}$ must be a unit vector having as; components the director cosines. The full classification of a given; state will provide the following information: the deepest physical node; containing the position vector, the distance to the closest boundary; along the direction vector, the next physical node after propagating the; current point with this distance and the safety distance to the nearest; boundary. This information allows the propagation of particle",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:100804,Performance,load,loaded,100804,"en creating; a matrix or a translation, this is by default owned by external objects.; The manager class becomes owner of all transformations used for; positioning volumes. In order to force the ownership for other; transformations, one can use `TGeoMatrix::RegisterYourself()` method. Do; not be therefore surprised that some transformations cannot be found by; name when creating a composite shape for instance if you did not; register them after creation. Logical nodes (positioned volumes) are created and destroyed by the; **`TGeoVolume`** class. Physical nodes and their global transformations; are subjected to a caching mechanism due to the sometimes very large; memory requirements of logical graph expansion. The total number of; physical instances of volumes triggers the caching mechanism and the; cache manager is a client of **`TGeoManager`**. The manager class also; controls the drawing/checking package (**`TGeoPainter`** client). This; is linked with ROOT graphical libraries loaded on demand in order to; control visualization actions. ## Navigation and Tracking. Tracking is the feature allowing the transport of a given particle; knowing its kinematics. A state is determined by any combination of the; position $\vec{r}$ and direction $\vec{n}$ with respect to the world; reference frame. The direction $\vec{n}$ must be a unit vector having as; components the director cosines. The full classification of a given; state will provide the following information: the deepest physical node; containing the position vector, the distance to the closest boundary; along the direction vector, the next physical node after propagating the; current point with this distance and the safety distance to the nearest; boundary. This information allows the propagation of particles inside a; detector geometry by taking into account both geometrical and physical; constraints. We will hereby describe the user interface of **`TGeo`** to access; tracking functionality. This allows either devel",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:111714,Performance,perform,perform,111714,"tes-1. The mapping from a given logical; node to a state number is generally not possible, as for the node; B\_1 that appears as current node for 2 different states. The; numbering order of states is therefore not important, but it can be; used as in the following lines:. ``` {.cpp}; gGeoManager->InitTrack(pt,dir); // anything to initialize a state; Int_t istate = gGeoManager->GetCurrentNodeId(); // in fact state Id; {; //... code changing the current state; }; gGeoManager->CdNode(istate); // forces state's re-initialization; ```. - Current `global transformation`. This represents the transformation; from `MARS` to the local reference of the current node, being the; product of all local mother-daughter transformations in the branch.; The global transformation can be referenced or copied:. ``` {.cpp}; const TGeoHMatrix *global = gGeoManager->GetCurrentMatrix();; TGeoHMatrix *copy = new TGeoHMatrix(*global);; ```. - One often needs to perform `master-to-local` and `local-to-master`; point and vector conversions to get from `MARS` to the local node; coordinates. This can be done by using the global transformation or; directly the **`TGeoManager`** corresponding interfaces:. ``` {.cpp}; Double_t *glob_pt = gGeoManager->GetCurrentPoint();; Double_t *glob_dir = gGeoManager->GetCurrentDirection();; Double_t loc_pt[3], loc_dir[3];; // Go from MARS to local coordinates:; gGeoManager->MasterToLocal(glob_pt,loc_pt); // or:; global->MasterToLocal(glob_pt,loc_pt); // will be omitted from now; ```. ### Saving and Restoring the Current State. As we already described, saving and restoring modeller states can be; quite useful during tracking and is a feature extensively used by; external tracking engines. We will call this navigation history; management, which in most of the cases can be performed by handling the; state identifiers. For quite big geometries, state indexing is not; possible anymore and will be automatically disabled by the modeller.; Fortunately there is a backup sol",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:112569,Performance,perform,performed,112569,"enced or copied:. ``` {.cpp}; const TGeoHMatrix *global = gGeoManager->GetCurrentMatrix();; TGeoHMatrix *copy = new TGeoHMatrix(*global);; ```. - One often needs to perform `master-to-local` and `local-to-master`; point and vector conversions to get from `MARS` to the local node; coordinates. This can be done by using the global transformation or; directly the **`TGeoManager`** corresponding interfaces:. ``` {.cpp}; Double_t *glob_pt = gGeoManager->GetCurrentPoint();; Double_t *glob_dir = gGeoManager->GetCurrentDirection();; Double_t loc_pt[3], loc_dir[3];; // Go from MARS to local coordinates:; gGeoManager->MasterToLocal(glob_pt,loc_pt); // or:; global->MasterToLocal(glob_pt,loc_pt); // will be omitted from now; ```. ### Saving and Restoring the Current State. As we already described, saving and restoring modeller states can be; quite useful during tracking and is a feature extensively used by; external tracking engines. We will call this navigation history; management, which in most of the cases can be performed by handling the; state identifiers. For quite big geometries, state indexing is not; possible anymore and will be automatically disabled by the modeller.; Fortunately there is a backup solution working in any condition: the; modeller maintains a stack of states that is internally used by its own; navigation algorithms, but user code is also allowed to access it. This; works on any stack principle by using PUSH and POP calls and user code; is responsible for popping the pushed states in order to keep the stack; clean. ``` {.cpp}; // push the current state in the stack; Int_t index = gGeoManager->PushPath();; // push state and current point; Int_t index = gGeoManager->PushPoint();; // retrieves the last pushed state (decrements stack index); gGeoManager->PopPath();; // the same but retrieves also the point location; gGeoManager->PopPoint();; // just decrement stack index without changing state; gGeoManager->PopDummy();; // retrieves a state at given index wi",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:114984,Performance,perform,perform,114984,"nd the current node or path has not; been changed by the user. #### Finding If Current State Is Changed For a New Point. One can find fast if a point different from the current one has or not; the same location inside the geometry tree. To do that, the new point; should not be introduced by using `TGeoManager::SetCurrentPoint()`; method, but rather by calling the specific method:. ``` {.cpp}; Bool_t TGeoManager::IsSameLocation(Double_t x,Double_t y,; Double_t z,Bool_t change=kFALSE);; ```. In the prototype above, `x, y` and `z` are the coordinates of the new; point. The modeller will check whether the current volume still contains; the new point or its location has changed in the geometry hierarchy. If; the new location is different, two actions are possible according to the; value of `change`:. - `change = kFALSE` (default) - the modeller does not change the; current state but just inform the caller about this change.; - `change = kTRUE` - the modeller will actually perform a new; `‘Where am I?' `search after finding out that the location has; changed. The current state will be actualized accordingly. Note that even when performing a normal search on the current state; after changing the current point coordinates (e.g.; `gGeoManager->FindNode(newX,newY,newZ)`), users can always query if the; previous state has changed by using a method having the same name but; without parameters:. ``` {.cpp}; Bool_t TGeoManager::IsSameLocation();; ```. #### Finding the Distance to the Next Boundary. All tracking engines need to compare the currently proposed physical; step with the maximum allowed distance in the current material. The; modeller provides this information by computing the distance to the; first boundary starting from the current point along a straight line.; The starting point and direction for this procedure are the ones; corresponding to the current state. The boundary search is initialized; inside the current volume and the crossed boundary can belong either to; t",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:115142,Performance,perform,performing,115142,"ne has or not; the same location inside the geometry tree. To do that, the new point; should not be introduced by using `TGeoManager::SetCurrentPoint()`; method, but rather by calling the specific method:. ``` {.cpp}; Bool_t TGeoManager::IsSameLocation(Double_t x,Double_t y,; Double_t z,Bool_t change=kFALSE);; ```. In the prototype above, `x, y` and `z` are the coordinates of the new; point. The modeller will check whether the current volume still contains; the new point or its location has changed in the geometry hierarchy. If; the new location is different, two actions are possible according to the; value of `change`:. - `change = kFALSE` (default) - the modeller does not change the; current state but just inform the caller about this change.; - `change = kTRUE` - the modeller will actually perform a new; `‘Where am I?' `search after finding out that the location has; changed. The current state will be actualized accordingly. Note that even when performing a normal search on the current state; after changing the current point coordinates (e.g.; `gGeoManager->FindNode(newX,newY,newZ)`), users can always query if the; previous state has changed by using a method having the same name but; without parameters:. ``` {.cpp}; Bool_t TGeoManager::IsSameLocation();; ```. #### Finding the Distance to the Next Boundary. All tracking engines need to compare the currently proposed physical; step with the maximum allowed distance in the current material. The; modeller provides this information by computing the distance to the; first boundary starting from the current point along a straight line.; The starting point and direction for this procedure are the ones; corresponding to the current state. The boundary search is initialized; inside the current volume and the crossed boundary can belong either to; the current node or to one of its daughters. The full prototype of the; method is:. ``` {.cpp}; TGeoNode *TGeoManager::FindNextBoundary(Double_t step=kBig);; ```. In the prototyp",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:123821,Performance,scalab,scalability,123821,"d Surface at Crossing Point. Supposing we have found out that a particle will cross a boundary during; the next step, it is sometimes useful to compute the normal to the; crossed surface. The modeller uses the following convention: we define; as `normal` ($\vec{n}$) the unit vector perpendicular; to a surface in the `next crossing point`, having the orientation such; that: $\vec{n}.\vec{d}>0$. Here $\vec{d}$; represents the current direction. The next crossing point represents the; point where a ray shot from the current point along the current; direction crosses the surface. ``` {.cpp}; Double_t *TGeoManager::FindNormal(Bool_t forward=kTRUE);; ```. The method above computes the normal to the next crossed surface in; forward or backward direction (i.e. the current one), assuming the state; corresponding to a current arbitrary point is initialized. An example of; usage of normal computation is ray tracing. The two most important features of the geometrical modeller concerning; tracking are scalability and performance as function of the total number; of physical nodes. The first refers to the possibility to make use of; the available memory resources and at the same time be able to resolve; any geometrical query, while the second defines the capability of the; modeller to respond quickly even for huge geometries. These parameters; can become critical when simulating big experiments like those at LHC. ### Creating and Visualizing Tracks. In case the modeller is interfaced with a tracking engine, one might; consider quite useful being able to store and visualize at least a part; of the tracks in the context of the geometry. The base class; **`TVirtualGeoTrack`** provides this functionality. It currently has one; implementation inside the drawing package (**`TGeoTrack`** class). A; track can be defined like:. ``` {.cpp}; TVirtualGeoTrack(Int_t id,Int_t pdg,TVirtualGeoTrack *parent=0,; TObject *particle=0);; ```. Where: `id` is user-defined id of the track, `pdg` - `pdg` c",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:123837,Performance,perform,performance,123837,"d Surface at Crossing Point. Supposing we have found out that a particle will cross a boundary during; the next step, it is sometimes useful to compute the normal to the; crossed surface. The modeller uses the following convention: we define; as `normal` ($\vec{n}$) the unit vector perpendicular; to a surface in the `next crossing point`, having the orientation such; that: $\vec{n}.\vec{d}>0$. Here $\vec{d}$; represents the current direction. The next crossing point represents the; point where a ray shot from the current point along the current; direction crosses the surface. ``` {.cpp}; Double_t *TGeoManager::FindNormal(Bool_t forward=kTRUE);; ```. The method above computes the normal to the next crossed surface in; forward or backward direction (i.e. the current one), assuming the state; corresponding to a current arbitrary point is initialized. An example of; usage of normal computation is ray tracing. The two most important features of the geometrical modeller concerning; tracking are scalability and performance as function of the total number; of physical nodes. The first refers to the possibility to make use of; the available memory resources and at the same time be able to resolve; any geometrical query, while the second defines the capability of the; modeller to respond quickly even for huge geometries. These parameters; can become critical when simulating big experiments like those at LHC. ### Creating and Visualizing Tracks. In case the modeller is interfaced with a tracking engine, one might; consider quite useful being able to store and visualize at least a part; of the tracks in the context of the geometry. The base class; **`TVirtualGeoTrack`** provides this functionality. It currently has one; implementation inside the drawing package (**`TGeoTrack`** class). A; track can be defined like:. ``` {.cpp}; TVirtualGeoTrack(Int_t id,Int_t pdg,TVirtualGeoTrack *parent=0,; TObject *particle=0);; ```. Where: `id` is user-defined id of the track, `pdg` - `pdg` c",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:128970,Performance,perform,perform,128970,"option="""");; ```. The drawing/animation time range is a global variable that can be; directly set:. ``` {.cpp}; gGeoManager->SetTminTmax(tmin, tmax);; // without arguments resets the time range to the maximum value; ```. Once set, the time range will be active both for individual or global; track drawing. For animation, this range is divided to the desired; number of frames and will be automatically updated at each frame in; order to get the animation effect. The option provided to all track-drawing methods can trigger different; track selections:. `default: `A track (or all primary tracks) drawn without daughters. `/D:` Track and first level descendents only are drawn. `/*: ` Track and all descendents are drawn. `/Ntype:` All tracks having `name=type` are drawn. Generally several options can be concatenated in the same string (E.g.; `""/D /Npion-""`). For animating tracks, additional options can be added:. `/G:`Geometry animate. Generally when drawing or animating tracks, one; has to first perform a normal drawing of the geometry as convenient. The; tracks will be drawn over the geometry. The geometry itself will be; animated (camera moving and rotating in order to ""catch"" the majority of; current track segments.). `/S:`Save all frames in gif format in the current folder. This option; allows creating a movie based on individual frames. ## Checking the Geometry. Several checking methods are accessible from the context menu of volume; objects or of the manager class. They generally apply only to the; visible parts of the drawn geometry in order to ease geometry checking,; and their implementation is in the **`TGeoChecker`** class. The checking; package contains an overlap checker and several utility methods that; generally have visualization outputs. ### The Overlap Checker. An overlap is any region in the Euclidian space being contained by more; than one positioned volume. Due to the containment scheme used by the; modeller, all points inside a volume have to be also ",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:131650,Performance,perform,performed,131650," are invisible since the current track has not yet reached; its mother. This is not the case when going the other way since the; track has first to exit the extruding node before checking the mother.; In other words, an extrusion behavior is dependent on the track; parameters, which is a highly undesirable effect. B) We will call ***`overlaps`*** only the regions in space contained by; more than one node inside the same container. The owner of such regions; cannot be determined based on hierarchical considerations; therefore; they will be considered as belonging to the node from which the current; track is coming from. When coming from their container, the ownership is totally; unpredictable. Again, the ownership of overlapping regions highly; depends on the current track parameters. We must say that even the overlaps of type A) and B) are allowed in case; the corresponding nodes are created using; **`TGeoVolume`**`::AddNodeOverlap()` method. Navigation is performed in such; cases by giving priority to the non-overlapping nodes. The modeller has; to perform an additional search through the overlapping candidates.; These are detected automatically during the geometry closing procedure; in order to optimize the algorithm, but we will stress that extensive; usage of this feature leads to a drastic deterioration of performance.; In the following we will focus on the non-declared overlaps of type A); and B) since this is the main source of errors during tracking. These; are generally non-intended overlaps due to coding mistakes or bad; geometry design. The checking package is loaded together with the; painter classes and contains an automated overlap checker.**. ![Overlap checking](pictures/030001DF.png). This can be activated both at volume level (checking for illegal; overlaps only one level inside a given volume) and from the geometry; manager level (checking full geometry):. ``` {.cpp}; myVolume->CheckOverlaps(precision, option);; gGeoManager->CheckOverlaps(precision",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:131745,Performance,perform,perform,131745," case when going the other way since the; track has first to exit the extruding node before checking the mother.; In other words, an extrusion behavior is dependent on the track; parameters, which is a highly undesirable effect. B) We will call ***`overlaps`*** only the regions in space contained by; more than one node inside the same container. The owner of such regions; cannot be determined based on hierarchical considerations; therefore; they will be considered as belonging to the node from which the current; track is coming from. When coming from their container, the ownership is totally; unpredictable. Again, the ownership of overlapping regions highly; depends on the current track parameters. We must say that even the overlaps of type A) and B) are allowed in case; the corresponding nodes are created using; **`TGeoVolume`**`::AddNodeOverlap()` method. Navigation is performed in such; cases by giving priority to the non-overlapping nodes. The modeller has; to perform an additional search through the overlapping candidates.; These are detected automatically during the geometry closing procedure; in order to optimize the algorithm, but we will stress that extensive; usage of this feature leads to a drastic deterioration of performance.; In the following we will focus on the non-declared overlaps of type A); and B) since this is the main source of errors during tracking. These; are generally non-intended overlaps due to coding mistakes or bad; geometry design. The checking package is loaded together with the; painter classes and contains an automated overlap checker.**. ![Overlap checking](pictures/030001DF.png). This can be activated both at volume level (checking for illegal; overlaps only one level inside a given volume) and from the geometry; manager level (checking full geometry):. ``` {.cpp}; myVolume->CheckOverlaps(precision, option);; gGeoManager->CheckOverlaps(precision);; myNode->CheckOverlaps(precision);; ```. Here precision represents the desired maxim",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:131895,Performance,optimiz,optimize,131895,"r is dependent on the track; parameters, which is a highly undesirable effect. B) We will call ***`overlaps`*** only the regions in space contained by; more than one node inside the same container. The owner of such regions; cannot be determined based on hierarchical considerations; therefore; they will be considered as belonging to the node from which the current; track is coming from. When coming from their container, the ownership is totally; unpredictable. Again, the ownership of overlapping regions highly; depends on the current track parameters. We must say that even the overlaps of type A) and B) are allowed in case; the corresponding nodes are created using; **`TGeoVolume`**`::AddNodeOverlap()` method. Navigation is performed in such; cases by giving priority to the non-overlapping nodes. The modeller has; to perform an additional search through the overlapping candidates.; These are detected automatically during the geometry closing procedure; in order to optimize the algorithm, but we will stress that extensive; usage of this feature leads to a drastic deterioration of performance.; In the following we will focus on the non-declared overlaps of type A); and B) since this is the main source of errors during tracking. These; are generally non-intended overlaps due to coding mistakes or bad; geometry design. The checking package is loaded together with the; painter classes and contains an automated overlap checker.**. ![Overlap checking](pictures/030001DF.png). This can be activated both at volume level (checking for illegal; overlaps only one level inside a given volume) and from the geometry; manager level (checking full geometry):. ``` {.cpp}; myVolume->CheckOverlaps(precision, option);; gGeoManager->CheckOverlaps(precision);; myNode->CheckOverlaps(precision);; ```. Here precision represents the desired maximum accepted overlap value in; centimeters (default value is 0.1). This tool checks all possible; significant pairs of candidates inside a given volume ",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:132012,Performance,perform,performance,132012,"r is dependent on the track; parameters, which is a highly undesirable effect. B) We will call ***`overlaps`*** only the regions in space contained by; more than one node inside the same container. The owner of such regions; cannot be determined based on hierarchical considerations; therefore; they will be considered as belonging to the node from which the current; track is coming from. When coming from their container, the ownership is totally; unpredictable. Again, the ownership of overlapping regions highly; depends on the current track parameters. We must say that even the overlaps of type A) and B) are allowed in case; the corresponding nodes are created using; **`TGeoVolume`**`::AddNodeOverlap()` method. Navigation is performed in such; cases by giving priority to the non-overlapping nodes. The modeller has; to perform an additional search through the overlapping candidates.; These are detected automatically during the geometry closing procedure; in order to optimize the algorithm, but we will stress that extensive; usage of this feature leads to a drastic deterioration of performance.; In the following we will focus on the non-declared overlaps of type A); and B) since this is the main source of errors during tracking. These; are generally non-intended overlaps due to coding mistakes or bad; geometry design. The checking package is loaded together with the; painter classes and contains an automated overlap checker.**. ![Overlap checking](pictures/030001DF.png). This can be activated both at volume level (checking for illegal; overlaps only one level inside a given volume) and from the geometry; manager level (checking full geometry):. ``` {.cpp}; myVolume->CheckOverlaps(precision, option);; gGeoManager->CheckOverlaps(precision);; myNode->CheckOverlaps(precision);; ```. Here precision represents the desired maximum accepted overlap value in; centimeters (default value is 0.1). This tool checks all possible; significant pairs of candidates inside a given volume ",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:132277,Performance,load,loaded,132277,"When coming from their container, the ownership is totally; unpredictable. Again, the ownership of overlapping regions highly; depends on the current track parameters. We must say that even the overlaps of type A) and B) are allowed in case; the corresponding nodes are created using; **`TGeoVolume`**`::AddNodeOverlap()` method. Navigation is performed in such; cases by giving priority to the non-overlapping nodes. The modeller has; to perform an additional search through the overlapping candidates.; These are detected automatically during the geometry closing procedure; in order to optimize the algorithm, but we will stress that extensive; usage of this feature leads to a drastic deterioration of performance.; In the following we will focus on the non-declared overlaps of type A); and B) since this is the main source of errors during tracking. These; are generally non-intended overlaps due to coding mistakes or bad; geometry design. The checking package is loaded together with the; painter classes and contains an automated overlap checker.**. ![Overlap checking](pictures/030001DF.png). This can be activated both at volume level (checking for illegal; overlaps only one level inside a given volume) and from the geometry; manager level (checking full geometry):. ``` {.cpp}; myVolume->CheckOverlaps(precision, option);; gGeoManager->CheckOverlaps(precision);; myNode->CheckOverlaps(precision);; ```. Here precision represents the desired maximum accepted overlap value in; centimeters (default value is 0.1). This tool checks all possible; significant pairs of candidates inside a given volume (not declared as; overlapping or division volumes). The check is performed by verifying; the mesh representation of one candidate against the shape of the other.; This sort of check cannot identify all possible overlapping topologies,; but it works for more than 95% and is much faster than the usual; shape-to-shape comparison. For a 100% reliability, one can perform the; check at the lev",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:132982,Performance,perform,performed,132982,".; In the following we will focus on the non-declared overlaps of type A); and B) since this is the main source of errors during tracking. These; are generally non-intended overlaps due to coding mistakes or bad; geometry design. The checking package is loaded together with the; painter classes and contains an automated overlap checker.**. ![Overlap checking](pictures/030001DF.png). This can be activated both at volume level (checking for illegal; overlaps only one level inside a given volume) and from the geometry; manager level (checking full geometry):. ``` {.cpp}; myVolume->CheckOverlaps(precision, option);; gGeoManager->CheckOverlaps(precision);; myNode->CheckOverlaps(precision);; ```. Here precision represents the desired maximum accepted overlap value in; centimeters (default value is 0.1). This tool checks all possible; significant pairs of candidates inside a given volume (not declared as; overlapping or division volumes). The check is performed by verifying; the mesh representation of one candidate against the shape of the other.; This sort of check cannot identify all possible overlapping topologies,; but it works for more than 95% and is much faster than the usual; shape-to-shape comparison. For a 100% reliability, one can perform the; check at the level of a single volume by using `option`=""`d`"" or; `option`=""`d<number>`"" to perform overlap checking by sampling the; volume with \<`number`\> random points (default 1 million). This; produces also a picture showing in red the overlapping region and; estimates the volume of the overlaps. An extrusion A) is declared in any of the following cases:. - At least one of the vertices of the daughter mesh representation is; outside the mother volume (in fact its shape) and having a safety; distance to the mother greater than the desired value;; - At least one of the mother vertices is contained also by one of its; daughters, in the same conditions. An overlap B) is declared if:. - At least one vertex of a positione",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:133278,Performance,perform,perform,133278," ![Overlap checking](pictures/030001DF.png). This can be activated both at volume level (checking for illegal; overlaps only one level inside a given volume) and from the geometry; manager level (checking full geometry):. ``` {.cpp}; myVolume->CheckOverlaps(precision, option);; gGeoManager->CheckOverlaps(precision);; myNode->CheckOverlaps(precision);; ```. Here precision represents the desired maximum accepted overlap value in; centimeters (default value is 0.1). This tool checks all possible; significant pairs of candidates inside a given volume (not declared as; overlapping or division volumes). The check is performed by verifying; the mesh representation of one candidate against the shape of the other.; This sort of check cannot identify all possible overlapping topologies,; but it works for more than 95% and is much faster than the usual; shape-to-shape comparison. For a 100% reliability, one can perform the; check at the level of a single volume by using `option`=""`d`"" or; `option`=""`d<number>`"" to perform overlap checking by sampling the; volume with \<`number`\> random points (default 1 million). This; produces also a picture showing in red the overlapping region and; estimates the volume of the overlaps. An extrusion A) is declared in any of the following cases:. - At least one of the vertices of the daughter mesh representation is; outside the mother volume (in fact its shape) and having a safety; distance to the mother greater than the desired value;; - At least one of the mother vertices is contained also by one of its; daughters, in the same conditions. An overlap B) is declared if:. - At least one vertex of a positioned volume mesh is contained (having; a safety bigger than the accepted maximum value) by other positioned; volume inside the same container. The check is performed also by; inverting the candidates. The code is highly optimized to avoid checking candidates that are far; away in space by performing a fast check on their bounding boxes. Once; ",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:133383,Performance,perform,perform,133383," ![Overlap checking](pictures/030001DF.png). This can be activated both at volume level (checking for illegal; overlaps only one level inside a given volume) and from the geometry; manager level (checking full geometry):. ``` {.cpp}; myVolume->CheckOverlaps(precision, option);; gGeoManager->CheckOverlaps(precision);; myNode->CheckOverlaps(precision);; ```. Here precision represents the desired maximum accepted overlap value in; centimeters (default value is 0.1). This tool checks all possible; significant pairs of candidates inside a given volume (not declared as; overlapping or division volumes). The check is performed by verifying; the mesh representation of one candidate against the shape of the other.; This sort of check cannot identify all possible overlapping topologies,; but it works for more than 95% and is much faster than the usual; shape-to-shape comparison. For a 100% reliability, one can perform the; check at the level of a single volume by using `option`=""`d`"" or; `option`=""`d<number>`"" to perform overlap checking by sampling the; volume with \<`number`\> random points (default 1 million). This; produces also a picture showing in red the overlapping region and; estimates the volume of the overlaps. An extrusion A) is declared in any of the following cases:. - At least one of the vertices of the daughter mesh representation is; outside the mother volume (in fact its shape) and having a safety; distance to the mother greater than the desired value;; - At least one of the mother vertices is contained also by one of its; daughters, in the same conditions. An overlap B) is declared if:. - At least one vertex of a positioned volume mesh is contained (having; a safety bigger than the accepted maximum value) by other positioned; volume inside the same container. The check is performed also by; inverting the candidates. The code is highly optimized to avoid checking candidates that are far; away in space by performing a fast check on their bounding boxes. Once; ",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:134176,Performance,perform,performed,134176,"much faster than the usual; shape-to-shape comparison. For a 100% reliability, one can perform the; check at the level of a single volume by using `option`=""`d`"" or; `option`=""`d<number>`"" to perform overlap checking by sampling the; volume with \<`number`\> random points (default 1 million). This; produces also a picture showing in red the overlapping region and; estimates the volume of the overlaps. An extrusion A) is declared in any of the following cases:. - At least one of the vertices of the daughter mesh representation is; outside the mother volume (in fact its shape) and having a safety; distance to the mother greater than the desired value;; - At least one of the mother vertices is contained also by one of its; daughters, in the same conditions. An overlap B) is declared if:. - At least one vertex of a positioned volume mesh is contained (having; a safety bigger than the accepted maximum value) by other positioned; volume inside the same container. The check is performed also by; inverting the candidates. The code is highly optimized to avoid checking candidates that are far; away in space by performing a fast check on their bounding boxes. Once; the checking tool is fired-up inside a volume or at top level, the list; of overlaps (visible as Illegal overlaps inside a **`TBrowser`**) held; by the manager class will be filled with **`TGeoOverlap`** objects; containing a full description of the detected overlaps. The list is; sorted in the decreasing order of the overlapping distance, extrusions; coming first. An overlap object name represents the full description of; the overlap, containing both candidate node names and a letter; (x-extrusion, o-overlap) representing the type. Double-clicking an; overlap item in a **`TBrowser`** produces a picture of the overlap; containing only the two overlapping nodes (one in blue and one in green); and having the critical vertices represented by red points. The picture; can be rotated/zoomed or drawn in X3d as any other v",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:134240,Performance,optimiz,optimized,134240,"; check at the level of a single volume by using `option`=""`d`"" or; `option`=""`d<number>`"" to perform overlap checking by sampling the; volume with \<`number`\> random points (default 1 million). This; produces also a picture showing in red the overlapping region and; estimates the volume of the overlaps. An extrusion A) is declared in any of the following cases:. - At least one of the vertices of the daughter mesh representation is; outside the mother volume (in fact its shape) and having a safety; distance to the mother greater than the desired value;; - At least one of the mother vertices is contained also by one of its; daughters, in the same conditions. An overlap B) is declared if:. - At least one vertex of a positioned volume mesh is contained (having; a safety bigger than the accepted maximum value) by other positioned; volume inside the same container. The check is performed also by; inverting the candidates. The code is highly optimized to avoid checking candidates that are far; away in space by performing a fast check on their bounding boxes. Once; the checking tool is fired-up inside a volume or at top level, the list; of overlaps (visible as Illegal overlaps inside a **`TBrowser`**) held; by the manager class will be filled with **`TGeoOverlap`** objects; containing a full description of the detected overlaps. The list is; sorted in the decreasing order of the overlapping distance, extrusions; coming first. An overlap object name represents the full description of; the overlap, containing both candidate node names and a letter; (x-extrusion, o-overlap) representing the type. Double-clicking an; overlap item in a **`TBrowser`** produces a picture of the overlap; containing only the two overlapping nodes (one in blue and one in green); and having the critical vertices represented by red points. The picture; can be rotated/zoomed or drawn in X3d as any other view. Calling; `gGeoManager->PrintOverlaps()` prints the list of overlaps. ### Graphical Checking M",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:134310,Performance,perform,performing,134310,"; check at the level of a single volume by using `option`=""`d`"" or; `option`=""`d<number>`"" to perform overlap checking by sampling the; volume with \<`number`\> random points (default 1 million). This; produces also a picture showing in red the overlapping region and; estimates the volume of the overlaps. An extrusion A) is declared in any of the following cases:. - At least one of the vertices of the daughter mesh representation is; outside the mother volume (in fact its shape) and having a safety; distance to the mother greater than the desired value;; - At least one of the mother vertices is contained also by one of its; daughters, in the same conditions. An overlap B) is declared if:. - At least one vertex of a positioned volume mesh is contained (having; a safety bigger than the accepted maximum value) by other positioned; volume inside the same container. The check is performed also by; inverting the candidates. The code is highly optimized to avoid checking candidates that are far; away in space by performing a fast check on their bounding boxes. Once; the checking tool is fired-up inside a volume or at top level, the list; of overlaps (visible as Illegal overlaps inside a **`TBrowser`**) held; by the manager class will be filled with **`TGeoOverlap`** objects; containing a full description of the detected overlaps. The list is; sorted in the decreasing order of the overlapping distance, extrusions; coming first. An overlap object name represents the full description of; the overlap, containing both candidate node names and a letter; (x-extrusion, o-overlap) representing the type. Double-clicking an; overlap item in a **`TBrowser`** produces a picture of the overlap; containing only the two overlapping nodes (one in blue and one in green); and having the critical vertices represented by red points. The picture; can be rotated/zoomed or drawn in X3d as any other view. Calling; `gGeoManager->PrintOverlaps()` prints the list of overlaps. ### Graphical Checking M",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:136665,Performance,load,loaded,136665,"k the validity of a given geometry is shooting random; points. This can be called with the method; **`TGeoVolume`**`::RandomPoints()` and it draws a volume with the current; visualization settings. Random points are generated in the bounding box; of the drawn volume. The points are drawn with the color of their; deepest container. Only points inside visible nodes are drawn. ![Random rays](pictures/030001E2.png). A ray tracing method can be called `TGeoVolume::RandomRays()`. This; shoots rays from a given point in the local reference frame with random; directions. The intersections with displayed nodes appear as segments; having the color of the touched node. ## The Drawing Package. ![](pictures/030001E3.png)The modeller provides a powerful drawing; package, supporting several different options of visualization. A; library separated from the main one provides all functionality being; linked with the underlying ROOT visualization system. This library is; dynamically loaded by the plug-in manager only when drawing features are; requested. The geometrical structures that can be visualized are volumes; and volume hierarchies. The main component of the visualization system is volume primitive; painting in a ROOT pad. Starting from this one, several specific options; or subsystems are available, like: X3D viewing using hidden line and; surface removal algorithms, OpenGL viewing\* or ray tracing. The method `TGeoManager::GetGeomPainter()`loads the painting library in; memory. This is generally not needed since it is called automatically by; `TGeoVolume::Draw()` as well as by few other methods setting; visualization attributes. ### Drawing Volumes and Hierarchies of Volumes. The first thing one would like to do after building some geometry is to; visualize the volume tree. This provides the fastest validation check; for most common coding or design mistakes. As soon as the geometry is; successfully closed, one should draw it starting from the top-level; volume:. ``` {.cpp}; ",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:137140,Performance,load,loads,137140,"`TGeoVolume::RandomRays()`. This; shoots rays from a given point in the local reference frame with random; directions. The intersections with displayed nodes appear as segments; having the color of the touched node. ## The Drawing Package. ![](pictures/030001E3.png)The modeller provides a powerful drawing; package, supporting several different options of visualization. A; library separated from the main one provides all functionality being; linked with the underlying ROOT visualization system. This library is; dynamically loaded by the plug-in manager only when drawing features are; requested. The geometrical structures that can be visualized are volumes; and volume hierarchies. The main component of the visualization system is volume primitive; painting in a ROOT pad. Starting from this one, several specific options; or subsystems are available, like: X3D viewing using hidden line and; surface removal algorithms, OpenGL viewing\* or ray tracing. The method `TGeoManager::GetGeomPainter()`loads the painting library in; memory. This is generally not needed since it is called automatically by; `TGeoVolume::Draw()` as well as by few other methods setting; visualization attributes. ### Drawing Volumes and Hierarchies of Volumes. The first thing one would like to do after building some geometry is to; visualize the volume tree. This provides the fastest validation check; for most common coding or design mistakes. As soon as the geometry is; successfully closed, one should draw it starting from the top-level; volume:. ``` {.cpp}; //... code for geometry building; root[] gGeoManager->CloseGeometry();; root[] gGeoManager->GetMasterVolume()->Draw();; ```. Doing this ensures that the original top-level volume of the geometry is; drawn, even if another volume is currently the geometry `root`. OK, I; suppose you already did that with your simple geometry and immediately; noticed a new ROOT canvas popping-up and having some more or less; strange picture inside. Here are few questi",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:138352,Performance,perform,perform,138352,"of Volumes. The first thing one would like to do after building some geometry is to; visualize the volume tree. This provides the fastest validation check; for most common coding or design mistakes. As soon as the geometry is; successfully closed, one should draw it starting from the top-level; volume:. ``` {.cpp}; //... code for geometry building; root[] gGeoManager->CloseGeometry();; root[] gGeoManager->GetMasterVolume()->Draw();; ```. Doing this ensures that the original top-level volume of the geometry is; drawn, even if another volume is currently the geometry `root`. OK, I; suppose you already did that with your simple geometry and immediately; noticed a new ROOT canvas popping-up and having some more or less; strange picture inside. Here are few questions that might come:. ***`Q:`*** ""The picture is strangely rotated; where are the coordinate axes?"". ***`A:`*** If drawn in a new canvas, any view has some default; viewpoint, center of view and size. One can then perform mouse/keyboard; actions to change them:. - Mouse left-click and drag will rotate the view;. - Some keys can be pressed when the view canvas is selected: J/K; zoom/un-zoom, U/I move up/down, L/H move left/right. The coordinate axes; display as well as changing top or side viewpoints can be activated from; the **`TView`** context menu: right-click on the picture when no object; is selected;. ***`Q:`*** ""Every line is black! I cannot figure out what is what..."". ***`A:`*** Volumes can have different colors (those known by ROOT of; course). Think at using them after each volume creation:; `myvolume->SetLineColor(Int_t color);` otherwise everything is by; default black. ***`Q:`*** ""The top volume of my geometry is a box but I see only its content."". ***`A:`*** By default the drawn volume is not displayed just because we; do not want to hide its content when changing the view to HLR or solid; mode. In order to see it in the default wire frame picture one has to; call **`TGeoManager::SetTopVisible()`.",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:140486,Performance,perform,performed,140486,"ide."". ***`A:`*** By default, **`TGeoVolume`**`::Draw()` paints the content of; a given volume three levels down. You can change this by using:; ***`gGeoManager`***`::SetVisLevel(n);`. Not only that, but none of the volumes at intermediate levels (0-2) are; visible on the drawing unless they are final ‘leaves' on their branch; (e.g. have no other volumes positioned inside). This behavior is the; default one and corresponds to ‘leaves' global visualization mode; (**`TGeoManager::fVisOption = 1`). In order to see on the screen the; intermediate containers, one can change this mode:; `gGeoManager->SetVisOption(0)`.**. ***`Q:`*** ""Volumes are highlighted when moving the mouse over their vertices. What does it mean?"". ***`A:`*** Indeed, moving the mouse close to some volume vertices; selects it. By checking the `Event Status` entry in the root canvas; `Options` menu, you will see exactly which is the selected node in the; bottom right. Right-clicking when a volume is selected will open its; context menu where several actions can be performed (e.g. drawing it). ***`Q:`*** ""OK, but now I do not want to see all the geometry, but just a particular volume and its content. How can I do this?"". ***`A:`*** Once you have set a convenient global visualization option; and level, what you need is just call the `Draw()` method of your; interesting volume. You can do this either by interacting with the; expanded tree of volumes in a ROOT browser (where the context menu of; any volume is available), either by getting a pointer to it (e.g. by; name): `gGeoManager->GetVolume(""vol_name"")->Draw();`. ### Visualization Settings and Attributes. Supposing you now understand the basic things to do for drawing the; geometry or parts of it, you still might be not happy and wishing to; have more control on it. We will describe below how you can fine-tune some; settings. Since the corresponding attributes are flags belonging to; volume and node objects, you can change them at any time (even when th",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:141293,Performance,tune,tune,141293,"in the root canvas; `Options` menu, you will see exactly which is the selected node in the; bottom right. Right-clicking when a volume is selected will open its; context menu where several actions can be performed (e.g. drawing it). ***`Q:`*** ""OK, but now I do not want to see all the geometry, but just a particular volume and its content. How can I do this?"". ***`A:`*** Once you have set a convenient global visualization option; and level, what you need is just call the `Draw()` method of your; interesting volume. You can do this either by interacting with the; expanded tree of volumes in a ROOT browser (where the context menu of; any volume is available), either by getting a pointer to it (e.g. by; name): `gGeoManager->GetVolume(""vol_name"")->Draw();`. ### Visualization Settings and Attributes. Supposing you now understand the basic things to do for drawing the; geometry or parts of it, you still might be not happy and wishing to; have more control on it. We will describe below how you can fine-tune some; settings. Since the corresponding attributes are flags belonging to; volume and node objects, you can change them at any time (even when the; picture is already drawn) and see immediately the result. #### Colors and Line Styles. We have already described how to change the line colors for volumes. In; fact, volume objects inherit from TAttLine class so the line style or; width can also be changed:. ``` {.cpp}; myVolume->SetLineColor(kRed);; myVolume->SetLineWith(2);; myVolume->SetLineStyle(kDotted);; ```. When drawing in solid mode, the color of the drawn volume corresponds to; the line color. #### Visibility Settings. The way geometry is build forces the definition of several volumes that; does not represent real objects, but just virtual containers used for; grouping and positioning volumes together. One would not want to see; them in the picture. Since every volume is by default visible, one has; to do this sort of tuning by its own:. ``` {.cpp}; myVolumeContaine",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:142619,Performance,tune,tune,142619,"ume objects inherit from TAttLine class so the line style or; width can also be changed:. ``` {.cpp}; myVolume->SetLineColor(kRed);; myVolume->SetLineWith(2);; myVolume->SetLineStyle(kDotted);; ```. When drawing in solid mode, the color of the drawn volume corresponds to; the line color. #### Visibility Settings. The way geometry is build forces the definition of several volumes that; does not represent real objects, but just virtual containers used for; grouping and positioning volumes together. One would not want to see; them in the picture. Since every volume is by default visible, one has; to do this sort of tuning by its own:. ``` {.cpp}; myVolumeContainer->SetVisibility(kFALSE);; ```. As described before, the drawing package supports two main global; options: 1 (default) - only final volume leaves; 0 - all volumes down; the drawn one appear on the screen. The global visible level put a; limitation on the maximum applied depth. Combined with visibility; settings per volume, these can tune quite well what should appear on the; screen. However, there are situations when users want to see a volume; branch displayed down to the maximum depth, keeping at the same time a; limitation or even suppressing others. In order to accomplish that, one; should use the volume attribute: `Visible daughters`. By default, all; daughters of all volumes are displayed if there is no limitation related; with their level depth with respect to the top drawn volume. ### Ray Tracing. Ray tracing is a quite known drawing technique based on tracking rays; from the eye position through all pixels of a view port device. The; pixel color is derived from the properties of the first crossed surface,; according some illumination model and material optical properties. While; there are currently existing quite sophisticated ray tracing models,; **`TGeo`** is currently using a very simple approach where the light; source is matching the eye position (no shadows or back-tracing of the; reflected ray)",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:145936,Performance,perform,performing,145936,"n several clipping shapes. Note that these shapes; are considered defined in the current `MARS`. Composite shapes may be; used. 2`. gGeoManager->SetClippingShape(clip1);`. One can activate or deactivate clipping at any time:; `gGeoManager->SetClipping(flag);`. 3. Perform ray-tracing:` gGeoManager->GetTopVolume()->Raytrace();`. One can redo the steps 2-3 as many times as needed. Let us look how the; ***`rootgeom`*** example looks clipped with a tube. ![Ray-tracing example with box-clipping](pictures/030001E5.png). ## Representing Misalignments of the Ideal Geometry. The ideal positioning of a detector does not match its position in the; experimental hall. This generally happens not only for the detector; modules, but also for their components. The accurate knowledge of the; detector real misalignments can be extremely important for getting close; to its designed resolution and the expected tracking efficiency.; **`TGeo`** offers tools for representing positioning misalignments,; applying them to the ideal geometry and performing navigation under; these conditions. Detector tracking algorithms can then directly query; the geometry for navigation purposes or for retrieving actual; misalignment information. ### Physical Nodes. Physical nodes are the actual ""touchable"" objects in the geometry,; representing actually a path of positioned volumes starting with the; top node: `path=/TOP/A_1/B_4/C_3` , where `A`, `B`, `C` represent names; of volumes. The number of physical nodes is given by the total number of; possible of branches in the geometry hierarchy. In case of detector; geometries and specially for calorimeters this number can be of the; order 106-109, therefore it is impossible to create all physical nodes; as objects in memory. In **`TGeo`**, physical nodes are represented by; the class **`TGeoPhysicalNode`** and can be created on demand for; alignment purposes:. ``` {.cpp}; TGeoPhysicalNode(const char* path); ```. The knowledge of the path to the objects that need",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:150653,Performance,load,loading,150653,". The call to `pn1->Align()` will invalidate the pointer to the node `B_1`; in `pn2` object.. The way out is to either call `pn1->Align()` before; the creation of `pn2`, either to use a global method that will correct; all existing physical nodes:. ``` {.cpp}; void RefreshPhysicalNodes(Bool_t lock = kTRUE); ```. The method above will optionally lock the possibility of doing any; further misalignment. ## Geometry I/O. Once geometry is successfully built, it can be saved in a root file, as; C++ macro or as GDML file by calling:. ``` {.cpp}; TGeoManager::Export(const char *filename,const char*keyname="""",; Option_t *opt=""vg""); ```. - `Filename`is the name of the file to be written (mandatory).; Depending on the extension of the file, the geometry is exported; either as ,root file or .C(.cxx) macro or GDML file in case; extension is .gdml.; - `keyname`is the name of the key in the file (default """"); - `opt` = `""v""` is an export voxelization (default), otherwise; voxelization is recomputed after loading the geometry, `""g""` this; option (default) is taken into account only for exporting to gdml; file and it ensures compatibility with Geant4 (e.g. it adds extra; plane to incorrectly set polycone, it checks whether offset of Phi; division is in (-360;0\> range, ...), for this gdml export there are; two more option, that are not set by default: `""f""` and `""n""`. If; none of this two options are set, then names of solids and volumes; in resulting gdml file will have incremental suffix (e.g.; TGeoBBox\_0x1, TGeoBBox\_0x2, ...). If `""f""` option is set then then; suffix will contain pointer of object (e.g. TGeoBBox\_0xAAAAA01,; ...). Finally if option `""n""` is set then no suffix will be added,; though in this case uniqueness of the names is not ensured and it can; cause that file will be invalid. Loading geometry from a root file can be done in the same way as for any; other ROOT object, but a static method is also provided:. ``` {.cpp}; TGeoManager::Import(const char *filename,con",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:154763,Performance,optimiz,optimization,154763,"; TGeoVolume *module2 = TGeoVolume::Import(""file.root"", ""MOD2"");; top->AddNode(module1, 1, new TGeoTranslation(0,0,100));; top->AddNode(module2, 1, new TGeoTranslation(0,0,-100));; // One should close oneself the geometry; geom->CloseGeometry();; ```. ### GDML. Few lines above word GDML was used. GDML stands for **G**eometry; **D**escription **M**arkup **L**anguage. It is an application-independent; geometry description format based on XML. It is mainly used for geometry; interchange between ROOT and Geant4 framework. More details about this; project can be found http://gdml.web.cern.ch. This feature; (importing/exporting from/to gdml file format) is disabled by default in; ROOT installation. To enable this feature add `--enable-gdml` option to; `./configure` script call. ## Navigation Algorithms. This section will describe the main methods and algorithms used for; implementing the navigation features within the geometrical modeller.; This includes navigation queries at shape level, global geometrical; queries and optimization mechanisms. ### Finding the State Corresponding to a Location (x,y,z). For reminder, a geometry state is a ‘touchable' object in the geometry; hierarchy. It is represented by a path like: **/TOP\_1/A\_1/B\_3/C\_1**,; where **B\_3** for instance is a copy of volume **B** positioned inside; volume **A**. A state is always associated to a transformation matrix; **M** of the touchable with respect to the global reference frame; (obtained by piling-up all local transformations of nodes in the branch; with respect to their containers). The current state and the; corresponding global matrix are updated whenever the geometry depth is; modified. The global transformations corresponding to all nodes in the; current branch are kept in an array: (**MTOP\_1, MA\_1, MB\_3, ...**). ![Navigation in the geometry hierarchy](pictures/080001E6.png). The elementary operations for changing the state are:. ``` {.cpp}; TGeoManager::CdUp();; TGeoManager::CdDown(i);; TG",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:157115,Performance,optimiz,optimizes,157115,"Node(x,y,z); ```. Note that the current particle position can be set using; **`SetCurrentPosition(x,y,z)`** method of the manager class, in which; case **`FindNode()`** can be called without arguments. The method; returns a pointer to the *deepest node* that geometrically contains *P*; (in our case let us suppose it is *B\_3*). Since a node is just a; positioned volume, we can then get a pointer to the volume, medium or; material objects related to it. *Deepest* means that *B\_3* still; contains point *P* (as well as *A\_1* and *TOP\_1*), but none of the; daughters of volume **B** does. After finding out the node containing; the particle, one can check if the geometry state is different compared; to the last located point:. ``` {.cpp}; Bool_t *TGeoManager::IsSameLocation(); ```. The algorithm for finding where a point is located in geometry is; presented in the figure 17-36. It always starts by checking if the last computed modeller state is the; answer. This optimizes the search when continuously tracking a particle.; The main actions performed are:. - moving up and down in the logical node tree while updating the; current node and its global matrix; - converting the global position into the local frame of the current; node/volume; - checking whether the local position lies within the geometrical; shape of the current volume - if this is the case continue the; search downwards for the daughters of the current node, otherwise; search upwards its containers until the top level is reached.; - the number of candidate nodes to be checked at a given level is; minimized by an additional optimization structure: voxels. This is; effective even in case there is only one daughter of the current; volume.; - in case the current node is declared as possibly overlapping, the; method FindInCluster() is invoked. This method checks all different; possibilities within the cluster of overlapping candidates. One of; the candidates is prioritized if one of the following conditions id; fu",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:157193,Performance,perform,performed,157193,"osition can be set using; **`SetCurrentPosition(x,y,z)`** method of the manager class, in which; case **`FindNode()`** can be called without arguments. The method; returns a pointer to the *deepest node* that geometrically contains *P*; (in our case let us suppose it is *B\_3*). Since a node is just a; positioned volume, we can then get a pointer to the volume, medium or; material objects related to it. *Deepest* means that *B\_3* still; contains point *P* (as well as *A\_1* and *TOP\_1*), but none of the; daughters of volume **B** does. After finding out the node containing; the particle, one can check if the geometry state is different compared; to the last located point:. ``` {.cpp}; Bool_t *TGeoManager::IsSameLocation(); ```. The algorithm for finding where a point is located in geometry is; presented in the figure 17-36. It always starts by checking if the last computed modeller state is the; answer. This optimizes the search when continuously tracking a particle.; The main actions performed are:. - moving up and down in the logical node tree while updating the; current node and its global matrix; - converting the global position into the local frame of the current; node/volume; - checking whether the local position lies within the geometrical; shape of the current volume - if this is the case continue the; search downwards for the daughters of the current node, otherwise; search upwards its containers until the top level is reached.; - the number of candidate nodes to be checked at a given level is; minimized by an additional optimization structure: voxels. This is; effective even in case there is only one daughter of the current; volume.; - in case the current node is declared as possibly overlapping, the; method FindInCluster() is invoked. This method checks all different; possibilities within the cluster of overlapping candidates. One of; the candidates is prioritized if one of the following conditions id; fulfilled (in order):; - Is declared as non-overlap",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:157749,Performance,optimiz,optimization,157749,"volume **B** does. After finding out the node containing; the particle, one can check if the geometry state is different compared; to the last located point:. ``` {.cpp}; Bool_t *TGeoManager::IsSameLocation(); ```. The algorithm for finding where a point is located in geometry is; presented in the figure 17-36. It always starts by checking if the last computed modeller state is the; answer. This optimizes the search when continuously tracking a particle.; The main actions performed are:. - moving up and down in the logical node tree while updating the; current node and its global matrix; - converting the global position into the local frame of the current; node/volume; - checking whether the local position lies within the geometrical; shape of the current volume - if this is the case continue the; search downwards for the daughters of the current node, otherwise; search upwards its containers until the top level is reached.; - the number of candidate nodes to be checked at a given level is; minimized by an additional optimization structure: voxels. This is; effective even in case there is only one daughter of the current; volume.; - in case the current node is declared as possibly overlapping, the; method FindInCluster() is invoked. This method checks all different; possibilities within the cluster of overlapping candidates. One of; the candidates is prioritized if one of the following conditions id; fulfilled (in order):; - Is declared as non-overlapping (these are anyway searched first); - Has at least one daughter that contains the current point; - Was already declared as containing the point at a previous step. ![Finding the location of a point in the geometry hierarchy](pictures/080001E7.png). ### Finding the Distance to Next Crossed Boundary. The most important feature provided by the modeller related to track; propagation is the computation of the distance to the next boundary; along a straight line. The relevant state parameters used for this task are:. - Cur",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:159973,Performance,perform,perform,159973,"ance to next boundary is:. ``` {.cpp}; TGeoNode *TGeoManager::FindNextBoundary(stepmax, path); ```. The output node returned by the method is the object which shape; boundary will be crossed first. The distance to the next crossing can be; retrieved after the call:. ``` {.cpp}; Double_t TGeoManager::GetStep(); ```. - The main input parameter is `stepmax,` which act as a trigger for; different features. The absolute value of this parameter represents; the step value proposed by the user. The algorithm will never try o; search for boundaries further than this distance. In case no; boundary is found the returned node will be the current one and the; computed step to boundary will be equal to abs (`stepmax`) having; the meaning *""step approved""*. The default value for `stepmax` is; `TGeoShape::Big `with the meaning that boundaries are looked for; without limitation. ![Finding the distance to the next crossed boundary](pictures/080001E8.png). According the values of the input parameters the method will perform; additional optional tasks:. **`|stepmax| < `** ***`TGeoShape::Big()`*** **` `**. The safe distance in the current volume is also computed. Moving the; particle from its current location with this distance in any direction; is safe in the sense that will never change the current state. **`stepmax < 0`**. The global matrix for the object that will have the next crossed; boundary is also computed. This can be retrieved for masterlocal point; or vector conversions: **`TGeoManager`**::`GetNextMatrix`(). In case the computation of the normal vector to the next crossed surface; is required, using a negative stepmax value is recommended. In this case; one can subsequently call a method for fast normal computation:. ``` {.cpp}; Double_t *TGeoManager::FindNormalFast(); ```. **`path `** **` 0`**. In case a path to a given physical object is specified, the distance to; its boundary is computed ignoring the rest of the geometry. #### Output Values. `TGeoManager::GetStep()`: di",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:162438,Performance,perform,performed,162438,"`**`::Safety ()` is invoked. A safety value less than; **`TGeoShape`**`::Tolerance()` will set the flag IsOnBoundary to true.; On the other hand, a safety value bigger than the proposed step will; stop the computation of the distance to next boundary, returning the; current geometry location with the meaning that the proposed step is; safe. The next stage is to check if computation of the distance to a give; physical object specified by a path was required. If this is the case,; the modeller changes the state to point to the required object, converts; the current point and direction coordinates to the local frame of this; object and computes the distance to its shape. The node returned is the; one pointed by the input path in case the shape is crossed; otherwise; the returned value is NULL. In case the distance to next crossed; boundary is required, the current point has to be physically INSIDE the; shape pointed by the current volume. This is only insured in case a call; to `TGeoManager::FindNode()` was performed for the current point.; Therefore, the first step is to convert the global current point and; direction in the local reference frame of the current volume and to; compute the distance to exit its shape from inside. The returned value; is again compared to the maximum allowed step (the proposed one) and in; case the distance is safe no other action is performed and the proposed; step is approved. In case the boundary is closer, the computed distance; is taken as maximum allowed step. For optimization purposed, for; particles starting very close to the current volume boundary (less than; 0.01 microns) and exiting the algorithm stops here. After computing the distance to exit the current node, the distance to; the daughter of the current volume which is crossed next is computed by; **`TGeoManager`**`::FindNextDaughterBoundary().` This computes the; distance to all daughter candidates that can be possibly crossed by; using volume voxelization. The algorithm is ",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:162801,Performance,perform,performed,162801," safe. The next stage is to check if computation of the distance to a give; physical object specified by a path was required. If this is the case,; the modeller changes the state to point to the required object, converts; the current point and direction coordinates to the local frame of this; object and computes the distance to its shape. The node returned is the; one pointed by the input path in case the shape is crossed; otherwise; the returned value is NULL. In case the distance to next crossed; boundary is required, the current point has to be physically INSIDE the; shape pointed by the current volume. This is only insured in case a call; to `TGeoManager::FindNode()` was performed for the current point.; Therefore, the first step is to convert the global current point and; direction in the local reference frame of the current volume and to; compute the distance to exit its shape from inside. The returned value; is again compared to the maximum allowed step (the proposed one) and in; case the distance is safe no other action is performed and the proposed; step is approved. In case the boundary is closer, the computed distance; is taken as maximum allowed step. For optimization purposed, for; particles starting very close to the current volume boundary (less than; 0.01 microns) and exiting the algorithm stops here. After computing the distance to exit the current node, the distance to; the daughter of the current volume which is crossed next is computed by; **`TGeoManager`**`::FindNextDaughterBoundary().` This computes the; distance to all daughter candidates that can be possibly crossed by; using volume voxelization. The algorithm is efficient in average only in; case the number of daughters is greater than 4. For fewer nodes, a; simple loop is performed and the minimum distance (from a point outside; each shape) is taken and compared to the maximum allowed step. The step; value is again updated if `step<stepmax` . A special case is when the current node is decla",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:162940,Performance,optimiz,optimization,162940,"oint and direction coordinates to the local frame of this; object and computes the distance to its shape. The node returned is the; one pointed by the input path in case the shape is crossed; otherwise; the returned value is NULL. In case the distance to next crossed; boundary is required, the current point has to be physically INSIDE the; shape pointed by the current volume. This is only insured in case a call; to `TGeoManager::FindNode()` was performed for the current point.; Therefore, the first step is to convert the global current point and; direction in the local reference frame of the current volume and to; compute the distance to exit its shape from inside. The returned value; is again compared to the maximum allowed step (the proposed one) and in; case the distance is safe no other action is performed and the proposed; step is approved. In case the boundary is closer, the computed distance; is taken as maximum allowed step. For optimization purposed, for; particles starting very close to the current volume boundary (less than; 0.01 microns) and exiting the algorithm stops here. After computing the distance to exit the current node, the distance to; the daughter of the current volume which is crossed next is computed by; **`TGeoManager`**`::FindNextDaughterBoundary().` This computes the; distance to all daughter candidates that can be possibly crossed by; using volume voxelization. The algorithm is efficient in average only in; case the number of daughters is greater than 4. For fewer nodes, a; simple loop is performed and the minimum distance (from a point outside; each shape) is taken and compared to the maximum allowed step. The step; value is again updated if `step<stepmax` . A special case is when the current node is declared as possibly; overlapping with something else. If this is the case, the distance is; computed for all possibly overlapping candidates, taking into account; the overlapping priorities (see also: "" Overlapping volumes ""). The global m",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:163532,Performance,perform,performed,163532," frame of the current volume and to; compute the distance to exit its shape from inside. The returned value; is again compared to the maximum allowed step (the proposed one) and in; case the distance is safe no other action is performed and the proposed; step is approved. In case the boundary is closer, the computed distance; is taken as maximum allowed step. For optimization purposed, for; particles starting very close to the current volume boundary (less than; 0.01 microns) and exiting the algorithm stops here. After computing the distance to exit the current node, the distance to; the daughter of the current volume which is crossed next is computed by; **`TGeoManager`**`::FindNextDaughterBoundary().` This computes the; distance to all daughter candidates that can be possibly crossed by; using volume voxelization. The algorithm is efficient in average only in; case the number of daughters is greater than 4. For fewer nodes, a; simple loop is performed and the minimum distance (from a point outside; each shape) is taken and compared to the maximum allowed step. The step; value is again updated if `step<stepmax` . A special case is when the current node is declared as possibly; overlapping with something else. If this is the case, the distance is; computed for all possibly overlapping candidates, taking into account; the overlapping priorities (see also: "" Overlapping volumes ""). The global matrix describing the next crossed physical node is; systematically computed in case the value of the proposed step is; negative. In this case, one can subsequently call; `TGeoManager::ComputeNormalFast()` to get the normal vector to the; crossed surface, after propagating the current point with the; `TGeoManager::GetStep()` value. This propagation can be done like:. ``` {.cpp}; Double_t *current_point = gGeoManager->GetCurrentPoint();; Double_t *current_dir = gGeoManager->GetCurrentDirection();; for (Int_t i=0; i<3; i++); current_point[i] += step * current_dir[I];; ```. Note: Th",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:165008,Performance,perform,performs,165008,"osed step is; negative. In this case, one can subsequently call; `TGeoManager::ComputeNormalFast()` to get the normal vector to the; crossed surface, after propagating the current point with the; `TGeoManager::GetStep()` value. This propagation can be done like:. ``` {.cpp}; Double_t *current_point = gGeoManager->GetCurrentPoint();; Double_t *current_dir = gGeoManager->GetCurrentDirection();; for (Int_t i=0; i<3; i++); current_point[i] += step * current_dir[I];; ```. Note: The method `TGeoManager::FindNextBoundary()` does not modify the; current point/direction nor the current volume/state. The returned node; is the next crossed one, but the physical path (state) AFTER crossing; the boundary is not determined. In order to find out this new state, one; has to propagate the point with a distance slightly bigger that the; computed step value (which is accurate within numerical precision). A; method that performs this task finding the next location is; `TGeoManager::Step()`, described in "" Making a Step "", but users may; implement more precise methods to insure post-step boundary crossing. ## Geometry Graphical User Interface. The geombuilder package allows you to create and edit geometries. The; package provides a library of all GUI classes related to geometry. Each; editable geometry class **`TGeoXXX`** have a correspondent editor; **`TGeoXXXEditor`** that provides a graphics user interface allowing to; edit some (or all) parameters of a geometry object. The editable objects; are geometry manager, volumes, nodes, shapes, media, materials and; matrices. The interfaces provide also access to specific functionality; of geometry objects. The editing mechanism is based on ROOT GED; (Graphics Editors) functionality and the library is loaded using the; plug-in mechanism. ### Editing a Geometry. There are two different use cases having different ways of invoking the; geometry editors. The first one applies when starting with geometry from; scratch and using the builder functi",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:165850,Performance,load,loaded,165850,"der to find out this new state, one; has to propagate the point with a distance slightly bigger that the; computed step value (which is accurate within numerical precision). A; method that performs this task finding the next location is; `TGeoManager::Step()`, described in "" Making a Step "", but users may; implement more precise methods to insure post-step boundary crossing. ## Geometry Graphical User Interface. The geombuilder package allows you to create and edit geometries. The; package provides a library of all GUI classes related to geometry. Each; editable geometry class **`TGeoXXX`** have a correspondent editor; **`TGeoXXXEditor`** that provides a graphics user interface allowing to; edit some (or all) parameters of a geometry object. The editable objects; are geometry manager, volumes, nodes, shapes, media, materials and; matrices. The interfaces provide also access to specific functionality; of geometry objects. The editing mechanism is based on ROOT GED; (Graphics Editors) functionality and the library is loaded using the; plug-in mechanism. ### Editing a Geometry. There are two different use cases having different ways of invoking the; geometry editors. The first one applies when starting with geometry from; scratch and using the builder functionality to create new geometry; objects. In this case, one should use the sequence:. ``` {.cpp}; root[] TGeoManager *geom = new TGeoManager(""MyGeom"",; ""Test builder"");; root[] geom->Edit(Option_t *option="""");; ```. The lines above will create a new **`TGeoManager`** class, create an; empty canvas and start the editor in the left-sided editor frame; attached to the canvas. To open the editor in a separate frame one; should provide a non-empty string as option to the `Edit()` method. ![The geometry manager editor](pictures/030001E9.png). ### The Geometry Manager Editor. ![Accessing/creating different categories of editable; objects](pictures/020001EA.jpg) ![Accessing/creating different; categories of editable objects](",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:167207,Performance,load,loaded,167207,"""Test builder"");; root[] geom->Edit(Option_t *option="""");; ```. The lines above will create a new **`TGeoManager`** class, create an; empty canvas and start the editor in the left-sided editor frame; attached to the canvas. To open the editor in a separate frame one; should provide a non-empty string as option to the `Edit()` method. ![The geometry manager editor](pictures/030001E9.png). ### The Geometry Manager Editor. ![Accessing/creating different categories of editable; objects](pictures/020001EA.jpg) ![Accessing/creating different; categories of editable objects](pictures/020001EB.jpg); ![Accessing/creating different categories of editable; objects](pictures/020001EC.jpg) ![Accessing/creating different; categories of editable objects](pictures/020001ED.jpg); ![Accessing/creating different categories of editable; objects](pictures/020001EE.jpg). The second use case applies when starting to edit an existing geometry.; Supposing the geometry was loaded into memory, besides the first method; that still applies one can also edit drawn geometry objects. For this,; the menu entry View/Editor of the canvas containing for instance a drawn; volume must be activated. For starting the volume editor one can click; on a volume. The GUI of the **`TGeoManager`** class can be started by; clicking on the top-right `40x40` pixels corner of the pad with a drawn; geometry. This is the main entry point for editing the geometry or creating new; objects. Once the interface is created (using one of the methods; described above), several categories can be accessed via a shutter GUI; widget:. - *General.* This allows changing the name/title of the geometry,; setting the top volume, closing the geometry and saving the geometry; in a file. The file name is formed by `geometry_name.C` or `.root`; depending if the geometry need to be saved as a `C` macro or a; `.root` file.; - *Shapes.* The category provides buttons for creation of all; supported shapes. The new shape name is chosen by the in",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:171722,Performance,perform,performed,171722," apply button is; pressed, the changes are applied to the edited shape and drawn. The; ""*Undo*"" button becomes active after the first modification has been; applied. It allows restoring the initial parameters of the shape. NOTE: In this version the ""*Undo*"" does not allow restoring an; intermediate state of the parameters that was applied - it will always; restore the parameters at the moment the shape was edited. All material properties changes are undoable. The mixture editor; currently allows adding elements one by one in the mixture composition.; This can be done either by element weight fraction or by number of; atoms. Once an element was added using one method the other method is not; selectable anymore. Summing component fractions up to 1 in the final; mixture is the user responsibility. Adding materials as components of a; mixture is not supported in this version. The elements that were added to the mixture appear in the bottom of the; mixture editor. The operations performed on mixture are not undoable. ### Creation of New Objects. As described above, all geometry object creators are accessible within; the geometry manager editor frame. Generally, if the new object that; needs to be created does not depend on other objects, it will be built; with a set of default parameters. This is the case for all shapes; (except composite shapes) and matrices. For all the other objects the; interface forces the selection of components before creating the object. ### Editing Volumes. Volumes are hierarchical components in the geometry, therefore their; editor is more complex. It provides the following functionalities:. - *General*. This category allows changing the name of the volume and; selecting other shape or medium among existing ones. - *Daughters*. The category allows removing existing daughter nodes or; adding new ones. The button ""*Position*"" allows editing the; positioning matrix of a given node. ![Setting volume properties and modifying volume hierarchy](pictur",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:134,Safety,detect,detector,134,"# The Geometry Package; \index{Geometry}. The new ROOT geometry package is a tool for building, browsing,; navigating and visualizing detector geometries. The code works; standalone with respect to any tracking Monte-Carlo engine; therefore,; it does not contain any constraints related to physics. However, the; navigation features provided by the package are designed to optimize; particle transport through complex geometries, working in correlation; with simulation packages such as GEANT3, GEANT4 and FLUKA. ## Quick Start: Creating the ""world"". This chapter will provide a detailed description on how to build valid; geometries as well as the ways to optimize them. There are several; components gluing together the geometrical model, but for the time being; let us get used with the most basic concepts. The basic bricks for building-up the model are called; `volumes`**.**These represent the un-positioned pieces of the geometry; puzzle. The difference is just that the relationship between the pieces; is not defined by neighbors, but by `containment`. In other words,; volumes are put one inside another making an in-depth hierarchy. From; outside, the whole thing looks like a big pack that you can open finding; out other smaller packs nicely arranged waiting to be opened at their; turn. The biggest one containing all others defines the ""`world`"" of the; model. We will often call this `master reference system (MARS)`. Going; on and opening our packs, we will obviously find out some empty ones,; otherwise, something is very wrong... We will call these leaves (by; analogy with a tree structure). On the other hand, any volume is a small world by itself - what we need; to do is to take it out and to ignore all the rest since it is a; self-contained object. In fact, the modeller can act like this,; considering a given volume as temporary MARS, but we will describe this; feature later on. Let us focus on the biggest pack - it is mandatory to; define one. Consider the simplest geom",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:2846,Safety,safe,safely,2846,"ter on. Let us focus on the biggest pack - it is mandatory to; define one. Consider the simplest geometry that is made of a single box.; Here is an example on how to build it:. ### Example 1: Creating the World. We first need to load the geometry library. This is not needed if one; does `make map` in root folder. ``` {.cpp}; root[] gSystem->Load(""libGeom"");; ```. Second, we have to create an instance of the geometry manager class.; This takes care of all the modeller components, performing several tasks; to insure geometry validity and containing the user interface for; building and interacting with the geometry. After its creation, the; geometry manager class can be accessed with the global; ***`gGeoManager`***:. ``` {.cpp}; root[] new TGeoManager(""world"", ""the simplest geometry"");; ```. We want to create a single volume in our geometry, but since any volume; needs to have an associated medium, we will create a dummy one. You can; safely ignore the following lines for the time being, since materials; and media will be explained in detail later on. ``` {.cpp}; root[] TGeoMaterial *mat = new TGeoMaterial(""Vacuum"",0,0,0);; root[] TGeoMedium *med = new TGeoMedium(""Vacuum"",1,mat);; ```. We can finally make our volume having a box shape. Note that the world; volume does not need to be a box - it can be any other shape. Generally,; boxes and tubes are the most recommendable shapes for this purpose due; to their fast navigation algorithms. ``` {.cpp}; root[] TGeoVolume *top=gGeoManager->MakeBox(""Top"",med,10.,10.,10.);; ```. The default units are in centimeters. Now we want to make this volume; our world. We have to do this operation **before** closing the geometry. ``` {.cpp}; root[] gGeoManager->SetTopVolume(top);; ```. This should be enough, but it is not since always after defining some; geometry hierarchy, **`TGeo`** needs to build some optimization; structures and perform some checks. Note the messages posted after the; statement is executed. We will describe the corr",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:23756,Safety,safe,safe,23756," can see that for creating; volumes one needs to create tracking media before. The way to proceed; for those not interested in performing tracking with external MC's is to; define and use only one `dummy tracking medium` as in the example (or a; `NULL` pointer). ### User Interface for Handling Materials and Media. The **`TGeoManager`** class contains the API for accessing and handling; defined materials:. ``` {.cpp}; TGeoManager::GetMaterial(name);; ```. ## Shapes. Shapes are geometrical objects that provide the basic modeling; functionality. They provide the definition of the `local` coordinate; system of the volume. Any volume must have a shape. Any shape recognized; by the modeller has to derive from the base **`TGeoShape`** class,; providing methods for:. - Finding out if a point defined in their local frame is contained or; not by the shape;; - Computing the distance to enter/exit the shape from a local point,; given a known direction;; - Computing the maximum distance in any direction from a local point; that does NOT result in a boundary crossing of the shape (safe; distance);; - Computing the cosines of the normal vector to the crossed shape; surface, given a starting local point and an ongoing direction. All the features above are globally managed by the modeller in order to; provide navigation functionality. In addition to those, shapes have also; to implement additional specific abstract methods:. - Computation of the minimal box bounding the shape, given that this; box have to be aligned with the local coordinates;; - Algorithms for dividing the shape along a given axis. The modeller currently provides a set of 20 basic shapes, which we will; call `primitives`. It also provides a special class allowing the; creation of shapes as a result of Boolean operations between primitives.; These are called `composite shapes` and the composition operation can be; recursive (combined composites). This allows the creation of a quite; large number of different shape to",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:28230,Safety,detect,detector,28230,"are; parallelograms in the general case. The Z faces have 2 edges parallel; with the X-axis. ![TGeoPara class](pictures/060001B7.png). The shape has the center in the origin and it is defined by:. - `dX, dY, dZ:` half-lengths of the projections of the edges on X, Y; and Z. The lower Z face is positioned at `-dZ`, while the upper at; `+dZ`.; - `alpha:` angle between the segment defined by the centers of the; X-parallel edges and Y axis `[-90,90]` in degrees; - `theta:` theta angle of the segment defined by the centers of the Z; faces;; - `phi:` phi angle of the same segment. ``` {.cpp}; TGeoPara(dX,dY,dZ,alpha,theta,phi);; ```. A box is a particular parallelepiped having the parameters:; `(dX,dY,dZ,0.,0.,0.)`. #### Trapezoids. In general, we will call trapezoidal shapes having 8 vertices and up to; 6 trapezoid faces. Besides that, two of the opposite faces are parallel; to XY plane and are positioned at ` dZ`. Since general trapezoids are; seldom used in detector geometry descriptions, there are several; primitives implemented in the modeller for particular cases. `Trd1` is a trapezoid with only X varying with Z. It is defined by the; half-length in Z, the half-length in X at the lowest and highest Z; planes and the half-length in Y:. ``` {.cpp}; TGeoTrd1(Double_t dx1,Double_t dx2,Double_t dy,Double_t dz);; ```. ![TGeoTrd1 class](pictures/060001B8.png). `Trd2` is a trapezoid with both X and Y varying with Z. It is defined by; the half-length in Z, the half-length in X at the lowest and highest Z; planes and the half-length in Y at these planes:. ``` {.cpp}; TGeoTrd2(Double_t dx1,Double_t dx2,Double_t dy1,Double_t dy2, Double_t dz);; ```. ![TGeoTrd2 class](pictures/060001B9.png). #### General Trapezoid - TGeoTrap Class. A general trapezoid is one for which the faces perpendicular to z are; trapezes but their centers are not necessary at the same x, y; coordinates. ![TGeoTrap Class](pictures/image443.jpg). It has eleven parameters: the half length in z, the polar angles",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:34685,Safety,avoid,avoid,34685," limited by two planes; perpendicular to the Z axis (top and bottom planes) and two hyperbolic; surfaces of revolution about Z axis (inner and outer surfaces). The; class describing hyperboloids is **`TGeoHype`** has 5 input parameters:. ``` {.cpp}; TGeoHype(Double_t rin,Double_t stin,Double_t rout,; Double_t stout,Double_t dz);; ```. ![TGeoHype Class](pictures/080001C1.png). The hyperbolic surface equation is taken in the form:. ``` {.cpp}; r2 - z2tan2() = r2min; ```. - `r,z:` cylindrical coordinates for a point on the surface; - `:` stereo angle between the hyperbola asymptotic lines and Z axis; - `r2min:` minimum distance between hyperbola and Z axis (at `z=0`). The input parameters represent:. - `rin, stin:` minimum radius and tangent of stereo angle for inner; surface; - `rout, stout:` minimum radius and tangent of stereo angle for outer; surface; - `dz:` half length in Z (bounding planes positions at `+/-dz`). The following conditions are mandatory in order to avoid intersections; between the inner and outer hyperbolic surfaces in the range `+/-dz`:. - `rin<rout`; - `rout>0`; - `rin2 + dz2*stin2 > rout2 + dz2*stout2`. Particular cases:. - `rin=0, stin0:` the inner surface is conical; - `stin=0 / stout=0:` cylindrical surface(s). #### Cones - TGeoCone Class. The cones are defined by 5 parameters:. ``` {.cpp}; TGeoCone(Double_t dz,Double_t rmin1,Double_t rmax1,; Double_t rmin2,Double_t rmax2);; ```. - `rmin1:` internal radius at Z is `-dz`; - `rmax1:` external radius at Z is `-dz`; - `rmin2:` internal radius at Z is `+dz`; - `rmax2:` external radius at Z is `+dz`; - `dz:` half length in Z (a cone ranges from `-dz` to +`dz`). A cone has Z-axis as its symmetry axis. ![TGeoCone Class](pictures/060001C2.png). #### Cone Segments - TGeoConeSeg Class. A cone segment is a cone having a range in `phi.` The cone segment class; derives from **`TGeoCone`**, having two extra parameters: `phi1` and; `phi2`. ``` {.cpp}; TGeoConeSeg(Double_t dz,Double_t rmin1,Double_t rmax1,; Do",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:50846,Safety,safe,safe,50846,"only when referring to a; given volume and it is always accessible at that level. Several volumes; may reference a single shape; therefore its deletion is not possible; once volumes were defined based on it. The navigation features related for instance to tracking particles are; performed in the following way: Each shape implement its specific; algorithms for all required tasks in its local reference system. Note; that the manager class handles global queries related to geometry.; However, shape-related queries might be sometimes useful:. ``` {.cpp}; Bool_t TGeoShape::Contains(Double_t *point[3]);; ```. The method above returns `kTRUE` if the point \*point is actually inside; the shape. The point has to be defined in the local shape reference. For; instance, for a box having `DX,DY` and `DZ `half-lengths a point will be; considered inside if:. `-DX <= point[0] <= DX`. `-DY <= point[1] <= DY`. `-DZ <= point[2] <= DZ`. ``` {.cpp}; Double_t TGeoShape::DistFromInside(Double_t *point[3],; Double_t *dir[3], Int_t iact,Double_t step,Double_t *safe);; ```. The method computes the distance to exiting a shape from a given point; `inside`, along a given direction. This direction is given by its; director cosines with respect to the local shape coordinate system. This; method provides additional information according the value of `iact`; input parameter:. - `iact = 0`computes only safe distance and fill it at the location; given by SAFE;; - `iact = 1`a proposed STEP is supplied. The safe distance is computed; first. If this is bigger than STEP than the proposed step is; approved and returned by the method since it does not cross the; shape boundaries. Otherwise, the distance to exiting the shape is; computed and returned;; - `iact = 2`computes both safe distance and distance to exiting,; ignoring the proposed step;; - `iact > 2`computes only the distance to exiting, ignoring anything; else. ``` {.cpp}; Double_t TGeoShape::DistFromOutside(Double_t *point[3],; Double_t *dir[3],Int",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:51186,Safety,safe,safe,51186,"anager class handles global queries related to geometry.; However, shape-related queries might be sometimes useful:. ``` {.cpp}; Bool_t TGeoShape::Contains(Double_t *point[3]);; ```. The method above returns `kTRUE` if the point \*point is actually inside; the shape. The point has to be defined in the local shape reference. For; instance, for a box having `DX,DY` and `DZ `half-lengths a point will be; considered inside if:. `-DX <= point[0] <= DX`. `-DY <= point[1] <= DY`. `-DZ <= point[2] <= DZ`. ``` {.cpp}; Double_t TGeoShape::DistFromInside(Double_t *point[3],; Double_t *dir[3], Int_t iact,Double_t step,Double_t *safe);; ```. The method computes the distance to exiting a shape from a given point; `inside`, along a given direction. This direction is given by its; director cosines with respect to the local shape coordinate system. This; method provides additional information according the value of `iact`; input parameter:. - `iact = 0`computes only safe distance and fill it at the location; given by SAFE;; - `iact = 1`a proposed STEP is supplied. The safe distance is computed; first. If this is bigger than STEP than the proposed step is; approved and returned by the method since it does not cross the; shape boundaries. Otherwise, the distance to exiting the shape is; computed and returned;; - `iact = 2`computes both safe distance and distance to exiting,; ignoring the proposed step;; - `iact > 2`computes only the distance to exiting, ignoring anything; else. ``` {.cpp}; Double_t TGeoShape::DistFromOutside(Double_t *point[3],; Double_t *dir[3],Int_t iact,Double_t step,Double_t *safe);; ```. This method computes the distance to entering a shape from a given point; `outside`. It acts in the same way as the previous method. ``` {.cpp}; Double_t TGeoShape::Safety(Double_t *point[3],Bool_t inside);; ```. This computes the maximum shift of a point in any direction that does; not change its `inside/outside `state (does not cross shape boundaries).; The state of the point h",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:51290,Safety,safe,safe,51290,"ueries might be sometimes useful:. ``` {.cpp}; Bool_t TGeoShape::Contains(Double_t *point[3]);; ```. The method above returns `kTRUE` if the point \*point is actually inside; the shape. The point has to be defined in the local shape reference. For; instance, for a box having `DX,DY` and `DZ `half-lengths a point will be; considered inside if:. `-DX <= point[0] <= DX`. `-DY <= point[1] <= DY`. `-DZ <= point[2] <= DZ`. ``` {.cpp}; Double_t TGeoShape::DistFromInside(Double_t *point[3],; Double_t *dir[3], Int_t iact,Double_t step,Double_t *safe);; ```. The method computes the distance to exiting a shape from a given point; `inside`, along a given direction. This direction is given by its; director cosines with respect to the local shape coordinate system. This; method provides additional information according the value of `iact`; input parameter:. - `iact = 0`computes only safe distance and fill it at the location; given by SAFE;; - `iact = 1`a proposed STEP is supplied. The safe distance is computed; first. If this is bigger than STEP than the proposed step is; approved and returned by the method since it does not cross the; shape boundaries. Otherwise, the distance to exiting the shape is; computed and returned;; - `iact = 2`computes both safe distance and distance to exiting,; ignoring the proposed step;; - `iact > 2`computes only the distance to exiting, ignoring anything; else. ``` {.cpp}; Double_t TGeoShape::DistFromOutside(Double_t *point[3],; Double_t *dir[3],Int_t iact,Double_t step,Double_t *safe);; ```. This method computes the distance to entering a shape from a given point; `outside`. It acts in the same way as the previous method. ``` {.cpp}; Double_t TGeoShape::Safety(Double_t *point[3],Bool_t inside);; ```. This computes the maximum shift of a point in any direction that does; not change its `inside/outside `state (does not cross shape boundaries).; The state of the point has to be properly supplied. ``` {.cpp}; Double_t *TGeoShape::ComputeNormal(Double_",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:51561,Safety,safe,safe,51561,",DY` and `DZ `half-lengths a point will be; considered inside if:. `-DX <= point[0] <= DX`. `-DY <= point[1] <= DY`. `-DZ <= point[2] <= DZ`. ``` {.cpp}; Double_t TGeoShape::DistFromInside(Double_t *point[3],; Double_t *dir[3], Int_t iact,Double_t step,Double_t *safe);; ```. The method computes the distance to exiting a shape from a given point; `inside`, along a given direction. This direction is given by its; director cosines with respect to the local shape coordinate system. This; method provides additional information according the value of `iact`; input parameter:. - `iact = 0`computes only safe distance and fill it at the location; given by SAFE;; - `iact = 1`a proposed STEP is supplied. The safe distance is computed; first. If this is bigger than STEP than the proposed step is; approved and returned by the method since it does not cross the; shape boundaries. Otherwise, the distance to exiting the shape is; computed and returned;; - `iact = 2`computes both safe distance and distance to exiting,; ignoring the proposed step;; - `iact > 2`computes only the distance to exiting, ignoring anything; else. ``` {.cpp}; Double_t TGeoShape::DistFromOutside(Double_t *point[3],; Double_t *dir[3],Int_t iact,Double_t step,Double_t *safe);; ```. This method computes the distance to entering a shape from a given point; `outside`. It acts in the same way as the previous method. ``` {.cpp}; Double_t TGeoShape::Safety(Double_t *point[3],Bool_t inside);; ```. This computes the maximum shift of a point in any direction that does; not change its `inside/outside `state (does not cross shape boundaries).; The state of the point has to be properly supplied. ``` {.cpp}; Double_t *TGeoShape::ComputeNormal(Double_t *point[3],; Double_t *dir[3],Double_t *norm[3]);; ```. The method above computes the director cosines of normal to the crossed; shape surface from a given point towards direction. This is filled into; the `norm` array, supplied by the user. The normal vector is always; chosen ",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:51827,Safety,safe,safe,51827,"ble_t *point[3],; Double_t *dir[3], Int_t iact,Double_t step,Double_t *safe);; ```. The method computes the distance to exiting a shape from a given point; `inside`, along a given direction. This direction is given by its; director cosines with respect to the local shape coordinate system. This; method provides additional information according the value of `iact`; input parameter:. - `iact = 0`computes only safe distance and fill it at the location; given by SAFE;; - `iact = 1`a proposed STEP is supplied. The safe distance is computed; first. If this is bigger than STEP than the proposed step is; approved and returned by the method since it does not cross the; shape boundaries. Otherwise, the distance to exiting the shape is; computed and returned;; - `iact = 2`computes both safe distance and distance to exiting,; ignoring the proposed step;; - `iact > 2`computes only the distance to exiting, ignoring anything; else. ``` {.cpp}; Double_t TGeoShape::DistFromOutside(Double_t *point[3],; Double_t *dir[3],Int_t iact,Double_t step,Double_t *safe);; ```. This method computes the distance to entering a shape from a given point; `outside`. It acts in the same way as the previous method. ``` {.cpp}; Double_t TGeoShape::Safety(Double_t *point[3],Bool_t inside);; ```. This computes the maximum shift of a point in any direction that does; not change its `inside/outside `state (does not cross shape boundaries).; The state of the point has to be properly supplied. ``` {.cpp}; Double_t *TGeoShape::ComputeNormal(Double_t *point[3],; Double_t *dir[3],Double_t *norm[3]);; ```. The method above computes the director cosines of normal to the crossed; shape surface from a given point towards direction. This is filled into; the `norm` array, supplied by the user. The normal vector is always; chosen such that its dot product with the direction is positive defined. ### Creating Shapes. Shape objects embeds only the minimum set of parameters that are fully; describing a valid physical shape.",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:55951,Safety,detect,detector,55951,"shapes. The modeller allows; however the definition of a single volume having undefined shape; parameters. ``` {.cpp}; TGeoManager::Volume(const char *name,const char *shape,Int_t nmed);; ```. - `name:` the name of the newly created volume;; - `shape:`the type of the associated shape. This has to contain the; case-insensitive first 4 letters of the corresponding class name; (e.g. ""`tubs`"" will match **`TGeoTubeSeg`**, ""`bbox`"" will match; **`TGeoBBox`**); - `nmed:` the medium number. This will create a special volume that will not be directly used in the; geometry, but whenever positioned will require a list of actual; parameters for the current shape that will be created in this process.; Such volumes having shape parameters known only when used have to be; positioned only with **`TGeoManager::Node()` method (see ‘Creating and; Positioning Volumes').**. Other case when shape parameterizations are quite useful is scaling; geometry structures. Imagine that we would like to enlarge/shrink a; detector structure on one or more axes. This happens quite often in real; life and is handled by ""fitting mother"" parameters. This is accomplished; by defining shapes with one or more invalid (negative) parameters. For; instance, defining a box having `dx=10.`, `dy=10.`, and `dz=-1` will not; generate an error but will be interpreted in a different way: A special; volume **`TGeoVolumeMulti`** will be created. Whenever positioned inside; a mother volume, this will create a normal **`TGeoVolume`** object; having as shape a box with `dz` fitting the corresponding `dz `of the; mother shape. Generally, this type of parameterization is used when; positioning volumes in containers having a matching shape, but it works; also for most reasonable combinations. ## Geometry Creation. A given geometry can be built in various ways, but one has to follow; some mandatory steps. Even if we might use some terms that will be; explained later, here are few general rules:. - Volumes need media and sha",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:64113,Safety,avoid,avoid,64113,"bedding such; nodes into geometry. Nodes have visualization attributes as the volume; has. When undefined by users, painting a node on a pad will take the; corresponding volume attributes. ### Creating and Positioning Volumes. #### Making Volumes. As mentioned before, volumes are the basic objects used in building the; geometrical hierarchy. They represent objects that are not positioned,; but store all information about the placement of the other volumes they; may contain. Therefore a volume can be replicated several times in the; geometry. As it was explained, in order to create a volume, one has to; put together a shape and a medium, which are already defined. Volumes have to be named by users at creation time. Every different name; may represent a unique volume object, but may also represent more; general a family (class) of volume objects having the same shape type; and medium, but possibly different shape parameters. It is the user's; task to provide different names for different volume families in order; to avoid ambiguities at tracking time. A generic family rather than a single volume is created only in two; cases: when a parametric shape is used or when a division operation is; applied. Each volume in the geometry stores a unique ID corresponding to; its family. In order to ease-up their creation, the manager class is; providing an API that allows making a shape and a volume in a single; step. #### Example of Volume Creation. ``` {.cpp}; // Making a volume out of a shape and a medium.; TGeoVolume *vol = new TGeoVolume(""VNAME"",ptrShape,ptrMed);. // Making a volume out of a shape but without a defined medium.; TGeoVolume *vol = new TGeoVolume(""VNAME"",ptrShape);. // Making a volume with a given shape in one step; TGeoVolume *vol = gGeoManager->MakeBox(""VNAME"",ptrMed,dx,dy,dz);; TGeoVolume *vol = gGeoManager->MakeTubs(""VNAME"",ptrMed,rmin,rmax,; dz,phi1,phi2);. // See class TGeoManager for the rest of shapes.; // Making a volume with a given shape with a unique ",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:65738,Safety,detect,detector,65738," Making a volume with a given shape in one step; TGeoVolume *vol = gGeoManager->MakeBox(""VNAME"",ptrMed,dx,dy,dz);; TGeoVolume *vol = gGeoManager->MakeTubs(""VNAME"",ptrMed,rmin,rmax,; dz,phi1,phi2);. // See class TGeoManager for the rest of shapes.; // Making a volume with a given shape with a unique prototype; TGeoVolume *vol = gGeoManager->Volume(""VNAME"",""XXXX"",nmed,upar,; npar);. // Where XXXX stands for the first 4 letters of the specific shape; // classes, nmed is the medium number, upar is an Double_t * array; // of the shape parameters and npar is the number of parameters.; // This prototype allows (npar = 0) to define volumes with shape; // defined only at positioning time (volumes defined in this way; // need to be positioned using TGeoManager::Node() method); ```. #### Positioned Volumes (Nodes). Geometrical modeling is a difficult task when the number of different; geometrical objects is 106-108. This is more or less the case for; detector geometries of complex experiments, where a ‘flat' CSG model; description cannot scale with the current CPU performances. This is the; reason why models like GEANT [1] introduced an additional dimension; (depth) in order to reduce the complexity of the problem. This concept; is also preserved by the ROOT modeller and introduces a pure geometrical; constraint between objects (volumes in our case) - containment. This; means in fact that any positioned volume has to be contained by another.; Now what means contained and positioned?. - We will say that a volume `contains` a point if this is inside the; shape associated to the volume. For instance, a volume having a box; shape will contain all points `P=(X,Y,Z)` verifying the conditions:; `Abs(Pi)dXi`. The points on the shape boundaries are considered as; inside the volume. The volume contains a daughter if it contains all; the points contained by the daughter.; - The definition of containment works of course only with points; defined in the local coordinate system of the consid",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:71506,Safety,avoid,avoid,71506,"ds, the limitation in proceeding this way is that `D,E,` and; `F` must point to the same medium. If this was not the case, we would; have to define different virtual volumes for each placement: `C`, `C'`; and `C""`, having the same shape but different media matching the; corresponding containers. This might not happen so often, but when it; does, it forces the creation of several extra virtual volumes. Other; limitation comes from the fact that any container is directly used by; navigation algorithms to optimize tracking. These must geometrically; contain their belongings (positioned volumes) so that these do not; extrude its shape boundaries. Not respecting this rule generally leads; to unpredictable results. Therefore `A` and `B` together must fit into; `C` that has to fit also into `D,E,` and `F`. This is not always; straightforward to accomplish, especially when instead of `A` and `B` we; have many more volumes. In order to avoid these problems, one can use for the difficult cases; the class **`TGeoVolumeAssembly`**, representing an assembly of volumes.; This behaves like a normal container volume supporting other volumes; positioned inside, but it has neither shape nor medium. It cannot be; used directly as a piece of the geometry, but just as a temporary; structure helping temporary assembling and positioning volumes. If we define now `C` as an assembly containing `A` and `B`, positioning; the assembly into `D,E` and `F` will actually position only `A` and; `B `directly into these volumes, taking into account their combined; transformations `A/B` to `C` and `C` to `D/E/F`. This looks much nicer,; is it? In fact, it is and it is not. Of course, we managed to get rid of; the ‘unnecessary' volume `C` in our geometry, but we end-up with a more; flat structure for `D,E` and `F` (more daughters inside). This can get; much worse when extensively used, as in the case: assemblies of; assemblies. For deciding what to choose between using virtual containers or; assemblies",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:76433,Safety,avoid,avoid,76433,"o all overlapping partners.; The answer provided by the modeller to ""Where am I?"" is no longer; deterministic if there is no priority assigned. There are two ways out provided by the modeller in such cases and we; will illustrate them by examples. - Suppose we have 2 crossing tubes that we have to describe. Such a; structure cannot be decomposed in a containment schema. This is a; typical example of simple structure that can be handled by using; composite shapes. What we have to do is to define as shapes the; inner and outer parts of the tubes (tubes having; `Rmin=0`,` Rmax=`inner/outer radius), then to make a composite:; - `C = (Tub1out+Tub2out)-(Tub1in+Tub2in)`; - On the other hand, if we have an EM calorimeter having a honeycomb; structure, Boolean combinations do not help anymore. Here the; problem is that we usually have a very large number of cells that; are naturally belonging to the same container. This result in a very; flat and slow structure for that particular container, which we; would very much want to avoid by introducing additional levels in; depth. We can describe the basic cell as a hexahedron that we can; represent by using a polygon primitive shape. Instead of putting one; by one all cells in the same container, we can define rows of such; elements, fitting in box-shaped containers. Then we can put; row-beside-row inside the container, making life much easier for its; navigation algorithms. The problem is that in order to reproduce the; honeycomb structure out of rows of cells, we have to overlap row; containers. Whoops - we have not obeyed rule No. 2 in positioning.; The way out is to position our rows with a special prototype:. ``` {.cpp}; ptrCAL->AddNodeOverlap(""ROW"",nRow,matrixRow);; ```. This will instruct the modeller that the daughter ROW inside CAL; overlaps with something else. The modeller will check this at closure; time and build a list of possibly overlapping candidates. This option is; equivalent with the option MANY in GEANT3. The ",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:79098,Safety,detect,detector,79098,"ll designate non-overlapping; nodes as ONLY and the others MANY as in GEANT3, where this concept was; introduced:. 1. The part of a MANY node B extruding its container A will never be; ""seen"" during navigation, as if B was in fact the result of the; intersection of A and B. 2. If we have two nodes A (ONLY) and B (MANY) inside the same container,; all points in the overlapping region of A and B will be designated as; belonging to A. 3. If A an B in the above case were both MANY, points in the overlapping; part will be designated to the one defined first. Both nodes must have; the same medium. 4. The slices of a divided MANY will be as well MANY. One needs to know that navigation inside geometry parts MANY nodes is; much slower. Any overlapping part can be defined based on composite; shapes - might be in some cases a better way out. #### Replicating Volumes. What can we do if our chamber contains two identical wires instead of; one? What if then we would need 1000 chambers in our detector? Should we; create 2000 wires and 1000 chamber volumes? No, we will just need to; replicate the ones that we have already created. ``` {.cpp}; chamber->AddNode(wire_co,1,new TGeoTranslation(0.2,0,0));; chamber->AddNode(wire_co,2,new TGeoTranslation(0.2,0,0));; ```. The 2 nodes that we have created inside chamber will both point to a; `wire_co` object, but will be completely distinct: `WIRE_CO_1` and; `WIRE_CO_2`. We will want now to place symmetrically 1000 chambers on a; pad, following a pattern of 20 rows and 50 columns. One way to do this; will be to replicate our chamber by positioning it 1000 times in; different positions of the pad. Unfortunately, this is far from being; the optimal way of doing what we want. Imagine that we would like to; find out which of the 1000 chambers is containing a `(x,y,z)` point; defined in the pad reference. You will never have to do that, since the; modeller will take care of it for you, but let's guess what it has to; do. The most simple algorithm",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:101505,Safety,safe,safety,101505,"nd their global transformations; are subjected to a caching mechanism due to the sometimes very large; memory requirements of logical graph expansion. The total number of; physical instances of volumes triggers the caching mechanism and the; cache manager is a client of **`TGeoManager`**. The manager class also; controls the drawing/checking package (**`TGeoPainter`** client). This; is linked with ROOT graphical libraries loaded on demand in order to; control visualization actions. ## Navigation and Tracking. Tracking is the feature allowing the transport of a given particle; knowing its kinematics. A state is determined by any combination of the; position $\vec{r}$ and direction $\vec{n}$ with respect to the world; reference frame. The direction $\vec{n}$ must be a unit vector having as; components the director cosines. The full classification of a given; state will provide the following information: the deepest physical node; containing the position vector, the distance to the closest boundary; along the direction vector, the next physical node after propagating the; current point with this distance and the safety distance to the nearest; boundary. This information allows the propagation of particles inside a; detector geometry by taking into account both geometrical and physical; constraints. We will hereby describe the user interface of **`TGeo`** to access; tracking functionality. This allows either developing a tracker for; simple navigation within a given geometry, either interfacing to an; external tracking engine such as GEANT. Note that the abstract interface; for external trackers can be found in `$ROOTSYS/vmc` folder and it can; be used to run GEANT3, GEANT4 and FLUKA-based simulations (\*) by using; directly a geometry described with ROOT. The interface methods related to tracking are incorporated into; **`TGeoManager`** class and implemented in the navigator class; **`TGeoNavigator`**. In order to be able to start tracking, one has to; define the initi",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:101610,Safety,detect,detector,101610,"cache manager is a client of **`TGeoManager`**. The manager class also; controls the drawing/checking package (**`TGeoPainter`** client). This; is linked with ROOT graphical libraries loaded on demand in order to; control visualization actions. ## Navigation and Tracking. Tracking is the feature allowing the transport of a given particle; knowing its kinematics. A state is determined by any combination of the; position $\vec{r}$ and direction $\vec{n}$ with respect to the world; reference frame. The direction $\vec{n}$ must be a unit vector having as; components the director cosines. The full classification of a given; state will provide the following information: the deepest physical node; containing the position vector, the distance to the closest boundary; along the direction vector, the next physical node after propagating the; current point with this distance and the safety distance to the nearest; boundary. This information allows the propagation of particles inside a; detector geometry by taking into account both geometrical and physical; constraints. We will hereby describe the user interface of **`TGeo`** to access; tracking functionality. This allows either developing a tracker for; simple navigation within a given geometry, either interfacing to an; external tracking engine such as GEANT. Note that the abstract interface; for external trackers can be found in `$ROOTSYS/vmc` folder and it can; be used to run GEANT3, GEANT4 and FLUKA-based simulations (\*) by using; directly a geometry described with ROOT. The interface methods related to tracking are incorporated into; **`TGeoManager`** class and implemented in the navigator class; **`TGeoNavigator`**. In order to be able to start tracking, one has to; define the initial state providing the starting point $\vec{r_0}$; and direction $\vec{n_0}$ .; There are several ways of doing that. ### TGeoNavigator Class. One geometry may have several independent navigators to query to; localize points or compute distan",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:103364,Safety,safe,safety,103364,"initial state providing the starting point $\vec{r_0}$; and direction $\vec{n_0}$ .; There are several ways of doing that. ### TGeoNavigator Class. One geometry may have several independent navigators to query to; localize points or compute distances. The geometry manager holds a list; of active navigators accessible via:. ``` {.cpp}; TObjArray *navigators = gGeoManager->GetListOfNavigators();; ```. Upon closing the geometry a default navigator is provided as first one; in this list, but one may add its own via:. ``` {.cpp}; TGeoNavigator *navig = new TGeoNavigator(gGeoManager);; // Store the index of the user navigator; Int_t inav = gGeoManager->AddNavigator(navig);; // Make its own navigator the active one; gGeoManager->SetCurrentNavigator(inav);; // Switch between navigators; gGeoManager->SetCurrentNavigator(0);; ```. A navigator holds several variables describing the current navigation; state: current point position, current direction distance to next; boundary, isotropic safety, pointer to current and next nods as well as; several tracking flags related to volume boundary conditions or other; properties required for track propagation in geometry. Each geometry; query affects these variables, so the only way in testing several; navigation alternatives and remembering the active navigation state is; to use parallel navigation. The following paragraphs will describe the; usage of a single navigator. All setters/getters for navigation state; parameters as well as navigation queries provided by **`TGeoNavigator`**; are interfaced by **`TGeoManager`** and will act on the current; navigator. ### Initializing the Starting Point. The current point (`x,y,z`) known by the modeller is stored as; `Double_t fCurrentPoint[3]` by the navigator class. This array of the; three coordinates is defined in the current global reference system and; can be retrieved any time:. ``` {.cpp}; Const Double_t *cpoint = gGeoManager->GetCurrentPoint();; ```. Initializing this point can be done ",MatchSource.DOCS,documentation/users-guide/Geometry.md,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md
