id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://root.cern/doc/master/TFormula_8cxx_source.html:151544,Performance,load,load,151544,"on TVirtualMutex.h:95; ROOT::v5::TFormulaThe FORMULA class (ROOT version 5)Definition TFormula.h:65; ROOT::v5::TFormula::GetParametersvirtual Double_t * GetParameters() constDefinition TFormula.h:243; ROOT::v5::TFormula::GetExpFormulavirtual TString GetExpFormula(Option_t *option="""") constReconstruct the formula expression from the internal TFormula member variables.Definition TFormula_v5.cxx:3022; ROOT::v5::TFormula::Streamervoid Streamer(TBuffer &b, const TClass *onfile_class)Stream a class object.Definition TFormula_v5.cxx:3460; TBufferBuffer base class used for serializing objects.Definition TBuffer.h:43; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::GetListOfAllPublicMethodsconst TList * GetListOfAllPublicMethods(Bool_t load=kTRUE)Returns a list of all public methods of this class and its base classes.Definition TClass.cxx:3912; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TF11-Dim function classDefinition TF1.h:233; TF1::GetFormulavirtual TFormula * GetFormula()Definition TF1.h:481; TFormulaFunctionHelper class for TFormula.Definition TFormula.h:32; TFormulaFunction::fFoundBool_t fFoundDefinition TFormula.h:37; TFormulaFunction::GetNameconst char * GetName() constDefinition TFormula.h:39; TFormulaFunction::GetNargsInt_t GetNargs() constDefinition TFormula.h:41; TFormulaFunction::fNameTString fNameDefinition TFormula.h:34; TFormulaFunction::IsFuncCallBool_t IsFuncCall() constDefinition TFormula.h:42; TFormulaVariableAnother helper class for TFormula.Definition TFormula.h:65; TFormulaVariable::fNameTString fNameDefinition TFormula.h:67; TFormulaVariable::fArrayPosInt_t fArrayPosDefinition TFormula.h:69; TFormulaVariable::fValueDouble_t fValueDefinition TFormula.h:68; TFormulaThe Formula class.Definition TFormula.h:89; TFormula::fHessFuncPtr",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:158740,Performance,perform,performs,158740,"lingInputTString fClingInput! Input function passed to ClingDefinition TFormula.h:93; TFormula::PrepareEvalMethodBool_t PrepareEvalMethod()Sets TMethodCall to function inside Cling environment.Definition TFormula.cxx:861; TFormula::fNumberInt_t fNumberNumber used to identify pre-defined functions (gaus, expo,..)Definition TFormula.h:151; TFormula::GetGradientFuncNamestd::string GetGradientFuncName() constDefinition TFormula.h:128; TFormula::fIsCladRuntimeIncludedstatic bool fIsCladRuntimeIncludedDefinition TFormula.h:111; TFormula::CladStoragestd::vector< Double_t > CladStorageDefinition TFormula.h:184; TFormula::GetVariableDouble_t GetVariable(const char *name) constReturns variable value.Definition TFormula.cxx:2686; TFormula::fFuncsstd::list< TFormulaFunction > fFuncs!Definition TFormula.h:143; TFormula::fAllParametersSettedBool_t fAllParametersSettedFlag to control if all parameters are setted.Definition TFormula.h:98; TFormula::ProcessFormulavoid ProcessFormula(TString &formula)Iterates through functors in fFuncs and performs the appropriate action.Definition TFormula.cxx:2077; TFormula::IsOperatorstatic Bool_t IsOperator(const char c)Definition TFormula.cxx:286; TFormula::HasHessianGenerationFailedbool HasHessianGenerationFailed() constDefinition TFormula.h:137; TFormula::SetVectorizedvoid SetVectorized(Bool_t vectorized)Definition TFormula.cxx:3046; TFormula::FillVecFunctionsShurtCutsvoid FillVecFunctionsShurtCuts()Fill the shortcuts for vectorized functions We will replace for example sin with vecCore::Mat::Sin.Definition TFormula.cxx:970; TFormula::GetParNameconst char * GetParName(Int_t ipar) constReturn parameter name given by integer.Definition TFormula.cxx:2859; TFormula::fVarsstd::map< TString, TFormulaVariable > fVars! List of variable namesDefinition TFormula.h:144; TFormula::fFuncPtrCallFuncSignature fFuncPtr! Function pointer, owned by the JIT.Definition TFormula.h:107; TFormula::HandlePolNvoid HandlePolN(TString &formula)Handling polN If before 'po",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:23541,Safety,avoid,avoid,23541,"y in the map; 610 {; 611 R__LOCKGUARD(gROOTMutex);; 612 ; 613 auto funcit = gClingFunctions.find(lambdaExpression);; 614 if (funcit != gClingFunctions.end() ) {; 615 fLambdaPtr = funcit->second;; 616 fClingInitialized = true;; 617 return true;; 618 }; 619 }; 620 ; 621 // to be sure the interpreter is initialized; 622 ROOT::GetROOT();; 623 R__ASSERT(gInterpreter);; 624 ; 625 // set the cling name using hash of the static formulae map; 626 auto hasher = gClingFunctions.hash_function();; 627 TString lambdaName = TString::Format(""lambda__id%zu"", hasher(lambdaExpression) );; 628 ; 629 //lambdaExpression = TString::Format(""[&](double * x, double *){ return %s ;}"",formula);; 630 //TString lambdaName = TString::Format(""mylambda_%s"",GetName() );; 631 TString lineExpr = TString::Format(""std::function<double(double*,double*)> %s = %s ;"",lambdaName.Data(), lambdaExpression.c_str() );; 632 gInterpreter->ProcessLine(lineExpr);; 633 fLambdaPtr = (void*) gInterpreter->ProcessLine(TString(lambdaName)+TString("";"")); // add ; to avoid printing; 634 if (fLambdaPtr != nullptr) {; 635 R__LOCKGUARD(gROOTMutex);; 636 gClingFunctions.insert ( std::make_pair ( lambdaExpression, fLambdaPtr) );; 637 fClingInitialized = true;; 638 return true;; 639 }; 640 fClingInitialized = false;; 641 return false;; 642}; 643 ; 644////////////////////////////////////////////////////////////////////////////////; 645/// Compile the given expression with Cling; 646/// backward compatibility method to be used in combination with the empty constructor; 647/// if no expression is given , the current stored formula (retrieved with GetExpFormula()) or the title is used.; 648/// return 0 if the formula compilation is successful; 649 ; 650Int_t TFormula::Compile(const char *expression); 651{; 652 TString formula = expression;; 653 if (formula.IsNull() ) {; 654 formula = fFormula;; 655 if (formula.IsNull() ) formula = GetTitle();; 656 }; 657 ; 658 if (formula.IsNull() ) return -1;; 659 ; 660 // do not re-process if it wa",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:45814,Safety,detect,detected,45814,"a(openingBracketPos + 1, closingBracketPos - openingBracketPos - 1);; 1197 dim = varList.CountChar(',') + 1;; 1198 variables.resize(dim);; 1199 Int_t Nvar = 0;; 1200 TString varName = """";; 1201 for (Int_t i = 0; i < varList.Length(); ++i) {; 1202 if (IsFunctionNameChar(varList[i])) {; 1203 varName.Append(varList[i]);; 1204 }; 1205 if (varList[i] == ',') {; 1206 variables[Nvar] = varName;; 1207 varName = """";; 1208 Nvar++;; 1209 }; 1210 }; 1211 if (varName != """") // we will miss last variable; 1212 {; 1213 variables[Nvar] = varName;; 1214 }; 1215 }; 1216 // check if dimension obtained from [...] is compatible with what is defined in existing pre-defined functions; 1217 // std::cout << "" Found dim = "" << dim << "" and function dimension is "" << funDim << std::endl;; 1218 if (dim != funDim) {; 1219 pair<TString, Int_t> key = make_pair(funName, dim);; 1220 if (functions.find(key) == functions.end()) {; 1221 Error(""PreProcessFormula"", ""Dimension of function %s is detected to be of dimension %d and is not ""; 1222 ""compatible with existing pre-defined function which has dim %d"",; 1223 funName.Data(), dim, funDim);; 1224 return;; 1225 }; 1226 // skip the particular function found - we might find later on the corresponding pre-defined function; 1227 funPos = formula.Index(funName, lastFunPos);; 1228 continue;; 1229 }; 1230 // look now for the (..) brackets to get the parameter counter (e.g. gaus(0) + gaus(3) ); 1231 // need to start for a position; 1232 Int_t openingParenthesisPos = (closingBracketPos == kNPOS) ? openingBracketPos : closingBracketPos + 1;; 1233 bool defaultCounter = (openingParenthesisPos > formula.Length() || formula[openingParenthesisPos] != '(');; 1234 ; 1235 // Int_t openingParenthesisPos = formula.Index('(',funPos);; 1236 // Bool_t defaultCounter = (openingParenthesisPos == kNPOS);; 1237 Int_t counter;; 1238 if (defaultCounter) {; 1239 counter = 0;; 1240 } else {; 1241 // Check whether this is just a number in parentheses. If not, leave; 1242 // it to `Han",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:75758,Safety,avoid,avoid,75758,"onArguments`); 1985 ; 1986 TString replacementFormula = f->GetExpFormula();; 1987 ; 1988 // analyze expression string; 1989 // std::cout << ""formula to replace for "" << f->GetName() << "" is "" << replacementFormula <<; 1990 // std::endl;; 1991 PreProcessFormula(replacementFormula);; 1992 // we need to define different parameters if we use the unnamed default parameters ([0]); 1993 // I need to replace all the terms in the functor for backward compatibility of the case; 1994 // f1(""[0]*x"") f2(""[0]*x"") f1+f2 - it is weird but it is better to support; 1995 // std::cout << ""current number of parameter is "" << fNpar << std::endl;; 1996 int nparOffset = 0;; 1997 // if (fParams.find(""0"") != fParams.end() ) {; 1998 // do in any case if parameters are existing; 1999 std::vector<TString> newNames;; 2000 if (fNpar > 0) {; 2001 nparOffset = fNpar;; 2002 newNames.resize(f->GetNpar());; 2003 // start from higher number to avoid overlap; 2004 for (int jpar = f->GetNpar() - 1; jpar >= 0; --jpar) {; 2005 // parameters name have a ""p"" added in front; 2006 TString pj = TString(f->GetParName(jpar));; 2007 if (pj[0] == 'p' && TString(pj(1, pj.Length())).IsDigit()) {; 2008 TString oldName = TString::Format(""[%s]"", f->GetParName(jpar));; 2009 TString newName = TString::Format(""[p%d]"", nparOffset + jpar);; 2010 // std::cout << ""replace - parameter "" << f->GetParName(jpar) << "" with "" << newName <<; 2011 // std::endl;; 2012 replacementFormula.ReplaceAll(oldName, newName);; 2013 newNames[jpar] = newName;; 2014 } else; 2015 newNames[jpar] = f->GetParName(jpar);; 2016 }; 2017 // std::cout << ""after replacing params "" << replacementFormula << std::endl;; 2018 }; 2019 ExtractFunctors(replacementFormula);; 2020 // std::cout << ""after re-extracting functors "" << replacementFormula << std::endl;; 2021 ; 2022 // set parameter value from replacement formula; 2023 for (int jpar = 0; jpar < f->GetNpar(); ++jpar) {; 2024 if (nparOffset > 0) {; 2025 // parameter have an offset- so take this into account; 2",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:115943,Safety,avoid,avoid,115943,"05 }; 3006 }; 3007 if (oldName.IsNull() ) {; 3008 Error(""SetParName"",""Parameter %d is not existing."",ipar);; 3009 return;; 3010 }; 3011 ; 3012 //replace also parameter name in formula expression in case is not a lambda; 3013 if (! TestBit(TFormula::kLambda)) ReplaceParamName(fFormula, oldName, name);; 3014 ; 3015}; 3016 ; 3017////////////////////////////////////////////////////////////////////////////////; 3018/// Replace in Formula expression the parameter name.; 3019 ; 3020void TFormula::ReplaceParamName(TString & formula, const TString & oldName, const TString & name){; 3021 if (!formula.IsNull() ) {; 3022 bool found = false;; 3023 for(list<TFormulaFunction>::iterator it = fFuncs.begin(); it != fFuncs.end(); ++it); 3024 {; 3025 if (oldName == it->GetName()) {; 3026 found = true;; 3027 it->fName = name;; 3028 break;; 3029 }; 3030 }; 3031 if (!found) {; 3032 Error(""SetParName"", ""Parameter %s is not defined."", oldName.Data());; 3033 return;; 3034 }; 3035 // change whitespace to \s to avoid problems in parsing; 3036 TString newName = name;; 3037 newName.ReplaceAll("" "", ""\\s"");; 3038 TString pattern = TString::Format(""[%s]"", oldName.Data());; 3039 TString replacement = TString::Format(""[%s]"", newName.Data());; 3040 formula.ReplaceAll(pattern, replacement);; 3041 }; 3042 ; 3043}; 3044 ; 3045////////////////////////////////////////////////////////////////////////////////; 3046void TFormula::SetVectorized(Bool_t vectorized); 3047{; 3048#ifdef R__HAS_VECCORE; 3049 if (fNdim == 0) {; 3050 Info(""SetVectorized"",""Cannot vectorized a function of zero dimension"");; 3051 return;; 3052 }; 3053 if (vectorized != fVectorized) {; 3054 if (!fFormula); 3055 Error(""SetVectorized"", ""Cannot set vectorized to %d -- Formula is missing"", vectorized);; 3056 ; 3057 fVectorized = vectorized;; 3058 // no need to JIT a new signature in case of zero dimension; 3059 //if (fNdim== 0) return;; 3060 fClingInitialized = false;; 3061 fReadyToExecute = false;; 3062 fClingName = """";; 3063 fClingInput = fF",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:128356,Safety,safe,safe,128356,"s shown.; 3358 ; 3359Double_t TFormula::DoEval(const double * x, const double * params) const; 3360{; 3361 if(!fReadyToExecute); 3362 {; 3363 Error(""Eval"", ""Formula is invalid and not ready to execute "");; 3364 for (auto it = fFuncs.begin(); it != fFuncs.end(); ++it) {; 3365 TFormulaFunction fun = *it;; 3366 if (!fun.fFound) {; 3367 printf(""%s is unknown.\n"", fun.GetName());; 3368 }; 3369 }; 3370 return TMath::QuietNaN();; 3371 }; 3372 ; 3373 // Lazy initialization is set and needed when reading from a file; 3374 if (!fClingInitialized && fLazyInitialization) {; 3375 // try recompiling the formula. We need to lock because this is not anymore thread safe; 3376 R__LOCKGUARD(gROOTMutex);; 3377 // check again in case another thread has initialized the formula (see ROOT-10994); 3378 if (!fClingInitialized) {; 3379 auto thisFormula = const_cast<TFormula*>(this);; 3380 thisFormula->ReInitializeEvalMethod();; 3381 }; 3382 if (!fClingInitialized) {; 3383 Error(""DoEval"", ""Formula has error and it is not properly initialized "");; 3384 return TMath::QuietNaN();; 3385 }; 3386 }; 3387 ; 3388 if (fLambdaPtr && TestBit(TFormula::kLambda)) {// case of lambda functions; 3389 std::function<double(double *, double *)> & fptr = * ( (std::function<double(double *, double *)> *) fLambdaPtr);; 3390 assert(x);; 3391 //double * v = (x) ? const_cast<double*>(x) : const_cast<double*>(fClingVariables.data());; 3392 double * v = const_cast<double*>(x);; 3393 double * p = (params) ? const_cast<double*>(params) : const_cast<double*>(fClingParameters.data());; 3394 return fptr(v, p);; 3395 }; 3396 ; 3397 ; 3398 Double_t result = 0;; 3399 void* args[2];; 3400 double * vars = (x) ? const_cast<double*>(x) : const_cast<double*>(fClingVariables.data());; 3401 args[0] = &vars;; 3402 if (fNpar <= 0) {; 3403 (*fFuncPtr)(nullptr, 1, args, &result);; 3404 } else {; 3405 double *pars = (params) ? const_cast<double *>(params) : const_cast<double *>(fClingParameters.data());; 3406 args[1] = &pars;; 3407 (*fFunc",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:130582,Safety,safe,safe,130582,"; 3415ROOT::Double_v TFormula::DoEvalVec(const ROOT::Double_v *x, const double *params) const; 3416{; 3417 if (!fReadyToExecute) {; 3418 Error(""Eval"", ""Formula is invalid and not ready to execute "");; 3419 for (auto it = fFuncs.begin(); it != fFuncs.end(); ++it) {; 3420 TFormulaFunction fun = *it;; 3421 if (!fun.fFound) {; 3422 printf(""%s is unknown.\n"", fun.GetName());; 3423 }; 3424 }; 3425 return TMath::QuietNaN();; 3426 }; 3427 // todo maybe save lambda ptr stuff for later; 3428 ; 3429 if (!fClingInitialized && fLazyInitialization) {; 3430 // try recompiling the formula. We need to lock because this is not anymore thread safe; 3431 R__LOCKGUARD(gROOTMutex);; 3432 // check again in case another thread has initialized the formula (see ROOT-10994); 3433 if (!fClingInitialized) {; 3434 auto thisFormula = const_cast<TFormula*>(this);; 3435 thisFormula->ReInitializeEvalMethod();; 3436 }; 3437 if (!fClingInitialized) {; 3438 Error(""DoEval"", ""Formula has error and it is not properly initialized "");; 3439 ROOT::Double_v res = TMath::QuietNaN();; 3440 return res;; 3441 }; 3442 }; 3443 ; 3444 ROOT::Double_v result = 0;; 3445 void *args[2];; 3446 ; 3447 ROOT::Double_v *vars = const_cast<ROOT::Double_v *>(x);; 3448 args[0] = &vars;; 3449 if (fNpar <= 0) {; 3450 (*fFuncPtr)(0, 1, args, &result);; 3451 }else {; 3452 double *pars = (params) ? const_cast<double *>(params) : const_cast<double *>(fClingParameters.data());; 3453 args[1] = &pars;; 3454 (*fFuncPtr)(0, 2, args, &result);; 3455 }; 3456 return result;; 3457}; 3458#endif // R__HAS_VECCORE; 3459 ; 3460 ; 3461//////////////////////////////////////////////////////////////////////////////; 3462/// Re-initialize eval method; 3463///; 3464/// This function is called by DoEval and DoEvalVector in case of a previous failure; 3465/// or in case of reading from a file; 3466////////////////////////////////////////////////////////////////////////////////; 3467void TFormula::ReInitializeEvalMethod() {; 3468 ; 3469 ; 3470 if (TestBit(TF",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:141465,Safety,avoid,avoid,141465,"er"",""Old formula read from file is NOT valid"");; 3699 Print(""v"");; 3700 }; 3701 delete fold;; 3702 return;; 3703 }; 3704 else if (v > 8) {; 3705 // new TFormula class; 3706 b.ReadClassBuffer(TFormula::Class(), this, v, R__s, R__c);; 3707 ; 3708 //std::cout << ""reading npar = "" << GetNpar() << std::endl;; 3709 ; 3710 // initialize the formula; 3711 // need to set size of fClingVariables which is transient; 3712 //fClingVariables.resize(fNdim);; 3713 ; 3714 // case of formula contains only parameters; 3715 if (fFormula.IsNull() ) return;; 3716 ; 3717 ; 3718 // store parameter values, names and order; 3719 std::vector<double> parValues = fClingParameters;; 3720 auto paramMap = fParams;; 3721 fNpar = fParams.size();; 3722 ; 3723 fLazyInitialization = true; // when reading we initialize the formula later to avoid problem of recursive Jitting; 3724 ; 3725 if (!TestBit(TFormula::kLambda) ) {; 3726 ; 3727 // save dimension read from the file (stored for V >=12); 3728 // and we check after initializing if it is the same; 3729 int ndim = fNdim;; 3730 fNdim = 0;; 3731 ; 3732 //std::cout << ""Streamer::Reading preprocess the formula "" << fFormula << "" ndim = "" << fNdim << "" npar = "" << fNpar << std::endl;; 3733 // for ( auto &p : fParams); 3734 // std::cout << ""parameter "" << p.first << "" index "" << p.second << std::endl;; 3735 ; 3736 fClingParameters.clear(); // need to be reset before re-initializing it; 3737 ; 3738 FillDefaults();; 3739 ; 3740 ; 3741 PreProcessFormula(fFormula);; 3742 ; 3743 //std::cout << ""Streamer::after pre-process the formula "" << fFormula << "" ndim = "" << fNdim << "" npar = "" << fNpar << std::endl;; 3744 ; 3745 PrepareFormula(fFormula);; 3746 ; 3747 //std::cout << ""Streamer::after prepared "" << fClingInput << "" ndim = "" << fNdim << "" npar = "" << fNpar << std::endl;; 3748 ; 3749 ; 3750 // restore parameter values; 3751 if (fNpar != (int) parValues.size() ) {; 3752 Error(""Streamer"",""number of parameters computed (%d) is not same as the stored parameters (%d",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:4890,Security,access,accessed,4890,"o applies to the predefined parametrized functions like `gaus` and; 110 `expo`.; 111 ; 112 Comparisons operators are also supported `(&amp;&amp;, ||, ==, &lt;=, &gt;=, !)`; 113 ; 114 Examples:; 115 ; 116 `sin(x*(x&lt;0.5 || x&gt;1))`; 117 ; 118 If the result of a comparison is TRUE, the result is 1, otherwise 0.; 119 ; 120 Already predefined names can be given. For example, if the formula; 121 ; 122 `TFormula old(""old"",sin(x*(x&lt;0.5 || x&gt;1)))`; 123 ; 124 one can assign a name to the formula. By default the name of the object = title = formula itself.; 125 ; 126 `TFormula new(""new"",""x*old"")`; 127 ; 128 is equivalent to:; 129 ; 130 `TFormula new(""new"",""x*sin(x*(x&lt;0.5 || x&gt;1))"")`; 131 ; 132 The class supports unlimited number of variables and parameters.; 133 By default the names which can be used for the variables are `x,y,z,t` or; 134 `x[0],x[1],x[2],x[3],....x[N]` for N-dimensional formulas.; 135 ; 136 This class is not anymore the base class for the function classes `TF1`, but it has now; 137 a data member of TF1 which can be accessed via `TF1::GetFormula`.; 138 ; 139 TFormula supports gradient and hessian calculations through clad.; 140 To calculate the gradient one needs to first declare a `CladStorage` of the; 141 same size as the number of parameters and then pass the variables and the; 142 created `CladStorage`:; 143 ; 144 ```; 145 TFormula f(""f"", ""x*[0] - y*[1]"");; 146 Double_t p[] = {40, 30};; 147 Double_t x[] = {1, 2};; 148 f.SetParameters(p);; 149 TFormula::CladStorage grad(2);; 150 f.GradientPar(x, grad);; 151 ```; 152 ; 153 The process is similar for hessians, except that the size of the created; 154 CladStorage should be the square of the number of parameters because; 155 `HessianPar` returns a flattened matrix:; 156 ; 157 ```; 158 TFormula::CladStorage hess(4);; 159 f.HessianPar(x, hess);; 160 ```; 161 ; 162 \anchor FormulaFuncs; 163 ### List of predefined functions; 164 ; 165 The list of available predefined functions which can be used as s",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:22920,Security,hash,hash,22920,")) {; 587 Error(""TFormula"",""The name %s is reserved as a TFormula variable name.\n"",formula.GetName());; 588 } else; 589 gROOT->GetListOfFunctions()->Add(this);; 590 }; 591 ; 592}; 593 ; 594////////////////////////////////////////////////////////////////////////////////; 595/// = operator.; 596 ; 597TFormula& TFormula::operator=(const TFormula &rhs); 598{; 599 if (this != &rhs); 600 rhs.TFormula::Copy(*this);; 601 return *this;; 602}; 603 ; 604////////////////////////////////////////////////////////////////////////////////; 605Bool_t TFormula::InitLambdaExpression(const char * formula) {; 606 ; 607 std::string lambdaExpression = formula;; 608 ; 609 // check if formula exist already in the map; 610 {; 611 R__LOCKGUARD(gROOTMutex);; 612 ; 613 auto funcit = gClingFunctions.find(lambdaExpression);; 614 if (funcit != gClingFunctions.end() ) {; 615 fLambdaPtr = funcit->second;; 616 fClingInitialized = true;; 617 return true;; 618 }; 619 }; 620 ; 621 // to be sure the interpreter is initialized; 622 ROOT::GetROOT();; 623 R__ASSERT(gInterpreter);; 624 ; 625 // set the cling name using hash of the static formulae map; 626 auto hasher = gClingFunctions.hash_function();; 627 TString lambdaName = TString::Format(""lambda__id%zu"", hasher(lambdaExpression) );; 628 ; 629 //lambdaExpression = TString::Format(""[&](double * x, double *){ return %s ;}"",formula);; 630 //TString lambdaName = TString::Format(""mylambda_%s"",GetName() );; 631 TString lineExpr = TString::Format(""std::function<double(double*,double*)> %s = %s ;"",lambdaName.Data(), lambdaExpression.c_str() );; 632 gInterpreter->ProcessLine(lineExpr);; 633 fLambdaPtr = (void*) gInterpreter->ProcessLine(TString(lambdaName)+TString("";"")); // add ; to avoid printing; 634 if (fLambdaPtr != nullptr) {; 635 R__LOCKGUARD(gROOTMutex);; 636 gClingFunctions.insert ( std::make_pair ( lambdaExpression, fLambdaPtr) );; 637 fClingInitialized = true;; 638 return true;; 639 }; 640 fClingInitialized = false;; 641 return false;; 642}; 643 ; 644///",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:22962,Security,hash,hasher,22962,")) {; 587 Error(""TFormula"",""The name %s is reserved as a TFormula variable name.\n"",formula.GetName());; 588 } else; 589 gROOT->GetListOfFunctions()->Add(this);; 590 }; 591 ; 592}; 593 ; 594////////////////////////////////////////////////////////////////////////////////; 595/// = operator.; 596 ; 597TFormula& TFormula::operator=(const TFormula &rhs); 598{; 599 if (this != &rhs); 600 rhs.TFormula::Copy(*this);; 601 return *this;; 602}; 603 ; 604////////////////////////////////////////////////////////////////////////////////; 605Bool_t TFormula::InitLambdaExpression(const char * formula) {; 606 ; 607 std::string lambdaExpression = formula;; 608 ; 609 // check if formula exist already in the map; 610 {; 611 R__LOCKGUARD(gROOTMutex);; 612 ; 613 auto funcit = gClingFunctions.find(lambdaExpression);; 614 if (funcit != gClingFunctions.end() ) {; 615 fLambdaPtr = funcit->second;; 616 fClingInitialized = true;; 617 return true;; 618 }; 619 }; 620 ; 621 // to be sure the interpreter is initialized; 622 ROOT::GetROOT();; 623 R__ASSERT(gInterpreter);; 624 ; 625 // set the cling name using hash of the static formulae map; 626 auto hasher = gClingFunctions.hash_function();; 627 TString lambdaName = TString::Format(""lambda__id%zu"", hasher(lambdaExpression) );; 628 ; 629 //lambdaExpression = TString::Format(""[&](double * x, double *){ return %s ;}"",formula);; 630 //TString lambdaName = TString::Format(""mylambda_%s"",GetName() );; 631 TString lineExpr = TString::Format(""std::function<double(double*,double*)> %s = %s ;"",lambdaName.Data(), lambdaExpression.c_str() );; 632 gInterpreter->ProcessLine(lineExpr);; 633 fLambdaPtr = (void*) gInterpreter->ProcessLine(TString(lambdaName)+TString("";"")); // add ; to avoid printing; 634 if (fLambdaPtr != nullptr) {; 635 R__LOCKGUARD(gROOTMutex);; 636 gClingFunctions.insert ( std::make_pair ( lambdaExpression, fLambdaPtr) );; 637 fClingInitialized = true;; 638 return true;; 639 }; 640 fClingInitialized = false;; 641 return false;; 642}; 643 ; 644///",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:23063,Security,hash,hasher,23063,"s); 598{; 599 if (this != &rhs); 600 rhs.TFormula::Copy(*this);; 601 return *this;; 602}; 603 ; 604////////////////////////////////////////////////////////////////////////////////; 605Bool_t TFormula::InitLambdaExpression(const char * formula) {; 606 ; 607 std::string lambdaExpression = formula;; 608 ; 609 // check if formula exist already in the map; 610 {; 611 R__LOCKGUARD(gROOTMutex);; 612 ; 613 auto funcit = gClingFunctions.find(lambdaExpression);; 614 if (funcit != gClingFunctions.end() ) {; 615 fLambdaPtr = funcit->second;; 616 fClingInitialized = true;; 617 return true;; 618 }; 619 }; 620 ; 621 // to be sure the interpreter is initialized; 622 ROOT::GetROOT();; 623 R__ASSERT(gInterpreter);; 624 ; 625 // set the cling name using hash of the static formulae map; 626 auto hasher = gClingFunctions.hash_function();; 627 TString lambdaName = TString::Format(""lambda__id%zu"", hasher(lambdaExpression) );; 628 ; 629 //lambdaExpression = TString::Format(""[&](double * x, double *){ return %s ;}"",formula);; 630 //TString lambdaName = TString::Format(""mylambda_%s"",GetName() );; 631 TString lineExpr = TString::Format(""std::function<double(double*,double*)> %s = %s ;"",lambdaName.Data(), lambdaExpression.c_str() );; 632 gInterpreter->ProcessLine(lineExpr);; 633 fLambdaPtr = (void*) gInterpreter->ProcessLine(TString(lambdaName)+TString("";"")); // add ; to avoid printing; 634 if (fLambdaPtr != nullptr) {; 635 R__LOCKGUARD(gROOTMutex);; 636 gClingFunctions.insert ( std::make_pair ( lambdaExpression, fLambdaPtr) );; 637 fClingInitialized = true;; 638 return true;; 639 }; 640 fClingInitialized = false;; 641 return false;; 642}; 643 ; 644////////////////////////////////////////////////////////////////////////////////; 645/// Compile the given expression with Cling; 646/// backward compatibility method to be used in combination with the empty constructor; 647/// if no expression is given , the current stored formula (retrieved with GetExpFormula()) or the title is used.; 648/// return",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:89569,Security,hash,hash,89569,"ectorized ? ""ROOT::Double_v"" : ""Double_t"";; 2309 ; 2310 // valid input formula - try to put into Cling (in case of no variables but only parameter we need to add the standard signature); 2311 TString argumentsPrototype = TString::Format(""%s%s%s"", ( (hasVariables || hasParameters) ? (argType + "" *x"").Data() : """"),; 2312 (hasParameters ? "","" : """"), (hasParameters ? ""Double_t *p"" : """"));; 2313 ; 2314 // set the name for Cling using the hash_function; 2315 fClingName = gNamePrefix;; 2316 ; 2317 // check if formula exist already in the map; 2318 R__LOCKGUARD(gROOTMutex);; 2319 ; 2320 // std::cout << ""gClingFunctions list"" << std::endl;; 2321 // for (auto thing : gClingFunctions); 2322 // std::cout << ""gClingFunctions : "" << thing.first << std::endl;; 2323 ; 2324 auto funcit = gClingFunctions.find(inputFormulaVecFlag);; 2325 ; 2326 if (funcit != gClingFunctions.end()) {; 2327 fFuncPtr = (TFormula::CallFuncSignature)funcit->second;; 2328 fClingInitialized = true;; 2329 inputIntoCling = false;; 2330 }; 2331 ; 2332 ; 2333 ; 2334 // set the cling name using hash of the static formulae map; 2335 auto hasher = gClingFunctions.hash_function();; 2336 fClingName = TString::Format(""%s__id%zu"", gNamePrefix.Data(), hasher(inputFormulaVecFlag));; 2337 ; 2338 fClingInput = TString::Format(""%s %s(%s){ return %s ; }"", argType.Data(), fClingName.Data(),; 2339 argumentsPrototype.Data(), inputFormula.c_str());; 2340 ; 2341 ; 2342 // std::cout << ""Input Formula "" << inputFormula << "" \t vec formula : "" << inputFormulaVecFlag << std::endl;; 2343 // std::cout << ""Cling functions existing "" << std::endl;; 2344 // for (auto & ff : gClingFunctions); 2345 // std::cout << ff.first << std::endl;; 2346 // std::cout << ""\n"";; 2347 // std::cout << fClingName << std::endl;; 2348 ; 2349 // this is not needed (maybe can be re-added in case of recompilation of identical expressions; 2350 // // check in case of a change if need to re-initialize; 2351 // if (fClingInitialized) {; 2352 // if (oldClingInput ==",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:89612,Security,hash,hasher,89612,"ectorized ? ""ROOT::Double_v"" : ""Double_t"";; 2309 ; 2310 // valid input formula - try to put into Cling (in case of no variables but only parameter we need to add the standard signature); 2311 TString argumentsPrototype = TString::Format(""%s%s%s"", ( (hasVariables || hasParameters) ? (argType + "" *x"").Data() : """"),; 2312 (hasParameters ? "","" : """"), (hasParameters ? ""Double_t *p"" : """"));; 2313 ; 2314 // set the name for Cling using the hash_function; 2315 fClingName = gNamePrefix;; 2316 ; 2317 // check if formula exist already in the map; 2318 R__LOCKGUARD(gROOTMutex);; 2319 ; 2320 // std::cout << ""gClingFunctions list"" << std::endl;; 2321 // for (auto thing : gClingFunctions); 2322 // std::cout << ""gClingFunctions : "" << thing.first << std::endl;; 2323 ; 2324 auto funcit = gClingFunctions.find(inputFormulaVecFlag);; 2325 ; 2326 if (funcit != gClingFunctions.end()) {; 2327 fFuncPtr = (TFormula::CallFuncSignature)funcit->second;; 2328 fClingInitialized = true;; 2329 inputIntoCling = false;; 2330 }; 2331 ; 2332 ; 2333 ; 2334 // set the cling name using hash of the static formulae map; 2335 auto hasher = gClingFunctions.hash_function();; 2336 fClingName = TString::Format(""%s__id%zu"", gNamePrefix.Data(), hasher(inputFormulaVecFlag));; 2337 ; 2338 fClingInput = TString::Format(""%s %s(%s){ return %s ; }"", argType.Data(), fClingName.Data(),; 2339 argumentsPrototype.Data(), inputFormula.c_str());; 2340 ; 2341 ; 2342 // std::cout << ""Input Formula "" << inputFormula << "" \t vec formula : "" << inputFormulaVecFlag << std::endl;; 2343 // std::cout << ""Cling functions existing "" << std::endl;; 2344 // for (auto & ff : gClingFunctions); 2345 // std::cout << ff.first << std::endl;; 2346 // std::cout << ""\n"";; 2347 // std::cout << fClingName << std::endl;; 2348 ; 2349 // this is not needed (maybe can be re-added in case of recompilation of identical expressions; 2350 // // check in case of a change if need to re-initialize; 2351 // if (fClingInitialized) {; 2352 // if (oldClingInput ==",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:89722,Security,hash,hasher,89722,"asParameters) ? (argType + "" *x"").Data() : """"),; 2312 (hasParameters ? "","" : """"), (hasParameters ? ""Double_t *p"" : """"));; 2313 ; 2314 // set the name for Cling using the hash_function; 2315 fClingName = gNamePrefix;; 2316 ; 2317 // check if formula exist already in the map; 2318 R__LOCKGUARD(gROOTMutex);; 2319 ; 2320 // std::cout << ""gClingFunctions list"" << std::endl;; 2321 // for (auto thing : gClingFunctions); 2322 // std::cout << ""gClingFunctions : "" << thing.first << std::endl;; 2323 ; 2324 auto funcit = gClingFunctions.find(inputFormulaVecFlag);; 2325 ; 2326 if (funcit != gClingFunctions.end()) {; 2327 fFuncPtr = (TFormula::CallFuncSignature)funcit->second;; 2328 fClingInitialized = true;; 2329 inputIntoCling = false;; 2330 }; 2331 ; 2332 ; 2333 ; 2334 // set the cling name using hash of the static formulae map; 2335 auto hasher = gClingFunctions.hash_function();; 2336 fClingName = TString::Format(""%s__id%zu"", gNamePrefix.Data(), hasher(inputFormulaVecFlag));; 2337 ; 2338 fClingInput = TString::Format(""%s %s(%s){ return %s ; }"", argType.Data(), fClingName.Data(),; 2339 argumentsPrototype.Data(), inputFormula.c_str());; 2340 ; 2341 ; 2342 // std::cout << ""Input Formula "" << inputFormula << "" \t vec formula : "" << inputFormulaVecFlag << std::endl;; 2343 // std::cout << ""Cling functions existing "" << std::endl;; 2344 // for (auto & ff : gClingFunctions); 2345 // std::cout << ff.first << std::endl;; 2346 // std::cout << ""\n"";; 2347 // std::cout << fClingName << std::endl;; 2348 ; 2349 // this is not needed (maybe can be re-added in case of recompilation of identical expressions; 2350 // // check in case of a change if need to re-initialize; 2351 // if (fClingInitialized) {; 2352 // if (oldClingInput == fClingInput); 2353 // inputIntoCling = false;; 2354 // else; 2355 // fClingInitialized = false;; 2356 // }; 2357 ; 2358 if (inputIntoCling) {; 2359 if (!fLazyInitialization) {; 2360 InputFormulaIntoCling();; 2361 if (fClingInitialized) {; 2362 // if Cling has been su",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:101725,Security,hash,hashes,101725,";; 2605 for (Int_t i = 0; i < size; ++i) {; 2606 ; 2607 const TString &vname = vars[i];; 2608 ; 2609 TFormulaVariable &var = fVars[vname];; 2610 if (var.fArrayPos < 0) {; 2611 ; 2612 var.fName = vname;; 2613 var.fArrayPos = fVars.size();; 2614 anyNewVar = true;; 2615 var.fValue = 0;; 2616 if (var.fArrayPos >= (int)fClingVariables.capacity()) {; 2617 Int_t multiplier = 2;; 2618 if (fFuncs.size() > 100) {; 2619 multiplier = TMath::Floor(TMath::Log10(fFuncs.size()) * 10);; 2620 }; 2621 fClingVariables.reserve(multiplier * fClingVariables.capacity());; 2622 }; 2623 fClingVariables.push_back(0.0);; 2624 }; 2625 // else; 2626 // {; 2627 // var.fValue = v.second;; 2628 // fClingVariables[var.fArrayPos] = v.second;; 2629 // }; 2630 }; 2631 if (anyNewVar && !fFormula.IsNull()) {; 2632 ProcessFormula(fClingInput);; 2633 }; 2634}; 2635 ; 2636////////////////////////////////////////////////////////////////////////////////; 2637/// Set the name of the formula. We need to allow the list of function to; 2638/// properly handle the hashes.; 2639 ; 2640void TFormula::SetName(const char* name); 2641{; 2642 if (IsReservedName(name)) {; 2643 Error(""SetName"", ""The name \'%s\' is reserved as a TFormula variable name.\n""; 2644 ""\tThis function will not be renamed."",; 2645 name);; 2646 } else {; 2647 // Here we need to remove and re-add to keep the hashes consistent with; 2648 // the underlying names.; 2649 auto listOfFunctions = gROOT->GetListOfFunctions();; 2650 TObject* thisAsFunctionInList = nullptr;; 2651 R__LOCKGUARD(gROOTMutex);; 2652 if (listOfFunctions){; 2653 thisAsFunctionInList = listOfFunctions->FindObject(this);; 2654 if (thisAsFunctionInList) listOfFunctions->Remove(thisAsFunctionInList);; 2655 }; 2656 TNamed::SetName(name);; 2657 if (thisAsFunctionInList) listOfFunctions->Add(thisAsFunctionInList);; 2658 }; 2659}; 2660 ; 2661////////////////////////////////////////////////////////////////////////////////; 2662///; 2663/// Sets multiple variables.; 2664/// First argument is ",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:102040,Security,hash,hashes,102040,"s.capacity()) {; 2617 Int_t multiplier = 2;; 2618 if (fFuncs.size() > 100) {; 2619 multiplier = TMath::Floor(TMath::Log10(fFuncs.size()) * 10);; 2620 }; 2621 fClingVariables.reserve(multiplier * fClingVariables.capacity());; 2622 }; 2623 fClingVariables.push_back(0.0);; 2624 }; 2625 // else; 2626 // {; 2627 // var.fValue = v.second;; 2628 // fClingVariables[var.fArrayPos] = v.second;; 2629 // }; 2630 }; 2631 if (anyNewVar && !fFormula.IsNull()) {; 2632 ProcessFormula(fClingInput);; 2633 }; 2634}; 2635 ; 2636////////////////////////////////////////////////////////////////////////////////; 2637/// Set the name of the formula. We need to allow the list of function to; 2638/// properly handle the hashes.; 2639 ; 2640void TFormula::SetName(const char* name); 2641{; 2642 if (IsReservedName(name)) {; 2643 Error(""SetName"", ""The name \'%s\' is reserved as a TFormula variable name.\n""; 2644 ""\tThis function will not be renamed."",; 2645 name);; 2646 } else {; 2647 // Here we need to remove and re-add to keep the hashes consistent with; 2648 // the underlying names.; 2649 auto listOfFunctions = gROOT->GetListOfFunctions();; 2650 TObject* thisAsFunctionInList = nullptr;; 2651 R__LOCKGUARD(gROOTMutex);; 2652 if (listOfFunctions){; 2653 thisAsFunctionInList = listOfFunctions->FindObject(this);; 2654 if (thisAsFunctionInList) listOfFunctions->Remove(thisAsFunctionInList);; 2655 }; 2656 TNamed::SetName(name);; 2657 if (thisAsFunctionInList) listOfFunctions->Add(thisAsFunctionInList);; 2658 }; 2659}; 2660 ; 2661////////////////////////////////////////////////////////////////////////////////; 2662///; 2663/// Sets multiple variables.; 2664/// First argument is an array of pairs<TString,Double>, where; 2665/// first argument is name of variable,; 2666/// second argument represents value.; 2667/// size - number of variables passed in first argument; 2668 ; 2669void TFormula::SetVariables(const pair<TString,Double_t> *vars, const Int_t size); 2670{; 2671 for(Int_t i = 0; i < size; ++i); 2",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:121950,Security,hash,hasher,121950,"177 } else {; 3178 // __attribute__((used)) extern ""C"" void __cf_0(void* obj, int nargs, void** args, void* ret); 3179 // {; 3180 // ((void (&)(double*, double*, double*))TFormula____id_grad_1)(*(double**)args[0],; 3181 // *(double**)args[1],; 3182 // *(double**)args[2]);; 3183 // return;; 3184 // }; 3185 args[1] = &pars;; 3186 args[2] = &result;; 3187 (*FuncPtr)(nullptr, 3, args, /*ret*/nullptr); // We do not use ret in a return-void func.; 3188 }; 3189}; 3190 ; 3191/// returns true on success.; 3192bool TFormula::GenerateGradientPar() {; 3193 // We already have generated the gradient.; 3194 if (fGradFuncPtr); 3195 return true;; 3196 ; 3197 if (HasGradientGenerationFailed()); 3198 return false;; 3199 ; 3200 IncludeCladRuntime(fIsCladRuntimeIncluded);; 3201 ; 3202 // Check if the gradient request was made as part of another TFormula.; 3203 // This can happen when we create multiple TFormula objects with the same; 3204 // formula. In that case, the hasher will give identical id and we can; 3205 // reuse the already generated gradient function.; 3206 if (!functionExists(GetGradientFuncName())) {; 3207 std::string GradientCall; 3208 (""clad::gradient("" + std::string(fClingName.Data()) + "", \""p\"");"");; 3209 if (!DeclareGenerationInput(GetGradientFuncName(),; 3210 GradientCall,; 3211 fGradGenerationInput)); 3212 return false;; 3213 }; 3214 ; 3215 fGradFuncPtr = GetFuncPtr(GetGradientFuncName(), fNpar, fNdim, fVectorized);; 3216 return true;; 3217}; 3218 ; 3219// Compute the gradient with respect to the parameter passing; 3220/// a CladStorageObject, i.e. a std::vector, which has the size as the nnumber of parameters.; 3221/// Note that the result buffer needs to be initialized to zero before passing it to this function.; 3222void TFormula::GradientPar(const Double_t *x, TFormula::CladStorage& result); 3223{; 3224 if (DoEval(x) == TMath::QuietNaN()); 3225 return;; 3226 ; 3227 if (!fClingInitialized) {; 3228 Error(""GradientPar"", ""Could not initialize the formula!"");; 3229 re",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:124464,Security,hash,hasher,124464,"3247/// a buffer with a size at least equal to the number of parameters.; 3248/// Note that the result buffer needs to be initialized to zero before passed to this function.; 3249void TFormula::GradientPar(const Double_t *x, Double_t *result) {; 3250 const Double_t *vars = (x) ? x : fClingVariables.data();; 3251 const Double_t *pars = (fNpar <= 0) ? nullptr : fClingParameters.data();; 3252 CallCladFunction(fGradFuncPtr, vars, pars, result, fNpar);; 3253}; 3254 ; 3255/// returns true on success.; 3256bool TFormula::GenerateHessianPar(); 3257{; 3258 // We already have generated the hessian.; 3259 if (fHessFuncPtr); 3260 return true;; 3261 ; 3262 if (HasHessianGenerationFailed()); 3263 return false;; 3264 ; 3265 IncludeCladRuntime(fIsCladRuntimeIncluded);; 3266 ; 3267 // Check if the hessian request was made as part of another TFormula.; 3268 // This can happen when we create multiple TFormula objects with the same; 3269 // formula. In that case, the hasher will give identical id and we can; 3270 // reuse the already generated hessian function.; 3271 if (!functionExists(GetHessianFuncName())) {; 3272 std::string indexes = (fNpar - 1 == 0) ? ""0"" : std::string(""0:""); 3273 + std::to_string(fNpar - 1);; 3274 std::string HessianCall; 3275 (""clad::hessian("" + std::string(fClingName.Data()) + "", \""p[""; 3276 + indexes + ""]\"" );"");; 3277 if (!DeclareGenerationInput(GetHessianFuncName(), HessianCall,; 3278 fHessGenerationInput)); 3279 return false;; 3280 }; 3281 ; 3282 fHessFuncPtr = GetFuncPtr(GetHessianFuncName(), fNpar, fNdim, fVectorized);; 3283 return true;; 3284}; 3285 ; 3286void TFormula::HessianPar(const Double_t *x, TFormula::CladStorage& result); 3287{; 3288 if (DoEval(x) == TMath::QuietNaN()); 3289 return;; 3290 ; 3291 if (!fClingInitialized) {; 3292 Error(""HessianPar"", ""Could not initialize the formula!"");; 3293 return;; 3294 }; 3295 ; 3296 if (!GenerateHessianPar()) {; 3297 Error(""HessianPar"", ""Could not generate a hessian for the formula %s!"",; 3298 fClingName.Data",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:20554,Testability,assert,assert,20554,"510 TFormula *old = nullptr;; 511 R__LOCKGUARD(gROOTMutex);; 512 old = dynamic_cast<TFormula *>(gROOT->GetListOfFunctions()->FindObject(name));; 513 if (old); 514 gROOT->GetListOfFunctions()->Remove(old);; 515 if (IsReservedName(name)); 516 Error(""TFormula"", ""The name %s is reserved as a TFormula variable name.\n"", name);; 517 else; 518 gROOT->GetListOfFunctions()->Add(this);; 519 }; 520 SetBit(kNotGlobal,!addToGlobList);; 521 }; 522 }; 523}; 524 ; 525////////////////////////////////////////////////////////////////////////////////; 526/// Constructor from a full compile-able C++ expression; 527 ; 528TFormula::TFormula(const char *name, const char *formula, int ndim, int npar, bool addToGlobList) :; 529 TNamed(name,formula),; 530 fClingInput(formula),fFormula(formula); 531{; 532 fReadyToExecute = false;; 533 fClingInitialized = false;; 534 fNpar = 0;; 535 fNumber = 0;; 536 fLambdaPtr = nullptr;; 537 fFuncPtr = nullptr;; 538 fGradFuncPtr = nullptr;; 539 fHessFuncPtr = nullptr;; 540 ; 541 ; 542 fNdim = ndim;; 543 for (int i = 0; i < npar; ++i) {; 544 DoAddParameter(TString::Format(""p%d"",i), 0, false);; 545 }; 546 fAllParametersSetted = true;; 547 assert (fNpar == npar);; 548 ; 549 bool ret = InitLambdaExpression(formula);; 550 ; 551 if (ret) {; 552 ; 553 SetBit(TFormula::kLambda);; 554 ; 555 fReadyToExecute = true;; 556 ; 557 if (addToGlobList && gROOT) {; 558 TFormula *old = nullptr;; 559 R__LOCKGUARD(gROOTMutex);; 560 old = dynamic_cast<TFormula*> ( gROOT->GetListOfFunctions()->FindObject(name) );; 561 if (old); 562 gROOT->GetListOfFunctions()->Remove(old);; 563 if (IsReservedName(name)); 564 Error(""TFormula"",""The name %s is reserved as a TFormula variable name.\n"",name);; 565 else; 566 gROOT->GetListOfFunctions()->Add(this);; 567 }; 568 SetBit(kNotGlobal,!addToGlobList);; 569 }; 570 else; 571 Error(""TFormula"",""Syntax error in building the lambda expression %s"", formula );; 572}; 573 ; 574////////////////////////////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:32923,Testability,log,loge,32923,"parsing += fClingInput + ""\n}"";; 886 gCling->ProcessLine(triggerAutoparsing);; 887 ; 888 // add pragma for optimization of the formula; 889 fClingInput = TString(""#pragma cling optimize(2)\n"") + fClingInput;; 890 ; 891 // Now that all libraries and headers are loaded, Declare() a performant version; 892 // of the same code:; 893 gCling->Declare(fClingInput);; 894 fClingInitialized = PrepareEvalMethod();; 895 if (!fClingInitialized) Error(""InputFormulaIntoCling"",""Error compiling formula expression in Cling"");; 896 }; 897}; 898 ; 899////////////////////////////////////////////////////////////////////////////////; 900/// Fill structures with default variables, constants and function shortcuts; 901 ; 902void TFormula::FillDefaults(); 903{; 904 const TString defvars[] = { ""x"",""y"",""z"",""t""};; 905 const pair<TString, Double_t> defconsts[] = {{""pi"", TMath::Pi()},; 906 {""sqrt2"", TMath::Sqrt2()},; 907 {""infinity"", TMath::Infinity()},; 908 {""e"", TMath::E()},; 909 {""ln10"", TMath::Ln10()},; 910 {""loge"", TMath::LogE()},; 911 {""c"", TMath::C()},; 912 {""g"", TMath::G()},; 913 {""h"", TMath::H()},; 914 {""k"", TMath::K()},; 915 {""sigma"", TMath::Sigma()},; 916 {""r"", TMath::R()},; 917 {""eg"", TMath::EulerGamma()},; 918 {""true"", 1},; 919 {""false"", 0}};; 920 // const pair<TString,Double_t> defconsts[] = { {""pi"",TMath::Pi()}, {""sqrt2"",TMath::Sqrt2()},; 921 // {""infinity"",TMath::Infinity()}, {""ln10"",TMath::Ln10()},; 922 // {""loge"",TMath::LogE()}, {""true"",1},{""false"",0} };; 923 const pair<TString,TString> funShortcuts[] =; 924 { {""sin"",""TMath::Sin"" },; 925 {""cos"",""TMath::Cos"" }, {""exp"",""TMath::Exp""}, {""log"",""TMath::Log""}, {""log10"",""TMath::Log10""},; 926 {""tan"",""TMath::Tan""}, {""sinh"",""TMath::SinH""}, {""cosh"",""TMath::CosH""},; 927 {""tanh"",""TMath::TanH""}, {""asin"",""TMath::ASin""}, {""acos"",""TMath::ACos""},; 928 {""atan"",""TMath::ATan""}, {""atan2"",""TMath::ATan2""}, {""sqrt"",""TMath::Sqrt""},; 929 {""ceil"",""TMath::Ceil""}, {""floor"",""TMath::Floor""}, {""pow"",""TMath::Power""},; 930 {""binomial"",""TMath::Binomial""},{""abs"",""TMa",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:33343,Testability,log,loge,33343," of the same code:; 893 gCling->Declare(fClingInput);; 894 fClingInitialized = PrepareEvalMethod();; 895 if (!fClingInitialized) Error(""InputFormulaIntoCling"",""Error compiling formula expression in Cling"");; 896 }; 897}; 898 ; 899////////////////////////////////////////////////////////////////////////////////; 900/// Fill structures with default variables, constants and function shortcuts; 901 ; 902void TFormula::FillDefaults(); 903{; 904 const TString defvars[] = { ""x"",""y"",""z"",""t""};; 905 const pair<TString, Double_t> defconsts[] = {{""pi"", TMath::Pi()},; 906 {""sqrt2"", TMath::Sqrt2()},; 907 {""infinity"", TMath::Infinity()},; 908 {""e"", TMath::E()},; 909 {""ln10"", TMath::Ln10()},; 910 {""loge"", TMath::LogE()},; 911 {""c"", TMath::C()},; 912 {""g"", TMath::G()},; 913 {""h"", TMath::H()},; 914 {""k"", TMath::K()},; 915 {""sigma"", TMath::Sigma()},; 916 {""r"", TMath::R()},; 917 {""eg"", TMath::EulerGamma()},; 918 {""true"", 1},; 919 {""false"", 0}};; 920 // const pair<TString,Double_t> defconsts[] = { {""pi"",TMath::Pi()}, {""sqrt2"",TMath::Sqrt2()},; 921 // {""infinity"",TMath::Infinity()}, {""ln10"",TMath::Ln10()},; 922 // {""loge"",TMath::LogE()}, {""true"",1},{""false"",0} };; 923 const pair<TString,TString> funShortcuts[] =; 924 { {""sin"",""TMath::Sin"" },; 925 {""cos"",""TMath::Cos"" }, {""exp"",""TMath::Exp""}, {""log"",""TMath::Log""}, {""log10"",""TMath::Log10""},; 926 {""tan"",""TMath::Tan""}, {""sinh"",""TMath::SinH""}, {""cosh"",""TMath::CosH""},; 927 {""tanh"",""TMath::TanH""}, {""asin"",""TMath::ASin""}, {""acos"",""TMath::ACos""},; 928 {""atan"",""TMath::ATan""}, {""atan2"",""TMath::ATan2""}, {""sqrt"",""TMath::Sqrt""},; 929 {""ceil"",""TMath::Ceil""}, {""floor"",""TMath::Floor""}, {""pow"",""TMath::Power""},; 930 {""binomial"",""TMath::Binomial""},{""abs"",""TMath::Abs""},; 931 {""min"",""TMath::Min""},{""max"",""TMath::Max""},{""sign"",""TMath::Sign"" },; 932 {""sq"",""TMath::Sq""}; 933 };; 934 ; 935 std::vector<TString> defvars2(10);; 936 for (int i = 0; i < 9; ++i); 937 defvars2[i] = TString::Format(""x[%d]"",i);; 938 ; 939 for (const auto &var : defvars) {; 940 int pos = fVars.",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:33523,Testability,log,log,33523," of the same code:; 893 gCling->Declare(fClingInput);; 894 fClingInitialized = PrepareEvalMethod();; 895 if (!fClingInitialized) Error(""InputFormulaIntoCling"",""Error compiling formula expression in Cling"");; 896 }; 897}; 898 ; 899////////////////////////////////////////////////////////////////////////////////; 900/// Fill structures with default variables, constants and function shortcuts; 901 ; 902void TFormula::FillDefaults(); 903{; 904 const TString defvars[] = { ""x"",""y"",""z"",""t""};; 905 const pair<TString, Double_t> defconsts[] = {{""pi"", TMath::Pi()},; 906 {""sqrt2"", TMath::Sqrt2()},; 907 {""infinity"", TMath::Infinity()},; 908 {""e"", TMath::E()},; 909 {""ln10"", TMath::Ln10()},; 910 {""loge"", TMath::LogE()},; 911 {""c"", TMath::C()},; 912 {""g"", TMath::G()},; 913 {""h"", TMath::H()},; 914 {""k"", TMath::K()},; 915 {""sigma"", TMath::Sigma()},; 916 {""r"", TMath::R()},; 917 {""eg"", TMath::EulerGamma()},; 918 {""true"", 1},; 919 {""false"", 0}};; 920 // const pair<TString,Double_t> defconsts[] = { {""pi"",TMath::Pi()}, {""sqrt2"",TMath::Sqrt2()},; 921 // {""infinity"",TMath::Infinity()}, {""ln10"",TMath::Ln10()},; 922 // {""loge"",TMath::LogE()}, {""true"",1},{""false"",0} };; 923 const pair<TString,TString> funShortcuts[] =; 924 { {""sin"",""TMath::Sin"" },; 925 {""cos"",""TMath::Cos"" }, {""exp"",""TMath::Exp""}, {""log"",""TMath::Log""}, {""log10"",""TMath::Log10""},; 926 {""tan"",""TMath::Tan""}, {""sinh"",""TMath::SinH""}, {""cosh"",""TMath::CosH""},; 927 {""tanh"",""TMath::TanH""}, {""asin"",""TMath::ASin""}, {""acos"",""TMath::ACos""},; 928 {""atan"",""TMath::ATan""}, {""atan2"",""TMath::ATan2""}, {""sqrt"",""TMath::Sqrt""},; 929 {""ceil"",""TMath::Ceil""}, {""floor"",""TMath::Floor""}, {""pow"",""TMath::Power""},; 930 {""binomial"",""TMath::Binomial""},{""abs"",""TMath::Abs""},; 931 {""min"",""TMath::Min""},{""max"",""TMath::Max""},{""sign"",""TMath::Sign"" },; 932 {""sq"",""TMath::Sq""}; 933 };; 934 ; 935 std::vector<TString> defvars2(10);; 936 for (int i = 0; i < 9; ++i); 937 defvars2[i] = TString::Format(""x[%d]"",i);; 938 ; 939 for (const auto &var : defvars) {; 940 int pos = fVars.",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:35403,Testability,log,log,35403,"ariable(xvar,0,i);; 950 // fClingVariables.push_back(0);; 951 // }; 952 ; 953 for (auto con : defconsts) {; 954 fConsts[con.first] = con.second;; 955 }; 956 if (fVectorized) {; 957 FillVecFunctionsShurtCuts();; 958 } else {; 959 for (auto fun : funShortcuts) {; 960 fFunctionsShortcuts[fun.first] = fun.second;; 961 }; 962 }; 963}; 964 ; 965////////////////////////////////////////////////////////////////////////////////; 966/// Fill the shortcuts for vectorized functions; 967/// We will replace for example sin with vecCore::Mat::Sin; 968///; 969 ; 970void TFormula::FillVecFunctionsShurtCuts() {; 971#ifdef R__HAS_VECCORE; 972 const pair<TString,TString> vecFunShortcuts[] =; 973 { {""sin"",""vecCore::math::Sin"" },; 974 {""cos"",""vecCore::math::Cos"" }, {""exp"",""vecCore::math::Exp""}, {""log"",""vecCore::math::Log""}, {""log10"",""vecCore::math::Log10""},; 975 {""tan"",""vecCore::math::Tan""},; 976 //{""sinh"",""vecCore::math::Sinh""}, {""cosh"",""vecCore::math::Cosh""},{""tanh"",""vecCore::math::Tanh""},; 977 {""asin"",""vecCore::math::ASin""},; 978 {""acos"",""TMath::Pi()/2-vecCore::math::ASin""},; 979 {""atan"",""vecCore::math::ATan""},; 980 {""atan2"",""vecCore::math::ATan2""}, {""sqrt"",""vecCore::math::Sqrt""},; 981 {""ceil"",""vecCore::math::Ceil""}, {""floor"",""vecCore::math::Floor""}, {""pow"",""vecCore::math::Pow""},; 982 {""cbrt"",""vecCore::math::Cbrt""},{""abs"",""vecCore::math::Abs""},; 983 {""min"",""vecCore::math::Min""},{""max"",""vecCore::math::Max""},{""sign"",""vecCore::math::Sign"" }; 984 //{""sq"",""TMath::Sq""}, {""binomial"",""TMath::Binomial""} // this last two functions will not work in vectorized mode; 985 };; 986 // replace in the data member maps fFunctionsShortcuts; 987 for (auto fun : vecFunShortcuts) {; 988 fFunctionsShortcuts[fun.first] = fun.second;; 989 }; 990#endif; 991 // do nothing in case Veccore is not enabled; 992}; 993 ; 994 ; 995////////////////////////////////////////////////////////////////////////////////; 996/// Handling polN; 997/// If before 'pol' exist any name, this name will be treated as variable used in pol",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:42797,Testability,assert,assert,42797,"l(""zexpo"",""expo[z]"");; 1125 formula.ReplaceAll(""xylandau"",""landau[x,y]"");; 1126 formula.ReplaceAll(""xyexpo"",""expo[x,y]"");; 1127 // at the moment pre-defined functions have no more than 3 dimensions; 1128 const char * defaultVariableNames[] = { ""x"",""y"",""z""};; 1129 ; 1130 for (map<pair<TString, Int_t>, pair<TString, TString>>::iterator it = functions.begin(); it != functions.end();; 1131 ++it) {; 1132 ; 1133 TString funName = it->first.first;; 1134 Int_t funDim = it->first.second;; 1135 Int_t funPos = formula.Index(funName);; 1136 ; 1137 // std::cout << formula << "" ---- "" << funName << "" "" << funPos << std::endl;; 1138 while (funPos != kNPOS && !IsAParameterName(formula, funPos)) {; 1139 ; 1140 // should also check that function is not something else (e.g. exponential - parse the expo); 1141 Int_t lastFunPos = funPos + funName.Length();; 1142 ; 1143 // check that first and last character is not a special character; 1144 Int_t iposBefore = funPos - 1;; 1145 // std::cout << ""looping on funpos is "" << funPos << "" formula is "" << formula << "" function "" << funName <<; 1146 // std::endl;; 1147 if (iposBefore >= 0) {; 1148 assert(iposBefore < formula.Length());; 1149 //if (isalpha(formula[iposBefore])) {; 1150 if (IsFunctionNameChar(formula[iposBefore])) {; 1151 // std::cout << ""previous character for function "" << funName << "" is "" << formula[iposBefore] << ""- skip; 1152 // "" << std::endl;; 1153 funPos = formula.Index(funName, lastFunPos);; 1154 continue;; 1155 }; 1156 }; 1157 ; 1158 Bool_t isNormalized = false;; 1159 if (lastFunPos < formula.Length()) {; 1160 // check if function is normalized by looking at ""n"" character after function name (e.g. gausn); 1161 isNormalized = (formula[lastFunPos] == 'n');; 1162 if (isNormalized); 1163 lastFunPos += 1;; 1164 if (lastFunPos < formula.Length()) {; 1165 char c = formula[lastFunPos];; 1166 // check if also last character is not alphanumeric or is not an operator and not a parenthesis ( or [.; 1167 // Parenthesis [] are used to ",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:63025,Testability,assert,assert,63025,"ated like 2^(3^4); 1634 ; 1635void TFormula::HandleExponentiation(TString &formula); 1636{; 1637 Int_t caretPos = formula.Last('^');; 1638 while (caretPos != kNPOS && !IsAParameterName(formula, caretPos)) {; 1639 ; 1640 TString right, left;; 1641 Int_t temp = caretPos;; 1642 temp--;; 1643 // get the expression in ( ) which has the operator^ applied; 1644 if (formula[temp] == ')') {; 1645 Int_t depth = 1;; 1646 temp--;; 1647 while (depth != 0 && temp > 0) {; 1648 if (formula[temp] == ')'); 1649 depth++;; 1650 if (formula[temp] == '('); 1651 depth--;; 1652 temp--;; 1653 }; 1654 if (depth == 0); 1655 temp++;; 1656 }; 1657 // this in case of someting like sin(x+2)^2; 1658 do {; 1659 temp--; // go down one; 1660 // handle scientific notation cases (1.e-2 ^ 3 ); 1661 if (temp >= 2 && IsScientificNotation(formula, temp - 1)); 1662 temp -= 3;; 1663 } while (temp >= 0 && !IsOperator(formula[temp]) && !IsBracket(formula[temp]));; 1664 ; 1665 assert(temp + 1 >= 0);; 1666 Int_t leftPos = temp + 1;; 1667 left = formula(leftPos, caretPos - leftPos);; 1668 // std::cout << ""left to replace is "" << left << std::endl;; 1669 ; 1670 // look now at the expression after the ^ operator; 1671 temp = caretPos;; 1672 temp++;; 1673 if (temp >= formula.Length()) {; 1674 Error(""HandleExponentiation"", ""Invalid position of operator ^"");; 1675 return;; 1676 }; 1677 if (formula[temp] == '(') {; 1678 Int_t depth = 1;; 1679 temp++;; 1680 while (depth != 0 && temp < formula.Length()) {; 1681 if (formula[temp] == ')'); 1682 depth--;; 1683 if (formula[temp] == '('); 1684 depth++;; 1685 temp++;; 1686 }; 1687 temp--;; 1688 } else {; 1689 // handle case first character is operator - or + continue; 1690 if (formula[temp] == '-' || formula[temp] == '+'); 1691 temp++;; 1692 // handle cases x^-2 or x^+2; 1693 // need to handle also cases x^sin(x+y); 1694 Int_t depth = 0;; 1695 // stop right expression if is an operator or if is a "")"" from a zero depth; 1696 while (temp < formula.Length() && ((depth > 0) || !IsO",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:76842,Testability,assert,assert,76842," if parameters are existing; 1999 std::vector<TString> newNames;; 2000 if (fNpar > 0) {; 2001 nparOffset = fNpar;; 2002 newNames.resize(f->GetNpar());; 2003 // start from higher number to avoid overlap; 2004 for (int jpar = f->GetNpar() - 1; jpar >= 0; --jpar) {; 2005 // parameters name have a ""p"" added in front; 2006 TString pj = TString(f->GetParName(jpar));; 2007 if (pj[0] == 'p' && TString(pj(1, pj.Length())).IsDigit()) {; 2008 TString oldName = TString::Format(""[%s]"", f->GetParName(jpar));; 2009 TString newName = TString::Format(""[p%d]"", nparOffset + jpar);; 2010 // std::cout << ""replace - parameter "" << f->GetParName(jpar) << "" with "" << newName <<; 2011 // std::endl;; 2012 replacementFormula.ReplaceAll(oldName, newName);; 2013 newNames[jpar] = newName;; 2014 } else; 2015 newNames[jpar] = f->GetParName(jpar);; 2016 }; 2017 // std::cout << ""after replacing params "" << replacementFormula << std::endl;; 2018 }; 2019 ExtractFunctors(replacementFormula);; 2020 // std::cout << ""after re-extracting functors "" << replacementFormula << std::endl;; 2021 ; 2022 // set parameter value from replacement formula; 2023 for (int jpar = 0; jpar < f->GetNpar(); ++jpar) {; 2024 if (nparOffset > 0) {; 2025 // parameter have an offset- so take this into account; 2026 assert((int)newNames.size() == f->GetNpar());; 2027 SetParameter(newNames[jpar], f->GetParameter(jpar));; 2028 } else; 2029 // names are the same between current formula and replaced one; 2030 SetParameter(f->GetParName(jpar), f->GetParameter(jpar));; 2031 }; 2032 // need to add parenthesis at begin and end of replacementFormula; 2033 replacementFormula.Insert(0, '(');; 2034 replacementFormula.Insert(replacementFormula.Length(), ')');; 2035 formula.Replace(i - name.Length(), name.Length(), replacementFormula, replacementFormula.Length());; 2036 // move forward the index i of the main loop; 2037 i += replacementFormula.Length() - name.Length();; 2038 ; 2039 // we have extracted all the functor for ""fname""; 2040 // std::c",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:81454,Testability,assert,assert,81454,"dex - 1]) || formula[index - 1] == ':')) {; 2103 index = formula.Index(shortcut, i2);; 2104 continue;; 2105 }; 2106 if (i2 < formula.Length() && formula[i2] != '(') {; 2107 index = formula.Index(shortcut, i2);; 2108 continue;; 2109 }; 2110 // now replace the string; 2111 formula.Replace(index, shortcut.Length(), full);; 2112 Ssiz_t inext = index + full.Length();; 2113 index = formula.Index(shortcut, inext);; 2114 fun.fFound = true;; 2115 }; 2116 }; 2117 // for functions we can live it to cling to decide if it is a valid function or NOT; 2118 // We don't need to retrieve this information from the ROOT interpreter; 2119 // we assume that the function is then found and all the following code does not need to be there; 2120#ifdef TFORMULA_CHECK_FUNCTIONS; 2121 ; 2122 if (fun.fName.Contains(""::"")) // add support for nested namespaces; 2123 {; 2124 // look for last occurence of ""::""; 2125 std::string name(fun.fName.Data());; 2126 size_t index = name.rfind(""::"");; 2127 assert(index != std::string::npos);; 2128 TString className = fun.fName(0, fun.fName(0, index).Length());; 2129 TString functionName = fun.fName(index + 2, fun.fName.Length());; 2130 ; 2131 Bool_t silent = true;; 2132 TClass *tclass = TClass::GetClass(className, silent);; 2133 // std::cout << ""looking for class "" << className << std::endl;; 2134 const TList *methodList = tclass->GetListOfAllPublicMethods();; 2135 TIter next(methodList);; 2136 TMethod *p;; 2137 while ((p = (TMethod *)next())) {; 2138 if (strcmp(p->GetName(), functionName.Data()) == 0 &&; 2139 (fun.GetNargs() <= p->GetNargs() && fun.GetNargs() >= p->GetNargs() - p->GetNargsOpt())) {; 2140 fun.fFound = true;; 2141 break;; 2142 }; 2143 }; 2144 }; 2145 if (!fun.fFound) {; 2146 // try to look into all the global functions in gROOT; 2147 TFunction *f;; 2148 {; 2149 R__LOCKGUARD(gROOTMutex);; 2150 f = (TFunction *)gROOT->GetListOfGlobalFunctions(true)->FindObject(fun.fName);; 2151 }; 2152 // if found a function with matching arguments; 2153 if (f && ",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:83133,Testability,assert,assert,83133,") - p->GetNargsOpt())) {; 2140 fun.fFound = true;; 2141 break;; 2142 }; 2143 }; 2144 }; 2145 if (!fun.fFound) {; 2146 // try to look into all the global functions in gROOT; 2147 TFunction *f;; 2148 {; 2149 R__LOCKGUARD(gROOTMutex);; 2150 f = (TFunction *)gROOT->GetListOfGlobalFunctions(true)->FindObject(fun.fName);; 2151 }; 2152 // if found a function with matching arguments; 2153 if (f && fun.GetNargs() <= f->GetNargs() && fun.GetNargs() >= f->GetNargs() - f->GetNargsOpt()) {; 2154 fun.fFound = true;; 2155 }; 2156 }; 2157 ; 2158 if (!fun.fFound) {; 2159 // ignore not found functions; 2160 if (gDebug); 2161 Info(""TFormula"", ""Could not find %s function with %d argument(s)"", fun.GetName(), fun.GetNargs());; 2162 fun.fFound = false;; 2163 }; 2164#endif; 2165 } else {; 2166 TFormula *old = nullptr;; 2167 {; 2168 R__LOCKGUARD(gROOTMutex);; 2169 old = (TFormula *)gROOT->GetListOfFunctions()->FindObject(gNamePrefix + fun.fName);; 2170 }; 2171 if (old) {; 2172 // we should not go here (this analysis is done before in ExtractFunctors); 2173 assert(false);; 2174 fun.fFound = true;; 2175 TString pattern = TString::Format(""{%s}"", fun.GetName());; 2176 TString replacement = old->GetExpFormula();; 2177 PreProcessFormula(replacement);; 2178 ExtractFunctors(replacement);; 2179 formula.ReplaceAll(pattern, replacement);; 2180 continue;; 2181 }; 2182 // looking for default variables defined in fVars; 2183 ; 2184 map<TString, TFormulaVariable>::iterator varsIt = fVars.find(fun.GetName());; 2185 if (varsIt != fVars.end()) {; 2186 ; 2187 TString name = (*varsIt).second.GetName();; 2188 Double_t value = (*varsIt).second.fValue;; 2189 ; 2190 AddVariable(name, value); // this set the cling variable; 2191 if (!fVars[name].fFound) {; 2192 ; 2193 fVars[name].fFound = true;; 2194 int varDim = (*varsIt).second.fArrayPos; // variable dimensions (0 for x, 1 for y, 2, for z); 2195 if (varDim >= fNdim) {; 2196 fNdim = varDim + 1;; 2197 ; 2198 // we need to be sure that all other variables are added w",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:114222,Testability,assert,assert,114222,"name = TString::Format(""%d"", i);; 2957 SetParameter(name, params[i]);; 2958 }; 2959 return;; 2960 }; 2961 fAllParametersSetted = true;; 2962 std::copy(params, params+size, fClingParameters.begin() );; 2963}; 2964 ; 2965////////////////////////////////////////////////////////////////////////////////; 2966/// Set a vector of parameters value.; 2967/// Order in the vector is by default the alphabetic order given to the parameters; 2968/// apart if the users has defined explicitly the parameter names; 2969 ; 2970void TFormula::SetParameters(const Double_t *params); 2971{; 2972 DoSetParameters(params,fNpar);; 2973}; 2974 ; 2975////////////////////////////////////////////////////////////////////////////////; 2976/// Set a parameter given a parameter index.; 2977/// The parameter index is by default the alphabetic order given to the parameters,; 2978/// apart if the users has defined explicitly the parameter names.; 2979 ; 2980void TFormula::SetParameter(Int_t param, Double_t value); 2981{; 2982 if (param < 0 || param >= fNpar) return;; 2983 assert(int(fClingParameters.size()) == fNpar);; 2984 fClingParameters[param] = value;; 2985 // TString name = TString::Format(""%d"",param);; 2986 // SetParameter(name,value);; 2987}; 2988 ; 2989////////////////////////////////////////////////////////////////////////////////; 2990void TFormula::SetParName(Int_t ipar, const char * name); 2991{; 2992 ; 2993 if (ipar < 0 || ipar > fNpar) {; 2994 Error(""SetParName"",""Wrong Parameter index %d "",ipar);; 2995 return;; 2996 }; 2997 TString oldName;; 2998 // find parameter with given index; 2999 for ( auto &it : fParams) {; 3000 if (it.second == ipar) {; 3001 oldName = it.first;; 3002 fParams.erase(oldName);; 3003 fParams.insert(std::make_pair(name, ipar) );; 3004 break;; 3005 }; 3006 }; 3007 if (oldName.IsNull() ) {; 3008 Error(""SetParName"",""Parameter %d is not existing."",ipar);; 3009 return;; 3010 }; 3011 ; 3012 //replace also parameter name in formula expression in case is not a lambda; 3013 if",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:128995,Testability,assert,assert,128995,"s shown.; 3358 ; 3359Double_t TFormula::DoEval(const double * x, const double * params) const; 3360{; 3361 if(!fReadyToExecute); 3362 {; 3363 Error(""Eval"", ""Formula is invalid and not ready to execute "");; 3364 for (auto it = fFuncs.begin(); it != fFuncs.end(); ++it) {; 3365 TFormulaFunction fun = *it;; 3366 if (!fun.fFound) {; 3367 printf(""%s is unknown.\n"", fun.GetName());; 3368 }; 3369 }; 3370 return TMath::QuietNaN();; 3371 }; 3372 ; 3373 // Lazy initialization is set and needed when reading from a file; 3374 if (!fClingInitialized && fLazyInitialization) {; 3375 // try recompiling the formula. We need to lock because this is not anymore thread safe; 3376 R__LOCKGUARD(gROOTMutex);; 3377 // check again in case another thread has initialized the formula (see ROOT-10994); 3378 if (!fClingInitialized) {; 3379 auto thisFormula = const_cast<TFormula*>(this);; 3380 thisFormula->ReInitializeEvalMethod();; 3381 }; 3382 if (!fClingInitialized) {; 3383 Error(""DoEval"", ""Formula has error and it is not properly initialized "");; 3384 return TMath::QuietNaN();; 3385 }; 3386 }; 3387 ; 3388 if (fLambdaPtr && TestBit(TFormula::kLambda)) {// case of lambda functions; 3389 std::function<double(double *, double *)> & fptr = * ( (std::function<double(double *, double *)> *) fLambdaPtr);; 3390 assert(x);; 3391 //double * v = (x) ? const_cast<double*>(x) : const_cast<double*>(fClingVariables.data());; 3392 double * v = const_cast<double*>(x);; 3393 double * p = (params) ? const_cast<double*>(params) : const_cast<double*>(fClingParameters.data());; 3394 return fptr(v, p);; 3395 }; 3396 ; 3397 ; 3398 Double_t result = 0;; 3399 void* args[2];; 3400 double * vars = (x) ? const_cast<double*>(x) : const_cast<double*>(fClingVariables.data());; 3401 args[0] = &vars;; 3402 if (fNpar <= 0) {; 3403 (*fFuncPtr)(nullptr, 1, args, &result);; 3404 } else {; 3405 double *pars = (params) ? const_cast<double *>(params) : const_cast<double *>(fClingParameters.data());; 3406 args[1] = &pars;; 3407 (*fFunc",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:135469,Testability,assert,assert,135469,"ize_t found2 = clingFunc.rfind(';');; 3539 if (found == std::string::npos || found2 == std::string::npos) {; 3540 Error(""GetExpFormula"",""Invalid Cling expression - return default formula expression"");; 3541 return fFormula;; 3542 }; 3543 TString clingFormula = fClingInput(found+7,found2-found-7);; 3544 // to be implemented; 3545 if (!opt.Contains(""P"")) return clingFormula;; 3546 // replace all ""p["" with ""[parname""; 3547 int i = 0;; 3548 while (i < clingFormula.Length()-2 ) {; 3549 // look for p[number; 3550 if (clingFormula[i] == 'p' && clingFormula[i+1] == '[' && isdigit(clingFormula[i+2]) ) {; 3551 int j = i+3;; 3552 while ( isdigit(clingFormula[j]) ) { j++;}; 3553 if (clingFormula[j] != ']') {; 3554 Error(""GetExpFormula"",""Parameters not found - invalid expression - return default cling formula"");; 3555 return clingFormula;; 3556 }; 3557 TString parNumbName = clingFormula(i+2,j-i-2);; 3558 int parNumber = parNumbName.Atoi();; 3559 assert(parNumber < fNpar);; 3560 TString replacement = TString::Format(""%f"",GetParameter(parNumber));; 3561 clingFormula.Replace(i,j-i+1, replacement );; 3562 i += replacement.Length();; 3563 }; 3564 i++;; 3565 }; 3566 return clingFormula;; 3567 }; 3568 if (opt.Contains(""P"") ) {; 3569 // replace parameter names with their values; 3570 TString expFormula = fFormula;; 3571 int i = 0;; 3572 while (i < expFormula.Length()-2 ) {; 3573 // look for [parName]; 3574 if (expFormula[i] == '[') {; 3575 int j = i+1;; 3576 while ( expFormula[j] != ']' ) { j++;}; 3577 if (expFormula[j] != ']') {; 3578 Error(""GetExpFormula"",""Parameter names not found - invalid expression - return default formula"");; 3579 return expFormula;; 3580 }; 3581 TString parName = expFormula(i+1,j-i-1);; 3582 TString replacement = TString::Format(""%g"",GetParameter(parName));; 3583 expFormula.Replace(i,j-i+1, replacement );; 3584 i += replacement.Length();; 3585 }; 3586 i++;; 3587 }; 3588 return expFormula;; 3589 }; 3590 Warning(""GetExpFormula"",""Invalid option - return default form",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:137796,Testability,assert,assert,137796,"t *, Double_t *, Double_t *)) "");; 3597 s += GetGradientFuncName();; 3598 gInterpreter->Evaluate(s.c_str(), *v);; 3599 return v->ToString();; 3600}; 3601 ; 3602TString TFormula::GetHessianFormula() const {; 3603 std::unique_ptr<TInterpreterValue> v = gInterpreter->MakeInterpreterValue();; 3604 gInterpreter->Evaluate(GetHessianFuncName().c_str(), *v);; 3605 return v->ToString();; 3606}; 3607 ; 3608////////////////////////////////////////////////////////////////////////////////; 3609/// Print the formula and its attributes.; 3610 ; 3611void TFormula::Print(Option_t *option) const; 3612{; 3613 printf("" %20s : %s Ndim= %d, Npar= %d, Number= %d \n"",GetName(),GetTitle(), fNdim,fNpar,fNumber);; 3614 printf("" Formula expression: \n"");; 3615 printf(""\t%s \n"",fFormula.Data() );; 3616 TString opt(option);; 3617 opt.ToUpper();; 3618 // do an evaluation as a cross-check; 3619 //if (fReadyToExecute) Eval();; 3620 ; 3621 if (opt.Contains(""V"") ) {; 3622 if (fNdim > 0 && !TestBit(TFormula::kLambda)) {; 3623 printf(""List of Variables: \n"");; 3624 assert(int(fClingVariables.size()) >= fNdim);; 3625 for ( int ivar = 0; ivar < fNdim ; ++ivar) {; 3626 printf(""Var%4d %20s = %10f \n"",ivar,GetVarName(ivar).Data(), fClingVariables[ivar]);; 3627 }; 3628 }; 3629 if (fNpar > 0) {; 3630 printf(""List of Parameters: \n"");; 3631 if ( int(fClingParameters.size()) < fNpar); 3632 Error(""Print"",""Number of stored parameters in vector %zu in map %zu is different than fNpar %d"",fClingParameters.size(), fParams.size(), fNpar);; 3633 assert(int(fClingParameters.size()) >= fNpar);; 3634 // print with order passed to Cling function; 3635 for ( int ipar = 0; ipar < fNpar ; ++ipar) {; 3636 printf(""Par%4d %20s = %10f \n"",ipar,GetParName(ipar), fClingParameters[ipar] );; 3637 }; 3638 }; 3639 printf(""Expression passed to Cling:\n"");; 3640 printf(""\t%s\n"",fClingInput.Data() );; 3641 if (fGradFuncPtr) {; 3642 printf(""Generated Gradient:\n"");; 3643 printf(""%s\n"", fGradGenerationInput.c_str());; 3644 printf(""%s\n"", Ge",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:138269,Testability,assert,assert,138269,"butes.; 3610 ; 3611void TFormula::Print(Option_t *option) const; 3612{; 3613 printf("" %20s : %s Ndim= %d, Npar= %d, Number= %d \n"",GetName(),GetTitle(), fNdim,fNpar,fNumber);; 3614 printf("" Formula expression: \n"");; 3615 printf(""\t%s \n"",fFormula.Data() );; 3616 TString opt(option);; 3617 opt.ToUpper();; 3618 // do an evaluation as a cross-check; 3619 //if (fReadyToExecute) Eval();; 3620 ; 3621 if (opt.Contains(""V"") ) {; 3622 if (fNdim > 0 && !TestBit(TFormula::kLambda)) {; 3623 printf(""List of Variables: \n"");; 3624 assert(int(fClingVariables.size()) >= fNdim);; 3625 for ( int ivar = 0; ivar < fNdim ; ++ivar) {; 3626 printf(""Var%4d %20s = %10f \n"",ivar,GetVarName(ivar).Data(), fClingVariables[ivar]);; 3627 }; 3628 }; 3629 if (fNpar > 0) {; 3630 printf(""List of Parameters: \n"");; 3631 if ( int(fClingParameters.size()) < fNpar); 3632 Error(""Print"",""Number of stored parameters in vector %zu in map %zu is different than fNpar %d"",fClingParameters.size(), fParams.size(), fNpar);; 3633 assert(int(fClingParameters.size()) >= fNpar);; 3634 // print with order passed to Cling function; 3635 for ( int ipar = 0; ipar < fNpar ; ++ipar) {; 3636 printf(""Par%4d %20s = %10f \n"",ipar,GetParName(ipar), fClingParameters[ipar] );; 3637 }; 3638 }; 3639 printf(""Expression passed to Cling:\n"");; 3640 printf(""\t%s\n"",fClingInput.Data() );; 3641 if (fGradFuncPtr) {; 3642 printf(""Generated Gradient:\n"");; 3643 printf(""%s\n"", fGradGenerationInput.c_str());; 3644 printf(""%s\n"", GetGradientFormula().Data());; 3645 }; 3646 if(fHessFuncPtr) {; 3647 printf(""Generated Hessian:\n"");; 3648 printf(""%s\n"", fHessGenerationInput.c_str());; 3649 printf(""%s\n"", GetHessianFormula().Data());; 3650 }; 3651 }; 3652 if(!fReadyToExecute); 3653 {; 3654 Warning(""Print"", ""Formula is not ready to execute. Missing parameters/variables"");; 3655 for (list<TFormulaFunction>::const_iterator it = fFuncs.begin(); it != fFuncs.end(); ++it) {; 3656 TFormulaFunction fun = *it;; 3657 if (!fun.fFound) {; 3658 printf(""%s is un",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:143175,Testability,assert,assert,143175,"st << "" index "" << p.second << std::endl;; 3735 ; 3736 fClingParameters.clear(); // need to be reset before re-initializing it; 3737 ; 3738 FillDefaults();; 3739 ; 3740 ; 3741 PreProcessFormula(fFormula);; 3742 ; 3743 //std::cout << ""Streamer::after pre-process the formula "" << fFormula << "" ndim = "" << fNdim << "" npar = "" << fNpar << std::endl;; 3744 ; 3745 PrepareFormula(fFormula);; 3746 ; 3747 //std::cout << ""Streamer::after prepared "" << fClingInput << "" ndim = "" << fNdim << "" npar = "" << fNpar << std::endl;; 3748 ; 3749 ; 3750 // restore parameter values; 3751 if (fNpar != (int) parValues.size() ) {; 3752 Error(""Streamer"",""number of parameters computed (%d) is not same as the stored parameters (%d)"",fNpar,int(parValues.size()) );; 3753 Print(""v"");; 3754 }; 3755 if (v > 11 && fNdim != ndim) {; 3756 Error(""Streamer"",""number of dimension computed (%d) is not same as the stored value (%d)"",fNdim, ndim );; 3757 Print(""v"");; 3758 }; 3759 }; 3760 else {; 3761 // we also delay the initialization of lamda expressions; 3762 if (!fLazyInitialization) {; 3763 bool ret = InitLambdaExpression(fFormula);; 3764 if (ret) {; 3765 fClingInitialized = true;; 3766 }; 3767 }else {; 3768 fReadyToExecute = true;; 3769 }; 3770 }; 3771 assert(fNpar == (int) parValues.size() );; 3772 std::copy( parValues.begin(), parValues.end(), fClingParameters.begin() );; 3773 // restore parameter names and order; 3774 if (fParams.size() != paramMap.size() ) {; 3775 Warning(""Streamer"",""number of parameters list found (%zu) is not same as the stored one (%zu) - use re-created list"",fParams.size(),paramMap.size()) ;; 3776 //Print(""v"");; 3777 }; 3778 else; 3779 //assert(fParams.size() == paramMap.size() );; 3780 fParams = paramMap;; 3781 ; 3782 // input formula into Cling; 3783 // need to replace in cling the name of the pointer of this object; 3784 // TString oldClingName = fClingName;; 3785 // fClingName.Replace(fClingName.Index(""_0x"")+1,fClingName.Length(), TString::Format(""%p"",this) );; 3786 // fCling",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:143593,Testability,assert,assert,143593,"r"",""number of parameters computed (%d) is not same as the stored parameters (%d)"",fNpar,int(parValues.size()) );; 3753 Print(""v"");; 3754 }; 3755 if (v > 11 && fNdim != ndim) {; 3756 Error(""Streamer"",""number of dimension computed (%d) is not same as the stored value (%d)"",fNdim, ndim );; 3757 Print(""v"");; 3758 }; 3759 }; 3760 else {; 3761 // we also delay the initialization of lamda expressions; 3762 if (!fLazyInitialization) {; 3763 bool ret = InitLambdaExpression(fFormula);; 3764 if (ret) {; 3765 fClingInitialized = true;; 3766 }; 3767 }else {; 3768 fReadyToExecute = true;; 3769 }; 3770 }; 3771 assert(fNpar == (int) parValues.size() );; 3772 std::copy( parValues.begin(), parValues.end(), fClingParameters.begin() );; 3773 // restore parameter names and order; 3774 if (fParams.size() != paramMap.size() ) {; 3775 Warning(""Streamer"",""number of parameters list found (%zu) is not same as the stored one (%zu) - use re-created list"",fParams.size(),paramMap.size()) ;; 3776 //Print(""v"");; 3777 }; 3778 else; 3779 //assert(fParams.size() == paramMap.size() );; 3780 fParams = paramMap;; 3781 ; 3782 // input formula into Cling; 3783 // need to replace in cling the name of the pointer of this object; 3784 // TString oldClingName = fClingName;; 3785 // fClingName.Replace(fClingName.Index(""_0x"")+1,fClingName.Length(), TString::Format(""%p"",this) );; 3786 // fClingInput.ReplaceAll(oldClingName, fClingName);; 3787 // InputFormulaIntoCling();; 3788 ; 3789 if (!TestBit(kNotGlobal)) {; 3790 R__LOCKGUARD(gROOTMutex);; 3791 gROOT->GetListOfFunctions()->Add(this);; 3792 }; 3793 if (!fReadyToExecute ) {; 3794 Error(""Streamer"",""Formula read from file is NOT ready to execute"");; 3795 Print(""v"");; 3796 }; 3797 //std::cout << ""reading 2 npar = "" << GetNpar() << std::endl;; 3798 ; 3799 return;; 3800 }; 3801 else {; 3802 Error(""Streamer"",""Reading version %d is not supported"",v);; 3803 return;; 3804 }; 3805 }; 3806 else {; 3807 // case of writing; 3808 b.WriteClassBuffer(TFormula::Class(), this);; ",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:170762,Testability,log,log,170762,"gend1.C:17; nconst Int_t nDefinition legend1.C:16; f1TF1 * f1Definition legend1.C:11; ROOT::Splitstd::vector< std::string > Split(std::string_view str, std::string_view delims, bool skipEmpty=false)Splits a string at each character in delims.Definition StringUtils.cxx:23; ROOT::GetROOTTROOT * GetROOT()Definition TROOT.cxx:472; TMath::Gconstexpr Double_t G()Gravitational constant in: .Definition TMath.h:135; TMath::Cconstexpr Double_t C()Velocity of light in .Definition TMath.h:114; TMath::MaxShort_t Max(Short_t a, Short_t b)Returns the largest of a and b.Definition TMathBase.h:250; TMath::QuietNaNDouble_t QuietNaN()Returns a quiet NaN as defined by IEEE 754.Definition TMath.h:902; TMath::FloorDouble_t Floor(Double_t x)Rounds x downward, returning the largest integral value that is not greater than x.Definition TMath.h:680; TMath::Kconstexpr Double_t K()Boltzmann's constant in : .Definition TMath.h:247; TMath::Sqrt2constexpr Double_t Sqrt2()Definition TMath.h:86; TMath::Econstexpr Double_t E()Base of natural log: .Definition TMath.h:93; TMath::Sigmaconstexpr Double_t Sigma()Stefan-Boltzmann constant in : .Definition TMath.h:270; TMath::Hconstexpr Double_t H()Planck's constant in : .Definition TMath.h:188; TMath::LogEconstexpr Double_t LogE()Base-10 log of e (to convert ln to log)Definition TMath.h:107; TMath::Ln10constexpr Double_t Ln10()Natural log of 10 (to convert log to ln)Definition TMath.h:100; TMath::EulerGammaconstexpr Double_t EulerGamma()Euler-Mascheroni Constant.Definition TMath.h:332; TMath::Piconstexpr Double_t Pi()Definition TMath.h:37; TMath::Rconstexpr Double_t R()Universal gas constant ( ) inDefinition TMath.h:302; TMath::Log10Double_t Log10(Double_t x)Returns the common (base-10) logarithm of x.Definition TMath.h:762; TMath::InfinityDouble_t Infinity()Returns an infinity as defined by the IEEE standard.Definition TMath.h:917; v@ vDefinition rootcling_impl.cxx:3699; TFormulaParamOrder::operator()bool operator()(const TString &a, const TString &b) con",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:171007,Testability,log,log,171007,"xx:23; ROOT::GetROOTTROOT * GetROOT()Definition TROOT.cxx:472; TMath::Gconstexpr Double_t G()Gravitational constant in: .Definition TMath.h:135; TMath::Cconstexpr Double_t C()Velocity of light in .Definition TMath.h:114; TMath::MaxShort_t Max(Short_t a, Short_t b)Returns the largest of a and b.Definition TMathBase.h:250; TMath::QuietNaNDouble_t QuietNaN()Returns a quiet NaN as defined by IEEE 754.Definition TMath.h:902; TMath::FloorDouble_t Floor(Double_t x)Rounds x downward, returning the largest integral value that is not greater than x.Definition TMath.h:680; TMath::Kconstexpr Double_t K()Boltzmann's constant in : .Definition TMath.h:247; TMath::Sqrt2constexpr Double_t Sqrt2()Definition TMath.h:86; TMath::Econstexpr Double_t E()Base of natural log: .Definition TMath.h:93; TMath::Sigmaconstexpr Double_t Sigma()Stefan-Boltzmann constant in : .Definition TMath.h:270; TMath::Hconstexpr Double_t H()Planck's constant in : .Definition TMath.h:188; TMath::LogEconstexpr Double_t LogE()Base-10 log of e (to convert ln to log)Definition TMath.h:107; TMath::Ln10constexpr Double_t Ln10()Natural log of 10 (to convert log to ln)Definition TMath.h:100; TMath::EulerGammaconstexpr Double_t EulerGamma()Euler-Mascheroni Constant.Definition TMath.h:332; TMath::Piconstexpr Double_t Pi()Definition TMath.h:37; TMath::Rconstexpr Double_t R()Universal gas constant ( ) inDefinition TMath.h:302; TMath::Log10Double_t Log10(Double_t x)Returns the common (base-10) logarithm of x.Definition TMath.h:762; TMath::InfinityDouble_t Infinity()Returns an infinity as defined by the IEEE standard.Definition TMath.h:917; v@ vDefinition rootcling_impl.cxx:3699; TFormulaParamOrder::operator()bool operator()(const TString &a, const TString &b) constDefinition TFormula.cxx:375; TInterpreter::CallFuncIFacePtr_t::Generic_tvoid(* Generic_t)(void *, int, void **, void *)Definition TInterpreter.h:90; TInterpreter::CallFuncIFacePtr_t::fGenericGeneric_t fGenericDefinition TInterpreter.h:105; mTMarker mDefinition text",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:171034,Testability,log,log,171034,"xx:23; ROOT::GetROOTTROOT * GetROOT()Definition TROOT.cxx:472; TMath::Gconstexpr Double_t G()Gravitational constant in: .Definition TMath.h:135; TMath::Cconstexpr Double_t C()Velocity of light in .Definition TMath.h:114; TMath::MaxShort_t Max(Short_t a, Short_t b)Returns the largest of a and b.Definition TMathBase.h:250; TMath::QuietNaNDouble_t QuietNaN()Returns a quiet NaN as defined by IEEE 754.Definition TMath.h:902; TMath::FloorDouble_t Floor(Double_t x)Rounds x downward, returning the largest integral value that is not greater than x.Definition TMath.h:680; TMath::Kconstexpr Double_t K()Boltzmann's constant in : .Definition TMath.h:247; TMath::Sqrt2constexpr Double_t Sqrt2()Definition TMath.h:86; TMath::Econstexpr Double_t E()Base of natural log: .Definition TMath.h:93; TMath::Sigmaconstexpr Double_t Sigma()Stefan-Boltzmann constant in : .Definition TMath.h:270; TMath::Hconstexpr Double_t H()Planck's constant in : .Definition TMath.h:188; TMath::LogEconstexpr Double_t LogE()Base-10 log of e (to convert ln to log)Definition TMath.h:107; TMath::Ln10constexpr Double_t Ln10()Natural log of 10 (to convert log to ln)Definition TMath.h:100; TMath::EulerGammaconstexpr Double_t EulerGamma()Euler-Mascheroni Constant.Definition TMath.h:332; TMath::Piconstexpr Double_t Pi()Definition TMath.h:37; TMath::Rconstexpr Double_t R()Universal gas constant ( ) inDefinition TMath.h:302; TMath::Log10Double_t Log10(Double_t x)Returns the common (base-10) logarithm of x.Definition TMath.h:762; TMath::InfinityDouble_t Infinity()Returns an infinity as defined by the IEEE standard.Definition TMath.h:917; v@ vDefinition rootcling_impl.cxx:3699; TFormulaParamOrder::operator()bool operator()(const TString &a, const TString &b) constDefinition TFormula.cxx:375; TInterpreter::CallFuncIFacePtr_t::Generic_tvoid(* Generic_t)(void *, int, void **, void *)Definition TInterpreter.h:90; TInterpreter::CallFuncIFacePtr_t::fGenericGeneric_t fGenericDefinition TInterpreter.h:105; mTMarker mDefinition text",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:171106,Testability,log,log,171106,"tional constant in: .Definition TMath.h:135; TMath::Cconstexpr Double_t C()Velocity of light in .Definition TMath.h:114; TMath::MaxShort_t Max(Short_t a, Short_t b)Returns the largest of a and b.Definition TMathBase.h:250; TMath::QuietNaNDouble_t QuietNaN()Returns a quiet NaN as defined by IEEE 754.Definition TMath.h:902; TMath::FloorDouble_t Floor(Double_t x)Rounds x downward, returning the largest integral value that is not greater than x.Definition TMath.h:680; TMath::Kconstexpr Double_t K()Boltzmann's constant in : .Definition TMath.h:247; TMath::Sqrt2constexpr Double_t Sqrt2()Definition TMath.h:86; TMath::Econstexpr Double_t E()Base of natural log: .Definition TMath.h:93; TMath::Sigmaconstexpr Double_t Sigma()Stefan-Boltzmann constant in : .Definition TMath.h:270; TMath::Hconstexpr Double_t H()Planck's constant in : .Definition TMath.h:188; TMath::LogEconstexpr Double_t LogE()Base-10 log of e (to convert ln to log)Definition TMath.h:107; TMath::Ln10constexpr Double_t Ln10()Natural log of 10 (to convert log to ln)Definition TMath.h:100; TMath::EulerGammaconstexpr Double_t EulerGamma()Euler-Mascheroni Constant.Definition TMath.h:332; TMath::Piconstexpr Double_t Pi()Definition TMath.h:37; TMath::Rconstexpr Double_t R()Universal gas constant ( ) inDefinition TMath.h:302; TMath::Log10Double_t Log10(Double_t x)Returns the common (base-10) logarithm of x.Definition TMath.h:762; TMath::InfinityDouble_t Infinity()Returns an infinity as defined by the IEEE standard.Definition TMath.h:917; v@ vDefinition rootcling_impl.cxx:3699; TFormulaParamOrder::operator()bool operator()(const TString &a, const TString &b) constDefinition TFormula.cxx:375; TInterpreter::CallFuncIFacePtr_t::Generic_tvoid(* Generic_t)(void *, int, void **, void *)Definition TInterpreter.h:90; TInterpreter::CallFuncIFacePtr_t::fGenericGeneric_t fGenericDefinition TInterpreter.h:105; mTMarker mDefinition textangle.C:8; TFormula.h. histhistsrcTFormula.cxx. ROOT master - Reference Guide Generated on Tue Nov ",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:171128,Testability,log,log,171128,"tional constant in: .Definition TMath.h:135; TMath::Cconstexpr Double_t C()Velocity of light in .Definition TMath.h:114; TMath::MaxShort_t Max(Short_t a, Short_t b)Returns the largest of a and b.Definition TMathBase.h:250; TMath::QuietNaNDouble_t QuietNaN()Returns a quiet NaN as defined by IEEE 754.Definition TMath.h:902; TMath::FloorDouble_t Floor(Double_t x)Rounds x downward, returning the largest integral value that is not greater than x.Definition TMath.h:680; TMath::Kconstexpr Double_t K()Boltzmann's constant in : .Definition TMath.h:247; TMath::Sqrt2constexpr Double_t Sqrt2()Definition TMath.h:86; TMath::Econstexpr Double_t E()Base of natural log: .Definition TMath.h:93; TMath::Sigmaconstexpr Double_t Sigma()Stefan-Boltzmann constant in : .Definition TMath.h:270; TMath::Hconstexpr Double_t H()Planck's constant in : .Definition TMath.h:188; TMath::LogEconstexpr Double_t LogE()Base-10 log of e (to convert ln to log)Definition TMath.h:107; TMath::Ln10constexpr Double_t Ln10()Natural log of 10 (to convert log to ln)Definition TMath.h:100; TMath::EulerGammaconstexpr Double_t EulerGamma()Euler-Mascheroni Constant.Definition TMath.h:332; TMath::Piconstexpr Double_t Pi()Definition TMath.h:37; TMath::Rconstexpr Double_t R()Universal gas constant ( ) inDefinition TMath.h:302; TMath::Log10Double_t Log10(Double_t x)Returns the common (base-10) logarithm of x.Definition TMath.h:762; TMath::InfinityDouble_t Infinity()Returns an infinity as defined by the IEEE standard.Definition TMath.h:917; v@ vDefinition rootcling_impl.cxx:3699; TFormulaParamOrder::operator()bool operator()(const TString &a, const TString &b) constDefinition TFormula.cxx:375; TInterpreter::CallFuncIFacePtr_t::Generic_tvoid(* Generic_t)(void *, int, void **, void *)Definition TInterpreter.h:90; TInterpreter::CallFuncIFacePtr_t::fGenericGeneric_t fGenericDefinition TInterpreter.h:105; mTMarker mDefinition textangle.C:8; TFormula.h. histhistsrcTFormula.cxx. ROOT master - Reference Guide Generated on Tue Nov ",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:171465,Testability,log,logarithm,171465,"constexpr Double_t C()Velocity of light in .Definition TMath.h:114; TMath::MaxShort_t Max(Short_t a, Short_t b)Returns the largest of a and b.Definition TMathBase.h:250; TMath::QuietNaNDouble_t QuietNaN()Returns a quiet NaN as defined by IEEE 754.Definition TMath.h:902; TMath::FloorDouble_t Floor(Double_t x)Rounds x downward, returning the largest integral value that is not greater than x.Definition TMath.h:680; TMath::Kconstexpr Double_t K()Boltzmann's constant in : .Definition TMath.h:247; TMath::Sqrt2constexpr Double_t Sqrt2()Definition TMath.h:86; TMath::Econstexpr Double_t E()Base of natural log: .Definition TMath.h:93; TMath::Sigmaconstexpr Double_t Sigma()Stefan-Boltzmann constant in : .Definition TMath.h:270; TMath::Hconstexpr Double_t H()Planck's constant in : .Definition TMath.h:188; TMath::LogEconstexpr Double_t LogE()Base-10 log of e (to convert ln to log)Definition TMath.h:107; TMath::Ln10constexpr Double_t Ln10()Natural log of 10 (to convert log to ln)Definition TMath.h:100; TMath::EulerGammaconstexpr Double_t EulerGamma()Euler-Mascheroni Constant.Definition TMath.h:332; TMath::Piconstexpr Double_t Pi()Definition TMath.h:37; TMath::Rconstexpr Double_t R()Universal gas constant ( ) inDefinition TMath.h:302; TMath::Log10Double_t Log10(Double_t x)Returns the common (base-10) logarithm of x.Definition TMath.h:762; TMath::InfinityDouble_t Infinity()Returns an infinity as defined by the IEEE standard.Definition TMath.h:917; v@ vDefinition rootcling_impl.cxx:3699; TFormulaParamOrder::operator()bool operator()(const TString &a, const TString &b) constDefinition TFormula.cxx:375; TInterpreter::CallFuncIFacePtr_t::Generic_tvoid(* Generic_t)(void *, int, void **, void *)Definition TInterpreter.h:90; TInterpreter::CallFuncIFacePtr_t::fGenericGeneric_t fGenericDefinition TInterpreter.h:105; mTMarker mDefinition textangle.C:8; TFormula.h. histhistsrcTFormula.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:32 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:7841,Usability,simpl,simple,7841,"T::Math::bigaussian_pdf (x,y,[SigmaX],[SigmaY],[Rho],[MeanX],[MeanY])`, a 2d gaussian including a correlation parameter.; 179 3. Three Dimensional functions:; 180 - `xyzgaus` is for a 3d Gaussians without correlations:; 181 `[Constant]*exp(-0.5*pow(((x-[MeanX])/[SigmaX]),2 )- 0.5*pow(((y-[MeanY])/[SigmaY]),2 )- 0.5*pow(((z-[MeanZ])/[SigmaZ]),2))`; 182 ; 183 ; 184 ### An expanded note on variables and parameters; 185 ; 186 In a TFormula, a variable is a defined by a name `x`, `y`, `z` or `t` or an; 187 index like `x[0]`, `x[1]`, `x[2]`; that is `x[N]` where N is an integer.; 188 ; 189 ```; 190 TFormula("""", ""x[0] * x[1] + 10""); 191 ```; 192 ; 193 Parameters are similar and can take any name. It is specified using brackets; 194 e.g. `[expected_mass]` or `[0]`.; 195 ; 196 ```; 197 TFormula("""", ""exp([expected_mass])-1""); 198 ```; 199 ; 200 Variables and parameters can be combined in the same TFormula. Here we consider; 201 a very simple case where we have an exponential decay after some time t and a; 202 number of events with timestamps for which we want to evaluate this function.; 203 ; 204 ```; 205 TFormula tf ("""", ""[0]*exp(-[1]*t)"");; 206 tf.SetParameter(0, 1);; 207 tf.SetParameter(1, 0.5);; 208 ; 209 for (auto & event : events) {; 210 tf.Eval(event.t);; 211 }; 212 ```; 213 ; 214 The distinction between variables and parameters arose from the TFormula's; 215 application in fitting. There parameters are fitted to the data provided; 216 through variables. In other applications this distinction can go away.; 217 ; 218 Parameter values can be provided dynamically using `TFormula::EvalPar`; 219 instead of `TFormula::Eval`. In this way parameters can be used identically; 220 to variables. See below for an example that uses only parameters to model a; 221 function.; 222 ; 223 ```; 224 Int_t params[2] = {1, 2}; // {vel_x, vel_y}; 225 TFormula tf ("""", ""[vel_x]/sqrt(([vel_x + vel_y])**2)"");; 226 ; 227 tf.EvalPar(nullptr, params);; 228 ```; 229 ; 230 ### A note on operators; 231 ",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:24598,Usability,clear,clear,24598,"; 634 if (fLambdaPtr != nullptr) {; 635 R__LOCKGUARD(gROOTMutex);; 636 gClingFunctions.insert ( std::make_pair ( lambdaExpression, fLambdaPtr) );; 637 fClingInitialized = true;; 638 return true;; 639 }; 640 fClingInitialized = false;; 641 return false;; 642}; 643 ; 644////////////////////////////////////////////////////////////////////////////////; 645/// Compile the given expression with Cling; 646/// backward compatibility method to be used in combination with the empty constructor; 647/// if no expression is given , the current stored formula (retrieved with GetExpFormula()) or the title is used.; 648/// return 0 if the formula compilation is successful; 649 ; 650Int_t TFormula::Compile(const char *expression); 651{; 652 TString formula = expression;; 653 if (formula.IsNull() ) {; 654 formula = fFormula;; 655 if (formula.IsNull() ) formula = GetTitle();; 656 }; 657 ; 658 if (formula.IsNull() ) return -1;; 659 ; 660 // do not re-process if it was done before; 661 if (IsValid() && formula == fFormula ) return 0;; 662 ; 663 // clear if a formula was already existing; 664 if (!fFormula.IsNull() ) Clear();; 665 ; 666 fFormula = formula;; 667 ; 668 if (TestBit(TFormula::kLambda) ) {; 669 bool ret = InitLambdaExpression(fFormula);; 670 return (ret) ? 0 : 1;; 671 }; 672 ; 673 if (fVars.empty() ) FillDefaults();; 674 // prepare the formula for Cling; 675 //printf(""compile: processing formula %s\n"",fFormula.Data() );; 676 PreProcessFormula(fFormula);; 677 // pass formula in CLing; 678 bool ret = PrepareFormula(fFormula);; 679 ; 680 return (ret) ? 0 : 1;; 681}; 682 ; 683////////////////////////////////////////////////////////////////////////////////; 684void TFormula::Copy(TObject &obj) const; 685{; 686 TNamed::Copy(obj);; 687 // need to copy also cling parameters; 688 TFormula & fnew = dynamic_cast<TFormula&>(obj);; 689 ; 690 fnew.fClingParameters = fClingParameters;; 691 fnew.fClingVariables = fClingVariables;; 692 ; 693 fnew.fFuncs = fFuncs;; 694 fnew.fVars = fVars;; 695 ",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:26186,Usability,clear,clear,26186,"void TFormula::Copy(TObject &obj) const; 685{; 686 TNamed::Copy(obj);; 687 // need to copy also cling parameters; 688 TFormula & fnew = dynamic_cast<TFormula&>(obj);; 689 ; 690 fnew.fClingParameters = fClingParameters;; 691 fnew.fClingVariables = fClingVariables;; 692 ; 693 fnew.fFuncs = fFuncs;; 694 fnew.fVars = fVars;; 695 fnew.fParams = fParams;; 696 fnew.fConsts = fConsts;; 697 fnew.fFunctionsShortcuts = fFunctionsShortcuts;; 698 fnew.fFormula = fFormula;; 699 fnew.fNdim = fNdim;; 700 fnew.fNpar = fNpar;; 701 fnew.fNumber = fNumber;; 702 fnew.fVectorized = fVectorized;; 703 fnew.SetParameters(GetParameters());; 704 // copy Linear parts (it is a vector of TFormula pointers) needs to be copied one by one; 705 // looping at all the elements; 706 // delete first previous elements; 707 int nLinParts = fnew.fLinearParts.size();; 708 if (nLinParts > 0) {; 709 for (int i = 0; i < nLinParts; ++i) delete fnew.fLinearParts[i];; 710 fnew.fLinearParts.clear();; 711 }; 712 // old size that needs to be copied; 713 nLinParts = fLinearParts.size();; 714 if (nLinParts > 0) {; 715 fnew.fLinearParts.reserve(nLinParts);; 716 for (int i = 0; i < nLinParts; ++i) {; 717 TFormula * linearNew = new TFormula();; 718 TFormula * linearOld = (TFormula*) fLinearParts[i];; 719 if (linearOld) {; 720 linearOld->Copy(*linearNew);; 721 fnew.fLinearParts.push_back(linearNew);; 722 }; 723 else; 724 Warning(""Copy"",""Function %s - expr %s has a dummy linear part %d"",GetName(),GetExpFormula().Data(),i);; 725 }; 726 }; 727 ; 728 fnew.fClingInput = fClingInput;; 729 fnew.fReadyToExecute = fReadyToExecute;; 730 fnew.fClingInitialized = fClingInitialized.load();; 731 fnew.fAllParametersSetted = fAllParametersSetted;; 732 fnew.fClingName = fClingName;; 733 fnew.fSavedInputFormula = fSavedInputFormula;; 734 fnew.fLazyInitialization = fLazyInitialization;; 735 ; 736 // case of function based on a C++ expression (lambda's) which is ready to be compiled; 737 if (fLambdaPtr && TestBit(TFormula::kLambda)) {; 738 ; ",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:28368,Usability,clear,clear,28368,"44 else {; 745 Error(""TFormula"",""Syntax error in building the lambda expression %s"", fFormula.Data() );; 746 fnew.fReadyToExecute = false;; 747 }; 748 }; 749 ; 750 // use copy-constructor of TMethodCall; 751 // if c++-14 could use std::make_unique; 752 TMethodCall *m = (fMethod) ? new TMethodCall(*fMethod) : nullptr;; 753 fnew.fMethod.reset(m);; 754 ; 755 fnew.fFuncPtr = fFuncPtr;; 756 fnew.fGradGenerationInput = fGradGenerationInput;; 757 fnew.fHessGenerationInput = fHessGenerationInput;; 758 fnew.fGradFuncPtr = fGradFuncPtr;; 759 fnew.fHessFuncPtr = fHessFuncPtr;; 760 ; 761}; 762 ; 763////////////////////////////////////////////////////////////////////////////////; 764/// Clear the formula setting expression to empty and reset the variables and; 765/// parameters containers.; 766 ; 767void TFormula::Clear(Option_t * ); 768{; 769 fNdim = 0;; 770 fNpar = 0;; 771 fNumber = 0;; 772 fFormula = """";; 773 fClingName = """";; 774 ; 775 fMethod.reset();; 776 ; 777 fClingVariables.clear();; 778 fClingParameters.clear();; 779 fReadyToExecute = false;; 780 fClingInitialized = false;; 781 fAllParametersSetted = false;; 782 fFuncs.clear();; 783 fVars.clear();; 784 fParams.clear();; 785 fConsts.clear();; 786 fFunctionsShortcuts.clear();; 787 ; 788 // delete linear parts; 789 int nLinParts = fLinearParts.size();; 790 if (nLinParts > 0) {; 791 for (int i = 0; i < nLinParts; ++i) delete fLinearParts[i];; 792 }; 793 fLinearParts.clear();; 794 ; 795}; 796 ; 797// Returns nullptr on failure.; 798static std::unique_ptr<TMethodCall>; 799prepareMethod(bool HasParameters, bool HasVariables, const char* FuncName,; 800 bool IsVectorized, bool AddCladArrayRef = false) {; 801 std::unique_ptr<TMethodCall>; 802 Method = std::make_unique<TMethodCall>();; 803 ; 804 TString prototypeArguments = """";; 805 if (HasVariables || HasParameters) {; 806 if (IsVectorized); 807 prototypeArguments.Append(""ROOT::Double_v*"");; 808 else; 809 prototypeArguments.Append(""Double_t*"");; 810 }; 811 auto AddDoublePtrParam ",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:28399,Usability,clear,clear,28399,"sion %s"", fFormula.Data() );; 746 fnew.fReadyToExecute = false;; 747 }; 748 }; 749 ; 750 // use copy-constructor of TMethodCall; 751 // if c++-14 could use std::make_unique; 752 TMethodCall *m = (fMethod) ? new TMethodCall(*fMethod) : nullptr;; 753 fnew.fMethod.reset(m);; 754 ; 755 fnew.fFuncPtr = fFuncPtr;; 756 fnew.fGradGenerationInput = fGradGenerationInput;; 757 fnew.fHessGenerationInput = fHessGenerationInput;; 758 fnew.fGradFuncPtr = fGradFuncPtr;; 759 fnew.fHessFuncPtr = fHessFuncPtr;; 760 ; 761}; 762 ; 763////////////////////////////////////////////////////////////////////////////////; 764/// Clear the formula setting expression to empty and reset the variables and; 765/// parameters containers.; 766 ; 767void TFormula::Clear(Option_t * ); 768{; 769 fNdim = 0;; 770 fNpar = 0;; 771 fNumber = 0;; 772 fFormula = """";; 773 fClingName = """";; 774 ; 775 fMethod.reset();; 776 ; 777 fClingVariables.clear();; 778 fClingParameters.clear();; 779 fReadyToExecute = false;; 780 fClingInitialized = false;; 781 fAllParametersSetted = false;; 782 fFuncs.clear();; 783 fVars.clear();; 784 fParams.clear();; 785 fConsts.clear();; 786 fFunctionsShortcuts.clear();; 787 ; 788 // delete linear parts; 789 int nLinParts = fLinearParts.size();; 790 if (nLinParts > 0) {; 791 for (int i = 0; i < nLinParts; ++i) delete fLinearParts[i];; 792 }; 793 fLinearParts.clear();; 794 ; 795}; 796 ; 797// Returns nullptr on failure.; 798static std::unique_ptr<TMethodCall>; 799prepareMethod(bool HasParameters, bool HasVariables, const char* FuncName,; 800 bool IsVectorized, bool AddCladArrayRef = false) {; 801 std::unique_ptr<TMethodCall>; 802 Method = std::make_unique<TMethodCall>();; 803 ; 804 TString prototypeArguments = """";; 805 if (HasVariables || HasParameters) {; 806 if (IsVectorized); 807 prototypeArguments.Append(""ROOT::Double_v*"");; 808 else; 809 prototypeArguments.Append(""Double_t*"");; 810 }; 811 auto AddDoublePtrParam = [&prototypeArguments]() {; 812 prototypeArguments.Append("","");; 813 prot",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:28517,Usability,clear,clear,28517,"}; 748 }; 749 ; 750 // use copy-constructor of TMethodCall; 751 // if c++-14 could use std::make_unique; 752 TMethodCall *m = (fMethod) ? new TMethodCall(*fMethod) : nullptr;; 753 fnew.fMethod.reset(m);; 754 ; 755 fnew.fFuncPtr = fFuncPtr;; 756 fnew.fGradGenerationInput = fGradGenerationInput;; 757 fnew.fHessGenerationInput = fHessGenerationInput;; 758 fnew.fGradFuncPtr = fGradFuncPtr;; 759 fnew.fHessFuncPtr = fHessFuncPtr;; 760 ; 761}; 762 ; 763////////////////////////////////////////////////////////////////////////////////; 764/// Clear the formula setting expression to empty and reset the variables and; 765/// parameters containers.; 766 ; 767void TFormula::Clear(Option_t * ); 768{; 769 fNdim = 0;; 770 fNpar = 0;; 771 fNumber = 0;; 772 fFormula = """";; 773 fClingName = """";; 774 ; 775 fMethod.reset();; 776 ; 777 fClingVariables.clear();; 778 fClingParameters.clear();; 779 fReadyToExecute = false;; 780 fClingInitialized = false;; 781 fAllParametersSetted = false;; 782 fFuncs.clear();; 783 fVars.clear();; 784 fParams.clear();; 785 fConsts.clear();; 786 fFunctionsShortcuts.clear();; 787 ; 788 // delete linear parts; 789 int nLinParts = fLinearParts.size();; 790 if (nLinParts > 0) {; 791 for (int i = 0; i < nLinParts; ++i) delete fLinearParts[i];; 792 }; 793 fLinearParts.clear();; 794 ; 795}; 796 ; 797// Returns nullptr on failure.; 798static std::unique_ptr<TMethodCall>; 799prepareMethod(bool HasParameters, bool HasVariables, const char* FuncName,; 800 bool IsVectorized, bool AddCladArrayRef = false) {; 801 std::unique_ptr<TMethodCall>; 802 Method = std::make_unique<TMethodCall>();; 803 ; 804 TString prototypeArguments = """";; 805 if (HasVariables || HasParameters) {; 806 if (IsVectorized); 807 prototypeArguments.Append(""ROOT::Double_v*"");; 808 else; 809 prototypeArguments.Append(""Double_t*"");; 810 }; 811 auto AddDoublePtrParam = [&prototypeArguments]() {; 812 prototypeArguments.Append("","");; 813 prototypeArguments.Append(""Double_t*"");; 814 };; 815 if (HasParameters); ",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:28537,Usability,clear,clear,28537,"/ use copy-constructor of TMethodCall; 751 // if c++-14 could use std::make_unique; 752 TMethodCall *m = (fMethod) ? new TMethodCall(*fMethod) : nullptr;; 753 fnew.fMethod.reset(m);; 754 ; 755 fnew.fFuncPtr = fFuncPtr;; 756 fnew.fGradGenerationInput = fGradGenerationInput;; 757 fnew.fHessGenerationInput = fHessGenerationInput;; 758 fnew.fGradFuncPtr = fGradFuncPtr;; 759 fnew.fHessFuncPtr = fHessFuncPtr;; 760 ; 761}; 762 ; 763////////////////////////////////////////////////////////////////////////////////; 764/// Clear the formula setting expression to empty and reset the variables and; 765/// parameters containers.; 766 ; 767void TFormula::Clear(Option_t * ); 768{; 769 fNdim = 0;; 770 fNpar = 0;; 771 fNumber = 0;; 772 fFormula = """";; 773 fClingName = """";; 774 ; 775 fMethod.reset();; 776 ; 777 fClingVariables.clear();; 778 fClingParameters.clear();; 779 fReadyToExecute = false;; 780 fClingInitialized = false;; 781 fAllParametersSetted = false;; 782 fFuncs.clear();; 783 fVars.clear();; 784 fParams.clear();; 785 fConsts.clear();; 786 fFunctionsShortcuts.clear();; 787 ; 788 // delete linear parts; 789 int nLinParts = fLinearParts.size();; 790 if (nLinParts > 0) {; 791 for (int i = 0; i < nLinParts; ++i) delete fLinearParts[i];; 792 }; 793 fLinearParts.clear();; 794 ; 795}; 796 ; 797// Returns nullptr on failure.; 798static std::unique_ptr<TMethodCall>; 799prepareMethod(bool HasParameters, bool HasVariables, const char* FuncName,; 800 bool IsVectorized, bool AddCladArrayRef = false) {; 801 std::unique_ptr<TMethodCall>; 802 Method = std::make_unique<TMethodCall>();; 803 ; 804 TString prototypeArguments = """";; 805 if (HasVariables || HasParameters) {; 806 if (IsVectorized); 807 prototypeArguments.Append(""ROOT::Double_v*"");; 808 else; 809 prototypeArguments.Append(""Double_t*"");; 810 }; 811 auto AddDoublePtrParam = [&prototypeArguments]() {; 812 prototypeArguments.Append("","");; 813 prototypeArguments.Append(""Double_t*"");; 814 };; 815 if (HasParameters); 816 AddDoublePtrParam",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:28559,Usability,clear,clear,28559," of TMethodCall; 751 // if c++-14 could use std::make_unique; 752 TMethodCall *m = (fMethod) ? new TMethodCall(*fMethod) : nullptr;; 753 fnew.fMethod.reset(m);; 754 ; 755 fnew.fFuncPtr = fFuncPtr;; 756 fnew.fGradGenerationInput = fGradGenerationInput;; 757 fnew.fHessGenerationInput = fHessGenerationInput;; 758 fnew.fGradFuncPtr = fGradFuncPtr;; 759 fnew.fHessFuncPtr = fHessFuncPtr;; 760 ; 761}; 762 ; 763////////////////////////////////////////////////////////////////////////////////; 764/// Clear the formula setting expression to empty and reset the variables and; 765/// parameters containers.; 766 ; 767void TFormula::Clear(Option_t * ); 768{; 769 fNdim = 0;; 770 fNpar = 0;; 771 fNumber = 0;; 772 fFormula = """";; 773 fClingName = """";; 774 ; 775 fMethod.reset();; 776 ; 777 fClingVariables.clear();; 778 fClingParameters.clear();; 779 fReadyToExecute = false;; 780 fClingInitialized = false;; 781 fAllParametersSetted = false;; 782 fFuncs.clear();; 783 fVars.clear();; 784 fParams.clear();; 785 fConsts.clear();; 786 fFunctionsShortcuts.clear();; 787 ; 788 // delete linear parts; 789 int nLinParts = fLinearParts.size();; 790 if (nLinParts > 0) {; 791 for (int i = 0; i < nLinParts; ++i) delete fLinearParts[i];; 792 }; 793 fLinearParts.clear();; 794 ; 795}; 796 ; 797// Returns nullptr on failure.; 798static std::unique_ptr<TMethodCall>; 799prepareMethod(bool HasParameters, bool HasVariables, const char* FuncName,; 800 bool IsVectorized, bool AddCladArrayRef = false) {; 801 std::unique_ptr<TMethodCall>; 802 Method = std::make_unique<TMethodCall>();; 803 ; 804 TString prototypeArguments = """";; 805 if (HasVariables || HasParameters) {; 806 if (IsVectorized); 807 prototypeArguments.Append(""ROOT::Double_v*"");; 808 else; 809 prototypeArguments.Append(""Double_t*"");; 810 }; 811 auto AddDoublePtrParam = [&prototypeArguments]() {; 812 prototypeArguments.Append("","");; 813 prototypeArguments.Append(""Double_t*"");; 814 };; 815 if (HasParameters); 816 AddDoublePtrParam();; 817 ; 818 // We n",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:28581,Usability,clear,clear,28581,"++-14 could use std::make_unique; 752 TMethodCall *m = (fMethod) ? new TMethodCall(*fMethod) : nullptr;; 753 fnew.fMethod.reset(m);; 754 ; 755 fnew.fFuncPtr = fFuncPtr;; 756 fnew.fGradGenerationInput = fGradGenerationInput;; 757 fnew.fHessGenerationInput = fHessGenerationInput;; 758 fnew.fGradFuncPtr = fGradFuncPtr;; 759 fnew.fHessFuncPtr = fHessFuncPtr;; 760 ; 761}; 762 ; 763////////////////////////////////////////////////////////////////////////////////; 764/// Clear the formula setting expression to empty and reset the variables and; 765/// parameters containers.; 766 ; 767void TFormula::Clear(Option_t * ); 768{; 769 fNdim = 0;; 770 fNpar = 0;; 771 fNumber = 0;; 772 fFormula = """";; 773 fClingName = """";; 774 ; 775 fMethod.reset();; 776 ; 777 fClingVariables.clear();; 778 fClingParameters.clear();; 779 fReadyToExecute = false;; 780 fClingInitialized = false;; 781 fAllParametersSetted = false;; 782 fFuncs.clear();; 783 fVars.clear();; 784 fParams.clear();; 785 fConsts.clear();; 786 fFunctionsShortcuts.clear();; 787 ; 788 // delete linear parts; 789 int nLinParts = fLinearParts.size();; 790 if (nLinParts > 0) {; 791 for (int i = 0; i < nLinParts; ++i) delete fLinearParts[i];; 792 }; 793 fLinearParts.clear();; 794 ; 795}; 796 ; 797// Returns nullptr on failure.; 798static std::unique_ptr<TMethodCall>; 799prepareMethod(bool HasParameters, bool HasVariables, const char* FuncName,; 800 bool IsVectorized, bool AddCladArrayRef = false) {; 801 std::unique_ptr<TMethodCall>; 802 Method = std::make_unique<TMethodCall>();; 803 ; 804 TString prototypeArguments = """";; 805 if (HasVariables || HasParameters) {; 806 if (IsVectorized); 807 prototypeArguments.Append(""ROOT::Double_v*"");; 808 else; 809 prototypeArguments.Append(""Double_t*"");; 810 }; 811 auto AddDoublePtrParam = [&prototypeArguments]() {; 812 prototypeArguments.Append("","");; 813 prototypeArguments.Append(""Double_t*"");; 814 };; 815 if (HasParameters); 816 AddDoublePtrParam();; 817 ; 818 // We need an extra Double_t* for t",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:28615,Usability,clear,clear,28615,"(fMethod) ? new TMethodCall(*fMethod) : nullptr;; 753 fnew.fMethod.reset(m);; 754 ; 755 fnew.fFuncPtr = fFuncPtr;; 756 fnew.fGradGenerationInput = fGradGenerationInput;; 757 fnew.fHessGenerationInput = fHessGenerationInput;; 758 fnew.fGradFuncPtr = fGradFuncPtr;; 759 fnew.fHessFuncPtr = fHessFuncPtr;; 760 ; 761}; 762 ; 763////////////////////////////////////////////////////////////////////////////////; 764/// Clear the formula setting expression to empty and reset the variables and; 765/// parameters containers.; 766 ; 767void TFormula::Clear(Option_t * ); 768{; 769 fNdim = 0;; 770 fNpar = 0;; 771 fNumber = 0;; 772 fFormula = """";; 773 fClingName = """";; 774 ; 775 fMethod.reset();; 776 ; 777 fClingVariables.clear();; 778 fClingParameters.clear();; 779 fReadyToExecute = false;; 780 fClingInitialized = false;; 781 fAllParametersSetted = false;; 782 fFuncs.clear();; 783 fVars.clear();; 784 fParams.clear();; 785 fConsts.clear();; 786 fFunctionsShortcuts.clear();; 787 ; 788 // delete linear parts; 789 int nLinParts = fLinearParts.size();; 790 if (nLinParts > 0) {; 791 for (int i = 0; i < nLinParts; ++i) delete fLinearParts[i];; 792 }; 793 fLinearParts.clear();; 794 ; 795}; 796 ; 797// Returns nullptr on failure.; 798static std::unique_ptr<TMethodCall>; 799prepareMethod(bool HasParameters, bool HasVariables, const char* FuncName,; 800 bool IsVectorized, bool AddCladArrayRef = false) {; 801 std::unique_ptr<TMethodCall>; 802 Method = std::make_unique<TMethodCall>();; 803 ; 804 TString prototypeArguments = """";; 805 if (HasVariables || HasParameters) {; 806 if (IsVectorized); 807 prototypeArguments.Append(""ROOT::Double_v*"");; 808 else; 809 prototypeArguments.Append(""Double_t*"");; 810 }; 811 auto AddDoublePtrParam = [&prototypeArguments]() {; 812 prototypeArguments.Append("","");; 813 prototypeArguments.Append(""Double_t*"");; 814 };; 815 if (HasParameters); 816 AddDoublePtrParam();; 817 ; 818 // We need an extra Double_t* for the gradient return result.; 819 if (AddCladArrayRef) {; ",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:28816,Usability,clear,clear,28816,"nInput = fHessGenerationInput;; 758 fnew.fGradFuncPtr = fGradFuncPtr;; 759 fnew.fHessFuncPtr = fHessFuncPtr;; 760 ; 761}; 762 ; 763////////////////////////////////////////////////////////////////////////////////; 764/// Clear the formula setting expression to empty and reset the variables and; 765/// parameters containers.; 766 ; 767void TFormula::Clear(Option_t * ); 768{; 769 fNdim = 0;; 770 fNpar = 0;; 771 fNumber = 0;; 772 fFormula = """";; 773 fClingName = """";; 774 ; 775 fMethod.reset();; 776 ; 777 fClingVariables.clear();; 778 fClingParameters.clear();; 779 fReadyToExecute = false;; 780 fClingInitialized = false;; 781 fAllParametersSetted = false;; 782 fFuncs.clear();; 783 fVars.clear();; 784 fParams.clear();; 785 fConsts.clear();; 786 fFunctionsShortcuts.clear();; 787 ; 788 // delete linear parts; 789 int nLinParts = fLinearParts.size();; 790 if (nLinParts > 0) {; 791 for (int i = 0; i < nLinParts; ++i) delete fLinearParts[i];; 792 }; 793 fLinearParts.clear();; 794 ; 795}; 796 ; 797// Returns nullptr on failure.; 798static std::unique_ptr<TMethodCall>; 799prepareMethod(bool HasParameters, bool HasVariables, const char* FuncName,; 800 bool IsVectorized, bool AddCladArrayRef = false) {; 801 std::unique_ptr<TMethodCall>; 802 Method = std::make_unique<TMethodCall>();; 803 ; 804 TString prototypeArguments = """";; 805 if (HasVariables || HasParameters) {; 806 if (IsVectorized); 807 prototypeArguments.Append(""ROOT::Double_v*"");; 808 else; 809 prototypeArguments.Append(""Double_t*"");; 810 }; 811 auto AddDoublePtrParam = [&prototypeArguments]() {; 812 prototypeArguments.Append("","");; 813 prototypeArguments.Append(""Double_t*"");; 814 };; 815 if (HasParameters); 816 AddDoublePtrParam();; 817 ; 818 // We need an extra Double_t* for the gradient return result.; 819 if (AddCladArrayRef) {; 820 prototypeArguments.Append("","");; 821 prototypeArguments.Append(""Double_t*"");; 822 }; 823 ; 824 // Initialize the method call using real function name (cling name) defined; 825 // by Process",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:68024,Usability,clear,clear,68024,"eAll(""**"",""^"");; 1774 formula.ReplaceAll(""++"",""@""); // for linear functions; 1775 formula.ReplaceAll("" "","""");; 1776 HandlePolN(formula);; 1777 HandleParametrizedFunctions(formula);; 1778 HandleParamRanges(formula);; 1779 HandleFunctionArguments(formula);; 1780 HandleExponentiation(formula);; 1781 // ""++"" wil be dealt with Handle Linear; 1782 HandleLinear(formula);; 1783 // special case for ""--"" and ""++""; 1784 // (""++"" needs to be written with whitespace that is removed before but then we re-add it again; 1785 formula.ReplaceAll(""--"",""- -"");; 1786 formula.ReplaceAll(""++"",""+ +"");; 1787}; 1788 ; 1789////////////////////////////////////////////////////////////////////////////////; 1790/// prepare the formula to be executed; 1791/// normally is called with fFormula; 1792 ; 1793Bool_t TFormula::PrepareFormula(TString &formula); 1794{; 1795 fFuncs.clear();; 1796 fReadyToExecute = false;; 1797 ExtractFunctors(formula);; 1798 ; 1799 // update the expression with the new formula; 1800 fFormula = formula;; 1801 // save formula to parse variable and parameters for Cling; 1802 fClingInput = formula;; 1803 // replace all { and }; 1804 fFormula.ReplaceAll(""{"","""");; 1805 fFormula.ReplaceAll(""}"","""");; 1806 ; 1807 // std::cout << ""functors are extracted formula is "" << std::endl;; 1808 // std::cout << fFormula << std::endl << std::endl;; 1809 ; 1810 fFuncs.sort();; 1811 fFuncs.unique();; 1812 ; 1813 // use inputFormula for Cling; 1814 ProcessFormula(fClingInput);; 1815 ; 1816 // for pre-defined functions (need after processing); 1817 if (fNumber != 0) SetPredefinedParamNames();; 1818 ; 1819 return fReadyToExecute && fClingInitialized;; 1820}; 1821 ; 1822////////////////////////////////////////////////////////////////////////////////; 1823/// Extracts functors from formula, and put them in fFuncs.; 1824/// Simple grammar:; 1825/// - `<function>` := name(arg1,arg2...); 1826/// - `<variable>` := name; 1827/// - `<parameter>` := [number]; 1828/// - `<name>` := String containing lower and ",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:142012,Usability,clear,clear,142012,"uble> parValues = fClingParameters;; 3720 auto paramMap = fParams;; 3721 fNpar = fParams.size();; 3722 ; 3723 fLazyInitialization = true; // when reading we initialize the formula later to avoid problem of recursive Jitting; 3724 ; 3725 if (!TestBit(TFormula::kLambda) ) {; 3726 ; 3727 // save dimension read from the file (stored for V >=12); 3728 // and we check after initializing if it is the same; 3729 int ndim = fNdim;; 3730 fNdim = 0;; 3731 ; 3732 //std::cout << ""Streamer::Reading preprocess the formula "" << fFormula << "" ndim = "" << fNdim << "" npar = "" << fNpar << std::endl;; 3733 // for ( auto &p : fParams); 3734 // std::cout << ""parameter "" << p.first << "" index "" << p.second << std::endl;; 3735 ; 3736 fClingParameters.clear(); // need to be reset before re-initializing it; 3737 ; 3738 FillDefaults();; 3739 ; 3740 ; 3741 PreProcessFormula(fFormula);; 3742 ; 3743 //std::cout << ""Streamer::after pre-process the formula "" << fFormula << "" ndim = "" << fNdim << "" npar = "" << fNpar << std::endl;; 3744 ; 3745 PrepareFormula(fFormula);; 3746 ; 3747 //std::cout << ""Streamer::after prepared "" << fClingInput << "" ndim = "" << fNdim << "" npar = "" << fNpar << std::endl;; 3748 ; 3749 ; 3750 // restore parameter values; 3751 if (fNpar != (int) parValues.size() ) {; 3752 Error(""Streamer"",""number of parameters computed (%d) is not same as the stored parameters (%d)"",fNpar,int(parValues.size()) );; 3753 Print(""v"");; 3754 }; 3755 if (v > 11 && fNdim != ndim) {; 3756 Error(""Streamer"",""number of dimension computed (%d) is not same as the stored value (%d)"",fNdim, ndim );; 3757 Print(""v"");; 3758 }; 3759 }; 3760 else {; 3761 // we also delay the initialization of lamda expressions; 3762 if (!fLazyInitialization) {; 3763 bool ret = InitLambdaExpression(fFormula);; 3764 if (ret) {; 3765 fClingInitialized = true;; 3766 }; 3767 }else {; 3768 fReadyToExecute = true;; 3769 }; 3770 }; 3771 assert(fNpar == (int) parValues.size() );; 3772 std::copy( parValues.begin(), parValues.end(), fClingP",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFrame_8cxx_source.html:2588,Deployability,update,update,2588,"ame object is clicked.; 76 ; 77void TFrame::ExecuteEvent(Int_t event, Int_t px, Int_t py); 78{; 79 if (!gPad) return;; 80 ; 81 if (!gPad->IsEditable()) return;; 82 ; 83 TWbox::ExecuteEvent(event, px, py);; 84 ; 85 Bool_t opaque = gPad->OpaqueMoving();; 86 ; 87 if ((event == kButton1Up) || ((opaque)&&(event == kButton1Motion))) {; 88 // update pad margins; 89 Double_t xmin = gPad->GetUxmin();; 90 Double_t xmax = gPad->GetUxmax();; 91 Double_t ymin = gPad->GetUymin();; 92 Double_t ymax = gPad->GetUymax();; 93 Double_t dx = xmax-xmin;; 94 Double_t dy = ymax-ymin;; 95 Double_t leftMargin = (fX1-gPad->GetX1())/(gPad->GetX2()-gPad->GetX1());; 96 Double_t topMargin = (gPad->GetY2()-fY2)/(gPad->GetY2()-gPad->GetY1());; 97 Double_t rightMargin = (gPad->GetX2()-fX2)/(gPad->GetX2()-gPad->GetX1());; 98 Double_t bottomMargin = (fY1-gPad->GetY1())/(gPad->GetY2()-gPad->GetY1());; 99 // margin may get very small negative values; 100 if (leftMargin < 0) leftMargin = 0;; 101 if (topMargin < 0) topMargin = 0;; 102 if (rightMargin < 0) rightMargin = 0;; 103 if (bottomMargin < 0) bottomMargin = 0;; 104 gPad->SetLeftMargin(leftMargin);; 105 gPad->SetRightMargin(rightMargin);; 106 gPad->SetBottomMargin(bottomMargin);; 107 gPad->SetTopMargin(topMargin);; 108 Double_t dxr = dx/(1 - gPad->GetLeftMargin() - gPad->GetRightMargin());; 109 Double_t dyr = dy/(1 - gPad->GetBottomMargin() - gPad->GetTopMargin());; 110 ; 111 // Range() could change the size of the pad pixmap and therefore should; 112 // be called before the other paint routines; 113 gPad->Range(xmin - dxr*gPad->GetLeftMargin(),; 114 ymin - dyr*gPad->GetBottomMargin(),; 115 xmax + dxr*gPad->GetRightMargin(),; 116 ymax + dyr*gPad->GetTopMargin());; 117 gPad->RangeAxis(xmin, ymin, xmax, ymax);; 118 fX1 = xmin;; 119 fY1 = ymin;; 120 fX2 = xmax;; 121 fY2 = ymax;; 122 }; 123}; 124 ; 125////////////////////////////////////////////////////////////////////////////////; 126/// Paint this wbox with its current attributes.; 127 ; 128void TFrame",MatchSource.WIKI,doc/master/TFrame_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFrame_8cxx_source.html
https://root.cern/doc/master/TFrame_8cxx_source.html:3778,Integrability,rout,routines,3778,"ame object is clicked.; 76 ; 77void TFrame::ExecuteEvent(Int_t event, Int_t px, Int_t py); 78{; 79 if (!gPad) return;; 80 ; 81 if (!gPad->IsEditable()) return;; 82 ; 83 TWbox::ExecuteEvent(event, px, py);; 84 ; 85 Bool_t opaque = gPad->OpaqueMoving();; 86 ; 87 if ((event == kButton1Up) || ((opaque)&&(event == kButton1Motion))) {; 88 // update pad margins; 89 Double_t xmin = gPad->GetUxmin();; 90 Double_t xmax = gPad->GetUxmax();; 91 Double_t ymin = gPad->GetUymin();; 92 Double_t ymax = gPad->GetUymax();; 93 Double_t dx = xmax-xmin;; 94 Double_t dy = ymax-ymin;; 95 Double_t leftMargin = (fX1-gPad->GetX1())/(gPad->GetX2()-gPad->GetX1());; 96 Double_t topMargin = (gPad->GetY2()-fY2)/(gPad->GetY2()-gPad->GetY1());; 97 Double_t rightMargin = (gPad->GetX2()-fX2)/(gPad->GetX2()-gPad->GetX1());; 98 Double_t bottomMargin = (fY1-gPad->GetY1())/(gPad->GetY2()-gPad->GetY1());; 99 // margin may get very small negative values; 100 if (leftMargin < 0) leftMargin = 0;; 101 if (topMargin < 0) topMargin = 0;; 102 if (rightMargin < 0) rightMargin = 0;; 103 if (bottomMargin < 0) bottomMargin = 0;; 104 gPad->SetLeftMargin(leftMargin);; 105 gPad->SetRightMargin(rightMargin);; 106 gPad->SetBottomMargin(bottomMargin);; 107 gPad->SetTopMargin(topMargin);; 108 Double_t dxr = dx/(1 - gPad->GetLeftMargin() - gPad->GetRightMargin());; 109 Double_t dyr = dy/(1 - gPad->GetBottomMargin() - gPad->GetTopMargin());; 110 ; 111 // Range() could change the size of the pad pixmap and therefore should; 112 // be called before the other paint routines; 113 gPad->Range(xmin - dxr*gPad->GetLeftMargin(),; 114 ymin - dyr*gPad->GetBottomMargin(),; 115 xmax + dxr*gPad->GetRightMargin(),; 116 ymax + dyr*gPad->GetTopMargin());; 117 gPad->RangeAxis(xmin, ymin, xmax, ymax);; 118 fX1 = xmin;; 119 fY1 = ymin;; 120 fX2 = xmax;; 121 fY2 = ymax;; 122 }; 123}; 124 ; 125////////////////////////////////////////////////////////////////////////////////; 126/// Paint this wbox with its current attributes.; 127 ; 128void TFrame",MatchSource.WIKI,doc/master/TFrame_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFrame_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:1054,Availability,error,errors,1054,". ROOT: math/fumili/src/TFumili.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TFumili.cxx. Go to the documentation of this file. 1// @(#)root/fumili:$Id$; 2// Author: Stanislav Nesterov 07/05/2003; 3 ; 4 ; 5/** \class TFumili; 6 ; 7### FUMILI minimization package; 8 ; 9FUMILI is based on ideas, proposed by I.N. Silin [See NIM A440, 2000 (p431)].; 10It was converted from FORTRAN to C by Sergey Yaschenko <s.yaschenko@fz-juelich.de>; 11 ; 12 ; 13FUMILI is used to minimize Chi-square function or to search maximum of; 14likelihood function.; 15 ; 16Experimentally measured values \f$F_i\f$ are fitted with theoretical; 17functions \f$f_i({\vec x}_i,\vec\theta\,\,)\f$, where \f${\vec x}_i\f$ are; 18coordinates, and \f$\vec\theta\f$ -- vector of parameters.; 19 ; 20For better convergence Chi-square function has to be the following form; 21 ; 22\f[; 23{\chi^2\over2}={1\over2}\sum^n_{i=1}\left(f_i(\vec; 24x_i,\vec\theta\,\,)-F_i\over\sigma_i\right)^2 \tag{1}; 25\f]; 26 ; 27where \f$\sigma_i\f$ are errors of measured function.; 28 ; 29The minimum condition is; 30 ; 31\f[; 32{\partial\chi^2\over\partial\theta_i}=\sum^n_{j=1}{1\over\sigma^2_j}\cdot; 33{\partial f_j\over\partial\theta_i}\left[f_j(\vec; 34x_j,\vec\theta\,\,)-F_j\right]=0,\qquad i=1\ldots m\tag{2}; 35\f]; 36 ; 37where m is the quantity of parameters.; 38 ; 39Expanding left part of (2) over parameter increments and; 40retaining only linear terms one gets; 41 ; 42\f[; 43\left(\partial\chi^2\over\theta_i\right)_{\vec\theta={\vec\theta}^0}; 44+\sum_k\left(\partial^2\chi^2\over\partial\theta_i\partial\theta_k\right)_{; 45\vec\theta={\vec\theta}^0}\cdot(\theta_k-\theta_k^0); 46= 0\tag{3}; 47\f]; 48 ; 49Here \f${\vec\theta}_0\f$ is some initial value of parameters. In general case:; 50 ; 51\f[; 52{\partial^2\chi^2\over\partial\theta_i\partial\theta_k}=; 53\sum^n_{j=1}{1\over\sigma^2_j}{\partial f_j\over\theta_i}; 54{\partial f_j\over\theta_k} +; 55\sum^n_{j=1}{(f_j - F_j)\",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:2383,Availability,down,down,2383," ; 37where m is the quantity of parameters.; 38 ; 39Expanding left part of (2) over parameter increments and; 40retaining only linear terms one gets; 41 ; 42\f[; 43\left(\partial\chi^2\over\theta_i\right)_{\vec\theta={\vec\theta}^0}; 44+\sum_k\left(\partial^2\chi^2\over\partial\theta_i\partial\theta_k\right)_{; 45\vec\theta={\vec\theta}^0}\cdot(\theta_k-\theta_k^0); 46= 0\tag{3}; 47\f]; 48 ; 49Here \f${\vec\theta}_0\f$ is some initial value of parameters. In general case:; 50 ; 51\f[; 52{\partial^2\chi^2\over\partial\theta_i\partial\theta_k}=; 53\sum^n_{j=1}{1\over\sigma^2_j}{\partial f_j\over\theta_i}; 54{\partial f_j\over\theta_k} +; 55\sum^n_{j=1}{(f_j - F_j)\over\sigma^2_j}\cdot; 56{\partial^2f_j\over\partial\theta_i\partial\theta_k}\tag{4}; 57\f]; 58 ; 59In FUMILI algorithm for second derivatives of Chi-square approximate; 60expression is used when last term in (4) is discarded. It is often; 61done, not always wittingly, and sometimes causes troubles, for example,; 62if user wants to limit parameters with positive values by writing down; 63\f$\theta_i^2\f$ instead of \f$\theta_i\f$. FUMILI will fail if one tries; 64minimize \f$\chi^2 = g^2(\vec\theta)\f$ where g is arbitrary function.; 65 ; 66Approximate value is:; 67\f[{\partial^2\chi^2\over\partial\theta_i\partial\theta_k}\approx; 68Z_{ik}=; 69\sum^n_{j=1}{1\over\sigma^2_j}{\partial f_j\over\theta_i}; 70{\partial f_j\over\theta_k}\tag{5}; 71\f]; 72 ; 73Then the equations for parameter increments are; 74\f[\left(\partial\chi^2\over\partial\theta_i\right)_{\vec\theta={\vec\theta}^0}; 75+\sum_k Z_{ik}\cdot(\theta_k-\theta^0_k) = 0,; 76\qquad i=1\ldots m\tag{6}; 77\f]; 78 ; 79Remarkable feature of algorithm is the technique for step; 80restriction. For an initial value of parameter \f${\vec\theta}^0\f$ a; 81parallelepiped \f$P_0\f$ is built with the center at \f${\vec\theta}^0\f$ and; 82axes parallel to coordinate axes \f$\theta_i\f$. The lengths of; 83parallelepiped sides along i-th axis is \f$2b_i\f$, where \f$",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:7713,Availability,error,errors,7713,"xParam];; 192 fDF = new Double_t[fMaxParam];; 193 fGr = new Double_t[fMaxParam];; 194 fANames = new TString[fMaxParam];; 195 ; 196 // fX = new Double_t[10];; 197 ; 198 Int_t zSize = fMaxParam*(fMaxParam+1)/2;; 199 fZ0 = new Double_t[zSize];; 200 fZ = new Double_t[zSize];; 201 ; 202 for (Int_t i=0;i<fMaxParam;i++) {; 203 fA[i] =0.;; 204 fDF[i]=0.;; 205 fAMN[i]=gMINDOUBLE;; 206 fAMX[i]=gMAXDOUBLE;; 207 fPL0[i]=.1;; 208 fPL[i] =.1;; 209 fParamError[i]=0.;; 210 fANames[i]=Form(""%d"",i);; 211 }; 212}; 213 ; 214////////////////////////////////////////////////////////////////////////////////; 215/// TFumili destructor; 216 ; 217TFumili::~TFumili() {; 218 DeleteArrays();; 219 if (gROOT && !gROOT->TestBit(TObject::kInvalidObject)); 220 gROOT->GetListOfSpecials()->Remove(this);; 221 if (gFumili == this) gFumili = nullptr;; 222}; 223 ; 224////////////////////////////////////////////////////////////////////////////////; 225/// return a chisquare equivalent; 226 ; 227Double_t TFumili::Chisquare(Int_t npar, Double_t *params) const; 228{; 229 Double_t amin = 0;; 230 H1FitChisquareFumili(npar,params,amin,params,1);; 231 return 2*amin;; 232}; 233 ; 234////////////////////////////////////////////////////////////////////////////////; 235///; 236/// Resets all parameter names, values and errors to zero; 237///; 238/// Argument opt is ignored; 239///; 240/// NB: this procedure doesn't reset parameter limits; 241 ; 242void TFumili::Clear(Option_t *); 243{; 244 fNpar = fMaxParam;; 245 fNfcn = 0;; 246 for (Int_t i=0;i<fNpar;i++) {; 247 fA[i] =0.;; 248 fDF[i] =0.;; 249 fPL0[i] =.1;; 250 fPL[i] =.1;; 251 fAMN[i] = gMINDOUBLE;; 252 fAMX[i] = gMAXDOUBLE;; 253 fParamError[i]=0.;; 254 fANames[i]=Form(""%d"",i);; 255 }; 256}; 257 ; 258////////////////////////////////////////////////////////////////////////////////; 259/// Deallocates memory. Called from destructor TFumili::~TFumili; 260 ; 261void TFumili::DeleteArrays(){; 262 delete[] fCmPar;; 263 delete[] fANames;; 264 delete[] fDF;; 265 // delete[]",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:12090,Availability,error,errors,12090,"(npar,grad,fval,par,flag);; 353 return npar;; 354}; 355 ; 356 ; 357////////////////////////////////////////////////////////////////////////////////; 358/// Evaluate theoretical function; 359/// - df: array of partial derivatives; 360/// - X: vector of theoretical function argument; 361 ; 362Double_t TFumili::EvalTFN(Double_t * /*df*/, Double_t *X); 363{; 364 // for the time being disable possibility to compute derivatives; 365 //if(fTFN); 366 // return (*fTFN)(df,X,fA);; 367 //else if(fTFNF1) {; 368 ; 369 TF1 *f1 = (TF1*)fUserFunc;; 370 return f1->EvalPar(X,fA);; 371 //}; 372 //return 0.;; 373}; 374 ; 375////////////////////////////////////////////////////////////////////////////////; 376///; 377/// Execute MINUIT commands. MINImize, SIMplex, MIGrad and FUMili all; 378/// will call TFumili::Minimize method.; 379///; 380/// For full command list see; 381/// MINUIT. Reference Manual. CERN Program Library Long Writeup D506.; 382///; 383/// Improvement and errors calculation are not yet implemented as well; 384/// as Monte-Carlo seeking and minimization.; 385/// Contour commands are also unsupported.; 386///; 387/// - command : command string; 388/// - args : array of arguments; 389/// - nargs : number of arguments; 390 ; 391Int_t TFumili::ExecuteCommand(const char *command, Double_t *args, Int_t nargs){; 392 TString comand = command;; 393 static TString clower = ""abcdefghijklmnopqrstuvwxyz"";; 394 static TString cupper = ""ABCDEFGHIJKLMNOPQRSTUVWXYZ"";; 395 const Int_t nntot = 40;; 396 const char *cname[nntot] = {; 397 ""MINImize "", // 0 checked; 398 ""SEEk "", // 1 none; 399 ""SIMplex "", // 2 checked same as 0; 400 ""MIGrad "", // 3 checked same as 0; 401 ""MINOs "", // 4 none; 402 ""SET xxx "", // 5 lot of stuff; 403 ""SHOw xxx "", // 6 -----------; 404 ""TOP of pag"", // 7 .; 405 ""fiX "", // 8 .; 406 ""REStore "", // 9 .; 407 ""RELease "", // 10 .; 408 ""SCAn "", // 11 not yet implemented; 409 ""CONtour "", // 12 not yet implemented; 410 ""HESse "", // 13 not yet implemented; 411 ""SAVe "", // 1",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:14491,Availability,toler,tolerance,14491,"IENT "", // 35; 433 ""MATOUT "", // 36; 434 ""ERROR DEF "", // 37; 435 ""LIMITS "", // 38; 436 ""PUNCH ""}; // 39; 437 ; 438 ; 439 fCword = comand;; 440 fCword.ToUpper();; 441 if (nargs<=0) fCmPar[0] = 0;; 442 Int_t i;; 443 for(i=0;i<fMaxParam;i++) {; 444 if(i<nargs) fCmPar[i] = args[i];; 445 }; 446 /*; 447 fNmaxIter = int(fCmPar[0]);; 448 if (fNmaxIter <= 0) {; 449 fNmaxIter = fNpar*10 + 20 + fNpar*M*5;; 450 }; 451 fEPS = fCmPar[1];; 452 */; 453 //*-*- look for command in list CNAME . . . . . . . . . .; 454 TString ctemp = fCword(0,3);; 455 Int_t ind;; 456 for (ind = 0; ind < nntot; ++ind) {; 457 if (strncmp(ctemp.Data(),cname[ind],3) == 0) break;; 458 }; 459 if (ind==nntot) return -3; // Unknown command - input ignored; 460 if (fCword(0,4) == ""MINO"") ind=3;; 461 switch (ind) {; 462 case 0: case 3: case 2: case 28:; 463 // MINImize [maxcalls] [tolerance]; 464 // also SIMplex, MIGrad and FUMili; 465 if(nargs>=1); 466 fNmaxIter=TMath::Max(Int_t(fCmPar[0]),fNmaxIter); // fiXME!!; 467 if(nargs==2); 468 fEPS=fCmPar[1];; 469 return Minimize();; 470 case 1:; 471 // SEEk not implemented in this package; 472 return -10;; 473 ; 474 case 4: // MINos errors analysis not implemented; 475 return -10;; 476 ; 477 case 5: case 6: // SET xxx & SHOW xxx; 478 return ExecuteSetCommand(nargs);; 479 ; 480 case 7: // Obsolete command; 481 Printf(""1"");; 482 return 0;; 483 case 8: // fiX <parno> ....; 484 if (nargs<1) return -1; // No parameters specified; 485 for (i=0;i<nargs;i++) {; 486 Int_t parnum = Int_t(fCmPar[i])-1;; 487 FixParameter(parnum);; 488 }; 489 return 0;; 490 case 9: // REStore <code>; 491 if (nargs<1) return 0;; 492 if(fCmPar[0]==0.); 493 for (i=0;i<fNpar;i++); 494 ReleaseParameter(i);; 495 else; 496 if(fCmPar[0]==1.) {; 497 ReleaseParameter(fLastFixed);; 498 std::cout <<fLastFixed<<std::endl;; 499 }; 500 return 0;; 501 case 10: // RELease <parno> ...; 502 if (nargs<1) return -1; // No parameters specified; 503 for (i=0;i<nargs;i++) {; 504 Int_t parnum = Int_t(fCmPar[i])-1;; 505 Re",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:14792,Availability,error,errors,14792,"IENT "", // 35; 433 ""MATOUT "", // 36; 434 ""ERROR DEF "", // 37; 435 ""LIMITS "", // 38; 436 ""PUNCH ""}; // 39; 437 ; 438 ; 439 fCword = comand;; 440 fCword.ToUpper();; 441 if (nargs<=0) fCmPar[0] = 0;; 442 Int_t i;; 443 for(i=0;i<fMaxParam;i++) {; 444 if(i<nargs) fCmPar[i] = args[i];; 445 }; 446 /*; 447 fNmaxIter = int(fCmPar[0]);; 448 if (fNmaxIter <= 0) {; 449 fNmaxIter = fNpar*10 + 20 + fNpar*M*5;; 450 }; 451 fEPS = fCmPar[1];; 452 */; 453 //*-*- look for command in list CNAME . . . . . . . . . .; 454 TString ctemp = fCword(0,3);; 455 Int_t ind;; 456 for (ind = 0; ind < nntot; ++ind) {; 457 if (strncmp(ctemp.Data(),cname[ind],3) == 0) break;; 458 }; 459 if (ind==nntot) return -3; // Unknown command - input ignored; 460 if (fCword(0,4) == ""MINO"") ind=3;; 461 switch (ind) {; 462 case 0: case 3: case 2: case 28:; 463 // MINImize [maxcalls] [tolerance]; 464 // also SIMplex, MIGrad and FUMili; 465 if(nargs>=1); 466 fNmaxIter=TMath::Max(Int_t(fCmPar[0]),fNmaxIter); // fiXME!!; 467 if(nargs==2); 468 fEPS=fCmPar[1];; 469 return Minimize();; 470 case 1:; 471 // SEEk not implemented in this package; 472 return -10;; 473 ; 474 case 4: // MINos errors analysis not implemented; 475 return -10;; 476 ; 477 case 5: case 6: // SET xxx & SHOW xxx; 478 return ExecuteSetCommand(nargs);; 479 ; 480 case 7: // Obsolete command; 481 Printf(""1"");; 482 return 0;; 483 case 8: // fiX <parno> ....; 484 if (nargs<1) return -1; // No parameters specified; 485 for (i=0;i<nargs;i++) {; 486 Int_t parnum = Int_t(fCmPar[i])-1;; 487 FixParameter(parnum);; 488 }; 489 return 0;; 490 case 9: // REStore <code>; 491 if (nargs<1) return 0;; 492 if(fCmPar[0]==0.); 493 for (i=0;i<fNpar;i++); 494 ReleaseParameter(i);; 495 else; 496 if(fCmPar[0]==1.) {; 497 ReleaseParameter(fLastFixed);; 498 std::cout <<fLastFixed<<std::endl;; 499 }; 500 return 0;; 501 case 10: // RELease <parno> ...; 502 if (nargs<1) return -1; // No parameters specified; 503 for (i=0;i<nargs;i++) {; 504 Int_t parnum = Int_t(fCmPar[i])-1;; 505 Re",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:22060,Availability,error,errors,22060,"mum correlation of the parameter\n with arbitrary linear combination of other parameters)"");; 689 for(i=0;i<fNpar;i++) {; 690 printf(""%5s: "",fANames[i].Data());; 691 printf(""%11.3E\n"",TMath::Sqrt(1-1/((fR[i]!=0.)?fR[i]:1.)) );; 692 }; 693 std::cout<<std::endl;; 694 return 0;; 695 case 5: // PRIntout not implemented; 696 return -10;; 697 case 6: // NOGradient; 698 if(!setCommand) return 0;; 699 fGRAD = false;; 700 return 0;; 701 case 7: // GRAdient; 702 if(!setCommand) return 0;; 703 fGRAD = true;; 704 return 0;; 705 case 8: // ERRordef - now ignored; 706 return 0;; 707 case 9: // INPut - not implemented; 708 return -10;; 709 case 10: // WIDthpage - not implemented; 710 return -10;; 711 case 11: // LINesperpage - not implemented; 712 return -10;; 713 case 12: //NOWarnings; 714 if(!setCommand) return 0;; 715 fWARN = false;; 716 return 0;; 717 case 13: // WARnings; 718 if(!setCommand) return 0;; 719 fWARN = true;; 720 return 0;; 721 case 14: // RANdomgenerator - not implemented; 722 return -10;; 723 case 15: // TITle - ignored; 724 return 0;; 725 case 16: // STRategy - ignored; 726 return 0;; 727 case 17: // EIGenvalues - not implemented; 728 return -10;; 729 case 18: // PAGethrow - ignored; 730 return 0;; 731 case 19: // MINos errors - not implemented; 732 return -10;; 733 case 20: //EPSmachine; 734 if(!setCommand) {; 735 Printf(""Relative floating point precision RP=%E"",fRP);; 736 } else; 737 if (nargs>0) {; 738 Double_t pres=fCmPar[0];; 739 if (pres<1e-5 && pres>1e-34) fRP=pres;; 740 }; 741 return 0;; 742 case 21: // OUTputfile - not implemented; 743 return -10;; 744 case 22: // BATch - ignored; 745 return 0;; 746 case 23: // INTerative - ignored; 747 return 0;; 748 case 24: // VERsion; 749 if(setCommand) return 0;; 750 Printf(""FUMILI-ROOT version 0.1"");; 751 return 0;; 752 case 25: // reserved; 753 return 0;; 754 case 26: // NODebug; 755 if(!setCommand) return 0;; 756 fDEBUG = false;; 757 return 0;; 758 case 27: // DEBug; 759 if(!setCommand) return 0;; 760 fDEBUG = ",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:24573,Availability,error,error,24573,"rianceMatrix() const; 785{; 786 return fZ;; 787 ; 788}; 789 ; 790////////////////////////////////////////////////////////////////////////////////; 791/// Return element i,j from the covariance matrix; 792 ; 793Double_t TFumili::GetCovarianceMatrixElement(Int_t i, Int_t j) const; 794{; 795 if (!fZ) return 0;; 796 if (i < 0 || i >= fNpar || j < 0 || j >= fNpar) {; 797 Error(""GetCovarianceMatrixElement"",""Illegal arguments i=%d, j=%d"",i,j);; 798 return 0;; 799 }; 800 return fZ[j+fNpar*i];; 801}; 802 ; 803////////////////////////////////////////////////////////////////////////////////; 804/// Return the total number of parameters (free + fixed); 805 ; 806Int_t TFumili::GetNumberTotalParameters() const; 807{; 808 return fNpar;; 809}; 810 ; 811////////////////////////////////////////////////////////////////////////////////; 812/// Return the number of free parameters; 813 ; 814Int_t TFumili::GetNumberFreeParameters() const; 815{; 816 Int_t nfree = fNpar;; 817 for (Int_t i=0;i<fNpar;i++) {; 818 if (IsFixed(i)) nfree--;; 819 }; 820 return nfree;; 821}; 822 ; 823////////////////////////////////////////////////////////////////////////////////; 824/// Return error of parameter ipar; 825 ; 826Double_t TFumili::GetParError(Int_t ipar) const; 827{; 828 if (ipar<0 || ipar>=fNpar) return 0;; 829 else return fParamError[ipar];; 830}; 831 ; 832////////////////////////////////////////////////////////////////////////////////; 833/// Return current value of parameter ipar; 834 ; 835Double_t TFumili::GetParameter(Int_t ipar) const; 836{; 837 if (ipar<0 || ipar>=fNpar) return 0;; 838 else return fA[ipar];; 839}; 840 ; 841////////////////////////////////////////////////////////////////////////////////; 842/// Get various ipar parameter attributes:; 843///; 844/// - cname: parameter name; 845/// - value: parameter value; 846/// - verr: parameter error; 847/// - vlow: lower limit; 848/// - vhigh: upper limit; 849///; 850/// WARNING! parname must be suitably dimensioned in the calling function.",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:25260,Availability,error,error,25260,"rianceMatrix() const; 785{; 786 return fZ;; 787 ; 788}; 789 ; 790////////////////////////////////////////////////////////////////////////////////; 791/// Return element i,j from the covariance matrix; 792 ; 793Double_t TFumili::GetCovarianceMatrixElement(Int_t i, Int_t j) const; 794{; 795 if (!fZ) return 0;; 796 if (i < 0 || i >= fNpar || j < 0 || j >= fNpar) {; 797 Error(""GetCovarianceMatrixElement"",""Illegal arguments i=%d, j=%d"",i,j);; 798 return 0;; 799 }; 800 return fZ[j+fNpar*i];; 801}; 802 ; 803////////////////////////////////////////////////////////////////////////////////; 804/// Return the total number of parameters (free + fixed); 805 ; 806Int_t TFumili::GetNumberTotalParameters() const; 807{; 808 return fNpar;; 809}; 810 ; 811////////////////////////////////////////////////////////////////////////////////; 812/// Return the number of free parameters; 813 ; 814Int_t TFumili::GetNumberFreeParameters() const; 815{; 816 Int_t nfree = fNpar;; 817 for (Int_t i=0;i<fNpar;i++) {; 818 if (IsFixed(i)) nfree--;; 819 }; 820 return nfree;; 821}; 822 ; 823////////////////////////////////////////////////////////////////////////////////; 824/// Return error of parameter ipar; 825 ; 826Double_t TFumili::GetParError(Int_t ipar) const; 827{; 828 if (ipar<0 || ipar>=fNpar) return 0;; 829 else return fParamError[ipar];; 830}; 831 ; 832////////////////////////////////////////////////////////////////////////////////; 833/// Return current value of parameter ipar; 834 ; 835Double_t TFumili::GetParameter(Int_t ipar) const; 836{; 837 if (ipar<0 || ipar>=fNpar) return 0;; 838 else return fA[ipar];; 839}; 840 ; 841////////////////////////////////////////////////////////////////////////////////; 842/// Get various ipar parameter attributes:; 843///; 844/// - cname: parameter name; 845/// - value: parameter value; 846/// - verr: parameter error; 847/// - vlow: lower limit; 848/// - vhigh: upper limit; 849///; 850/// WARNING! parname must be suitably dimensioned in the calling function.",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:26218,Availability,error,errors,26218,"gh = 0;; 859 return -1;; 860 }; 861 strcpy(cname,fANames[ipar].Data());; 862 value = fA[ipar];; 863 verr = fParamError[ipar];; 864 vlow = fAMN[ipar];; 865 vhigh = fAMX[ipar];; 866 return 0;; 867}; 868 ; 869////////////////////////////////////////////////////////////////////////////////; 870/// Return name of parameter ipar; 871 ; 872const char *TFumili::GetParName(Int_t ipar) const; 873{; 874 if (ipar < 0 || ipar > fNpar) return """";; 875 return fANames[ipar].Data();; 876}; 877 ; 878////////////////////////////////////////////////////////////////////////////////; 879/// Return errors after MINOs; 880/// not implemented; 881 ; 882Int_t TFumili::GetErrors(Int_t ipar,Double_t &eplus, Double_t &eminus, Double_t &eparab, Double_t &globcc) const; 883{; 884 eparab = 0;; 885 globcc = 0;; 886 if (ipar<0 || ipar>=fNpar) {; 887 eplus = 0;; 888 eminus = 0;; 889 return -1;; 890 }; 891 eplus=fParamError[ipar];; 892 eminus=-eplus;; 893 return 0;; 894}; 895 ; 896////////////////////////////////////////////////////////////////////////////////; 897/// Return global fit parameters; 898/// - amin : chisquare; 899/// - edm : estimated distance to minimum; 900/// - errdef; 901/// - nvpar : number of variable parameters; 902/// - nparx : total number of parameters; 903 ; 904Int_t TFumili::GetStats(Double_t &amin, Double_t &edm, Double_t &errdef, Int_t &nvpar, Int_t &nparx) const; 905{; 906 amin = 2*fS;; 907 edm = fGT; //; 908 errdef = 0; // ??; 909 nparx = fNpar;; 910 nvpar = 0;; 911 for(Int_t ii=0; ii<fNpar; ii++) {; 912 if(fPL0[ii]>0.) nvpar++;; 913 }; 914 return 0;; 915}; 916 ; 917////////////////////////////////////////////////////////////////////////////////; 918/// Return Sum(log(i) i=0,n; 919/// used by log-likelihood fits; 920 ; 921Double_t TFumili::GetSumLog(Int_t n); 922{; 923 if (n < 0) return 0;; 924 if (n > fNlog) {; 925 if (fSumLog) delete [] fSumLog;; 926 fNlog = 2*n+1000;; 927 fSumLog = new Double_t[fNlog+1];; 928 Double_t fobs = 0;; 929 for (Int_t j=0;j<=fNlog;j++) {; 930 i",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:31307,Availability,error,error,31307,"/////////////////; 1071/// Main minimization procedure; 1072///; 1073/// This function is called after setting theoretical function; 1074/// by means of TFumili::SetUserFunc and initializing parameters.; 1075/// Optionally one can set FCN function (see TFumili::SetFCN and TFumili::Eval); 1076/// If FCN is undefined then user has to provide data arrays by calling; 1077/// TFumili::SetData procedure.; 1078///; 1079/// TFumili::Minimize return following values:; 1080/// - 0 - fit is converged; 1081/// - -2 - function is not decreasing (or bad derivatives); 1082/// - -3 - error estimations are infinite; 1083/// - -4 - maximum number of iterations is exceeded; 1084 ; 1085Int_t TFumili::Minimize(); 1086{; 1087 Int_t i;; 1088 // Flag3 - is fit is chi2 or likelihood? 0 - chi2, 1 - likelihood; 1089 fINDFLG[2]=0;; 1090 //; 1091 // Are the parameters outside of the boundaries ?; 1092 //; 1093 Int_t parn;; 1094 ; 1095 if(fFCN) {; 1096 Eval(parn,fGr,fS,fA,9); fNfcn++;; 1097 }; 1098 for( i = 0; i < fNpar; i++) {; 1099 if(fA[i] > fAMX[i]) fA[i] = fAMX[i];; 1100 if(fA[i] < fAMN[i]) fA[i] = fAMN[i];; 1101 }; 1102 ; 1103 Int_t nn2, n, fixFLG, ifix1, fi, nn3, nn1, n0;; 1104 Double_t t1;; 1105 Double_t sp, t, olds=0;; 1106 Double_t bi, aiMAX=0, amb;; 1107 Double_t afix, sigi, akap;; 1108 Double_t alambd, al, bm, abi, abm;; 1109 Int_t l1, k, ifix;; 1110 ; 1111 nn2=0;; 1112 ; 1113 // Number of parameters;; 1114 n=fNpar;; 1115 fixFLG=0;; 1116 ; 1117 // Exit flag; 1118 fENDFLG=0;; 1119 ; 1120 // Flag2; 1121 fINDFLG[1] = 0;; 1122 ifix1=-1;; 1123 fi=0;; 1124 nn3=0;; 1125 ; 1126 // Initialize param.step limits; 1127 for( i=0; i < n; i++) {; 1128 fR[i]=0.;; 1129 if ( fEPS > 0.) fParamError[i] = 0.;; 1130 fPL[i] = fPL0[i];; 1131 }; 1132 ; 1133L3: // Start Iteration; 1134 ; 1135 nn1 = 1;; 1136 t1 = 1.;; 1137 ; 1138L4: // New iteration; 1139 ; 1140 // fS - objective function value - zero first; 1141 fS = 0.;; 1142 // n0 - number of variable parameters in fit; 1143 n0 = 0;; 1144 for( i = 0; i < n;",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:36035,Availability,error,errors,36035,")) {; 1227 fPL[i] = 0.;; 1228 k1 = k1 + i1; // i1 stands for fZ-matrix row-number multiplier; 1229 /// - skip this row; 1230 // in case we are fixing parameter number i; 1231 } else {; 1232 for( j=0; j <= i; j++) {// cycle on columns of fZ-matrix; 1233 if (fPL0[j] > .0) {; 1234 // if parameter is not fixed then fZ = fZ0; 1235 // Now matrix fZ of other dimension; 1236 if (fPL[j] > .0) {; 1237 fZ[k2 -1] = fZ0[k1 -1];; 1238 k2=k2+1;; 1239 }; 1240 k1=k1+1;; 1241 }; 1242 }; 1243 }; 1244 }; 1245 else k1 = k1 + i1; // In case of negative fPL[i] - after mconvd; 1246 i1=i1+1; // Next row of fZ0; 1247 }; 1248 }; 1249 ; 1250 // INVERT fZ-matrix (mconvd() procedure); 1251 i1 = 1;; 1252 l = 1;; 1253 for( i = 0; i < n; i++) {// extract diagonal elements to fR-vector; 1254 if (fPL[i] > .0) {; 1255 fR[i] = fZ[l - 1];; 1256 i1 = i1+1;; 1257 l = l + i1;; 1258 }; 1259 }; 1260 ; 1261 n0 = i1 - 1;; 1262 InvertZ(n0);; 1263 ; 1264 // fZ matrix now is inverted; 1265 if (fINDFLG[0] != 0) { // problems; 1266 // some PLs now have negative values, try to reduce fZ-matrix again; 1267 fINDFLG[0] = 0;; 1268 fINDFLG[1] = 1; // errors can be infinite; 1269 fixFLG = fixFLG + 1;; 1270 fi = 0;; 1271 goto L19;; 1272 }; 1273 ; 1274 // ... CALCULATE THEORETICAL STEP TO MINIMUM; 1275 i1 = 1;; 1276 for( i = 0; i < n; i++) {; 1277 fDA[i]=0.; // initial step is zero; 1278 if (fPL[i] > .0) { // for non-fixed parameters; 1279 l1=1;; 1280 for( l = 0; l < n; l++) {; 1281 if (fPL[l] > .0) {; 1282 // Calculate offset of Z^-1(i1,l1) element in packed matrix; 1283 // because we skip fixed param numbers we need also i,l; 1284 if (i1 <= l1 ) k=l1*(l1-1)/2+i1;; 1285 else k=i1*(i1-1)/2+l1;; 1286 // dA_i = \sum (-Z^{-1}_{il}*grad(fS)_l); 1287 fDA[i]=fDA[i]-fGr[l]*fZ[k - 1];; 1288 l1=l1+1;; 1289 }; 1290 }; 1291 i1=i1+1;; 1292 }; 1293 }; 1294 // ... CHECK FOR PARAMETERS ON BOUNDARY; 1295 ; 1296 afix=0.;; 1297 ifix = -1;; 1298 i1 = 1;; 1299 l = i1;; 1300 for( i = 0; i < n; i++); 1301 if (fPL[i] > .0) {; 1302 sigi = TMath::Sq",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:40733,Availability,error,errors,40733," else {// we have fixed parameters; 1400 if (fENDFLG == 0) {; 1401 //... CHECK IF fiXING ON BOUND IS CORRECT; 1402 fENDFLG = 1;; 1403 fixFLG = 0;; 1404 ifix1=-1;; 1405 // release fixed parameters; 1406 for( i = 0; i < fNpar; i++) fPL[i] = fPL0[i];; 1407 fINDFLG[1] = 0;; 1408 // and repeat iteration; 1409 goto L19;; 1410 } else {; 1411 if( ifix1 >= 0) {; 1412 fi = fi + 1;; 1413 fENDFLG = 0;; 1414 }; 1415 }; 1416 }; 1417 } else { // fit does not converge; 1418 if( fixFLG != 0) {; 1419 if( fi > fixFLG ) {; 1420 //... CHECK IF fiXING ON BOUND IS CORRECT; 1421 fENDFLG = 1;; 1422 fixFLG = 0;; 1423 ifix1=-1;; 1424 for( i = 0; i < fNpar; i++) fPL[i] = fPL0[i];; 1425 fINDFLG[1] = 0;; 1426 goto L19;; 1427 } else {; 1428 fi = fi + 1;; 1429 fENDFLG = 0;; 1430 }; 1431 } else {; 1432 fi = fi + 1;; 1433 fENDFLG = 0;; 1434 }; 1435 }; 1436 }; 1437 ; 1438// L85:; 1439 // iteration number limit is exceeded; 1440 if(fENDFLG == 0 && nn3 >= fNmaxIter) fENDFLG=-3;; 1441 ; 1442 // fit errors are infinite;; 1443 if(fENDFLG > 0 && fINDFLG[1] > 0) fENDFLG=-2;; 1444 ; 1445 //MONITO (fS,fNpar,nn3,IT,fEPS,fGT,fAKAPPA,alambd);; 1446 if (fENDFLG == 0) { // make step; 1447 for ( i = 0; i < n; i++) fA[i] = fA[i] + fDA[i];; 1448 if (imax >= 0) fA[imax] = aiMAX;; 1449 olds=fS;; 1450 nn2=nn2+1;; 1451 nn3=nn3+1;; 1452 } else {; 1453 // fill covariant matrix VL; 1454 // fill parameter error matrix up; 1455 Int_t il;; 1456 il = 0;; 1457 for( Int_t ip = 0; ip < fNpar; ip++) {; 1458 if( fPL0[ip] > .0) {; 1459 for( Int_t jp = 0; jp <= ip; jp++) {; 1460 if(fPL0[jp] > .0) {; 1461 // VL[ind(ip,jp)] = fZ[il];; 1462 il = il + 1;; 1463 }; 1464 }; 1465 }; 1466 }; 1467 return fENDFLG - 1;; 1468 }; 1469 goto L3;; 1470}; 1471 ; 1472////////////////////////////////////////////////////////////////////////////////; 1473/// Prints fit results.; 1474///; 1475/// ikode is the type of printing parameters; 1476/// p is function value; 1477///; 1478/// - ikode = 1 - print values, errors and limits; 1479/// - ikode = 2 - print v",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:41126,Availability,error,error,41126," else {// we have fixed parameters; 1400 if (fENDFLG == 0) {; 1401 //... CHECK IF fiXING ON BOUND IS CORRECT; 1402 fENDFLG = 1;; 1403 fixFLG = 0;; 1404 ifix1=-1;; 1405 // release fixed parameters; 1406 for( i = 0; i < fNpar; i++) fPL[i] = fPL0[i];; 1407 fINDFLG[1] = 0;; 1408 // and repeat iteration; 1409 goto L19;; 1410 } else {; 1411 if( ifix1 >= 0) {; 1412 fi = fi + 1;; 1413 fENDFLG = 0;; 1414 }; 1415 }; 1416 }; 1417 } else { // fit does not converge; 1418 if( fixFLG != 0) {; 1419 if( fi > fixFLG ) {; 1420 //... CHECK IF fiXING ON BOUND IS CORRECT; 1421 fENDFLG = 1;; 1422 fixFLG = 0;; 1423 ifix1=-1;; 1424 for( i = 0; i < fNpar; i++) fPL[i] = fPL0[i];; 1425 fINDFLG[1] = 0;; 1426 goto L19;; 1427 } else {; 1428 fi = fi + 1;; 1429 fENDFLG = 0;; 1430 }; 1431 } else {; 1432 fi = fi + 1;; 1433 fENDFLG = 0;; 1434 }; 1435 }; 1436 }; 1437 ; 1438// L85:; 1439 // iteration number limit is exceeded; 1440 if(fENDFLG == 0 && nn3 >= fNmaxIter) fENDFLG=-3;; 1441 ; 1442 // fit errors are infinite;; 1443 if(fENDFLG > 0 && fINDFLG[1] > 0) fENDFLG=-2;; 1444 ; 1445 //MONITO (fS,fNpar,nn3,IT,fEPS,fGT,fAKAPPA,alambd);; 1446 if (fENDFLG == 0) { // make step; 1447 for ( i = 0; i < n; i++) fA[i] = fA[i] + fDA[i];; 1448 if (imax >= 0) fA[imax] = aiMAX;; 1449 olds=fS;; 1450 nn2=nn2+1;; 1451 nn3=nn3+1;; 1452 } else {; 1453 // fill covariant matrix VL; 1454 // fill parameter error matrix up; 1455 Int_t il;; 1456 il = 0;; 1457 for( Int_t ip = 0; ip < fNpar; ip++) {; 1458 if( fPL0[ip] > .0) {; 1459 for( Int_t jp = 0; jp <= ip; jp++) {; 1460 if(fPL0[jp] > .0) {; 1461 // VL[ind(ip,jp)] = fZ[il];; 1462 il = il + 1;; 1463 }; 1464 }; 1465 }; 1466 }; 1467 return fENDFLG - 1;; 1468 }; 1469 goto L3;; 1470}; 1471 ; 1472////////////////////////////////////////////////////////////////////////////////; 1473/// Prints fit results.; 1474///; 1475/// ikode is the type of printing parameters; 1476/// p is function value; 1477///; 1478/// - ikode = 1 - print values, errors and limits; 1479/// - ikode = 2 - print v",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:41710,Availability,error,errors,41710,"s=fS;; 1450 nn2=nn2+1;; 1451 nn3=nn3+1;; 1452 } else {; 1453 // fill covariant matrix VL; 1454 // fill parameter error matrix up; 1455 Int_t il;; 1456 il = 0;; 1457 for( Int_t ip = 0; ip < fNpar; ip++) {; 1458 if( fPL0[ip] > .0) {; 1459 for( Int_t jp = 0; jp <= ip; jp++) {; 1460 if(fPL0[jp] > .0) {; 1461 // VL[ind(ip,jp)] = fZ[il];; 1462 il = il + 1;; 1463 }; 1464 }; 1465 }; 1466 }; 1467 return fENDFLG - 1;; 1468 }; 1469 goto L3;; 1470}; 1471 ; 1472////////////////////////////////////////////////////////////////////////////////; 1473/// Prints fit results.; 1474///; 1475/// ikode is the type of printing parameters; 1476/// p is function value; 1477///; 1478/// - ikode = 1 - print values, errors and limits; 1479/// - ikode = 2 - print values, errors and steps; 1480/// - ikode = 3 - print values, errors, steps and derivatives; 1481/// - ikode = 4 - print only values and errors; 1482 ; 1483void TFumili::PrintResults(Int_t ikode,Double_t p) const; 1484{; 1485 TString exitStatus="""";; 1486 TString xsexpl="""";; 1487 TString colhdu[3],colhdl[3],cx2,cx3;; 1488 switch (fENDFLG) {; 1489 case 1:; 1490 exitStatus=""CONVERGED"";; 1491 break;; 1492 case -1:; 1493 exitStatus=""CONST FCN"";; 1494 xsexpl=""****\n* FUNCTION IS NOT DECREASING OR BAD DERIVATIVES\n****"";; 1495 break;; 1496 case -2:; 1497 exitStatus=""ERRORS INF"";; 1498 xsexpl=""****\n* ESTIMATED ERRORS ARE INfiNITE\n****"";; 1499 break;; 1500 case -3:; 1501 exitStatus=""MAX ITER."";; 1502 xsexpl=""****\n* MAXIMUM NUMBER OF ITERATIONS IS EXCEEDED\n****"";; 1503 break;; 1504 case -4:; 1505 exitStatus=""ZERO PROBAB"";; 1506 xsexpl=""****\n* PROBABILITY OF LIKLIHOOD FUNCTION IS NEGATIVE OR ZERO\n****"";; 1507 break;; 1508 default:; 1509 exitStatus=""UNDEfiNED"";; 1510 xsexpl=""****\n* fiT IS IN PROGRESS\n****"";; 1511 break;; 1512 }; 1513 if (ikode == 1) {; 1514 colhdu[0] = "" "";; 1515 colhdl[0] = "" ERROR "";; 1516 colhdu[1] = "" PHYSICAL"";; 1517 colhdu[2] = "" LIMITS "";; 1518 colhdl[1] = "" NEGATIVE "";; 1519 colhdl[2] = "" POSITIVE "";; 1520 }; 1521 i",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:41765,Availability,error,errors,41765,"s=fS;; 1450 nn2=nn2+1;; 1451 nn3=nn3+1;; 1452 } else {; 1453 // fill covariant matrix VL; 1454 // fill parameter error matrix up; 1455 Int_t il;; 1456 il = 0;; 1457 for( Int_t ip = 0; ip < fNpar; ip++) {; 1458 if( fPL0[ip] > .0) {; 1459 for( Int_t jp = 0; jp <= ip; jp++) {; 1460 if(fPL0[jp] > .0) {; 1461 // VL[ind(ip,jp)] = fZ[il];; 1462 il = il + 1;; 1463 }; 1464 }; 1465 }; 1466 }; 1467 return fENDFLG - 1;; 1468 }; 1469 goto L3;; 1470}; 1471 ; 1472////////////////////////////////////////////////////////////////////////////////; 1473/// Prints fit results.; 1474///; 1475/// ikode is the type of printing parameters; 1476/// p is function value; 1477///; 1478/// - ikode = 1 - print values, errors and limits; 1479/// - ikode = 2 - print values, errors and steps; 1480/// - ikode = 3 - print values, errors, steps and derivatives; 1481/// - ikode = 4 - print only values and errors; 1482 ; 1483void TFumili::PrintResults(Int_t ikode,Double_t p) const; 1484{; 1485 TString exitStatus="""";; 1486 TString xsexpl="""";; 1487 TString colhdu[3],colhdl[3],cx2,cx3;; 1488 switch (fENDFLG) {; 1489 case 1:; 1490 exitStatus=""CONVERGED"";; 1491 break;; 1492 case -1:; 1493 exitStatus=""CONST FCN"";; 1494 xsexpl=""****\n* FUNCTION IS NOT DECREASING OR BAD DERIVATIVES\n****"";; 1495 break;; 1496 case -2:; 1497 exitStatus=""ERRORS INF"";; 1498 xsexpl=""****\n* ESTIMATED ERRORS ARE INfiNITE\n****"";; 1499 break;; 1500 case -3:; 1501 exitStatus=""MAX ITER."";; 1502 xsexpl=""****\n* MAXIMUM NUMBER OF ITERATIONS IS EXCEEDED\n****"";; 1503 break;; 1504 case -4:; 1505 exitStatus=""ZERO PROBAB"";; 1506 xsexpl=""****\n* PROBABILITY OF LIKLIHOOD FUNCTION IS NEGATIVE OR ZERO\n****"";; 1507 break;; 1508 default:; 1509 exitStatus=""UNDEfiNED"";; 1510 xsexpl=""****\n* fiT IS IN PROGRESS\n****"";; 1511 break;; 1512 }; 1513 if (ikode == 1) {; 1514 colhdu[0] = "" "";; 1515 colhdl[0] = "" ERROR "";; 1516 colhdu[1] = "" PHYSICAL"";; 1517 colhdu[2] = "" LIMITS "";; 1518 colhdl[1] = "" NEGATIVE "";; 1519 colhdl[2] = "" POSITIVE "";; 1520 }; 1521 i",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:41819,Availability,error,errors,41819,"s=fS;; 1450 nn2=nn2+1;; 1451 nn3=nn3+1;; 1452 } else {; 1453 // fill covariant matrix VL; 1454 // fill parameter error matrix up; 1455 Int_t il;; 1456 il = 0;; 1457 for( Int_t ip = 0; ip < fNpar; ip++) {; 1458 if( fPL0[ip] > .0) {; 1459 for( Int_t jp = 0; jp <= ip; jp++) {; 1460 if(fPL0[jp] > .0) {; 1461 // VL[ind(ip,jp)] = fZ[il];; 1462 il = il + 1;; 1463 }; 1464 }; 1465 }; 1466 }; 1467 return fENDFLG - 1;; 1468 }; 1469 goto L3;; 1470}; 1471 ; 1472////////////////////////////////////////////////////////////////////////////////; 1473/// Prints fit results.; 1474///; 1475/// ikode is the type of printing parameters; 1476/// p is function value; 1477///; 1478/// - ikode = 1 - print values, errors and limits; 1479/// - ikode = 2 - print values, errors and steps; 1480/// - ikode = 3 - print values, errors, steps and derivatives; 1481/// - ikode = 4 - print only values and errors; 1482 ; 1483void TFumili::PrintResults(Int_t ikode,Double_t p) const; 1484{; 1485 TString exitStatus="""";; 1486 TString xsexpl="""";; 1487 TString colhdu[3],colhdl[3],cx2,cx3;; 1488 switch (fENDFLG) {; 1489 case 1:; 1490 exitStatus=""CONVERGED"";; 1491 break;; 1492 case -1:; 1493 exitStatus=""CONST FCN"";; 1494 xsexpl=""****\n* FUNCTION IS NOT DECREASING OR BAD DERIVATIVES\n****"";; 1495 break;; 1496 case -2:; 1497 exitStatus=""ERRORS INF"";; 1498 xsexpl=""****\n* ESTIMATED ERRORS ARE INfiNITE\n****"";; 1499 break;; 1500 case -3:; 1501 exitStatus=""MAX ITER."";; 1502 xsexpl=""****\n* MAXIMUM NUMBER OF ITERATIONS IS EXCEEDED\n****"";; 1503 break;; 1504 case -4:; 1505 exitStatus=""ZERO PROBAB"";; 1506 xsexpl=""****\n* PROBABILITY OF LIKLIHOOD FUNCTION IS NEGATIVE OR ZERO\n****"";; 1507 break;; 1508 default:; 1509 exitStatus=""UNDEfiNED"";; 1510 xsexpl=""****\n* fiT IS IN PROGRESS\n****"";; 1511 break;; 1512 }; 1513 if (ikode == 1) {; 1514 colhdu[0] = "" "";; 1515 colhdl[0] = "" ERROR "";; 1516 colhdu[1] = "" PHYSICAL"";; 1517 colhdu[2] = "" LIMITS "";; 1518 colhdl[1] = "" NEGATIVE "";; 1519 colhdl[2] = "" POSITIVE "";; 1520 }; 1521 i",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:41894,Availability,error,errors,41894,"s=fS;; 1450 nn2=nn2+1;; 1451 nn3=nn3+1;; 1452 } else {; 1453 // fill covariant matrix VL; 1454 // fill parameter error matrix up; 1455 Int_t il;; 1456 il = 0;; 1457 for( Int_t ip = 0; ip < fNpar; ip++) {; 1458 if( fPL0[ip] > .0) {; 1459 for( Int_t jp = 0; jp <= ip; jp++) {; 1460 if(fPL0[jp] > .0) {; 1461 // VL[ind(ip,jp)] = fZ[il];; 1462 il = il + 1;; 1463 }; 1464 }; 1465 }; 1466 }; 1467 return fENDFLG - 1;; 1468 }; 1469 goto L3;; 1470}; 1471 ; 1472////////////////////////////////////////////////////////////////////////////////; 1473/// Prints fit results.; 1474///; 1475/// ikode is the type of printing parameters; 1476/// p is function value; 1477///; 1478/// - ikode = 1 - print values, errors and limits; 1479/// - ikode = 2 - print values, errors and steps; 1480/// - ikode = 3 - print values, errors, steps and derivatives; 1481/// - ikode = 4 - print only values and errors; 1482 ; 1483void TFumili::PrintResults(Int_t ikode,Double_t p) const; 1484{; 1485 TString exitStatus="""";; 1486 TString xsexpl="""";; 1487 TString colhdu[3],colhdl[3],cx2,cx3;; 1488 switch (fENDFLG) {; 1489 case 1:; 1490 exitStatus=""CONVERGED"";; 1491 break;; 1492 case -1:; 1493 exitStatus=""CONST FCN"";; 1494 xsexpl=""****\n* FUNCTION IS NOT DECREASING OR BAD DERIVATIVES\n****"";; 1495 break;; 1496 case -2:; 1497 exitStatus=""ERRORS INF"";; 1498 xsexpl=""****\n* ESTIMATED ERRORS ARE INfiNITE\n****"";; 1499 break;; 1500 case -3:; 1501 exitStatus=""MAX ITER."";; 1502 xsexpl=""****\n* MAXIMUM NUMBER OF ITERATIONS IS EXCEEDED\n****"";; 1503 break;; 1504 case -4:; 1505 exitStatus=""ZERO PROBAB"";; 1506 xsexpl=""****\n* PROBABILITY OF LIKLIHOOD FUNCTION IS NEGATIVE OR ZERO\n****"";; 1507 break;; 1508 default:; 1509 exitStatus=""UNDEfiNED"";; 1510 xsexpl=""****\n* fiT IS IN PROGRESS\n****"";; 1511 break;; 1512 }; 1513 if (ikode == 1) {; 1514 colhdu[0] = "" "";; 1515 colhdl[0] = "" ERROR "";; 1516 colhdu[1] = "" PHYSICAL"";; 1517 colhdu[2] = "" LIMITS "";; 1518 colhdl[1] = "" NEGATIVE "";; 1519 colhdl[2] = "" POSITIVE "";; 1520 }; 1521 i",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:45625,Availability,error,error,45625,"////////////////////////////////////////////////////////////////////; 1594/// Sets pointer to data array provided by user.; 1595/// Necessary if SetFCN is not called.; 1596///; 1597/// - numpoints: number of experimental points; 1598/// - vecsize: size of data point vector + 2; 1599/// (for N-dimensional fit vecsize=N+2); 1600/// - exdata: data array with following format; 1601///; 1602/// - exdata[0] = ExpValue_0 - experimental data value number 0; 1603/// - exdata[1] = ExpSigma_0 - error of value number 0; 1604/// - exdata[2] = X_0[0]; 1605/// - exdata[3] = X_0[1]; 1606///; 1607/// - exdata[vecsize-1] = X_0[vecsize-3]; 1608/// - exdata[vecsize] = ExpValue_1; 1609/// - exdata[vecsize+1] = ExpSigma_1; 1610/// - exdata[vecsize+2] = X_1[0]; 1611///; 1612/// - exdata[vecsize*(numpoints-1)] = ExpValue_(numpoints-1); 1613///; 1614/// - exdata[vecsize*numpoints-1] = X_(numpoints-1)[vecsize-3]; 1615 ; 1616void TFumili::SetData(Double_t *exdata,Int_t numpoints,Int_t vecsize){; 1617 if(exdata){; 1618 fNED1 = numpoints;; 1619 fNED2 = vecsize;; 1620 fEXDA = exdata;; 1621 }; 1622}; 1623 ; 1624 ; 1625////////////////////////////////////////////////////////////////////////////////; 1626/// ret fit method (chisquare or log-likelihood); 1627 ; 1628void TFumili::SetFitMethod(const char *name); 1629{; 1630 if (!strcmp(name,""H1FitChisquare"")) SetFCN(H1FitChisquareFumili);; 1631 if (!strcmp(name,""H1FitLikelihood"")) SetFCN(H1FitLikelihoodFumili);; 1632 if (!strcmp(name,""GraphFitChisquare"")) SetFCN(GraphFitChisquareFumili);; 1633}; 1634 ; 1635////////////////////////////////////////////////////////////////////////////////; 1636/// Sets for parameter number ipar initial parameter value,; 1637/// name parname, initial error verr and limits vlow and vhigh; 1638/// - If vlow = vhigh but not equal to zero, parameter will be fixed.; 1639/// - If vlow = vhigh = 0, parameter is released and its limits are discarded; 1640 ; 1641Int_t TFumili::SetParameter(Int_t ipar,const char *parname,Double_t va",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:46860,Availability,error,error,46860,"////////////////////////////////////////////////////////////////////; 1594/// Sets pointer to data array provided by user.; 1595/// Necessary if SetFCN is not called.; 1596///; 1597/// - numpoints: number of experimental points; 1598/// - vecsize: size of data point vector + 2; 1599/// (for N-dimensional fit vecsize=N+2); 1600/// - exdata: data array with following format; 1601///; 1602/// - exdata[0] = ExpValue_0 - experimental data value number 0; 1603/// - exdata[1] = ExpSigma_0 - error of value number 0; 1604/// - exdata[2] = X_0[0]; 1605/// - exdata[3] = X_0[1]; 1606///; 1607/// - exdata[vecsize-1] = X_0[vecsize-3]; 1608/// - exdata[vecsize] = ExpValue_1; 1609/// - exdata[vecsize+1] = ExpSigma_1; 1610/// - exdata[vecsize+2] = X_1[0]; 1611///; 1612/// - exdata[vecsize*(numpoints-1)] = ExpValue_(numpoints-1); 1613///; 1614/// - exdata[vecsize*numpoints-1] = X_(numpoints-1)[vecsize-3]; 1615 ; 1616void TFumili::SetData(Double_t *exdata,Int_t numpoints,Int_t vecsize){; 1617 if(exdata){; 1618 fNED1 = numpoints;; 1619 fNED2 = vecsize;; 1620 fEXDA = exdata;; 1621 }; 1622}; 1623 ; 1624 ; 1625////////////////////////////////////////////////////////////////////////////////; 1626/// ret fit method (chisquare or log-likelihood); 1627 ; 1628void TFumili::SetFitMethod(const char *name); 1629{; 1630 if (!strcmp(name,""H1FitChisquare"")) SetFCN(H1FitChisquareFumili);; 1631 if (!strcmp(name,""H1FitLikelihood"")) SetFCN(H1FitLikelihoodFumili);; 1632 if (!strcmp(name,""GraphFitChisquare"")) SetFCN(GraphFitChisquareFumili);; 1633}; 1634 ; 1635////////////////////////////////////////////////////////////////////////////////; 1636/// Sets for parameter number ipar initial parameter value,; 1637/// name parname, initial error verr and limits vlow and vhigh; 1638/// - If vlow = vhigh but not equal to zero, parameter will be fixed.; 1639/// - If vlow = vhigh = 0, parameter is released and its limits are discarded; 1640 ; 1641Int_t TFumili::SetParameter(Int_t ipar,const char *parname,Double_t va",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:49667,Availability,error,error,49667,";; 1702 return -1; // indflg[0] = 1;; 1703 }; 1704 } else { // Chi2 method; 1705 sig = fEXDA[k2]; // sigma of experimental point; 1706 y = y - fEXDA[k1-1]; // f(x_i) - F_i; 1707 fS = fS + (y*y/(sig*sig))*.5; // simple chi2/2; 1708 }; 1709 Int_t n = 0;; 1710 for (i=0;i<fNpar;i++) {; 1711 if (fPL0[i]>0){; 1712 df[n] = df[i]/sig; // left only non-fixed param derivatives div by Sig; 1713 fGr[i] += df[n]*(y/sig);; 1714 n++;; 1715 }; 1716 }; 1717 l = 0;; 1718 for (i=0;i<n;i++); 1719 for (j=0;j<=i;j++); 1720 fZ[l++] += df[i]*df[j];; 1721 k2 += fNED2;; 1722 }; 1723 ; 1724 delete[] df;; 1725 delete[] x;; 1726 return 1;; 1727}; 1728 ; 1729 ; 1730////////////////////////////////////////////////////////////////////////////////; 1731/// Minimization function for H1s using a Chisquare method.; 1732/// Default method (function evaluated at center of bin); 1733/// for each point the cache contains the following info; 1734/// - 1D : bc,e,xc (bin content, error, x of center of bin); 1735/// - 2D : bc,e,xc,yc; 1736/// - 3D : bc,e,xc,yc,zc; 1737 ; 1738void TFumili::FitChisquare(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag); 1739{; 1740 Foption_t fitOption = GetFitOption();; 1741 if (fitOption.Integral) {; 1742 FitChisquareI(npar,gin,f,u,flag);; 1743 return;; 1744 }; 1745 Double_t cu,eu,fu,fsum;; 1746 Double_t x[3];; 1747 Double_t *zik=nullptr;; 1748 Double_t *pl0=nullptr;; 1749 ; 1750 TH1 *hfit = (TH1*)GetObjectFit();; 1751 TF1 *f1 = (TF1*)GetUserFunc();; 1752 Int_t nd = hfit->GetDimension();; 1753 Int_t j;; 1754 ; 1755 npar = f1->GetNpar();; 1756 SetParNumber(npar);; 1757 if(flag == 9) return;; 1758 zik = GetZ();; 1759 pl0 = GetPL0();; 1760 ; 1761 Double_t *df = new Double_t[npar];; 1762 f1->InitArgs(x,u);; 1763 f = 0;; 1764 ; 1765 Int_t npfit = 0;; 1766 Double_t *cache = fCache;; 1767 for (Int_t i=0;i<fNpoints;i++) {; 1768 if (nd > 2) x[2] = cache[4];; 1769 if (nd > 1) x[1] = cache[3];; 1770 x[0] = cache[2];; 1771 cu = cache[0];; 1772 TF1::RejectPoint(kFALSE);; 177",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:51657,Availability,error,error,51657,"784 gin[j] += df[n]*fsum;; 1785 n++;; 1786 }; 1787 }; 1788 Int_t l = 0;; 1789 for (j=0;j<n;j++); 1790 for (Int_t k=0;k<=j;k++); 1791 zik[l++] += df[j]*df[k];; 1792 }; 1793 f += .5*fsum*fsum;; 1794 npfit++;; 1795 cache += fPointSize;; 1796 }; 1797 f1->SetNumberFitPoints(npfit);; 1798 delete [] df;; 1799}; 1800 ; 1801////////////////////////////////////////////////////////////////////////////////; 1802/// Minimization function for H1s using a Chisquare method.; 1803/// The ""I""ntegral method is used; 1804/// for each point the cache contains the following info; 1805/// - 1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); 1806/// - 2D : bc,e,xc,xw,yc,yw; 1807/// - 3D : bc,e,xc,xw,yc,yw,zc,zw; 1808 ; 1809void TFumili::FitChisquareI(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag); 1810{; 1811 Double_t cu,eu,fu,fsum;; 1812 Double_t x[3];; 1813 Double_t *zik=nullptr;; 1814 Double_t *pl0=nullptr;; 1815 ; 1816 TH1 *hfit = (TH1*)GetObjectFit();; 1817 TF1 *f1 = (TF1*)GetUserFunc();; 1818 Int_t nd = hfit->GetDimension();; 1819 Int_t j;; 1820 ; 1821 f1->InitArgs(x,u);; 1822 npar = f1->GetNpar();; 1823 SetParNumber(npar);; 1824 if(flag == 9) return;; 1825 zik = GetZ();; 1826 pl0 = GetPL0();; 1827 ; 1828 Double_t *df=new Double_t[npar];; 1829 f = 0;; 1830 ; 1831 Int_t npfit = 0;; 1832 Double_t *cache = fCache;; 1833 for (Int_t i=0;i<fNpoints;i++) {; 1834 cu = cache[0];; 1835 TF1::RejectPoint(kFALSE);; 1836 f1->SetParameters(u);; 1837 if (nd < 2) {; 1838 fu = f1->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3])/cache[3];; 1839 } else if (nd < 3) {; 1840 fu = ((TF2*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5])/(cache[3]*cache[5]);; 1841 } else {; 1842 fu = ((TF3*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5],cache[6] - 0.5*cache[7],cache[6] + 0.5*cache[7])/(cache[3]*cache[5]*cache[7]);; 1843 }; 1844 if ",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:54267,Availability,error,error,54267," non-fixed param derivatives / by Sigma; 1854 gin[j] += df[n]*fsum;; 1855 n++;; 1856 }; 1857 }; 1858 Int_t l = 0;; 1859 for (j=0;j<n;j++); 1860 for (Int_t k=0;k<=j;k++); 1861 zik[l++] += df[j]*df[k];; 1862 }; 1863 f += .5*fsum*fsum;; 1864 npfit++;; 1865 cache += fPointSize;; 1866 }; 1867 f1->SetNumberFitPoints(npfit);; 1868 delete[] df;; 1869}; 1870 ; 1871////////////////////////////////////////////////////////////////////////////////; 1872/// Minimization function for H1s using a Likelihood method.; 1873/// Basically, it forms the likelihood by determining the Poisson; 1874/// probability that given a number of entries in a particular bin,; 1875/// the fit would predict it's value. This is then done for each bin,; 1876/// and the sum of the logs is taken as the likelihood.; 1877///; 1878/// Default method (function evaluated at center of bin); 1879/// for each point the cache contains the following info; 1880/// - 1D : bc,e,xc (bin content, error, x of center of bin); 1881/// - 2D : bc,e,xc,yc; 1882/// - 3D : bc,e,xc,yc,zc; 1883 ; 1884void TFumili::FitLikelihood(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag); 1885{; 1886 Foption_t fitOption = GetFitOption();; 1887 if (fitOption.Integral) {; 1888 FitLikelihoodI(npar,gin,f,u,flag);; 1889 return;; 1890 }; 1891 Double_t cu,fu,fobs,fsub;; 1892 Double_t dersum[100];; 1893 Double_t x[3];; 1894 Int_t icu;; 1895 ; 1896 TH1 *hfit = (TH1*)GetObjectFit();; 1897 TF1 *f1 = (TF1*)GetUserFunc();; 1898 Int_t nd = hfit->GetDimension();; 1899 Int_t j;; 1900 Double_t *zik = GetZ();; 1901 Double_t *pl0 = GetPL0();; 1902 ; 1903 npar = f1->GetNpar();; 1904 SetParNumber(npar);; 1905 if(flag == 9) return;; 1906 Double_t *df=new Double_t[npar];; 1907 if (flag == 2) for (j=0;j<npar;j++) dersum[j] = gin[j] = 0;; 1908 f1->InitArgs(x,u);; 1909 f = 0;; 1910 ; 1911 Int_t npfit = 0;; 1912 Double_t *cache = fCache;; 1913 for (Int_t i=0;i<fNpoints;i++) {; 1914 if (nd > 2) x[2] = cache[4];; 1915 if (nd > 1) x[1] = cache[3];; 1916 x[",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:56970,Availability,error,error,56970,"/////////////////////////////////; 1960/// Minimization function for H1s using a Likelihood method.; 1961/// Basically, it forms the likelihood by determining the Poisson; 1962/// probability that given a number of entries in a particular bin,; 1963/// the fit would predict it's value. This is then done for each bin,; 1964/// and the sum of the logs is taken as the likelihood.; 1965///; 1966/// The ""I""ntegral method is used; 1967/// for each point the cache contains the following info; 1968/// - 1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); 1969/// - 2D : bc,e,xc,xw,yc,yw; 1970/// - 3D : bc,e,xc,xw,yc,yw,zc,zw; 1971 ; 1972void TFumili::FitLikelihoodI(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag); 1973{; 1974 Double_t cu,fu,fobs,fsub;; 1975 Double_t dersum[100];; 1976 Double_t x[3];; 1977 Int_t icu;; 1978 ; 1979 TH1 *hfit = (TH1*)GetObjectFit();; 1980 TF1 *f1 = (TF1*)GetUserFunc();; 1981 Int_t nd = hfit->GetDimension();; 1982 Int_t j;; 1983 Double_t *zik = GetZ();; 1984 Double_t *pl0 = GetPL0();; 1985 ; 1986 Double_t *df=new Double_t[npar];; 1987 ; 1988 npar = f1->GetNpar();; 1989 SetParNumber(npar);; 1990 if(flag == 9) {delete [] df; return;}; 1991 if (flag == 2) for (j=0;j<npar;j++) dersum[j] = gin[j] = 0;; 1992 f1->InitArgs(x,u);; 1993 f = 0;; 1994 ; 1995 Int_t npfit = 0;; 1996 Double_t *cache = fCache;; 1997 for (Int_t i=0;i<fNpoints;i++) {; 1998 if (nd > 2) x[2] = cache[4];; 1999 if (nd > 1) x[1] = cache[3];; 2000 x[0] = cache[2];; 2001 cu = cache[0];; 2002 TF1::RejectPoint(kFALSE);; 2003 if (nd < 2) {; 2004 fu = f1->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3])/cache[3];; 2005 } else if (nd < 3) {; 2006 fu = ((TF2*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5])/(cache[3]*cache[5]);; 2007 } else {; 2008 fu = ((TF3*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5],cache[6] - 0.",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:61277,Availability,error,error,61277," Poisson; 2067/// probability that given a number of entries in a particular bin,; 2068/// the fit would predict it's value. This is then done for each bin,; 2069/// and the sum of the logs is taken as the likelihood.; 2070/// PDF: P=exp(-f(x_i))/[F_i]!*(f(x_i))^[F_i]; 2071/// where F_i - experimental value, f(x_i) - expected theoretical value; 2072/// [F_i] - integer part of F_i.; 2073/// drawback is that if F_i>Int_t - GetSumLog will fail; 2074/// for big F_i is faster to use Euler's Gamma-function; 2075 ; 2076void H1FitLikelihoodFumili(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag); 2077{; 2078 ; 2079 TFumili *hFitter = (TFumili*)TVirtualFitter::GetFitter();; 2080 hFitter->FitLikelihood(npar, gin, f, u, flag);; 2081}; 2082 ; 2083////////////////////////////////////////////////////////////////////////////////; 2084/// Minimization function for Graphs using a Chisquare method.; 2085/// In case of a TGraphErrors object, ex, the error along x, is projected; 2086/// along the y-direction by calculating the function at the points x-exlow and; 2087/// x+exhigh.; 2088///; 2089/// The chisquare is computed as the sum of the quantity below at each point:; 2090///; 2091/// (y - f(x))**2; 2092/// -----------------------------------; 2093/// ey**2 + (0.5*(exl + exh)*f'(x))**2; 2094///; 2095/// where x and y are the point coordinates and f'(x) is the derivative of function f(x).; 2096/// This method to approximate the uncertainty in y because of the errors in x, is called; 2097/// ""effective variance"" method.; 2098/// The improvement, compared to the previously used method (f(x+ exhigh) - f(x-exlow))/2; 2099/// is of (error of x)**2 order.; 2100///; 2101/// NOTE:; 2102///; 2103/// 1. By using the ""effective variance"" method a simple linear regression; 2104/// becomes a non-linear case , which takes several iterations; 2105/// instead of 0 as in the linear case .; 2106///; 2107/// 2. The effective variance technique assumes that there is no correlation; 2108//",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:61798,Availability,error,errors,61798," to use Euler's Gamma-function; 2075 ; 2076void H1FitLikelihoodFumili(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag); 2077{; 2078 ; 2079 TFumili *hFitter = (TFumili*)TVirtualFitter::GetFitter();; 2080 hFitter->FitLikelihood(npar, gin, f, u, flag);; 2081}; 2082 ; 2083////////////////////////////////////////////////////////////////////////////////; 2084/// Minimization function for Graphs using a Chisquare method.; 2085/// In case of a TGraphErrors object, ex, the error along x, is projected; 2086/// along the y-direction by calculating the function at the points x-exlow and; 2087/// x+exhigh.; 2088///; 2089/// The chisquare is computed as the sum of the quantity below at each point:; 2090///; 2091/// (y - f(x))**2; 2092/// -----------------------------------; 2093/// ey**2 + (0.5*(exl + exh)*f'(x))**2; 2094///; 2095/// where x and y are the point coordinates and f'(x) is the derivative of function f(x).; 2096/// This method to approximate the uncertainty in y because of the errors in x, is called; 2097/// ""effective variance"" method.; 2098/// The improvement, compared to the previously used method (f(x+ exhigh) - f(x-exlow))/2; 2099/// is of (error of x)**2 order.; 2100///; 2101/// NOTE:; 2102///; 2103/// 1. By using the ""effective variance"" method a simple linear regression; 2104/// becomes a non-linear case , which takes several iterations; 2105/// instead of 0 as in the linear case .; 2106///; 2107/// 2. The effective variance technique assumes that there is no correlation; 2108/// between the x and y coordinate .; 2109///; 2110/// In case the function lies below (above) the data point, ey is ey_low (ey_high).; 2111 ; 2112void GraphFitChisquareFumili(Int_t &npar, Double_t * gin, Double_t &f,; 2113 Double_t *u, Int_t flag); 2114{; 2115 Double_t cu,eu,exl,exh,ey,eux,fu,fsum;; 2116 Double_t x[1];; 2117 Int_t i, bin, npfits=0;; 2118 ; 2119 TFumili *grFitter = (TFumili*)TVirtualFitter::GetFitter();; 2120 TGraph *gr = (TGraph*)grFitter->GetObjectFit();",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:61970,Availability,error,error,61970,"g); 2077{; 2078 ; 2079 TFumili *hFitter = (TFumili*)TVirtualFitter::GetFitter();; 2080 hFitter->FitLikelihood(npar, gin, f, u, flag);; 2081}; 2082 ; 2083////////////////////////////////////////////////////////////////////////////////; 2084/// Minimization function for Graphs using a Chisquare method.; 2085/// In case of a TGraphErrors object, ex, the error along x, is projected; 2086/// along the y-direction by calculating the function at the points x-exlow and; 2087/// x+exhigh.; 2088///; 2089/// The chisquare is computed as the sum of the quantity below at each point:; 2090///; 2091/// (y - f(x))**2; 2092/// -----------------------------------; 2093/// ey**2 + (0.5*(exl + exh)*f'(x))**2; 2094///; 2095/// where x and y are the point coordinates and f'(x) is the derivative of function f(x).; 2096/// This method to approximate the uncertainty in y because of the errors in x, is called; 2097/// ""effective variance"" method.; 2098/// The improvement, compared to the previously used method (f(x+ exhigh) - f(x-exlow))/2; 2099/// is of (error of x)**2 order.; 2100///; 2101/// NOTE:; 2102///; 2103/// 1. By using the ""effective variance"" method a simple linear regression; 2104/// becomes a non-linear case , which takes several iterations; 2105/// instead of 0 as in the linear case .; 2106///; 2107/// 2. The effective variance technique assumes that there is no correlation; 2108/// between the x and y coordinate .; 2109///; 2110/// In case the function lies below (above) the data point, ey is ey_low (ey_high).; 2111 ; 2112void GraphFitChisquareFumili(Int_t &npar, Double_t * gin, Double_t &f,; 2113 Double_t *u, Int_t flag); 2114{; 2115 Double_t cu,eu,exl,exh,ey,eux,fu,fsum;; 2116 Double_t x[1];; 2117 Int_t i, bin, npfits=0;; 2118 ; 2119 TFumili *grFitter = (TFumili*)TVirtualFitter::GetFitter();; 2120 TGraph *gr = (TGraph*)grFitter->GetObjectFit();; 2121 TF1 *f1 = (TF1*)grFitter->GetUserFunc();; 2122 Foption_t fitOption = grFitter->GetFitOption();; 2123 ; 2124 Int_t n = gr->GetN",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:63854,Availability,error,errors,63854,"er::GetFitter();; 2120 TGraph *gr = (TGraph*)grFitter->GetObjectFit();; 2121 TF1 *f1 = (TF1*)grFitter->GetUserFunc();; 2122 Foption_t fitOption = grFitter->GetFitOption();; 2123 ; 2124 Int_t n = gr->GetN();; 2125 Double_t *gx = gr->GetX();; 2126 Double_t *gy = gr->GetY();; 2127 npar = f1->GetNpar();; 2128 ; 2129 grFitter->SetParNumber(npar);; 2130 ; 2131 if(flag == 9) return;; 2132 Double_t *zik = grFitter->GetZ();; 2133 Double_t *pl0 = grFitter->GetPL0();; 2134 Double_t *df = new Double_t[npar];; 2135 ; 2136 ; 2137 f1->InitArgs(x,u);; 2138 f = 0;; 2139 for (bin=0;bin<n;bin++) {; 2140 x[0] = gx[bin];; 2141 if (!f1->IsInside(x)) continue;; 2142 cu = gy[bin];; 2143 TF1::RejectPoint(kFALSE);; 2144 fu = f1->EvalPar(x,u);; 2145 if (TF1::RejectedPoint()) continue;; 2146 npfits++;; 2147 Double_t eusq=1.;; 2148 if (fitOption.W1) {; 2149 eu = 1.;; 2150 } else {; 2151 exh = gr->GetErrorXhigh(bin);; 2152 exl = gr->GetErrorXlow(bin);; 2153 ey = gr->GetErrorY(bin);; 2154 if (exl < 0) exl = 0;; 2155 if (exh < 0) exh = 0;; 2156 if (ey < 0) ey = 0;; 2157 if (exh > 0 && exl > 0) {; 2158// ""Effective variance"" method for projecting errors; 2159 eux = 0.5*(exl + exh)*f1->Derivative(x[0], u);; 2160 } else; 2161 eux = 0.;; 2162 eu = ey*ey+eux*eux;; 2163 if (eu <= 0) eu = 1;; 2164 eusq = TMath::Sqrt(eu);; 2165 }; 2166 grFitter->Derivatives(df,x);; 2167 n = 0;; 2168 fsum = (fu-cu)/eusq;; 2169 for (i=0;i<npar;i++) {; 2170 if (pl0[i]>0){; 2171 df[n] = df[i]/eusq;; 2172 // left only non-fixed param derivatives / by Sigma; 2173 gin[i] += df[n]*fsum;; 2174 n++;; 2175 }; 2176 }; 2177 Int_t l = 0;; 2178 for (i=0;i<n;i++); 2179 for (Int_t j=0;j<=i;j++); 2180 zik[l++] += df[i]*df[j];; 2181 f += .5*fsum*fsum;; 2182 ; 2183 }; 2184 delete [] df;; 2185 f1->SetNumberFitPoints(npfits);; 2186}; 2187 ; d#define d(i)Definition RSha256.hxx:102; f#define f(i)Definition RSha256.hxx:104; c#define c(i)Definition RSha256.hxx:101; e#define e(i)Definition RSha256.hxx:103; Int_tint Int_tDefinition RtypesCore.h:45; k",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:69363,Availability,error,error,69363,"n TF1.cxx:1468; TF1::RejectedPointstatic Bool_t RejectedPoint()See TF1::RejectPoint above.Definition TF1.cxx:3692; TF1::SetParametersvirtual void SetParameters(const Double_t *params)Definition TF1.h:677; TF1::IsInsidevirtual Bool_t IsInside(const Double_t *x) constreturn kTRUE if the point is inside the function rangeDefinition TF1.h:626; TF2A 2-Dim function with parameters.Definition TF2.h:29; TF3A 3-Dim function with parameters.Definition TF3.h:28; TFumiliDefinition TFumili.h:11; TFumili::GetParameterDouble_t GetParameter(Int_t ipar) const overrideReturn current value of parameter ipar.Definition TFumili.cxx:835; TFumili::fWARNBool_t fWARNwarningsDefinition TFumili.h:29; TFumili::fNED12Int_t fNED12fNED1+fNED2Definition TFumili.h:18; TFumili::DeleteArraysvoid DeleteArrays()Deallocates memory. Called from destructor TFumili::~TFumili.Definition TFumili.cxx:261; TFumili::fNumericDerivativesBool_t fNumericDerivativesDefinition TFumili.h:32; TFumili::GetParErrorDouble_t GetParError(Int_t ipar) const overrideReturn error of parameter ipar.Definition TFumili.cxx:826; TFumili::IsFixedBool_t IsFixed(Int_t ipar) const overrideReturn kTRUE if parameter ipar is fixed, kFALSE otherwise)Definition TFumili.cxx:1060; TFumili::fNED2Int_t fNED2K - Length of vector X plus 2 (for chi2)Definition TFumili.h:17; TFumili::GetCovarianceMatrixElementDouble_t GetCovarianceMatrixElement(Int_t i, Int_t j) const overrideReturn element i,j from the covariance matrix.Definition TFumili.cxx:793; TFumili::ExecuteCommandInt_t ExecuteCommand(const char *command, Double_t *args, Int_t nargs) overrideExecute MINUIT commands.Definition TFumili.cxx:391; TFumili::fNparInt_t fNparfNpar - number of parametersDefinition TFumili.h:19; TFumili::PrintResultsvoid PrintResults(Int_t k, Double_t p) const overridePrints fit results.Definition TFumili.cxx:1483; TFumili::GetNumberFreeParametersInt_t GetNumberFreeParameters() const overrideReturn the number of free parameters.Definition TFumili.cxx:814; TFumili::Get",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:73185,Availability,error,errorsDefinition,73185,"on TFumili.h:51; TFumili::fANamesTString * fANames[fMaxParam] Parameter namesDefinition TFumili.h:62; TFumili::GetPL0Double_t * GetPL0() constDefinition TFumili.h:95; TFumili::fPLDouble_t * fPL[fMaxParam] Limits for parameters step. If <0, then parameter is fixedDefinition TFumili.h:46; TFumili::EvalInt_t Eval(Int_t &npar, Double_t *grad, Double_t &fval, Double_t *par, Int_t flag)Evaluate the minimisation function.Definition TFumili.cxx:350; TFumili::fMaxParamInt_t fMaxParamDefinition TFumili.h:13; TFumili::SetParNumbervoid SetParNumber(Int_t ParNum)Definition TFumili.cxx:168; TFumili::SetDatavoid SetData(Double_t *, Int_t, Int_t)Sets pointer to data array provided by user.Definition TFumili.cxx:1616; TFumili::fINDFLGInt_t fINDFLG[5]internal flags;Definition TFumili.h:25; TFumili::EvalTFNDouble_t EvalTFN(Double_t *, Double_t *)Evaluate theoretical function.Definition TFumili.cxx:362; TFumili::GetZDouble_t * GetZ() constDefinition TFumili.h:102; TFumili::fParamErrorDouble_t * fParamError[fMaxParam] Parameter errorsDefinition TFumili.h:39; TFumili::ChisquareDouble_t Chisquare(Int_t npar, Double_t *params) const overridereturn a chisquare equivalentDefinition TFumili.cxx:227; TFumili::fENDFLGInt_t fENDFLGEnd flag of fit.Definition TFumili.h:24; TFumili::fRDouble_t * fR[fMaxParam] Correlation factorsDefinition TFumili.h:52; TFumili::fDADouble_t * fDA[fMaxParam] Parameter stepDefinition TFumili.h:49; TFumili::SetFitMethodvoid SetFitMethod(const char *name) overrideret fit method (chisquare or log-likelihood)Definition TFumili.cxx:1628; TFumili::fNstepDecInt_t fNstepDecfNstepDec - maximum number of step decreasing counterDefinition TFumili.h:20; TFumili::GetErrorsInt_t GetErrors(Int_t ipar, Double_t &eplus, Double_t &eminus, Double_t &eparab, Double_t &globcc) const overrideReturn errors after MINOs not implemented.Definition TFumili.cxx:882; TFumili::fZ0Double_t * fZ0[fMaxParam2] Matrix of approximate second derivatives of objective function This matrix is diagonal a...D",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:73968,Availability,error,errors,73968," flags;Definition TFumili.h:25; TFumili::EvalTFNDouble_t EvalTFN(Double_t *, Double_t *)Evaluate theoretical function.Definition TFumili.cxx:362; TFumili::GetZDouble_t * GetZ() constDefinition TFumili.h:102; TFumili::fParamErrorDouble_t * fParamError[fMaxParam] Parameter errorsDefinition TFumili.h:39; TFumili::ChisquareDouble_t Chisquare(Int_t npar, Double_t *params) const overridereturn a chisquare equivalentDefinition TFumili.cxx:227; TFumili::fENDFLGInt_t fENDFLGEnd flag of fit.Definition TFumili.h:24; TFumili::fRDouble_t * fR[fMaxParam] Correlation factorsDefinition TFumili.h:52; TFumili::fDADouble_t * fDA[fMaxParam] Parameter stepDefinition TFumili.h:49; TFumili::SetFitMethodvoid SetFitMethod(const char *name) overrideret fit method (chisquare or log-likelihood)Definition TFumili.cxx:1628; TFumili::fNstepDecInt_t fNstepDecfNstepDec - maximum number of step decreasing counterDefinition TFumili.h:20; TFumili::GetErrorsInt_t GetErrors(Int_t ipar, Double_t &eplus, Double_t &eminus, Double_t &eparab, Double_t &globcc) const overrideReturn errors after MINOs not implemented.Definition TFumili.cxx:882; TFumili::fZ0Double_t * fZ0[fMaxParam2] Matrix of approximate second derivatives of objective function This matrix is diagonal a...Definition TFumili.h:34; TFumili::fPL0Double_t * fPL0[fMaxParam] Step initial boundsDefinition TFumili.h:45; TFumili::fADouble_t * fA[fMaxParam] Fit parameter arrayDefinition TFumili.h:44; TFumili::fAKAPPADouble_t fAKAPPADefinition TFumili.h:60; TFumili::MinimizeInt_t Minimize()Main minimization procedure.Definition TFumili.cxx:1085; TFumili::fNmaxIterInt_t fNmaxIterfNmaxIter - maximum number of iterationsDefinition TFumili.h:22; TFumili::TFumiliTFumili(Int_t maxpar=25)Definition TFumili.cxx:129; TFumili::ExecuteSetCommandInt_t ExecuteSetCommand(Int_t)Called from TFumili::ExecuteCommand in case of ""SET xxx"" and ""SHOW xxx"".Definition TFumili.cxx:558; TFumili::fSDouble_t fSfS - objective function value (return)Definition TFumili.h:57; TFumili::f",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:75832,Availability,error,errors,75832,"Definition TFumili.cxx:558; TFumili::fSDouble_t fSfS - objective function value (return)Definition TFumili.h:57; TFumili::fEPSDouble_t fEPSfEPS - required precision of parameters. If fEPS<0 thenDefinition TFumili.h:58; TFumili::FitChisquareIvirtual void FitChisquareI(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag)Minimization function for H1s using a Chisquare method.Definition TFumili.cxx:1809; TFumili::fNfcnInt_t fNfcnNumber of FCN calls;.Definition TFumili.h:15; TFumili::fLastFixedInt_t fLastFixedLast fixed parameter number.Definition TFumili.h:23; TFumili::BuildArraysvoid BuildArrays()Allocates memory for internal arrays.Definition TFumili.cxx:182; TFumili::fZDouble_t * fZ[fMaxParam2] Inverse fZ0 matrix - covariance matrixDefinition TFumili.h:37; TFumili::fLogLikeBool_t fLogLikeLogLikelihood flag.Definition TFumili.h:31; TFumili::fNED1Int_t fNED1Number of experimental vectors X=(x1,x2,...xK)Definition TFumili.h:16; TFumili::Clearvoid Clear(Option_t *opt="""") overrideResets all parameter names, values and errors to zero.Definition TFumili.cxx:242; TFumili::fGrDouble_t * fGr[fMaxParam] Gradients of objective functionDefinition TFumili.h:38; TFumili::fGTDouble_t fGTExpected function change in next iteration.Definition TFumili.h:61; TFumili::SetParameterInt_t SetParameter(Int_t ipar, const char *parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh) overrideSets for parameter number ipar initial parameter value, name parname, initial error verr and limits v...Definition TFumili.cxx:1641; TFumili::fCwordTString fCwordCommand string.Definition TFumili.h:63; TFumili::FitLikelihoodIvirtual void FitLikelihoodI(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag)Minimization function for H1s using a Likelihood method.Definition TFumili.cxx:1972; TFumili::fRPDouble_t fRPPrecision of fit ( machine zero on CDC 6000) quite old yeh?Definition TFumili.h:59; TFumili::fCmParDouble_t * fCmPar[fMaxParam] parameters of commandsDefinition ",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:76282,Availability,error,error,76282,"efinition TFumili.cxx:1809; TFumili::fNfcnInt_t fNfcnNumber of FCN calls;.Definition TFumili.h:15; TFumili::fLastFixedInt_t fLastFixedLast fixed parameter number.Definition TFumili.h:23; TFumili::BuildArraysvoid BuildArrays()Allocates memory for internal arrays.Definition TFumili.cxx:182; TFumili::fZDouble_t * fZ[fMaxParam2] Inverse fZ0 matrix - covariance matrixDefinition TFumili.h:37; TFumili::fLogLikeBool_t fLogLikeLogLikelihood flag.Definition TFumili.h:31; TFumili::fNED1Int_t fNED1Number of experimental vectors X=(x1,x2,...xK)Definition TFumili.h:16; TFumili::Clearvoid Clear(Option_t *opt="""") overrideResets all parameter names, values and errors to zero.Definition TFumili.cxx:242; TFumili::fGrDouble_t * fGr[fMaxParam] Gradients of objective functionDefinition TFumili.h:38; TFumili::fGTDouble_t fGTExpected function change in next iteration.Definition TFumili.h:61; TFumili::SetParameterInt_t SetParameter(Int_t ipar, const char *parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh) overrideSets for parameter number ipar initial parameter value, name parname, initial error verr and limits v...Definition TFumili.cxx:1641; TFumili::fCwordTString fCwordCommand string.Definition TFumili.h:63; TFumili::FitLikelihoodIvirtual void FitLikelihoodI(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag)Minimization function for H1s using a Likelihood method.Definition TFumili.cxx:1972; TFumili::fRPDouble_t fRPPrecision of fit ( machine zero on CDC 6000) quite old yeh?Definition TFumili.h:59; TFumili::fCmParDouble_t * fCmPar[fMaxParam] parameters of commandsDefinition TFumili.h:55; TFumili::fDFDouble_t * fDF[fMaxParam] First derivatives of theoretical functionDefinition TFumili.h:54; TFumili::GetSumLogDouble_t GetSumLog(Int_t) overrideReturn Sum(log(i) i=0,n used by log-likelihood fits.Definition TFumili.cxx:921; TFumili::fSumLogDouble_t * fSumLog[fNlog]Definition TFumili.h:40; TFumili::fAMXDouble_t * fAMX[fMaxParam] Maximum param valueDefinition TFu",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:77670,Availability,error,error,77670,"ion of fit ( machine zero on CDC 6000) quite old yeh?Definition TFumili.h:59; TFumili::fCmParDouble_t * fCmPar[fMaxParam] parameters of commandsDefinition TFumili.h:55; TFumili::fDFDouble_t * fDF[fMaxParam] First derivatives of theoretical functionDefinition TFumili.h:54; TFumili::GetSumLogDouble_t GetSumLog(Int_t) overrideReturn Sum(log(i) i=0,n used by log-likelihood fits.Definition TFumili.cxx:921; TFumili::fSumLogDouble_t * fSumLog[fNlog]Definition TFumili.h:40; TFumili::fAMXDouble_t * fAMX[fMaxParam] Maximum param valueDefinition TFumili.h:50; TFumili::fDEBUGBool_t fDEBUGdebug infoDefinition TFumili.h:30; TFumili::fNlimMulInt_t fNlimMulfNlimMul - after fNlimMul successful iterations permits four-fold increasing of fPLDefinition TFumili.h:21; TFumili::fGRADBool_t fGRADuser calculated gradientsDefinition TFumili.h:28; TFumili::InvertZvoid InvertZ(Int_t)Inverts packed diagonal matrix Z by square-root method.Definition TFumili.cxx:945; TGraphErrors::GetErrorYDouble_t GetErrorY(Int_t bin) const overrideIt returns the error along Y at point i.Definition TGraphErrors.cxx:623; TGraphErrors::GetErrorXhighDouble_t GetErrorXhigh(Int_t bin) const overrideIt returns the error along X at point i.Definition TGraphErrors.cxx:635; TGraphErrors::GetErrorXlowDouble_t GetErrorXlow(Int_t bin) const overrideIt returns the error along X at point i.Definition TGraphErrors.cxx:647; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; TGraph::GetYDouble_t * GetY() constDefinition TGraph.h:140; TGraph::GetNInt_t GetN() constDefinition TGraph.h:132; TGraph::GetXDouble_t * GetX() constDefinition TGraph.h:139; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::GetDimensionvirtual Int_t GetDimension() constDefinition TH1.h:283; TNamed::SetNamevirtual void SetName(const char *name)Set the name of the TNamed.Definition TNamed.cxx:140; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) con",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:77818,Availability,error,error,77818,"Definition TFumili.h:55; TFumili::fDFDouble_t * fDF[fMaxParam] First derivatives of theoretical functionDefinition TFumili.h:54; TFumili::GetSumLogDouble_t GetSumLog(Int_t) overrideReturn Sum(log(i) i=0,n used by log-likelihood fits.Definition TFumili.cxx:921; TFumili::fSumLogDouble_t * fSumLog[fNlog]Definition TFumili.h:40; TFumili::fAMXDouble_t * fAMX[fMaxParam] Maximum param valueDefinition TFumili.h:50; TFumili::fDEBUGBool_t fDEBUGdebug infoDefinition TFumili.h:30; TFumili::fNlimMulInt_t fNlimMulfNlimMul - after fNlimMul successful iterations permits four-fold increasing of fPLDefinition TFumili.h:21; TFumili::fGRADBool_t fGRADuser calculated gradientsDefinition TFumili.h:28; TFumili::InvertZvoid InvertZ(Int_t)Inverts packed diagonal matrix Z by square-root method.Definition TFumili.cxx:945; TGraphErrors::GetErrorYDouble_t GetErrorY(Int_t bin) const overrideIt returns the error along Y at point i.Definition TGraphErrors.cxx:623; TGraphErrors::GetErrorXhighDouble_t GetErrorXhigh(Int_t bin) const overrideIt returns the error along X at point i.Definition TGraphErrors.cxx:635; TGraphErrors::GetErrorXlowDouble_t GetErrorXlow(Int_t bin) const overrideIt returns the error along X at point i.Definition TGraphErrors.cxx:647; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; TGraph::GetYDouble_t * GetY() constDefinition TGraph.h:140; TGraph::GetNInt_t GetN() constDefinition TGraph.h:132; TGraph::GetXDouble_t * GetX() constDefinition TGraph.h:139; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::GetDimensionvirtual Int_t GetDimension() constDefinition TH1.h:283; TNamed::SetNamevirtual void SetName(const char *name)Set the name of the TNamed.Definition TNamed.cxx:140; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue erro",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:77964,Availability,error,error,77964,"Double_t GetSumLog(Int_t) overrideReturn Sum(log(i) i=0,n used by log-likelihood fits.Definition TFumili.cxx:921; TFumili::fSumLogDouble_t * fSumLog[fNlog]Definition TFumili.h:40; TFumili::fAMXDouble_t * fAMX[fMaxParam] Maximum param valueDefinition TFumili.h:50; TFumili::fDEBUGBool_t fDEBUGdebug infoDefinition TFumili.h:30; TFumili::fNlimMulInt_t fNlimMulfNlimMul - after fNlimMul successful iterations permits four-fold increasing of fPLDefinition TFumili.h:21; TFumili::fGRADBool_t fGRADuser calculated gradientsDefinition TFumili.h:28; TFumili::InvertZvoid InvertZ(Int_t)Inverts packed diagonal matrix Z by square-root method.Definition TFumili.cxx:945; TGraphErrors::GetErrorYDouble_t GetErrorY(Int_t bin) const overrideIt returns the error along Y at point i.Definition TGraphErrors.cxx:623; TGraphErrors::GetErrorXhighDouble_t GetErrorXhigh(Int_t bin) const overrideIt returns the error along X at point i.Definition TGraphErrors.cxx:635; TGraphErrors::GetErrorXlowDouble_t GetErrorXlow(Int_t bin) const overrideIt returns the error along X at point i.Definition TGraphErrors.cxx:647; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; TGraph::GetYDouble_t * GetY() constDefinition TGraph.h:140; TGraph::GetNInt_t GetN() constDefinition TGraph.h:132; TGraph::GetXDouble_t * GetX() constDefinition TGraph.h:139; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::GetDimensionvirtual Int_t GetDimension() constDefinition TH1.h:283; TNamed::SetNamevirtual void SetName(const char *name)Set the name of the TNamed.Definition TNamed.cxx:140; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::kInvalidObject@ kInvalidObjectif object ctor succeeded but object should not be usedDefinition TObje",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:78777,Availability,error,error,78777,"(Int_t bin) const overrideIt returns the error along X at point i.Definition TGraphErrors.cxx:635; TGraphErrors::GetErrorXlowDouble_t GetErrorXlow(Int_t bin) const overrideIt returns the error along X at point i.Definition TGraphErrors.cxx:647; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; TGraph::GetYDouble_t * GetY() constDefinition TGraph.h:140; TGraph::GetNInt_t GetN() constDefinition TGraph.h:132; TGraph::GetXDouble_t * GetX() constDefinition TGraph.h:139; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::GetDimensionvirtual Int_t GetDimension() constDefinition TH1.h:283; TNamed::SetNamevirtual void SetName(const char *name)Set the name of the TNamed.Definition TNamed.cxx:140; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::kInvalidObject@ kInvalidObjectif object ctor succeeded but object should not be usedDefinition TObject.h:72; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; TString::ToUppervoid ToUpper()Change string to upper case.Definition TString.cxx:1195; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TVirtualFitter::fPointSizeInt_t fPointSizeNumber of words per point in the cache.Definition TVirtualFitter.h:40; TVirtualFitter::GetObjectFitvirtual TObject * GetObjectFit() constDefinition TVirtualFitter.h:77; TVirtualFitter::fUserFuncTObject * fUserFuncPointer to user theoretical function (a TF1*)Definition TVirtualFitter.h:44; TVirtualFitter::GetFitOptionvirtual Foption_t GetFitOption() constDefinition TVirtualFitter.h:73; TVirtualFitter::SetFCNvirtual void SetFCN(void(*fcn)(Int_t &, Double_t *, Double_t &f, Double_t *, Int",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:34604,Deployability,release,release,34604,"> 0) {; 1178 if (nn1 <= fNstepDec) {; 1179 t=2.*(fS-olds-fGT);; 1180 if (fINDFLG[0] == 0) {; 1181 if (TMath::Abs(fS-olds) <= sp && -fGT <= sp) goto L19;; 1182 if( 0.59*t < -fGT) goto L19;; 1183 t = -fGT/t;; 1184 if (t < 0.25 ) t = 0.25;; 1185 }; 1186 else t = 0.25;; 1187 fGT = fGT*t;; 1188 t1 = t1*t;; 1189 nn2=0;; 1190 for( i = 0; i < n; i++) {; 1191 if (fPL[i] > 0.) {; 1192 fA[i]=fA[i]-fDA[i];; 1193 fPL[i]=fPL[i]*t;; 1194 fDA[i]=fDA[i]*t;; 1195 fA[i]=fA[i]+fDA[i];; 1196 }; 1197 }; 1198 nn1=nn1+1;; 1199 goto L4;; 1200 }; 1201 }; 1202 ; 1203L19:; 1204 ; 1205 if(fINDFLG[0] != 0) {; 1206 fENDFLG=-4;; 1207 printf(""trying to execute an illegal jump at L85\n"");; 1208 //goto L85;; 1209 }; 1210 ; 1211 ; 1212 Int_t k1, k2, i1, j, l;; 1213 k1 = 1;; 1214 k2 = 1;; 1215 i1 = 1;; 1216 // In this cycle we removed from fZ contributions from fixed parameters; 1217 // We'll get fixed parameters after boundary check; 1218 for( i = 0; i < n; i++) {; 1219 if (fPL0[i] > .0) {; 1220 // if parameter was fixed - release it; 1221 if (fPL[i] == 0.) fPL[i]=fPL0[i];; 1222 if (fPL[i] > .0) { // ??? it is already non-zero; 1223 // if derivative is negative and we above maximum; 1224 // or vice versa then fix parameter again and increment k1 by i1; 1225 if ((fA[i] >= fAMX[i] && fGr[i] < 0.) ||; 1226 (fA[i] <= fAMN[i] && fGr[i] > 0.)) {; 1227 fPL[i] = 0.;; 1228 k1 = k1 + i1; // i1 stands for fZ-matrix row-number multiplier; 1229 /// - skip this row; 1230 // in case we are fixing parameter number i; 1231 } else {; 1232 for( j=0; j <= i; j++) {// cycle on columns of fZ-matrix; 1233 if (fPL0[j] > .0) {; 1234 // if parameter is not fixed then fZ = fZ0; 1235 // Now matrix fZ of other dimension; 1236 if (fPL[j] > .0) {; 1237 fZ[k2 -1] = fZ0[k1 -1];; 1238 k2=k2+1;; 1239 }; 1240 k1=k1+1;; 1241 }; 1242 }; 1243 }; 1244 }; 1245 else k1 = k1 + i1; // In case of negative fPL[i] - after mconvd; 1246 i1=i1+1; // Next row of fZ0; 1247 }; 1248 }; 1249 ; 1250 // INVERT fZ-matrix (mconvd() procedure); 1251 i1 = 1;; 1",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:39928,Deployability,release,release,39928,"ul ) {; 1378 if (TMath::Abs(fDA[i]/fPL[i]) > amb ) {; 1379 fPL[i] = 4.*fPL[i]; // increase parallelepiped; 1380 t1=4.; // flag - that fPL was increased; 1381 }; 1382 }; 1383 // cut step; 1384 fDA[i] = fDA[i]*alambd;; 1385 // expected function value change in next iteration; 1386 fGT = fGT + fDA[i]*fGr[i];; 1387 }; 1388 }; 1389 ; 1390 //.. CHECK IF MINIMUM ATTAINED AND SET EXIT MODE; 1391 // if expected fGT smaller than precision; 1392 // and other stuff; 1393 if (-fGT <= sp && t1 < 1. && alambd < 1.)fENDFLG = -1; // function is not decreasing; 1394 ; 1395 if (fENDFLG >= 0) {; 1396 if (fAKAPPA < TMath::Abs(fEPS)) { // fit is converging; 1397 if (fixFLG == 0); 1398 fENDFLG=1; // successful fit; 1399 else {// we have fixed parameters; 1400 if (fENDFLG == 0) {; 1401 //... CHECK IF fiXING ON BOUND IS CORRECT; 1402 fENDFLG = 1;; 1403 fixFLG = 0;; 1404 ifix1=-1;; 1405 // release fixed parameters; 1406 for( i = 0; i < fNpar; i++) fPL[i] = fPL0[i];; 1407 fINDFLG[1] = 0;; 1408 // and repeat iteration; 1409 goto L19;; 1410 } else {; 1411 if( ifix1 >= 0) {; 1412 fi = fi + 1;; 1413 fENDFLG = 0;; 1414 }; 1415 }; 1416 }; 1417 } else { // fit does not converge; 1418 if( fixFLG != 0) {; 1419 if( fi > fixFLG ) {; 1420 //... CHECK IF fiXING ON BOUND IS CORRECT; 1421 fENDFLG = 1;; 1422 fixFLG = 0;; 1423 ifix1=-1;; 1424 for( i = 0; i < fNpar; i++) fPL[i] = fPL0[i];; 1425 fINDFLG[1] = 0;; 1426 goto L19;; 1427 } else {; 1428 fi = fi + 1;; 1429 fENDFLG = 0;; 1430 }; 1431 } else {; 1432 fi = fi + 1;; 1433 fENDFLG = 0;; 1434 }; 1435 }; 1436 }; 1437 ; 1438// L85:; 1439 // iteration number limit is exceeded; 1440 if(fENDFLG == 0 && nn3 >= fNmaxIter) fENDFLG=-3;; 1441 ; 1442 // fit errors are infinite;; 1443 if(fENDFLG > 0 && fINDFLG[1] > 0) fENDFLG=-2;; 1444 ; 1445 //MONITO (fS,fNpar,nn3,IT,fEPS,fGT,fAKAPPA,alambd);; 1446 if (fENDFLG == 0) { // make step; 1447 for ( i = 0; i < n; i++) fA[i] = fA[i] + fDA[i];; 1448 if (imax >= 0) fA[imax] = aiMAX;; 1449 olds=fS;; 1450 nn2=nn2+1;; 1451 nn3=nn3+1;",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:47017,Deployability,release,released,47017,"//////////////////////////////////////////////////////////////////////; 1626/// ret fit method (chisquare or log-likelihood); 1627 ; 1628void TFumili::SetFitMethod(const char *name); 1629{; 1630 if (!strcmp(name,""H1FitChisquare"")) SetFCN(H1FitChisquareFumili);; 1631 if (!strcmp(name,""H1FitLikelihood"")) SetFCN(H1FitLikelihoodFumili);; 1632 if (!strcmp(name,""GraphFitChisquare"")) SetFCN(GraphFitChisquareFumili);; 1633}; 1634 ; 1635////////////////////////////////////////////////////////////////////////////////; 1636/// Sets for parameter number ipar initial parameter value,; 1637/// name parname, initial error verr and limits vlow and vhigh; 1638/// - If vlow = vhigh but not equal to zero, parameter will be fixed.; 1639/// - If vlow = vhigh = 0, parameter is released and its limits are discarded; 1640 ; 1641Int_t TFumili::SetParameter(Int_t ipar,const char *parname,Double_t value,Double_t verr,Double_t vlow, Double_t vhigh) {; 1642 if (ipar<0 || ipar>=fNpar) return -1;; 1643 fANames[ipar] = parname;; 1644 fA[ipar] = value;; 1645 fParamError[ipar] = verr;; 1646 if(vlow<vhigh) {; 1647 fAMN[ipar] = vlow;; 1648 fAMX[ipar] = vhigh;; 1649 } else {; 1650 if(vhigh<vlow) {; 1651 fAMN[ipar] = vhigh;; 1652 fAMX[ipar] = vlow;; 1653 }; 1654 if(vhigh==vlow) {; 1655 if(vhigh==0.) {; 1656 ReleaseParameter(ipar);; 1657 fAMN[ipar] = gMINDOUBLE;; 1658 fAMX[ipar] = gMAXDOUBLE;; 1659 }; 1660 if(vlow!=0) FixParameter(ipar);; 1661 }; 1662 }; 1663 return 0;; 1664}; 1665 ; 1666////////////////////////////////////////////////////////////////////////////////; 1667/// Evaluates objective function ( chi-square ), gradients and; 1668/// Z-matrix using data provided by user via TFumili::SetData; 1669 ; 1670Int_t TFumili::SGZ(); 1671{; 1672 fS = 0.;; 1673 Int_t i,j,l,k2=1,k1,ki=0;; 1674 Double_t *x = new Double_t[fNED2];; 1675 Double_t *df = new Double_t[fNpar];; 1676 Int_t nx = fNED2-2;; 1677 for (l=0;l<fNED1;l++) { // cycle on all exp. points; 1678 k1 = k2;; 1679 if (fLogLike) {; 1680 fNumericDeriva",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:35965,Energy Efficiency,reduce,reduce,35965,")) {; 1227 fPL[i] = 0.;; 1228 k1 = k1 + i1; // i1 stands for fZ-matrix row-number multiplier; 1229 /// - skip this row; 1230 // in case we are fixing parameter number i; 1231 } else {; 1232 for( j=0; j <= i; j++) {// cycle on columns of fZ-matrix; 1233 if (fPL0[j] > .0) {; 1234 // if parameter is not fixed then fZ = fZ0; 1235 // Now matrix fZ of other dimension; 1236 if (fPL[j] > .0) {; 1237 fZ[k2 -1] = fZ0[k1 -1];; 1238 k2=k2+1;; 1239 }; 1240 k1=k1+1;; 1241 }; 1242 }; 1243 }; 1244 }; 1245 else k1 = k1 + i1; // In case of negative fPL[i] - after mconvd; 1246 i1=i1+1; // Next row of fZ0; 1247 }; 1248 }; 1249 ; 1250 // INVERT fZ-matrix (mconvd() procedure); 1251 i1 = 1;; 1252 l = 1;; 1253 for( i = 0; i < n; i++) {// extract diagonal elements to fR-vector; 1254 if (fPL[i] > .0) {; 1255 fR[i] = fZ[l - 1];; 1256 i1 = i1+1;; 1257 l = l + i1;; 1258 }; 1259 }; 1260 ; 1261 n0 = i1 - 1;; 1262 InvertZ(n0);; 1263 ; 1264 // fZ matrix now is inverted; 1265 if (fINDFLG[0] != 0) { // problems; 1266 // some PLs now have negative values, try to reduce fZ-matrix again; 1267 fINDFLG[0] = 0;; 1268 fINDFLG[1] = 1; // errors can be infinite; 1269 fixFLG = fixFLG + 1;; 1270 fi = 0;; 1271 goto L19;; 1272 }; 1273 ; 1274 // ... CALCULATE THEORETICAL STEP TO MINIMUM; 1275 i1 = 1;; 1276 for( i = 0; i < n; i++) {; 1277 fDA[i]=0.; // initial step is zero; 1278 if (fPL[i] > .0) { // for non-fixed parameters; 1279 l1=1;; 1280 for( l = 0; l < n; l++) {; 1281 if (fPL[l] > .0) {; 1282 // Calculate offset of Z^-1(i1,l1) element in packed matrix; 1283 // because we skip fixed param numbers we need also i,l; 1284 if (i1 <= l1 ) k=l1*(l1-1)/2+i1;; 1285 else k=i1*(i1-1)/2+l1;; 1286 // dA_i = \sum (-Z^{-1}_{il}*grad(fS)_l); 1287 fDA[i]=fDA[i]-fGr[l]*fZ[k - 1];; 1288 l1=l1+1;; 1289 }; 1290 }; 1291 i1=i1+1;; 1292 }; 1293 }; 1294 // ... CHECK FOR PARAMETERS ON BOUNDARY; 1295 ; 1296 afix=0.;; 1297 ifix = -1;; 1298 i1 = 1;; 1299 l = i1;; 1300 for( i = 0; i < n; i++); 1301 if (fPL[i] > .0) {; 1302 sigi = TMath::Sq",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:37570,Energy Efficiency,reduce,reduce,37570,"0) {; 1282 // Calculate offset of Z^-1(i1,l1) element in packed matrix; 1283 // because we skip fixed param numbers we need also i,l; 1284 if (i1 <= l1 ) k=l1*(l1-1)/2+i1;; 1285 else k=i1*(i1-1)/2+l1;; 1286 // dA_i = \sum (-Z^{-1}_{il}*grad(fS)_l); 1287 fDA[i]=fDA[i]-fGr[l]*fZ[k - 1];; 1288 l1=l1+1;; 1289 }; 1290 }; 1291 i1=i1+1;; 1292 }; 1293 }; 1294 // ... CHECK FOR PARAMETERS ON BOUNDARY; 1295 ; 1296 afix=0.;; 1297 ifix = -1;; 1298 i1 = 1;; 1299 l = i1;; 1300 for( i = 0; i < n; i++); 1301 if (fPL[i] > .0) {; 1302 sigi = TMath::Sqrt(TMath::Abs(fZ[l - 1])); // calculate \sqrt{Z^{-1}_{ii}}; 1303 fR[i] = fR[i]*fZ[l - 1]; // Z_ii * Z^-1_ii; 1304 if (fEPS > .0) fParamError[i]=sigi;; 1305 if ((fA[i] >= fAMX[i] && fDA[i] > 0.) || (fA[i] <= fAMN[i]; 1306 && fDA[i] < .0)) {; 1307 // if parameter out of bounds and if step is making things worse; 1308 ; 1309 akap = TMath::Abs(fDA[i]/sigi);; 1310 // let's found maximum of dA/sigi - the worst of parameter steps; 1311 if (akap > afix) {; 1312 afix=akap;; 1313 ifix=i;; 1314 ifix1=i;; 1315 }; 1316 }; 1317 i1=i1+1;; 1318 l=l+i1;; 1319 }; 1320 if (ifix != -1) {; 1321 // so the worst parameter is found - fix it and exclude,; 1322 // reduce fZ-matrix again; 1323 fPL[ifix] = -1.;; 1324 fixFLG = fixFLG + 1;; 1325 fi = 0;; 1326 //.. REPEAT CALCULATION OF THEORETICAL STEP AFTER fiXING EACH PARAMETER; 1327 goto L19;; 1328 }; 1329 ; 1330 //... CALCULATE STEP CORRECTION FACTOR; 1331 ; 1332 alambd = 1.;; 1333 fAKAPPA = 0.;; 1334 Int_t imax;; 1335 imax = -1;; 1336 ; 1337 ; 1338 for( i = 0; i < n; i++) {; 1339 if (fPL[i] > .0) {; 1340 bm = fAMX[i] - fA[i];; 1341 abi = fA[i] + fPL[i]; // upper parameter limit; 1342 abm = fAMX[i];; 1343 if (fDA[i] <= .0) {; 1344 bm = fA[i] - fAMN[i];; 1345 abi = fA[i] - fPL[i]; // lower parameter limit; 1346 abm = fAMN[i];; 1347 }; 1348 bi = fPL[i];; 1349 // if parallelepiped boundary is crossing limits; 1350 // then reduce it (deforming); 1351 if ( bi > bm) {; 1352 bi = bm;; 1353 abi = abm;; 1354 }; 1355 // if c",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:38289,Energy Efficiency,reduce,reduce,38289,"=i1+1;; 1318 l=l+i1;; 1319 }; 1320 if (ifix != -1) {; 1321 // so the worst parameter is found - fix it and exclude,; 1322 // reduce fZ-matrix again; 1323 fPL[ifix] = -1.;; 1324 fixFLG = fixFLG + 1;; 1325 fi = 0;; 1326 //.. REPEAT CALCULATION OF THEORETICAL STEP AFTER fiXING EACH PARAMETER; 1327 goto L19;; 1328 }; 1329 ; 1330 //... CALCULATE STEP CORRECTION FACTOR; 1331 ; 1332 alambd = 1.;; 1333 fAKAPPA = 0.;; 1334 Int_t imax;; 1335 imax = -1;; 1336 ; 1337 ; 1338 for( i = 0; i < n; i++) {; 1339 if (fPL[i] > .0) {; 1340 bm = fAMX[i] - fA[i];; 1341 abi = fA[i] + fPL[i]; // upper parameter limit; 1342 abm = fAMX[i];; 1343 if (fDA[i] <= .0) {; 1344 bm = fA[i] - fAMN[i];; 1345 abi = fA[i] - fPL[i]; // lower parameter limit; 1346 abm = fAMN[i];; 1347 }; 1348 bi = fPL[i];; 1349 // if parallelepiped boundary is crossing limits; 1350 // then reduce it (deforming); 1351 if ( bi > bm) {; 1352 bi = bm;; 1353 abi = abm;; 1354 }; 1355 // if calculated step is out of bounds; 1356 if ( TMath::Abs(fDA[i]) > bi) {; 1357 // decrease step splitter alambdA if needed; 1358 al = TMath::Abs(bi/fDA[i]);; 1359 if (alambd > al) {; 1360 imax=i;; 1361 aiMAX=abi;; 1362 alambd=al;; 1363 }; 1364 }; 1365 // fAKAPPA - parameter will be <fEPS if fit is converged; 1366 akap = TMath::Abs(fDA[i]/fParamError[i]);; 1367 if (akap > fAKAPPA) fAKAPPA=akap;; 1368 }; 1369 }; 1370 //... CALCULATE NEW CORRECTED STEP; 1371 fGT = 0.;; 1372 amb = 1.e18;; 1373 // alambd - multiplier to split theoretical step dA; 1374 if (alambd > .0) amb = 0.25/alambd;; 1375 for( i = 0; i < n; i++) {; 1376 if (fPL[i] > .0) {; 1377 if (nn2 > fNlimMul ) {; 1378 if (TMath::Abs(fDA[i]/fPL[i]) > amb ) {; 1379 fPL[i] = 4.*fPL[i]; // increase parallelepiped; 1380 t1=4.; // flag - that fPL was increased; 1381 }; 1382 }; 1383 // cut step; 1384 fDA[i] = fDA[i]*alambd;; 1385 // expected function value change in next iteration; 1386 fGT = fGT + fDA[i]*fGr[i];; 1387 }; 1388 }; 1389 ; 1390 //.. CHECK IF MINIMUM ATTAINED AND SET EXIT MODE; 1391 // i",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:4548,Integrability,depend,dependent,4548,"ithm; 94of the likelihood function with the same idea - linearization of; 95function argument.; 96 ; 97*/; 98 ; 99 ; 100#include ""TFumili.h""; 101 ; 102#include <iostream>; 103#include ""TGraphAsymmErrors.h""; 104#include ""TF1.h""; 105#include ""TF2.h""; 106#include ""TF3.h""; 107#include ""TH1.h""; 108#include ""TMath.h""; 109#include ""TROOT.h""; 110#include ""TList.h""; 111#include ""TVirtualFitter.h""; 112 ; 113 ; 114extern void H1FitChisquareFumili(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag);; 115extern void H1FitLikelihoodFumili(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag);; 116extern void GraphFitChisquareFumili(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag);; 117 ; 118 ; 119ClassImp(TFumili);; 120 ; 121TFumili *gFumili=nullptr;; 122// Machine dependent values fiXME!!; 123// But don't set min=max=0 if param is unlimited; 124static const Double_t gMAXDOUBLE=1e300;; 125static const Double_t gMINDOUBLE=-1e300;; 126 ; 127////////////////////////////////////////////////////////////////////////////////; 128 ; 129TFumili::TFumili(Int_t maxpar); 130{//----------- FUMILI constructor ---------; 131 // maxpar is the maximum number of parameters used with TFumili object; 132 //; 133 fMaxParam = TMath::Max(maxpar,25);; 134 BuildArrays();; 135 ; 136 fNumericDerivatives = true;; 137 fLogLike = false;; 138 fNpar = fMaxParam;; 139 fGRAD = false;; 140 fWARN = true;; 141 fDEBUG = false;; 142 fNlog = 0;; 143 fSumLog = nullptr;; 144 fNED1 = 0;; 145 fNED2 = 0;; 146 fNED12 = fNED1+fNED2;; 147 fEXDA = nullptr;; 148 fFCN = nullptr;; 149 fNfcn = 0;; 150 fRP = 1.e-15; //precision; 151 fS = 1e10;; 152 fEPS =0.01;; 153 fENDFLG = 0;; 154 fNlimMul = 2;; 155 fNmaxIter= 150;; 156 fNstepDec= 3;; 157 fLastFixed = -1;; 158 ; 159 fAKAPPA = 0.;; 160 fGT = 0.;; 161 for (int i = 0; i<5; ++i) fINDFLG[i] = 0;; 162 ; 163 SetName(""Fumili"");; 164 gFumili = this;; 165 gROOT->GetListOfSpecials()->Add(gFumili);; 166}; 167 ; 168void TFumili::SetParNumber(Int_t ParN",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:78653,Integrability,message,message,78653," overrideIt returns the error along Y at point i.Definition TGraphErrors.cxx:623; TGraphErrors::GetErrorXhighDouble_t GetErrorXhigh(Int_t bin) const overrideIt returns the error along X at point i.Definition TGraphErrors.cxx:635; TGraphErrors::GetErrorXlowDouble_t GetErrorXlow(Int_t bin) const overrideIt returns the error along X at point i.Definition TGraphErrors.cxx:647; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; TGraph::GetYDouble_t * GetY() constDefinition TGraph.h:140; TGraph::GetNInt_t GetN() constDefinition TGraph.h:132; TGraph::GetXDouble_t * GetX() constDefinition TGraph.h:139; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::GetDimensionvirtual Int_t GetDimension() constDefinition TH1.h:283; TNamed::SetNamevirtual void SetName(const char *name)Set the name of the TNamed.Definition TNamed.cxx:140; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::kInvalidObject@ kInvalidObjectif object ctor succeeded but object should not be usedDefinition TObject.h:72; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; TString::ToUppervoid ToUpper()Change string to upper case.Definition TString.cxx:1195; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TVirtualFitter::fPointSizeInt_t fPointSizeNumber of words per point in the cache.Definition TVirtualFitter.h:40; TVirtualFitter::GetObjectFitvirtual TObject * GetObjectFit() constDefinition TVirtualFitter.h:77; TVirtualFitter::fUserFuncTObject * fUserFuncPointer to user theoretical function (a TF1*)Definition TVirtualFitter.h:44; TVirtualFitter::GetFitOptionvirtual Foption_t GetFitOption() constDef",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:78783,Integrability,message,message,78783,"(Int_t bin) const overrideIt returns the error along X at point i.Definition TGraphErrors.cxx:635; TGraphErrors::GetErrorXlowDouble_t GetErrorXlow(Int_t bin) const overrideIt returns the error along X at point i.Definition TGraphErrors.cxx:647; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; TGraph::GetYDouble_t * GetY() constDefinition TGraph.h:140; TGraph::GetNInt_t GetN() constDefinition TGraph.h:132; TGraph::GetXDouble_t * GetX() constDefinition TGraph.h:139; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::GetDimensionvirtual Int_t GetDimension() constDefinition TH1.h:283; TNamed::SetNamevirtual void SetName(const char *name)Set the name of the TNamed.Definition TNamed.cxx:140; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::kInvalidObject@ kInvalidObjectif object ctor succeeded but object should not be usedDefinition TObject.h:72; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; TString::ToUppervoid ToUpper()Change string to upper case.Definition TString.cxx:1195; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TVirtualFitter::fPointSizeInt_t fPointSizeNumber of words per point in the cache.Definition TVirtualFitter.h:40; TVirtualFitter::GetObjectFitvirtual TObject * GetObjectFit() constDefinition TVirtualFitter.h:77; TVirtualFitter::fUserFuncTObject * fUserFuncPointer to user theoretical function (a TF1*)Definition TVirtualFitter.h:44; TVirtualFitter::GetFitOptionvirtual Foption_t GetFitOption() constDefinition TVirtualFitter.h:73; TVirtualFitter::SetFCNvirtual void SetFCN(void(*fcn)(Int_t &, Double_t *, Double_t &f, Double_t *, Int",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:9996,Modifiability,variab,variable,9996,"//////; 280///; 281/// Calculates partial derivatives of theoretical function; 282///; 283/// Input:; 284/// - fX - vector of data point; 285///; 286/// Output:; 287/// - DF - array of derivatives; 288///; 289/// ARITHM.F: Converted from CERNLIB; 290 ; 291void TFumili::Derivatives(Double_t *df,Double_t *fX){; 292 Double_t ff,ai,hi,y,pi;; 293 y = EvalTFN(df,fX);; 294 for (Int_t i=0;i<fNpar;i++) {; 295 df[i]=0;; 296 if(fPL0[i]>0.) {; 297 ai = fA[i]; // save current parameter value; 298 hi = 0.01*fPL0[i]; // diff step; 299 pi = fRP*TMath::Abs(ai);; 300 if (hi<pi) hi = pi; // if diff step is less than precision; 301 fA[i] = ai+hi;; 302 ; 303 if (fA[i]>fAMX[i]) { // if param is out of limits; 304 fA[i] = ai-hi;; 305 hi = -hi;; 306 if (fA[i]<fAMN[i]) { // again out of bounds; 307 fA[i] = fAMX[i]; // set param to high limit; 308 hi = fAMX[i]-ai;; 309 if (fAMN[i]-ai+hi<0) { // if hi < (ai-fAMN); 310 fA[i]=fAMN[i];; 311 hi=fAMN[i]-ai;; 312 }; 313 }; 314 }; 315 ff = EvalTFN(df,fX);; 316 df[i] = (ff-y)/hi;; 317 fA[i] = ai;; 318 }; 319 }; 320}; 321 ; 322 ; 323////////////////////////////////////////////////////////////////////////////////; 324/// Evaluate the minimisation function; 325///; 326/// Input parameters:; 327/// - npar: number of currently variable parameters; 328/// - par: array of (constant and variable) parameters; 329/// - flag: Indicates what is to be calculated; 330/// - grad: array of gradients; 331///; 332/// Output parameters:; 333/// - fval: The calculated function value.; 334/// - grad: The vector of first derivatives.; 335///; 336/// The meaning of the parameters par is of course defined by the user,; 337/// who uses the values of those parameters to calculate their function value.; 338/// The starting values must be specified by the user.; 339///; 340/// Inside FCN user has to define Z-matrix by means TFumili::GetZ; 341/// and TFumili::Derivatives,; 342/// set theoretical function by means of TFumili::SetUserFunc,; 343/// but first - pass number of parame",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:10054,Modifiability,variab,variable,10054,"//////; 280///; 281/// Calculates partial derivatives of theoretical function; 282///; 283/// Input:; 284/// - fX - vector of data point; 285///; 286/// Output:; 287/// - DF - array of derivatives; 288///; 289/// ARITHM.F: Converted from CERNLIB; 290 ; 291void TFumili::Derivatives(Double_t *df,Double_t *fX){; 292 Double_t ff,ai,hi,y,pi;; 293 y = EvalTFN(df,fX);; 294 for (Int_t i=0;i<fNpar;i++) {; 295 df[i]=0;; 296 if(fPL0[i]>0.) {; 297 ai = fA[i]; // save current parameter value; 298 hi = 0.01*fPL0[i]; // diff step; 299 pi = fRP*TMath::Abs(ai);; 300 if (hi<pi) hi = pi; // if diff step is less than precision; 301 fA[i] = ai+hi;; 302 ; 303 if (fA[i]>fAMX[i]) { // if param is out of limits; 304 fA[i] = ai-hi;; 305 hi = -hi;; 306 if (fA[i]<fAMN[i]) { // again out of bounds; 307 fA[i] = fAMX[i]; // set param to high limit; 308 hi = fAMX[i]-ai;; 309 if (fAMN[i]-ai+hi<0) { // if hi < (ai-fAMN); 310 fA[i]=fAMN[i];; 311 hi=fAMN[i]-ai;; 312 }; 313 }; 314 }; 315 ff = EvalTFN(df,fX);; 316 df[i] = (ff-y)/hi;; 317 fA[i] = ai;; 318 }; 319 }; 320}; 321 ; 322 ; 323////////////////////////////////////////////////////////////////////////////////; 324/// Evaluate the minimisation function; 325///; 326/// Input parameters:; 327/// - npar: number of currently variable parameters; 328/// - par: array of (constant and variable) parameters; 329/// - flag: Indicates what is to be calculated; 330/// - grad: array of gradients; 331///; 332/// Output parameters:; 333/// - fval: The calculated function value.; 334/// - grad: The vector of first derivatives.; 335///; 336/// The meaning of the parameters par is of course defined by the user,; 337/// who uses the values of those parameters to calculate their function value.; 338/// The starting values must be specified by the user.; 339///; 340/// Inside FCN user has to define Z-matrix by means TFumili::GetZ; 341/// and TFumili::Derivatives,; 342/// set theoretical function by means of TFumili::SetUserFunc,; 343/// but first - pass number of parame",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:26831,Modifiability,variab,variable,26831,"gh = 0;; 859 return -1;; 860 }; 861 strcpy(cname,fANames[ipar].Data());; 862 value = fA[ipar];; 863 verr = fParamError[ipar];; 864 vlow = fAMN[ipar];; 865 vhigh = fAMX[ipar];; 866 return 0;; 867}; 868 ; 869////////////////////////////////////////////////////////////////////////////////; 870/// Return name of parameter ipar; 871 ; 872const char *TFumili::GetParName(Int_t ipar) const; 873{; 874 if (ipar < 0 || ipar > fNpar) return """";; 875 return fANames[ipar].Data();; 876}; 877 ; 878////////////////////////////////////////////////////////////////////////////////; 879/// Return errors after MINOs; 880/// not implemented; 881 ; 882Int_t TFumili::GetErrors(Int_t ipar,Double_t &eplus, Double_t &eminus, Double_t &eparab, Double_t &globcc) const; 883{; 884 eparab = 0;; 885 globcc = 0;; 886 if (ipar<0 || ipar>=fNpar) {; 887 eplus = 0;; 888 eminus = 0;; 889 return -1;; 890 }; 891 eplus=fParamError[ipar];; 892 eminus=-eplus;; 893 return 0;; 894}; 895 ; 896////////////////////////////////////////////////////////////////////////////////; 897/// Return global fit parameters; 898/// - amin : chisquare; 899/// - edm : estimated distance to minimum; 900/// - errdef; 901/// - nvpar : number of variable parameters; 902/// - nparx : total number of parameters; 903 ; 904Int_t TFumili::GetStats(Double_t &amin, Double_t &edm, Double_t &errdef, Int_t &nvpar, Int_t &nparx) const; 905{; 906 amin = 2*fS;; 907 edm = fGT; //; 908 errdef = 0; // ??; 909 nparx = fNpar;; 910 nvpar = 0;; 911 for(Int_t ii=0; ii<fNpar; ii++) {; 912 if(fPL0[ii]>0.) nvpar++;; 913 }; 914 return 0;; 915}; 916 ; 917////////////////////////////////////////////////////////////////////////////////; 918/// Return Sum(log(i) i=0,n; 919/// used by log-likelihood fits; 920 ; 921Double_t TFumili::GetSumLog(Int_t n); 922{; 923 if (n < 0) return 0;; 924 if (n > fNlog) {; 925 if (fSumLog) delete [] fSumLog;; 926 fNlog = 2*n+1000;; 927 fSumLog = new Double_t[fNlog+1];; 928 Double_t fobs = 0;; 929 for (Int_t j=0;j<=fNlog;j++) {; 930 i",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:28028,Modifiability,variab,variable,28028,"8 errdef = 0; // ??; 909 nparx = fNpar;; 910 nvpar = 0;; 911 for(Int_t ii=0; ii<fNpar; ii++) {; 912 if(fPL0[ii]>0.) nvpar++;; 913 }; 914 return 0;; 915}; 916 ; 917////////////////////////////////////////////////////////////////////////////////; 918/// Return Sum(log(i) i=0,n; 919/// used by log-likelihood fits; 920 ; 921Double_t TFumili::GetSumLog(Int_t n); 922{; 923 if (n < 0) return 0;; 924 if (n > fNlog) {; 925 if (fSumLog) delete [] fSumLog;; 926 fNlog = 2*n+1000;; 927 fSumLog = new Double_t[fNlog+1];; 928 Double_t fobs = 0;; 929 for (Int_t j=0;j<=fNlog;j++) {; 930 if (j > 1) fobs += TMath::Log(j);; 931 fSumLog[j] = fobs;; 932 }; 933 }; 934 if (fSumLog) return fSumLog[n];; 935 return 0;; 936}; 937 ; 938////////////////////////////////////////////////////////////////////////////////; 939/// Inverts packed diagonal matrix Z by square-root method.; 940/// Matrix elements corresponding to; 941/// fix parameters are removed.; 942///; 943/// - n: number of variable parameters; 944 ; 945void TFumili::InvertZ(Int_t n); 946{; 947 static Double_t am = 3.4e138;; 948 static Double_t rp = 5.0e-14;; 949 Double_t ap, aps, c, d;; 950 Double_t *r_1=fR;; 951 Double_t *pl_1=fPL;; 952 Double_t *z_1=fZ;; 953 Int_t i, k, l, ii, ki, li, kk, ni, ll, nk, nl, ir, lk;; 954 if (n < 1) {; 955 return;; 956 }; 957 --pl_1;; 958 --r_1;; 959 --z_1;; 960 aps = am / n;; 961 aps = sqrt(aps);; 962 ap = 1.0e0 / (aps * aps);; 963 ir = 0;; 964 for (i = 1; i <= n; ++i) {; 965 L1:; 966 ++ir;; 967 if (pl_1[ir] <= 0.0e0) goto L1;; 968 else goto L2;; 969 L2:; 970 ni = i * (i - 1) / 2;; 971 ii = ni + i;; 972 k = n + 1;; 973 if (z_1[ii] <= rp * TMath::Abs(r_1[ir]) || z_1[ii] <= ap) {; 974 goto L19;; 975 }; 976 z_1[ii] = 1.0e0 / sqrt(z_1[ii]);; 977 nl = ii - 1;; 978 L3:; 979 if (nl - ni <= 0) goto L5;; 980 else goto L4;; 981 L4:; 982 z_1[nl] *= z_1[ii];; 983 if (TMath::Abs(z_1[nl]) >= aps) {; 984 goto L16;; 985 }; 986 --nl;; 987 goto L3;; 988 L5:; 989 if (i - n >= 0) goto L12;; 990 else goto L6;; 991 L6:; 992 -",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:32667,Modifiability,variab,variable,32667,"++;; 1097 }; 1098 for( i = 0; i < fNpar; i++) {; 1099 if(fA[i] > fAMX[i]) fA[i] = fAMX[i];; 1100 if(fA[i] < fAMN[i]) fA[i] = fAMN[i];; 1101 }; 1102 ; 1103 Int_t nn2, n, fixFLG, ifix1, fi, nn3, nn1, n0;; 1104 Double_t t1;; 1105 Double_t sp, t, olds=0;; 1106 Double_t bi, aiMAX=0, amb;; 1107 Double_t afix, sigi, akap;; 1108 Double_t alambd, al, bm, abi, abm;; 1109 Int_t l1, k, ifix;; 1110 ; 1111 nn2=0;; 1112 ; 1113 // Number of parameters;; 1114 n=fNpar;; 1115 fixFLG=0;; 1116 ; 1117 // Exit flag; 1118 fENDFLG=0;; 1119 ; 1120 // Flag2; 1121 fINDFLG[1] = 0;; 1122 ifix1=-1;; 1123 fi=0;; 1124 nn3=0;; 1125 ; 1126 // Initialize param.step limits; 1127 for( i=0; i < n; i++) {; 1128 fR[i]=0.;; 1129 if ( fEPS > 0.) fParamError[i] = 0.;; 1130 fPL[i] = fPL0[i];; 1131 }; 1132 ; 1133L3: // Start Iteration; 1134 ; 1135 nn1 = 1;; 1136 t1 = 1.;; 1137 ; 1138L4: // New iteration; 1139 ; 1140 // fS - objective function value - zero first; 1141 fS = 0.;; 1142 // n0 - number of variable parameters in fit; 1143 n0 = 0;; 1144 for( i = 0; i < n; i++) {; 1145 fGr[i]=0.; // zero gradients; 1146 if (fPL0[i] > .0) {; 1147 n0=n0+1;; 1148 // new iteration - new parallelepiped; 1149 if (fPL[i] > .0) fPL0[i]=fPL[i];; 1150 }; 1151 }; 1152 Int_t nn0;; 1153 // Calculate number of fZ-matrix elements as nn0=1+2+..+n0; 1154 nn0 = n0*(n0+1)/2;; 1155 // if (nn0 >= 1) ????; 1156 // fZ-matrix is initialized; 1157 for( i=0; i < nn0; i++) fZ[i]=0.;; 1158 ; 1159 // Flag1; 1160 fINDFLG[0] = 0;; 1161 Int_t ijkl=1;; 1162 ; 1163 // Calculate fS - objective function, fGr - gradients, fZ - fZ-matrix; 1164 if(fFCN) {; 1165 Eval(parn,fGr,fS,fA,2);; 1166 fNfcn++;; 1167 } else; 1168 ijkl = SGZ();; 1169 if(!ijkl) return 10;; 1170 if (ijkl == -1) fINDFLG[0]=1;; 1171 ; 1172 // sp - scaled on fS machine precision; 1173 sp=fRP*TMath::Abs(fS);; 1174 ; 1175 // save fZ-matrix; 1176 for( i=0; i < nn0; i++) fZ0[i] = fZ[i];; 1177 if (nn3 > 0) {; 1178 if (nn1 <= fNstepDec) {; 1179 t=2.*(fS-olds-fGT);; 1180 if (fINDFLG[0] == 0) {; 1181",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:10864,Performance,perform,performs,10864,"(df,fX);; 316 df[i] = (ff-y)/hi;; 317 fA[i] = ai;; 318 }; 319 }; 320}; 321 ; 322 ; 323////////////////////////////////////////////////////////////////////////////////; 324/// Evaluate the minimisation function; 325///; 326/// Input parameters:; 327/// - npar: number of currently variable parameters; 328/// - par: array of (constant and variable) parameters; 329/// - flag: Indicates what is to be calculated; 330/// - grad: array of gradients; 331///; 332/// Output parameters:; 333/// - fval: The calculated function value.; 334/// - grad: The vector of first derivatives.; 335///; 336/// The meaning of the parameters par is of course defined by the user,; 337/// who uses the values of those parameters to calculate their function value.; 338/// The starting values must be specified by the user.; 339///; 340/// Inside FCN user has to define Z-matrix by means TFumili::GetZ; 341/// and TFumili::Derivatives,; 342/// set theoretical function by means of TFumili::SetUserFunc,; 343/// but first - pass number of parameters by TFumili::SetParNumber; 344///; 345/// Later values are determined by Fumili as it searches for the minimum; 346/// or performs whatever analysis is requested by the user.; 347///; 348/// The default function calls the function specified in SetFCN; 349 ; 350Int_t TFumili::Eval(Int_t& npar, Double_t *grad, Double_t &fval, Double_t *par, Int_t flag); 351{; 352 if (fFCN) (*fFCN)(npar,grad,fval,par,flag);; 353 return npar;; 354}; 355 ; 356 ; 357////////////////////////////////////////////////////////////////////////////////; 358/// Evaluate theoretical function; 359/// - df: array of partial derivatives; 360/// - X: vector of theoretical function argument; 361 ; 362Double_t TFumili::EvalTFN(Double_t * /*df*/, Double_t *X); 363{; 364 // for the time being disable possibility to compute derivatives; 365 //if(fTFN); 366 // return (*fTFN)(df,X,fA);; 367 //else if(fTFNF1) {; 368 ; 369 TF1 *f1 = (TF1*)fUserFunc;; 370 return f1->EvalPar(X,fA);; 371 //}; 372 //return 0.",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:49595,Performance,cache,cache,49595,";; 1702 return -1; // indflg[0] = 1;; 1703 }; 1704 } else { // Chi2 method; 1705 sig = fEXDA[k2]; // sigma of experimental point; 1706 y = y - fEXDA[k1-1]; // f(x_i) - F_i; 1707 fS = fS + (y*y/(sig*sig))*.5; // simple chi2/2; 1708 }; 1709 Int_t n = 0;; 1710 for (i=0;i<fNpar;i++) {; 1711 if (fPL0[i]>0){; 1712 df[n] = df[i]/sig; // left only non-fixed param derivatives div by Sig; 1713 fGr[i] += df[n]*(y/sig);; 1714 n++;; 1715 }; 1716 }; 1717 l = 0;; 1718 for (i=0;i<n;i++); 1719 for (j=0;j<=i;j++); 1720 fZ[l++] += df[i]*df[j];; 1721 k2 += fNED2;; 1722 }; 1723 ; 1724 delete[] df;; 1725 delete[] x;; 1726 return 1;; 1727}; 1728 ; 1729 ; 1730////////////////////////////////////////////////////////////////////////////////; 1731/// Minimization function for H1s using a Chisquare method.; 1732/// Default method (function evaluated at center of bin); 1733/// for each point the cache contains the following info; 1734/// - 1D : bc,e,xc (bin content, error, x of center of bin); 1735/// - 2D : bc,e,xc,yc; 1736/// - 3D : bc,e,xc,yc,zc; 1737 ; 1738void TFumili::FitChisquare(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag); 1739{; 1740 Foption_t fitOption = GetFitOption();; 1741 if (fitOption.Integral) {; 1742 FitChisquareI(npar,gin,f,u,flag);; 1743 return;; 1744 }; 1745 Double_t cu,eu,fu,fsum;; 1746 Double_t x[3];; 1747 Double_t *zik=nullptr;; 1748 Double_t *pl0=nullptr;; 1749 ; 1750 TH1 *hfit = (TH1*)GetObjectFit();; 1751 TF1 *f1 = (TF1*)GetUserFunc();; 1752 Int_t nd = hfit->GetDimension();; 1753 Int_t j;; 1754 ; 1755 npar = f1->GetNpar();; 1756 SetParNumber(npar);; 1757 if(flag == 9) return;; 1758 zik = GetZ();; 1759 pl0 = GetPL0();; 1760 ; 1761 Double_t *df = new Double_t[npar];; 1762 f1->InitArgs(x,u);; 1763 f = 0;; 1764 ; 1765 Int_t npfit = 0;; 1766 Double_t *cache = fCache;; 1767 for (Int_t i=0;i<fNpoints;i++) {; 1768 if (nd > 2) x[2] = cache[4];; 1769 if (nd > 1) x[1] = cache[3];; 1770 x[0] = cache[2];; 1771 cu = cache[0];; 1772 TF1::RejectPoint(kFALSE);; 177",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:50511,Performance,cache,cache,50511,"r each point the cache contains the following info; 1734/// - 1D : bc,e,xc (bin content, error, x of center of bin); 1735/// - 2D : bc,e,xc,yc; 1736/// - 3D : bc,e,xc,yc,zc; 1737 ; 1738void TFumili::FitChisquare(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag); 1739{; 1740 Foption_t fitOption = GetFitOption();; 1741 if (fitOption.Integral) {; 1742 FitChisquareI(npar,gin,f,u,flag);; 1743 return;; 1744 }; 1745 Double_t cu,eu,fu,fsum;; 1746 Double_t x[3];; 1747 Double_t *zik=nullptr;; 1748 Double_t *pl0=nullptr;; 1749 ; 1750 TH1 *hfit = (TH1*)GetObjectFit();; 1751 TF1 *f1 = (TF1*)GetUserFunc();; 1752 Int_t nd = hfit->GetDimension();; 1753 Int_t j;; 1754 ; 1755 npar = f1->GetNpar();; 1756 SetParNumber(npar);; 1757 if(flag == 9) return;; 1758 zik = GetZ();; 1759 pl0 = GetPL0();; 1760 ; 1761 Double_t *df = new Double_t[npar];; 1762 f1->InitArgs(x,u);; 1763 f = 0;; 1764 ; 1765 Int_t npfit = 0;; 1766 Double_t *cache = fCache;; 1767 for (Int_t i=0;i<fNpoints;i++) {; 1768 if (nd > 2) x[2] = cache[4];; 1769 if (nd > 1) x[1] = cache[3];; 1770 x[0] = cache[2];; 1771 cu = cache[0];; 1772 TF1::RejectPoint(kFALSE);; 1773 fu = f1->EvalPar(x,u);; 1774 if (TF1::RejectedPoint()) {cache += fPointSize; continue;}; 1775 eu = cache[1];; 1776 Derivatives(df,x);; 1777 Int_t n = 0;; 1778 fsum = (fu-cu)/eu;; 1779 if (flag!=1) {; 1780 for (j=0;j<npar;j++) {; 1781 if (pl0[j]>0) {; 1782 df[n] = df[j]/eu;; 1783 // left only non-fixed param derivatives / by Sigma; 1784 gin[j] += df[n]*fsum;; 1785 n++;; 1786 }; 1787 }; 1788 Int_t l = 0;; 1789 for (j=0;j<n;j++); 1790 for (Int_t k=0;k<=j;k++); 1791 zik[l++] += df[j]*df[k];; 1792 }; 1793 f += .5*fsum*fsum;; 1794 npfit++;; 1795 cache += fPointSize;; 1796 }; 1797 f1->SetNumberFitPoints(npfit);; 1798 delete [] df;; 1799}; 1800 ; 1801////////////////////////////////////////////////////////////////////////////////; 1802/// Minimization function for H1s using a Chisquare method.; 1803/// The ""I""ntegral method is used; 1804/// for each point t",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:50591,Performance,cache,cache,50591,"r each point the cache contains the following info; 1734/// - 1D : bc,e,xc (bin content, error, x of center of bin); 1735/// - 2D : bc,e,xc,yc; 1736/// - 3D : bc,e,xc,yc,zc; 1737 ; 1738void TFumili::FitChisquare(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag); 1739{; 1740 Foption_t fitOption = GetFitOption();; 1741 if (fitOption.Integral) {; 1742 FitChisquareI(npar,gin,f,u,flag);; 1743 return;; 1744 }; 1745 Double_t cu,eu,fu,fsum;; 1746 Double_t x[3];; 1747 Double_t *zik=nullptr;; 1748 Double_t *pl0=nullptr;; 1749 ; 1750 TH1 *hfit = (TH1*)GetObjectFit();; 1751 TF1 *f1 = (TF1*)GetUserFunc();; 1752 Int_t nd = hfit->GetDimension();; 1753 Int_t j;; 1754 ; 1755 npar = f1->GetNpar();; 1756 SetParNumber(npar);; 1757 if(flag == 9) return;; 1758 zik = GetZ();; 1759 pl0 = GetPL0();; 1760 ; 1761 Double_t *df = new Double_t[npar];; 1762 f1->InitArgs(x,u);; 1763 f = 0;; 1764 ; 1765 Int_t npfit = 0;; 1766 Double_t *cache = fCache;; 1767 for (Int_t i=0;i<fNpoints;i++) {; 1768 if (nd > 2) x[2] = cache[4];; 1769 if (nd > 1) x[1] = cache[3];; 1770 x[0] = cache[2];; 1771 cu = cache[0];; 1772 TF1::RejectPoint(kFALSE);; 1773 fu = f1->EvalPar(x,u);; 1774 if (TF1::RejectedPoint()) {cache += fPointSize; continue;}; 1775 eu = cache[1];; 1776 Derivatives(df,x);; 1777 Int_t n = 0;; 1778 fsum = (fu-cu)/eu;; 1779 if (flag!=1) {; 1780 for (j=0;j<npar;j++) {; 1781 if (pl0[j]>0) {; 1782 df[n] = df[j]/eu;; 1783 // left only non-fixed param derivatives / by Sigma; 1784 gin[j] += df[n]*fsum;; 1785 n++;; 1786 }; 1787 }; 1788 Int_t l = 0;; 1789 for (j=0;j<n;j++); 1790 for (Int_t k=0;k<=j;k++); 1791 zik[l++] += df[j]*df[k];; 1792 }; 1793 f += .5*fsum*fsum;; 1794 npfit++;; 1795 cache += fPointSize;; 1796 }; 1797 f1->SetNumberFitPoints(npfit);; 1798 delete [] df;; 1799}; 1800 ; 1801////////////////////////////////////////////////////////////////////////////////; 1802/// Minimization function for H1s using a Chisquare method.; 1803/// The ""I""ntegral method is used; 1804/// for each point t",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:50626,Performance,cache,cache,50626,"r each point the cache contains the following info; 1734/// - 1D : bc,e,xc (bin content, error, x of center of bin); 1735/// - 2D : bc,e,xc,yc; 1736/// - 3D : bc,e,xc,yc,zc; 1737 ; 1738void TFumili::FitChisquare(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag); 1739{; 1740 Foption_t fitOption = GetFitOption();; 1741 if (fitOption.Integral) {; 1742 FitChisquareI(npar,gin,f,u,flag);; 1743 return;; 1744 }; 1745 Double_t cu,eu,fu,fsum;; 1746 Double_t x[3];; 1747 Double_t *zik=nullptr;; 1748 Double_t *pl0=nullptr;; 1749 ; 1750 TH1 *hfit = (TH1*)GetObjectFit();; 1751 TF1 *f1 = (TF1*)GetUserFunc();; 1752 Int_t nd = hfit->GetDimension();; 1753 Int_t j;; 1754 ; 1755 npar = f1->GetNpar();; 1756 SetParNumber(npar);; 1757 if(flag == 9) return;; 1758 zik = GetZ();; 1759 pl0 = GetPL0();; 1760 ; 1761 Double_t *df = new Double_t[npar];; 1762 f1->InitArgs(x,u);; 1763 f = 0;; 1764 ; 1765 Int_t npfit = 0;; 1766 Double_t *cache = fCache;; 1767 for (Int_t i=0;i<fNpoints;i++) {; 1768 if (nd > 2) x[2] = cache[4];; 1769 if (nd > 1) x[1] = cache[3];; 1770 x[0] = cache[2];; 1771 cu = cache[0];; 1772 TF1::RejectPoint(kFALSE);; 1773 fu = f1->EvalPar(x,u);; 1774 if (TF1::RejectedPoint()) {cache += fPointSize; continue;}; 1775 eu = cache[1];; 1776 Derivatives(df,x);; 1777 Int_t n = 0;; 1778 fsum = (fu-cu)/eu;; 1779 if (flag!=1) {; 1780 for (j=0;j<npar;j++) {; 1781 if (pl0[j]>0) {; 1782 df[n] = df[j]/eu;; 1783 // left only non-fixed param derivatives / by Sigma; 1784 gin[j] += df[n]*fsum;; 1785 n++;; 1786 }; 1787 }; 1788 Int_t l = 0;; 1789 for (j=0;j<n;j++); 1790 for (Int_t k=0;k<=j;k++); 1791 zik[l++] += df[j]*df[k];; 1792 }; 1793 f += .5*fsum*fsum;; 1794 npfit++;; 1795 cache += fPointSize;; 1796 }; 1797 f1->SetNumberFitPoints(npfit);; 1798 delete [] df;; 1799}; 1800 ; 1801////////////////////////////////////////////////////////////////////////////////; 1802/// Minimization function for H1s using a Chisquare method.; 1803/// The ""I""ntegral method is used; 1804/// for each point t",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:50649,Performance,cache,cache,50649,"r each point the cache contains the following info; 1734/// - 1D : bc,e,xc (bin content, error, x of center of bin); 1735/// - 2D : bc,e,xc,yc; 1736/// - 3D : bc,e,xc,yc,zc; 1737 ; 1738void TFumili::FitChisquare(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag); 1739{; 1740 Foption_t fitOption = GetFitOption();; 1741 if (fitOption.Integral) {; 1742 FitChisquareI(npar,gin,f,u,flag);; 1743 return;; 1744 }; 1745 Double_t cu,eu,fu,fsum;; 1746 Double_t x[3];; 1747 Double_t *zik=nullptr;; 1748 Double_t *pl0=nullptr;; 1749 ; 1750 TH1 *hfit = (TH1*)GetObjectFit();; 1751 TF1 *f1 = (TF1*)GetUserFunc();; 1752 Int_t nd = hfit->GetDimension();; 1753 Int_t j;; 1754 ; 1755 npar = f1->GetNpar();; 1756 SetParNumber(npar);; 1757 if(flag == 9) return;; 1758 zik = GetZ();; 1759 pl0 = GetPL0();; 1760 ; 1761 Double_t *df = new Double_t[npar];; 1762 f1->InitArgs(x,u);; 1763 f = 0;; 1764 ; 1765 Int_t npfit = 0;; 1766 Double_t *cache = fCache;; 1767 for (Int_t i=0;i<fNpoints;i++) {; 1768 if (nd > 2) x[2] = cache[4];; 1769 if (nd > 1) x[1] = cache[3];; 1770 x[0] = cache[2];; 1771 cu = cache[0];; 1772 TF1::RejectPoint(kFALSE);; 1773 fu = f1->EvalPar(x,u);; 1774 if (TF1::RejectedPoint()) {cache += fPointSize; continue;}; 1775 eu = cache[1];; 1776 Derivatives(df,x);; 1777 Int_t n = 0;; 1778 fsum = (fu-cu)/eu;; 1779 if (flag!=1) {; 1780 for (j=0;j<npar;j++) {; 1781 if (pl0[j]>0) {; 1782 df[n] = df[j]/eu;; 1783 // left only non-fixed param derivatives / by Sigma; 1784 gin[j] += df[n]*fsum;; 1785 n++;; 1786 }; 1787 }; 1788 Int_t l = 0;; 1789 for (j=0;j<n;j++); 1790 for (Int_t k=0;k<=j;k++); 1791 zik[l++] += df[j]*df[k];; 1792 }; 1793 f += .5*fsum*fsum;; 1794 npfit++;; 1795 cache += fPointSize;; 1796 }; 1797 f1->SetNumberFitPoints(npfit);; 1798 delete [] df;; 1799}; 1800 ; 1801////////////////////////////////////////////////////////////////////////////////; 1802/// Minimization function for H1s using a Chisquare method.; 1803/// The ""I""ntegral method is used; 1804/// for each point t",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:50670,Performance,cache,cache,50670,"r each point the cache contains the following info; 1734/// - 1D : bc,e,xc (bin content, error, x of center of bin); 1735/// - 2D : bc,e,xc,yc; 1736/// - 3D : bc,e,xc,yc,zc; 1737 ; 1738void TFumili::FitChisquare(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag); 1739{; 1740 Foption_t fitOption = GetFitOption();; 1741 if (fitOption.Integral) {; 1742 FitChisquareI(npar,gin,f,u,flag);; 1743 return;; 1744 }; 1745 Double_t cu,eu,fu,fsum;; 1746 Double_t x[3];; 1747 Double_t *zik=nullptr;; 1748 Double_t *pl0=nullptr;; 1749 ; 1750 TH1 *hfit = (TH1*)GetObjectFit();; 1751 TF1 *f1 = (TF1*)GetUserFunc();; 1752 Int_t nd = hfit->GetDimension();; 1753 Int_t j;; 1754 ; 1755 npar = f1->GetNpar();; 1756 SetParNumber(npar);; 1757 if(flag == 9) return;; 1758 zik = GetZ();; 1759 pl0 = GetPL0();; 1760 ; 1761 Double_t *df = new Double_t[npar];; 1762 f1->InitArgs(x,u);; 1763 f = 0;; 1764 ; 1765 Int_t npfit = 0;; 1766 Double_t *cache = fCache;; 1767 for (Int_t i=0;i<fNpoints;i++) {; 1768 if (nd > 2) x[2] = cache[4];; 1769 if (nd > 1) x[1] = cache[3];; 1770 x[0] = cache[2];; 1771 cu = cache[0];; 1772 TF1::RejectPoint(kFALSE);; 1773 fu = f1->EvalPar(x,u);; 1774 if (TF1::RejectedPoint()) {cache += fPointSize; continue;}; 1775 eu = cache[1];; 1776 Derivatives(df,x);; 1777 Int_t n = 0;; 1778 fsum = (fu-cu)/eu;; 1779 if (flag!=1) {; 1780 for (j=0;j<npar;j++) {; 1781 if (pl0[j]>0) {; 1782 df[n] = df[j]/eu;; 1783 // left only non-fixed param derivatives / by Sigma; 1784 gin[j] += df[n]*fsum;; 1785 n++;; 1786 }; 1787 }; 1788 Int_t l = 0;; 1789 for (j=0;j<n;j++); 1790 for (Int_t k=0;k<=j;k++); 1791 zik[l++] += df[j]*df[k];; 1792 }; 1793 f += .5*fsum*fsum;; 1794 npfit++;; 1795 cache += fPointSize;; 1796 }; 1797 f1->SetNumberFitPoints(npfit);; 1798 delete [] df;; 1799}; 1800 ; 1801////////////////////////////////////////////////////////////////////////////////; 1802/// Minimization function for H1s using a Chisquare method.; 1803/// The ""I""ntegral method is used; 1804/// for each point t",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:50774,Performance,cache,cache,50774,"r each point the cache contains the following info; 1734/// - 1D : bc,e,xc (bin content, error, x of center of bin); 1735/// - 2D : bc,e,xc,yc; 1736/// - 3D : bc,e,xc,yc,zc; 1737 ; 1738void TFumili::FitChisquare(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag); 1739{; 1740 Foption_t fitOption = GetFitOption();; 1741 if (fitOption.Integral) {; 1742 FitChisquareI(npar,gin,f,u,flag);; 1743 return;; 1744 }; 1745 Double_t cu,eu,fu,fsum;; 1746 Double_t x[3];; 1747 Double_t *zik=nullptr;; 1748 Double_t *pl0=nullptr;; 1749 ; 1750 TH1 *hfit = (TH1*)GetObjectFit();; 1751 TF1 *f1 = (TF1*)GetUserFunc();; 1752 Int_t nd = hfit->GetDimension();; 1753 Int_t j;; 1754 ; 1755 npar = f1->GetNpar();; 1756 SetParNumber(npar);; 1757 if(flag == 9) return;; 1758 zik = GetZ();; 1759 pl0 = GetPL0();; 1760 ; 1761 Double_t *df = new Double_t[npar];; 1762 f1->InitArgs(x,u);; 1763 f = 0;; 1764 ; 1765 Int_t npfit = 0;; 1766 Double_t *cache = fCache;; 1767 for (Int_t i=0;i<fNpoints;i++) {; 1768 if (nd > 2) x[2] = cache[4];; 1769 if (nd > 1) x[1] = cache[3];; 1770 x[0] = cache[2];; 1771 cu = cache[0];; 1772 TF1::RejectPoint(kFALSE);; 1773 fu = f1->EvalPar(x,u);; 1774 if (TF1::RejectedPoint()) {cache += fPointSize; continue;}; 1775 eu = cache[1];; 1776 Derivatives(df,x);; 1777 Int_t n = 0;; 1778 fsum = (fu-cu)/eu;; 1779 if (flag!=1) {; 1780 for (j=0;j<npar;j++) {; 1781 if (pl0[j]>0) {; 1782 df[n] = df[j]/eu;; 1783 // left only non-fixed param derivatives / by Sigma; 1784 gin[j] += df[n]*fsum;; 1785 n++;; 1786 }; 1787 }; 1788 Int_t l = 0;; 1789 for (j=0;j<n;j++); 1790 for (Int_t k=0;k<=j;k++); 1791 zik[l++] += df[j]*df[k];; 1792 }; 1793 f += .5*fsum*fsum;; 1794 npfit++;; 1795 cache += fPointSize;; 1796 }; 1797 f1->SetNumberFitPoints(npfit);; 1798 delete [] df;; 1799}; 1800 ; 1801////////////////////////////////////////////////////////////////////////////////; 1802/// Minimization function for H1s using a Chisquare method.; 1803/// The ""I""ntegral method is used; 1804/// for each point t",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:50817,Performance,cache,cache,50817,"r each point the cache contains the following info; 1734/// - 1D : bc,e,xc (bin content, error, x of center of bin); 1735/// - 2D : bc,e,xc,yc; 1736/// - 3D : bc,e,xc,yc,zc; 1737 ; 1738void TFumili::FitChisquare(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag); 1739{; 1740 Foption_t fitOption = GetFitOption();; 1741 if (fitOption.Integral) {; 1742 FitChisquareI(npar,gin,f,u,flag);; 1743 return;; 1744 }; 1745 Double_t cu,eu,fu,fsum;; 1746 Double_t x[3];; 1747 Double_t *zik=nullptr;; 1748 Double_t *pl0=nullptr;; 1749 ; 1750 TH1 *hfit = (TH1*)GetObjectFit();; 1751 TF1 *f1 = (TF1*)GetUserFunc();; 1752 Int_t nd = hfit->GetDimension();; 1753 Int_t j;; 1754 ; 1755 npar = f1->GetNpar();; 1756 SetParNumber(npar);; 1757 if(flag == 9) return;; 1758 zik = GetZ();; 1759 pl0 = GetPL0();; 1760 ; 1761 Double_t *df = new Double_t[npar];; 1762 f1->InitArgs(x,u);; 1763 f = 0;; 1764 ; 1765 Int_t npfit = 0;; 1766 Double_t *cache = fCache;; 1767 for (Int_t i=0;i<fNpoints;i++) {; 1768 if (nd > 2) x[2] = cache[4];; 1769 if (nd > 1) x[1] = cache[3];; 1770 x[0] = cache[2];; 1771 cu = cache[0];; 1772 TF1::RejectPoint(kFALSE);; 1773 fu = f1->EvalPar(x,u);; 1774 if (TF1::RejectedPoint()) {cache += fPointSize; continue;}; 1775 eu = cache[1];; 1776 Derivatives(df,x);; 1777 Int_t n = 0;; 1778 fsum = (fu-cu)/eu;; 1779 if (flag!=1) {; 1780 for (j=0;j<npar;j++) {; 1781 if (pl0[j]>0) {; 1782 df[n] = df[j]/eu;; 1783 // left only non-fixed param derivatives / by Sigma; 1784 gin[j] += df[n]*fsum;; 1785 n++;; 1786 }; 1787 }; 1788 Int_t l = 0;; 1789 for (j=0;j<n;j++); 1790 for (Int_t k=0;k<=j;k++); 1791 zik[l++] += df[j]*df[k];; 1792 }; 1793 f += .5*fsum*fsum;; 1794 npfit++;; 1795 cache += fPointSize;; 1796 }; 1797 f1->SetNumberFitPoints(npfit);; 1798 delete [] df;; 1799}; 1800 ; 1801////////////////////////////////////////////////////////////////////////////////; 1802/// Minimization function for H1s using a Chisquare method.; 1803/// The ""I""ntegral method is used; 1804/// for each point t",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:51264,Performance,cache,cache,51264,"PL0();; 1760 ; 1761 Double_t *df = new Double_t[npar];; 1762 f1->InitArgs(x,u);; 1763 f = 0;; 1764 ; 1765 Int_t npfit = 0;; 1766 Double_t *cache = fCache;; 1767 for (Int_t i=0;i<fNpoints;i++) {; 1768 if (nd > 2) x[2] = cache[4];; 1769 if (nd > 1) x[1] = cache[3];; 1770 x[0] = cache[2];; 1771 cu = cache[0];; 1772 TF1::RejectPoint(kFALSE);; 1773 fu = f1->EvalPar(x,u);; 1774 if (TF1::RejectedPoint()) {cache += fPointSize; continue;}; 1775 eu = cache[1];; 1776 Derivatives(df,x);; 1777 Int_t n = 0;; 1778 fsum = (fu-cu)/eu;; 1779 if (flag!=1) {; 1780 for (j=0;j<npar;j++) {; 1781 if (pl0[j]>0) {; 1782 df[n] = df[j]/eu;; 1783 // left only non-fixed param derivatives / by Sigma; 1784 gin[j] += df[n]*fsum;; 1785 n++;; 1786 }; 1787 }; 1788 Int_t l = 0;; 1789 for (j=0;j<n;j++); 1790 for (Int_t k=0;k<=j;k++); 1791 zik[l++] += df[j]*df[k];; 1792 }; 1793 f += .5*fsum*fsum;; 1794 npfit++;; 1795 cache += fPointSize;; 1796 }; 1797 f1->SetNumberFitPoints(npfit);; 1798 delete [] df;; 1799}; 1800 ; 1801////////////////////////////////////////////////////////////////////////////////; 1802/// Minimization function for H1s using a Chisquare method.; 1803/// The ""I""ntegral method is used; 1804/// for each point the cache contains the following info; 1805/// - 1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); 1806/// - 2D : bc,e,xc,xw,yc,yw; 1807/// - 3D : bc,e,xc,xw,yc,yw,zc,zw; 1808 ; 1809void TFumili::FitChisquareI(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag); 1810{; 1811 Double_t cu,eu,fu,fsum;; 1812 Double_t x[3];; 1813 Double_t *zik=nullptr;; 1814 Double_t *pl0=nullptr;; 1815 ; 1816 TH1 *hfit = (TH1*)GetObjectFit();; 1817 TF1 *f1 = (TF1*)GetUserFunc();; 1818 Int_t nd = hfit->GetDimension();; 1819 Int_t j;; 1820 ; 1821 f1->InitArgs(x,u);; 1822 npar = f1->GetNpar();; 1823 SetParNumber(npar);; 1824 if(flag == 9) return;; 1825 zik = GetZ();; 1826 pl0 = GetPL0();; 1827 ; 1828 Double_t *df=new Double_t[npar];; 1829 f = 0;; 1830 ; 1831 Int_t np",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:51582,Performance,cache,cache,51582,"784 gin[j] += df[n]*fsum;; 1785 n++;; 1786 }; 1787 }; 1788 Int_t l = 0;; 1789 for (j=0;j<n;j++); 1790 for (Int_t k=0;k<=j;k++); 1791 zik[l++] += df[j]*df[k];; 1792 }; 1793 f += .5*fsum*fsum;; 1794 npfit++;; 1795 cache += fPointSize;; 1796 }; 1797 f1->SetNumberFitPoints(npfit);; 1798 delete [] df;; 1799}; 1800 ; 1801////////////////////////////////////////////////////////////////////////////////; 1802/// Minimization function for H1s using a Chisquare method.; 1803/// The ""I""ntegral method is used; 1804/// for each point the cache contains the following info; 1805/// - 1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); 1806/// - 2D : bc,e,xc,xw,yc,yw; 1807/// - 3D : bc,e,xc,xw,yc,yw,zc,zw; 1808 ; 1809void TFumili::FitChisquareI(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag); 1810{; 1811 Double_t cu,eu,fu,fsum;; 1812 Double_t x[3];; 1813 Double_t *zik=nullptr;; 1814 Double_t *pl0=nullptr;; 1815 ; 1816 TH1 *hfit = (TH1*)GetObjectFit();; 1817 TF1 *f1 = (TF1*)GetUserFunc();; 1818 Int_t nd = hfit->GetDimension();; 1819 Int_t j;; 1820 ; 1821 f1->InitArgs(x,u);; 1822 npar = f1->GetNpar();; 1823 SetParNumber(npar);; 1824 if(flag == 9) return;; 1825 zik = GetZ();; 1826 pl0 = GetPL0();; 1827 ; 1828 Double_t *df=new Double_t[npar];; 1829 f = 0;; 1830 ; 1831 Int_t npfit = 0;; 1832 Double_t *cache = fCache;; 1833 for (Int_t i=0;i<fNpoints;i++) {; 1834 cu = cache[0];; 1835 TF1::RejectPoint(kFALSE);; 1836 f1->SetParameters(u);; 1837 if (nd < 2) {; 1838 fu = f1->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3])/cache[3];; 1839 } else if (nd < 3) {; 1840 fu = ((TF2*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5])/(cache[3]*cache[5]);; 1841 } else {; 1842 fu = ((TF3*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5],cache[6] - 0.5*cache[7],cache[6] + 0.5*cache[7])/(cache[3]*cache[5]*cache[7]);; 1843 }; 1844 if ",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:52397,Performance,cache,cache,52397,"784 gin[j] += df[n]*fsum;; 1785 n++;; 1786 }; 1787 }; 1788 Int_t l = 0;; 1789 for (j=0;j<n;j++); 1790 for (Int_t k=0;k<=j;k++); 1791 zik[l++] += df[j]*df[k];; 1792 }; 1793 f += .5*fsum*fsum;; 1794 npfit++;; 1795 cache += fPointSize;; 1796 }; 1797 f1->SetNumberFitPoints(npfit);; 1798 delete [] df;; 1799}; 1800 ; 1801////////////////////////////////////////////////////////////////////////////////; 1802/// Minimization function for H1s using a Chisquare method.; 1803/// The ""I""ntegral method is used; 1804/// for each point the cache contains the following info; 1805/// - 1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); 1806/// - 2D : bc,e,xc,xw,yc,yw; 1807/// - 3D : bc,e,xc,xw,yc,yw,zc,zw; 1808 ; 1809void TFumili::FitChisquareI(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag); 1810{; 1811 Double_t cu,eu,fu,fsum;; 1812 Double_t x[3];; 1813 Double_t *zik=nullptr;; 1814 Double_t *pl0=nullptr;; 1815 ; 1816 TH1 *hfit = (TH1*)GetObjectFit();; 1817 TF1 *f1 = (TF1*)GetUserFunc();; 1818 Int_t nd = hfit->GetDimension();; 1819 Int_t j;; 1820 ; 1821 f1->InitArgs(x,u);; 1822 npar = f1->GetNpar();; 1823 SetParNumber(npar);; 1824 if(flag == 9) return;; 1825 zik = GetZ();; 1826 pl0 = GetPL0();; 1827 ; 1828 Double_t *df=new Double_t[npar];; 1829 f = 0;; 1830 ; 1831 Int_t npfit = 0;; 1832 Double_t *cache = fCache;; 1833 for (Int_t i=0;i<fNpoints;i++) {; 1834 cu = cache[0];; 1835 TF1::RejectPoint(kFALSE);; 1836 f1->SetParameters(u);; 1837 if (nd < 2) {; 1838 fu = f1->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3])/cache[3];; 1839 } else if (nd < 3) {; 1840 fu = ((TF2*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5])/(cache[3]*cache[5]);; 1841 } else {; 1842 fu = ((TF3*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5],cache[6] - 0.5*cache[7],cache[6] + 0.5*cache[7])/(cache[3]*cache[5]*cache[7]);; 1843 }; 1844 if ",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:52463,Performance,cache,cache,52463,"784 gin[j] += df[n]*fsum;; 1785 n++;; 1786 }; 1787 }; 1788 Int_t l = 0;; 1789 for (j=0;j<n;j++); 1790 for (Int_t k=0;k<=j;k++); 1791 zik[l++] += df[j]*df[k];; 1792 }; 1793 f += .5*fsum*fsum;; 1794 npfit++;; 1795 cache += fPointSize;; 1796 }; 1797 f1->SetNumberFitPoints(npfit);; 1798 delete [] df;; 1799}; 1800 ; 1801////////////////////////////////////////////////////////////////////////////////; 1802/// Minimization function for H1s using a Chisquare method.; 1803/// The ""I""ntegral method is used; 1804/// for each point the cache contains the following info; 1805/// - 1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); 1806/// - 2D : bc,e,xc,xw,yc,yw; 1807/// - 3D : bc,e,xc,xw,yc,yw,zc,zw; 1808 ; 1809void TFumili::FitChisquareI(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag); 1810{; 1811 Double_t cu,eu,fu,fsum;; 1812 Double_t x[3];; 1813 Double_t *zik=nullptr;; 1814 Double_t *pl0=nullptr;; 1815 ; 1816 TH1 *hfit = (TH1*)GetObjectFit();; 1817 TF1 *f1 = (TF1*)GetUserFunc();; 1818 Int_t nd = hfit->GetDimension();; 1819 Int_t j;; 1820 ; 1821 f1->InitArgs(x,u);; 1822 npar = f1->GetNpar();; 1823 SetParNumber(npar);; 1824 if(flag == 9) return;; 1825 zik = GetZ();; 1826 pl0 = GetPL0();; 1827 ; 1828 Double_t *df=new Double_t[npar];; 1829 f = 0;; 1830 ; 1831 Int_t npfit = 0;; 1832 Double_t *cache = fCache;; 1833 for (Int_t i=0;i<fNpoints;i++) {; 1834 cu = cache[0];; 1835 TF1::RejectPoint(kFALSE);; 1836 f1->SetParameters(u);; 1837 if (nd < 2) {; 1838 fu = f1->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3])/cache[3];; 1839 } else if (nd < 3) {; 1840 fu = ((TF2*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5])/(cache[3]*cache[5]);; 1841 } else {; 1842 fu = ((TF3*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5],cache[6] - 0.5*cache[7],cache[6] + 0.5*cache[7])/(cache[3]*cache[5]*cache[7]);; 1843 }; 1844 if ",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:52577,Performance,cache,cache,52577,"784 gin[j] += df[n]*fsum;; 1785 n++;; 1786 }; 1787 }; 1788 Int_t l = 0;; 1789 for (j=0;j<n;j++); 1790 for (Int_t k=0;k<=j;k++); 1791 zik[l++] += df[j]*df[k];; 1792 }; 1793 f += .5*fsum*fsum;; 1794 npfit++;; 1795 cache += fPointSize;; 1796 }; 1797 f1->SetNumberFitPoints(npfit);; 1798 delete [] df;; 1799}; 1800 ; 1801////////////////////////////////////////////////////////////////////////////////; 1802/// Minimization function for H1s using a Chisquare method.; 1803/// The ""I""ntegral method is used; 1804/// for each point the cache contains the following info; 1805/// - 1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); 1806/// - 2D : bc,e,xc,xw,yc,yw; 1807/// - 3D : bc,e,xc,xw,yc,yw,zc,zw; 1808 ; 1809void TFumili::FitChisquareI(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag); 1810{; 1811 Double_t cu,eu,fu,fsum;; 1812 Double_t x[3];; 1813 Double_t *zik=nullptr;; 1814 Double_t *pl0=nullptr;; 1815 ; 1816 TH1 *hfit = (TH1*)GetObjectFit();; 1817 TF1 *f1 = (TF1*)GetUserFunc();; 1818 Int_t nd = hfit->GetDimension();; 1819 Int_t j;; 1820 ; 1821 f1->InitArgs(x,u);; 1822 npar = f1->GetNpar();; 1823 SetParNumber(npar);; 1824 if(flag == 9) return;; 1825 zik = GetZ();; 1826 pl0 = GetPL0();; 1827 ; 1828 Double_t *df=new Double_t[npar];; 1829 f = 0;; 1830 ; 1831 Int_t npfit = 0;; 1832 Double_t *cache = fCache;; 1833 for (Int_t i=0;i<fNpoints;i++) {; 1834 cu = cache[0];; 1835 TF1::RejectPoint(kFALSE);; 1836 f1->SetParameters(u);; 1837 if (nd < 2) {; 1838 fu = f1->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3])/cache[3];; 1839 } else if (nd < 3) {; 1840 fu = ((TF2*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5])/(cache[3]*cache[5]);; 1841 } else {; 1842 fu = ((TF3*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5],cache[6] - 0.5*cache[7],cache[6] + 0.5*cache[7])/(cache[3]*cache[5]*cache[7]);; 1843 }; 1844 if ",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:52592,Performance,cache,cache,52592,"ollowing info; 1805/// - 1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); 1806/// - 2D : bc,e,xc,xw,yc,yw; 1807/// - 3D : bc,e,xc,xw,yc,yw,zc,zw; 1808 ; 1809void TFumili::FitChisquareI(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag); 1810{; 1811 Double_t cu,eu,fu,fsum;; 1812 Double_t x[3];; 1813 Double_t *zik=nullptr;; 1814 Double_t *pl0=nullptr;; 1815 ; 1816 TH1 *hfit = (TH1*)GetObjectFit();; 1817 TF1 *f1 = (TF1*)GetUserFunc();; 1818 Int_t nd = hfit->GetDimension();; 1819 Int_t j;; 1820 ; 1821 f1->InitArgs(x,u);; 1822 npar = f1->GetNpar();; 1823 SetParNumber(npar);; 1824 if(flag == 9) return;; 1825 zik = GetZ();; 1826 pl0 = GetPL0();; 1827 ; 1828 Double_t *df=new Double_t[npar];; 1829 f = 0;; 1830 ; 1831 Int_t npfit = 0;; 1832 Double_t *cache = fCache;; 1833 for (Int_t i=0;i<fNpoints;i++) {; 1834 cu = cache[0];; 1835 TF1::RejectPoint(kFALSE);; 1836 f1->SetParameters(u);; 1837 if (nd < 2) {; 1838 fu = f1->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3])/cache[3];; 1839 } else if (nd < 3) {; 1840 fu = ((TF2*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5])/(cache[3]*cache[5]);; 1841 } else {; 1842 fu = ((TF3*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5],cache[6] - 0.5*cache[7],cache[6] + 0.5*cache[7])/(cache[3]*cache[5]*cache[7]);; 1843 }; 1844 if (TF1::RejectedPoint()) {cache += fPointSize; continue;}; 1845 eu = cache[1];; 1846 Derivatives(df,x);; 1847 Int_t n = 0;; 1848 fsum = (fu-cu)/eu;; 1849 if (flag!=1) {; 1850 for (j=0;j<npar;j++) {; 1851 if (pl0[j]>0){; 1852 df[n] = df[j]/eu;; 1853 // left only non-fixed param derivatives / by Sigma; 1854 gin[j] += df[n]*fsum;; 1855 n++;; 1856 }; 1857 }; 1858 Int_t l = 0;; 1859 for (j=0;j<n;j++); 1860 for (Int_t k=0;k<=j;k++); 1861 zik[l++] += df[j]*df[k];; 1862 }; 1863 f += .5*fsum*fsum;; 1864 npfit++;; 1865 cache += fPointSize;; 1866 }; 1867 f1",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:52601,Performance,cache,cache,52601,"ollowing info; 1805/// - 1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); 1806/// - 2D : bc,e,xc,xw,yc,yw; 1807/// - 3D : bc,e,xc,xw,yc,yw,zc,zw; 1808 ; 1809void TFumili::FitChisquareI(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag); 1810{; 1811 Double_t cu,eu,fu,fsum;; 1812 Double_t x[3];; 1813 Double_t *zik=nullptr;; 1814 Double_t *pl0=nullptr;; 1815 ; 1816 TH1 *hfit = (TH1*)GetObjectFit();; 1817 TF1 *f1 = (TF1*)GetUserFunc();; 1818 Int_t nd = hfit->GetDimension();; 1819 Int_t j;; 1820 ; 1821 f1->InitArgs(x,u);; 1822 npar = f1->GetNpar();; 1823 SetParNumber(npar);; 1824 if(flag == 9) return;; 1825 zik = GetZ();; 1826 pl0 = GetPL0();; 1827 ; 1828 Double_t *df=new Double_t[npar];; 1829 f = 0;; 1830 ; 1831 Int_t npfit = 0;; 1832 Double_t *cache = fCache;; 1833 for (Int_t i=0;i<fNpoints;i++) {; 1834 cu = cache[0];; 1835 TF1::RejectPoint(kFALSE);; 1836 f1->SetParameters(u);; 1837 if (nd < 2) {; 1838 fu = f1->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3])/cache[3];; 1839 } else if (nd < 3) {; 1840 fu = ((TF2*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5])/(cache[3]*cache[5]);; 1841 } else {; 1842 fu = ((TF3*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5],cache[6] - 0.5*cache[7],cache[6] + 0.5*cache[7])/(cache[3]*cache[5]*cache[7]);; 1843 }; 1844 if (TF1::RejectedPoint()) {cache += fPointSize; continue;}; 1845 eu = cache[1];; 1846 Derivatives(df,x);; 1847 Int_t n = 0;; 1848 fsum = (fu-cu)/eu;; 1849 if (flag!=1) {; 1850 for (j=0;j<npar;j++) {; 1851 if (pl0[j]>0){; 1852 df[n] = df[j]/eu;; 1853 // left only non-fixed param derivatives / by Sigma; 1854 gin[j] += df[n]*fsum;; 1855 n++;; 1856 }; 1857 }; 1858 Int_t l = 0;; 1859 for (j=0;j<n;j++); 1860 for (Int_t k=0;k<=j;k++); 1861 zik[l++] += df[j]*df[k];; 1862 }; 1863 f += .5*fsum*fsum;; 1864 npfit++;; 1865 cache += fPointSize;; 1866 }; 1867 f1",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:52616,Performance,cache,cache,52616,"r, x of center of bin, x bin width of bin); 1806/// - 2D : bc,e,xc,xw,yc,yw; 1807/// - 3D : bc,e,xc,xw,yc,yw,zc,zw; 1808 ; 1809void TFumili::FitChisquareI(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag); 1810{; 1811 Double_t cu,eu,fu,fsum;; 1812 Double_t x[3];; 1813 Double_t *zik=nullptr;; 1814 Double_t *pl0=nullptr;; 1815 ; 1816 TH1 *hfit = (TH1*)GetObjectFit();; 1817 TF1 *f1 = (TF1*)GetUserFunc();; 1818 Int_t nd = hfit->GetDimension();; 1819 Int_t j;; 1820 ; 1821 f1->InitArgs(x,u);; 1822 npar = f1->GetNpar();; 1823 SetParNumber(npar);; 1824 if(flag == 9) return;; 1825 zik = GetZ();; 1826 pl0 = GetPL0();; 1827 ; 1828 Double_t *df=new Double_t[npar];; 1829 f = 0;; 1830 ; 1831 Int_t npfit = 0;; 1832 Double_t *cache = fCache;; 1833 for (Int_t i=0;i<fNpoints;i++) {; 1834 cu = cache[0];; 1835 TF1::RejectPoint(kFALSE);; 1836 f1->SetParameters(u);; 1837 if (nd < 2) {; 1838 fu = f1->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3])/cache[3];; 1839 } else if (nd < 3) {; 1840 fu = ((TF2*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5])/(cache[3]*cache[5]);; 1841 } else {; 1842 fu = ((TF3*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5],cache[6] - 0.5*cache[7],cache[6] + 0.5*cache[7])/(cache[3]*cache[5]*cache[7]);; 1843 }; 1844 if (TF1::RejectedPoint()) {cache += fPointSize; continue;}; 1845 eu = cache[1];; 1846 Derivatives(df,x);; 1847 Int_t n = 0;; 1848 fsum = (fu-cu)/eu;; 1849 if (flag!=1) {; 1850 for (j=0;j<npar;j++) {; 1851 if (pl0[j]>0){; 1852 df[n] = df[j]/eu;; 1853 // left only non-fixed param derivatives / by Sigma; 1854 gin[j] += df[n]*fsum;; 1855 n++;; 1856 }; 1857 }; 1858 Int_t l = 0;; 1859 for (j=0;j<n;j++); 1860 for (Int_t k=0;k<=j;k++); 1861 zik[l++] += df[j]*df[k];; 1862 }; 1863 f += .5*fsum*fsum;; 1864 npfit++;; 1865 cache += fPointSize;; 1866 }; 1867 f1->SetNumberFitPoints(npfit);; 1868 delete[] df;; 1869}; 187",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:52626,Performance,cache,cache,52626,"r, x of center of bin, x bin width of bin); 1806/// - 2D : bc,e,xc,xw,yc,yw; 1807/// - 3D : bc,e,xc,xw,yc,yw,zc,zw; 1808 ; 1809void TFumili::FitChisquareI(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag); 1810{; 1811 Double_t cu,eu,fu,fsum;; 1812 Double_t x[3];; 1813 Double_t *zik=nullptr;; 1814 Double_t *pl0=nullptr;; 1815 ; 1816 TH1 *hfit = (TH1*)GetObjectFit();; 1817 TF1 *f1 = (TF1*)GetUserFunc();; 1818 Int_t nd = hfit->GetDimension();; 1819 Int_t j;; 1820 ; 1821 f1->InitArgs(x,u);; 1822 npar = f1->GetNpar();; 1823 SetParNumber(npar);; 1824 if(flag == 9) return;; 1825 zik = GetZ();; 1826 pl0 = GetPL0();; 1827 ; 1828 Double_t *df=new Double_t[npar];; 1829 f = 0;; 1830 ; 1831 Int_t npfit = 0;; 1832 Double_t *cache = fCache;; 1833 for (Int_t i=0;i<fNpoints;i++) {; 1834 cu = cache[0];; 1835 TF1::RejectPoint(kFALSE);; 1836 f1->SetParameters(u);; 1837 if (nd < 2) {; 1838 fu = f1->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3])/cache[3];; 1839 } else if (nd < 3) {; 1840 fu = ((TF2*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5])/(cache[3]*cache[5]);; 1841 } else {; 1842 fu = ((TF3*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5],cache[6] - 0.5*cache[7],cache[6] + 0.5*cache[7])/(cache[3]*cache[5]*cache[7]);; 1843 }; 1844 if (TF1::RejectedPoint()) {cache += fPointSize; continue;}; 1845 eu = cache[1];; 1846 Derivatives(df,x);; 1847 Int_t n = 0;; 1848 fsum = (fu-cu)/eu;; 1849 if (flag!=1) {; 1850 for (j=0;j<npar;j++) {; 1851 if (pl0[j]>0){; 1852 df[n] = df[j]/eu;; 1853 // left only non-fixed param derivatives / by Sigma; 1854 gin[j] += df[n]*fsum;; 1855 n++;; 1856 }; 1857 }; 1858 Int_t l = 0;; 1859 for (j=0;j<n;j++); 1860 for (Int_t k=0;k<=j;k++); 1861 zik[l++] += df[j]*df[k];; 1862 }; 1863 f += .5*fsum*fsum;; 1864 npfit++;; 1865 cache += fPointSize;; 1866 }; 1867 f1->SetNumberFitPoints(npfit);; 1868 delete[] df;; 1869}; 187",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:52695,Performance,cache,cache,52695,"r, x of center of bin, x bin width of bin); 1806/// - 2D : bc,e,xc,xw,yc,yw; 1807/// - 3D : bc,e,xc,xw,yc,yw,zc,zw; 1808 ; 1809void TFumili::FitChisquareI(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag); 1810{; 1811 Double_t cu,eu,fu,fsum;; 1812 Double_t x[3];; 1813 Double_t *zik=nullptr;; 1814 Double_t *pl0=nullptr;; 1815 ; 1816 TH1 *hfit = (TH1*)GetObjectFit();; 1817 TF1 *f1 = (TF1*)GetUserFunc();; 1818 Int_t nd = hfit->GetDimension();; 1819 Int_t j;; 1820 ; 1821 f1->InitArgs(x,u);; 1822 npar = f1->GetNpar();; 1823 SetParNumber(npar);; 1824 if(flag == 9) return;; 1825 zik = GetZ();; 1826 pl0 = GetPL0();; 1827 ; 1828 Double_t *df=new Double_t[npar];; 1829 f = 0;; 1830 ; 1831 Int_t npfit = 0;; 1832 Double_t *cache = fCache;; 1833 for (Int_t i=0;i<fNpoints;i++) {; 1834 cu = cache[0];; 1835 TF1::RejectPoint(kFALSE);; 1836 f1->SetParameters(u);; 1837 if (nd < 2) {; 1838 fu = f1->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3])/cache[3];; 1839 } else if (nd < 3) {; 1840 fu = ((TF2*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5])/(cache[3]*cache[5]);; 1841 } else {; 1842 fu = ((TF3*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5],cache[6] - 0.5*cache[7],cache[6] + 0.5*cache[7])/(cache[3]*cache[5]*cache[7]);; 1843 }; 1844 if (TF1::RejectedPoint()) {cache += fPointSize; continue;}; 1845 eu = cache[1];; 1846 Derivatives(df,x);; 1847 Int_t n = 0;; 1848 fsum = (fu-cu)/eu;; 1849 if (flag!=1) {; 1850 for (j=0;j<npar;j++) {; 1851 if (pl0[j]>0){; 1852 df[n] = df[j]/eu;; 1853 // left only non-fixed param derivatives / by Sigma; 1854 gin[j] += df[n]*fsum;; 1855 n++;; 1856 }; 1857 }; 1858 Int_t l = 0;; 1859 for (j=0;j<n;j++); 1860 for (Int_t k=0;k<=j;k++); 1861 zik[l++] += df[j]*df[k];; 1862 }; 1863 f += .5*fsum*fsum;; 1864 npfit++;; 1865 cache += fPointSize;; 1866 }; 1867 f1->SetNumberFitPoints(npfit);; 1868 delete[] df;; 1869}; 187",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:52710,Performance,cache,cache,52710,"bc,e,xc,xw,yc,yw; 1807/// - 3D : bc,e,xc,xw,yc,yw,zc,zw; 1808 ; 1809void TFumili::FitChisquareI(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag); 1810{; 1811 Double_t cu,eu,fu,fsum;; 1812 Double_t x[3];; 1813 Double_t *zik=nullptr;; 1814 Double_t *pl0=nullptr;; 1815 ; 1816 TH1 *hfit = (TH1*)GetObjectFit();; 1817 TF1 *f1 = (TF1*)GetUserFunc();; 1818 Int_t nd = hfit->GetDimension();; 1819 Int_t j;; 1820 ; 1821 f1->InitArgs(x,u);; 1822 npar = f1->GetNpar();; 1823 SetParNumber(npar);; 1824 if(flag == 9) return;; 1825 zik = GetZ();; 1826 pl0 = GetPL0();; 1827 ; 1828 Double_t *df=new Double_t[npar];; 1829 f = 0;; 1830 ; 1831 Int_t npfit = 0;; 1832 Double_t *cache = fCache;; 1833 for (Int_t i=0;i<fNpoints;i++) {; 1834 cu = cache[0];; 1835 TF1::RejectPoint(kFALSE);; 1836 f1->SetParameters(u);; 1837 if (nd < 2) {; 1838 fu = f1->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3])/cache[3];; 1839 } else if (nd < 3) {; 1840 fu = ((TF2*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5])/(cache[3]*cache[5]);; 1841 } else {; 1842 fu = ((TF3*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5],cache[6] - 0.5*cache[7],cache[6] + 0.5*cache[7])/(cache[3]*cache[5]*cache[7]);; 1843 }; 1844 if (TF1::RejectedPoint()) {cache += fPointSize; continue;}; 1845 eu = cache[1];; 1846 Derivatives(df,x);; 1847 Int_t n = 0;; 1848 fsum = (fu-cu)/eu;; 1849 if (flag!=1) {; 1850 for (j=0;j<npar;j++) {; 1851 if (pl0[j]>0){; 1852 df[n] = df[j]/eu;; 1853 // left only non-fixed param derivatives / by Sigma; 1854 gin[j] += df[n]*fsum;; 1855 n++;; 1856 }; 1857 }; 1858 Int_t l = 0;; 1859 for (j=0;j<n;j++); 1860 for (Int_t k=0;k<=j;k++); 1861 zik[l++] += df[j]*df[k];; 1862 }; 1863 f += .5*fsum*fsum;; 1864 npfit++;; 1865 cache += fPointSize;; 1866 }; 1867 f1->SetNumberFitPoints(npfit);; 1868 delete[] df;; 1869}; 1870 ; 1871///////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:52719,Performance,cache,cache,52719,"bc,e,xc,xw,yc,yw; 1807/// - 3D : bc,e,xc,xw,yc,yw,zc,zw; 1808 ; 1809void TFumili::FitChisquareI(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag); 1810{; 1811 Double_t cu,eu,fu,fsum;; 1812 Double_t x[3];; 1813 Double_t *zik=nullptr;; 1814 Double_t *pl0=nullptr;; 1815 ; 1816 TH1 *hfit = (TH1*)GetObjectFit();; 1817 TF1 *f1 = (TF1*)GetUserFunc();; 1818 Int_t nd = hfit->GetDimension();; 1819 Int_t j;; 1820 ; 1821 f1->InitArgs(x,u);; 1822 npar = f1->GetNpar();; 1823 SetParNumber(npar);; 1824 if(flag == 9) return;; 1825 zik = GetZ();; 1826 pl0 = GetPL0();; 1827 ; 1828 Double_t *df=new Double_t[npar];; 1829 f = 0;; 1830 ; 1831 Int_t npfit = 0;; 1832 Double_t *cache = fCache;; 1833 for (Int_t i=0;i<fNpoints;i++) {; 1834 cu = cache[0];; 1835 TF1::RejectPoint(kFALSE);; 1836 f1->SetParameters(u);; 1837 if (nd < 2) {; 1838 fu = f1->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3])/cache[3];; 1839 } else if (nd < 3) {; 1840 fu = ((TF2*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5])/(cache[3]*cache[5]);; 1841 } else {; 1842 fu = ((TF3*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5],cache[6] - 0.5*cache[7],cache[6] + 0.5*cache[7])/(cache[3]*cache[5]*cache[7]);; 1843 }; 1844 if (TF1::RejectedPoint()) {cache += fPointSize; continue;}; 1845 eu = cache[1];; 1846 Derivatives(df,x);; 1847 Int_t n = 0;; 1848 fsum = (fu-cu)/eu;; 1849 if (flag!=1) {; 1850 for (j=0;j<npar;j++) {; 1851 if (pl0[j]>0){; 1852 df[n] = df[j]/eu;; 1853 // left only non-fixed param derivatives / by Sigma; 1854 gin[j] += df[n]*fsum;; 1855 n++;; 1856 }; 1857 }; 1858 Int_t l = 0;; 1859 for (j=0;j<n;j++); 1860 for (Int_t k=0;k<=j;k++); 1861 zik[l++] += df[j]*df[k];; 1862 }; 1863 f += .5*fsum*fsum;; 1864 npfit++;; 1865 cache += fPointSize;; 1866 }; 1867 f1->SetNumberFitPoints(npfit);; 1868 delete[] df;; 1869}; 1870 ; 1871///////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:52734,Performance,cache,cache,52734,"/ - 3D : bc,e,xc,xw,yc,yw,zc,zw; 1808 ; 1809void TFumili::FitChisquareI(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag); 1810{; 1811 Double_t cu,eu,fu,fsum;; 1812 Double_t x[3];; 1813 Double_t *zik=nullptr;; 1814 Double_t *pl0=nullptr;; 1815 ; 1816 TH1 *hfit = (TH1*)GetObjectFit();; 1817 TF1 *f1 = (TF1*)GetUserFunc();; 1818 Int_t nd = hfit->GetDimension();; 1819 Int_t j;; 1820 ; 1821 f1->InitArgs(x,u);; 1822 npar = f1->GetNpar();; 1823 SetParNumber(npar);; 1824 if(flag == 9) return;; 1825 zik = GetZ();; 1826 pl0 = GetPL0();; 1827 ; 1828 Double_t *df=new Double_t[npar];; 1829 f = 0;; 1830 ; 1831 Int_t npfit = 0;; 1832 Double_t *cache = fCache;; 1833 for (Int_t i=0;i<fNpoints;i++) {; 1834 cu = cache[0];; 1835 TF1::RejectPoint(kFALSE);; 1836 f1->SetParameters(u);; 1837 if (nd < 2) {; 1838 fu = f1->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3])/cache[3];; 1839 } else if (nd < 3) {; 1840 fu = ((TF2*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5])/(cache[3]*cache[5]);; 1841 } else {; 1842 fu = ((TF3*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5],cache[6] - 0.5*cache[7],cache[6] + 0.5*cache[7])/(cache[3]*cache[5]*cache[7]);; 1843 }; 1844 if (TF1::RejectedPoint()) {cache += fPointSize; continue;}; 1845 eu = cache[1];; 1846 Derivatives(df,x);; 1847 Int_t n = 0;; 1848 fsum = (fu-cu)/eu;; 1849 if (flag!=1) {; 1850 for (j=0;j<npar;j++) {; 1851 if (pl0[j]>0){; 1852 df[n] = df[j]/eu;; 1853 // left only non-fixed param derivatives / by Sigma; 1854 gin[j] += df[n]*fsum;; 1855 n++;; 1856 }; 1857 }; 1858 Int_t l = 0;; 1859 for (j=0;j<n;j++); 1860 for (Int_t k=0;k<=j;k++); 1861 zik[l++] += df[j]*df[k];; 1862 }; 1863 f += .5*fsum*fsum;; 1864 npfit++;; 1865 cache += fPointSize;; 1866 }; 1867 f1->SetNumberFitPoints(npfit);; 1868 delete[] df;; 1869}; 1870 ; 1871///////////////////////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:52743,Performance,cache,cache,52743,"/ - 3D : bc,e,xc,xw,yc,yw,zc,zw; 1808 ; 1809void TFumili::FitChisquareI(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag); 1810{; 1811 Double_t cu,eu,fu,fsum;; 1812 Double_t x[3];; 1813 Double_t *zik=nullptr;; 1814 Double_t *pl0=nullptr;; 1815 ; 1816 TH1 *hfit = (TH1*)GetObjectFit();; 1817 TF1 *f1 = (TF1*)GetUserFunc();; 1818 Int_t nd = hfit->GetDimension();; 1819 Int_t j;; 1820 ; 1821 f1->InitArgs(x,u);; 1822 npar = f1->GetNpar();; 1823 SetParNumber(npar);; 1824 if(flag == 9) return;; 1825 zik = GetZ();; 1826 pl0 = GetPL0();; 1827 ; 1828 Double_t *df=new Double_t[npar];; 1829 f = 0;; 1830 ; 1831 Int_t npfit = 0;; 1832 Double_t *cache = fCache;; 1833 for (Int_t i=0;i<fNpoints;i++) {; 1834 cu = cache[0];; 1835 TF1::RejectPoint(kFALSE);; 1836 f1->SetParameters(u);; 1837 if (nd < 2) {; 1838 fu = f1->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3])/cache[3];; 1839 } else if (nd < 3) {; 1840 fu = ((TF2*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5])/(cache[3]*cache[5]);; 1841 } else {; 1842 fu = ((TF3*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5],cache[6] - 0.5*cache[7],cache[6] + 0.5*cache[7])/(cache[3]*cache[5]*cache[7]);; 1843 }; 1844 if (TF1::RejectedPoint()) {cache += fPointSize; continue;}; 1845 eu = cache[1];; 1846 Derivatives(df,x);; 1847 Int_t n = 0;; 1848 fsum = (fu-cu)/eu;; 1849 if (flag!=1) {; 1850 for (j=0;j<npar;j++) {; 1851 if (pl0[j]>0){; 1852 df[n] = df[j]/eu;; 1853 // left only non-fixed param derivatives / by Sigma; 1854 gin[j] += df[n]*fsum;; 1855 n++;; 1856 }; 1857 }; 1858 Int_t l = 0;; 1859 for (j=0;j<n;j++); 1860 for (Int_t k=0;k<=j;k++); 1861 zik[l++] += df[j]*df[k];; 1862 }; 1863 f += .5*fsum*fsum;; 1864 npfit++;; 1865 cache += fPointSize;; 1866 }; 1867 f1->SetNumberFitPoints(npfit);; 1868 delete[] df;; 1869}; 1870 ; 1871///////////////////////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:52758,Performance,cache,cache,52758,"w,zc,zw; 1808 ; 1809void TFumili::FitChisquareI(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag); 1810{; 1811 Double_t cu,eu,fu,fsum;; 1812 Double_t x[3];; 1813 Double_t *zik=nullptr;; 1814 Double_t *pl0=nullptr;; 1815 ; 1816 TH1 *hfit = (TH1*)GetObjectFit();; 1817 TF1 *f1 = (TF1*)GetUserFunc();; 1818 Int_t nd = hfit->GetDimension();; 1819 Int_t j;; 1820 ; 1821 f1->InitArgs(x,u);; 1822 npar = f1->GetNpar();; 1823 SetParNumber(npar);; 1824 if(flag == 9) return;; 1825 zik = GetZ();; 1826 pl0 = GetPL0();; 1827 ; 1828 Double_t *df=new Double_t[npar];; 1829 f = 0;; 1830 ; 1831 Int_t npfit = 0;; 1832 Double_t *cache = fCache;; 1833 for (Int_t i=0;i<fNpoints;i++) {; 1834 cu = cache[0];; 1835 TF1::RejectPoint(kFALSE);; 1836 f1->SetParameters(u);; 1837 if (nd < 2) {; 1838 fu = f1->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3])/cache[3];; 1839 } else if (nd < 3) {; 1840 fu = ((TF2*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5])/(cache[3]*cache[5]);; 1841 } else {; 1842 fu = ((TF3*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5],cache[6] - 0.5*cache[7],cache[6] + 0.5*cache[7])/(cache[3]*cache[5]*cache[7]);; 1843 }; 1844 if (TF1::RejectedPoint()) {cache += fPointSize; continue;}; 1845 eu = cache[1];; 1846 Derivatives(df,x);; 1847 Int_t n = 0;; 1848 fsum = (fu-cu)/eu;; 1849 if (flag!=1) {; 1850 for (j=0;j<npar;j++) {; 1851 if (pl0[j]>0){; 1852 df[n] = df[j]/eu;; 1853 // left only non-fixed param derivatives / by Sigma; 1854 gin[j] += df[n]*fsum;; 1855 n++;; 1856 }; 1857 }; 1858 Int_t l = 0;; 1859 for (j=0;j<n;j++); 1860 for (Int_t k=0;k<=j;k++); 1861 zik[l++] += df[j]*df[k];; 1862 }; 1863 f += .5*fsum*fsum;; 1864 npfit++;; 1865 cache += fPointSize;; 1866 }; 1867 f1->SetNumberFitPoints(npfit);; 1868 delete[] df;; 1869}; 1870 ; 1871////////////////////////////////////////////////////////////////////////////////; 1872/// Minimizat",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:52767,Performance,cache,cache,52767,"w,zc,zw; 1808 ; 1809void TFumili::FitChisquareI(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag); 1810{; 1811 Double_t cu,eu,fu,fsum;; 1812 Double_t x[3];; 1813 Double_t *zik=nullptr;; 1814 Double_t *pl0=nullptr;; 1815 ; 1816 TH1 *hfit = (TH1*)GetObjectFit();; 1817 TF1 *f1 = (TF1*)GetUserFunc();; 1818 Int_t nd = hfit->GetDimension();; 1819 Int_t j;; 1820 ; 1821 f1->InitArgs(x,u);; 1822 npar = f1->GetNpar();; 1823 SetParNumber(npar);; 1824 if(flag == 9) return;; 1825 zik = GetZ();; 1826 pl0 = GetPL0();; 1827 ; 1828 Double_t *df=new Double_t[npar];; 1829 f = 0;; 1830 ; 1831 Int_t npfit = 0;; 1832 Double_t *cache = fCache;; 1833 for (Int_t i=0;i<fNpoints;i++) {; 1834 cu = cache[0];; 1835 TF1::RejectPoint(kFALSE);; 1836 f1->SetParameters(u);; 1837 if (nd < 2) {; 1838 fu = f1->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3])/cache[3];; 1839 } else if (nd < 3) {; 1840 fu = ((TF2*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5])/(cache[3]*cache[5]);; 1841 } else {; 1842 fu = ((TF3*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5],cache[6] - 0.5*cache[7],cache[6] + 0.5*cache[7])/(cache[3]*cache[5]*cache[7]);; 1843 }; 1844 if (TF1::RejectedPoint()) {cache += fPointSize; continue;}; 1845 eu = cache[1];; 1846 Derivatives(df,x);; 1847 Int_t n = 0;; 1848 fsum = (fu-cu)/eu;; 1849 if (flag!=1) {; 1850 for (j=0;j<npar;j++) {; 1851 if (pl0[j]>0){; 1852 df[n] = df[j]/eu;; 1853 // left only non-fixed param derivatives / by Sigma; 1854 gin[j] += df[n]*fsum;; 1855 n++;; 1856 }; 1857 }; 1858 Int_t l = 0;; 1859 for (j=0;j<n;j++); 1860 for (Int_t k=0;k<=j;k++); 1861 zik[l++] += df[j]*df[k];; 1862 }; 1863 f += .5*fsum*fsum;; 1864 npfit++;; 1865 cache += fPointSize;; 1866 }; 1867 f1->SetNumberFitPoints(npfit);; 1868 delete[] df;; 1869}; 1870 ; 1871////////////////////////////////////////////////////////////////////////////////; 1872/// Minimizat",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:52782,Performance,cache,cache,52782,"r, Double_t *gin, Double_t &f, Double_t *u, Int_t flag); 1810{; 1811 Double_t cu,eu,fu,fsum;; 1812 Double_t x[3];; 1813 Double_t *zik=nullptr;; 1814 Double_t *pl0=nullptr;; 1815 ; 1816 TH1 *hfit = (TH1*)GetObjectFit();; 1817 TF1 *f1 = (TF1*)GetUserFunc();; 1818 Int_t nd = hfit->GetDimension();; 1819 Int_t j;; 1820 ; 1821 f1->InitArgs(x,u);; 1822 npar = f1->GetNpar();; 1823 SetParNumber(npar);; 1824 if(flag == 9) return;; 1825 zik = GetZ();; 1826 pl0 = GetPL0();; 1827 ; 1828 Double_t *df=new Double_t[npar];; 1829 f = 0;; 1830 ; 1831 Int_t npfit = 0;; 1832 Double_t *cache = fCache;; 1833 for (Int_t i=0;i<fNpoints;i++) {; 1834 cu = cache[0];; 1835 TF1::RejectPoint(kFALSE);; 1836 f1->SetParameters(u);; 1837 if (nd < 2) {; 1838 fu = f1->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3])/cache[3];; 1839 } else if (nd < 3) {; 1840 fu = ((TF2*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5])/(cache[3]*cache[5]);; 1841 } else {; 1842 fu = ((TF3*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5],cache[6] - 0.5*cache[7],cache[6] + 0.5*cache[7])/(cache[3]*cache[5]*cache[7]);; 1843 }; 1844 if (TF1::RejectedPoint()) {cache += fPointSize; continue;}; 1845 eu = cache[1];; 1846 Derivatives(df,x);; 1847 Int_t n = 0;; 1848 fsum = (fu-cu)/eu;; 1849 if (flag!=1) {; 1850 for (j=0;j<npar;j++) {; 1851 if (pl0[j]>0){; 1852 df[n] = df[j]/eu;; 1853 // left only non-fixed param derivatives / by Sigma; 1854 gin[j] += df[n]*fsum;; 1855 n++;; 1856 }; 1857 }; 1858 Int_t l = 0;; 1859 for (j=0;j<n;j++); 1860 for (Int_t k=0;k<=j;k++); 1861 zik[l++] += df[j]*df[k];; 1862 }; 1863 f += .5*fsum*fsum;; 1864 npfit++;; 1865 cache += fPointSize;; 1866 }; 1867 f1->SetNumberFitPoints(npfit);; 1868 delete[] df;; 1869}; 1870 ; 1871////////////////////////////////////////////////////////////////////////////////; 1872/// Minimization function for H1s using a Likelihood method.; 1873/// Ba",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:52793,Performance,cache,cache,52793,"r, Double_t *gin, Double_t &f, Double_t *u, Int_t flag); 1810{; 1811 Double_t cu,eu,fu,fsum;; 1812 Double_t x[3];; 1813 Double_t *zik=nullptr;; 1814 Double_t *pl0=nullptr;; 1815 ; 1816 TH1 *hfit = (TH1*)GetObjectFit();; 1817 TF1 *f1 = (TF1*)GetUserFunc();; 1818 Int_t nd = hfit->GetDimension();; 1819 Int_t j;; 1820 ; 1821 f1->InitArgs(x,u);; 1822 npar = f1->GetNpar();; 1823 SetParNumber(npar);; 1824 if(flag == 9) return;; 1825 zik = GetZ();; 1826 pl0 = GetPL0();; 1827 ; 1828 Double_t *df=new Double_t[npar];; 1829 f = 0;; 1830 ; 1831 Int_t npfit = 0;; 1832 Double_t *cache = fCache;; 1833 for (Int_t i=0;i<fNpoints;i++) {; 1834 cu = cache[0];; 1835 TF1::RejectPoint(kFALSE);; 1836 f1->SetParameters(u);; 1837 if (nd < 2) {; 1838 fu = f1->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3])/cache[3];; 1839 } else if (nd < 3) {; 1840 fu = ((TF2*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5])/(cache[3]*cache[5]);; 1841 } else {; 1842 fu = ((TF3*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5],cache[6] - 0.5*cache[7],cache[6] + 0.5*cache[7])/(cache[3]*cache[5]*cache[7]);; 1843 }; 1844 if (TF1::RejectedPoint()) {cache += fPointSize; continue;}; 1845 eu = cache[1];; 1846 Derivatives(df,x);; 1847 Int_t n = 0;; 1848 fsum = (fu-cu)/eu;; 1849 if (flag!=1) {; 1850 for (j=0;j<npar;j++) {; 1851 if (pl0[j]>0){; 1852 df[n] = df[j]/eu;; 1853 // left only non-fixed param derivatives / by Sigma; 1854 gin[j] += df[n]*fsum;; 1855 n++;; 1856 }; 1857 }; 1858 Int_t l = 0;; 1859 for (j=0;j<n;j++); 1860 for (Int_t k=0;k<=j;k++); 1861 zik[l++] += df[j]*df[k];; 1862 }; 1863 f += .5*fsum*fsum;; 1864 npfit++;; 1865 cache += fPointSize;; 1866 }; 1867 f1->SetNumberFitPoints(npfit);; 1868 delete[] df;; 1869}; 1870 ; 1871////////////////////////////////////////////////////////////////////////////////; 1872/// Minimization function for H1s using a Likelihood method.; 1873/// Ba",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:52802,Performance,cache,cache,52802,"r, Double_t *gin, Double_t &f, Double_t *u, Int_t flag); 1810{; 1811 Double_t cu,eu,fu,fsum;; 1812 Double_t x[3];; 1813 Double_t *zik=nullptr;; 1814 Double_t *pl0=nullptr;; 1815 ; 1816 TH1 *hfit = (TH1*)GetObjectFit();; 1817 TF1 *f1 = (TF1*)GetUserFunc();; 1818 Int_t nd = hfit->GetDimension();; 1819 Int_t j;; 1820 ; 1821 f1->InitArgs(x,u);; 1822 npar = f1->GetNpar();; 1823 SetParNumber(npar);; 1824 if(flag == 9) return;; 1825 zik = GetZ();; 1826 pl0 = GetPL0();; 1827 ; 1828 Double_t *df=new Double_t[npar];; 1829 f = 0;; 1830 ; 1831 Int_t npfit = 0;; 1832 Double_t *cache = fCache;; 1833 for (Int_t i=0;i<fNpoints;i++) {; 1834 cu = cache[0];; 1835 TF1::RejectPoint(kFALSE);; 1836 f1->SetParameters(u);; 1837 if (nd < 2) {; 1838 fu = f1->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3])/cache[3];; 1839 } else if (nd < 3) {; 1840 fu = ((TF2*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5])/(cache[3]*cache[5]);; 1841 } else {; 1842 fu = ((TF3*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5],cache[6] - 0.5*cache[7],cache[6] + 0.5*cache[7])/(cache[3]*cache[5]*cache[7]);; 1843 }; 1844 if (TF1::RejectedPoint()) {cache += fPointSize; continue;}; 1845 eu = cache[1];; 1846 Derivatives(df,x);; 1847 Int_t n = 0;; 1848 fsum = (fu-cu)/eu;; 1849 if (flag!=1) {; 1850 for (j=0;j<npar;j++) {; 1851 if (pl0[j]>0){; 1852 df[n] = df[j]/eu;; 1853 // left only non-fixed param derivatives / by Sigma; 1854 gin[j] += df[n]*fsum;; 1855 n++;; 1856 }; 1857 }; 1858 Int_t l = 0;; 1859 for (j=0;j<n;j++); 1860 for (Int_t k=0;k<=j;k++); 1861 zik[l++] += df[j]*df[k];; 1862 }; 1863 f += .5*fsum*fsum;; 1864 npfit++;; 1865 cache += fPointSize;; 1866 }; 1867 f1->SetNumberFitPoints(npfit);; 1868 delete[] df;; 1869}; 1870 ; 1871////////////////////////////////////////////////////////////////////////////////; 1872/// Minimization function for H1s using a Likelihood method.; 1873/// Ba",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:52860,Performance,cache,cache,52860,"r, Double_t *gin, Double_t &f, Double_t *u, Int_t flag); 1810{; 1811 Double_t cu,eu,fu,fsum;; 1812 Double_t x[3];; 1813 Double_t *zik=nullptr;; 1814 Double_t *pl0=nullptr;; 1815 ; 1816 TH1 *hfit = (TH1*)GetObjectFit();; 1817 TF1 *f1 = (TF1*)GetUserFunc();; 1818 Int_t nd = hfit->GetDimension();; 1819 Int_t j;; 1820 ; 1821 f1->InitArgs(x,u);; 1822 npar = f1->GetNpar();; 1823 SetParNumber(npar);; 1824 if(flag == 9) return;; 1825 zik = GetZ();; 1826 pl0 = GetPL0();; 1827 ; 1828 Double_t *df=new Double_t[npar];; 1829 f = 0;; 1830 ; 1831 Int_t npfit = 0;; 1832 Double_t *cache = fCache;; 1833 for (Int_t i=0;i<fNpoints;i++) {; 1834 cu = cache[0];; 1835 TF1::RejectPoint(kFALSE);; 1836 f1->SetParameters(u);; 1837 if (nd < 2) {; 1838 fu = f1->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3])/cache[3];; 1839 } else if (nd < 3) {; 1840 fu = ((TF2*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5])/(cache[3]*cache[5]);; 1841 } else {; 1842 fu = ((TF3*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5],cache[6] - 0.5*cache[7],cache[6] + 0.5*cache[7])/(cache[3]*cache[5]*cache[7]);; 1843 }; 1844 if (TF1::RejectedPoint()) {cache += fPointSize; continue;}; 1845 eu = cache[1];; 1846 Derivatives(df,x);; 1847 Int_t n = 0;; 1848 fsum = (fu-cu)/eu;; 1849 if (flag!=1) {; 1850 for (j=0;j<npar;j++) {; 1851 if (pl0[j]>0){; 1852 df[n] = df[j]/eu;; 1853 // left only non-fixed param derivatives / by Sigma; 1854 gin[j] += df[n]*fsum;; 1855 n++;; 1856 }; 1857 }; 1858 Int_t l = 0;; 1859 for (j=0;j<n;j++); 1860 for (Int_t k=0;k<=j;k++); 1861 zik[l++] += df[j]*df[k];; 1862 }; 1863 f += .5*fsum*fsum;; 1864 npfit++;; 1865 cache += fPointSize;; 1866 }; 1867 f1->SetNumberFitPoints(npfit);; 1868 delete[] df;; 1869}; 1870 ; 1871////////////////////////////////////////////////////////////////////////////////; 1872/// Minimization function for H1s using a Likelihood method.; 1873/// Ba",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:52875,Performance,cache,cache,52875,"10{; 1811 Double_t cu,eu,fu,fsum;; 1812 Double_t x[3];; 1813 Double_t *zik=nullptr;; 1814 Double_t *pl0=nullptr;; 1815 ; 1816 TH1 *hfit = (TH1*)GetObjectFit();; 1817 TF1 *f1 = (TF1*)GetUserFunc();; 1818 Int_t nd = hfit->GetDimension();; 1819 Int_t j;; 1820 ; 1821 f1->InitArgs(x,u);; 1822 npar = f1->GetNpar();; 1823 SetParNumber(npar);; 1824 if(flag == 9) return;; 1825 zik = GetZ();; 1826 pl0 = GetPL0();; 1827 ; 1828 Double_t *df=new Double_t[npar];; 1829 f = 0;; 1830 ; 1831 Int_t npfit = 0;; 1832 Double_t *cache = fCache;; 1833 for (Int_t i=0;i<fNpoints;i++) {; 1834 cu = cache[0];; 1835 TF1::RejectPoint(kFALSE);; 1836 f1->SetParameters(u);; 1837 if (nd < 2) {; 1838 fu = f1->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3])/cache[3];; 1839 } else if (nd < 3) {; 1840 fu = ((TF2*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5])/(cache[3]*cache[5]);; 1841 } else {; 1842 fu = ((TF3*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5],cache[6] - 0.5*cache[7],cache[6] + 0.5*cache[7])/(cache[3]*cache[5]*cache[7]);; 1843 }; 1844 if (TF1::RejectedPoint()) {cache += fPointSize; continue;}; 1845 eu = cache[1];; 1846 Derivatives(df,x);; 1847 Int_t n = 0;; 1848 fsum = (fu-cu)/eu;; 1849 if (flag!=1) {; 1850 for (j=0;j<npar;j++) {; 1851 if (pl0[j]>0){; 1852 df[n] = df[j]/eu;; 1853 // left only non-fixed param derivatives / by Sigma; 1854 gin[j] += df[n]*fsum;; 1855 n++;; 1856 }; 1857 }; 1858 Int_t l = 0;; 1859 for (j=0;j<n;j++); 1860 for (Int_t k=0;k<=j;k++); 1861 zik[l++] += df[j]*df[k];; 1862 }; 1863 f += .5*fsum*fsum;; 1864 npfit++;; 1865 cache += fPointSize;; 1866 }; 1867 f1->SetNumberFitPoints(npfit);; 1868 delete[] df;; 1869}; 1870 ; 1871////////////////////////////////////////////////////////////////////////////////; 1872/// Minimization function for H1s using a Likelihood method.; 1873/// Basically, it forms the likelihood by determining the Poisso",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:52884,Performance,cache,cache,52884,"10{; 1811 Double_t cu,eu,fu,fsum;; 1812 Double_t x[3];; 1813 Double_t *zik=nullptr;; 1814 Double_t *pl0=nullptr;; 1815 ; 1816 TH1 *hfit = (TH1*)GetObjectFit();; 1817 TF1 *f1 = (TF1*)GetUserFunc();; 1818 Int_t nd = hfit->GetDimension();; 1819 Int_t j;; 1820 ; 1821 f1->InitArgs(x,u);; 1822 npar = f1->GetNpar();; 1823 SetParNumber(npar);; 1824 if(flag == 9) return;; 1825 zik = GetZ();; 1826 pl0 = GetPL0();; 1827 ; 1828 Double_t *df=new Double_t[npar];; 1829 f = 0;; 1830 ; 1831 Int_t npfit = 0;; 1832 Double_t *cache = fCache;; 1833 for (Int_t i=0;i<fNpoints;i++) {; 1834 cu = cache[0];; 1835 TF1::RejectPoint(kFALSE);; 1836 f1->SetParameters(u);; 1837 if (nd < 2) {; 1838 fu = f1->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3])/cache[3];; 1839 } else if (nd < 3) {; 1840 fu = ((TF2*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5])/(cache[3]*cache[5]);; 1841 } else {; 1842 fu = ((TF3*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5],cache[6] - 0.5*cache[7],cache[6] + 0.5*cache[7])/(cache[3]*cache[5]*cache[7]);; 1843 }; 1844 if (TF1::RejectedPoint()) {cache += fPointSize; continue;}; 1845 eu = cache[1];; 1846 Derivatives(df,x);; 1847 Int_t n = 0;; 1848 fsum = (fu-cu)/eu;; 1849 if (flag!=1) {; 1850 for (j=0;j<npar;j++) {; 1851 if (pl0[j]>0){; 1852 df[n] = df[j]/eu;; 1853 // left only non-fixed param derivatives / by Sigma; 1854 gin[j] += df[n]*fsum;; 1855 n++;; 1856 }; 1857 }; 1858 Int_t l = 0;; 1859 for (j=0;j<n;j++); 1860 for (Int_t k=0;k<=j;k++); 1861 zik[l++] += df[j]*df[k];; 1862 }; 1863 f += .5*fsum*fsum;; 1864 npfit++;; 1865 cache += fPointSize;; 1866 }; 1867 f1->SetNumberFitPoints(npfit);; 1868 delete[] df;; 1869}; 1870 ; 1871////////////////////////////////////////////////////////////////////////////////; 1872/// Minimization function for H1s using a Likelihood method.; 1873/// Basically, it forms the likelihood by determining the Poisso",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:52899,Performance,cache,cache,52899,",fu,fsum;; 1812 Double_t x[3];; 1813 Double_t *zik=nullptr;; 1814 Double_t *pl0=nullptr;; 1815 ; 1816 TH1 *hfit = (TH1*)GetObjectFit();; 1817 TF1 *f1 = (TF1*)GetUserFunc();; 1818 Int_t nd = hfit->GetDimension();; 1819 Int_t j;; 1820 ; 1821 f1->InitArgs(x,u);; 1822 npar = f1->GetNpar();; 1823 SetParNumber(npar);; 1824 if(flag == 9) return;; 1825 zik = GetZ();; 1826 pl0 = GetPL0();; 1827 ; 1828 Double_t *df=new Double_t[npar];; 1829 f = 0;; 1830 ; 1831 Int_t npfit = 0;; 1832 Double_t *cache = fCache;; 1833 for (Int_t i=0;i<fNpoints;i++) {; 1834 cu = cache[0];; 1835 TF1::RejectPoint(kFALSE);; 1836 f1->SetParameters(u);; 1837 if (nd < 2) {; 1838 fu = f1->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3])/cache[3];; 1839 } else if (nd < 3) {; 1840 fu = ((TF2*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5])/(cache[3]*cache[5]);; 1841 } else {; 1842 fu = ((TF3*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5],cache[6] - 0.5*cache[7],cache[6] + 0.5*cache[7])/(cache[3]*cache[5]*cache[7]);; 1843 }; 1844 if (TF1::RejectedPoint()) {cache += fPointSize; continue;}; 1845 eu = cache[1];; 1846 Derivatives(df,x);; 1847 Int_t n = 0;; 1848 fsum = (fu-cu)/eu;; 1849 if (flag!=1) {; 1850 for (j=0;j<npar;j++) {; 1851 if (pl0[j]>0){; 1852 df[n] = df[j]/eu;; 1853 // left only non-fixed param derivatives / by Sigma; 1854 gin[j] += df[n]*fsum;; 1855 n++;; 1856 }; 1857 }; 1858 Int_t l = 0;; 1859 for (j=0;j<n;j++); 1860 for (Int_t k=0;k<=j;k++); 1861 zik[l++] += df[j]*df[k];; 1862 }; 1863 f += .5*fsum*fsum;; 1864 npfit++;; 1865 cache += fPointSize;; 1866 }; 1867 f1->SetNumberFitPoints(npfit);; 1868 delete[] df;; 1869}; 1870 ; 1871////////////////////////////////////////////////////////////////////////////////; 1872/// Minimization function for H1s using a Likelihood method.; 1873/// Basically, it forms the likelihood by determining the Poisson; 1874/// probability t",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:52908,Performance,cache,cache,52908,",fu,fsum;; 1812 Double_t x[3];; 1813 Double_t *zik=nullptr;; 1814 Double_t *pl0=nullptr;; 1815 ; 1816 TH1 *hfit = (TH1*)GetObjectFit();; 1817 TF1 *f1 = (TF1*)GetUserFunc();; 1818 Int_t nd = hfit->GetDimension();; 1819 Int_t j;; 1820 ; 1821 f1->InitArgs(x,u);; 1822 npar = f1->GetNpar();; 1823 SetParNumber(npar);; 1824 if(flag == 9) return;; 1825 zik = GetZ();; 1826 pl0 = GetPL0();; 1827 ; 1828 Double_t *df=new Double_t[npar];; 1829 f = 0;; 1830 ; 1831 Int_t npfit = 0;; 1832 Double_t *cache = fCache;; 1833 for (Int_t i=0;i<fNpoints;i++) {; 1834 cu = cache[0];; 1835 TF1::RejectPoint(kFALSE);; 1836 f1->SetParameters(u);; 1837 if (nd < 2) {; 1838 fu = f1->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3])/cache[3];; 1839 } else if (nd < 3) {; 1840 fu = ((TF2*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5])/(cache[3]*cache[5]);; 1841 } else {; 1842 fu = ((TF3*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5],cache[6] - 0.5*cache[7],cache[6] + 0.5*cache[7])/(cache[3]*cache[5]*cache[7]);; 1843 }; 1844 if (TF1::RejectedPoint()) {cache += fPointSize; continue;}; 1845 eu = cache[1];; 1846 Derivatives(df,x);; 1847 Int_t n = 0;; 1848 fsum = (fu-cu)/eu;; 1849 if (flag!=1) {; 1850 for (j=0;j<npar;j++) {; 1851 if (pl0[j]>0){; 1852 df[n] = df[j]/eu;; 1853 // left only non-fixed param derivatives / by Sigma; 1854 gin[j] += df[n]*fsum;; 1855 n++;; 1856 }; 1857 }; 1858 Int_t l = 0;; 1859 for (j=0;j<n;j++); 1860 for (Int_t k=0;k<=j;k++); 1861 zik[l++] += df[j]*df[k];; 1862 }; 1863 f += .5*fsum*fsum;; 1864 npfit++;; 1865 cache += fPointSize;; 1866 }; 1867 f1->SetNumberFitPoints(npfit);; 1868 delete[] df;; 1869}; 1870 ; 1871////////////////////////////////////////////////////////////////////////////////; 1872/// Minimization function for H1s using a Likelihood method.; 1873/// Basically, it forms the likelihood by determining the Poisson; 1874/// probability t",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:52923,Performance,cache,cache,52923," x[3];; 1813 Double_t *zik=nullptr;; 1814 Double_t *pl0=nullptr;; 1815 ; 1816 TH1 *hfit = (TH1*)GetObjectFit();; 1817 TF1 *f1 = (TF1*)GetUserFunc();; 1818 Int_t nd = hfit->GetDimension();; 1819 Int_t j;; 1820 ; 1821 f1->InitArgs(x,u);; 1822 npar = f1->GetNpar();; 1823 SetParNumber(npar);; 1824 if(flag == 9) return;; 1825 zik = GetZ();; 1826 pl0 = GetPL0();; 1827 ; 1828 Double_t *df=new Double_t[npar];; 1829 f = 0;; 1830 ; 1831 Int_t npfit = 0;; 1832 Double_t *cache = fCache;; 1833 for (Int_t i=0;i<fNpoints;i++) {; 1834 cu = cache[0];; 1835 TF1::RejectPoint(kFALSE);; 1836 f1->SetParameters(u);; 1837 if (nd < 2) {; 1838 fu = f1->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3])/cache[3];; 1839 } else if (nd < 3) {; 1840 fu = ((TF2*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5])/(cache[3]*cache[5]);; 1841 } else {; 1842 fu = ((TF3*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5],cache[6] - 0.5*cache[7],cache[6] + 0.5*cache[7])/(cache[3]*cache[5]*cache[7]);; 1843 }; 1844 if (TF1::RejectedPoint()) {cache += fPointSize; continue;}; 1845 eu = cache[1];; 1846 Derivatives(df,x);; 1847 Int_t n = 0;; 1848 fsum = (fu-cu)/eu;; 1849 if (flag!=1) {; 1850 for (j=0;j<npar;j++) {; 1851 if (pl0[j]>0){; 1852 df[n] = df[j]/eu;; 1853 // left only non-fixed param derivatives / by Sigma; 1854 gin[j] += df[n]*fsum;; 1855 n++;; 1856 }; 1857 }; 1858 Int_t l = 0;; 1859 for (j=0;j<n;j++); 1860 for (Int_t k=0;k<=j;k++); 1861 zik[l++] += df[j]*df[k];; 1862 }; 1863 f += .5*fsum*fsum;; 1864 npfit++;; 1865 cache += fPointSize;; 1866 }; 1867 f1->SetNumberFitPoints(npfit);; 1868 delete[] df;; 1869}; 1870 ; 1871////////////////////////////////////////////////////////////////////////////////; 1872/// Minimization function for H1s using a Likelihood method.; 1873/// Basically, it forms the likelihood by determining the Poisson; 1874/// probability that given a number of en",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:52932,Performance,cache,cache,52932," x[3];; 1813 Double_t *zik=nullptr;; 1814 Double_t *pl0=nullptr;; 1815 ; 1816 TH1 *hfit = (TH1*)GetObjectFit();; 1817 TF1 *f1 = (TF1*)GetUserFunc();; 1818 Int_t nd = hfit->GetDimension();; 1819 Int_t j;; 1820 ; 1821 f1->InitArgs(x,u);; 1822 npar = f1->GetNpar();; 1823 SetParNumber(npar);; 1824 if(flag == 9) return;; 1825 zik = GetZ();; 1826 pl0 = GetPL0();; 1827 ; 1828 Double_t *df=new Double_t[npar];; 1829 f = 0;; 1830 ; 1831 Int_t npfit = 0;; 1832 Double_t *cache = fCache;; 1833 for (Int_t i=0;i<fNpoints;i++) {; 1834 cu = cache[0];; 1835 TF1::RejectPoint(kFALSE);; 1836 f1->SetParameters(u);; 1837 if (nd < 2) {; 1838 fu = f1->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3])/cache[3];; 1839 } else if (nd < 3) {; 1840 fu = ((TF2*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5])/(cache[3]*cache[5]);; 1841 } else {; 1842 fu = ((TF3*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5],cache[6] - 0.5*cache[7],cache[6] + 0.5*cache[7])/(cache[3]*cache[5]*cache[7]);; 1843 }; 1844 if (TF1::RejectedPoint()) {cache += fPointSize; continue;}; 1845 eu = cache[1];; 1846 Derivatives(df,x);; 1847 Int_t n = 0;; 1848 fsum = (fu-cu)/eu;; 1849 if (flag!=1) {; 1850 for (j=0;j<npar;j++) {; 1851 if (pl0[j]>0){; 1852 df[n] = df[j]/eu;; 1853 // left only non-fixed param derivatives / by Sigma; 1854 gin[j] += df[n]*fsum;; 1855 n++;; 1856 }; 1857 }; 1858 Int_t l = 0;; 1859 for (j=0;j<n;j++); 1860 for (Int_t k=0;k<=j;k++); 1861 zik[l++] += df[j]*df[k];; 1862 }; 1863 f += .5*fsum*fsum;; 1864 npfit++;; 1865 cache += fPointSize;; 1866 }; 1867 f1->SetNumberFitPoints(npfit);; 1868 delete[] df;; 1869}; 1870 ; 1871////////////////////////////////////////////////////////////////////////////////; 1872/// Minimization function for H1s using a Likelihood method.; 1873/// Basically, it forms the likelihood by determining the Poisson; 1874/// probability that given a number of en",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:52947,Performance,cache,cache,52947,"ik=nullptr;; 1814 Double_t *pl0=nullptr;; 1815 ; 1816 TH1 *hfit = (TH1*)GetObjectFit();; 1817 TF1 *f1 = (TF1*)GetUserFunc();; 1818 Int_t nd = hfit->GetDimension();; 1819 Int_t j;; 1820 ; 1821 f1->InitArgs(x,u);; 1822 npar = f1->GetNpar();; 1823 SetParNumber(npar);; 1824 if(flag == 9) return;; 1825 zik = GetZ();; 1826 pl0 = GetPL0();; 1827 ; 1828 Double_t *df=new Double_t[npar];; 1829 f = 0;; 1830 ; 1831 Int_t npfit = 0;; 1832 Double_t *cache = fCache;; 1833 for (Int_t i=0;i<fNpoints;i++) {; 1834 cu = cache[0];; 1835 TF1::RejectPoint(kFALSE);; 1836 f1->SetParameters(u);; 1837 if (nd < 2) {; 1838 fu = f1->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3])/cache[3];; 1839 } else if (nd < 3) {; 1840 fu = ((TF2*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5])/(cache[3]*cache[5]);; 1841 } else {; 1842 fu = ((TF3*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5],cache[6] - 0.5*cache[7],cache[6] + 0.5*cache[7])/(cache[3]*cache[5]*cache[7]);; 1843 }; 1844 if (TF1::RejectedPoint()) {cache += fPointSize; continue;}; 1845 eu = cache[1];; 1846 Derivatives(df,x);; 1847 Int_t n = 0;; 1848 fsum = (fu-cu)/eu;; 1849 if (flag!=1) {; 1850 for (j=0;j<npar;j++) {; 1851 if (pl0[j]>0){; 1852 df[n] = df[j]/eu;; 1853 // left only non-fixed param derivatives / by Sigma; 1854 gin[j] += df[n]*fsum;; 1855 n++;; 1856 }; 1857 }; 1858 Int_t l = 0;; 1859 for (j=0;j<n;j++); 1860 for (Int_t k=0;k<=j;k++); 1861 zik[l++] += df[j]*df[k];; 1862 }; 1863 f += .5*fsum*fsum;; 1864 npfit++;; 1865 cache += fPointSize;; 1866 }; 1867 f1->SetNumberFitPoints(npfit);; 1868 delete[] df;; 1869}; 1870 ; 1871////////////////////////////////////////////////////////////////////////////////; 1872/// Minimization function for H1s using a Likelihood method.; 1873/// Basically, it forms the likelihood by determining the Poisson; 1874/// probability that given a number of entries in a particular bi",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:52956,Performance,cache,cache,52956,"ik=nullptr;; 1814 Double_t *pl0=nullptr;; 1815 ; 1816 TH1 *hfit = (TH1*)GetObjectFit();; 1817 TF1 *f1 = (TF1*)GetUserFunc();; 1818 Int_t nd = hfit->GetDimension();; 1819 Int_t j;; 1820 ; 1821 f1->InitArgs(x,u);; 1822 npar = f1->GetNpar();; 1823 SetParNumber(npar);; 1824 if(flag == 9) return;; 1825 zik = GetZ();; 1826 pl0 = GetPL0();; 1827 ; 1828 Double_t *df=new Double_t[npar];; 1829 f = 0;; 1830 ; 1831 Int_t npfit = 0;; 1832 Double_t *cache = fCache;; 1833 for (Int_t i=0;i<fNpoints;i++) {; 1834 cu = cache[0];; 1835 TF1::RejectPoint(kFALSE);; 1836 f1->SetParameters(u);; 1837 if (nd < 2) {; 1838 fu = f1->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3])/cache[3];; 1839 } else if (nd < 3) {; 1840 fu = ((TF2*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5])/(cache[3]*cache[5]);; 1841 } else {; 1842 fu = ((TF3*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5],cache[6] - 0.5*cache[7],cache[6] + 0.5*cache[7])/(cache[3]*cache[5]*cache[7]);; 1843 }; 1844 if (TF1::RejectedPoint()) {cache += fPointSize; continue;}; 1845 eu = cache[1];; 1846 Derivatives(df,x);; 1847 Int_t n = 0;; 1848 fsum = (fu-cu)/eu;; 1849 if (flag!=1) {; 1850 for (j=0;j<npar;j++) {; 1851 if (pl0[j]>0){; 1852 df[n] = df[j]/eu;; 1853 // left only non-fixed param derivatives / by Sigma; 1854 gin[j] += df[n]*fsum;; 1855 n++;; 1856 }; 1857 }; 1858 Int_t l = 0;; 1859 for (j=0;j<n;j++); 1860 for (Int_t k=0;k<=j;k++); 1861 zik[l++] += df[j]*df[k];; 1862 }; 1863 f += .5*fsum*fsum;; 1864 npfit++;; 1865 cache += fPointSize;; 1866 }; 1867 f1->SetNumberFitPoints(npfit);; 1868 delete[] df;; 1869}; 1870 ; 1871////////////////////////////////////////////////////////////////////////////////; 1872/// Minimization function for H1s using a Likelihood method.; 1873/// Basically, it forms the likelihood by determining the Poisson; 1874/// probability that given a number of entries in a particular bi",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:52971,Performance,cache,cache,52971,"_t *pl0=nullptr;; 1815 ; 1816 TH1 *hfit = (TH1*)GetObjectFit();; 1817 TF1 *f1 = (TF1*)GetUserFunc();; 1818 Int_t nd = hfit->GetDimension();; 1819 Int_t j;; 1820 ; 1821 f1->InitArgs(x,u);; 1822 npar = f1->GetNpar();; 1823 SetParNumber(npar);; 1824 if(flag == 9) return;; 1825 zik = GetZ();; 1826 pl0 = GetPL0();; 1827 ; 1828 Double_t *df=new Double_t[npar];; 1829 f = 0;; 1830 ; 1831 Int_t npfit = 0;; 1832 Double_t *cache = fCache;; 1833 for (Int_t i=0;i<fNpoints;i++) {; 1834 cu = cache[0];; 1835 TF1::RejectPoint(kFALSE);; 1836 f1->SetParameters(u);; 1837 if (nd < 2) {; 1838 fu = f1->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3])/cache[3];; 1839 } else if (nd < 3) {; 1840 fu = ((TF2*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5])/(cache[3]*cache[5]);; 1841 } else {; 1842 fu = ((TF3*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5],cache[6] - 0.5*cache[7],cache[6] + 0.5*cache[7])/(cache[3]*cache[5]*cache[7]);; 1843 }; 1844 if (TF1::RejectedPoint()) {cache += fPointSize; continue;}; 1845 eu = cache[1];; 1846 Derivatives(df,x);; 1847 Int_t n = 0;; 1848 fsum = (fu-cu)/eu;; 1849 if (flag!=1) {; 1850 for (j=0;j<npar;j++) {; 1851 if (pl0[j]>0){; 1852 df[n] = df[j]/eu;; 1853 // left only non-fixed param derivatives / by Sigma; 1854 gin[j] += df[n]*fsum;; 1855 n++;; 1856 }; 1857 }; 1858 Int_t l = 0;; 1859 for (j=0;j<n;j++); 1860 for (Int_t k=0;k<=j;k++); 1861 zik[l++] += df[j]*df[k];; 1862 }; 1863 f += .5*fsum*fsum;; 1864 npfit++;; 1865 cache += fPointSize;; 1866 }; 1867 f1->SetNumberFitPoints(npfit);; 1868 delete[] df;; 1869}; 1870 ; 1871////////////////////////////////////////////////////////////////////////////////; 1872/// Minimization function for H1s using a Likelihood method.; 1873/// Basically, it forms the likelihood by determining the Poisson; 1874/// probability that given a number of entries in a particular bin,; 1875/// the fit woul",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:52980,Performance,cache,cache,52980,"_t *pl0=nullptr;; 1815 ; 1816 TH1 *hfit = (TH1*)GetObjectFit();; 1817 TF1 *f1 = (TF1*)GetUserFunc();; 1818 Int_t nd = hfit->GetDimension();; 1819 Int_t j;; 1820 ; 1821 f1->InitArgs(x,u);; 1822 npar = f1->GetNpar();; 1823 SetParNumber(npar);; 1824 if(flag == 9) return;; 1825 zik = GetZ();; 1826 pl0 = GetPL0();; 1827 ; 1828 Double_t *df=new Double_t[npar];; 1829 f = 0;; 1830 ; 1831 Int_t npfit = 0;; 1832 Double_t *cache = fCache;; 1833 for (Int_t i=0;i<fNpoints;i++) {; 1834 cu = cache[0];; 1835 TF1::RejectPoint(kFALSE);; 1836 f1->SetParameters(u);; 1837 if (nd < 2) {; 1838 fu = f1->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3])/cache[3];; 1839 } else if (nd < 3) {; 1840 fu = ((TF2*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5])/(cache[3]*cache[5]);; 1841 } else {; 1842 fu = ((TF3*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5],cache[6] - 0.5*cache[7],cache[6] + 0.5*cache[7])/(cache[3]*cache[5]*cache[7]);; 1843 }; 1844 if (TF1::RejectedPoint()) {cache += fPointSize; continue;}; 1845 eu = cache[1];; 1846 Derivatives(df,x);; 1847 Int_t n = 0;; 1848 fsum = (fu-cu)/eu;; 1849 if (flag!=1) {; 1850 for (j=0;j<npar;j++) {; 1851 if (pl0[j]>0){; 1852 df[n] = df[j]/eu;; 1853 // left only non-fixed param derivatives / by Sigma; 1854 gin[j] += df[n]*fsum;; 1855 n++;; 1856 }; 1857 }; 1858 Int_t l = 0;; 1859 for (j=0;j<n;j++); 1860 for (Int_t k=0;k<=j;k++); 1861 zik[l++] += df[j]*df[k];; 1862 }; 1863 f += .5*fsum*fsum;; 1864 npfit++;; 1865 cache += fPointSize;; 1866 }; 1867 f1->SetNumberFitPoints(npfit);; 1868 delete[] df;; 1869}; 1870 ; 1871////////////////////////////////////////////////////////////////////////////////; 1872/// Minimization function for H1s using a Likelihood method.; 1873/// Basically, it forms the likelihood by determining the Poisson; 1874/// probability that given a number of entries in a particular bin,; 1875/// the fit woul",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:52995,Performance,cache,cache,52995,"GetZ();; 1826 pl0 = GetPL0();; 1827 ; 1828 Double_t *df=new Double_t[npar];; 1829 f = 0;; 1830 ; 1831 Int_t npfit = 0;; 1832 Double_t *cache = fCache;; 1833 for (Int_t i=0;i<fNpoints;i++) {; 1834 cu = cache[0];; 1835 TF1::RejectPoint(kFALSE);; 1836 f1->SetParameters(u);; 1837 if (nd < 2) {; 1838 fu = f1->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3])/cache[3];; 1839 } else if (nd < 3) {; 1840 fu = ((TF2*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5])/(cache[3]*cache[5]);; 1841 } else {; 1842 fu = ((TF3*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5],cache[6] - 0.5*cache[7],cache[6] + 0.5*cache[7])/(cache[3]*cache[5]*cache[7]);; 1843 }; 1844 if (TF1::RejectedPoint()) {cache += fPointSize; continue;}; 1845 eu = cache[1];; 1846 Derivatives(df,x);; 1847 Int_t n = 0;; 1848 fsum = (fu-cu)/eu;; 1849 if (flag!=1) {; 1850 for (j=0;j<npar;j++) {; 1851 if (pl0[j]>0){; 1852 df[n] = df[j]/eu;; 1853 // left only non-fixed param derivatives / by Sigma; 1854 gin[j] += df[n]*fsum;; 1855 n++;; 1856 }; 1857 }; 1858 Int_t l = 0;; 1859 for (j=0;j<n;j++); 1860 for (Int_t k=0;k<=j;k++); 1861 zik[l++] += df[j]*df[k];; 1862 }; 1863 f += .5*fsum*fsum;; 1864 npfit++;; 1865 cache += fPointSize;; 1866 }; 1867 f1->SetNumberFitPoints(npfit);; 1868 delete[] df;; 1869}; 1870 ; 1871////////////////////////////////////////////////////////////////////////////////; 1872/// Minimization function for H1s using a Likelihood method.; 1873/// Basically, it forms the likelihood by determining the Poisson; 1874/// probability that given a number of entries in a particular bin,; 1875/// the fit would predict it's value. This is then done for each bin,; 1876/// and the sum of the logs is taken as the likelihood.; 1877///; 1878/// Default method (function evaluated at center of bin); 1879/// for each point the cache contains the following info; 1880/// - 1D : bc,e,xc (bin cont",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:53006,Performance,cache,cache,53006,"GetZ();; 1826 pl0 = GetPL0();; 1827 ; 1828 Double_t *df=new Double_t[npar];; 1829 f = 0;; 1830 ; 1831 Int_t npfit = 0;; 1832 Double_t *cache = fCache;; 1833 for (Int_t i=0;i<fNpoints;i++) {; 1834 cu = cache[0];; 1835 TF1::RejectPoint(kFALSE);; 1836 f1->SetParameters(u);; 1837 if (nd < 2) {; 1838 fu = f1->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3])/cache[3];; 1839 } else if (nd < 3) {; 1840 fu = ((TF2*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5])/(cache[3]*cache[5]);; 1841 } else {; 1842 fu = ((TF3*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5],cache[6] - 0.5*cache[7],cache[6] + 0.5*cache[7])/(cache[3]*cache[5]*cache[7]);; 1843 }; 1844 if (TF1::RejectedPoint()) {cache += fPointSize; continue;}; 1845 eu = cache[1];; 1846 Derivatives(df,x);; 1847 Int_t n = 0;; 1848 fsum = (fu-cu)/eu;; 1849 if (flag!=1) {; 1850 for (j=0;j<npar;j++) {; 1851 if (pl0[j]>0){; 1852 df[n] = df[j]/eu;; 1853 // left only non-fixed param derivatives / by Sigma; 1854 gin[j] += df[n]*fsum;; 1855 n++;; 1856 }; 1857 }; 1858 Int_t l = 0;; 1859 for (j=0;j<n;j++); 1860 for (Int_t k=0;k<=j;k++); 1861 zik[l++] += df[j]*df[k];; 1862 }; 1863 f += .5*fsum*fsum;; 1864 npfit++;; 1865 cache += fPointSize;; 1866 }; 1867 f1->SetNumberFitPoints(npfit);; 1868 delete[] df;; 1869}; 1870 ; 1871////////////////////////////////////////////////////////////////////////////////; 1872/// Minimization function for H1s using a Likelihood method.; 1873/// Basically, it forms the likelihood by determining the Poisson; 1874/// probability that given a number of entries in a particular bin,; 1875/// the fit would predict it's value. This is then done for each bin,; 1876/// and the sum of the logs is taken as the likelihood.; 1877///; 1878/// Default method (function evaluated at center of bin); 1879/// for each point the cache contains the following info; 1880/// - 1D : bc,e,xc (bin cont",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:53015,Performance,cache,cache,53015,"GetZ();; 1826 pl0 = GetPL0();; 1827 ; 1828 Double_t *df=new Double_t[npar];; 1829 f = 0;; 1830 ; 1831 Int_t npfit = 0;; 1832 Double_t *cache = fCache;; 1833 for (Int_t i=0;i<fNpoints;i++) {; 1834 cu = cache[0];; 1835 TF1::RejectPoint(kFALSE);; 1836 f1->SetParameters(u);; 1837 if (nd < 2) {; 1838 fu = f1->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3])/cache[3];; 1839 } else if (nd < 3) {; 1840 fu = ((TF2*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5])/(cache[3]*cache[5]);; 1841 } else {; 1842 fu = ((TF3*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5],cache[6] - 0.5*cache[7],cache[6] + 0.5*cache[7])/(cache[3]*cache[5]*cache[7]);; 1843 }; 1844 if (TF1::RejectedPoint()) {cache += fPointSize; continue;}; 1845 eu = cache[1];; 1846 Derivatives(df,x);; 1847 Int_t n = 0;; 1848 fsum = (fu-cu)/eu;; 1849 if (flag!=1) {; 1850 for (j=0;j<npar;j++) {; 1851 if (pl0[j]>0){; 1852 df[n] = df[j]/eu;; 1853 // left only non-fixed param derivatives / by Sigma; 1854 gin[j] += df[n]*fsum;; 1855 n++;; 1856 }; 1857 }; 1858 Int_t l = 0;; 1859 for (j=0;j<n;j++); 1860 for (Int_t k=0;k<=j;k++); 1861 zik[l++] += df[j]*df[k];; 1862 }; 1863 f += .5*fsum*fsum;; 1864 npfit++;; 1865 cache += fPointSize;; 1866 }; 1867 f1->SetNumberFitPoints(npfit);; 1868 delete[] df;; 1869}; 1870 ; 1871////////////////////////////////////////////////////////////////////////////////; 1872/// Minimization function for H1s using a Likelihood method.; 1873/// Basically, it forms the likelihood by determining the Poisson; 1874/// probability that given a number of entries in a particular bin,; 1875/// the fit would predict it's value. This is then done for each bin,; 1876/// and the sum of the logs is taken as the likelihood.; 1877///; 1878/// Default method (function evaluated at center of bin); 1879/// for each point the cache contains the following info; 1880/// - 1D : bc,e,xc (bin cont",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:53024,Performance,cache,cache,53024,"GetZ();; 1826 pl0 = GetPL0();; 1827 ; 1828 Double_t *df=new Double_t[npar];; 1829 f = 0;; 1830 ; 1831 Int_t npfit = 0;; 1832 Double_t *cache = fCache;; 1833 for (Int_t i=0;i<fNpoints;i++) {; 1834 cu = cache[0];; 1835 TF1::RejectPoint(kFALSE);; 1836 f1->SetParameters(u);; 1837 if (nd < 2) {; 1838 fu = f1->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3])/cache[3];; 1839 } else if (nd < 3) {; 1840 fu = ((TF2*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5])/(cache[3]*cache[5]);; 1841 } else {; 1842 fu = ((TF3*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5],cache[6] - 0.5*cache[7],cache[6] + 0.5*cache[7])/(cache[3]*cache[5]*cache[7]);; 1843 }; 1844 if (TF1::RejectedPoint()) {cache += fPointSize; continue;}; 1845 eu = cache[1];; 1846 Derivatives(df,x);; 1847 Int_t n = 0;; 1848 fsum = (fu-cu)/eu;; 1849 if (flag!=1) {; 1850 for (j=0;j<npar;j++) {; 1851 if (pl0[j]>0){; 1852 df[n] = df[j]/eu;; 1853 // left only non-fixed param derivatives / by Sigma; 1854 gin[j] += df[n]*fsum;; 1855 n++;; 1856 }; 1857 }; 1858 Int_t l = 0;; 1859 for (j=0;j<n;j++); 1860 for (Int_t k=0;k<=j;k++); 1861 zik[l++] += df[j]*df[k];; 1862 }; 1863 f += .5*fsum*fsum;; 1864 npfit++;; 1865 cache += fPointSize;; 1866 }; 1867 f1->SetNumberFitPoints(npfit);; 1868 delete[] df;; 1869}; 1870 ; 1871////////////////////////////////////////////////////////////////////////////////; 1872/// Minimization function for H1s using a Likelihood method.; 1873/// Basically, it forms the likelihood by determining the Poisson; 1874/// probability that given a number of entries in a particular bin,; 1875/// the fit would predict it's value. This is then done for each bin,; 1876/// and the sum of the logs is taken as the likelihood.; 1877///; 1878/// Default method (function evaluated at center of bin); 1879/// for each point the cache contains the following info; 1880/// - 1D : bc,e,xc (bin cont",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:53076,Performance,cache,cache,53076,"GetZ();; 1826 pl0 = GetPL0();; 1827 ; 1828 Double_t *df=new Double_t[npar];; 1829 f = 0;; 1830 ; 1831 Int_t npfit = 0;; 1832 Double_t *cache = fCache;; 1833 for (Int_t i=0;i<fNpoints;i++) {; 1834 cu = cache[0];; 1835 TF1::RejectPoint(kFALSE);; 1836 f1->SetParameters(u);; 1837 if (nd < 2) {; 1838 fu = f1->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3])/cache[3];; 1839 } else if (nd < 3) {; 1840 fu = ((TF2*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5])/(cache[3]*cache[5]);; 1841 } else {; 1842 fu = ((TF3*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5],cache[6] - 0.5*cache[7],cache[6] + 0.5*cache[7])/(cache[3]*cache[5]*cache[7]);; 1843 }; 1844 if (TF1::RejectedPoint()) {cache += fPointSize; continue;}; 1845 eu = cache[1];; 1846 Derivatives(df,x);; 1847 Int_t n = 0;; 1848 fsum = (fu-cu)/eu;; 1849 if (flag!=1) {; 1850 for (j=0;j<npar;j++) {; 1851 if (pl0[j]>0){; 1852 df[n] = df[j]/eu;; 1853 // left only non-fixed param derivatives / by Sigma; 1854 gin[j] += df[n]*fsum;; 1855 n++;; 1856 }; 1857 }; 1858 Int_t l = 0;; 1859 for (j=0;j<n;j++); 1860 for (Int_t k=0;k<=j;k++); 1861 zik[l++] += df[j]*df[k];; 1862 }; 1863 f += .5*fsum*fsum;; 1864 npfit++;; 1865 cache += fPointSize;; 1866 }; 1867 f1->SetNumberFitPoints(npfit);; 1868 delete[] df;; 1869}; 1870 ; 1871////////////////////////////////////////////////////////////////////////////////; 1872/// Minimization function for H1s using a Likelihood method.; 1873/// Basically, it forms the likelihood by determining the Poisson; 1874/// probability that given a number of entries in a particular bin,; 1875/// the fit would predict it's value. This is then done for each bin,; 1876/// and the sum of the logs is taken as the likelihood.; 1877///; 1878/// Default method (function evaluated at center of bin); 1879/// for each point the cache contains the following info; 1880/// - 1D : bc,e,xc (bin cont",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:53119,Performance,cache,cache,53119,"GetZ();; 1826 pl0 = GetPL0();; 1827 ; 1828 Double_t *df=new Double_t[npar];; 1829 f = 0;; 1830 ; 1831 Int_t npfit = 0;; 1832 Double_t *cache = fCache;; 1833 for (Int_t i=0;i<fNpoints;i++) {; 1834 cu = cache[0];; 1835 TF1::RejectPoint(kFALSE);; 1836 f1->SetParameters(u);; 1837 if (nd < 2) {; 1838 fu = f1->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3])/cache[3];; 1839 } else if (nd < 3) {; 1840 fu = ((TF2*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5])/(cache[3]*cache[5]);; 1841 } else {; 1842 fu = ((TF3*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5],cache[6] - 0.5*cache[7],cache[6] + 0.5*cache[7])/(cache[3]*cache[5]*cache[7]);; 1843 }; 1844 if (TF1::RejectedPoint()) {cache += fPointSize; continue;}; 1845 eu = cache[1];; 1846 Derivatives(df,x);; 1847 Int_t n = 0;; 1848 fsum = (fu-cu)/eu;; 1849 if (flag!=1) {; 1850 for (j=0;j<npar;j++) {; 1851 if (pl0[j]>0){; 1852 df[n] = df[j]/eu;; 1853 // left only non-fixed param derivatives / by Sigma; 1854 gin[j] += df[n]*fsum;; 1855 n++;; 1856 }; 1857 }; 1858 Int_t l = 0;; 1859 for (j=0;j<n;j++); 1860 for (Int_t k=0;k<=j;k++); 1861 zik[l++] += df[j]*df[k];; 1862 }; 1863 f += .5*fsum*fsum;; 1864 npfit++;; 1865 cache += fPointSize;; 1866 }; 1867 f1->SetNumberFitPoints(npfit);; 1868 delete[] df;; 1869}; 1870 ; 1871////////////////////////////////////////////////////////////////////////////////; 1872/// Minimization function for H1s using a Likelihood method.; 1873/// Basically, it forms the likelihood by determining the Poisson; 1874/// probability that given a number of entries in a particular bin,; 1875/// the fit would predict it's value. This is then done for each bin,; 1876/// and the sum of the logs is taken as the likelihood.; 1877///; 1878/// Default method (function evaluated at center of bin); 1879/// for each point the cache contains the following info; 1880/// - 1D : bc,e,xc (bin cont",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:53565,Performance,cache,cache,53565," ((TF2*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5])/(cache[3]*cache[5]);; 1841 } else {; 1842 fu = ((TF3*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5],cache[6] - 0.5*cache[7],cache[6] + 0.5*cache[7])/(cache[3]*cache[5]*cache[7]);; 1843 }; 1844 if (TF1::RejectedPoint()) {cache += fPointSize; continue;}; 1845 eu = cache[1];; 1846 Derivatives(df,x);; 1847 Int_t n = 0;; 1848 fsum = (fu-cu)/eu;; 1849 if (flag!=1) {; 1850 for (j=0;j<npar;j++) {; 1851 if (pl0[j]>0){; 1852 df[n] = df[j]/eu;; 1853 // left only non-fixed param derivatives / by Sigma; 1854 gin[j] += df[n]*fsum;; 1855 n++;; 1856 }; 1857 }; 1858 Int_t l = 0;; 1859 for (j=0;j<n;j++); 1860 for (Int_t k=0;k<=j;k++); 1861 zik[l++] += df[j]*df[k];; 1862 }; 1863 f += .5*fsum*fsum;; 1864 npfit++;; 1865 cache += fPointSize;; 1866 }; 1867 f1->SetNumberFitPoints(npfit);; 1868 delete[] df;; 1869}; 1870 ; 1871////////////////////////////////////////////////////////////////////////////////; 1872/// Minimization function for H1s using a Likelihood method.; 1873/// Basically, it forms the likelihood by determining the Poisson; 1874/// probability that given a number of entries in a particular bin,; 1875/// the fit would predict it's value. This is then done for each bin,; 1876/// and the sum of the logs is taken as the likelihood.; 1877///; 1878/// Default method (function evaluated at center of bin); 1879/// for each point the cache contains the following info; 1880/// - 1D : bc,e,xc (bin content, error, x of center of bin); 1881/// - 2D : bc,e,xc,yc; 1882/// - 3D : bc,e,xc,yc,zc; 1883 ; 1884void TFumili::FitLikelihood(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag); 1885{; 1886 Foption_t fitOption = GetFitOption();; 1887 if (fitOption.Integral) {; 1888 FitLikelihoodI(npar,gin,f,u,flag);; 1889 return;; 1890 }; 1891 Double_t cu,fu,fobs,fsub;; 1892 Double_t dersum[100];; 1893 Doub",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:54195,Performance,cache,cache,54195," non-fixed param derivatives / by Sigma; 1854 gin[j] += df[n]*fsum;; 1855 n++;; 1856 }; 1857 }; 1858 Int_t l = 0;; 1859 for (j=0;j<n;j++); 1860 for (Int_t k=0;k<=j;k++); 1861 zik[l++] += df[j]*df[k];; 1862 }; 1863 f += .5*fsum*fsum;; 1864 npfit++;; 1865 cache += fPointSize;; 1866 }; 1867 f1->SetNumberFitPoints(npfit);; 1868 delete[] df;; 1869}; 1870 ; 1871////////////////////////////////////////////////////////////////////////////////; 1872/// Minimization function for H1s using a Likelihood method.; 1873/// Basically, it forms the likelihood by determining the Poisson; 1874/// probability that given a number of entries in a particular bin,; 1875/// the fit would predict it's value. This is then done for each bin,; 1876/// and the sum of the logs is taken as the likelihood.; 1877///; 1878/// Default method (function evaluated at center of bin); 1879/// for each point the cache contains the following info; 1880/// - 1D : bc,e,xc (bin content, error, x of center of bin); 1881/// - 2D : bc,e,xc,yc; 1882/// - 3D : bc,e,xc,yc,zc; 1883 ; 1884void TFumili::FitLikelihood(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag); 1885{; 1886 Foption_t fitOption = GetFitOption();; 1887 if (fitOption.Integral) {; 1888 FitLikelihoodI(npar,gin,f,u,flag);; 1889 return;; 1890 }; 1891 Double_t cu,fu,fobs,fsub;; 1892 Double_t dersum[100];; 1893 Double_t x[3];; 1894 Int_t icu;; 1895 ; 1896 TH1 *hfit = (TH1*)GetObjectFit();; 1897 TF1 *f1 = (TF1*)GetUserFunc();; 1898 Int_t nd = hfit->GetDimension();; 1899 Int_t j;; 1900 Double_t *zik = GetZ();; 1901 Double_t *pl0 = GetPL0();; 1902 ; 1903 npar = f1->GetNpar();; 1904 SetParNumber(npar);; 1905 if(flag == 9) return;; 1906 Double_t *df=new Double_t[npar];; 1907 if (flag == 2) for (j=0;j<npar;j++) dersum[j] = gin[j] = 0;; 1908 f1->InitArgs(x,u);; 1909 f = 0;; 1910 ; 1911 Int_t npfit = 0;; 1912 Double_t *cache = fCache;; 1913 for (Int_t i=0;i<fNpoints;i++) {; 1914 if (nd > 2) x[2] = cache[4];; 1915 if (nd > 1) x[1] = cache[3];; 1916 x[",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:55179,Performance,cache,cache,55179," 1877///; 1878/// Default method (function evaluated at center of bin); 1879/// for each point the cache contains the following info; 1880/// - 1D : bc,e,xc (bin content, error, x of center of bin); 1881/// - 2D : bc,e,xc,yc; 1882/// - 3D : bc,e,xc,yc,zc; 1883 ; 1884void TFumili::FitLikelihood(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag); 1885{; 1886 Foption_t fitOption = GetFitOption();; 1887 if (fitOption.Integral) {; 1888 FitLikelihoodI(npar,gin,f,u,flag);; 1889 return;; 1890 }; 1891 Double_t cu,fu,fobs,fsub;; 1892 Double_t dersum[100];; 1893 Double_t x[3];; 1894 Int_t icu;; 1895 ; 1896 TH1 *hfit = (TH1*)GetObjectFit();; 1897 TF1 *f1 = (TF1*)GetUserFunc();; 1898 Int_t nd = hfit->GetDimension();; 1899 Int_t j;; 1900 Double_t *zik = GetZ();; 1901 Double_t *pl0 = GetPL0();; 1902 ; 1903 npar = f1->GetNpar();; 1904 SetParNumber(npar);; 1905 if(flag == 9) return;; 1906 Double_t *df=new Double_t[npar];; 1907 if (flag == 2) for (j=0;j<npar;j++) dersum[j] = gin[j] = 0;; 1908 f1->InitArgs(x,u);; 1909 f = 0;; 1910 ; 1911 Int_t npfit = 0;; 1912 Double_t *cache = fCache;; 1913 for (Int_t i=0;i<fNpoints;i++) {; 1914 if (nd > 2) x[2] = cache[4];; 1915 if (nd > 1) x[1] = cache[3];; 1916 x[0] = cache[2];; 1917 cu = cache[0];; 1918 TF1::RejectPoint(kFALSE);; 1919 fu = f1->EvalPar(x,u);; 1920 if (TF1::RejectedPoint()) {cache += fPointSize; continue;}; 1921 if (flag == 2) {; 1922 for (j=0;j<npar;j++) {; 1923 dersum[j] += 1; //should be the derivative; 1924 //grad[j] += dersum[j]*(fu-cu)/eu; dersum[j] = 0;; 1925 }; 1926 }; 1927 if (fu < 1.e-9) fu = 1.e-9;; 1928 icu = Int_t(cu);; 1929 fsub = -fu +icu*TMath::Log(fu);; 1930 fobs = GetSumLog(icu);; 1931 fsub -= fobs;; 1932 Derivatives(df,x);; 1933 int n=0;; 1934 // Here we need gradients of Log likelihood function; 1935 //; 1936 for (j=0;j<npar;j++) {; 1937 if (pl0[j]>0){; 1938 df[n] = df[j]*(icu/fu-1);; 1939 gin[j] -= df[n];; 1940 n++;; 1941 }; 1942 }; 1943 Int_t l = 0;; 1944 // Z-matrix here - production of first d",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:55259,Performance,cache,cache,55259," 1877///; 1878/// Default method (function evaluated at center of bin); 1879/// for each point the cache contains the following info; 1880/// - 1D : bc,e,xc (bin content, error, x of center of bin); 1881/// - 2D : bc,e,xc,yc; 1882/// - 3D : bc,e,xc,yc,zc; 1883 ; 1884void TFumili::FitLikelihood(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag); 1885{; 1886 Foption_t fitOption = GetFitOption();; 1887 if (fitOption.Integral) {; 1888 FitLikelihoodI(npar,gin,f,u,flag);; 1889 return;; 1890 }; 1891 Double_t cu,fu,fobs,fsub;; 1892 Double_t dersum[100];; 1893 Double_t x[3];; 1894 Int_t icu;; 1895 ; 1896 TH1 *hfit = (TH1*)GetObjectFit();; 1897 TF1 *f1 = (TF1*)GetUserFunc();; 1898 Int_t nd = hfit->GetDimension();; 1899 Int_t j;; 1900 Double_t *zik = GetZ();; 1901 Double_t *pl0 = GetPL0();; 1902 ; 1903 npar = f1->GetNpar();; 1904 SetParNumber(npar);; 1905 if(flag == 9) return;; 1906 Double_t *df=new Double_t[npar];; 1907 if (flag == 2) for (j=0;j<npar;j++) dersum[j] = gin[j] = 0;; 1908 f1->InitArgs(x,u);; 1909 f = 0;; 1910 ; 1911 Int_t npfit = 0;; 1912 Double_t *cache = fCache;; 1913 for (Int_t i=0;i<fNpoints;i++) {; 1914 if (nd > 2) x[2] = cache[4];; 1915 if (nd > 1) x[1] = cache[3];; 1916 x[0] = cache[2];; 1917 cu = cache[0];; 1918 TF1::RejectPoint(kFALSE);; 1919 fu = f1->EvalPar(x,u);; 1920 if (TF1::RejectedPoint()) {cache += fPointSize; continue;}; 1921 if (flag == 2) {; 1922 for (j=0;j<npar;j++) {; 1923 dersum[j] += 1; //should be the derivative; 1924 //grad[j] += dersum[j]*(fu-cu)/eu; dersum[j] = 0;; 1925 }; 1926 }; 1927 if (fu < 1.e-9) fu = 1.e-9;; 1928 icu = Int_t(cu);; 1929 fsub = -fu +icu*TMath::Log(fu);; 1930 fobs = GetSumLog(icu);; 1931 fsub -= fobs;; 1932 Derivatives(df,x);; 1933 int n=0;; 1934 // Here we need gradients of Log likelihood function; 1935 //; 1936 for (j=0;j<npar;j++) {; 1937 if (pl0[j]>0){; 1938 df[n] = df[j]*(icu/fu-1);; 1939 gin[j] -= df[n];; 1940 n++;; 1941 }; 1942 }; 1943 Int_t l = 0;; 1944 // Z-matrix here - production of first d",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:55294,Performance,cache,cache,55294," 1877///; 1878/// Default method (function evaluated at center of bin); 1879/// for each point the cache contains the following info; 1880/// - 1D : bc,e,xc (bin content, error, x of center of bin); 1881/// - 2D : bc,e,xc,yc; 1882/// - 3D : bc,e,xc,yc,zc; 1883 ; 1884void TFumili::FitLikelihood(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag); 1885{; 1886 Foption_t fitOption = GetFitOption();; 1887 if (fitOption.Integral) {; 1888 FitLikelihoodI(npar,gin,f,u,flag);; 1889 return;; 1890 }; 1891 Double_t cu,fu,fobs,fsub;; 1892 Double_t dersum[100];; 1893 Double_t x[3];; 1894 Int_t icu;; 1895 ; 1896 TH1 *hfit = (TH1*)GetObjectFit();; 1897 TF1 *f1 = (TF1*)GetUserFunc();; 1898 Int_t nd = hfit->GetDimension();; 1899 Int_t j;; 1900 Double_t *zik = GetZ();; 1901 Double_t *pl0 = GetPL0();; 1902 ; 1903 npar = f1->GetNpar();; 1904 SetParNumber(npar);; 1905 if(flag == 9) return;; 1906 Double_t *df=new Double_t[npar];; 1907 if (flag == 2) for (j=0;j<npar;j++) dersum[j] = gin[j] = 0;; 1908 f1->InitArgs(x,u);; 1909 f = 0;; 1910 ; 1911 Int_t npfit = 0;; 1912 Double_t *cache = fCache;; 1913 for (Int_t i=0;i<fNpoints;i++) {; 1914 if (nd > 2) x[2] = cache[4];; 1915 if (nd > 1) x[1] = cache[3];; 1916 x[0] = cache[2];; 1917 cu = cache[0];; 1918 TF1::RejectPoint(kFALSE);; 1919 fu = f1->EvalPar(x,u);; 1920 if (TF1::RejectedPoint()) {cache += fPointSize; continue;}; 1921 if (flag == 2) {; 1922 for (j=0;j<npar;j++) {; 1923 dersum[j] += 1; //should be the derivative; 1924 //grad[j] += dersum[j]*(fu-cu)/eu; dersum[j] = 0;; 1925 }; 1926 }; 1927 if (fu < 1.e-9) fu = 1.e-9;; 1928 icu = Int_t(cu);; 1929 fsub = -fu +icu*TMath::Log(fu);; 1930 fobs = GetSumLog(icu);; 1931 fsub -= fobs;; 1932 Derivatives(df,x);; 1933 int n=0;; 1934 // Here we need gradients of Log likelihood function; 1935 //; 1936 for (j=0;j<npar;j++) {; 1937 if (pl0[j]>0){; 1938 df[n] = df[j]*(icu/fu-1);; 1939 gin[j] -= df[n];; 1940 n++;; 1941 }; 1942 }; 1943 Int_t l = 0;; 1944 // Z-matrix here - production of first d",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:55317,Performance,cache,cache,55317," 1877///; 1878/// Default method (function evaluated at center of bin); 1879/// for each point the cache contains the following info; 1880/// - 1D : bc,e,xc (bin content, error, x of center of bin); 1881/// - 2D : bc,e,xc,yc; 1882/// - 3D : bc,e,xc,yc,zc; 1883 ; 1884void TFumili::FitLikelihood(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag); 1885{; 1886 Foption_t fitOption = GetFitOption();; 1887 if (fitOption.Integral) {; 1888 FitLikelihoodI(npar,gin,f,u,flag);; 1889 return;; 1890 }; 1891 Double_t cu,fu,fobs,fsub;; 1892 Double_t dersum[100];; 1893 Double_t x[3];; 1894 Int_t icu;; 1895 ; 1896 TH1 *hfit = (TH1*)GetObjectFit();; 1897 TF1 *f1 = (TF1*)GetUserFunc();; 1898 Int_t nd = hfit->GetDimension();; 1899 Int_t j;; 1900 Double_t *zik = GetZ();; 1901 Double_t *pl0 = GetPL0();; 1902 ; 1903 npar = f1->GetNpar();; 1904 SetParNumber(npar);; 1905 if(flag == 9) return;; 1906 Double_t *df=new Double_t[npar];; 1907 if (flag == 2) for (j=0;j<npar;j++) dersum[j] = gin[j] = 0;; 1908 f1->InitArgs(x,u);; 1909 f = 0;; 1910 ; 1911 Int_t npfit = 0;; 1912 Double_t *cache = fCache;; 1913 for (Int_t i=0;i<fNpoints;i++) {; 1914 if (nd > 2) x[2] = cache[4];; 1915 if (nd > 1) x[1] = cache[3];; 1916 x[0] = cache[2];; 1917 cu = cache[0];; 1918 TF1::RejectPoint(kFALSE);; 1919 fu = f1->EvalPar(x,u);; 1920 if (TF1::RejectedPoint()) {cache += fPointSize; continue;}; 1921 if (flag == 2) {; 1922 for (j=0;j<npar;j++) {; 1923 dersum[j] += 1; //should be the derivative; 1924 //grad[j] += dersum[j]*(fu-cu)/eu; dersum[j] = 0;; 1925 }; 1926 }; 1927 if (fu < 1.e-9) fu = 1.e-9;; 1928 icu = Int_t(cu);; 1929 fsub = -fu +icu*TMath::Log(fu);; 1930 fobs = GetSumLog(icu);; 1931 fsub -= fobs;; 1932 Derivatives(df,x);; 1933 int n=0;; 1934 // Here we need gradients of Log likelihood function; 1935 //; 1936 for (j=0;j<npar;j++) {; 1937 if (pl0[j]>0){; 1938 df[n] = df[j]*(icu/fu-1);; 1939 gin[j] -= df[n];; 1940 n++;; 1941 }; 1942 }; 1943 Int_t l = 0;; 1944 // Z-matrix here - production of first d",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:55338,Performance,cache,cache,55338," 1877///; 1878/// Default method (function evaluated at center of bin); 1879/// for each point the cache contains the following info; 1880/// - 1D : bc,e,xc (bin content, error, x of center of bin); 1881/// - 2D : bc,e,xc,yc; 1882/// - 3D : bc,e,xc,yc,zc; 1883 ; 1884void TFumili::FitLikelihood(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag); 1885{; 1886 Foption_t fitOption = GetFitOption();; 1887 if (fitOption.Integral) {; 1888 FitLikelihoodI(npar,gin,f,u,flag);; 1889 return;; 1890 }; 1891 Double_t cu,fu,fobs,fsub;; 1892 Double_t dersum[100];; 1893 Double_t x[3];; 1894 Int_t icu;; 1895 ; 1896 TH1 *hfit = (TH1*)GetObjectFit();; 1897 TF1 *f1 = (TF1*)GetUserFunc();; 1898 Int_t nd = hfit->GetDimension();; 1899 Int_t j;; 1900 Double_t *zik = GetZ();; 1901 Double_t *pl0 = GetPL0();; 1902 ; 1903 npar = f1->GetNpar();; 1904 SetParNumber(npar);; 1905 if(flag == 9) return;; 1906 Double_t *df=new Double_t[npar];; 1907 if (flag == 2) for (j=0;j<npar;j++) dersum[j] = gin[j] = 0;; 1908 f1->InitArgs(x,u);; 1909 f = 0;; 1910 ; 1911 Int_t npfit = 0;; 1912 Double_t *cache = fCache;; 1913 for (Int_t i=0;i<fNpoints;i++) {; 1914 if (nd > 2) x[2] = cache[4];; 1915 if (nd > 1) x[1] = cache[3];; 1916 x[0] = cache[2];; 1917 cu = cache[0];; 1918 TF1::RejectPoint(kFALSE);; 1919 fu = f1->EvalPar(x,u);; 1920 if (TF1::RejectedPoint()) {cache += fPointSize; continue;}; 1921 if (flag == 2) {; 1922 for (j=0;j<npar;j++) {; 1923 dersum[j] += 1; //should be the derivative; 1924 //grad[j] += dersum[j]*(fu-cu)/eu; dersum[j] = 0;; 1925 }; 1926 }; 1927 if (fu < 1.e-9) fu = 1.e-9;; 1928 icu = Int_t(cu);; 1929 fsub = -fu +icu*TMath::Log(fu);; 1930 fobs = GetSumLog(icu);; 1931 fsub -= fobs;; 1932 Derivatives(df,x);; 1933 int n=0;; 1934 // Here we need gradients of Log likelihood function; 1935 //; 1936 for (j=0;j<npar;j++) {; 1937 if (pl0[j]>0){; 1938 df[n] = df[j]*(icu/fu-1);; 1939 gin[j] -= df[n];; 1940 n++;; 1941 }; 1942 }; 1943 Int_t l = 0;; 1944 // Z-matrix here - production of first d",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:55442,Performance,cache,cache,55442," 1877///; 1878/// Default method (function evaluated at center of bin); 1879/// for each point the cache contains the following info; 1880/// - 1D : bc,e,xc (bin content, error, x of center of bin); 1881/// - 2D : bc,e,xc,yc; 1882/// - 3D : bc,e,xc,yc,zc; 1883 ; 1884void TFumili::FitLikelihood(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag); 1885{; 1886 Foption_t fitOption = GetFitOption();; 1887 if (fitOption.Integral) {; 1888 FitLikelihoodI(npar,gin,f,u,flag);; 1889 return;; 1890 }; 1891 Double_t cu,fu,fobs,fsub;; 1892 Double_t dersum[100];; 1893 Double_t x[3];; 1894 Int_t icu;; 1895 ; 1896 TH1 *hfit = (TH1*)GetObjectFit();; 1897 TF1 *f1 = (TF1*)GetUserFunc();; 1898 Int_t nd = hfit->GetDimension();; 1899 Int_t j;; 1900 Double_t *zik = GetZ();; 1901 Double_t *pl0 = GetPL0();; 1902 ; 1903 npar = f1->GetNpar();; 1904 SetParNumber(npar);; 1905 if(flag == 9) return;; 1906 Double_t *df=new Double_t[npar];; 1907 if (flag == 2) for (j=0;j<npar;j++) dersum[j] = gin[j] = 0;; 1908 f1->InitArgs(x,u);; 1909 f = 0;; 1910 ; 1911 Int_t npfit = 0;; 1912 Double_t *cache = fCache;; 1913 for (Int_t i=0;i<fNpoints;i++) {; 1914 if (nd > 2) x[2] = cache[4];; 1915 if (nd > 1) x[1] = cache[3];; 1916 x[0] = cache[2];; 1917 cu = cache[0];; 1918 TF1::RejectPoint(kFALSE);; 1919 fu = f1->EvalPar(x,u);; 1920 if (TF1::RejectedPoint()) {cache += fPointSize; continue;}; 1921 if (flag == 2) {; 1922 for (j=0;j<npar;j++) {; 1923 dersum[j] += 1; //should be the derivative; 1924 //grad[j] += dersum[j]*(fu-cu)/eu; dersum[j] = 0;; 1925 }; 1926 }; 1927 if (fu < 1.e-9) fu = 1.e-9;; 1928 icu = Int_t(cu);; 1929 fsub = -fu +icu*TMath::Log(fu);; 1930 fobs = GetSumLog(icu);; 1931 fsub -= fobs;; 1932 Derivatives(df,x);; 1933 int n=0;; 1934 // Here we need gradients of Log likelihood function; 1935 //; 1936 for (j=0;j<npar;j++) {; 1937 if (pl0[j]>0){; 1938 df[n] = df[j]*(icu/fu-1);; 1939 gin[j] -= df[n];; 1940 n++;; 1941 }; 1942 }; 1943 Int_t l = 0;; 1944 // Z-matrix here - production of first d",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:56274,Performance,cache,cache,56274,"itArgs(x,u);; 1909 f = 0;; 1910 ; 1911 Int_t npfit = 0;; 1912 Double_t *cache = fCache;; 1913 for (Int_t i=0;i<fNpoints;i++) {; 1914 if (nd > 2) x[2] = cache[4];; 1915 if (nd > 1) x[1] = cache[3];; 1916 x[0] = cache[2];; 1917 cu = cache[0];; 1918 TF1::RejectPoint(kFALSE);; 1919 fu = f1->EvalPar(x,u);; 1920 if (TF1::RejectedPoint()) {cache += fPointSize; continue;}; 1921 if (flag == 2) {; 1922 for (j=0;j<npar;j++) {; 1923 dersum[j] += 1; //should be the derivative; 1924 //grad[j] += dersum[j]*(fu-cu)/eu; dersum[j] = 0;; 1925 }; 1926 }; 1927 if (fu < 1.e-9) fu = 1.e-9;; 1928 icu = Int_t(cu);; 1929 fsub = -fu +icu*TMath::Log(fu);; 1930 fobs = GetSumLog(icu);; 1931 fsub -= fobs;; 1932 Derivatives(df,x);; 1933 int n=0;; 1934 // Here we need gradients of Log likelihood function; 1935 //; 1936 for (j=0;j<npar;j++) {; 1937 if (pl0[j]>0){; 1938 df[n] = df[j]*(icu/fu-1);; 1939 gin[j] -= df[n];; 1940 n++;; 1941 }; 1942 }; 1943 Int_t l = 0;; 1944 // Z-matrix here - production of first derivatives; 1945 // of log-likelihood function; 1946 for (j=0;j<n;j++); 1947 for (Int_t k=0;k<=j;k++); 1948 zik[l++] += df[j]*df[k];; 1949 ; 1950 f -= fsub;; 1951 npfit++;; 1952 cache += fPointSize;; 1953 }; 1954 f *= 2;; 1955 f1->SetNumberFitPoints(npfit);; 1956 delete[] df;; 1957}; 1958 ; 1959////////////////////////////////////////////////////////////////////////////////; 1960/// Minimization function for H1s using a Likelihood method.; 1961/// Basically, it forms the likelihood by determining the Poisson; 1962/// probability that given a number of entries in a particular bin,; 1963/// the fit would predict it's value. This is then done for each bin,; 1964/// and the sum of the logs is taken as the likelihood.; 1965///; 1966/// The ""I""ntegral method is used; 1967/// for each point the cache contains the following info; 1968/// - 1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); 1969/// - 2D : bc,e,xc,xw,yc,yw; 1970/// - 3D : bc,e,xc,xw,yc,yw,zc,zw; 1971 ; 1972void T",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:56895,Performance,cache,cache,56895,"/////////////////////////////////; 1960/// Minimization function for H1s using a Likelihood method.; 1961/// Basically, it forms the likelihood by determining the Poisson; 1962/// probability that given a number of entries in a particular bin,; 1963/// the fit would predict it's value. This is then done for each bin,; 1964/// and the sum of the logs is taken as the likelihood.; 1965///; 1966/// The ""I""ntegral method is used; 1967/// for each point the cache contains the following info; 1968/// - 1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); 1969/// - 2D : bc,e,xc,xw,yc,yw; 1970/// - 3D : bc,e,xc,xw,yc,yw,zc,zw; 1971 ; 1972void TFumili::FitLikelihoodI(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag); 1973{; 1974 Double_t cu,fu,fobs,fsub;; 1975 Double_t dersum[100];; 1976 Double_t x[3];; 1977 Int_t icu;; 1978 ; 1979 TH1 *hfit = (TH1*)GetObjectFit();; 1980 TF1 *f1 = (TF1*)GetUserFunc();; 1981 Int_t nd = hfit->GetDimension();; 1982 Int_t j;; 1983 Double_t *zik = GetZ();; 1984 Double_t *pl0 = GetPL0();; 1985 ; 1986 Double_t *df=new Double_t[npar];; 1987 ; 1988 npar = f1->GetNpar();; 1989 SetParNumber(npar);; 1990 if(flag == 9) {delete [] df; return;}; 1991 if (flag == 2) for (j=0;j<npar;j++) dersum[j] = gin[j] = 0;; 1992 f1->InitArgs(x,u);; 1993 f = 0;; 1994 ; 1995 Int_t npfit = 0;; 1996 Double_t *cache = fCache;; 1997 for (Int_t i=0;i<fNpoints;i++) {; 1998 if (nd > 2) x[2] = cache[4];; 1999 if (nd > 1) x[1] = cache[3];; 2000 x[0] = cache[2];; 2001 cu = cache[0];; 2002 TF1::RejectPoint(kFALSE);; 2003 if (nd < 2) {; 2004 fu = f1->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3])/cache[3];; 2005 } else if (nd < 3) {; 2006 fu = ((TF2*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5])/(cache[3]*cache[5]);; 2007 } else {; 2008 fu = ((TF3*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5],cache[6] - 0.",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:57802,Performance,cache,cache,57802,"/////////////////////////////////; 1960/// Minimization function for H1s using a Likelihood method.; 1961/// Basically, it forms the likelihood by determining the Poisson; 1962/// probability that given a number of entries in a particular bin,; 1963/// the fit would predict it's value. This is then done for each bin,; 1964/// and the sum of the logs is taken as the likelihood.; 1965///; 1966/// The ""I""ntegral method is used; 1967/// for each point the cache contains the following info; 1968/// - 1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); 1969/// - 2D : bc,e,xc,xw,yc,yw; 1970/// - 3D : bc,e,xc,xw,yc,yw,zc,zw; 1971 ; 1972void TFumili::FitLikelihoodI(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag); 1973{; 1974 Double_t cu,fu,fobs,fsub;; 1975 Double_t dersum[100];; 1976 Double_t x[3];; 1977 Int_t icu;; 1978 ; 1979 TH1 *hfit = (TH1*)GetObjectFit();; 1980 TF1 *f1 = (TF1*)GetUserFunc();; 1981 Int_t nd = hfit->GetDimension();; 1982 Int_t j;; 1983 Double_t *zik = GetZ();; 1984 Double_t *pl0 = GetPL0();; 1985 ; 1986 Double_t *df=new Double_t[npar];; 1987 ; 1988 npar = f1->GetNpar();; 1989 SetParNumber(npar);; 1990 if(flag == 9) {delete [] df; return;}; 1991 if (flag == 2) for (j=0;j<npar;j++) dersum[j] = gin[j] = 0;; 1992 f1->InitArgs(x,u);; 1993 f = 0;; 1994 ; 1995 Int_t npfit = 0;; 1996 Double_t *cache = fCache;; 1997 for (Int_t i=0;i<fNpoints;i++) {; 1998 if (nd > 2) x[2] = cache[4];; 1999 if (nd > 1) x[1] = cache[3];; 2000 x[0] = cache[2];; 2001 cu = cache[0];; 2002 TF1::RejectPoint(kFALSE);; 2003 if (nd < 2) {; 2004 fu = f1->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3])/cache[3];; 2005 } else if (nd < 3) {; 2006 fu = ((TF2*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5])/(cache[3]*cache[5]);; 2007 } else {; 2008 fu = ((TF3*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5],cache[6] - 0.",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:57882,Performance,cache,cache,57882,"/////////////////////////////////; 1960/// Minimization function for H1s using a Likelihood method.; 1961/// Basically, it forms the likelihood by determining the Poisson; 1962/// probability that given a number of entries in a particular bin,; 1963/// the fit would predict it's value. This is then done for each bin,; 1964/// and the sum of the logs is taken as the likelihood.; 1965///; 1966/// The ""I""ntegral method is used; 1967/// for each point the cache contains the following info; 1968/// - 1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); 1969/// - 2D : bc,e,xc,xw,yc,yw; 1970/// - 3D : bc,e,xc,xw,yc,yw,zc,zw; 1971 ; 1972void TFumili::FitLikelihoodI(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag); 1973{; 1974 Double_t cu,fu,fobs,fsub;; 1975 Double_t dersum[100];; 1976 Double_t x[3];; 1977 Int_t icu;; 1978 ; 1979 TH1 *hfit = (TH1*)GetObjectFit();; 1980 TF1 *f1 = (TF1*)GetUserFunc();; 1981 Int_t nd = hfit->GetDimension();; 1982 Int_t j;; 1983 Double_t *zik = GetZ();; 1984 Double_t *pl0 = GetPL0();; 1985 ; 1986 Double_t *df=new Double_t[npar];; 1987 ; 1988 npar = f1->GetNpar();; 1989 SetParNumber(npar);; 1990 if(flag == 9) {delete [] df; return;}; 1991 if (flag == 2) for (j=0;j<npar;j++) dersum[j] = gin[j] = 0;; 1992 f1->InitArgs(x,u);; 1993 f = 0;; 1994 ; 1995 Int_t npfit = 0;; 1996 Double_t *cache = fCache;; 1997 for (Int_t i=0;i<fNpoints;i++) {; 1998 if (nd > 2) x[2] = cache[4];; 1999 if (nd > 1) x[1] = cache[3];; 2000 x[0] = cache[2];; 2001 cu = cache[0];; 2002 TF1::RejectPoint(kFALSE);; 2003 if (nd < 2) {; 2004 fu = f1->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3])/cache[3];; 2005 } else if (nd < 3) {; 2006 fu = ((TF2*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5])/(cache[3]*cache[5]);; 2007 } else {; 2008 fu = ((TF3*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5],cache[6] - 0.",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:57917,Performance,cache,cache,57917,"/////////////////////////////////; 1960/// Minimization function for H1s using a Likelihood method.; 1961/// Basically, it forms the likelihood by determining the Poisson; 1962/// probability that given a number of entries in a particular bin,; 1963/// the fit would predict it's value. This is then done for each bin,; 1964/// and the sum of the logs is taken as the likelihood.; 1965///; 1966/// The ""I""ntegral method is used; 1967/// for each point the cache contains the following info; 1968/// - 1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); 1969/// - 2D : bc,e,xc,xw,yc,yw; 1970/// - 3D : bc,e,xc,xw,yc,yw,zc,zw; 1971 ; 1972void TFumili::FitLikelihoodI(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag); 1973{; 1974 Double_t cu,fu,fobs,fsub;; 1975 Double_t dersum[100];; 1976 Double_t x[3];; 1977 Int_t icu;; 1978 ; 1979 TH1 *hfit = (TH1*)GetObjectFit();; 1980 TF1 *f1 = (TF1*)GetUserFunc();; 1981 Int_t nd = hfit->GetDimension();; 1982 Int_t j;; 1983 Double_t *zik = GetZ();; 1984 Double_t *pl0 = GetPL0();; 1985 ; 1986 Double_t *df=new Double_t[npar];; 1987 ; 1988 npar = f1->GetNpar();; 1989 SetParNumber(npar);; 1990 if(flag == 9) {delete [] df; return;}; 1991 if (flag == 2) for (j=0;j<npar;j++) dersum[j] = gin[j] = 0;; 1992 f1->InitArgs(x,u);; 1993 f = 0;; 1994 ; 1995 Int_t npfit = 0;; 1996 Double_t *cache = fCache;; 1997 for (Int_t i=0;i<fNpoints;i++) {; 1998 if (nd > 2) x[2] = cache[4];; 1999 if (nd > 1) x[1] = cache[3];; 2000 x[0] = cache[2];; 2001 cu = cache[0];; 2002 TF1::RejectPoint(kFALSE);; 2003 if (nd < 2) {; 2004 fu = f1->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3])/cache[3];; 2005 } else if (nd < 3) {; 2006 fu = ((TF2*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5])/(cache[3]*cache[5]);; 2007 } else {; 2008 fu = ((TF3*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5],cache[6] - 0.",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:57940,Performance,cache,cache,57940,"/////////////////////////////////; 1960/// Minimization function for H1s using a Likelihood method.; 1961/// Basically, it forms the likelihood by determining the Poisson; 1962/// probability that given a number of entries in a particular bin,; 1963/// the fit would predict it's value. This is then done for each bin,; 1964/// and the sum of the logs is taken as the likelihood.; 1965///; 1966/// The ""I""ntegral method is used; 1967/// for each point the cache contains the following info; 1968/// - 1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); 1969/// - 2D : bc,e,xc,xw,yc,yw; 1970/// - 3D : bc,e,xc,xw,yc,yw,zc,zw; 1971 ; 1972void TFumili::FitLikelihoodI(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag); 1973{; 1974 Double_t cu,fu,fobs,fsub;; 1975 Double_t dersum[100];; 1976 Double_t x[3];; 1977 Int_t icu;; 1978 ; 1979 TH1 *hfit = (TH1*)GetObjectFit();; 1980 TF1 *f1 = (TF1*)GetUserFunc();; 1981 Int_t nd = hfit->GetDimension();; 1982 Int_t j;; 1983 Double_t *zik = GetZ();; 1984 Double_t *pl0 = GetPL0();; 1985 ; 1986 Double_t *df=new Double_t[npar];; 1987 ; 1988 npar = f1->GetNpar();; 1989 SetParNumber(npar);; 1990 if(flag == 9) {delete [] df; return;}; 1991 if (flag == 2) for (j=0;j<npar;j++) dersum[j] = gin[j] = 0;; 1992 f1->InitArgs(x,u);; 1993 f = 0;; 1994 ; 1995 Int_t npfit = 0;; 1996 Double_t *cache = fCache;; 1997 for (Int_t i=0;i<fNpoints;i++) {; 1998 if (nd > 2) x[2] = cache[4];; 1999 if (nd > 1) x[1] = cache[3];; 2000 x[0] = cache[2];; 2001 cu = cache[0];; 2002 TF1::RejectPoint(kFALSE);; 2003 if (nd < 2) {; 2004 fu = f1->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3])/cache[3];; 2005 } else if (nd < 3) {; 2006 fu = ((TF2*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5])/(cache[3]*cache[5]);; 2007 } else {; 2008 fu = ((TF3*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5],cache[6] - 0.",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:57961,Performance,cache,cache,57961,"/////////////////////////////////; 1960/// Minimization function for H1s using a Likelihood method.; 1961/// Basically, it forms the likelihood by determining the Poisson; 1962/// probability that given a number of entries in a particular bin,; 1963/// the fit would predict it's value. This is then done for each bin,; 1964/// and the sum of the logs is taken as the likelihood.; 1965///; 1966/// The ""I""ntegral method is used; 1967/// for each point the cache contains the following info; 1968/// - 1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); 1969/// - 2D : bc,e,xc,xw,yc,yw; 1970/// - 3D : bc,e,xc,xw,yc,yw,zc,zw; 1971 ; 1972void TFumili::FitLikelihoodI(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag); 1973{; 1974 Double_t cu,fu,fobs,fsub;; 1975 Double_t dersum[100];; 1976 Double_t x[3];; 1977 Int_t icu;; 1978 ; 1979 TH1 *hfit = (TH1*)GetObjectFit();; 1980 TF1 *f1 = (TF1*)GetUserFunc();; 1981 Int_t nd = hfit->GetDimension();; 1982 Int_t j;; 1983 Double_t *zik = GetZ();; 1984 Double_t *pl0 = GetPL0();; 1985 ; 1986 Double_t *df=new Double_t[npar];; 1987 ; 1988 npar = f1->GetNpar();; 1989 SetParNumber(npar);; 1990 if(flag == 9) {delete [] df; return;}; 1991 if (flag == 2) for (j=0;j<npar;j++) dersum[j] = gin[j] = 0;; 1992 f1->InitArgs(x,u);; 1993 f = 0;; 1994 ; 1995 Int_t npfit = 0;; 1996 Double_t *cache = fCache;; 1997 for (Int_t i=0;i<fNpoints;i++) {; 1998 if (nd > 2) x[2] = cache[4];; 1999 if (nd > 1) x[1] = cache[3];; 2000 x[0] = cache[2];; 2001 cu = cache[0];; 2002 TF1::RejectPoint(kFALSE);; 2003 if (nd < 2) {; 2004 fu = f1->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3])/cache[3];; 2005 } else if (nd < 3) {; 2006 fu = ((TF2*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5])/(cache[3]*cache[5]);; 2007 } else {; 2008 fu = ((TF3*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5],cache[6] - 0.",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:58047,Performance,cache,cache,58047,"/////////////////////////////////; 1960/// Minimization function for H1s using a Likelihood method.; 1961/// Basically, it forms the likelihood by determining the Poisson; 1962/// probability that given a number of entries in a particular bin,; 1963/// the fit would predict it's value. This is then done for each bin,; 1964/// and the sum of the logs is taken as the likelihood.; 1965///; 1966/// The ""I""ntegral method is used; 1967/// for each point the cache contains the following info; 1968/// - 1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); 1969/// - 2D : bc,e,xc,xw,yc,yw; 1970/// - 3D : bc,e,xc,xw,yc,yw,zc,zw; 1971 ; 1972void TFumili::FitLikelihoodI(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag); 1973{; 1974 Double_t cu,fu,fobs,fsub;; 1975 Double_t dersum[100];; 1976 Double_t x[3];; 1977 Int_t icu;; 1978 ; 1979 TH1 *hfit = (TH1*)GetObjectFit();; 1980 TF1 *f1 = (TF1*)GetUserFunc();; 1981 Int_t nd = hfit->GetDimension();; 1982 Int_t j;; 1983 Double_t *zik = GetZ();; 1984 Double_t *pl0 = GetPL0();; 1985 ; 1986 Double_t *df=new Double_t[npar];; 1987 ; 1988 npar = f1->GetNpar();; 1989 SetParNumber(npar);; 1990 if(flag == 9) {delete [] df; return;}; 1991 if (flag == 2) for (j=0;j<npar;j++) dersum[j] = gin[j] = 0;; 1992 f1->InitArgs(x,u);; 1993 f = 0;; 1994 ; 1995 Int_t npfit = 0;; 1996 Double_t *cache = fCache;; 1997 for (Int_t i=0;i<fNpoints;i++) {; 1998 if (nd > 2) x[2] = cache[4];; 1999 if (nd > 1) x[1] = cache[3];; 2000 x[0] = cache[2];; 2001 cu = cache[0];; 2002 TF1::RejectPoint(kFALSE);; 2003 if (nd < 2) {; 2004 fu = f1->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3])/cache[3];; 2005 } else if (nd < 3) {; 2006 fu = ((TF2*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5])/(cache[3]*cache[5]);; 2007 } else {; 2008 fu = ((TF3*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5],cache[6] - 0.",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:58062,Performance,cache,cache,58062,"c,xw,yc,yw,zc,zw; 1971 ; 1972void TFumili::FitLikelihoodI(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag); 1973{; 1974 Double_t cu,fu,fobs,fsub;; 1975 Double_t dersum[100];; 1976 Double_t x[3];; 1977 Int_t icu;; 1978 ; 1979 TH1 *hfit = (TH1*)GetObjectFit();; 1980 TF1 *f1 = (TF1*)GetUserFunc();; 1981 Int_t nd = hfit->GetDimension();; 1982 Int_t j;; 1983 Double_t *zik = GetZ();; 1984 Double_t *pl0 = GetPL0();; 1985 ; 1986 Double_t *df=new Double_t[npar];; 1987 ; 1988 npar = f1->GetNpar();; 1989 SetParNumber(npar);; 1990 if(flag == 9) {delete [] df; return;}; 1991 if (flag == 2) for (j=0;j<npar;j++) dersum[j] = gin[j] = 0;; 1992 f1->InitArgs(x,u);; 1993 f = 0;; 1994 ; 1995 Int_t npfit = 0;; 1996 Double_t *cache = fCache;; 1997 for (Int_t i=0;i<fNpoints;i++) {; 1998 if (nd > 2) x[2] = cache[4];; 1999 if (nd > 1) x[1] = cache[3];; 2000 x[0] = cache[2];; 2001 cu = cache[0];; 2002 TF1::RejectPoint(kFALSE);; 2003 if (nd < 2) {; 2004 fu = f1->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3])/cache[3];; 2005 } else if (nd < 3) {; 2006 fu = ((TF2*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5])/(cache[3]*cache[5]);; 2007 } else {; 2008 fu = ((TF3*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5],cache[6] - 0.5*cache[7],cache[6] + 0.5*cache[7])/(cache[3]*cache[5]*cache[7]);; 2009 }; 2010 if (TF1::RejectedPoint()) {cache += fPointSize; continue;}; 2011 if (flag == 2) {; 2012 for (j=0;j<npar;j++) {; 2013 dersum[j] += 1; //should be the derivative; 2014 //grad[j] += dersum[j]*(fu-cu)/eu; dersum[j] = 0;; 2015 }; 2016 }; 2017 if (fu < 1.e-9) fu = 1.e-9;; 2018 icu = Int_t(cu);; 2019 fsub = -fu +icu*TMath::Log(fu);; 2020 fobs = GetSumLog(icu);; 2021 fsub -= fobs;; 2022 Derivatives(df,x);; 2023 int n=0;; 2024 // Here we need gradients of Log likelihood function; 2025 //; 2026 for (j=0;j<npar;j++) {; 2027 if (pl0[j]>0){; 2028 df[n] = df[j]",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:58071,Performance,cache,cache,58071,"c,xw,yc,yw,zc,zw; 1971 ; 1972void TFumili::FitLikelihoodI(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag); 1973{; 1974 Double_t cu,fu,fobs,fsub;; 1975 Double_t dersum[100];; 1976 Double_t x[3];; 1977 Int_t icu;; 1978 ; 1979 TH1 *hfit = (TH1*)GetObjectFit();; 1980 TF1 *f1 = (TF1*)GetUserFunc();; 1981 Int_t nd = hfit->GetDimension();; 1982 Int_t j;; 1983 Double_t *zik = GetZ();; 1984 Double_t *pl0 = GetPL0();; 1985 ; 1986 Double_t *df=new Double_t[npar];; 1987 ; 1988 npar = f1->GetNpar();; 1989 SetParNumber(npar);; 1990 if(flag == 9) {delete [] df; return;}; 1991 if (flag == 2) for (j=0;j<npar;j++) dersum[j] = gin[j] = 0;; 1992 f1->InitArgs(x,u);; 1993 f = 0;; 1994 ; 1995 Int_t npfit = 0;; 1996 Double_t *cache = fCache;; 1997 for (Int_t i=0;i<fNpoints;i++) {; 1998 if (nd > 2) x[2] = cache[4];; 1999 if (nd > 1) x[1] = cache[3];; 2000 x[0] = cache[2];; 2001 cu = cache[0];; 2002 TF1::RejectPoint(kFALSE);; 2003 if (nd < 2) {; 2004 fu = f1->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3])/cache[3];; 2005 } else if (nd < 3) {; 2006 fu = ((TF2*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5])/(cache[3]*cache[5]);; 2007 } else {; 2008 fu = ((TF3*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5],cache[6] - 0.5*cache[7],cache[6] + 0.5*cache[7])/(cache[3]*cache[5]*cache[7]);; 2009 }; 2010 if (TF1::RejectedPoint()) {cache += fPointSize; continue;}; 2011 if (flag == 2) {; 2012 for (j=0;j<npar;j++) {; 2013 dersum[j] += 1; //should be the derivative; 2014 //grad[j] += dersum[j]*(fu-cu)/eu; dersum[j] = 0;; 2015 }; 2016 }; 2017 if (fu < 1.e-9) fu = 1.e-9;; 2018 icu = Int_t(cu);; 2019 fsub = -fu +icu*TMath::Log(fu);; 2020 fobs = GetSumLog(icu);; 2021 fsub -= fobs;; 2022 Derivatives(df,x);; 2023 int n=0;; 2024 // Here we need gradients of Log likelihood function; 2025 //; 2026 for (j=0;j<npar;j++) {; 2027 if (pl0[j]>0){; 2028 df[n] = df[j]",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:58086,Performance,cache,cache,58086,"nt_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag); 1973{; 1974 Double_t cu,fu,fobs,fsub;; 1975 Double_t dersum[100];; 1976 Double_t x[3];; 1977 Int_t icu;; 1978 ; 1979 TH1 *hfit = (TH1*)GetObjectFit();; 1980 TF1 *f1 = (TF1*)GetUserFunc();; 1981 Int_t nd = hfit->GetDimension();; 1982 Int_t j;; 1983 Double_t *zik = GetZ();; 1984 Double_t *pl0 = GetPL0();; 1985 ; 1986 Double_t *df=new Double_t[npar];; 1987 ; 1988 npar = f1->GetNpar();; 1989 SetParNumber(npar);; 1990 if(flag == 9) {delete [] df; return;}; 1991 if (flag == 2) for (j=0;j<npar;j++) dersum[j] = gin[j] = 0;; 1992 f1->InitArgs(x,u);; 1993 f = 0;; 1994 ; 1995 Int_t npfit = 0;; 1996 Double_t *cache = fCache;; 1997 for (Int_t i=0;i<fNpoints;i++) {; 1998 if (nd > 2) x[2] = cache[4];; 1999 if (nd > 1) x[1] = cache[3];; 2000 x[0] = cache[2];; 2001 cu = cache[0];; 2002 TF1::RejectPoint(kFALSE);; 2003 if (nd < 2) {; 2004 fu = f1->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3])/cache[3];; 2005 } else if (nd < 3) {; 2006 fu = ((TF2*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5])/(cache[3]*cache[5]);; 2007 } else {; 2008 fu = ((TF3*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5],cache[6] - 0.5*cache[7],cache[6] + 0.5*cache[7])/(cache[3]*cache[5]*cache[7]);; 2009 }; 2010 if (TF1::RejectedPoint()) {cache += fPointSize; continue;}; 2011 if (flag == 2) {; 2012 for (j=0;j<npar;j++) {; 2013 dersum[j] += 1; //should be the derivative; 2014 //grad[j] += dersum[j]*(fu-cu)/eu; dersum[j] = 0;; 2015 }; 2016 }; 2017 if (fu < 1.e-9) fu = 1.e-9;; 2018 icu = Int_t(cu);; 2019 fsub = -fu +icu*TMath::Log(fu);; 2020 fobs = GetSumLog(icu);; 2021 fsub -= fobs;; 2022 Derivatives(df,x);; 2023 int n=0;; 2024 // Here we need gradients of Log likelihood function; 2025 //; 2026 for (j=0;j<npar;j++) {; 2027 if (pl0[j]>0){; 2028 df[n] = df[j]*(icu/fu-1);; 2029 gin[j] -= df[n];; 2030 n++;; 2031 }; 203",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:58096,Performance,cache,cache,58096,"nt_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag); 1973{; 1974 Double_t cu,fu,fobs,fsub;; 1975 Double_t dersum[100];; 1976 Double_t x[3];; 1977 Int_t icu;; 1978 ; 1979 TH1 *hfit = (TH1*)GetObjectFit();; 1980 TF1 *f1 = (TF1*)GetUserFunc();; 1981 Int_t nd = hfit->GetDimension();; 1982 Int_t j;; 1983 Double_t *zik = GetZ();; 1984 Double_t *pl0 = GetPL0();; 1985 ; 1986 Double_t *df=new Double_t[npar];; 1987 ; 1988 npar = f1->GetNpar();; 1989 SetParNumber(npar);; 1990 if(flag == 9) {delete [] df; return;}; 1991 if (flag == 2) for (j=0;j<npar;j++) dersum[j] = gin[j] = 0;; 1992 f1->InitArgs(x,u);; 1993 f = 0;; 1994 ; 1995 Int_t npfit = 0;; 1996 Double_t *cache = fCache;; 1997 for (Int_t i=0;i<fNpoints;i++) {; 1998 if (nd > 2) x[2] = cache[4];; 1999 if (nd > 1) x[1] = cache[3];; 2000 x[0] = cache[2];; 2001 cu = cache[0];; 2002 TF1::RejectPoint(kFALSE);; 2003 if (nd < 2) {; 2004 fu = f1->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3])/cache[3];; 2005 } else if (nd < 3) {; 2006 fu = ((TF2*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5])/(cache[3]*cache[5]);; 2007 } else {; 2008 fu = ((TF3*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5],cache[6] - 0.5*cache[7],cache[6] + 0.5*cache[7])/(cache[3]*cache[5]*cache[7]);; 2009 }; 2010 if (TF1::RejectedPoint()) {cache += fPointSize; continue;}; 2011 if (flag == 2) {; 2012 for (j=0;j<npar;j++) {; 2013 dersum[j] += 1; //should be the derivative; 2014 //grad[j] += dersum[j]*(fu-cu)/eu; dersum[j] = 0;; 2015 }; 2016 }; 2017 if (fu < 1.e-9) fu = 1.e-9;; 2018 icu = Int_t(cu);; 2019 fsub = -fu +icu*TMath::Log(fu);; 2020 fobs = GetSumLog(icu);; 2021 fsub -= fobs;; 2022 Derivatives(df,x);; 2023 int n=0;; 2024 // Here we need gradients of Log likelihood function; 2025 //; 2026 for (j=0;j<npar;j++) {; 2027 if (pl0[j]>0){; 2028 df[n] = df[j]*(icu/fu-1);; 2029 gin[j] -= df[n];; 2030 n++;; 2031 }; 203",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:58165,Performance,cache,cache,58165,"nt_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag); 1973{; 1974 Double_t cu,fu,fobs,fsub;; 1975 Double_t dersum[100];; 1976 Double_t x[3];; 1977 Int_t icu;; 1978 ; 1979 TH1 *hfit = (TH1*)GetObjectFit();; 1980 TF1 *f1 = (TF1*)GetUserFunc();; 1981 Int_t nd = hfit->GetDimension();; 1982 Int_t j;; 1983 Double_t *zik = GetZ();; 1984 Double_t *pl0 = GetPL0();; 1985 ; 1986 Double_t *df=new Double_t[npar];; 1987 ; 1988 npar = f1->GetNpar();; 1989 SetParNumber(npar);; 1990 if(flag == 9) {delete [] df; return;}; 1991 if (flag == 2) for (j=0;j<npar;j++) dersum[j] = gin[j] = 0;; 1992 f1->InitArgs(x,u);; 1993 f = 0;; 1994 ; 1995 Int_t npfit = 0;; 1996 Double_t *cache = fCache;; 1997 for (Int_t i=0;i<fNpoints;i++) {; 1998 if (nd > 2) x[2] = cache[4];; 1999 if (nd > 1) x[1] = cache[3];; 2000 x[0] = cache[2];; 2001 cu = cache[0];; 2002 TF1::RejectPoint(kFALSE);; 2003 if (nd < 2) {; 2004 fu = f1->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3])/cache[3];; 2005 } else if (nd < 3) {; 2006 fu = ((TF2*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5])/(cache[3]*cache[5]);; 2007 } else {; 2008 fu = ((TF3*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5],cache[6] - 0.5*cache[7],cache[6] + 0.5*cache[7])/(cache[3]*cache[5]*cache[7]);; 2009 }; 2010 if (TF1::RejectedPoint()) {cache += fPointSize; continue;}; 2011 if (flag == 2) {; 2012 for (j=0;j<npar;j++) {; 2013 dersum[j] += 1; //should be the derivative; 2014 //grad[j] += dersum[j]*(fu-cu)/eu; dersum[j] = 0;; 2015 }; 2016 }; 2017 if (fu < 1.e-9) fu = 1.e-9;; 2018 icu = Int_t(cu);; 2019 fsub = -fu +icu*TMath::Log(fu);; 2020 fobs = GetSumLog(icu);; 2021 fsub -= fobs;; 2022 Derivatives(df,x);; 2023 int n=0;; 2024 // Here we need gradients of Log likelihood function; 2025 //; 2026 for (j=0;j<npar;j++) {; 2027 if (pl0[j]>0){; 2028 df[n] = df[j]*(icu/fu-1);; 2029 gin[j] -= df[n];; 2030 n++;; 2031 }; 203",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:58180,Performance,cache,cache,58180,"flag); 1973{; 1974 Double_t cu,fu,fobs,fsub;; 1975 Double_t dersum[100];; 1976 Double_t x[3];; 1977 Int_t icu;; 1978 ; 1979 TH1 *hfit = (TH1*)GetObjectFit();; 1980 TF1 *f1 = (TF1*)GetUserFunc();; 1981 Int_t nd = hfit->GetDimension();; 1982 Int_t j;; 1983 Double_t *zik = GetZ();; 1984 Double_t *pl0 = GetPL0();; 1985 ; 1986 Double_t *df=new Double_t[npar];; 1987 ; 1988 npar = f1->GetNpar();; 1989 SetParNumber(npar);; 1990 if(flag == 9) {delete [] df; return;}; 1991 if (flag == 2) for (j=0;j<npar;j++) dersum[j] = gin[j] = 0;; 1992 f1->InitArgs(x,u);; 1993 f = 0;; 1994 ; 1995 Int_t npfit = 0;; 1996 Double_t *cache = fCache;; 1997 for (Int_t i=0;i<fNpoints;i++) {; 1998 if (nd > 2) x[2] = cache[4];; 1999 if (nd > 1) x[1] = cache[3];; 2000 x[0] = cache[2];; 2001 cu = cache[0];; 2002 TF1::RejectPoint(kFALSE);; 2003 if (nd < 2) {; 2004 fu = f1->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3])/cache[3];; 2005 } else if (nd < 3) {; 2006 fu = ((TF2*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5])/(cache[3]*cache[5]);; 2007 } else {; 2008 fu = ((TF3*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5],cache[6] - 0.5*cache[7],cache[6] + 0.5*cache[7])/(cache[3]*cache[5]*cache[7]);; 2009 }; 2010 if (TF1::RejectedPoint()) {cache += fPointSize; continue;}; 2011 if (flag == 2) {; 2012 for (j=0;j<npar;j++) {; 2013 dersum[j] += 1; //should be the derivative; 2014 //grad[j] += dersum[j]*(fu-cu)/eu; dersum[j] = 0;; 2015 }; 2016 }; 2017 if (fu < 1.e-9) fu = 1.e-9;; 2018 icu = Int_t(cu);; 2019 fsub = -fu +icu*TMath::Log(fu);; 2020 fobs = GetSumLog(icu);; 2021 fsub -= fobs;; 2022 Derivatives(df,x);; 2023 int n=0;; 2024 // Here we need gradients of Log likelihood function; 2025 //; 2026 for (j=0;j<npar;j++) {; 2027 if (pl0[j]>0){; 2028 df[n] = df[j]*(icu/fu-1);; 2029 gin[j] -= df[n];; 2030 n++;; 2031 }; 2032 }; 2033 Int_t l = 0;; 2034 // Z-matrix here - production ",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:58189,Performance,cache,cache,58189,"flag); 1973{; 1974 Double_t cu,fu,fobs,fsub;; 1975 Double_t dersum[100];; 1976 Double_t x[3];; 1977 Int_t icu;; 1978 ; 1979 TH1 *hfit = (TH1*)GetObjectFit();; 1980 TF1 *f1 = (TF1*)GetUserFunc();; 1981 Int_t nd = hfit->GetDimension();; 1982 Int_t j;; 1983 Double_t *zik = GetZ();; 1984 Double_t *pl0 = GetPL0();; 1985 ; 1986 Double_t *df=new Double_t[npar];; 1987 ; 1988 npar = f1->GetNpar();; 1989 SetParNumber(npar);; 1990 if(flag == 9) {delete [] df; return;}; 1991 if (flag == 2) for (j=0;j<npar;j++) dersum[j] = gin[j] = 0;; 1992 f1->InitArgs(x,u);; 1993 f = 0;; 1994 ; 1995 Int_t npfit = 0;; 1996 Double_t *cache = fCache;; 1997 for (Int_t i=0;i<fNpoints;i++) {; 1998 if (nd > 2) x[2] = cache[4];; 1999 if (nd > 1) x[1] = cache[3];; 2000 x[0] = cache[2];; 2001 cu = cache[0];; 2002 TF1::RejectPoint(kFALSE);; 2003 if (nd < 2) {; 2004 fu = f1->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3])/cache[3];; 2005 } else if (nd < 3) {; 2006 fu = ((TF2*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5])/(cache[3]*cache[5]);; 2007 } else {; 2008 fu = ((TF3*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5],cache[6] - 0.5*cache[7],cache[6] + 0.5*cache[7])/(cache[3]*cache[5]*cache[7]);; 2009 }; 2010 if (TF1::RejectedPoint()) {cache += fPointSize; continue;}; 2011 if (flag == 2) {; 2012 for (j=0;j<npar;j++) {; 2013 dersum[j] += 1; //should be the derivative; 2014 //grad[j] += dersum[j]*(fu-cu)/eu; dersum[j] = 0;; 2015 }; 2016 }; 2017 if (fu < 1.e-9) fu = 1.e-9;; 2018 icu = Int_t(cu);; 2019 fsub = -fu +icu*TMath::Log(fu);; 2020 fobs = GetSumLog(icu);; 2021 fsub -= fobs;; 2022 Derivatives(df,x);; 2023 int n=0;; 2024 // Here we need gradients of Log likelihood function; 2025 //; 2026 for (j=0;j<npar;j++) {; 2027 if (pl0[j]>0){; 2028 df[n] = df[j]*(icu/fu-1);; 2029 gin[j] -= df[n];; 2030 n++;; 2031 }; 2032 }; 2033 Int_t l = 0;; 2034 // Z-matrix here - production ",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:58204,Performance,cache,cache,58204,"e_t cu,fu,fobs,fsub;; 1975 Double_t dersum[100];; 1976 Double_t x[3];; 1977 Int_t icu;; 1978 ; 1979 TH1 *hfit = (TH1*)GetObjectFit();; 1980 TF1 *f1 = (TF1*)GetUserFunc();; 1981 Int_t nd = hfit->GetDimension();; 1982 Int_t j;; 1983 Double_t *zik = GetZ();; 1984 Double_t *pl0 = GetPL0();; 1985 ; 1986 Double_t *df=new Double_t[npar];; 1987 ; 1988 npar = f1->GetNpar();; 1989 SetParNumber(npar);; 1990 if(flag == 9) {delete [] df; return;}; 1991 if (flag == 2) for (j=0;j<npar;j++) dersum[j] = gin[j] = 0;; 1992 f1->InitArgs(x,u);; 1993 f = 0;; 1994 ; 1995 Int_t npfit = 0;; 1996 Double_t *cache = fCache;; 1997 for (Int_t i=0;i<fNpoints;i++) {; 1998 if (nd > 2) x[2] = cache[4];; 1999 if (nd > 1) x[1] = cache[3];; 2000 x[0] = cache[2];; 2001 cu = cache[0];; 2002 TF1::RejectPoint(kFALSE);; 2003 if (nd < 2) {; 2004 fu = f1->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3])/cache[3];; 2005 } else if (nd < 3) {; 2006 fu = ((TF2*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5])/(cache[3]*cache[5]);; 2007 } else {; 2008 fu = ((TF3*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5],cache[6] - 0.5*cache[7],cache[6] + 0.5*cache[7])/(cache[3]*cache[5]*cache[7]);; 2009 }; 2010 if (TF1::RejectedPoint()) {cache += fPointSize; continue;}; 2011 if (flag == 2) {; 2012 for (j=0;j<npar;j++) {; 2013 dersum[j] += 1; //should be the derivative; 2014 //grad[j] += dersum[j]*(fu-cu)/eu; dersum[j] = 0;; 2015 }; 2016 }; 2017 if (fu < 1.e-9) fu = 1.e-9;; 2018 icu = Int_t(cu);; 2019 fsub = -fu +icu*TMath::Log(fu);; 2020 fobs = GetSumLog(icu);; 2021 fsub -= fobs;; 2022 Derivatives(df,x);; 2023 int n=0;; 2024 // Here we need gradients of Log likelihood function; 2025 //; 2026 for (j=0;j<npar;j++) {; 2027 if (pl0[j]>0){; 2028 df[n] = df[j]*(icu/fu-1);; 2029 gin[j] -= df[n];; 2030 n++;; 2031 }; 2032 }; 2033 Int_t l = 0;; 2034 // Z-matrix here - production of first derivatives; 20",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:58213,Performance,cache,cache,58213,"e_t cu,fu,fobs,fsub;; 1975 Double_t dersum[100];; 1976 Double_t x[3];; 1977 Int_t icu;; 1978 ; 1979 TH1 *hfit = (TH1*)GetObjectFit();; 1980 TF1 *f1 = (TF1*)GetUserFunc();; 1981 Int_t nd = hfit->GetDimension();; 1982 Int_t j;; 1983 Double_t *zik = GetZ();; 1984 Double_t *pl0 = GetPL0();; 1985 ; 1986 Double_t *df=new Double_t[npar];; 1987 ; 1988 npar = f1->GetNpar();; 1989 SetParNumber(npar);; 1990 if(flag == 9) {delete [] df; return;}; 1991 if (flag == 2) for (j=0;j<npar;j++) dersum[j] = gin[j] = 0;; 1992 f1->InitArgs(x,u);; 1993 f = 0;; 1994 ; 1995 Int_t npfit = 0;; 1996 Double_t *cache = fCache;; 1997 for (Int_t i=0;i<fNpoints;i++) {; 1998 if (nd > 2) x[2] = cache[4];; 1999 if (nd > 1) x[1] = cache[3];; 2000 x[0] = cache[2];; 2001 cu = cache[0];; 2002 TF1::RejectPoint(kFALSE);; 2003 if (nd < 2) {; 2004 fu = f1->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3])/cache[3];; 2005 } else if (nd < 3) {; 2006 fu = ((TF2*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5])/(cache[3]*cache[5]);; 2007 } else {; 2008 fu = ((TF3*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5],cache[6] - 0.5*cache[7],cache[6] + 0.5*cache[7])/(cache[3]*cache[5]*cache[7]);; 2009 }; 2010 if (TF1::RejectedPoint()) {cache += fPointSize; continue;}; 2011 if (flag == 2) {; 2012 for (j=0;j<npar;j++) {; 2013 dersum[j] += 1; //should be the derivative; 2014 //grad[j] += dersum[j]*(fu-cu)/eu; dersum[j] = 0;; 2015 }; 2016 }; 2017 if (fu < 1.e-9) fu = 1.e-9;; 2018 icu = Int_t(cu);; 2019 fsub = -fu +icu*TMath::Log(fu);; 2020 fobs = GetSumLog(icu);; 2021 fsub -= fobs;; 2022 Derivatives(df,x);; 2023 int n=0;; 2024 // Here we need gradients of Log likelihood function; 2025 //; 2026 for (j=0;j<npar;j++) {; 2027 if (pl0[j]>0){; 2028 df[n] = df[j]*(icu/fu-1);; 2029 gin[j] -= df[n];; 2030 n++;; 2031 }; 2032 }; 2033 Int_t l = 0;; 2034 // Z-matrix here - production of first derivatives; 20",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:58228,Performance,cache,cache,58228,"75 Double_t dersum[100];; 1976 Double_t x[3];; 1977 Int_t icu;; 1978 ; 1979 TH1 *hfit = (TH1*)GetObjectFit();; 1980 TF1 *f1 = (TF1*)GetUserFunc();; 1981 Int_t nd = hfit->GetDimension();; 1982 Int_t j;; 1983 Double_t *zik = GetZ();; 1984 Double_t *pl0 = GetPL0();; 1985 ; 1986 Double_t *df=new Double_t[npar];; 1987 ; 1988 npar = f1->GetNpar();; 1989 SetParNumber(npar);; 1990 if(flag == 9) {delete [] df; return;}; 1991 if (flag == 2) for (j=0;j<npar;j++) dersum[j] = gin[j] = 0;; 1992 f1->InitArgs(x,u);; 1993 f = 0;; 1994 ; 1995 Int_t npfit = 0;; 1996 Double_t *cache = fCache;; 1997 for (Int_t i=0;i<fNpoints;i++) {; 1998 if (nd > 2) x[2] = cache[4];; 1999 if (nd > 1) x[1] = cache[3];; 2000 x[0] = cache[2];; 2001 cu = cache[0];; 2002 TF1::RejectPoint(kFALSE);; 2003 if (nd < 2) {; 2004 fu = f1->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3])/cache[3];; 2005 } else if (nd < 3) {; 2006 fu = ((TF2*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5])/(cache[3]*cache[5]);; 2007 } else {; 2008 fu = ((TF3*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5],cache[6] - 0.5*cache[7],cache[6] + 0.5*cache[7])/(cache[3]*cache[5]*cache[7]);; 2009 }; 2010 if (TF1::RejectedPoint()) {cache += fPointSize; continue;}; 2011 if (flag == 2) {; 2012 for (j=0;j<npar;j++) {; 2013 dersum[j] += 1; //should be the derivative; 2014 //grad[j] += dersum[j]*(fu-cu)/eu; dersum[j] = 0;; 2015 }; 2016 }; 2017 if (fu < 1.e-9) fu = 1.e-9;; 2018 icu = Int_t(cu);; 2019 fsub = -fu +icu*TMath::Log(fu);; 2020 fobs = GetSumLog(icu);; 2021 fsub -= fobs;; 2022 Derivatives(df,x);; 2023 int n=0;; 2024 // Here we need gradients of Log likelihood function; 2025 //; 2026 for (j=0;j<npar;j++) {; 2027 if (pl0[j]>0){; 2028 df[n] = df[j]*(icu/fu-1);; 2029 gin[j] -= df[n];; 2030 n++;; 2031 }; 2032 }; 2033 Int_t l = 0;; 2034 // Z-matrix here - production of first derivatives; 2035 // of log-likelihood ",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:58237,Performance,cache,cache,58237,"75 Double_t dersum[100];; 1976 Double_t x[3];; 1977 Int_t icu;; 1978 ; 1979 TH1 *hfit = (TH1*)GetObjectFit();; 1980 TF1 *f1 = (TF1*)GetUserFunc();; 1981 Int_t nd = hfit->GetDimension();; 1982 Int_t j;; 1983 Double_t *zik = GetZ();; 1984 Double_t *pl0 = GetPL0();; 1985 ; 1986 Double_t *df=new Double_t[npar];; 1987 ; 1988 npar = f1->GetNpar();; 1989 SetParNumber(npar);; 1990 if(flag == 9) {delete [] df; return;}; 1991 if (flag == 2) for (j=0;j<npar;j++) dersum[j] = gin[j] = 0;; 1992 f1->InitArgs(x,u);; 1993 f = 0;; 1994 ; 1995 Int_t npfit = 0;; 1996 Double_t *cache = fCache;; 1997 for (Int_t i=0;i<fNpoints;i++) {; 1998 if (nd > 2) x[2] = cache[4];; 1999 if (nd > 1) x[1] = cache[3];; 2000 x[0] = cache[2];; 2001 cu = cache[0];; 2002 TF1::RejectPoint(kFALSE);; 2003 if (nd < 2) {; 2004 fu = f1->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3])/cache[3];; 2005 } else if (nd < 3) {; 2006 fu = ((TF2*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5])/(cache[3]*cache[5]);; 2007 } else {; 2008 fu = ((TF3*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5],cache[6] - 0.5*cache[7],cache[6] + 0.5*cache[7])/(cache[3]*cache[5]*cache[7]);; 2009 }; 2010 if (TF1::RejectedPoint()) {cache += fPointSize; continue;}; 2011 if (flag == 2) {; 2012 for (j=0;j<npar;j++) {; 2013 dersum[j] += 1; //should be the derivative; 2014 //grad[j] += dersum[j]*(fu-cu)/eu; dersum[j] = 0;; 2015 }; 2016 }; 2017 if (fu < 1.e-9) fu = 1.e-9;; 2018 icu = Int_t(cu);; 2019 fsub = -fu +icu*TMath::Log(fu);; 2020 fobs = GetSumLog(icu);; 2021 fsub -= fobs;; 2022 Derivatives(df,x);; 2023 int n=0;; 2024 // Here we need gradients of Log likelihood function; 2025 //; 2026 for (j=0;j<npar;j++) {; 2027 if (pl0[j]>0){; 2028 df[n] = df[j]*(icu/fu-1);; 2029 gin[j] -= df[n];; 2030 n++;; 2031 }; 2032 }; 2033 Int_t l = 0;; 2034 // Z-matrix here - production of first derivatives; 2035 // of log-likelihood ",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:58252,Performance,cache,cache,58252,"icu;; 1978 ; 1979 TH1 *hfit = (TH1*)GetObjectFit();; 1980 TF1 *f1 = (TF1*)GetUserFunc();; 1981 Int_t nd = hfit->GetDimension();; 1982 Int_t j;; 1983 Double_t *zik = GetZ();; 1984 Double_t *pl0 = GetPL0();; 1985 ; 1986 Double_t *df=new Double_t[npar];; 1987 ; 1988 npar = f1->GetNpar();; 1989 SetParNumber(npar);; 1990 if(flag == 9) {delete [] df; return;}; 1991 if (flag == 2) for (j=0;j<npar;j++) dersum[j] = gin[j] = 0;; 1992 f1->InitArgs(x,u);; 1993 f = 0;; 1994 ; 1995 Int_t npfit = 0;; 1996 Double_t *cache = fCache;; 1997 for (Int_t i=0;i<fNpoints;i++) {; 1998 if (nd > 2) x[2] = cache[4];; 1999 if (nd > 1) x[1] = cache[3];; 2000 x[0] = cache[2];; 2001 cu = cache[0];; 2002 TF1::RejectPoint(kFALSE);; 2003 if (nd < 2) {; 2004 fu = f1->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3])/cache[3];; 2005 } else if (nd < 3) {; 2006 fu = ((TF2*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5])/(cache[3]*cache[5]);; 2007 } else {; 2008 fu = ((TF3*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5],cache[6] - 0.5*cache[7],cache[6] + 0.5*cache[7])/(cache[3]*cache[5]*cache[7]);; 2009 }; 2010 if (TF1::RejectedPoint()) {cache += fPointSize; continue;}; 2011 if (flag == 2) {; 2012 for (j=0;j<npar;j++) {; 2013 dersum[j] += 1; //should be the derivative; 2014 //grad[j] += dersum[j]*(fu-cu)/eu; dersum[j] = 0;; 2015 }; 2016 }; 2017 if (fu < 1.e-9) fu = 1.e-9;; 2018 icu = Int_t(cu);; 2019 fsub = -fu +icu*TMath::Log(fu);; 2020 fobs = GetSumLog(icu);; 2021 fsub -= fobs;; 2022 Derivatives(df,x);; 2023 int n=0;; 2024 // Here we need gradients of Log likelihood function; 2025 //; 2026 for (j=0;j<npar;j++) {; 2027 if (pl0[j]>0){; 2028 df[n] = df[j]*(icu/fu-1);; 2029 gin[j] -= df[n];; 2030 n++;; 2031 }; 2032 }; 2033 Int_t l = 0;; 2034 // Z-matrix here - production of first derivatives; 2035 // of log-likelihood function; 2036 for (j=0;j<n;j++); 2037 for (Int_t k=0;k<=j;",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:58263,Performance,cache,cache,58263,"icu;; 1978 ; 1979 TH1 *hfit = (TH1*)GetObjectFit();; 1980 TF1 *f1 = (TF1*)GetUserFunc();; 1981 Int_t nd = hfit->GetDimension();; 1982 Int_t j;; 1983 Double_t *zik = GetZ();; 1984 Double_t *pl0 = GetPL0();; 1985 ; 1986 Double_t *df=new Double_t[npar];; 1987 ; 1988 npar = f1->GetNpar();; 1989 SetParNumber(npar);; 1990 if(flag == 9) {delete [] df; return;}; 1991 if (flag == 2) for (j=0;j<npar;j++) dersum[j] = gin[j] = 0;; 1992 f1->InitArgs(x,u);; 1993 f = 0;; 1994 ; 1995 Int_t npfit = 0;; 1996 Double_t *cache = fCache;; 1997 for (Int_t i=0;i<fNpoints;i++) {; 1998 if (nd > 2) x[2] = cache[4];; 1999 if (nd > 1) x[1] = cache[3];; 2000 x[0] = cache[2];; 2001 cu = cache[0];; 2002 TF1::RejectPoint(kFALSE);; 2003 if (nd < 2) {; 2004 fu = f1->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3])/cache[3];; 2005 } else if (nd < 3) {; 2006 fu = ((TF2*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5])/(cache[3]*cache[5]);; 2007 } else {; 2008 fu = ((TF3*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5],cache[6] - 0.5*cache[7],cache[6] + 0.5*cache[7])/(cache[3]*cache[5]*cache[7]);; 2009 }; 2010 if (TF1::RejectedPoint()) {cache += fPointSize; continue;}; 2011 if (flag == 2) {; 2012 for (j=0;j<npar;j++) {; 2013 dersum[j] += 1; //should be the derivative; 2014 //grad[j] += dersum[j]*(fu-cu)/eu; dersum[j] = 0;; 2015 }; 2016 }; 2017 if (fu < 1.e-9) fu = 1.e-9;; 2018 icu = Int_t(cu);; 2019 fsub = -fu +icu*TMath::Log(fu);; 2020 fobs = GetSumLog(icu);; 2021 fsub -= fobs;; 2022 Derivatives(df,x);; 2023 int n=0;; 2024 // Here we need gradients of Log likelihood function; 2025 //; 2026 for (j=0;j<npar;j++) {; 2027 if (pl0[j]>0){; 2028 df[n] = df[j]*(icu/fu-1);; 2029 gin[j] -= df[n];; 2030 n++;; 2031 }; 2032 }; 2033 Int_t l = 0;; 2034 // Z-matrix here - production of first derivatives; 2035 // of log-likelihood function; 2036 for (j=0;j<n;j++); 2037 for (Int_t k=0;k<=j;",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:58272,Performance,cache,cache,58272,"icu;; 1978 ; 1979 TH1 *hfit = (TH1*)GetObjectFit();; 1980 TF1 *f1 = (TF1*)GetUserFunc();; 1981 Int_t nd = hfit->GetDimension();; 1982 Int_t j;; 1983 Double_t *zik = GetZ();; 1984 Double_t *pl0 = GetPL0();; 1985 ; 1986 Double_t *df=new Double_t[npar];; 1987 ; 1988 npar = f1->GetNpar();; 1989 SetParNumber(npar);; 1990 if(flag == 9) {delete [] df; return;}; 1991 if (flag == 2) for (j=0;j<npar;j++) dersum[j] = gin[j] = 0;; 1992 f1->InitArgs(x,u);; 1993 f = 0;; 1994 ; 1995 Int_t npfit = 0;; 1996 Double_t *cache = fCache;; 1997 for (Int_t i=0;i<fNpoints;i++) {; 1998 if (nd > 2) x[2] = cache[4];; 1999 if (nd > 1) x[1] = cache[3];; 2000 x[0] = cache[2];; 2001 cu = cache[0];; 2002 TF1::RejectPoint(kFALSE);; 2003 if (nd < 2) {; 2004 fu = f1->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3])/cache[3];; 2005 } else if (nd < 3) {; 2006 fu = ((TF2*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5])/(cache[3]*cache[5]);; 2007 } else {; 2008 fu = ((TF3*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5],cache[6] - 0.5*cache[7],cache[6] + 0.5*cache[7])/(cache[3]*cache[5]*cache[7]);; 2009 }; 2010 if (TF1::RejectedPoint()) {cache += fPointSize; continue;}; 2011 if (flag == 2) {; 2012 for (j=0;j<npar;j++) {; 2013 dersum[j] += 1; //should be the derivative; 2014 //grad[j] += dersum[j]*(fu-cu)/eu; dersum[j] = 0;; 2015 }; 2016 }; 2017 if (fu < 1.e-9) fu = 1.e-9;; 2018 icu = Int_t(cu);; 2019 fsub = -fu +icu*TMath::Log(fu);; 2020 fobs = GetSumLog(icu);; 2021 fsub -= fobs;; 2022 Derivatives(df,x);; 2023 int n=0;; 2024 // Here we need gradients of Log likelihood function; 2025 //; 2026 for (j=0;j<npar;j++) {; 2027 if (pl0[j]>0){; 2028 df[n] = df[j]*(icu/fu-1);; 2029 gin[j] -= df[n];; 2030 n++;; 2031 }; 2032 }; 2033 Int_t l = 0;; 2034 // Z-matrix here - production of first derivatives; 2035 // of log-likelihood function; 2036 for (j=0;j<n;j++); 2037 for (Int_t k=0;k<=j;",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:58330,Performance,cache,cache,58330,"icu;; 1978 ; 1979 TH1 *hfit = (TH1*)GetObjectFit();; 1980 TF1 *f1 = (TF1*)GetUserFunc();; 1981 Int_t nd = hfit->GetDimension();; 1982 Int_t j;; 1983 Double_t *zik = GetZ();; 1984 Double_t *pl0 = GetPL0();; 1985 ; 1986 Double_t *df=new Double_t[npar];; 1987 ; 1988 npar = f1->GetNpar();; 1989 SetParNumber(npar);; 1990 if(flag == 9) {delete [] df; return;}; 1991 if (flag == 2) for (j=0;j<npar;j++) dersum[j] = gin[j] = 0;; 1992 f1->InitArgs(x,u);; 1993 f = 0;; 1994 ; 1995 Int_t npfit = 0;; 1996 Double_t *cache = fCache;; 1997 for (Int_t i=0;i<fNpoints;i++) {; 1998 if (nd > 2) x[2] = cache[4];; 1999 if (nd > 1) x[1] = cache[3];; 2000 x[0] = cache[2];; 2001 cu = cache[0];; 2002 TF1::RejectPoint(kFALSE);; 2003 if (nd < 2) {; 2004 fu = f1->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3])/cache[3];; 2005 } else if (nd < 3) {; 2006 fu = ((TF2*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5])/(cache[3]*cache[5]);; 2007 } else {; 2008 fu = ((TF3*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5],cache[6] - 0.5*cache[7],cache[6] + 0.5*cache[7])/(cache[3]*cache[5]*cache[7]);; 2009 }; 2010 if (TF1::RejectedPoint()) {cache += fPointSize; continue;}; 2011 if (flag == 2) {; 2012 for (j=0;j<npar;j++) {; 2013 dersum[j] += 1; //should be the derivative; 2014 //grad[j] += dersum[j]*(fu-cu)/eu; dersum[j] = 0;; 2015 }; 2016 }; 2017 if (fu < 1.e-9) fu = 1.e-9;; 2018 icu = Int_t(cu);; 2019 fsub = -fu +icu*TMath::Log(fu);; 2020 fobs = GetSumLog(icu);; 2021 fsub -= fobs;; 2022 Derivatives(df,x);; 2023 int n=0;; 2024 // Here we need gradients of Log likelihood function; 2025 //; 2026 for (j=0;j<npar;j++) {; 2027 if (pl0[j]>0){; 2028 df[n] = df[j]*(icu/fu-1);; 2029 gin[j] -= df[n];; 2030 n++;; 2031 }; 2032 }; 2033 Int_t l = 0;; 2034 // Z-matrix here - production of first derivatives; 2035 // of log-likelihood function; 2036 for (j=0;j<n;j++); 2037 for (Int_t k=0;k<=j;",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:58345,Performance,cache,cache,58345,"F1 *f1 = (TF1*)GetUserFunc();; 1981 Int_t nd = hfit->GetDimension();; 1982 Int_t j;; 1983 Double_t *zik = GetZ();; 1984 Double_t *pl0 = GetPL0();; 1985 ; 1986 Double_t *df=new Double_t[npar];; 1987 ; 1988 npar = f1->GetNpar();; 1989 SetParNumber(npar);; 1990 if(flag == 9) {delete [] df; return;}; 1991 if (flag == 2) for (j=0;j<npar;j++) dersum[j] = gin[j] = 0;; 1992 f1->InitArgs(x,u);; 1993 f = 0;; 1994 ; 1995 Int_t npfit = 0;; 1996 Double_t *cache = fCache;; 1997 for (Int_t i=0;i<fNpoints;i++) {; 1998 if (nd > 2) x[2] = cache[4];; 1999 if (nd > 1) x[1] = cache[3];; 2000 x[0] = cache[2];; 2001 cu = cache[0];; 2002 TF1::RejectPoint(kFALSE);; 2003 if (nd < 2) {; 2004 fu = f1->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3])/cache[3];; 2005 } else if (nd < 3) {; 2006 fu = ((TF2*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5])/(cache[3]*cache[5]);; 2007 } else {; 2008 fu = ((TF3*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5],cache[6] - 0.5*cache[7],cache[6] + 0.5*cache[7])/(cache[3]*cache[5]*cache[7]);; 2009 }; 2010 if (TF1::RejectedPoint()) {cache += fPointSize; continue;}; 2011 if (flag == 2) {; 2012 for (j=0;j<npar;j++) {; 2013 dersum[j] += 1; //should be the derivative; 2014 //grad[j] += dersum[j]*(fu-cu)/eu; dersum[j] = 0;; 2015 }; 2016 }; 2017 if (fu < 1.e-9) fu = 1.e-9;; 2018 icu = Int_t(cu);; 2019 fsub = -fu +icu*TMath::Log(fu);; 2020 fobs = GetSumLog(icu);; 2021 fsub -= fobs;; 2022 Derivatives(df,x);; 2023 int n=0;; 2024 // Here we need gradients of Log likelihood function; 2025 //; 2026 for (j=0;j<npar;j++) {; 2027 if (pl0[j]>0){; 2028 df[n] = df[j]*(icu/fu-1);; 2029 gin[j] -= df[n];; 2030 n++;; 2031 }; 2032 }; 2033 Int_t l = 0;; 2034 // Z-matrix here - production of first derivatives; 2035 // of log-likelihood function; 2036 for (j=0;j<n;j++); 2037 for (Int_t k=0;k<=j;k++); 2038 zik[l++] += df[j]*df[k];; 2039 ; 2040 f -= fsub",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:58354,Performance,cache,cache,58354,"F1 *f1 = (TF1*)GetUserFunc();; 1981 Int_t nd = hfit->GetDimension();; 1982 Int_t j;; 1983 Double_t *zik = GetZ();; 1984 Double_t *pl0 = GetPL0();; 1985 ; 1986 Double_t *df=new Double_t[npar];; 1987 ; 1988 npar = f1->GetNpar();; 1989 SetParNumber(npar);; 1990 if(flag == 9) {delete [] df; return;}; 1991 if (flag == 2) for (j=0;j<npar;j++) dersum[j] = gin[j] = 0;; 1992 f1->InitArgs(x,u);; 1993 f = 0;; 1994 ; 1995 Int_t npfit = 0;; 1996 Double_t *cache = fCache;; 1997 for (Int_t i=0;i<fNpoints;i++) {; 1998 if (nd > 2) x[2] = cache[4];; 1999 if (nd > 1) x[1] = cache[3];; 2000 x[0] = cache[2];; 2001 cu = cache[0];; 2002 TF1::RejectPoint(kFALSE);; 2003 if (nd < 2) {; 2004 fu = f1->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3])/cache[3];; 2005 } else if (nd < 3) {; 2006 fu = ((TF2*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5])/(cache[3]*cache[5]);; 2007 } else {; 2008 fu = ((TF3*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5],cache[6] - 0.5*cache[7],cache[6] + 0.5*cache[7])/(cache[3]*cache[5]*cache[7]);; 2009 }; 2010 if (TF1::RejectedPoint()) {cache += fPointSize; continue;}; 2011 if (flag == 2) {; 2012 for (j=0;j<npar;j++) {; 2013 dersum[j] += 1; //should be the derivative; 2014 //grad[j] += dersum[j]*(fu-cu)/eu; dersum[j] = 0;; 2015 }; 2016 }; 2017 if (fu < 1.e-9) fu = 1.e-9;; 2018 icu = Int_t(cu);; 2019 fsub = -fu +icu*TMath::Log(fu);; 2020 fobs = GetSumLog(icu);; 2021 fsub -= fobs;; 2022 Derivatives(df,x);; 2023 int n=0;; 2024 // Here we need gradients of Log likelihood function; 2025 //; 2026 for (j=0;j<npar;j++) {; 2027 if (pl0[j]>0){; 2028 df[n] = df[j]*(icu/fu-1);; 2029 gin[j] -= df[n];; 2030 n++;; 2031 }; 2032 }; 2033 Int_t l = 0;; 2034 // Z-matrix here - production of first derivatives; 2035 // of log-likelihood function; 2036 for (j=0;j<n;j++); 2037 for (Int_t k=0;k<=j;k++); 2038 zik[l++] += df[j]*df[k];; 2039 ; 2040 f -= fsub",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:58369,Performance,cache,cache,58369,"nc();; 1981 Int_t nd = hfit->GetDimension();; 1982 Int_t j;; 1983 Double_t *zik = GetZ();; 1984 Double_t *pl0 = GetPL0();; 1985 ; 1986 Double_t *df=new Double_t[npar];; 1987 ; 1988 npar = f1->GetNpar();; 1989 SetParNumber(npar);; 1990 if(flag == 9) {delete [] df; return;}; 1991 if (flag == 2) for (j=0;j<npar;j++) dersum[j] = gin[j] = 0;; 1992 f1->InitArgs(x,u);; 1993 f = 0;; 1994 ; 1995 Int_t npfit = 0;; 1996 Double_t *cache = fCache;; 1997 for (Int_t i=0;i<fNpoints;i++) {; 1998 if (nd > 2) x[2] = cache[4];; 1999 if (nd > 1) x[1] = cache[3];; 2000 x[0] = cache[2];; 2001 cu = cache[0];; 2002 TF1::RejectPoint(kFALSE);; 2003 if (nd < 2) {; 2004 fu = f1->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3])/cache[3];; 2005 } else if (nd < 3) {; 2006 fu = ((TF2*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5])/(cache[3]*cache[5]);; 2007 } else {; 2008 fu = ((TF3*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5],cache[6] - 0.5*cache[7],cache[6] + 0.5*cache[7])/(cache[3]*cache[5]*cache[7]);; 2009 }; 2010 if (TF1::RejectedPoint()) {cache += fPointSize; continue;}; 2011 if (flag == 2) {; 2012 for (j=0;j<npar;j++) {; 2013 dersum[j] += 1; //should be the derivative; 2014 //grad[j] += dersum[j]*(fu-cu)/eu; dersum[j] = 0;; 2015 }; 2016 }; 2017 if (fu < 1.e-9) fu = 1.e-9;; 2018 icu = Int_t(cu);; 2019 fsub = -fu +icu*TMath::Log(fu);; 2020 fobs = GetSumLog(icu);; 2021 fsub -= fobs;; 2022 Derivatives(df,x);; 2023 int n=0;; 2024 // Here we need gradients of Log likelihood function; 2025 //; 2026 for (j=0;j<npar;j++) {; 2027 if (pl0[j]>0){; 2028 df[n] = df[j]*(icu/fu-1);; 2029 gin[j] -= df[n];; 2030 n++;; 2031 }; 2032 }; 2033 Int_t l = 0;; 2034 // Z-matrix here - production of first derivatives; 2035 // of log-likelihood function; 2036 for (j=0;j<n;j++); 2037 for (Int_t k=0;k<=j;k++); 2038 zik[l++] += df[j]*df[k];; 2039 ; 2040 f -= fsub;; 2041 npfit++;; 2042 c",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:58378,Performance,cache,cache,58378,"nc();; 1981 Int_t nd = hfit->GetDimension();; 1982 Int_t j;; 1983 Double_t *zik = GetZ();; 1984 Double_t *pl0 = GetPL0();; 1985 ; 1986 Double_t *df=new Double_t[npar];; 1987 ; 1988 npar = f1->GetNpar();; 1989 SetParNumber(npar);; 1990 if(flag == 9) {delete [] df; return;}; 1991 if (flag == 2) for (j=0;j<npar;j++) dersum[j] = gin[j] = 0;; 1992 f1->InitArgs(x,u);; 1993 f = 0;; 1994 ; 1995 Int_t npfit = 0;; 1996 Double_t *cache = fCache;; 1997 for (Int_t i=0;i<fNpoints;i++) {; 1998 if (nd > 2) x[2] = cache[4];; 1999 if (nd > 1) x[1] = cache[3];; 2000 x[0] = cache[2];; 2001 cu = cache[0];; 2002 TF1::RejectPoint(kFALSE);; 2003 if (nd < 2) {; 2004 fu = f1->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3])/cache[3];; 2005 } else if (nd < 3) {; 2006 fu = ((TF2*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5])/(cache[3]*cache[5]);; 2007 } else {; 2008 fu = ((TF3*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5],cache[6] - 0.5*cache[7],cache[6] + 0.5*cache[7])/(cache[3]*cache[5]*cache[7]);; 2009 }; 2010 if (TF1::RejectedPoint()) {cache += fPointSize; continue;}; 2011 if (flag == 2) {; 2012 for (j=0;j<npar;j++) {; 2013 dersum[j] += 1; //should be the derivative; 2014 //grad[j] += dersum[j]*(fu-cu)/eu; dersum[j] = 0;; 2015 }; 2016 }; 2017 if (fu < 1.e-9) fu = 1.e-9;; 2018 icu = Int_t(cu);; 2019 fsub = -fu +icu*TMath::Log(fu);; 2020 fobs = GetSumLog(icu);; 2021 fsub -= fobs;; 2022 Derivatives(df,x);; 2023 int n=0;; 2024 // Here we need gradients of Log likelihood function; 2025 //; 2026 for (j=0;j<npar;j++) {; 2027 if (pl0[j]>0){; 2028 df[n] = df[j]*(icu/fu-1);; 2029 gin[j] -= df[n];; 2030 n++;; 2031 }; 2032 }; 2033 Int_t l = 0;; 2034 // Z-matrix here - production of first derivatives; 2035 // of log-likelihood function; 2036 for (j=0;j<n;j++); 2037 for (Int_t k=0;k<=j;k++); 2038 zik[l++] += df[j]*df[k];; 2039 ; 2040 f -= fsub;; 2041 npfit++;; 2042 c",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:58393,Performance,cache,cache,58393,"fit->GetDimension();; 1982 Int_t j;; 1983 Double_t *zik = GetZ();; 1984 Double_t *pl0 = GetPL0();; 1985 ; 1986 Double_t *df=new Double_t[npar];; 1987 ; 1988 npar = f1->GetNpar();; 1989 SetParNumber(npar);; 1990 if(flag == 9) {delete [] df; return;}; 1991 if (flag == 2) for (j=0;j<npar;j++) dersum[j] = gin[j] = 0;; 1992 f1->InitArgs(x,u);; 1993 f = 0;; 1994 ; 1995 Int_t npfit = 0;; 1996 Double_t *cache = fCache;; 1997 for (Int_t i=0;i<fNpoints;i++) {; 1998 if (nd > 2) x[2] = cache[4];; 1999 if (nd > 1) x[1] = cache[3];; 2000 x[0] = cache[2];; 2001 cu = cache[0];; 2002 TF1::RejectPoint(kFALSE);; 2003 if (nd < 2) {; 2004 fu = f1->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3])/cache[3];; 2005 } else if (nd < 3) {; 2006 fu = ((TF2*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5])/(cache[3]*cache[5]);; 2007 } else {; 2008 fu = ((TF3*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5],cache[6] - 0.5*cache[7],cache[6] + 0.5*cache[7])/(cache[3]*cache[5]*cache[7]);; 2009 }; 2010 if (TF1::RejectedPoint()) {cache += fPointSize; continue;}; 2011 if (flag == 2) {; 2012 for (j=0;j<npar;j++) {; 2013 dersum[j] += 1; //should be the derivative; 2014 //grad[j] += dersum[j]*(fu-cu)/eu; dersum[j] = 0;; 2015 }; 2016 }; 2017 if (fu < 1.e-9) fu = 1.e-9;; 2018 icu = Int_t(cu);; 2019 fsub = -fu +icu*TMath::Log(fu);; 2020 fobs = GetSumLog(icu);; 2021 fsub -= fobs;; 2022 Derivatives(df,x);; 2023 int n=0;; 2024 // Here we need gradients of Log likelihood function; 2025 //; 2026 for (j=0;j<npar;j++) {; 2027 if (pl0[j]>0){; 2028 df[n] = df[j]*(icu/fu-1);; 2029 gin[j] -= df[n];; 2030 n++;; 2031 }; 2032 }; 2033 Int_t l = 0;; 2034 // Z-matrix here - production of first derivatives; 2035 // of log-likelihood function; 2036 for (j=0;j<n;j++); 2037 for (Int_t k=0;k<=j;k++); 2038 zik[l++] += df[j]*df[k];; 2039 ; 2040 f -= fsub;; 2041 npfit++;; 2042 cache += fPointSize;; 204",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:58402,Performance,cache,cache,58402,"fit->GetDimension();; 1982 Int_t j;; 1983 Double_t *zik = GetZ();; 1984 Double_t *pl0 = GetPL0();; 1985 ; 1986 Double_t *df=new Double_t[npar];; 1987 ; 1988 npar = f1->GetNpar();; 1989 SetParNumber(npar);; 1990 if(flag == 9) {delete [] df; return;}; 1991 if (flag == 2) for (j=0;j<npar;j++) dersum[j] = gin[j] = 0;; 1992 f1->InitArgs(x,u);; 1993 f = 0;; 1994 ; 1995 Int_t npfit = 0;; 1996 Double_t *cache = fCache;; 1997 for (Int_t i=0;i<fNpoints;i++) {; 1998 if (nd > 2) x[2] = cache[4];; 1999 if (nd > 1) x[1] = cache[3];; 2000 x[0] = cache[2];; 2001 cu = cache[0];; 2002 TF1::RejectPoint(kFALSE);; 2003 if (nd < 2) {; 2004 fu = f1->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3])/cache[3];; 2005 } else if (nd < 3) {; 2006 fu = ((TF2*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5])/(cache[3]*cache[5]);; 2007 } else {; 2008 fu = ((TF3*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5],cache[6] - 0.5*cache[7],cache[6] + 0.5*cache[7])/(cache[3]*cache[5]*cache[7]);; 2009 }; 2010 if (TF1::RejectedPoint()) {cache += fPointSize; continue;}; 2011 if (flag == 2) {; 2012 for (j=0;j<npar;j++) {; 2013 dersum[j] += 1; //should be the derivative; 2014 //grad[j] += dersum[j]*(fu-cu)/eu; dersum[j] = 0;; 2015 }; 2016 }; 2017 if (fu < 1.e-9) fu = 1.e-9;; 2018 icu = Int_t(cu);; 2019 fsub = -fu +icu*TMath::Log(fu);; 2020 fobs = GetSumLog(icu);; 2021 fsub -= fobs;; 2022 Derivatives(df,x);; 2023 int n=0;; 2024 // Here we need gradients of Log likelihood function; 2025 //; 2026 for (j=0;j<npar;j++) {; 2027 if (pl0[j]>0){; 2028 df[n] = df[j]*(icu/fu-1);; 2029 gin[j] -= df[n];; 2030 n++;; 2031 }; 2032 }; 2033 Int_t l = 0;; 2034 // Z-matrix here - production of first derivatives; 2035 // of log-likelihood function; 2036 for (j=0;j<n;j++); 2037 for (Int_t k=0;k<=j;k++); 2038 zik[l++] += df[j]*df[k];; 2039 ; 2040 f -= fsub;; 2041 npfit++;; 2042 cache += fPointSize;; 204",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:58417,Performance,cache,cache,58417,"82 Int_t j;; 1983 Double_t *zik = GetZ();; 1984 Double_t *pl0 = GetPL0();; 1985 ; 1986 Double_t *df=new Double_t[npar];; 1987 ; 1988 npar = f1->GetNpar();; 1989 SetParNumber(npar);; 1990 if(flag == 9) {delete [] df; return;}; 1991 if (flag == 2) for (j=0;j<npar;j++) dersum[j] = gin[j] = 0;; 1992 f1->InitArgs(x,u);; 1993 f = 0;; 1994 ; 1995 Int_t npfit = 0;; 1996 Double_t *cache = fCache;; 1997 for (Int_t i=0;i<fNpoints;i++) {; 1998 if (nd > 2) x[2] = cache[4];; 1999 if (nd > 1) x[1] = cache[3];; 2000 x[0] = cache[2];; 2001 cu = cache[0];; 2002 TF1::RejectPoint(kFALSE);; 2003 if (nd < 2) {; 2004 fu = f1->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3])/cache[3];; 2005 } else if (nd < 3) {; 2006 fu = ((TF2*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5])/(cache[3]*cache[5]);; 2007 } else {; 2008 fu = ((TF3*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5],cache[6] - 0.5*cache[7],cache[6] + 0.5*cache[7])/(cache[3]*cache[5]*cache[7]);; 2009 }; 2010 if (TF1::RejectedPoint()) {cache += fPointSize; continue;}; 2011 if (flag == 2) {; 2012 for (j=0;j<npar;j++) {; 2013 dersum[j] += 1; //should be the derivative; 2014 //grad[j] += dersum[j]*(fu-cu)/eu; dersum[j] = 0;; 2015 }; 2016 }; 2017 if (fu < 1.e-9) fu = 1.e-9;; 2018 icu = Int_t(cu);; 2019 fsub = -fu +icu*TMath::Log(fu);; 2020 fobs = GetSumLog(icu);; 2021 fsub -= fobs;; 2022 Derivatives(df,x);; 2023 int n=0;; 2024 // Here we need gradients of Log likelihood function; 2025 //; 2026 for (j=0;j<npar;j++) {; 2027 if (pl0[j]>0){; 2028 df[n] = df[j]*(icu/fu-1);; 2029 gin[j] -= df[n];; 2030 n++;; 2031 }; 2032 }; 2033 Int_t l = 0;; 2034 // Z-matrix here - production of first derivatives; 2035 // of log-likelihood function; 2036 for (j=0;j<n;j++); 2037 for (Int_t k=0;k<=j;k++); 2038 zik[l++] += df[j]*df[k];; 2039 ; 2040 f -= fsub;; 2041 npfit++;; 2042 cache += fPointSize;; 2043 }; 2044 f *= 2;; 2045 ",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:58426,Performance,cache,cache,58426,"82 Int_t j;; 1983 Double_t *zik = GetZ();; 1984 Double_t *pl0 = GetPL0();; 1985 ; 1986 Double_t *df=new Double_t[npar];; 1987 ; 1988 npar = f1->GetNpar();; 1989 SetParNumber(npar);; 1990 if(flag == 9) {delete [] df; return;}; 1991 if (flag == 2) for (j=0;j<npar;j++) dersum[j] = gin[j] = 0;; 1992 f1->InitArgs(x,u);; 1993 f = 0;; 1994 ; 1995 Int_t npfit = 0;; 1996 Double_t *cache = fCache;; 1997 for (Int_t i=0;i<fNpoints;i++) {; 1998 if (nd > 2) x[2] = cache[4];; 1999 if (nd > 1) x[1] = cache[3];; 2000 x[0] = cache[2];; 2001 cu = cache[0];; 2002 TF1::RejectPoint(kFALSE);; 2003 if (nd < 2) {; 2004 fu = f1->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3])/cache[3];; 2005 } else if (nd < 3) {; 2006 fu = ((TF2*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5])/(cache[3]*cache[5]);; 2007 } else {; 2008 fu = ((TF3*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5],cache[6] - 0.5*cache[7],cache[6] + 0.5*cache[7])/(cache[3]*cache[5]*cache[7]);; 2009 }; 2010 if (TF1::RejectedPoint()) {cache += fPointSize; continue;}; 2011 if (flag == 2) {; 2012 for (j=0;j<npar;j++) {; 2013 dersum[j] += 1; //should be the derivative; 2014 //grad[j] += dersum[j]*(fu-cu)/eu; dersum[j] = 0;; 2015 }; 2016 }; 2017 if (fu < 1.e-9) fu = 1.e-9;; 2018 icu = Int_t(cu);; 2019 fsub = -fu +icu*TMath::Log(fu);; 2020 fobs = GetSumLog(icu);; 2021 fsub -= fobs;; 2022 Derivatives(df,x);; 2023 int n=0;; 2024 // Here we need gradients of Log likelihood function; 2025 //; 2026 for (j=0;j<npar;j++) {; 2027 if (pl0[j]>0){; 2028 df[n] = df[j]*(icu/fu-1);; 2029 gin[j] -= df[n];; 2030 n++;; 2031 }; 2032 }; 2033 Int_t l = 0;; 2034 // Z-matrix here - production of first derivatives; 2035 // of log-likelihood function; 2036 for (j=0;j<n;j++); 2037 for (Int_t k=0;k<=j;k++); 2038 zik[l++] += df[j]*df[k];; 2039 ; 2040 f -= fsub;; 2041 npfit++;; 2042 cache += fPointSize;; 2043 }; 2044 f *= 2;; 2045 ",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:58441,Performance,cache,cache,58441,"_t *zik = GetZ();; 1984 Double_t *pl0 = GetPL0();; 1985 ; 1986 Double_t *df=new Double_t[npar];; 1987 ; 1988 npar = f1->GetNpar();; 1989 SetParNumber(npar);; 1990 if(flag == 9) {delete [] df; return;}; 1991 if (flag == 2) for (j=0;j<npar;j++) dersum[j] = gin[j] = 0;; 1992 f1->InitArgs(x,u);; 1993 f = 0;; 1994 ; 1995 Int_t npfit = 0;; 1996 Double_t *cache = fCache;; 1997 for (Int_t i=0;i<fNpoints;i++) {; 1998 if (nd > 2) x[2] = cache[4];; 1999 if (nd > 1) x[1] = cache[3];; 2000 x[0] = cache[2];; 2001 cu = cache[0];; 2002 TF1::RejectPoint(kFALSE);; 2003 if (nd < 2) {; 2004 fu = f1->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3])/cache[3];; 2005 } else if (nd < 3) {; 2006 fu = ((TF2*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5])/(cache[3]*cache[5]);; 2007 } else {; 2008 fu = ((TF3*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5],cache[6] - 0.5*cache[7],cache[6] + 0.5*cache[7])/(cache[3]*cache[5]*cache[7]);; 2009 }; 2010 if (TF1::RejectedPoint()) {cache += fPointSize; continue;}; 2011 if (flag == 2) {; 2012 for (j=0;j<npar;j++) {; 2013 dersum[j] += 1; //should be the derivative; 2014 //grad[j] += dersum[j]*(fu-cu)/eu; dersum[j] = 0;; 2015 }; 2016 }; 2017 if (fu < 1.e-9) fu = 1.e-9;; 2018 icu = Int_t(cu);; 2019 fsub = -fu +icu*TMath::Log(fu);; 2020 fobs = GetSumLog(icu);; 2021 fsub -= fobs;; 2022 Derivatives(df,x);; 2023 int n=0;; 2024 // Here we need gradients of Log likelihood function; 2025 //; 2026 for (j=0;j<npar;j++) {; 2027 if (pl0[j]>0){; 2028 df[n] = df[j]*(icu/fu-1);; 2029 gin[j] -= df[n];; 2030 n++;; 2031 }; 2032 }; 2033 Int_t l = 0;; 2034 // Z-matrix here - production of first derivatives; 2035 // of log-likelihood function; 2036 for (j=0;j<n;j++); 2037 for (Int_t k=0;k<=j;k++); 2038 zik[l++] += df[j]*df[k];; 2039 ; 2040 f -= fsub;; 2041 npfit++;; 2042 cache += fPointSize;; 2043 }; 2044 f *= 2;; 2045 f1->SetNumberFitPoints(n",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:58450,Performance,cache,cache,58450,"_t *zik = GetZ();; 1984 Double_t *pl0 = GetPL0();; 1985 ; 1986 Double_t *df=new Double_t[npar];; 1987 ; 1988 npar = f1->GetNpar();; 1989 SetParNumber(npar);; 1990 if(flag == 9) {delete [] df; return;}; 1991 if (flag == 2) for (j=0;j<npar;j++) dersum[j] = gin[j] = 0;; 1992 f1->InitArgs(x,u);; 1993 f = 0;; 1994 ; 1995 Int_t npfit = 0;; 1996 Double_t *cache = fCache;; 1997 for (Int_t i=0;i<fNpoints;i++) {; 1998 if (nd > 2) x[2] = cache[4];; 1999 if (nd > 1) x[1] = cache[3];; 2000 x[0] = cache[2];; 2001 cu = cache[0];; 2002 TF1::RejectPoint(kFALSE);; 2003 if (nd < 2) {; 2004 fu = f1->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3])/cache[3];; 2005 } else if (nd < 3) {; 2006 fu = ((TF2*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5])/(cache[3]*cache[5]);; 2007 } else {; 2008 fu = ((TF3*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5],cache[6] - 0.5*cache[7],cache[6] + 0.5*cache[7])/(cache[3]*cache[5]*cache[7]);; 2009 }; 2010 if (TF1::RejectedPoint()) {cache += fPointSize; continue;}; 2011 if (flag == 2) {; 2012 for (j=0;j<npar;j++) {; 2013 dersum[j] += 1; //should be the derivative; 2014 //grad[j] += dersum[j]*(fu-cu)/eu; dersum[j] = 0;; 2015 }; 2016 }; 2017 if (fu < 1.e-9) fu = 1.e-9;; 2018 icu = Int_t(cu);; 2019 fsub = -fu +icu*TMath::Log(fu);; 2020 fobs = GetSumLog(icu);; 2021 fsub -= fobs;; 2022 Derivatives(df,x);; 2023 int n=0;; 2024 // Here we need gradients of Log likelihood function; 2025 //; 2026 for (j=0;j<npar;j++) {; 2027 if (pl0[j]>0){; 2028 df[n] = df[j]*(icu/fu-1);; 2029 gin[j] -= df[n];; 2030 n++;; 2031 }; 2032 }; 2033 Int_t l = 0;; 2034 // Z-matrix here - production of first derivatives; 2035 // of log-likelihood function; 2036 for (j=0;j<n;j++); 2037 for (Int_t k=0;k<=j;k++); 2038 zik[l++] += df[j]*df[k];; 2039 ; 2040 f -= fsub;; 2041 npfit++;; 2042 cache += fPointSize;; 2043 }; 2044 f *= 2;; 2045 f1->SetNumberFitPoints(n",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:58465,Performance,cache,cache,58465,"f(flag == 9) {delete [] df; return;}; 1991 if (flag == 2) for (j=0;j<npar;j++) dersum[j] = gin[j] = 0;; 1992 f1->InitArgs(x,u);; 1993 f = 0;; 1994 ; 1995 Int_t npfit = 0;; 1996 Double_t *cache = fCache;; 1997 for (Int_t i=0;i<fNpoints;i++) {; 1998 if (nd > 2) x[2] = cache[4];; 1999 if (nd > 1) x[1] = cache[3];; 2000 x[0] = cache[2];; 2001 cu = cache[0];; 2002 TF1::RejectPoint(kFALSE);; 2003 if (nd < 2) {; 2004 fu = f1->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3])/cache[3];; 2005 } else if (nd < 3) {; 2006 fu = ((TF2*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5])/(cache[3]*cache[5]);; 2007 } else {; 2008 fu = ((TF3*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5],cache[6] - 0.5*cache[7],cache[6] + 0.5*cache[7])/(cache[3]*cache[5]*cache[7]);; 2009 }; 2010 if (TF1::RejectedPoint()) {cache += fPointSize; continue;}; 2011 if (flag == 2) {; 2012 for (j=0;j<npar;j++) {; 2013 dersum[j] += 1; //should be the derivative; 2014 //grad[j] += dersum[j]*(fu-cu)/eu; dersum[j] = 0;; 2015 }; 2016 }; 2017 if (fu < 1.e-9) fu = 1.e-9;; 2018 icu = Int_t(cu);; 2019 fsub = -fu +icu*TMath::Log(fu);; 2020 fobs = GetSumLog(icu);; 2021 fsub -= fobs;; 2022 Derivatives(df,x);; 2023 int n=0;; 2024 // Here we need gradients of Log likelihood function; 2025 //; 2026 for (j=0;j<npar;j++) {; 2027 if (pl0[j]>0){; 2028 df[n] = df[j]*(icu/fu-1);; 2029 gin[j] -= df[n];; 2030 n++;; 2031 }; 2032 }; 2033 Int_t l = 0;; 2034 // Z-matrix here - production of first derivatives; 2035 // of log-likelihood function; 2036 for (j=0;j<n;j++); 2037 for (Int_t k=0;k<=j;k++); 2038 zik[l++] += df[j]*df[k];; 2039 ; 2040 f -= fsub;; 2041 npfit++;; 2042 cache += fPointSize;; 2043 }; 2044 f *= 2;; 2045 f1->SetNumberFitPoints(npfit);; 2046 delete[] df;; 2047}; 2048 ; 2049 ; 2050//______________________________________________________________________________; 2051//; 2052// STATIC functions",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:58476,Performance,cache,cache,58476,"f(flag == 9) {delete [] df; return;}; 1991 if (flag == 2) for (j=0;j<npar;j++) dersum[j] = gin[j] = 0;; 1992 f1->InitArgs(x,u);; 1993 f = 0;; 1994 ; 1995 Int_t npfit = 0;; 1996 Double_t *cache = fCache;; 1997 for (Int_t i=0;i<fNpoints;i++) {; 1998 if (nd > 2) x[2] = cache[4];; 1999 if (nd > 1) x[1] = cache[3];; 2000 x[0] = cache[2];; 2001 cu = cache[0];; 2002 TF1::RejectPoint(kFALSE);; 2003 if (nd < 2) {; 2004 fu = f1->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3])/cache[3];; 2005 } else if (nd < 3) {; 2006 fu = ((TF2*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5])/(cache[3]*cache[5]);; 2007 } else {; 2008 fu = ((TF3*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5],cache[6] - 0.5*cache[7],cache[6] + 0.5*cache[7])/(cache[3]*cache[5]*cache[7]);; 2009 }; 2010 if (TF1::RejectedPoint()) {cache += fPointSize; continue;}; 2011 if (flag == 2) {; 2012 for (j=0;j<npar;j++) {; 2013 dersum[j] += 1; //should be the derivative; 2014 //grad[j] += dersum[j]*(fu-cu)/eu; dersum[j] = 0;; 2015 }; 2016 }; 2017 if (fu < 1.e-9) fu = 1.e-9;; 2018 icu = Int_t(cu);; 2019 fsub = -fu +icu*TMath::Log(fu);; 2020 fobs = GetSumLog(icu);; 2021 fsub -= fobs;; 2022 Derivatives(df,x);; 2023 int n=0;; 2024 // Here we need gradients of Log likelihood function; 2025 //; 2026 for (j=0;j<npar;j++) {; 2027 if (pl0[j]>0){; 2028 df[n] = df[j]*(icu/fu-1);; 2029 gin[j] -= df[n];; 2030 n++;; 2031 }; 2032 }; 2033 Int_t l = 0;; 2034 // Z-matrix here - production of first derivatives; 2035 // of log-likelihood function; 2036 for (j=0;j<n;j++); 2037 for (Int_t k=0;k<=j;k++); 2038 zik[l++] += df[j]*df[k];; 2039 ; 2040 f -= fsub;; 2041 npfit++;; 2042 cache += fPointSize;; 2043 }; 2044 f *= 2;; 2045 f1->SetNumberFitPoints(npfit);; 2046 delete[] df;; 2047}; 2048 ; 2049 ; 2050//______________________________________________________________________________; 2051//; 2052// STATIC functions",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:58485,Performance,cache,cache,58485,"f(flag == 9) {delete [] df; return;}; 1991 if (flag == 2) for (j=0;j<npar;j++) dersum[j] = gin[j] = 0;; 1992 f1->InitArgs(x,u);; 1993 f = 0;; 1994 ; 1995 Int_t npfit = 0;; 1996 Double_t *cache = fCache;; 1997 for (Int_t i=0;i<fNpoints;i++) {; 1998 if (nd > 2) x[2] = cache[4];; 1999 if (nd > 1) x[1] = cache[3];; 2000 x[0] = cache[2];; 2001 cu = cache[0];; 2002 TF1::RejectPoint(kFALSE);; 2003 if (nd < 2) {; 2004 fu = f1->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3])/cache[3];; 2005 } else if (nd < 3) {; 2006 fu = ((TF2*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5])/(cache[3]*cache[5]);; 2007 } else {; 2008 fu = ((TF3*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5],cache[6] - 0.5*cache[7],cache[6] + 0.5*cache[7])/(cache[3]*cache[5]*cache[7]);; 2009 }; 2010 if (TF1::RejectedPoint()) {cache += fPointSize; continue;}; 2011 if (flag == 2) {; 2012 for (j=0;j<npar;j++) {; 2013 dersum[j] += 1; //should be the derivative; 2014 //grad[j] += dersum[j]*(fu-cu)/eu; dersum[j] = 0;; 2015 }; 2016 }; 2017 if (fu < 1.e-9) fu = 1.e-9;; 2018 icu = Int_t(cu);; 2019 fsub = -fu +icu*TMath::Log(fu);; 2020 fobs = GetSumLog(icu);; 2021 fsub -= fobs;; 2022 Derivatives(df,x);; 2023 int n=0;; 2024 // Here we need gradients of Log likelihood function; 2025 //; 2026 for (j=0;j<npar;j++) {; 2027 if (pl0[j]>0){; 2028 df[n] = df[j]*(icu/fu-1);; 2029 gin[j] -= df[n];; 2030 n++;; 2031 }; 2032 }; 2033 Int_t l = 0;; 2034 // Z-matrix here - production of first derivatives; 2035 // of log-likelihood function; 2036 for (j=0;j<n;j++); 2037 for (Int_t k=0;k<=j;k++); 2038 zik[l++] += df[j]*df[k];; 2039 ; 2040 f -= fsub;; 2041 npfit++;; 2042 cache += fPointSize;; 2043 }; 2044 f *= 2;; 2045 f1->SetNumberFitPoints(npfit);; 2046 delete[] df;; 2047}; 2048 ; 2049 ; 2050//______________________________________________________________________________; 2051//; 2052// STATIC functions",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:58494,Performance,cache,cache,58494,"f(flag == 9) {delete [] df; return;}; 1991 if (flag == 2) for (j=0;j<npar;j++) dersum[j] = gin[j] = 0;; 1992 f1->InitArgs(x,u);; 1993 f = 0;; 1994 ; 1995 Int_t npfit = 0;; 1996 Double_t *cache = fCache;; 1997 for (Int_t i=0;i<fNpoints;i++) {; 1998 if (nd > 2) x[2] = cache[4];; 1999 if (nd > 1) x[1] = cache[3];; 2000 x[0] = cache[2];; 2001 cu = cache[0];; 2002 TF1::RejectPoint(kFALSE);; 2003 if (nd < 2) {; 2004 fu = f1->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3])/cache[3];; 2005 } else if (nd < 3) {; 2006 fu = ((TF2*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5])/(cache[3]*cache[5]);; 2007 } else {; 2008 fu = ((TF3*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5],cache[6] - 0.5*cache[7],cache[6] + 0.5*cache[7])/(cache[3]*cache[5]*cache[7]);; 2009 }; 2010 if (TF1::RejectedPoint()) {cache += fPointSize; continue;}; 2011 if (flag == 2) {; 2012 for (j=0;j<npar;j++) {; 2013 dersum[j] += 1; //should be the derivative; 2014 //grad[j] += dersum[j]*(fu-cu)/eu; dersum[j] = 0;; 2015 }; 2016 }; 2017 if (fu < 1.e-9) fu = 1.e-9;; 2018 icu = Int_t(cu);; 2019 fsub = -fu +icu*TMath::Log(fu);; 2020 fobs = GetSumLog(icu);; 2021 fsub -= fobs;; 2022 Derivatives(df,x);; 2023 int n=0;; 2024 // Here we need gradients of Log likelihood function; 2025 //; 2026 for (j=0;j<npar;j++) {; 2027 if (pl0[j]>0){; 2028 df[n] = df[j]*(icu/fu-1);; 2029 gin[j] -= df[n];; 2030 n++;; 2031 }; 2032 }; 2033 Int_t l = 0;; 2034 // Z-matrix here - production of first derivatives; 2035 // of log-likelihood function; 2036 for (j=0;j<n;j++); 2037 for (Int_t k=0;k<=j;k++); 2038 zik[l++] += df[j]*df[k];; 2039 ; 2040 f -= fsub;; 2041 npfit++;; 2042 cache += fPointSize;; 2043 }; 2044 f *= 2;; 2045 f1->SetNumberFitPoints(npfit);; 2046 delete[] df;; 2047}; 2048 ; 2049 ; 2050//______________________________________________________________________________; 2051//; 2052// STATIC functions",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:58546,Performance,cache,cache,58546,"f(flag == 9) {delete [] df; return;}; 1991 if (flag == 2) for (j=0;j<npar;j++) dersum[j] = gin[j] = 0;; 1992 f1->InitArgs(x,u);; 1993 f = 0;; 1994 ; 1995 Int_t npfit = 0;; 1996 Double_t *cache = fCache;; 1997 for (Int_t i=0;i<fNpoints;i++) {; 1998 if (nd > 2) x[2] = cache[4];; 1999 if (nd > 1) x[1] = cache[3];; 2000 x[0] = cache[2];; 2001 cu = cache[0];; 2002 TF1::RejectPoint(kFALSE);; 2003 if (nd < 2) {; 2004 fu = f1->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3])/cache[3];; 2005 } else if (nd < 3) {; 2006 fu = ((TF2*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5])/(cache[3]*cache[5]);; 2007 } else {; 2008 fu = ((TF3*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5],cache[6] - 0.5*cache[7],cache[6] + 0.5*cache[7])/(cache[3]*cache[5]*cache[7]);; 2009 }; 2010 if (TF1::RejectedPoint()) {cache += fPointSize; continue;}; 2011 if (flag == 2) {; 2012 for (j=0;j<npar;j++) {; 2013 dersum[j] += 1; //should be the derivative; 2014 //grad[j] += dersum[j]*(fu-cu)/eu; dersum[j] = 0;; 2015 }; 2016 }; 2017 if (fu < 1.e-9) fu = 1.e-9;; 2018 icu = Int_t(cu);; 2019 fsub = -fu +icu*TMath::Log(fu);; 2020 fobs = GetSumLog(icu);; 2021 fsub -= fobs;; 2022 Derivatives(df,x);; 2023 int n=0;; 2024 // Here we need gradients of Log likelihood function; 2025 //; 2026 for (j=0;j<npar;j++) {; 2027 if (pl0[j]>0){; 2028 df[n] = df[j]*(icu/fu-1);; 2029 gin[j] -= df[n];; 2030 n++;; 2031 }; 2032 }; 2033 Int_t l = 0;; 2034 // Z-matrix here - production of first derivatives; 2035 // of log-likelihood function; 2036 for (j=0;j<n;j++); 2037 for (Int_t k=0;k<=j;k++); 2038 zik[l++] += df[j]*df[k];; 2039 ; 2040 f -= fsub;; 2041 npfit++;; 2042 cache += fPointSize;; 2043 }; 2044 f *= 2;; 2045 f1->SetNumberFitPoints(npfit);; 2046 delete[] df;; 2047}; 2048 ; 2049 ; 2050//______________________________________________________________________________; 2051//; 2052// STATIC functions",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:59378,Performance,cache,cache,59378,">Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5],cache[6] - 0.5*cache[7],cache[6] + 0.5*cache[7])/(cache[3]*cache[5]*cache[7]);; 2009 }; 2010 if (TF1::RejectedPoint()) {cache += fPointSize; continue;}; 2011 if (flag == 2) {; 2012 for (j=0;j<npar;j++) {; 2013 dersum[j] += 1; //should be the derivative; 2014 //grad[j] += dersum[j]*(fu-cu)/eu; dersum[j] = 0;; 2015 }; 2016 }; 2017 if (fu < 1.e-9) fu = 1.e-9;; 2018 icu = Int_t(cu);; 2019 fsub = -fu +icu*TMath::Log(fu);; 2020 fobs = GetSumLog(icu);; 2021 fsub -= fobs;; 2022 Derivatives(df,x);; 2023 int n=0;; 2024 // Here we need gradients of Log likelihood function; 2025 //; 2026 for (j=0;j<npar;j++) {; 2027 if (pl0[j]>0){; 2028 df[n] = df[j]*(icu/fu-1);; 2029 gin[j] -= df[n];; 2030 n++;; 2031 }; 2032 }; 2033 Int_t l = 0;; 2034 // Z-matrix here - production of first derivatives; 2035 // of log-likelihood function; 2036 for (j=0;j<n;j++); 2037 for (Int_t k=0;k<=j;k++); 2038 zik[l++] += df[j]*df[k];; 2039 ; 2040 f -= fsub;; 2041 npfit++;; 2042 cache += fPointSize;; 2043 }; 2044 f *= 2;; 2045 f1->SetNumberFitPoints(npfit);; 2046 delete[] df;; 2047}; 2048 ; 2049 ; 2050//______________________________________________________________________________; 2051//; 2052// STATIC functions; 2053//______________________________________________________________________________; 2054 ; 2055////////////////////////////////////////////////////////////////////////////////; 2056/// Minimization function for H1s using a Chisquare method.; 2057 ; 2058void H1FitChisquareFumili(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag); 2059{; 2060 TFumili *hFitter = (TFumili*)TVirtualFitter::GetFitter();; 2061 hFitter->FitChisquare(npar, gin, f, u, flag);; 2062}; 2063 ; 2064////////////////////////////////////////////////////////////////////////////////; 2065/// Minimization function for H1s using a Likelihood method.; 2066/// Basically, it forms the likelihood by determining the Poi",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:79321,Performance,cache,cache,79321,"aph.h:139; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::GetDimensionvirtual Int_t GetDimension() constDefinition TH1.h:283; TNamed::SetNamevirtual void SetName(const char *name)Set the name of the TNamed.Definition TNamed.cxx:140; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::kInvalidObject@ kInvalidObjectif object ctor succeeded but object should not be usedDefinition TObject.h:72; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; TString::ToUppervoid ToUpper()Change string to upper case.Definition TString.cxx:1195; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TVirtualFitter::fPointSizeInt_t fPointSizeNumber of words per point in the cache.Definition TVirtualFitter.h:40; TVirtualFitter::GetObjectFitvirtual TObject * GetObjectFit() constDefinition TVirtualFitter.h:77; TVirtualFitter::fUserFuncTObject * fUserFuncPointer to user theoretical function (a TF1*)Definition TVirtualFitter.h:44; TVirtualFitter::GetFitOptionvirtual Foption_t GetFitOption() constDefinition TVirtualFitter.h:73; TVirtualFitter::SetFCNvirtual void SetFCN(void(*fcn)(Int_t &, Double_t *, Double_t &f, Double_t *, Int_t))To set the address of the minimization objective function called by the native compiler (see function...Definition TVirtualFitter.cxx:267; TVirtualFitter::fCacheDouble_t * fCache[fCacheSize] Array of points data (fNpoints*fPointSize < fCacheSize words)Definition TVirtualFitter.h:42; TVirtualFitter::fFCNvoid(* fFCN)(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag)Definition TVirtualFitter.h:46; TVirtualFitter::GetFitterstatic TVirtualFitter * GetFitter()static: return the current ",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:53983,Safety,predict,predict,53983,"cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5],cache[6] - 0.5*cache[7],cache[6] + 0.5*cache[7])/(cache[3]*cache[5]*cache[7]);; 1843 }; 1844 if (TF1::RejectedPoint()) {cache += fPointSize; continue;}; 1845 eu = cache[1];; 1846 Derivatives(df,x);; 1847 Int_t n = 0;; 1848 fsum = (fu-cu)/eu;; 1849 if (flag!=1) {; 1850 for (j=0;j<npar;j++) {; 1851 if (pl0[j]>0){; 1852 df[n] = df[j]/eu;; 1853 // left only non-fixed param derivatives / by Sigma; 1854 gin[j] += df[n]*fsum;; 1855 n++;; 1856 }; 1857 }; 1858 Int_t l = 0;; 1859 for (j=0;j<n;j++); 1860 for (Int_t k=0;k<=j;k++); 1861 zik[l++] += df[j]*df[k];; 1862 }; 1863 f += .5*fsum*fsum;; 1864 npfit++;; 1865 cache += fPointSize;; 1866 }; 1867 f1->SetNumberFitPoints(npfit);; 1868 delete[] df;; 1869}; 1870 ; 1871////////////////////////////////////////////////////////////////////////////////; 1872/// Minimization function for H1s using a Likelihood method.; 1873/// Basically, it forms the likelihood by determining the Poisson; 1874/// probability that given a number of entries in a particular bin,; 1875/// the fit would predict it's value. This is then done for each bin,; 1876/// and the sum of the logs is taken as the likelihood.; 1877///; 1878/// Default method (function evaluated at center of bin); 1879/// for each point the cache contains the following info; 1880/// - 1D : bc,e,xc (bin content, error, x of center of bin); 1881/// - 2D : bc,e,xc,yc; 1882/// - 3D : bc,e,xc,yc,zc; 1883 ; 1884void TFumili::FitLikelihood(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag); 1885{; 1886 Foption_t fitOption = GetFitOption();; 1887 if (fitOption.Integral) {; 1888 FitLikelihoodI(npar,gin,f,u,flag);; 1889 return;; 1890 }; 1891 Double_t cu,fu,fobs,fsub;; 1892 Double_t dersum[100];; 1893 Double_t x[3];; 1894 Int_t icu;; 1895 ; 1896 TH1 *hfit = (TH1*)GetObjectFit();; 1897 TF1 *f1 = (TF1*)GetUserFunc();; 1898 Int_t nd = hfit->GetDimension();; 1899 Int_t j;; 1900 Double_t *zik = GetZ();; 1901 Double_t *pl0 = GetPL0();; 1902 ; ",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:56706,Safety,predict,predict,56706," 1925 }; 1926 }; 1927 if (fu < 1.e-9) fu = 1.e-9;; 1928 icu = Int_t(cu);; 1929 fsub = -fu +icu*TMath::Log(fu);; 1930 fobs = GetSumLog(icu);; 1931 fsub -= fobs;; 1932 Derivatives(df,x);; 1933 int n=0;; 1934 // Here we need gradients of Log likelihood function; 1935 //; 1936 for (j=0;j<npar;j++) {; 1937 if (pl0[j]>0){; 1938 df[n] = df[j]*(icu/fu-1);; 1939 gin[j] -= df[n];; 1940 n++;; 1941 }; 1942 }; 1943 Int_t l = 0;; 1944 // Z-matrix here - production of first derivatives; 1945 // of log-likelihood function; 1946 for (j=0;j<n;j++); 1947 for (Int_t k=0;k<=j;k++); 1948 zik[l++] += df[j]*df[k];; 1949 ; 1950 f -= fsub;; 1951 npfit++;; 1952 cache += fPointSize;; 1953 }; 1954 f *= 2;; 1955 f1->SetNumberFitPoints(npfit);; 1956 delete[] df;; 1957}; 1958 ; 1959////////////////////////////////////////////////////////////////////////////////; 1960/// Minimization function for H1s using a Likelihood method.; 1961/// Basically, it forms the likelihood by determining the Poisson; 1962/// probability that given a number of entries in a particular bin,; 1963/// the fit would predict it's value. This is then done for each bin,; 1964/// and the sum of the logs is taken as the likelihood.; 1965///; 1966/// The ""I""ntegral method is used; 1967/// for each point the cache contains the following info; 1968/// - 1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); 1969/// - 2D : bc,e,xc,xw,yc,yw; 1970/// - 3D : bc,e,xc,xw,yc,yw,zc,zw; 1971 ; 1972void TFumili::FitLikelihoodI(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag); 1973{; 1974 Double_t cu,fu,fobs,fsub;; 1975 Double_t dersum[100];; 1976 Double_t x[3];; 1977 Int_t icu;; 1978 ; 1979 TH1 *hfit = (TH1*)GetObjectFit();; 1980 TF1 *f1 = (TF1*)GetUserFunc();; 1981 Int_t nd = hfit->GetDimension();; 1982 Int_t j;; 1983 Double_t *zik = GetZ();; 1984 Double_t *pl0 = GetPL0();; 1985 ; 1986 Double_t *df=new Double_t[npar];; 1987 ; 1988 npar = f1->GetNpar();; 1989 SetParNumber(npar);; 1990 if(flag == 9) {del",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:60421,Safety,predict,predict,60421,"f -= fsub;; 2041 npfit++;; 2042 cache += fPointSize;; 2043 }; 2044 f *= 2;; 2045 f1->SetNumberFitPoints(npfit);; 2046 delete[] df;; 2047}; 2048 ; 2049 ; 2050//______________________________________________________________________________; 2051//; 2052// STATIC functions; 2053//______________________________________________________________________________; 2054 ; 2055////////////////////////////////////////////////////////////////////////////////; 2056/// Minimization function for H1s using a Chisquare method.; 2057 ; 2058void H1FitChisquareFumili(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag); 2059{; 2060 TFumili *hFitter = (TFumili*)TVirtualFitter::GetFitter();; 2061 hFitter->FitChisquare(npar, gin, f, u, flag);; 2062}; 2063 ; 2064////////////////////////////////////////////////////////////////////////////////; 2065/// Minimization function for H1s using a Likelihood method.; 2066/// Basically, it forms the likelihood by determining the Poisson; 2067/// probability that given a number of entries in a particular bin,; 2068/// the fit would predict it's value. This is then done for each bin,; 2069/// and the sum of the logs is taken as the likelihood.; 2070/// PDF: P=exp(-f(x_i))/[F_i]!*(f(x_i))^[F_i]; 2071/// where F_i - experimental value, f(x_i) - expected theoretical value; 2072/// [F_i] - integer part of F_i.; 2073/// drawback is that if F_i>Int_t - GetSumLog will fail; 2074/// for big F_i is faster to use Euler's Gamma-function; 2075 ; 2076void H1FitLikelihoodFumili(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag); 2077{; 2078 ; 2079 TFumili *hFitter = (TFumili*)TVirtualFitter::GetFitter();; 2080 hFitter->FitLikelihood(npar, gin, f, u, flag);; 2081}; 2082 ; 2083////////////////////////////////////////////////////////////////////////////////; 2084/// Minimization function for Graphs using a Chisquare method.; 2085/// In case of a TGraphErrors object, ex, the error along x, is projected; 2086/// along the y-direction by calculat",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:3738,Testability,log,logarithm,3738,"72 ; 73Then the equations for parameter increments are; 74\f[\left(\partial\chi^2\over\partial\theta_i\right)_{\vec\theta={\vec\theta}^0}; 75+\sum_k Z_{ik}\cdot(\theta_k-\theta^0_k) = 0,; 76\qquad i=1\ldots m\tag{6}; 77\f]; 78 ; 79Remarkable feature of algorithm is the technique for step; 80restriction. For an initial value of parameter \f${\vec\theta}^0\f$ a; 81parallelepiped \f$P_0\f$ is built with the center at \f${\vec\theta}^0\f$ and; 82axes parallel to coordinate axes \f$\theta_i\f$. The lengths of; 83parallelepiped sides along i-th axis is \f$2b_i\f$, where \f$b_i\f$ is such a; 84value that the functions \f$f_j(\vec\theta)\f$ are quasi-linear all over; 85the parallelepiped.; 86 ; 87FUMILI takes into account simple linear inequalities in the form:; 88\f[; 89\theta_i^{\rm min}\le\theta_i\le\theta^{\rm max}_i\tag{7}; 90\f]; 91 ; 92They form parallelepiped \f$P\f$ (\f$P_0\f$ may be deformed by \f$P\f$).; 93Very similar step formulae are used in FUMILI for negative logarithm; 94of the likelihood function with the same idea - linearization of; 95function argument.; 96 ; 97*/; 98 ; 99 ; 100#include ""TFumili.h""; 101 ; 102#include <iostream>; 103#include ""TGraphAsymmErrors.h""; 104#include ""TF1.h""; 105#include ""TF2.h""; 106#include ""TF3.h""; 107#include ""TH1.h""; 108#include ""TMath.h""; 109#include ""TROOT.h""; 110#include ""TList.h""; 111#include ""TVirtualFitter.h""; 112 ; 113 ; 114extern void H1FitChisquareFumili(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag);; 115extern void H1FitLikelihoodFumili(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag);; 116extern void GraphFitChisquareFumili(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag);; 117 ; 118 ; 119ClassImp(TFumili);; 120 ; 121TFumili *gFumili=nullptr;; 122// Machine dependent values fiXME!!; 123// But don't set min=max=0 if param is unlimited; 124static const Double_t gMAXDOUBLE=1e300;; 125static const Double_t gMINDOUBLE=-1e300;; 126 ; 127///////////////////////////////",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:27322,Testability,log,log,27322,"92 eminus=-eplus;; 893 return 0;; 894}; 895 ; 896////////////////////////////////////////////////////////////////////////////////; 897/// Return global fit parameters; 898/// - amin : chisquare; 899/// - edm : estimated distance to minimum; 900/// - errdef; 901/// - nvpar : number of variable parameters; 902/// - nparx : total number of parameters; 903 ; 904Int_t TFumili::GetStats(Double_t &amin, Double_t &edm, Double_t &errdef, Int_t &nvpar, Int_t &nparx) const; 905{; 906 amin = 2*fS;; 907 edm = fGT; //; 908 errdef = 0; // ??; 909 nparx = fNpar;; 910 nvpar = 0;; 911 for(Int_t ii=0; ii<fNpar; ii++) {; 912 if(fPL0[ii]>0.) nvpar++;; 913 }; 914 return 0;; 915}; 916 ; 917////////////////////////////////////////////////////////////////////////////////; 918/// Return Sum(log(i) i=0,n; 919/// used by log-likelihood fits; 920 ; 921Double_t TFumili::GetSumLog(Int_t n); 922{; 923 if (n < 0) return 0;; 924 if (n > fNlog) {; 925 if (fSumLog) delete [] fSumLog;; 926 fNlog = 2*n+1000;; 927 fSumLog = new Double_t[fNlog+1];; 928 Double_t fobs = 0;; 929 for (Int_t j=0;j<=fNlog;j++) {; 930 if (j > 1) fobs += TMath::Log(j);; 931 fSumLog[j] = fobs;; 932 }; 933 }; 934 if (fSumLog) return fSumLog[n];; 935 return 0;; 936}; 937 ; 938////////////////////////////////////////////////////////////////////////////////; 939/// Inverts packed diagonal matrix Z by square-root method.; 940/// Matrix elements corresponding to; 941/// fix parameters are removed.; 942///; 943/// - n: number of variable parameters; 944 ; 945void TFumili::InvertZ(Int_t n); 946{; 947 static Double_t am = 3.4e138;; 948 static Double_t rp = 5.0e-14;; 949 Double_t ap, aps, c, d;; 950 Double_t *r_1=fR;; 951 Double_t *pl_1=fPL;; 952 Double_t *z_1=fZ;; 953 Int_t i, k, l, ii, ki, li, kk, ni, ll, nk, nl, ir, lk;; 954 if (n < 1) {; 955 return;; 956 }; 957 --pl_1;; 958 --r_1;; 959 --z_1;; 960 aps = am / n;; 961 aps = sqrt(aps);; 962 ap = 1.0e0 / (aps * aps);; 963 ir = 0;; 964 for (i = 1; i <= n; ++i) {; 965 L1:; 966 ++ir;; 967 if (",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:27351,Testability,log,log-likelihood,27351,"92 eminus=-eplus;; 893 return 0;; 894}; 895 ; 896////////////////////////////////////////////////////////////////////////////////; 897/// Return global fit parameters; 898/// - amin : chisquare; 899/// - edm : estimated distance to minimum; 900/// - errdef; 901/// - nvpar : number of variable parameters; 902/// - nparx : total number of parameters; 903 ; 904Int_t TFumili::GetStats(Double_t &amin, Double_t &edm, Double_t &errdef, Int_t &nvpar, Int_t &nparx) const; 905{; 906 amin = 2*fS;; 907 edm = fGT; //; 908 errdef = 0; // ??; 909 nparx = fNpar;; 910 nvpar = 0;; 911 for(Int_t ii=0; ii<fNpar; ii++) {; 912 if(fPL0[ii]>0.) nvpar++;; 913 }; 914 return 0;; 915}; 916 ; 917////////////////////////////////////////////////////////////////////////////////; 918/// Return Sum(log(i) i=0,n; 919/// used by log-likelihood fits; 920 ; 921Double_t TFumili::GetSumLog(Int_t n); 922{; 923 if (n < 0) return 0;; 924 if (n > fNlog) {; 925 if (fSumLog) delete [] fSumLog;; 926 fNlog = 2*n+1000;; 927 fSumLog = new Double_t[fNlog+1];; 928 Double_t fobs = 0;; 929 for (Int_t j=0;j<=fNlog;j++) {; 930 if (j > 1) fobs += TMath::Log(j);; 931 fSumLog[j] = fobs;; 932 }; 933 }; 934 if (fSumLog) return fSumLog[n];; 935 return 0;; 936}; 937 ; 938////////////////////////////////////////////////////////////////////////////////; 939/// Inverts packed diagonal matrix Z by square-root method.; 940/// Matrix elements corresponding to; 941/// fix parameters are removed.; 942///; 943/// - n: number of variable parameters; 944 ; 945void TFumili::InvertZ(Int_t n); 946{; 947 static Double_t am = 3.4e138;; 948 static Double_t rp = 5.0e-14;; 949 Double_t ap, aps, c, d;; 950 Double_t *r_1=fR;; 951 Double_t *pl_1=fPL;; 952 Double_t *z_1=fZ;; 953 Int_t i, k, l, ii, ki, li, kk, ni, ll, nk, nl, ir, lk;; 954 if (n < 1) {; 955 return;; 956 }; 957 --pl_1;; 958 --r_1;; 959 --z_1;; 960 aps = am / n;; 961 aps = sqrt(aps);; 962 ap = 1.0e0 / (aps * aps);; 963 ir = 0;; 964 for (i = 1; i <= n; ++i) {; 965 L1:; 966 ++ir;; 967 if (",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:46360,Testability,log,log-likelihood,46360,"////////////////////////////////////////////////////////////////////; 1594/// Sets pointer to data array provided by user.; 1595/// Necessary if SetFCN is not called.; 1596///; 1597/// - numpoints: number of experimental points; 1598/// - vecsize: size of data point vector + 2; 1599/// (for N-dimensional fit vecsize=N+2); 1600/// - exdata: data array with following format; 1601///; 1602/// - exdata[0] = ExpValue_0 - experimental data value number 0; 1603/// - exdata[1] = ExpSigma_0 - error of value number 0; 1604/// - exdata[2] = X_0[0]; 1605/// - exdata[3] = X_0[1]; 1606///; 1607/// - exdata[vecsize-1] = X_0[vecsize-3]; 1608/// - exdata[vecsize] = ExpValue_1; 1609/// - exdata[vecsize+1] = ExpSigma_1; 1610/// - exdata[vecsize+2] = X_1[0]; 1611///; 1612/// - exdata[vecsize*(numpoints-1)] = ExpValue_(numpoints-1); 1613///; 1614/// - exdata[vecsize*numpoints-1] = X_(numpoints-1)[vecsize-3]; 1615 ; 1616void TFumili::SetData(Double_t *exdata,Int_t numpoints,Int_t vecsize){; 1617 if(exdata){; 1618 fNED1 = numpoints;; 1619 fNED2 = vecsize;; 1620 fEXDA = exdata;; 1621 }; 1622}; 1623 ; 1624 ; 1625////////////////////////////////////////////////////////////////////////////////; 1626/// ret fit method (chisquare or log-likelihood); 1627 ; 1628void TFumili::SetFitMethod(const char *name); 1629{; 1630 if (!strcmp(name,""H1FitChisquare"")) SetFCN(H1FitChisquareFumili);; 1631 if (!strcmp(name,""H1FitLikelihood"")) SetFCN(H1FitLikelihoodFumili);; 1632 if (!strcmp(name,""GraphFitChisquare"")) SetFCN(GraphFitChisquareFumili);; 1633}; 1634 ; 1635////////////////////////////////////////////////////////////////////////////////; 1636/// Sets for parameter number ipar initial parameter value,; 1637/// name parname, initial error verr and limits vlow and vhigh; 1638/// - If vlow = vhigh but not equal to zero, parameter will be fixed.; 1639/// - If vlow = vhigh = 0, parameter is released and its limits are discarded; 1640 ; 1641Int_t TFumili::SetParameter(Int_t ipar,const char *parname,Double_t va",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:48607,Testability,log,log,48607,"////////////////////////////////////////////////////; 1667/// Evaluates objective function ( chi-square ), gradients and; 1668/// Z-matrix using data provided by user via TFumili::SetData; 1669 ; 1670Int_t TFumili::SGZ(); 1671{; 1672 fS = 0.;; 1673 Int_t i,j,l,k2=1,k1,ki=0;; 1674 Double_t *x = new Double_t[fNED2];; 1675 Double_t *df = new Double_t[fNpar];; 1676 Int_t nx = fNED2-2;; 1677 for (l=0;l<fNED1;l++) { // cycle on all exp. points; 1678 k1 = k2;; 1679 if (fLogLike) {; 1680 fNumericDerivatives = kTRUE;; 1681 nx = fNED2;; 1682 k1 -= 2;; 1683 }; 1684 ; 1685 for (i=0;i<nx;i++){; 1686 ki += 1+i;; 1687 x[i] = fEXDA[ki];; 1688 }; 1689 // Double_t y = ARITHM(df,x);; 1690 Double_t y = EvalTFN(df,x);; 1691 if(fNumericDerivatives) Derivatives(df,x);; 1692 Double_t sig=1.;; 1693 if(fLogLike) { // Likelihood method; 1694 if(y>0.) {; 1695 fS = fS - log(y);; 1696 y = -y;; 1697 sig= y;; 1698 } else { //; 1699 delete [] x;; 1700 delete [] df;; 1701 fS = 1e10;; 1702 return -1; // indflg[0] = 1;; 1703 }; 1704 } else { // Chi2 method; 1705 sig = fEXDA[k2]; // sigma of experimental point; 1706 y = y - fEXDA[k1-1]; // f(x_i) - F_i; 1707 fS = fS + (y*y/(sig*sig))*.5; // simple chi2/2; 1708 }; 1709 Int_t n = 0;; 1710 for (i=0;i<fNpar;i++) {; 1711 if (fPL0[i]>0){; 1712 df[n] = df[i]/sig; // left only non-fixed param derivatives div by Sig; 1713 fGr[i] += df[n]*(y/sig);; 1714 n++;; 1715 }; 1716 }; 1717 l = 0;; 1718 for (i=0;i<n;i++); 1719 for (j=0;j<=i;j++); 1720 fZ[l++] += df[i]*df[j];; 1721 k2 += fNED2;; 1722 }; 1723 ; 1724 delete[] df;; 1725 delete[] x;; 1726 return 1;; 1727}; 1728 ; 1729 ; 1730////////////////////////////////////////////////////////////////////////////////; 1731/// Minimization function for H1s using a Chisquare method.; 1732/// Default method (function evaluated at center of bin); 1733/// for each point the cache contains the following info; 1734/// - 1D : bc,e,xc (bin content, error, x of center of bin); 1735/// - 2D : bc,e,xc,yc; 1736/// - 3D : bc,e,xc,yc,zc; 17",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:54063,Testability,log,logs,54063," if (TF1::RejectedPoint()) {cache += fPointSize; continue;}; 1845 eu = cache[1];; 1846 Derivatives(df,x);; 1847 Int_t n = 0;; 1848 fsum = (fu-cu)/eu;; 1849 if (flag!=1) {; 1850 for (j=0;j<npar;j++) {; 1851 if (pl0[j]>0){; 1852 df[n] = df[j]/eu;; 1853 // left only non-fixed param derivatives / by Sigma; 1854 gin[j] += df[n]*fsum;; 1855 n++;; 1856 }; 1857 }; 1858 Int_t l = 0;; 1859 for (j=0;j<n;j++); 1860 for (Int_t k=0;k<=j;k++); 1861 zik[l++] += df[j]*df[k];; 1862 }; 1863 f += .5*fsum*fsum;; 1864 npfit++;; 1865 cache += fPointSize;; 1866 }; 1867 f1->SetNumberFitPoints(npfit);; 1868 delete[] df;; 1869}; 1870 ; 1871////////////////////////////////////////////////////////////////////////////////; 1872/// Minimization function for H1s using a Likelihood method.; 1873/// Basically, it forms the likelihood by determining the Poisson; 1874/// probability that given a number of entries in a particular bin,; 1875/// the fit would predict it's value. This is then done for each bin,; 1876/// and the sum of the logs is taken as the likelihood.; 1877///; 1878/// Default method (function evaluated at center of bin); 1879/// for each point the cache contains the following info; 1880/// - 1D : bc,e,xc (bin content, error, x of center of bin); 1881/// - 2D : bc,e,xc,yc; 1882/// - 3D : bc,e,xc,yc,zc; 1883 ; 1884void TFumili::FitLikelihood(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag); 1885{; 1886 Foption_t fitOption = GetFitOption();; 1887 if (fitOption.Integral) {; 1888 FitLikelihoodI(npar,gin,f,u,flag);; 1889 return;; 1890 }; 1891 Double_t cu,fu,fobs,fsub;; 1892 Double_t dersum[100];; 1893 Double_t x[3];; 1894 Int_t icu;; 1895 ; 1896 TH1 *hfit = (TH1*)GetObjectFit();; 1897 TF1 *f1 = (TF1*)GetUserFunc();; 1898 Int_t nd = hfit->GetDimension();; 1899 Int_t j;; 1900 Double_t *zik = GetZ();; 1901 Double_t *pl0 = GetPL0();; 1902 ; 1903 npar = f1->GetNpar();; 1904 SetParNumber(npar);; 1905 if(flag == 9) return;; 1906 Double_t *df=new Double_t[npar];; 1907 if (flag == 2)",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:56119,Testability,log,log-likelihood,56119,"itArgs(x,u);; 1909 f = 0;; 1910 ; 1911 Int_t npfit = 0;; 1912 Double_t *cache = fCache;; 1913 for (Int_t i=0;i<fNpoints;i++) {; 1914 if (nd > 2) x[2] = cache[4];; 1915 if (nd > 1) x[1] = cache[3];; 1916 x[0] = cache[2];; 1917 cu = cache[0];; 1918 TF1::RejectPoint(kFALSE);; 1919 fu = f1->EvalPar(x,u);; 1920 if (TF1::RejectedPoint()) {cache += fPointSize; continue;}; 1921 if (flag == 2) {; 1922 for (j=0;j<npar;j++) {; 1923 dersum[j] += 1; //should be the derivative; 1924 //grad[j] += dersum[j]*(fu-cu)/eu; dersum[j] = 0;; 1925 }; 1926 }; 1927 if (fu < 1.e-9) fu = 1.e-9;; 1928 icu = Int_t(cu);; 1929 fsub = -fu +icu*TMath::Log(fu);; 1930 fobs = GetSumLog(icu);; 1931 fsub -= fobs;; 1932 Derivatives(df,x);; 1933 int n=0;; 1934 // Here we need gradients of Log likelihood function; 1935 //; 1936 for (j=0;j<npar;j++) {; 1937 if (pl0[j]>0){; 1938 df[n] = df[j]*(icu/fu-1);; 1939 gin[j] -= df[n];; 1940 n++;; 1941 }; 1942 }; 1943 Int_t l = 0;; 1944 // Z-matrix here - production of first derivatives; 1945 // of log-likelihood function; 1946 for (j=0;j<n;j++); 1947 for (Int_t k=0;k<=j;k++); 1948 zik[l++] += df[j]*df[k];; 1949 ; 1950 f -= fsub;; 1951 npfit++;; 1952 cache += fPointSize;; 1953 }; 1954 f *= 2;; 1955 f1->SetNumberFitPoints(npfit);; 1956 delete[] df;; 1957}; 1958 ; 1959////////////////////////////////////////////////////////////////////////////////; 1960/// Minimization function for H1s using a Likelihood method.; 1961/// Basically, it forms the likelihood by determining the Poisson; 1962/// probability that given a number of entries in a particular bin,; 1963/// the fit would predict it's value. This is then done for each bin,; 1964/// and the sum of the logs is taken as the likelihood.; 1965///; 1966/// The ""I""ntegral method is used; 1967/// for each point the cache contains the following info; 1968/// - 1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); 1969/// - 2D : bc,e,xc,xw,yc,yw; 1970/// - 3D : bc,e,xc,xw,yc,yw,zc,zw; 1971 ; 1972void T",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:56786,Testability,log,logs,56786," 1931 fsub -= fobs;; 1932 Derivatives(df,x);; 1933 int n=0;; 1934 // Here we need gradients of Log likelihood function; 1935 //; 1936 for (j=0;j<npar;j++) {; 1937 if (pl0[j]>0){; 1938 df[n] = df[j]*(icu/fu-1);; 1939 gin[j] -= df[n];; 1940 n++;; 1941 }; 1942 }; 1943 Int_t l = 0;; 1944 // Z-matrix here - production of first derivatives; 1945 // of log-likelihood function; 1946 for (j=0;j<n;j++); 1947 for (Int_t k=0;k<=j;k++); 1948 zik[l++] += df[j]*df[k];; 1949 ; 1950 f -= fsub;; 1951 npfit++;; 1952 cache += fPointSize;; 1953 }; 1954 f *= 2;; 1955 f1->SetNumberFitPoints(npfit);; 1956 delete[] df;; 1957}; 1958 ; 1959////////////////////////////////////////////////////////////////////////////////; 1960/// Minimization function for H1s using a Likelihood method.; 1961/// Basically, it forms the likelihood by determining the Poisson; 1962/// probability that given a number of entries in a particular bin,; 1963/// the fit would predict it's value. This is then done for each bin,; 1964/// and the sum of the logs is taken as the likelihood.; 1965///; 1966/// The ""I""ntegral method is used; 1967/// for each point the cache contains the following info; 1968/// - 1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); 1969/// - 2D : bc,e,xc,xw,yc,yw; 1970/// - 3D : bc,e,xc,xw,yc,yw,zc,zw; 1971 ; 1972void TFumili::FitLikelihoodI(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag); 1973{; 1974 Double_t cu,fu,fobs,fsub;; 1975 Double_t dersum[100];; 1976 Double_t x[3];; 1977 Int_t icu;; 1978 ; 1979 TH1 *hfit = (TH1*)GetObjectFit();; 1980 TF1 *f1 = (TF1*)GetUserFunc();; 1981 Int_t nd = hfit->GetDimension();; 1982 Int_t j;; 1983 Double_t *zik = GetZ();; 1984 Double_t *pl0 = GetPL0();; 1985 ; 1986 Double_t *df=new Double_t[npar];; 1987 ; 1988 npar = f1->GetNpar();; 1989 SetParNumber(npar);; 1990 if(flag == 9) {delete [] df; return;}; 1991 if (flag == 2) for (j=0;j<npar;j++) dersum[j] = gin[j] = 0;; 1992 f1->InitArgs(x,u);; 1993 f = 0;; 1994 ; 1995 Int",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:59223,Testability,log,log-likelihood,59223,">Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5],cache[6] - 0.5*cache[7],cache[6] + 0.5*cache[7])/(cache[3]*cache[5]*cache[7]);; 2009 }; 2010 if (TF1::RejectedPoint()) {cache += fPointSize; continue;}; 2011 if (flag == 2) {; 2012 for (j=0;j<npar;j++) {; 2013 dersum[j] += 1; //should be the derivative; 2014 //grad[j] += dersum[j]*(fu-cu)/eu; dersum[j] = 0;; 2015 }; 2016 }; 2017 if (fu < 1.e-9) fu = 1.e-9;; 2018 icu = Int_t(cu);; 2019 fsub = -fu +icu*TMath::Log(fu);; 2020 fobs = GetSumLog(icu);; 2021 fsub -= fobs;; 2022 Derivatives(df,x);; 2023 int n=0;; 2024 // Here we need gradients of Log likelihood function; 2025 //; 2026 for (j=0;j<npar;j++) {; 2027 if (pl0[j]>0){; 2028 df[n] = df[j]*(icu/fu-1);; 2029 gin[j] -= df[n];; 2030 n++;; 2031 }; 2032 }; 2033 Int_t l = 0;; 2034 // Z-matrix here - production of first derivatives; 2035 // of log-likelihood function; 2036 for (j=0;j<n;j++); 2037 for (Int_t k=0;k<=j;k++); 2038 zik[l++] += df[j]*df[k];; 2039 ; 2040 f -= fsub;; 2041 npfit++;; 2042 cache += fPointSize;; 2043 }; 2044 f *= 2;; 2045 f1->SetNumberFitPoints(npfit);; 2046 delete[] df;; 2047}; 2048 ; 2049 ; 2050//______________________________________________________________________________; 2051//; 2052// STATIC functions; 2053//______________________________________________________________________________; 2054 ; 2055////////////////////////////////////////////////////////////////////////////////; 2056/// Minimization function for H1s using a Chisquare method.; 2057 ; 2058void H1FitChisquareFumili(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag); 2059{; 2060 TFumili *hFitter = (TFumili*)TVirtualFitter::GetFitter();; 2061 hFitter->FitChisquare(npar, gin, f, u, flag);; 2062}; 2063 ; 2064////////////////////////////////////////////////////////////////////////////////; 2065/// Minimization function for H1s using a Likelihood method.; 2066/// Basically, it forms the likelihood by determining the Poi",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:60501,Testability,log,logs,60501,"048 ; 2049 ; 2050//______________________________________________________________________________; 2051//; 2052// STATIC functions; 2053//______________________________________________________________________________; 2054 ; 2055////////////////////////////////////////////////////////////////////////////////; 2056/// Minimization function for H1s using a Chisquare method.; 2057 ; 2058void H1FitChisquareFumili(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag); 2059{; 2060 TFumili *hFitter = (TFumili*)TVirtualFitter::GetFitter();; 2061 hFitter->FitChisquare(npar, gin, f, u, flag);; 2062}; 2063 ; 2064////////////////////////////////////////////////////////////////////////////////; 2065/// Minimization function for H1s using a Likelihood method.; 2066/// Basically, it forms the likelihood by determining the Poisson; 2067/// probability that given a number of entries in a particular bin,; 2068/// the fit would predict it's value. This is then done for each bin,; 2069/// and the sum of the logs is taken as the likelihood.; 2070/// PDF: P=exp(-f(x_i))/[F_i]!*(f(x_i))^[F_i]; 2071/// where F_i - experimental value, f(x_i) - expected theoretical value; 2072/// [F_i] - integer part of F_i.; 2073/// drawback is that if F_i>Int_t - GetSumLog will fail; 2074/// for big F_i is faster to use Euler's Gamma-function; 2075 ; 2076void H1FitLikelihoodFumili(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag); 2077{; 2078 ; 2079 TFumili *hFitter = (TFumili*)TVirtualFitter::GetFitter();; 2080 hFitter->FitLikelihood(npar, gin, f, u, flag);; 2081}; 2082 ; 2083////////////////////////////////////////////////////////////////////////////////; 2084/// Minimization function for Graphs using a Chisquare method.; 2085/// In case of a TGraphErrors object, ex, the error along x, is projected; 2086/// along the y-direction by calculating the function at the points x-exlow and; 2087/// x+exhigh.; 2088///; 2089/// The chisquare is computed as the sum of the quantity below a",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:67468,Testability,test,tested,67468,"pyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char cnameDefinition TGWin32VirtualXProxy.cxx:230; valueOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void valueDefinition TGWin32VirtualXProxy.cxx:142; namechar name[80]Definition TGX11.cxx:110; TGraphAsymmErrors.h; TH1.h; hi#define hiDefinition THbookFile.cxx:128; TList.h; TMath.h; TROOT.h; gROOT#define gROOTDefinition TROOT.h:406; Formchar * Form(const char *fmt,...)Formats a string in a circular formatting buffer.Definition TString.cxx:2489; Printfvoid Printf(const char *fmt,...)Formats a string in a circular formatting buffer and prints the string.Definition TString.cxx:2503; TVirtualFitter.h; TF11-Dim function classDefinition TF1.h:233; TF1::RejectPointstatic void RejectPoint(Bool_t reject=kTRUE)Static function to set the global flag to reject points the fgRejectPoint global flag is tested by al...Definition TF1.cxx:3683; TF1::Derivativevirtual Double_t Derivative(Double_t x, Double_t *params=nullptr, Double_t epsilon=0.001) constReturns the first derivative of the function at point x, computed by Richardson's extrapolation metho...Definition TF1.cxx:1113; TF1::GetNparvirtual Int_t GetNpar() constDefinition TF1.h:509; TF1::Integralvirtual Double_t Integral(Double_t a, Double_t b, Double_t epsrel=1.e-12)IntegralOneDim or analytical integral.Definition TF1.cxx:2531; TF1::SetNumberFitPointsvirtual void SetNumberFitPoints(Int_t npfits)Definition TF1.h:652; TF1::InitArgsvirtual void InitArgs(const Double_t *x, const Double_t *params)Initialize parameters addresses.Definition TF1.cxx:2482; TF1::EvalParvirtual Double_t EvalPar(const Double_t *x, const Double_t *params=nullptr)Evaluate function with given coordinates and parameters.Definition TF1.cxx:1468; TF1::RejectedPointstatic Bool_t RejectedPoint(",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:73675,Testability,log,log-likelihood,73675,"efinition TFumili.h:13; TFumili::SetParNumbervoid SetParNumber(Int_t ParNum)Definition TFumili.cxx:168; TFumili::SetDatavoid SetData(Double_t *, Int_t, Int_t)Sets pointer to data array provided by user.Definition TFumili.cxx:1616; TFumili::fINDFLGInt_t fINDFLG[5]internal flags;Definition TFumili.h:25; TFumili::EvalTFNDouble_t EvalTFN(Double_t *, Double_t *)Evaluate theoretical function.Definition TFumili.cxx:362; TFumili::GetZDouble_t * GetZ() constDefinition TFumili.h:102; TFumili::fParamErrorDouble_t * fParamError[fMaxParam] Parameter errorsDefinition TFumili.h:39; TFumili::ChisquareDouble_t Chisquare(Int_t npar, Double_t *params) const overridereturn a chisquare equivalentDefinition TFumili.cxx:227; TFumili::fENDFLGInt_t fENDFLGEnd flag of fit.Definition TFumili.h:24; TFumili::fRDouble_t * fR[fMaxParam] Correlation factorsDefinition TFumili.h:52; TFumili::fDADouble_t * fDA[fMaxParam] Parameter stepDefinition TFumili.h:49; TFumili::SetFitMethodvoid SetFitMethod(const char *name) overrideret fit method (chisquare or log-likelihood)Definition TFumili.cxx:1628; TFumili::fNstepDecInt_t fNstepDecfNstepDec - maximum number of step decreasing counterDefinition TFumili.h:20; TFumili::GetErrorsInt_t GetErrors(Int_t ipar, Double_t &eplus, Double_t &eminus, Double_t &eparab, Double_t &globcc) const overrideReturn errors after MINOs not implemented.Definition TFumili.cxx:882; TFumili::fZ0Double_t * fZ0[fMaxParam2] Matrix of approximate second derivatives of objective function This matrix is diagonal a...Definition TFumili.h:34; TFumili::fPL0Double_t * fPL0[fMaxParam] Step initial boundsDefinition TFumili.h:45; TFumili::fADouble_t * fA[fMaxParam] Fit parameter arrayDefinition TFumili.h:44; TFumili::fAKAPPADouble_t fAKAPPADefinition TFumili.h:60; TFumili::MinimizeInt_t Minimize()Main minimization procedure.Definition TFumili.cxx:1085; TFumili::fNmaxIterInt_t fNmaxIterfNmaxIter - maximum number of iterationsDefinition TFumili.h:22; TFumili::TFumiliTFumili(Int_t maxpar=25)Definit",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:76973,Testability,log,log,76973,"ili.h:38; TFumili::fGTDouble_t fGTExpected function change in next iteration.Definition TFumili.h:61; TFumili::SetParameterInt_t SetParameter(Int_t ipar, const char *parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh) overrideSets for parameter number ipar initial parameter value, name parname, initial error verr and limits v...Definition TFumili.cxx:1641; TFumili::fCwordTString fCwordCommand string.Definition TFumili.h:63; TFumili::FitLikelihoodIvirtual void FitLikelihoodI(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag)Minimization function for H1s using a Likelihood method.Definition TFumili.cxx:1972; TFumili::fRPDouble_t fRPPrecision of fit ( machine zero on CDC 6000) quite old yeh?Definition TFumili.h:59; TFumili::fCmParDouble_t * fCmPar[fMaxParam] parameters of commandsDefinition TFumili.h:55; TFumili::fDFDouble_t * fDF[fMaxParam] First derivatives of theoretical functionDefinition TFumili.h:54; TFumili::GetSumLogDouble_t GetSumLog(Int_t) overrideReturn Sum(log(i) i=0,n used by log-likelihood fits.Definition TFumili.cxx:921; TFumili::fSumLogDouble_t * fSumLog[fNlog]Definition TFumili.h:40; TFumili::fAMXDouble_t * fAMX[fMaxParam] Maximum param valueDefinition TFumili.h:50; TFumili::fDEBUGBool_t fDEBUGdebug infoDefinition TFumili.h:30; TFumili::fNlimMulInt_t fNlimMulfNlimMul - after fNlimMul successful iterations permits four-fold increasing of fPLDefinition TFumili.h:21; TFumili::fGRADBool_t fGRADuser calculated gradientsDefinition TFumili.h:28; TFumili::InvertZvoid InvertZ(Int_t)Inverts packed diagonal matrix Z by square-root method.Definition TFumili.cxx:945; TGraphErrors::GetErrorYDouble_t GetErrorY(Int_t bin) const overrideIt returns the error along Y at point i.Definition TGraphErrors.cxx:623; TGraphErrors::GetErrorXhighDouble_t GetErrorXhigh(Int_t bin) const overrideIt returns the error along X at point i.Definition TGraphErrors.cxx:635; TGraphErrors::GetErrorXlowDouble_t GetErrorXlow(Int_t bin) const overrideIt returns",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:76994,Testability,log,log-likelihood,76994,"ili.h:38; TFumili::fGTDouble_t fGTExpected function change in next iteration.Definition TFumili.h:61; TFumili::SetParameterInt_t SetParameter(Int_t ipar, const char *parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh) overrideSets for parameter number ipar initial parameter value, name parname, initial error verr and limits v...Definition TFumili.cxx:1641; TFumili::fCwordTString fCwordCommand string.Definition TFumili.h:63; TFumili::FitLikelihoodIvirtual void FitLikelihoodI(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag)Minimization function for H1s using a Likelihood method.Definition TFumili.cxx:1972; TFumili::fRPDouble_t fRPPrecision of fit ( machine zero on CDC 6000) quite old yeh?Definition TFumili.h:59; TFumili::fCmParDouble_t * fCmPar[fMaxParam] parameters of commandsDefinition TFumili.h:55; TFumili::fDFDouble_t * fDF[fMaxParam] First derivatives of theoretical functionDefinition TFumili.h:54; TFumili::GetSumLogDouble_t GetSumLog(Int_t) overrideReturn Sum(log(i) i=0,n used by log-likelihood fits.Definition TFumili.cxx:921; TFumili::fSumLogDouble_t * fSumLog[fNlog]Definition TFumili.h:40; TFumili::fAMXDouble_t * fAMX[fMaxParam] Maximum param valueDefinition TFumili.h:50; TFumili::fDEBUGBool_t fDEBUGdebug infoDefinition TFumili.h:30; TFumili::fNlimMulInt_t fNlimMulfNlimMul - after fNlimMul successful iterations permits four-fold increasing of fPLDefinition TFumili.h:21; TFumili::fGRADBool_t fGRADuser calculated gradientsDefinition TFumili.h:28; TFumili::InvertZvoid InvertZ(Int_t)Inverts packed diagonal matrix Z by square-root method.Definition TFumili.cxx:945; TGraphErrors::GetErrorYDouble_t GetErrorY(Int_t bin) const overrideIt returns the error along Y at point i.Definition TGraphErrors.cxx:623; TGraphErrors::GetErrorXhighDouble_t GetErrorXhigh(Int_t bin) const overrideIt returns the error along X at point i.Definition TGraphErrors.cxx:635; TGraphErrors::GetErrorXlowDouble_t GetErrorXlow(Int_t bin) const overrideIt returns",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:80926,Testability,log,logarithm,80926,"cPointer to user theoretical function (a TF1*)Definition TVirtualFitter.h:44; TVirtualFitter::GetFitOptionvirtual Foption_t GetFitOption() constDefinition TVirtualFitter.h:73; TVirtualFitter::SetFCNvirtual void SetFCN(void(*fcn)(Int_t &, Double_t *, Double_t &f, Double_t *, Int_t))To set the address of the minimization objective function called by the native compiler (see function...Definition TVirtualFitter.cxx:267; TVirtualFitter::fCacheDouble_t * fCache[fCacheSize] Array of points data (fNpoints*fPointSize < fCacheSize words)Definition TVirtualFitter.h:42; TVirtualFitter::fFCNvoid(* fFCN)(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag)Definition TVirtualFitter.h:46; TVirtualFitter::GetFitterstatic TVirtualFitter * GetFitter()static: return the current FitterDefinition TVirtualFitter.cxx:209; TVirtualFitter::GetUserFuncvirtual TObject * GetUserFunc() constDefinition TVirtualFitter.h:84; TVirtualFitter::fNpointsInt_t fNpointsNumber of points to fit.Definition TVirtualFitter.h:39; bool; double; int; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; eyDouble_t ey[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; grTGraphErrors * grDefinition legend1.C:25; f1TF1 * f1Definition legend1.C:11; TMath::MaxShort_t Max(Short_t a, Short_t b)Returns the largest of a and b.Definition TMathBase.h:250; TMath::LogDouble_t Log(Double_t x)Returns the natural logarithm of x.Definition TMath.h:756; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123; Foption_tDefinition Foption.h:24; Foption_t::W1int W1Definition Foption.h:36; Foption_t::Integralint IntegralDefinition Foption.h:44; lTLine lDefinition textangle.C:4; t1auto * t1Definition textangle.C:20. mathfumilisrcTFumili.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:39 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:3480,Usability,simpl,simple,3480,"alue is:; 67\f[{\partial^2\chi^2\over\partial\theta_i\partial\theta_k}\approx; 68Z_{ik}=; 69\sum^n_{j=1}{1\over\sigma^2_j}{\partial f_j\over\theta_i}; 70{\partial f_j\over\theta_k}\tag{5}; 71\f]; 72 ; 73Then the equations for parameter increments are; 74\f[\left(\partial\chi^2\over\partial\theta_i\right)_{\vec\theta={\vec\theta}^0}; 75+\sum_k Z_{ik}\cdot(\theta_k-\theta^0_k) = 0,; 76\qquad i=1\ldots m\tag{6}; 77\f]; 78 ; 79Remarkable feature of algorithm is the technique for step; 80restriction. For an initial value of parameter \f${\vec\theta}^0\f$ a; 81parallelepiped \f$P_0\f$ is built with the center at \f${\vec\theta}^0\f$ and; 82axes parallel to coordinate axes \f$\theta_i\f$. The lengths of; 83parallelepiped sides along i-th axis is \f$2b_i\f$, where \f$b_i\f$ is such a; 84value that the functions \f$f_j(\vec\theta)\f$ are quasi-linear all over; 85the parallelepiped.; 86 ; 87FUMILI takes into account simple linear inequalities in the form:; 88\f[; 89\theta_i^{\rm min}\le\theta_i\le\theta^{\rm max}_i\tag{7}; 90\f]; 91 ; 92They form parallelepiped \f$P\f$ (\f$P_0\f$ may be deformed by \f$P\f$).; 93Very similar step formulae are used in FUMILI for negative logarithm; 94of the likelihood function with the same idea - linearization of; 95function argument.; 96 ; 97*/; 98 ; 99 ; 100#include ""TFumili.h""; 101 ; 102#include <iostream>; 103#include ""TGraphAsymmErrors.h""; 104#include ""TF1.h""; 105#include ""TF2.h""; 106#include ""TF3.h""; 107#include ""TH1.h""; 108#include ""TMath.h""; 109#include ""TROOT.h""; 110#include ""TList.h""; 111#include ""TVirtualFitter.h""; 112 ; 113 ; 114extern void H1FitChisquareFumili(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag);; 115extern void H1FitLikelihoodFumili(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag);; 116extern void GraphFitChisquareFumili(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag);; 117 ; 118 ; 119ClassImp(TFumili);; 120 ; 121TFumili *gFumili=nullptr;; 122// Machine dependent va",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:48926,Usability,simpl,simple,48926,"679 if (fLogLike) {; 1680 fNumericDerivatives = kTRUE;; 1681 nx = fNED2;; 1682 k1 -= 2;; 1683 }; 1684 ; 1685 for (i=0;i<nx;i++){; 1686 ki += 1+i;; 1687 x[i] = fEXDA[ki];; 1688 }; 1689 // Double_t y = ARITHM(df,x);; 1690 Double_t y = EvalTFN(df,x);; 1691 if(fNumericDerivatives) Derivatives(df,x);; 1692 Double_t sig=1.;; 1693 if(fLogLike) { // Likelihood method; 1694 if(y>0.) {; 1695 fS = fS - log(y);; 1696 y = -y;; 1697 sig= y;; 1698 } else { //; 1699 delete [] x;; 1700 delete [] df;; 1701 fS = 1e10;; 1702 return -1; // indflg[0] = 1;; 1703 }; 1704 } else { // Chi2 method; 1705 sig = fEXDA[k2]; // sigma of experimental point; 1706 y = y - fEXDA[k1-1]; // f(x_i) - F_i; 1707 fS = fS + (y*y/(sig*sig))*.5; // simple chi2/2; 1708 }; 1709 Int_t n = 0;; 1710 for (i=0;i<fNpar;i++) {; 1711 if (fPL0[i]>0){; 1712 df[n] = df[i]/sig; // left only non-fixed param derivatives div by Sig; 1713 fGr[i] += df[n]*(y/sig);; 1714 n++;; 1715 }; 1716 }; 1717 l = 0;; 1718 for (i=0;i<n;i++); 1719 for (j=0;j<=i;j++); 1720 fZ[l++] += df[i]*df[j];; 1721 k2 += fNED2;; 1722 }; 1723 ; 1724 delete[] df;; 1725 delete[] x;; 1726 return 1;; 1727}; 1728 ; 1729 ; 1730////////////////////////////////////////////////////////////////////////////////; 1731/// Minimization function for H1s using a Chisquare method.; 1732/// Default method (function evaluated at center of bin); 1733/// for each point the cache contains the following info; 1734/// - 1D : bc,e,xc (bin content, error, x of center of bin); 1735/// - 2D : bc,e,xc,yc; 1736/// - 3D : bc,e,xc,yc,zc; 1737 ; 1738void TFumili::FitChisquare(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag); 1739{; 1740 Foption_t fitOption = GetFitOption();; 1741 if (fitOption.Integral) {; 1742 FitChisquareI(npar,gin,f,u,flag);; 1743 return;; 1744 }; 1745 Double_t cu,eu,fu,fsum;; 1746 Double_t x[3];; 1747 Double_t *zik=nullptr;; 1748 Double_t *pl0=nullptr;; 1749 ; 1750 TH1 *hfit = (TH1*)GetObjectFit();; 1751 TF1 *f1 = (TF1*)GetUserFunc();; 1752 Int_t nd = h",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8cxx_source.html:62080,Usability,simpl,simple,62080,"//////////////////////////////; 2084/// Minimization function for Graphs using a Chisquare method.; 2085/// In case of a TGraphErrors object, ex, the error along x, is projected; 2086/// along the y-direction by calculating the function at the points x-exlow and; 2087/// x+exhigh.; 2088///; 2089/// The chisquare is computed as the sum of the quantity below at each point:; 2090///; 2091/// (y - f(x))**2; 2092/// -----------------------------------; 2093/// ey**2 + (0.5*(exl + exh)*f'(x))**2; 2094///; 2095/// where x and y are the point coordinates and f'(x) is the derivative of function f(x).; 2096/// This method to approximate the uncertainty in y because of the errors in x, is called; 2097/// ""effective variance"" method.; 2098/// The improvement, compared to the previously used method (f(x+ exhigh) - f(x-exlow))/2; 2099/// is of (error of x)**2 order.; 2100///; 2101/// NOTE:; 2102///; 2103/// 1. By using the ""effective variance"" method a simple linear regression; 2104/// becomes a non-linear case , which takes several iterations; 2105/// instead of 0 as in the linear case .; 2106///; 2107/// 2. The effective variance technique assumes that there is no correlation; 2108/// between the x and y coordinate .; 2109///; 2110/// In case the function lies below (above) the data point, ey is ey_low (ey_high).; 2111 ; 2112void GraphFitChisquareFumili(Int_t &npar, Double_t * gin, Double_t &f,; 2113 Double_t *u, Int_t flag); 2114{; 2115 Double_t cu,eu,exl,exh,ey,eux,fu,fsum;; 2116 Double_t x[1];; 2117 Int_t i, bin, npfits=0;; 2118 ; 2119 TFumili *grFitter = (TFumili*)TVirtualFitter::GetFitter();; 2120 TGraph *gr = (TGraph*)grFitter->GetObjectFit();; 2121 TF1 *f1 = (TF1*)grFitter->GetUserFunc();; 2122 Foption_t fitOption = grFitter->GetFitOption();; 2123 ; 2124 Int_t n = gr->GetN();; 2125 Double_t *gx = gr->GetX();; 2126 Double_t *gy = gr->GetY();; 2127 npar = f1->GetNpar();; 2128 ; 2129 grFitter->SetParNumber(npar);; 2130 ; 2131 if(flag == 9) return;; 2132 Double_t *zik = grFi",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
https://root.cern/doc/master/TFumili_8h_source.html:1707,Availability,error,errors,1707,"itter.h""; 8 ; 9class TF1;; 10 ; 11class TFumili : public TVirtualFitter {; 12private:; 13 Int_t fMaxParam; ///<; 14 Int_t fNlog; ///<; 15 Int_t fNfcn; ///< Number of FCN calls;; 16 Int_t fNED1; ///< Number of experimental vectors X=(x1,x2,...xK); 17 Int_t fNED2; ///< K - Length of vector X plus 2 (for chi2); 18 Int_t fNED12; ///< fNED1+fNED2; 19 Int_t fNpar; ///< fNpar - number of parameters; 20 Int_t fNstepDec; ///< fNstepDec - maximum number of step decreasing counter; 21 Int_t fNlimMul; ///< fNlimMul - after fNlimMul successful iterations permits four-fold increasing of fPL; 22 Int_t fNmaxIter; ///< fNmaxIter - maximum number of iterations; 23 Int_t fLastFixed; ///< Last fixed parameter number; 24 Int_t fENDFLG; ///< End flag of fit; 25 Int_t fINDFLG[5]; ///< internal flags;; 26 ; 27 ; 28 Bool_t fGRAD; ///< user calculated gradients; 29 Bool_t fWARN; ///< warnings; 30 Bool_t fDEBUG; ///< debug info; 31 Bool_t fLogLike; ///< LogLikelihood flag; 32 Bool_t fNumericDerivatives; ///<; 33 ; 34 Double_t *fZ0; ///< [fMaxParam2] Matrix of approximate second derivatives of objective function; 35 ///< This matrix is diagonal and always contain only variable parameter's; 36 ///< derivatives; 37 Double_t *fZ; ///< [fMaxParam2] Inverse fZ0 matrix - covariance matrix; 38 Double_t *fGr; ///< [fMaxParam] Gradients of objective function; 39 Double_t *fParamError; ///< [fMaxParam] Parameter errors; 40 Double_t *fSumLog; ///< [fNlog]; 41 Double_t *fEXDA; ///< [fNED12] experimental data poInt_ter; 42 ; 43 // don't calculate parameter errors - take them from fParamError array; 44 Double_t *fA; ///< [fMaxParam] Fit parameter array; 45 Double_t *fPL0; ///< [fMaxParam] Step initial bounds; 46 Double_t *fPL; ///< [fMaxParam] Limits for parameters step. If <0, then parameter is fixed; 47 ; 48 // Defines multidimensional parallelepiped with center in param. vector; 49 Double_t *fDA; ///< [fMaxParam] Parameter step; 50 Double_t *fAMX; ///< [fMaxParam] Maximum param value; 51 Double_t *fAMN; /",MatchSource.WIKI,doc/master/TFumili_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8h_source.html
https://root.cern/doc/master/TFumili_8h_source.html:1851,Availability,error,errors,1851,"itter.h""; 8 ; 9class TF1;; 10 ; 11class TFumili : public TVirtualFitter {; 12private:; 13 Int_t fMaxParam; ///<; 14 Int_t fNlog; ///<; 15 Int_t fNfcn; ///< Number of FCN calls;; 16 Int_t fNED1; ///< Number of experimental vectors X=(x1,x2,...xK); 17 Int_t fNED2; ///< K - Length of vector X plus 2 (for chi2); 18 Int_t fNED12; ///< fNED1+fNED2; 19 Int_t fNpar; ///< fNpar - number of parameters; 20 Int_t fNstepDec; ///< fNstepDec - maximum number of step decreasing counter; 21 Int_t fNlimMul; ///< fNlimMul - after fNlimMul successful iterations permits four-fold increasing of fPL; 22 Int_t fNmaxIter; ///< fNmaxIter - maximum number of iterations; 23 Int_t fLastFixed; ///< Last fixed parameter number; 24 Int_t fENDFLG; ///< End flag of fit; 25 Int_t fINDFLG[5]; ///< internal flags;; 26 ; 27 ; 28 Bool_t fGRAD; ///< user calculated gradients; 29 Bool_t fWARN; ///< warnings; 30 Bool_t fDEBUG; ///< debug info; 31 Bool_t fLogLike; ///< LogLikelihood flag; 32 Bool_t fNumericDerivatives; ///<; 33 ; 34 Double_t *fZ0; ///< [fMaxParam2] Matrix of approximate second derivatives of objective function; 35 ///< This matrix is diagonal and always contain only variable parameter's; 36 ///< derivatives; 37 Double_t *fZ; ///< [fMaxParam2] Inverse fZ0 matrix - covariance matrix; 38 Double_t *fGr; ///< [fMaxParam] Gradients of objective function; 39 Double_t *fParamError; ///< [fMaxParam] Parameter errors; 40 Double_t *fSumLog; ///< [fNlog]; 41 Double_t *fEXDA; ///< [fNED12] experimental data poInt_ter; 42 ; 43 // don't calculate parameter errors - take them from fParamError array; 44 Double_t *fA; ///< [fMaxParam] Fit parameter array; 45 Double_t *fPL0; ///< [fMaxParam] Step initial bounds; 46 Double_t *fPL; ///< [fMaxParam] Limits for parameters step. If <0, then parameter is fixed; 47 ; 48 // Defines multidimensional parallelepiped with center in param. vector; 49 Double_t *fDA; ///< [fMaxParam] Parameter step; 50 Double_t *fAMX; ///< [fMaxParam] Maximum param value; 51 Double_t *fAMN; /",MatchSource.WIKI,doc/master/TFumili_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8h_source.html
https://root.cern/doc/master/TFumili_8h_source.html:7190,Availability,error,error,7190,"iliR__EXTERN TFumili * gFumiliDefinition TFumili.h:117; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; valueOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void valueDefinition TGWin32VirtualXProxy.cxx:142; namechar name[80]Definition TGX11.cxx:110; TVirtualFitter.h; TF11-Dim function classDefinition TF1.h:233; TFumiliDefinition TFumili.h:11; TFumili::GetParameterDouble_t GetParameter(Int_t ipar) const overrideReturn current value of parameter ipar.Definition TFumili.cxx:835; TFumili::fWARNBool_t fWARNwarningsDefinition TFumili.h:29; TFumili::fNED12Int_t fNED12fNED1+fNED2Definition TFumili.h:18; TFumili::DeleteArraysvoid DeleteArrays()Deallocates memory. Called from destructor TFumili::~TFumili.Definition TFumili.cxx:261; TFumili::fNumericDerivativesBool_t fNumericDerivativesDefinition TFumili.h:32; TFumili::GetParErrorDouble_t GetParError(Int_t ipar) const overrideReturn error of parameter ipar.Definition TFumili.cxx:826; TFumili::IsFixedBool_t IsFixed(Int_t ipar) const overrideReturn kTRUE if parameter ipar is fixed, kFALSE otherwise)Definition TFumili.cxx:1060; TFumili::fNED2Int_t fNED2K - Length of vector X plus 2 (for chi2)Definition TFumili.h:17; TFumili::GetCovarianceMatrixElementDouble_t GetCovarianceMatrixElement(Int_t i, Int_t j) const overrideReturn element i,j from the covariance matrix.Definition TFumili.cxx:793; TFumili::ExecuteCommandInt_t ExecuteCommand(const char *command, Double_t *args, Int_t nargs) overrideExecute MINUIT commands.Definition TFumili.cxx:391; TFumili::fNparInt_t fNparfNpar - number of parametersDefinition TFumili.h:19; TFumili::PrintResultsvoid PrintResults(Int_t k, Double_t p) const overridePrints fit results.Definition TFumili.cxx:1483; TFumili::GetNumberFreeParametersInt_t GetNumberFreeParameters() const overrideReturn the number of free parameters.Definition TFumili.cxx:814; TFumili::Get",MatchSource.WIKI,doc/master/TFumili_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8h_source.html
https://root.cern/doc/master/TFumili_8h_source.html:11012,Availability,error,errorsDefinition,11012,"on TFumili.h:51; TFumili::fANamesTString * fANames[fMaxParam] Parameter namesDefinition TFumili.h:62; TFumili::GetPL0Double_t * GetPL0() constDefinition TFumili.h:95; TFumili::fPLDouble_t * fPL[fMaxParam] Limits for parameters step. If <0, then parameter is fixedDefinition TFumili.h:46; TFumili::EvalInt_t Eval(Int_t &npar, Double_t *grad, Double_t &fval, Double_t *par, Int_t flag)Evaluate the minimisation function.Definition TFumili.cxx:350; TFumili::fMaxParamInt_t fMaxParamDefinition TFumili.h:13; TFumili::SetParNumbervoid SetParNumber(Int_t ParNum)Definition TFumili.cxx:168; TFumili::SetDatavoid SetData(Double_t *, Int_t, Int_t)Sets pointer to data array provided by user.Definition TFumili.cxx:1616; TFumili::fINDFLGInt_t fINDFLG[5]internal flags;Definition TFumili.h:25; TFumili::EvalTFNDouble_t EvalTFN(Double_t *, Double_t *)Evaluate theoretical function.Definition TFumili.cxx:362; TFumili::GetZDouble_t * GetZ() constDefinition TFumili.h:102; TFumili::fParamErrorDouble_t * fParamError[fMaxParam] Parameter errorsDefinition TFumili.h:39; TFumili::ChisquareDouble_t Chisquare(Int_t npar, Double_t *params) const overridereturn a chisquare equivalentDefinition TFumili.cxx:227; TFumili::fENDFLGInt_t fENDFLGEnd flag of fit.Definition TFumili.h:24; TFumili::fRDouble_t * fR[fMaxParam] Correlation factorsDefinition TFumili.h:52; TFumili::fDADouble_t * fDA[fMaxParam] Parameter stepDefinition TFumili.h:49; TFumili::SetFitMethodvoid SetFitMethod(const char *name) overrideret fit method (chisquare or log-likelihood)Definition TFumili.cxx:1628; TFumili::fNstepDecInt_t fNstepDecfNstepDec - maximum number of step decreasing counterDefinition TFumili.h:20; TFumili::GetErrorsInt_t GetErrors(Int_t ipar, Double_t &eplus, Double_t &eminus, Double_t &eparab, Double_t &globcc) const overrideReturn errors after MINOs not implemented.Definition TFumili.cxx:882; TFumili::fZ0Double_t * fZ0[fMaxParam2] Matrix of approximate second derivatives of objective function This matrix is diagonal a...D",MatchSource.WIKI,doc/master/TFumili_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8h_source.html
https://root.cern/doc/master/TFumili_8h_source.html:11795,Availability,error,errors,11795," flags;Definition TFumili.h:25; TFumili::EvalTFNDouble_t EvalTFN(Double_t *, Double_t *)Evaluate theoretical function.Definition TFumili.cxx:362; TFumili::GetZDouble_t * GetZ() constDefinition TFumili.h:102; TFumili::fParamErrorDouble_t * fParamError[fMaxParam] Parameter errorsDefinition TFumili.h:39; TFumili::ChisquareDouble_t Chisquare(Int_t npar, Double_t *params) const overridereturn a chisquare equivalentDefinition TFumili.cxx:227; TFumili::fENDFLGInt_t fENDFLGEnd flag of fit.Definition TFumili.h:24; TFumili::fRDouble_t * fR[fMaxParam] Correlation factorsDefinition TFumili.h:52; TFumili::fDADouble_t * fDA[fMaxParam] Parameter stepDefinition TFumili.h:49; TFumili::SetFitMethodvoid SetFitMethod(const char *name) overrideret fit method (chisquare or log-likelihood)Definition TFumili.cxx:1628; TFumili::fNstepDecInt_t fNstepDecfNstepDec - maximum number of step decreasing counterDefinition TFumili.h:20; TFumili::GetErrorsInt_t GetErrors(Int_t ipar, Double_t &eplus, Double_t &eminus, Double_t &eparab, Double_t &globcc) const overrideReturn errors after MINOs not implemented.Definition TFumili.cxx:882; TFumili::fZ0Double_t * fZ0[fMaxParam2] Matrix of approximate second derivatives of objective function This matrix is diagonal a...Definition TFumili.h:34; TFumili::fPL0Double_t * fPL0[fMaxParam] Step initial boundsDefinition TFumili.h:45; TFumili::fADouble_t * fA[fMaxParam] Fit parameter arrayDefinition TFumili.h:44; TFumili::fAKAPPADouble_t fAKAPPADefinition TFumili.h:60; TFumili::MinimizeInt_t Minimize()Main minimization procedure.Definition TFumili.cxx:1085; TFumili::fNmaxIterInt_t fNmaxIterfNmaxIter - maximum number of iterationsDefinition TFumili.h:22; TFumili::ExecuteSetCommandInt_t ExecuteSetCommand(Int_t)Called from TFumili::ExecuteCommand in case of ""SET xxx"" and ""SHOW xxx"".Definition TFumili.cxx:558; TFumili::fSDouble_t fSfS - objective function value (return)Definition TFumili.h:57; TFumili::fEPSDouble_t fEPSfEPS - required precision of parameters. If fEPS<0 t",MatchSource.WIKI,doc/master/TFumili_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8h_source.html
https://root.cern/doc/master/TFumili_8h_source.html:13591,Availability,error,errors,13591,"Definition TFumili.cxx:558; TFumili::fSDouble_t fSfS - objective function value (return)Definition TFumili.h:57; TFumili::fEPSDouble_t fEPSfEPS - required precision of parameters. If fEPS<0 thenDefinition TFumili.h:58; TFumili::FitChisquareIvirtual void FitChisquareI(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag)Minimization function for H1s using a Chisquare method.Definition TFumili.cxx:1809; TFumili::fNfcnInt_t fNfcnNumber of FCN calls;.Definition TFumili.h:15; TFumili::fLastFixedInt_t fLastFixedLast fixed parameter number.Definition TFumili.h:23; TFumili::BuildArraysvoid BuildArrays()Allocates memory for internal arrays.Definition TFumili.cxx:182; TFumili::fZDouble_t * fZ[fMaxParam2] Inverse fZ0 matrix - covariance matrixDefinition TFumili.h:37; TFumili::fLogLikeBool_t fLogLikeLogLikelihood flag.Definition TFumili.h:31; TFumili::fNED1Int_t fNED1Number of experimental vectors X=(x1,x2,...xK)Definition TFumili.h:16; TFumili::Clearvoid Clear(Option_t *opt="""") overrideResets all parameter names, values and errors to zero.Definition TFumili.cxx:242; TFumili::fGrDouble_t * fGr[fMaxParam] Gradients of objective functionDefinition TFumili.h:38; TFumili::fGTDouble_t fGTExpected function change in next iteration.Definition TFumili.h:61; TFumili::SetParameterInt_t SetParameter(Int_t ipar, const char *parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh) overrideSets for parameter number ipar initial parameter value, name parname, initial error verr and limits v...Definition TFumili.cxx:1641; TFumili::fCwordTString fCwordCommand string.Definition TFumili.h:63; TFumili::FitLikelihoodIvirtual void FitLikelihoodI(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag)Minimization function for H1s using a Likelihood method.Definition TFumili.cxx:1972; TFumili::fRPDouble_t fRPPrecision of fit ( machine zero on CDC 6000) quite old yeh?Definition TFumili.h:59; TFumili::fCmParDouble_t * fCmPar[fMaxParam] parameters of commandsDefinition ",MatchSource.WIKI,doc/master/TFumili_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8h_source.html
https://root.cern/doc/master/TFumili_8h_source.html:14041,Availability,error,error,14041,"efinition TFumili.cxx:1809; TFumili::fNfcnInt_t fNfcnNumber of FCN calls;.Definition TFumili.h:15; TFumili::fLastFixedInt_t fLastFixedLast fixed parameter number.Definition TFumili.h:23; TFumili::BuildArraysvoid BuildArrays()Allocates memory for internal arrays.Definition TFumili.cxx:182; TFumili::fZDouble_t * fZ[fMaxParam2] Inverse fZ0 matrix - covariance matrixDefinition TFumili.h:37; TFumili::fLogLikeBool_t fLogLikeLogLikelihood flag.Definition TFumili.h:31; TFumili::fNED1Int_t fNED1Number of experimental vectors X=(x1,x2,...xK)Definition TFumili.h:16; TFumili::Clearvoid Clear(Option_t *opt="""") overrideResets all parameter names, values and errors to zero.Definition TFumili.cxx:242; TFumili::fGrDouble_t * fGr[fMaxParam] Gradients of objective functionDefinition TFumili.h:38; TFumili::fGTDouble_t fGTExpected function change in next iteration.Definition TFumili.h:61; TFumili::SetParameterInt_t SetParameter(Int_t ipar, const char *parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh) overrideSets for parameter number ipar initial parameter value, name parname, initial error verr and limits v...Definition TFumili.cxx:1641; TFumili::fCwordTString fCwordCommand string.Definition TFumili.h:63; TFumili::FitLikelihoodIvirtual void FitLikelihoodI(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag)Minimization function for H1s using a Likelihood method.Definition TFumili.cxx:1972; TFumili::fRPDouble_t fRPPrecision of fit ( machine zero on CDC 6000) quite old yeh?Definition TFumili.h:59; TFumili::fCmParDouble_t * fCmPar[fMaxParam] parameters of commandsDefinition TFumili.h:55; TFumili::fDFDouble_t * fDF[fMaxParam] First derivatives of theoretical functionDefinition TFumili.h:54; TFumili::GetSumLogDouble_t GetSumLog(Int_t) overrideReturn Sum(log(i) i=0,n used by log-likelihood fits.Definition TFumili.cxx:921; TFumili::fSumLogDouble_t * fSumLog[fNlog]Definition TFumili.h:40; TFumili::fAMXDouble_t * fAMX[fMaxParam] Maximum param valueDefinition TFu",MatchSource.WIKI,doc/master/TFumili_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8h_source.html
https://root.cern/doc/master/TFumili_8h_source.html:3111,Integrability,wrap,wrapper,3111,,MatchSource.WIKI,doc/master/TFumili_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8h_source.html
https://root.cern/doc/master/TFumili_8h_source.html:1468,Modifiability,variab,variable,1468,"itter.h""; 8 ; 9class TF1;; 10 ; 11class TFumili : public TVirtualFitter {; 12private:; 13 Int_t fMaxParam; ///<; 14 Int_t fNlog; ///<; 15 Int_t fNfcn; ///< Number of FCN calls;; 16 Int_t fNED1; ///< Number of experimental vectors X=(x1,x2,...xK); 17 Int_t fNED2; ///< K - Length of vector X plus 2 (for chi2); 18 Int_t fNED12; ///< fNED1+fNED2; 19 Int_t fNpar; ///< fNpar - number of parameters; 20 Int_t fNstepDec; ///< fNstepDec - maximum number of step decreasing counter; 21 Int_t fNlimMul; ///< fNlimMul - after fNlimMul successful iterations permits four-fold increasing of fPL; 22 Int_t fNmaxIter; ///< fNmaxIter - maximum number of iterations; 23 Int_t fLastFixed; ///< Last fixed parameter number; 24 Int_t fENDFLG; ///< End flag of fit; 25 Int_t fINDFLG[5]; ///< internal flags;; 26 ; 27 ; 28 Bool_t fGRAD; ///< user calculated gradients; 29 Bool_t fWARN; ///< warnings; 30 Bool_t fDEBUG; ///< debug info; 31 Bool_t fLogLike; ///< LogLikelihood flag; 32 Bool_t fNumericDerivatives; ///<; 33 ; 34 Double_t *fZ0; ///< [fMaxParam2] Matrix of approximate second derivatives of objective function; 35 ///< This matrix is diagonal and always contain only variable parameter's; 36 ///< derivatives; 37 Double_t *fZ; ///< [fMaxParam2] Inverse fZ0 matrix - covariance matrix; 38 Double_t *fGr; ///< [fMaxParam] Gradients of objective function; 39 Double_t *fParamError; ///< [fMaxParam] Parameter errors; 40 Double_t *fSumLog; ///< [fNlog]; 41 Double_t *fEXDA; ///< [fNED12] experimental data poInt_ter; 42 ; 43 // don't calculate parameter errors - take them from fParamError array; 44 Double_t *fA; ///< [fMaxParam] Fit parameter array; 45 Double_t *fPL0; ///< [fMaxParam] Step initial bounds; 46 Double_t *fPL; ///< [fMaxParam] Limits for parameters step. If <0, then parameter is fixed; 47 ; 48 // Defines multidimensional parallelepiped with center in param. vector; 49 Double_t *fDA; ///< [fMaxParam] Parameter step; 50 Double_t *fAMX; ///< [fMaxParam] Maximum param value; 51 Double_t *fAMN; /",MatchSource.WIKI,doc/master/TFumili_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8h_source.html
https://root.cern/doc/master/TFumili_8h_source.html:11502,Testability,log,log-likelihood,11502,"efinition TFumili.h:13; TFumili::SetParNumbervoid SetParNumber(Int_t ParNum)Definition TFumili.cxx:168; TFumili::SetDatavoid SetData(Double_t *, Int_t, Int_t)Sets pointer to data array provided by user.Definition TFumili.cxx:1616; TFumili::fINDFLGInt_t fINDFLG[5]internal flags;Definition TFumili.h:25; TFumili::EvalTFNDouble_t EvalTFN(Double_t *, Double_t *)Evaluate theoretical function.Definition TFumili.cxx:362; TFumili::GetZDouble_t * GetZ() constDefinition TFumili.h:102; TFumili::fParamErrorDouble_t * fParamError[fMaxParam] Parameter errorsDefinition TFumili.h:39; TFumili::ChisquareDouble_t Chisquare(Int_t npar, Double_t *params) const overridereturn a chisquare equivalentDefinition TFumili.cxx:227; TFumili::fENDFLGInt_t fENDFLGEnd flag of fit.Definition TFumili.h:24; TFumili::fRDouble_t * fR[fMaxParam] Correlation factorsDefinition TFumili.h:52; TFumili::fDADouble_t * fDA[fMaxParam] Parameter stepDefinition TFumili.h:49; TFumili::SetFitMethodvoid SetFitMethod(const char *name) overrideret fit method (chisquare or log-likelihood)Definition TFumili.cxx:1628; TFumili::fNstepDecInt_t fNstepDecfNstepDec - maximum number of step decreasing counterDefinition TFumili.h:20; TFumili::GetErrorsInt_t GetErrors(Int_t ipar, Double_t &eplus, Double_t &eminus, Double_t &eparab, Double_t &globcc) const overrideReturn errors after MINOs not implemented.Definition TFumili.cxx:882; TFumili::fZ0Double_t * fZ0[fMaxParam2] Matrix of approximate second derivatives of objective function This matrix is diagonal a...Definition TFumili.h:34; TFumili::fPL0Double_t * fPL0[fMaxParam] Step initial boundsDefinition TFumili.h:45; TFumili::fADouble_t * fA[fMaxParam] Fit parameter arrayDefinition TFumili.h:44; TFumili::fAKAPPADouble_t fAKAPPADefinition TFumili.h:60; TFumili::MinimizeInt_t Minimize()Main minimization procedure.Definition TFumili.cxx:1085; TFumili::fNmaxIterInt_t fNmaxIterfNmaxIter - maximum number of iterationsDefinition TFumili.h:22; TFumili::ExecuteSetCommandInt_t ExecuteSetComma",MatchSource.WIKI,doc/master/TFumili_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8h_source.html
https://root.cern/doc/master/TFumili_8h_source.html:14732,Testability,log,log,14732,".cxx:242; TFumili::fGrDouble_t * fGr[fMaxParam] Gradients of objective functionDefinition TFumili.h:38; TFumili::fGTDouble_t fGTExpected function change in next iteration.Definition TFumili.h:61; TFumili::SetParameterInt_t SetParameter(Int_t ipar, const char *parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh) overrideSets for parameter number ipar initial parameter value, name parname, initial error verr and limits v...Definition TFumili.cxx:1641; TFumili::fCwordTString fCwordCommand string.Definition TFumili.h:63; TFumili::FitLikelihoodIvirtual void FitLikelihoodI(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag)Minimization function for H1s using a Likelihood method.Definition TFumili.cxx:1972; TFumili::fRPDouble_t fRPPrecision of fit ( machine zero on CDC 6000) quite old yeh?Definition TFumili.h:59; TFumili::fCmParDouble_t * fCmPar[fMaxParam] parameters of commandsDefinition TFumili.h:55; TFumili::fDFDouble_t * fDF[fMaxParam] First derivatives of theoretical functionDefinition TFumili.h:54; TFumili::GetSumLogDouble_t GetSumLog(Int_t) overrideReturn Sum(log(i) i=0,n used by log-likelihood fits.Definition TFumili.cxx:921; TFumili::fSumLogDouble_t * fSumLog[fNlog]Definition TFumili.h:40; TFumili::fAMXDouble_t * fAMX[fMaxParam] Maximum param valueDefinition TFumili.h:50; TFumili::fDEBUGBool_t fDEBUGdebug infoDefinition TFumili.h:30; TFumili::fNlimMulInt_t fNlimMulfNlimMul - after fNlimMul successful iterations permits four-fold increasing of fPLDefinition TFumili.h:21; TFumili::fGRADBool_t fGRADuser calculated gradientsDefinition TFumili.h:28; TFumili::InvertZvoid InvertZ(Int_t)Inverts packed diagonal matrix Z by square-root method.Definition TFumili.cxx:945; TStringBasic string class.Definition TString.h:139; TVirtualFitterAbstract Base Class for Fitting.Definition TVirtualFitter.h:29; bool; double; int. mathfumiliincTFumili.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:39 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TFumili_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8h_source.html
https://root.cern/doc/master/TFumili_8h_source.html:14753,Testability,log,log-likelihood,14753,".cxx:242; TFumili::fGrDouble_t * fGr[fMaxParam] Gradients of objective functionDefinition TFumili.h:38; TFumili::fGTDouble_t fGTExpected function change in next iteration.Definition TFumili.h:61; TFumili::SetParameterInt_t SetParameter(Int_t ipar, const char *parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh) overrideSets for parameter number ipar initial parameter value, name parname, initial error verr and limits v...Definition TFumili.cxx:1641; TFumili::fCwordTString fCwordCommand string.Definition TFumili.h:63; TFumili::FitLikelihoodIvirtual void FitLikelihoodI(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag)Minimization function for H1s using a Likelihood method.Definition TFumili.cxx:1972; TFumili::fRPDouble_t fRPPrecision of fit ( machine zero on CDC 6000) quite old yeh?Definition TFumili.h:59; TFumili::fCmParDouble_t * fCmPar[fMaxParam] parameters of commandsDefinition TFumili.h:55; TFumili::fDFDouble_t * fDF[fMaxParam] First derivatives of theoretical functionDefinition TFumili.h:54; TFumili::GetSumLogDouble_t GetSumLog(Int_t) overrideReturn Sum(log(i) i=0,n used by log-likelihood fits.Definition TFumili.cxx:921; TFumili::fSumLogDouble_t * fSumLog[fNlog]Definition TFumili.h:40; TFumili::fAMXDouble_t * fAMX[fMaxParam] Maximum param valueDefinition TFumili.h:50; TFumili::fDEBUGBool_t fDEBUGdebug infoDefinition TFumili.h:30; TFumili::fNlimMulInt_t fNlimMulfNlimMul - after fNlimMul successful iterations permits four-fold increasing of fPLDefinition TFumili.h:21; TFumili::fGRADBool_t fGRADuser calculated gradientsDefinition TFumili.h:28; TFumili::InvertZvoid InvertZ(Int_t)Inverts packed diagonal matrix Z by square-root method.Definition TFumili.cxx:945; TStringBasic string class.Definition TString.h:139; TVirtualFitterAbstract Base Class for Fitting.Definition TVirtualFitter.h:29; bool; double; int. mathfumiliincTFumili.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:39 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TFumili_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8h_source.html
https://root.cern/doc/master/TGaxis_8cxx_source.html:44769,Availability,avail,available,44769,"1556736; // months (average # days); 1231 rangeOffset = (Double_t) ((Long_t)(timeoffset)%rangeBase);; 1232 if (range>31536000) {; 1233 tp0 = gmtime(&timetp);; 1234 tp0->tm_mon = 0;; 1235 tp0->tm_mday = 1;; 1236 tp0->tm_hour = 0;; 1237 tp0->tm_min = 0;; 1238 tp0->tm_sec = 0;; 1239 tp0->tm_isdst = 1; // daylight saving time is on.; 1240 rangeBase = (timetp-mktime(tp0)); // years; 1241 rangeOffset = (Double_t) (rangeBase);; 1242 }; 1243 wmax += rangeOffset;; 1244 wmin += rangeOffset;; 1245 }; 1246 ; 1247// Determine number of divisions 1, 2 and 3 and the maximum digits for this axis; 1248 n1a = (ndiv%100);; 1249 n2a = (ndiv%10000 - n1a)/100;; 1250 n3a = (ndiv%1000000 - n2a -n1a)/10000;; 1251 nn3 = TMath::Max(n3a,1);; 1252 nn2 = TMath::Max(n2a,1)*nn3;; 1253 nn1 = TMath::Max(n1a,1)*nn2+1;; 1254 nticks = nn1;; 1255 maxDigits = (ndiv/1000000);; 1256 if (maxDigits==0) maxDigits = gStyle->GetAxisMaxDigits();; 1257 ; 1258// Axis bining optimisation is ignored if:; 1259// - the first and the last label are equal; 1260// - the number of divisions is 0; 1261// - less than 1 primary division is requested; 1262// - logarithmic scale is requested; 1263 ; 1264 if (wmin == wmax || ndiv == 0 || n1a <= 1 || optionLog) {; 1265 optionNoopt = 1;; 1266 optionInt = 0;; 1267 }; 1268 ; 1269// Axis bining optimisation; 1270 if ( (wmax-wmin) < 1 && optionInt) {; 1271 Error(where, ""option I not available"");; 1272 optionInt = 0;; 1273 }; 1274 if (!optionNoopt || optionInt ) {; 1275 ; 1276// Primary divisions optimisation; 1277// When integer labelling is required, Optimize is invoked first; 1278// and only if the result is not an integer labelling, AdjustBinSize is invoked.; 1279 ; 1280 THLimitsFinder::Optimize(wmin,wmax,n1a,binLow,binHigh,nbins,binWidth,fChopt.Data());; 1281 if (optionInt) {; 1282 if (binLow != Double_t(int(binLow)) || binWidth != Double_t(int(binWidth))) {; 1283 AdjustBinSize(wmin,wmax,n1a,binLow,binHigh,nbins,binWidth);; 1284 }; 1285 }; 1286 if ((wmin-binLow) > epsilon) { binLo",MatchSource.WIKI,doc/master/TGaxis_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGaxis_8cxx_source.html
https://root.cern/doc/master/TGaxis_8cxx_source.html:66003,Availability,error,error,66003,"hile (ndyn) {; 1906 Double_t wdyn = TMath::Abs((wmax-wmin)/ndyn);; 1907 if (wdyn <= 0.999 && na < maxDigits-2) {; 1908 na++;; 1909 ndyn /= 10;; 1910 }; 1911 else break;; 1912 }; 1913// if1 and if2 are the two digits defining the format used to produce the; 1914// labels. The format used will be %[if1].[if2]f .; 1915// if1 and if2 are positive (small) integers.; 1916 if2 = na;; 1917 if1 = TMath::Max(nf+na,maxDigits)+1;; 1918L110:; 1919 if (TMath::Min(wmin,wmax) < 0)if1 = if1+1;; 1920 if1 = TMath::Min(if1,32);; 1921 ; 1922// In some cases, if1 and if2 are too small....; 1923 while (dwlabel < TMath::Power(10,-if2)) {; 1924 if1++;; 1925 if2++;; 1926 }; 1927 if (if1 > 14) if1 = 14;; 1928 if (if2 > 14) if2 = 14;; 1929 if (if1 < 0) if1 = 0;; 1930 int len = 0;; 1931 if (if2 > 0) {; 1932 len = snprintf(chcoded,sizeof(chcoded),""%%%d.%df"",if1,if2);; 1933 } else {; 1934 len = snprintf(chcoded,sizeof(chcoded),""%%%d.%df"",if1+1,1);; 1935 }; 1936 // check improbable error condition, suppress gcc9 warnings; 1937 if ((len < 0) || (len >= (int) sizeof(chcoded))); 1938 strcpy(chcoded,""%7.3f"");; 1939 }; 1940 ; 1941// We draw labels; 1942 ; 1943 snprintf(chtemp,256,""%g"",dwlabel);; 1944 Int_t ndecimals = 0;; 1945 if (optionDecimals) {; 1946 char *dot = strchr(chtemp,'.');; 1947 if (dot) {; 1948 ndecimals = chtemp + strlen(chtemp) -dot;; 1949 } else {; 1950 char *exp;; 1951 exp = strstr(chtemp,""e-"");; 1952 if (exp) {; 1953 sscanf(&exp[2],""%d"",&ndecimals);; 1954 ndecimals++;; 1955 }; 1956 }; 1957 }; 1958 if (optionM) nlabels = n1a-1;; 1959 else nlabels = n1a;; 1960 wTimeIni = wlabel;; 1961 for ( k=0; k<=nlabels; k++) {; 1962 if (fFunction) {; 1963 Double_t xf = binLow+Double_t(k*nn2)*dxtick;; 1964 Double_t zz = fFunction->Eval(xf)-rwmi;; 1965 wlabel = xf;; 1966 xlabel = zz* axis_length / TMath::Abs(rwma-rwmi);; 1967 } else {; 1968 xlabel = dxlabel*k;; 1969 }; 1970 if (optionM) xlabel += 0.5*dxlabel;; 1971 ; 1972 axis_value = wlabel;; 1973 ; 1974 if (!optionText && !optionTime) {; 1975 snprin",MatchSource.WIKI,doc/master/TGaxis_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGaxis_8cxx_source.html
https://root.cern/doc/master/TGaxis_8cxx_source.html:71511,Availability,down,down,71511," 2087 if (scale>0.0) toffset = TMath::Max(toffset,(double)w/scale);; 2088 }; 2089 textaxis.PaintLatex(gPad->GetX1() + xx*(gPad->GetX2() - gPad->GetX1()),; 2090 gPad->GetY1() + yy*(gPad->GetY2() - gPad->GetY1()),; 2091 textaxis.GetTextAngle(),; 2092 textaxis.GetTextSize(),; 2093 typolabel.Data());; 2094 if (fNModLabs) ResetLabelAttributes(&textaxis);; 2095 } else {; 2096 strlcpy(chtemp, fAxis->GetBinLabel(k+fAxis->GetFirst()), 255);; 2097 if (fNModLabs) ChangeLabelAttributes(k+fAxis->GetFirst(), fAxis->GetLabels()->GetSize()-1, &textaxis, chtemp, k+fAxis->GetFirst(), 0.1);; 2098 if (optionText == 1) textaxis.PaintLatex(gPad->GetX1() + xx*(gPad->GetX2() - gPad->GetX1()),; 2099 gPad->GetY1() + yy*(gPad->GetY2() - gPad->GetY1()),; 2100 0,; 2101 textaxis.GetTextSize(),; 2102 chtemp);; 2103 if (fNModLabs) ResetLabelAttributes(&textaxis);; 2104 }; 2105 } else {; 2106 ; 2107// Text alignment is down; 2108 if (!optionText) lnlen = last-first+1;; 2109 else {; 2110 if (k+1 > nhilab) lnlen = 0;; 2111 }; 2112 for ( l=1; l<=lnlen; l++) {; 2113 if (!optionText) *chtemp = label[first+l-2];; 2114 else {; 2115 if (lnlen == 0) strncpy(chtemp, "" "", 256);; 2116 else strncpy(chtemp, ""1"", 256);; 2117 }; 2118 typolabel = chtemp;; 2119 typolabel.ReplaceAll(""-"", ""#minus"");; 2120 textaxis.PaintLatex(gPad->GetX1() + xx*(gPad->GetX2() - gPad->GetX1()),; 2121 gPad->GetY1() + yy*(gPad->GetY2() - gPad->GetY1()),; 2122 0,; 2123 textaxis.GetTextSize(),; 2124 typolabel.Data());; 2125 yy -= charheight*1.3;; 2126 }; 2127 }; 2128 }; 2129 ; 2130// We use the format x 10 ** n; 2131 ; 2132 if (flexe && !optionText && nexe) {; 2133 snprintf(label,256,""#times10^{%d}"", nexe);; 2134 if (x0 != x1) { xfactor = axis_length+0.1*charheight; yfactor = 0; }; 2135 else { xfactor = y1-y0+0.1*charheight; yfactor = 0; }; 2136 Rotate (xfactor,yfactor,cosphi,sinphi,x0,y0,xx,yy);; 2137 textaxis.SetTextAlign(11);; 2138 if (GetLabelFont()%10 < 2) // force TLatex mode in PaintLatex; 2139 textaxis.SetTextFont((Int_t)(GetLabelFon",MatchSource.WIKI,doc/master/TGaxis_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGaxis_8cxx_source.html
https://root.cern/doc/master/TGaxis_8cxx_source.html:127235,Availability,error,error,127235,"amervoid Streamer(TBuffer &) overrideStream an object of class TLine.Definition TLine.cxx:518; TListA doubly linked list.Definition TList.h:38; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TList::Deletevoid Delete(Option_t *option="""") overrideRemove all objects from the list AND delete all heap based objects.Definition TList.cxx:468; TNamed::SetTitlevirtual void SetTitle(const char *title="""")Set the title of the TNamed.Definition TNamed.cxx:164; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::AppendPadvirtual void AppendPad(Option_t *option="""")Append graphics object to current pad.Definition TObject.cxx:190; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::Dataconst char * Data() constDefinition TString.h:376; TString::ReplaceAllTString & ReplaceAll(const TString &s1, const TString &s2)Definition TString.h:704; TString::IsNullBool_t IsNull() constDefinition TString.h:414; TString::RemoveTString & Remove(Ssiz_t pos)Definition TString.h:685; TString::Streamervirtual void Streamer(TBuffer &)Stream a string object.Definition TString.cxx:1412; TString::AppendTString & Append(const char *cs)Definition TString.h:572; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TString::IndexSsiz_t Ind",MatchSource.WIKI,doc/master/TGaxis_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGaxis_8cxx_source.html
https://root.cern/doc/master/TGaxis_8cxx_source.html:34484,Deployability,toggle,toggle,34484,"->GetTitleSize());; 972 SetBit(TAxis::kCenterTitle, axis->TestBit(TAxis::kCenterTitle));; 973 SetBit(TAxis::kCenterLabels, axis->TestBit(TAxis::kCenterLabels));; 974 SetBit(TAxis::kRotateTitle, axis->TestBit(TAxis::kRotateTitle));; 975 SetBit(TAxis::kNoExponent, axis->TestBit(TAxis::kNoExponent));; 976 SetBit(TAxis::kTickPlus, axis->TestBit(TAxis::kTickPlus));; 977 SetBit(TAxis::kTickMinus, axis->TestBit(TAxis::kTickMinus));; 978 SetBit(TAxis::kMoreLogLabels, axis->TestBit(TAxis::kMoreLogLabels));; 979 if (axis->GetDecimals()) SetBit(TAxis::kDecimals); //the bit is in TAxis::fAxis2; 980 SetTimeFormat(axis->GetTimeFormat());; 981}; 982 ; 983////////////////////////////////////////////////////////////////////////////////; 984/// Draw this axis with its current attributes.; 985 ; 986void TGaxis::Paint(Option_t *); 987{; 988 if (!gPad) return;; 989 ; 990 Double_t wmin = fWmin;; 991 Double_t wmax = fWmax;; 992 Int_t ndiv = fNdiv;; 993 ; 994 // following code required to support toggle of lin/log scales; 995 Double_t x1 = gPad->XtoPad(fX1);; 996 Double_t y1 = gPad->YtoPad(fY1);; 997 Double_t x2 = gPad->XtoPad(fX2);; 998 Double_t y2 = gPad->YtoPad(fY2);; 999 ; 1000 PaintAxis(x1,y1,x2,y2,wmin,wmax,ndiv,fChopt.Data(),fGridLength);; 1001}; 1002 ; 1003////////////////////////////////////////////////////////////////////////////////; 1004/// Control function to draw an axis.; 1005/// Original authors: O.Couet C.E.Vandoni N.Cremel-Somon.; 1006/// Modified and converted to C++ class by Rene Brun.; 1007 ; 1008void TGaxis::PaintAxis(Double_t xmin, Double_t ymin, Double_t xmax, Double_t ymax,; 1009 Double_t &wmin, Double_t &wmax, Int_t &ndiv, Option_t *chopt,; 1010 Double_t gridlength, Bool_t drawGridOnly); 1011{; 1012 if (!gPad) return;; 1013 ; 1014 const char *where = ""PaintAxis"";; 1015 ; 1016 Double_t alfa, beta, ratio1, ratio2, grid_side;; 1017 Double_t axis_lengthN = 0;; 1018 Double_t axis_length0 = 0;; 1019 Double_t axis_length1 = 0;; 1020 Double_t axis_length;; 1021 Double_t at",MatchSource.WIKI,doc/master/TGaxis_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGaxis_8cxx_source.html
https://root.cern/doc/master/TGaxis_8cxx_source.html:5077,Energy Efficiency,energy,energy,5077,"ar *func, Int_t ndiv, Option_t *chopt,; 115 Double_t gridlength); 116~~~; 117Where:; 118 ; 119- xmin : X origin coordinate in user's coordinates space.; 120- xmax : X end axis coordinate in user's coordinates space.; 121- ymin : Y origin coordinate in user's coordinates space.; 122- ymax : Y end axis coordinate in user's coordinates space.; 123- func : function defining axis labels and tick marks.; 124- ndiv : Number of divisions.; 125 - ndiv=N1 + 100*N2 + 10000*N3; 126 - N1=number of 1st divisions.; 127 - N2=number of 2nd divisions.; 128 - N3=number of 3rd divisions. e.g.:; 129 - ndiv=0 --> no tick marks.; 130 - ndiv=2 --> 2 divisions, one tick mark in the middle of the axis.; 131- chopt : Drawing options (see below).; 132- gridlength: grid length on main tick marks.; 133 ; 134It should be noted that `func` is not defined in the user's coordinate space,; 135but in the new TGaxis space. If `x` is the original axis, `w` the new axis,; 136and `w = f(x)` (for example, `f` is a calibration function converting ADC; 137channels `x` to energy `w`), then `func` must be supplied as `f^{-1}(w)`.; 138 ; 139Examples:; 140 ; 141Begin_Macro(source); 142{; 143 TCanvas *c2 = new TCanvas(""c2"",""c2"",10,10,700,500);; 144 ; 145 gPad->DrawFrame(0.,-2.,10.,2);; 146 ; 147 TF1 *f1=new TF1(""f1"",""-x"",-10,10);; 148 TGaxis *A1 = new TGaxis(0,2,10,2,""f1"",510,""-"");; 149 A1->SetTitle(""axis with decreasing values"");; 150 A1->Draw();; 151 ; 152 TF1 *f2=new TF1(""f2"",""exp(x)"",0,2);; 153 TGaxis *A2 = new TGaxis(1,1,9,1,""f2"");; 154 A2->SetTitle(""exponential axis"");; 155 A2->SetLabelSize(0.03);; 156 A2->SetTitleSize(0.03);; 157 A2->SetTitleOffset(1.2);; 158 A2->Draw();; 159 ; 160 TF1 *f3=new TF1(""f3"",""log10(x)"",1,1000);; 161 TGaxis *A3 = new TGaxis(2,-2,2,0,""f3"",505,"""");; 162 A3->SetTitle(""logarithmic axis"");; 163 A3->SetLabelSize(0.02);; 164 A3->SetTitleSize(0.03);; 165 A3->SetTitleOffset(0.); // Axis title automatically placed; 166 A3->Draw();; 167}; 168End_Macro; 169 ; 170Note that this functionality h",MatchSource.WIKI,doc/master/TGaxis_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGaxis_8cxx_source.html
https://root.cern/doc/master/TGaxis_8cxx_source.html:26642,Energy Efficiency,energy,energy,26642,"t wmax, Int_t ndiv, Option_t *chopt,; 724 Double_t gridlength); 725 : TLine(xmin,ymin,xmax,ymax), TAttText(11,0,1,62,0.040); 726{; 727 ; 728 fWmin = wmin;; 729 fWmax = wmax;; 730 fNdiv = ndiv;; 731 fNModLabs = 0;; 732 fModLabs = nullptr;; 733 fGridLength = gridlength;; 734 fLabelOffset = 0.005;; 735 fLabelSize = 0.040;; 736 fLabelFont = 62;; 737 fLabelColor = 1;; 738 fTickSize = 0.030;; 739 fTitleOffset = 1;; 740 fTitleSize = fLabelSize;; 741 fChopt = chopt;; 742 fName = """";; 743 fTitle = """";; 744 fTimeFormat = """";; 745 fFunctionName= """";; 746 fFunction = nullptr;; 747 fAxis = nullptr;; 748}; 749 ; 750////////////////////////////////////////////////////////////////////////////////; 751/// Constructor with a `TF1` to map axis values.; 752///; 753/// \note The function `func` (with name `funcname`) is not defined in the user's; 754/// coordinate space, but in the new TGaxis space. If `x` is the original axis,; 755/// `w` the new axis, and `w = f(x)` (for example, `f` is a calibration function; 756/// converting ADC channels `x` to energy `w`), then `func` must be supplied as; 757/// `f^{-1}(w)`.; 758 ; 759TGaxis::TGaxis(Double_t xmin, Double_t ymin, Double_t xmax, Double_t ymax,; 760 const char *funcname, Int_t ndiv, Option_t *chopt,; 761 Double_t gridlength); 762 : TLine(xmin,ymin,xmax,ymax), TAttText(11,0,1,62,0.040); 763{; 764 ; 765 fFunction = (TF1*)gROOT->GetFunction(funcname);; 766 if (!fFunction) {; 767 Error(""TGaxis"", ""calling constructor with an unknown function: %s"", funcname);; 768 fWmin = 0;; 769 fWmax = 1;; 770 } else {; 771 fWmin = fFunction->GetXmin();; 772 fWmax = fFunction->GetXmax();; 773 }; 774 fFunctionName= funcname;; 775 fNdiv = ndiv;; 776 fNModLabs = 0;; 777 fModLabs = nullptr;; 778 fGridLength = gridlength;; 779 fLabelOffset = 0.005;; 780 fLabelSize = 0.040;; 781 fLabelFont = 62;; 782 fLabelColor = 1;; 783 fTickSize = 0.030;; 784 fTitleOffset = 1;; 785 fTitleSize = fLabelSize;; 786 fChopt = chopt;; 787 fName = """";; 788 fTitle = """";; 789 fTimeFor",MatchSource.WIKI,doc/master/TGaxis_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGaxis_8cxx_source.html
https://root.cern/doc/master/TGaxis_8cxx_source.html:64393,Energy Efficiency,power,powers,64393,"1855 nexe = int(af);; 1856 iexe = TMath::Abs(nexe);; 1857 if (iexe%3 == 1) iexe += 2;; 1858 else if(iexe%3 == 2) iexe += 1;; 1859 if (nexe < 0) nexe = -iexe;; 1860 else nexe = iexe;; 1861 wlabel = wlabel*TMath::Power(10,iexe);; 1862 dwlabel = dwlabel*TMath::Power(10,iexe);; 1863 if1 = maxDigits;; 1864 if2 = maxDigits-2;; 1865 goto L110;; 1866 }; 1867 }; 1868 if (ww >= 1) af = TMath::Log10(ww);; 1869 else af = TMath::Log10(ww*0.0001);; 1870 af += epsilon;; 1871 nf = Int_t(af)+1;; 1872 if (!noExponent && nf > maxDigits) flexpo = kTRUE;; 1873 if (!noExponent && nf < -maxDigits) flexne = kTRUE;; 1874 ; 1875// Use x 10 n format. (only powers of 3 allowed); 1876 ; 1877 if (flexpo) {; 1878 flexe = kTRUE;; 1879 while (true) {; 1880 nexe++;; 1881 ww /= 10;; 1882 wlabel /= 10;; 1883 dwlabel /= 10;; 1884 if (nexe%3 == 0 && ww <= TMath::Power(10,maxDigits-1)) break;; 1885 }; 1886 }; 1887 ; 1888 if (flexne) {; 1889 flexe = kTRUE;; 1890 rne = 1/TMath::Power(10,maxDigits-2);; 1891 while (true) {; 1892 nexe--;; 1893 ww *= 10;; 1894 wlabel *= 10;; 1895 dwlabel *= 10;; 1896 if (nexe%3 == 0 && ww >= rne) break;; 1897 }; 1898 }; 1899 ; 1900 na = 0;; 1901 for (i=maxDigits-1; i>0; i--) {; 1902 if (TMath::Abs(ww) < TMath::Power(10,i)) na = maxDigits-i;; 1903 }; 1904 ndyn = n1a;; 1905 while (ndyn) {; 1906 Double_t wdyn = TMath::Abs((wmax-wmin)/ndyn);; 1907 if (wdyn <= 0.999 && na < maxDigits-2) {; 1908 na++;; 1909 ndyn /= 10;; 1910 }; 1911 else break;; 1912 }; 1913// if1 and if2 are the two digits defining the format used to produce the; 1914// labels. The format used will be %[if1].[if2]f .; 1915// if1 and if2 are positive (small) integers.; 1916 if2 = na;; 1917 if1 = TMath::Max(nf+na,maxDigits)+1;; 1918L110:; 1919 if (TMath::Min(wmin,wmax) < 0)if1 = if1+1;; 1920 if1 = TMath::Min(if1,32);; 1921 ; 1922// In some cases, if1 and if2 are too small....; 1923 while (dwlabel < TMath::Power(10,-if2)) {; 1924 if1++;; 1925 if2++;; 1926 }; 1927 if (if1 > 14) if1 = 14;; 1928 if (if2 > 14) if2 = 14;; ",MatchSource.WIKI,doc/master/TGaxis_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGaxis_8cxx_source.html
https://root.cern/doc/master/TGaxis_8cxx_source.html:95176,Energy Efficiency,green,green,95176,"am[in] labSize New size (0 erase the label); 2779/// \param[in] labAlign New alignment value; 2780/// \param[in] labColor New label color; 2781/// \param[in] labFont New label font; 2782/// \param[in] labText New label text; 2783///; 2784/// #### Example:; 2785///; 2786/// Begin_Macro(source); 2787/// {; 2788/// auto c = new TCanvas(""c1"",""Examples of TGaxis"",900,100);; 2789/// c->Range(-6,-0.1,6,0.1);; 2790/// auto *axis = new TGaxis(-5.5,0.,5.5,0.,0.0,100,510,""S"");; 2791/// axis->SetName(""axis1"");; 2792/// axis->SetTitle(""Axis Title"");; 2793/// axis->SetTitleSize(0.2);; 2794/// axis->SetLabelSize(0.2);; 2795/// axis->SetTickSize(0.15);; 2796/// axis->SetTitleColor(kBlue);; 2797/// axis->SetTitleFont(42);; 2798/// axis->ChangeLabelByValue(0., -1, -1, -1, kRed);; 2799/// axis->ChangeLabelByValue(20., -1, 0);; 2800/// axis->ChangeLabelByValue(40., 30.);; 2801/// axis->ChangeLabelByValue(50., -1, -1, -1, kBlue, -1, ""blue for 50."");; 2802/// axis->ChangeLabelByValue(90., -1, -1, -1, kGreen, -1, ""green for 90."");; 2803/// axis->Draw();; 2804/// }; 2805/// End_Macro; 2806///; 2807/// #### Notes:; 2808///; 2809/// - If an attribute should not be changed just give the value ""-1"".; 2810/// - To erase a label set labSize to 0; 2811/// - If labText is not specified or is an empty string, the text label is not changed.; 2812 ; 2813void TGaxis::ChangeLabelByValue(Double_t labValue, Double_t labAngle, Double_t labSize,; 2814 Int_t labAlign, Int_t labColor, Int_t labFont,; 2815 const TString &labText); 2816{; 2817 // special situation when mod labs taken from axis - one have to reset pointer; 2818 if (fModLabs && !IsOwnedModLabs()) {; 2819 fModLabs = nullptr;; 2820 fNModLabs = 0;; 2821 }; 2822 ; 2823 fNModLabs++;; 2824 if (!fModLabs) {; 2825 fModLabs = new TList();; 2826 fModLabs->SetOwner(kTRUE);; 2827 }; 2828 ; 2829 TAxisModLab *ml = FindModLab(0, 0, labValue, 0.);; 2830 if (!ml) {; 2831 ml = new TAxisModLab();; 2832 ml->SetLabValue(labValue);; 2833 fModLabs->Add(ml);; 2834 }; 2",MatchSource.WIKI,doc/master/TGaxis_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGaxis_8cxx_source.html
https://root.cern/doc/master/TGaxis_8cxx_source.html:130361,Energy Efficiency,power,power,130361," the notation with 10^N ...Definition TStyle.cxx:1880; TStyle::GetGridWidthWidth_t GetGridWidth() constDefinition TStyle.h:224; TStyle::GetStripDecimalsInt_t GetStripDecimals() constDefinition TStyle.h:268; TStyle::GetExponentOffsetvoid GetExponentOffset(Float_t &xoff, Float_t &yoff, Option_t *axis=""X"") constMethod returns X and Y offset of the axis 10^n notation.Definition TStyle.cxx:1855; TText::SetTextvirtual void SetText(Double_t x, Double_t y, const char *text)Definition TText.h:74; TTimeStamp::MktimeFromUTCstatic time_t MktimeFromUTC(tm_t *tmstruct)Equivalent of standard routine ""mktime"" but using the assumption that tm struct is filled with UTC,...Definition TTimeStamp.cxx:768; bool; double; int; unsigned int; yDouble_t y[n]Definition legend1.C:17; TMath::MaxShort_t Max(Short_t a, Short_t b)Returns the largest of a and b.Definition TMathBase.h:250; TMath::ATan2Double_t ATan2(Double_t y, Double_t x)Returns the principal value of the arc tangent of y/x, expressed in radians.Definition TMath.h:646; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662; TMath::PowerLongDouble_t Power(LongDouble_t x, LongDouble_t y)Returns x raised to the power y.Definition TMath.h:721; TMath::MinShort_t Min(Short_t a, Short_t b)Returns the smallest of a and b.Definition TMathBase.h:198; TMath::CosDouble_t Cos(Double_t)Returns the cosine of an angle of x radians.Definition TMath.h:594; TMath::Piconstexpr Double_t Pi()Definition TMath.h:37; TMath::SinDouble_t Sin(Double_t)Returns the sine of an angle of x radians.Definition TMath.h:588; TMath::Log10Double_t Log10(Double_t x)Returns the common (base-10) logarithm of x.Definition TMath.h:762; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123; v@ vDefinition rootcling_impl.cxx:3699; lTLine lDefinition textangle.C:4. graf2dgrafsrcTGaxis.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:18 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TGaxis_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGaxis_8cxx_source.html
https://root.cern/doc/master/TGaxis_8cxx_source.html:127241,Integrability,message,message,127241,"amervoid Streamer(TBuffer &) overrideStream an object of class TLine.Definition TLine.cxx:518; TListA doubly linked list.Definition TList.h:38; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TList::Deletevoid Delete(Option_t *option="""") overrideRemove all objects from the list AND delete all heap based objects.Definition TList.cxx:468; TNamed::SetTitlevirtual void SetTitle(const char *title="""")Set the title of the TNamed.Definition TNamed.cxx:164; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::AppendPadvirtual void AppendPad(Option_t *option="""")Append graphics object to current pad.Definition TObject.cxx:190; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::Dataconst char * Data() constDefinition TString.h:376; TString::ReplaceAllTString & ReplaceAll(const TString &s1, const TString &s2)Definition TString.h:704; TString::IsNullBool_t IsNull() constDefinition TString.h:414; TString::RemoveTString & Remove(Ssiz_t pos)Definition TString.h:685; TString::Streamervirtual void Streamer(TBuffer &)Stream a string object.Definition TString.cxx:1412; TString::AppendTString & Append(const char *cs)Definition TString.h:572; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TString::IndexSsiz_t Ind",MatchSource.WIKI,doc/master/TGaxis_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGaxis_8cxx_source.html
https://root.cern/doc/master/TGaxis_8cxx_source.html:129752,Integrability,rout,routine,129752,"tExponentOffsetvoid SetExponentOffset(Float_t xoff=0., Float_t yoff=0., Option_t *axis=""XY"")Method set X and Y offset of the axis 10^n notation.Definition TStyle.cxx:1836; TStyle::GetTitleOffsetFloat_t GetTitleOffset(Option_t *axis=""X"") constReturn title offset.Definition TStyle.cxx:1228; TStyle::SetAxisMaxDigitsvoid SetAxisMaxDigits(Int_t maxd=5)Method set maximum number of digits permitted for the axis labels above which the notation with 10^N ...Definition TStyle.cxx:1880; TStyle::GetGridWidthWidth_t GetGridWidth() constDefinition TStyle.h:224; TStyle::GetStripDecimalsInt_t GetStripDecimals() constDefinition TStyle.h:268; TStyle::GetExponentOffsetvoid GetExponentOffset(Float_t &xoff, Float_t &yoff, Option_t *axis=""X"") constMethod returns X and Y offset of the axis 10^n notation.Definition TStyle.cxx:1855; TText::SetTextvirtual void SetText(Double_t x, Double_t y, const char *text)Definition TText.h:74; TTimeStamp::MktimeFromUTCstatic time_t MktimeFromUTC(tm_t *tmstruct)Equivalent of standard routine ""mktime"" but using the assumption that tm struct is filled with UTC,...Definition TTimeStamp.cxx:768; bool; double; int; unsigned int; yDouble_t y[n]Definition legend1.C:17; TMath::MaxShort_t Max(Short_t a, Short_t b)Returns the largest of a and b.Definition TMathBase.h:250; TMath::ATan2Double_t ATan2(Double_t y, Double_t x)Returns the principal value of the arc tangent of y/x, expressed in radians.Definition TMath.h:646; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662; TMath::PowerLongDouble_t Power(LongDouble_t x, LongDouble_t y)Returns x raised to the power y.Definition TMath.h:721; TMath::MinShort_t Min(Short_t a, Short_t b)Returns the smallest of a and b.Definition TMathBase.h:198; TMath::CosDouble_t Cos(Double_t)Returns the cosine of an angle of x radians.Definition TMath.h:594; TMath::Piconstexpr Double_t Pi()Definition TMath.h:37; TMath::SinDouble_t Sin(Double_t)Returns the sine of an angle of x radians.Definition TMath.",MatchSource.WIKI,doc/master/TGaxis_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGaxis_8cxx_source.html
https://root.cern/doc/master/TGaxis_8cxx_source.html:29987,Modifiability,config,configured,29987,"; 845 fChopt=ax.fChopt;; 846 fName=ax.fName;; 847 fTitle=ax.fTitle;; 848 fTimeFormat=ax.fTimeFormat;; 849 fFunctionName=ax.fFunctionName;; 850 fFunction=ax.fFunction;; 851 fAxis=ax.fAxis;; 852 fNModLabs=ax.fNModLabs;; 853 fModLabs = ax.IsOwnedModLabs() ? (TList *) ax.fModLabs->Clone() : ax.fModLabs;; 854 }; 855 return *this;; 856}; 857 ; 858////////////////////////////////////////////////////////////////////////////////; 859/// TGaxis default destructor.; 860 ; 861TGaxis::~TGaxis(); 862{; 863 CleanupModLabs();; 864}; 865 ; 866////////////////////////////////////////////////////////////////////////////////; 867/// Returns kTRUE when fModLabs owned by TGaxis and should be cleaned up; 868 ; 869Bool_t TGaxis::IsOwnedModLabs() const; 870{; 871 if (!fModLabs) return kFALSE;; 872 if (fAxis && (fAxis->GetModifiedLabels() == fModLabs)) return kFALSE;; 873 // TList created by TGaxis configured with owner flag; 874 // If TGaxis object from old ROOT file will be read, memory will be leaked; 875 return fModLabs->IsOwner();; 876}; 877 ; 878////////////////////////////////////////////////////////////////////////////////; 879/// Correctly cleanup fModLabs - delete content when owned by TGaxis; 880 ; 881void TGaxis::CleanupModLabs(); 882{; 883 if (IsOwnedModLabs()) {; 884 fModLabs->Delete();; 885 delete fModLabs;; 886 }; 887 fModLabs = nullptr;; 888 fNModLabs = 0;; 889}; 890 ; 891////////////////////////////////////////////////////////////////////////////////; 892/// If center = kTRUE axis labels are centered in the center of the bin.; 893/// The default is to center on the primary tick marks.; 894/// This option does not make sense if there are more bins than tick marks.; 895 ; 896void TGaxis::CenterLabels(Bool_t center); 897{; 898 ; 899 if (center) SetBit(TAxis::kCenterLabels);; 900 else ResetBit(TAxis::kCenterLabels);; 901}; 902 ; 903////////////////////////////////////////////////////////////////////////////////; 904/// If center = kTRUE axis title will be centered. The default i",MatchSource.WIKI,doc/master/TGaxis_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGaxis_8cxx_source.html
https://root.cern/doc/master/TGaxis_8cxx_source.html:32989,Modifiability,config,configured,32989,"945/// Static function returning `gStyle->GetAxisMaxDigits()`.; 946 ; 947Int_t TGaxis::GetMaxDigits(); 948{; 949 return gStyle->GetAxisMaxDigits();; 950}; 951 ; 952////////////////////////////////////////////////////////////////////////////////; 953/// Internal method to import TAxis attributes to this TGaxis.; 954 ; 955void TGaxis::ImportAxisAttributes(TAxis *axis); 956{; 957 // cleanup previously configured custom labels; 958 CleanupModLabs();; 959 ; 960 fAxis = axis;; 961 SetLineColor(axis->GetAxisColor());; 962 SetTextColor(axis->GetTitleColor());; 963 SetTextFont(axis->GetTitleFont());; 964 SetLabelColor(axis->GetLabelColor());; 965 SetLabelFont(axis->GetLabelFont());; 966 SetLabelSize(axis->GetLabelSize());; 967 SetLabelOffset(axis->GetLabelOffset());; 968 SetTickSize(axis->GetTickLength());; 969 SetTitle(axis->GetTitle());; 970 SetTitleOffset(axis->GetTitleOffset());; 971 SetTitleSize(axis->GetTitleSize());; 972 SetBit(TAxis::kCenterTitle, axis->TestBit(TAxis::kCenterTitle));; 973 SetBit(TAxis::kCenterLabels, axis->TestBit(TAxis::kCenterLabels));; 974 SetBit(TAxis::kRotateTitle, axis->TestBit(TAxis::kRotateTitle));; 975 SetBit(TAxis::kNoExponent, axis->TestBit(TAxis::kNoExponent));; 976 SetBit(TAxis::kTickPlus, axis->TestBit(TAxis::kTickPlus));; 977 SetBit(TAxis::kTickMinus, axis->TestBit(TAxis::kTickMinus));; 978 SetBit(TAxis::kMoreLogLabels, axis->TestBit(TAxis::kMoreLogLabels));; 979 if (axis->GetDecimals()) SetBit(TAxis::kDecimals); //the bit is in TAxis::fAxis2; 980 SetTimeFormat(axis->GetTimeFormat());; 981}; 982 ; 983////////////////////////////////////////////////////////////////////////////////; 984/// Draw this axis with its current attributes.; 985 ; 986void TGaxis::Paint(Option_t *); 987{; 988 if (!gPad) return;; 989 ; 990 Double_t wmin = fWmin;; 991 Double_t wmax = fWmax;; 992 Int_t ndiv = fNdiv;; 993 ; 994 // following code required to support toggle of lin/log scales; 995 Double_t x1 = gPad->XtoPad(fX1);; 996 Double_t y1 = gPad->YtoPad(fY1);; 9",MatchSource.WIKI,doc/master/TGaxis_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGaxis_8cxx_source.html
https://root.cern/doc/master/TGaxis_8cxx_source.html:96416,Modifiability,variab,variable,96416,"807/// #### Notes:; 2808///; 2809/// - If an attribute should not be changed just give the value ""-1"".; 2810/// - To erase a label set labSize to 0; 2811/// - If labText is not specified or is an empty string, the text label is not changed.; 2812 ; 2813void TGaxis::ChangeLabelByValue(Double_t labValue, Double_t labAngle, Double_t labSize,; 2814 Int_t labAlign, Int_t labColor, Int_t labFont,; 2815 const TString &labText); 2816{; 2817 // special situation when mod labs taken from axis - one have to reset pointer; 2818 if (fModLabs && !IsOwnedModLabs()) {; 2819 fModLabs = nullptr;; 2820 fNModLabs = 0;; 2821 }; 2822 ; 2823 fNModLabs++;; 2824 if (!fModLabs) {; 2825 fModLabs = new TList();; 2826 fModLabs->SetOwner(kTRUE);; 2827 }; 2828 ; 2829 TAxisModLab *ml = FindModLab(0, 0, labValue, 0.);; 2830 if (!ml) {; 2831 ml = new TAxisModLab();; 2832 ml->SetLabValue(labValue);; 2833 fModLabs->Add(ml);; 2834 }; 2835 ; 2836 ml->SetAngle(labAngle);; 2837 ml->SetSize(labSize);; 2838 ml->SetAlign(labAlign);; 2839 ml->SetColor(labColor);; 2840 ml->SetFont(labFont);; 2841 ml->SetText(labText);; 2842}; 2843 ; 2844 ; 2845static TAttText SavedAttText; ///< Global variable saving the current label's text angle. Used by TGaxis::ChangeLabelAttributes.; 2846 ; 2847////////////////////////////////////////////////////////////////////////////////; 2848/// Helper method used by TGaxis::ChangeLabel.; 2849/// Change the label attributes of label number i. If needed.; 2850///; 2851/// \param[in] i Current label number to be changed if needed; 2852/// \param[in] nlabels Totals number of labels for this axis (useful when i is counted from the end); 2853/// \param[in] t Original TLatex string holding the label to be changed; 2854/// \param[in] c Text string to be drawn; 2855/// \param[in] value Axis value which should be changed; 2856/// \param[in] eps Epsilon parameter for axis value, -1 means ignore axis value at all; 2857 ; 2858 ; 2859void TGaxis::ChangeLabelAttributes(Int_t i, Int_t nlabels, TLatex",MatchSource.WIKI,doc/master/TGaxis_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGaxis_8cxx_source.html
https://root.cern/doc/master/TGaxis_8cxx_source.html:99571,Modifiability,inherit,inherited,99571,"e max number of digits in all axes.; 2892/// If you only want to change the digits of the current TGaxis instance, use; 2893/// axis->SetNdivisions(N*1000000 + (axis->GetNdiv()%1000000)); 2894/// instead of axis->SetMaxDigits(N).; 2895 ; 2896void TGaxis::SetMaxDigits(Int_t maxd); 2897{; 2898 gStyle->SetAxisMaxDigits(maxd);; 2899}; 2900 ; 2901////////////////////////////////////////////////////////////////////////////////; 2902/// Change the name of the axis.; 2903 ; 2904void TGaxis::SetName(const char *name); 2905{; 2906 fName = name;; 2907}; 2908 ; 2909////////////////////////////////////////////////////////////////////////////////; 2910/// Set the kMoreLogLabels bit flag. When this option is selected more labels are; 2911/// drawn when in logarithmic scale and there is a small number of decades (less than 3).; 2912/// Note that this option is automatically inherited from TAxis; 2913 ; 2914void TGaxis::SetMoreLogLabels(Bool_t more); 2915{; 2916 if (more) SetBit(TAxis::kMoreLogLabels);; 2917 else ResetBit(TAxis::kMoreLogLabels);; 2918}; 2919 ; 2920////////////////////////////////////////////////////////////////////////////////; 2921/// Set the NoExponent flag. By default, an exponent of the form 10^N is used; 2922/// when the label values are either all very small or very large. One can disable; 2923/// the exponent by calling axis.SetNoExponent(kTRUE).; 2924 ; 2925void TGaxis::SetNoExponent(Bool_t noExponent); 2926{; 2927 if (noExponent) SetBit(TAxis::kNoExponent);; 2928 else ResetBit(TAxis::kNoExponent);; 2929}; 2930 ; 2931////////////////////////////////////////////////////////////////////////////////; 2932/// To set axis options.; 2933 ; 2934void TGaxis::SetOption(Option_t *option); 2935{; 2936 fChopt = option;; 2937}; 2938 ; 2939////////////////////////////////////////////////////////////////////////////////; 2940/// Change the title of the axis.; 2941 ; 2942void TGaxis::SetTitle(const char *title); 2943{; 2944 fTitle = title;; 2945}; 2946 ; 2947///////////////",MatchSource.WIKI,doc/master/TGaxis_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGaxis_8cxx_source.html
https://root.cern/doc/master/TGaxis_8cxx_source.html:108308,Modifiability,variab,variable,108308,me_t UChar_t lenDefinition TGWin32VirtualXProxy.cxx:249; x2Option_t Option_t TPoint TPoint const char x2Definition TGWin32VirtualXProxy.cxx:70; x1Option_t Option_t TPoint TPoint const char x1Definition TGWin32VirtualXProxy.cxx:70; SetTextFontOption_t Option_t SetTextFontDefinition TGWin32VirtualXProxy.cxx:60; angleOption_t Option_t TPoint TPoint angleDefinition TGWin32VirtualXProxy.cxx:68; y2Option_t Option_t TPoint TPoint const char y2Definition TGWin32VirtualXProxy.cxx:70; widthOption_t Option_t widthDefinition TGWin32VirtualXProxy.cxx:56; wmaxOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t wmaxDefinition TGWin32VirtualXProxy.cxx:162; y1Option_t Option_t TPoint TPoint const char y1Definition TGWin32VirtualXProxy.cxx:70; namechar name[80]Definition TGX11.cxx:110; kHoriconst Int_t kHoriDefinition TGaxis.cxx:39; SavedAttTextstatic TAttText SavedAttTextGlobal variable saving the current label's text angle. Used by TGaxis::ChangeLabelAttributes.Definition TGaxis.cxx:2845; TGaxis.h; THLimitsFinder.h; THashList.h; xminfloat xminDefinition THbookFile.cxx:95; hi#define hiDefinition THbookFile.cxx:128; yminfloat yminDefinition THbookFile.cxx:95; xmaxfloat xmaxDefinition THbookFile.cxx:95; ymaxfloat ymaxDefinition THbookFile.cxx:95; TLatex.h; TLine.h; TMath.h; TObject.h; TROOT.h; gROOT#define gROOTDefinition TROOT.h:406; TStyle.h; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; TTimeStamp.h; TVirtualPad.h; gPad#define gPadDefinition TVirtualPad.h:308; TVirtualX.h; gVirtualX#define gVirtualXDefinition TVirtualX.h:337; snprintf#define snprintfDefinition civetweb.c:1540; TArrowDraw all kinds of Arrows.Definition TArrow.h:29; TAttAxis::GetTitleColorvirtual Color_t GetTitleColor() constDefinition TAttAxis.h:46; TAttAxis::GetLabelColorvirtual Color_t GetLabelColor() constDefinition TAttAxis.h:38; TAttAxis::GetAxisColorvirtual Color_t GetAxis,MatchSource.WIKI,doc/master/TGaxis_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGaxis_8cxx_source.html
https://root.cern/doc/master/TGaxis_8cxx_source.html:13818,Performance,optimiz,optimization,13818,"; 349By default the number of divisions on axis is optimised to show a coherent; 350labelling of the main tick marks. The number of division (`ndiv`) is a; 351composite integer given by:; 352 ; 353` ndiv = N1 + 100*N2 + 10000*N3`; 354 ; 355 - `N1` = number of 1st divisions.; 356 - `N2` = number of 2nd divisions.; 357 - `N3` = number of 3rd divisions.; 358 ; 359by default the value of `N1`, `N2` and `N3` are maximum; 360values. After optimisation the real number of divisions will be smaller or; 361equal to these value. If one wants to bypass the optimisation, the option `""N""`; 362should be given when the `TGaxis` is created. The option `""I""`; 363also act on the number of division as it will force an integer labelling of; 364the axis.; 365 ; 366On an histogram pointer `h` the number of divisions can be set in different ways:.; 367 ; 368- Directly on the histogram. The following will set the number of division; 369 to 510 on the X axis of `h`. To avoid optimization the number of divisions; 370 should be negative (ie: -510);; 371~~~ {.cpp}; 372 h->SetNdivisions(510, ""X"");; 373~~~; 374- On the axis itself:; 375~~~ {.cpp}; 376 h->GetXaxis()->SetNdivisions(510, kTRUE);; 377~~~; 378 ; 379The first parameter is the number of division. If it is negative of if the; 380second parameter is kFALSE then the number of divisions is not optimised.; 381And other signature is also allowed:; 382~~~ {.cpp}; 383 h->GetXaxis()->SetNdivisions(10, 5, 0, kTRUE);; 384~~~; 385\anchor GA12; 386## Maximum Number of Digits for the axis labels; 387 ; 388The static method `TGaxis::SetMaxDigits` sets the maximum number of; 389digits permitted for the axis labels above which the notation with 10^N is used.; 390For example, to accept 6 digits number like 900000 on an axis call; 391`TGaxis::SetMaxDigits(6)`. The default value is 5.; 392`fgMaxDigits` must be greater than 0.; 393Warning: even when called on a particular TGaxis* instance, this static function; 394changes globally the number of digits for al",MatchSource.WIKI,doc/master/TGaxis_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGaxis_8cxx_source.html
https://root.cern/doc/master/TGaxis_8cxx_source.html:13812,Safety,avoid,avoid,13812,"; 349By default the number of divisions on axis is optimised to show a coherent; 350labelling of the main tick marks. The number of division (`ndiv`) is a; 351composite integer given by:; 352 ; 353` ndiv = N1 + 100*N2 + 10000*N3`; 354 ; 355 - `N1` = number of 1st divisions.; 356 - `N2` = number of 2nd divisions.; 357 - `N3` = number of 3rd divisions.; 358 ; 359by default the value of `N1`, `N2` and `N3` are maximum; 360values. After optimisation the real number of divisions will be smaller or; 361equal to these value. If one wants to bypass the optimisation, the option `""N""`; 362should be given when the `TGaxis` is created. The option `""I""`; 363also act on the number of division as it will force an integer labelling of; 364the axis.; 365 ; 366On an histogram pointer `h` the number of divisions can be set in different ways:.; 367 ; 368- Directly on the histogram. The following will set the number of division; 369 to 510 on the X axis of `h`. To avoid optimization the number of divisions; 370 should be negative (ie: -510);; 371~~~ {.cpp}; 372 h->SetNdivisions(510, ""X"");; 373~~~; 374- On the axis itself:; 375~~~ {.cpp}; 376 h->GetXaxis()->SetNdivisions(510, kTRUE);; 377~~~; 378 ; 379The first parameter is the number of division. If it is negative of if the; 380second parameter is kFALSE then the number of divisions is not optimised.; 381And other signature is also allowed:; 382~~~ {.cpp}; 383 h->GetXaxis()->SetNdivisions(10, 5, 0, kTRUE);; 384~~~; 385\anchor GA12; 386## Maximum Number of Digits for the axis labels; 387 ; 388The static method `TGaxis::SetMaxDigits` sets the maximum number of; 389digits permitted for the axis labels above which the notation with 10^N is used.; 390For example, to accept 6 digits number like 900000 on an axis call; 391`TGaxis::SetMaxDigits(6)`. The default value is 5.; 392`fgMaxDigits` must be greater than 0.; 393Warning: even when called on a particular TGaxis* instance, this static function; 394changes globally the number of digits for al",MatchSource.WIKI,doc/master/TGaxis_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGaxis_8cxx_source.html
https://root.cern/doc/master/TGaxis_8cxx_source.html:5814,Testability,log,logarithmic,5814,"2- gridlength: grid length on main tick marks.; 133 ; 134It should be noted that `func` is not defined in the user's coordinate space,; 135but in the new TGaxis space. If `x` is the original axis, `w` the new axis,; 136and `w = f(x)` (for example, `f` is a calibration function converting ADC; 137channels `x` to energy `w`), then `func` must be supplied as `f^{-1}(w)`.; 138 ; 139Examples:; 140 ; 141Begin_Macro(source); 142{; 143 TCanvas *c2 = new TCanvas(""c2"",""c2"",10,10,700,500);; 144 ; 145 gPad->DrawFrame(0.,-2.,10.,2);; 146 ; 147 TF1 *f1=new TF1(""f1"",""-x"",-10,10);; 148 TGaxis *A1 = new TGaxis(0,2,10,2,""f1"",510,""-"");; 149 A1->SetTitle(""axis with decreasing values"");; 150 A1->Draw();; 151 ; 152 TF1 *f2=new TF1(""f2"",""exp(x)"",0,2);; 153 TGaxis *A2 = new TGaxis(1,1,9,1,""f2"");; 154 A2->SetTitle(""exponential axis"");; 155 A2->SetLabelSize(0.03);; 156 A2->SetTitleSize(0.03);; 157 A2->SetTitleOffset(1.2);; 158 A2->Draw();; 159 ; 160 TF1 *f3=new TF1(""f3"",""log10(x)"",1,1000);; 161 TGaxis *A3 = new TGaxis(2,-2,2,0,""f3"",505,"""");; 162 A3->SetTitle(""logarithmic axis"");; 163 A3->SetLabelSize(0.02);; 164 A3->SetTitleSize(0.03);; 165 A3->SetTitleOffset(0.); // Axis title automatically placed; 166 A3->Draw();; 167}; 168End_Macro; 169 ; 170Note that this functionality has some limitations and does not follow all the TGaxis setting.; 171In particular the number of divisions or the maximum number digits do not apply.; 172 ; 173\anchor GA02; 174## Logarithmic axis; 175 ; 176By default axis are linear. To define a `TGaxis` as logarithmic, it is; 177enough to create it with the option `""G""`.; 178 ; 179When plotting an histogram or a graph the logarithmic scale can be set using:; 180 ; 181 - `gPad->SetLogx(1);` set the logarithmic scale on the X axis; 182 - `gPad->SetLogy(1);` set the logarithmic scale on the Y axis; 183 ; 184When the `SetMoreLogLabels()` method is called more labels are drawn; 185when in logarithmic scale and there is a small number of decades (less than 3).; 186 ; 187\ancho",MatchSource.WIKI,doc/master/TGaxis_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGaxis_8cxx_source.html
https://root.cern/doc/master/TGaxis_8cxx_source.html:6291,Testability,log,logarithmic,6291,"w TF1(""f1"",""-x"",-10,10);; 148 TGaxis *A1 = new TGaxis(0,2,10,2,""f1"",510,""-"");; 149 A1->SetTitle(""axis with decreasing values"");; 150 A1->Draw();; 151 ; 152 TF1 *f2=new TF1(""f2"",""exp(x)"",0,2);; 153 TGaxis *A2 = new TGaxis(1,1,9,1,""f2"");; 154 A2->SetTitle(""exponential axis"");; 155 A2->SetLabelSize(0.03);; 156 A2->SetTitleSize(0.03);; 157 A2->SetTitleOffset(1.2);; 158 A2->Draw();; 159 ; 160 TF1 *f3=new TF1(""f3"",""log10(x)"",1,1000);; 161 TGaxis *A3 = new TGaxis(2,-2,2,0,""f3"",505,"""");; 162 A3->SetTitle(""logarithmic axis"");; 163 A3->SetLabelSize(0.02);; 164 A3->SetTitleSize(0.03);; 165 A3->SetTitleOffset(0.); // Axis title automatically placed; 166 A3->Draw();; 167}; 168End_Macro; 169 ; 170Note that this functionality has some limitations and does not follow all the TGaxis setting.; 171In particular the number of divisions or the maximum number digits do not apply.; 172 ; 173\anchor GA02; 174## Logarithmic axis; 175 ; 176By default axis are linear. To define a `TGaxis` as logarithmic, it is; 177enough to create it with the option `""G""`.; 178 ; 179When plotting an histogram or a graph the logarithmic scale can be set using:; 180 ; 181 - `gPad->SetLogx(1);` set the logarithmic scale on the X axis; 182 - `gPad->SetLogy(1);` set the logarithmic scale on the Y axis; 183 ; 184When the `SetMoreLogLabels()` method is called more labels are drawn; 185when in logarithmic scale and there is a small number of decades (less than 3).; 186 ; 187\anchor GA03; 188## Blank axis; 189To draw only the axis tick marks without the axis body, it is enough to specify; 190the option `""B""`. It useful to superpose axis.; 191 ; 192\anchor GA03a; 193## Arrow on axis; 194\since **ROOT version 6.27/01:**; 195 ; 196To draw an arrow at the end of the axis use the option `"">""`. To draw it at the beginning; 197of the axis use the option `""<""`. To draw it on both ends use `""<>""`.; 198 ; 199Begin_Macro(source); 200{; 201 auto c = new TCanvas(""c"",""c"",0,0,500,500);; 202 c->Range(-11,-11,11,11);; 203 ; 204 auto f",MatchSource.WIKI,doc/master/TGaxis_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGaxis_8cxx_source.html
https://root.cern/doc/master/TGaxis_8cxx_source.html:6409,Testability,log,logarithmic,6409," A2->SetTitle(""exponential axis"");; 155 A2->SetLabelSize(0.03);; 156 A2->SetTitleSize(0.03);; 157 A2->SetTitleOffset(1.2);; 158 A2->Draw();; 159 ; 160 TF1 *f3=new TF1(""f3"",""log10(x)"",1,1000);; 161 TGaxis *A3 = new TGaxis(2,-2,2,0,""f3"",505,"""");; 162 A3->SetTitle(""logarithmic axis"");; 163 A3->SetLabelSize(0.02);; 164 A3->SetTitleSize(0.03);; 165 A3->SetTitleOffset(0.); // Axis title automatically placed; 166 A3->Draw();; 167}; 168End_Macro; 169 ; 170Note that this functionality has some limitations and does not follow all the TGaxis setting.; 171In particular the number of divisions or the maximum number digits do not apply.; 172 ; 173\anchor GA02; 174## Logarithmic axis; 175 ; 176By default axis are linear. To define a `TGaxis` as logarithmic, it is; 177enough to create it with the option `""G""`.; 178 ; 179When plotting an histogram or a graph the logarithmic scale can be set using:; 180 ; 181 - `gPad->SetLogx(1);` set the logarithmic scale on the X axis; 182 - `gPad->SetLogy(1);` set the logarithmic scale on the Y axis; 183 ; 184When the `SetMoreLogLabels()` method is called more labels are drawn; 185when in logarithmic scale and there is a small number of decades (less than 3).; 186 ; 187\anchor GA03; 188## Blank axis; 189To draw only the axis tick marks without the axis body, it is enough to specify; 190the option `""B""`. It useful to superpose axis.; 191 ; 192\anchor GA03a; 193## Arrow on axis; 194\since **ROOT version 6.27/01:**; 195 ; 196To draw an arrow at the end of the axis use the option `"">""`. To draw it at the beginning; 197of the axis use the option `""<""`. To draw it on both ends use `""<>""`.; 198 ; 199Begin_Macro(source); 200{; 201 auto c = new TCanvas(""c"",""c"",0,0,500,500);; 202 c->Range(-11,-11,11,11);; 203 ; 204 auto f2 = new TF1(""x2"",""x*x"",-10,10);; 205 f2->SetLineColor(kRed);; 206 f2->Draw(""same"");; 207 ; 208 auto f3 = new TF1(""x3"",""x*x*x"",-10,10);; 209 f3->SetLineColor(kBlue);; 210 f3->Draw(""same"");; 211 ; 212 // Draw the axis with arrows; 213 auto ox ",MatchSource.WIKI,doc/master/TGaxis_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGaxis_8cxx_source.html
https://root.cern/doc/master/TGaxis_8cxx_source.html:6486,Testability,log,logarithmic,6486," A2->SetTitle(""exponential axis"");; 155 A2->SetLabelSize(0.03);; 156 A2->SetTitleSize(0.03);; 157 A2->SetTitleOffset(1.2);; 158 A2->Draw();; 159 ; 160 TF1 *f3=new TF1(""f3"",""log10(x)"",1,1000);; 161 TGaxis *A3 = new TGaxis(2,-2,2,0,""f3"",505,"""");; 162 A3->SetTitle(""logarithmic axis"");; 163 A3->SetLabelSize(0.02);; 164 A3->SetTitleSize(0.03);; 165 A3->SetTitleOffset(0.); // Axis title automatically placed; 166 A3->Draw();; 167}; 168End_Macro; 169 ; 170Note that this functionality has some limitations and does not follow all the TGaxis setting.; 171In particular the number of divisions or the maximum number digits do not apply.; 172 ; 173\anchor GA02; 174## Logarithmic axis; 175 ; 176By default axis are linear. To define a `TGaxis` as logarithmic, it is; 177enough to create it with the option `""G""`.; 178 ; 179When plotting an histogram or a graph the logarithmic scale can be set using:; 180 ; 181 - `gPad->SetLogx(1);` set the logarithmic scale on the X axis; 182 - `gPad->SetLogy(1);` set the logarithmic scale on the Y axis; 183 ; 184When the `SetMoreLogLabels()` method is called more labels are drawn; 185when in logarithmic scale and there is a small number of decades (less than 3).; 186 ; 187\anchor GA03; 188## Blank axis; 189To draw only the axis tick marks without the axis body, it is enough to specify; 190the option `""B""`. It useful to superpose axis.; 191 ; 192\anchor GA03a; 193## Arrow on axis; 194\since **ROOT version 6.27/01:**; 195 ; 196To draw an arrow at the end of the axis use the option `"">""`. To draw it at the beginning; 197of the axis use the option `""<""`. To draw it on both ends use `""<>""`.; 198 ; 199Begin_Macro(source); 200{; 201 auto c = new TCanvas(""c"",""c"",0,0,500,500);; 202 c->Range(-11,-11,11,11);; 203 ; 204 auto f2 = new TF1(""x2"",""x*x"",-10,10);; 205 f2->SetLineColor(kRed);; 206 f2->Draw(""same"");; 207 ; 208 auto f3 = new TF1(""x3"",""x*x*x"",-10,10);; 209 f3->SetLineColor(kBlue);; 210 f3->Draw(""same"");; 211 ; 212 // Draw the axis with arrows; 213 auto ox ",MatchSource.WIKI,doc/master/TGaxis_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGaxis_8cxx_source.html
https://root.cern/doc/master/TGaxis_8cxx_source.html:6553,Testability,log,logarithmic,6553," A2->SetTitle(""exponential axis"");; 155 A2->SetLabelSize(0.03);; 156 A2->SetTitleSize(0.03);; 157 A2->SetTitleOffset(1.2);; 158 A2->Draw();; 159 ; 160 TF1 *f3=new TF1(""f3"",""log10(x)"",1,1000);; 161 TGaxis *A3 = new TGaxis(2,-2,2,0,""f3"",505,"""");; 162 A3->SetTitle(""logarithmic axis"");; 163 A3->SetLabelSize(0.02);; 164 A3->SetTitleSize(0.03);; 165 A3->SetTitleOffset(0.); // Axis title automatically placed; 166 A3->Draw();; 167}; 168End_Macro; 169 ; 170Note that this functionality has some limitations and does not follow all the TGaxis setting.; 171In particular the number of divisions or the maximum number digits do not apply.; 172 ; 173\anchor GA02; 174## Logarithmic axis; 175 ; 176By default axis are linear. To define a `TGaxis` as logarithmic, it is; 177enough to create it with the option `""G""`.; 178 ; 179When plotting an histogram or a graph the logarithmic scale can be set using:; 180 ; 181 - `gPad->SetLogx(1);` set the logarithmic scale on the X axis; 182 - `gPad->SetLogy(1);` set the logarithmic scale on the Y axis; 183 ; 184When the `SetMoreLogLabels()` method is called more labels are drawn; 185when in logarithmic scale and there is a small number of decades (less than 3).; 186 ; 187\anchor GA03; 188## Blank axis; 189To draw only the axis tick marks without the axis body, it is enough to specify; 190the option `""B""`. It useful to superpose axis.; 191 ; 192\anchor GA03a; 193## Arrow on axis; 194\since **ROOT version 6.27/01:**; 195 ; 196To draw an arrow at the end of the axis use the option `"">""`. To draw it at the beginning; 197of the axis use the option `""<""`. To draw it on both ends use `""<>""`.; 198 ; 199Begin_Macro(source); 200{; 201 auto c = new TCanvas(""c"",""c"",0,0,500,500);; 202 c->Range(-11,-11,11,11);; 203 ; 204 auto f2 = new TF1(""x2"",""x*x"",-10,10);; 205 f2->SetLineColor(kRed);; 206 f2->Draw(""same"");; 207 ; 208 auto f3 = new TF1(""x3"",""x*x*x"",-10,10);; 209 f3->SetLineColor(kBlue);; 210 f3->Draw(""same"");; 211 ; 212 // Draw the axis with arrows; 213 auto ox ",MatchSource.WIKI,doc/master/TGaxis_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGaxis_8cxx_source.html
https://root.cern/doc/master/TGaxis_8cxx_source.html:6676,Testability,log,logarithmic,6676," A2->SetTitle(""exponential axis"");; 155 A2->SetLabelSize(0.03);; 156 A2->SetTitleSize(0.03);; 157 A2->SetTitleOffset(1.2);; 158 A2->Draw();; 159 ; 160 TF1 *f3=new TF1(""f3"",""log10(x)"",1,1000);; 161 TGaxis *A3 = new TGaxis(2,-2,2,0,""f3"",505,"""");; 162 A3->SetTitle(""logarithmic axis"");; 163 A3->SetLabelSize(0.02);; 164 A3->SetTitleSize(0.03);; 165 A3->SetTitleOffset(0.); // Axis title automatically placed; 166 A3->Draw();; 167}; 168End_Macro; 169 ; 170Note that this functionality has some limitations and does not follow all the TGaxis setting.; 171In particular the number of divisions or the maximum number digits do not apply.; 172 ; 173\anchor GA02; 174## Logarithmic axis; 175 ; 176By default axis are linear. To define a `TGaxis` as logarithmic, it is; 177enough to create it with the option `""G""`.; 178 ; 179When plotting an histogram or a graph the logarithmic scale can be set using:; 180 ; 181 - `gPad->SetLogx(1);` set the logarithmic scale on the X axis; 182 - `gPad->SetLogy(1);` set the logarithmic scale on the Y axis; 183 ; 184When the `SetMoreLogLabels()` method is called more labels are drawn; 185when in logarithmic scale and there is a small number of decades (less than 3).; 186 ; 187\anchor GA03; 188## Blank axis; 189To draw only the axis tick marks without the axis body, it is enough to specify; 190the option `""B""`. It useful to superpose axis.; 191 ; 192\anchor GA03a; 193## Arrow on axis; 194\since **ROOT version 6.27/01:**; 195 ; 196To draw an arrow at the end of the axis use the option `"">""`. To draw it at the beginning; 197of the axis use the option `""<""`. To draw it on both ends use `""<>""`.; 198 ; 199Begin_Macro(source); 200{; 201 auto c = new TCanvas(""c"",""c"",0,0,500,500);; 202 c->Range(-11,-11,11,11);; 203 ; 204 auto f2 = new TF1(""x2"",""x*x"",-10,10);; 205 f2->SetLineColor(kRed);; 206 f2->Draw(""same"");; 207 ; 208 auto f3 = new TF1(""x3"",""x*x*x"",-10,10);; 209 f3->SetLineColor(kBlue);; 210 f3->Draw(""same"");; 211 ; 212 // Draw the axis with arrows; 213 auto ox ",MatchSource.WIKI,doc/master/TGaxis_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGaxis_8cxx_source.html
https://root.cern/doc/master/TGaxis_8cxx_source.html:15241,Testability,log,log,15241,"ions(10, 5, 0, kTRUE);; 384~~~; 385\anchor GA12; 386## Maximum Number of Digits for the axis labels; 387 ; 388The static method `TGaxis::SetMaxDigits` sets the maximum number of; 389digits permitted for the axis labels above which the notation with 10^N is used.; 390For example, to accept 6 digits number like 900000 on an axis call; 391`TGaxis::SetMaxDigits(6)`. The default value is 5.; 392`fgMaxDigits` must be greater than 0.; 393Warning: even when called on a particular TGaxis* instance, this static function; 394changes globally the number of digits for all axes (X, Y, ...) in the canvas.; 395If you want to change the maximum number of digits N only of the current TGaxis*,; 396and not all the others, use axis->SetNdivisions(N*1000000 + (axis->GetNdiv()%1000000)); 397instead of axis->SetMaxDigits(N).; 398 ; 399\anchor GA13; 400## Optional grid; 401 ; 402The option `""W""` allows to draw a grid on the primary tick marks. In case; 403of a log axis, the grid is only drawn for the primary tick marks if the number; 404of secondary and tertiary divisions is 0. `SetGridLength()` allows to define; 405the length of the grid.; 406 ; 407When plotting an histogram or a graph the grid can be set ON or OFF using:; 408 ; 409 - `gPad->SetGridy(1);` set the grid on the X axis; 410 - `gPad->SetGridx(1);` set the grid on the Y axis; 411 - `gPad->SetGrid(1,1);` set the grid on both axis.; 412 ; 413\anchor GA14; 414## Time axis; 415 ; 416Histograms' axis can be defined as ""time axis"". To do that it is enough to activate; 417the TAxis::SetTimeDisplay attribute on a given axis. If `h` is an histogram, it is; 418done the following way:; 419 ; 420~~~ {.cpp}; 421 h->GetXaxis()->SetTimeDisplay(1); // The X axis is a time axis; 422~~~; 423 ; 424Two parameters can be adjusted in order to define time axis:; 425 ; 426### The time format:; 427 ; 428Defines the format of the labels along the time axis. It can be changed using the TAxis; 429TAxis::SetTimeFormat. The time format is the one used by the ",MatchSource.WIKI,doc/master/TGaxis_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGaxis_8cxx_source.html
https://root.cern/doc/master/TGaxis_8cxx_source.html:20921,Testability,test,test,20921,">SetTimeDisplay(1);; 539 ht3->GetXaxis()->SetTimeOffset(dh.Convert());; 540 ht3->Draw();; 541}; 542End_Macro; 543 ; 544The histogram limits times in seconds. If `wmin` and `wmax` are the histogram; 545limits, the time axis will spread around the time offset value from `TimeOffset+wmin`; 546to `TimeOffset+wmax`. Until now all the examples had a lowest value equal to 0.; 547The following example demonstrates how to define the histogram limits relatively; 548to the time offset value.; 549 ; 550Begin_Macro(source); 551{; 552 // Define the time offset as 2003, January 1st; 553 TDatime T0(2003,1,1,0,0,0);; 554 auto X0 = T0.Convert();; 555 gStyle->SetTimeOffset(X0);; 556 ; 557 // Define the lowest histogram limit as 2002, September 23rd; 558 TDatime T1(2002,9,23,0,0,0);; 559 auto X1 = T1.Convert()-X0;; 560 ; 561 // Define the highest histogram limit as 2003, March 7th; 562 TDatime T2(2003,3,7,0,0,0);; 563 auto X2 = T2.Convert(1)-X0;; 564 ; 565 auto h1 = new TH1F(""h1"",""test"",100,X1,X2);; 566 ; 567 TRandom r;; 568 for (Int_t i=0;i<30000;i++) {; 569 Double_t noise = r.Gaus(0.5*(X1+X2),0.1*(X2-X1));; 570 h1->Fill(noise);; 571 }; 572 ; 573 h1->GetXaxis()->SetTimeDisplay(1);; 574 h1->GetXaxis()->SetLabelSize(0.03);; 575 h1->GetXaxis()->SetTimeFormat(""%Y/%m/%d"");; 576 h1->Draw();; 577}; 578End_Macro; 579 ; 580 ; 581Usually time axis are created automatically via histograms, but one may also want; 582to draw a time axis outside an ""histogram context"". Therefore it is useful to; 583understand how TGaxis works for such axis.; 584 ; 585The time offset can be defined using one of the three methods described before.; 586The time axis will spread around the time offset value. Actually it will go from; 587`TimeOffset+wmin` to `TimeOffset+wmax` where `wmin` and `wmax` are the minimum; 588and maximum values (in seconds) of the axis. Let's take again an example. Having; 589defined ""2003, February 28 at 12h"" we would like to see the axis a day before and; 590a day after. A TGaxis can be crea",MatchSource.WIKI,doc/master/TGaxis_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGaxis_8cxx_source.html
https://root.cern/doc/master/TGaxis_8cxx_source.html:24298,Testability,test,test,24298,"e(0.2);; 637 ; 638 TDatime da(2003,02,28,12,00,00);; 639 axis->SetTimeOffset(da.Convert());; 640 axis->SetLabelOffset(0.15);; 641 axis->SetTimeFormat(""#splitline{%Y}{%d/%m}"");; 642 axis->Draw();; 643 return c1;; 644}; 645End_Macro; 646 ; 647 ; 648The following example shows time axis on a TGraph:; 649 ; 650Begin_Macro(source); 651{; 652 TDatime da1(2008,02,28,15,52,00);; 653 TDatime da2(2008,02,28,15,53,00);; 654 ; 655 double x[2],y[2];; 656 ; 657 y[0] = 1.;; 658 y[1] = 2.;; 659 x[0] = da1.Convert();; 660 x[1] = da2.Convert();; 661 ; 662 TGraph mgr(2,x,y);; 663 mgr.SetMarkerStyle(20);; 664 ; 665 mgr.Draw(""apl"");; 666 mgr.GetXaxis()->SetTimeDisplay(1);; 667 mgr.GetXaxis()->SetNdivisions(-503);; 668 mgr.GetXaxis()->SetTimeFormat(""%Y-%m-%d %H:%M"");; 669 mgr.GetXaxis()->SetTimeOffset(0,""gmt"");; 670}; 671End_Macro; 672 ; 673The following example compares what the system time function `gmtime`; 674and `localtime` give with what gives `TGaxis`. It can be used; 675as referenced test to check if the time option of `TGaxis` is working properly.; 676 ; 677Begin_Macro(source); 678../../../tutorials/graphs/timeonaxis3.C; 679End_Macro; 680 ; 681 ; 682The following macro illustrates the use, with histograms axis, of the time mode on the axis; 683with different time intervals and time formats.; 684 ; 685Begin_Macro(source); 686../../../tutorials/graphs/timeonaxis.C; 687End_Macro; 688 ; 689*/; 690 ; 691////////////////////////////////////////////////////////////////////////////////; 692/// TGaxis default constructor.; 693 ; 694TGaxis::TGaxis(): TLine(), TAttText(11,0,1,62,0.040); 695{; 696 ; 697 fGridLength = 0.;; 698 fLabelOffset = 0.005;; 699 fLabelSize = 0.040;; 700 fLabelFont = 62;; 701 fLabelColor = 1;; 702 fTickSize = 0.030;; 703 fTitleOffset = 1;; 704 fTitleSize = fLabelSize;; 705 fChopt = """";; 706 fName = """";; 707 fTitle = """";; 708 fTimeFormat = """";; 709 fFunctionName= """";; 710 fFunction = nullptr;; 711 fAxis = nullptr;; 712 fNdiv = 0;; 713 fNModLabs = 0;; 714 fModLabs = null",MatchSource.WIKI,doc/master/TGaxis_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGaxis_8cxx_source.html
https://root.cern/doc/master/TGaxis_8cxx_source.html:34498,Testability,log,log,34498,"->GetTitleSize());; 972 SetBit(TAxis::kCenterTitle, axis->TestBit(TAxis::kCenterTitle));; 973 SetBit(TAxis::kCenterLabels, axis->TestBit(TAxis::kCenterLabels));; 974 SetBit(TAxis::kRotateTitle, axis->TestBit(TAxis::kRotateTitle));; 975 SetBit(TAxis::kNoExponent, axis->TestBit(TAxis::kNoExponent));; 976 SetBit(TAxis::kTickPlus, axis->TestBit(TAxis::kTickPlus));; 977 SetBit(TAxis::kTickMinus, axis->TestBit(TAxis::kTickMinus));; 978 SetBit(TAxis::kMoreLogLabels, axis->TestBit(TAxis::kMoreLogLabels));; 979 if (axis->GetDecimals()) SetBit(TAxis::kDecimals); //the bit is in TAxis::fAxis2; 980 SetTimeFormat(axis->GetTimeFormat());; 981}; 982 ; 983////////////////////////////////////////////////////////////////////////////////; 984/// Draw this axis with its current attributes.; 985 ; 986void TGaxis::Paint(Option_t *); 987{; 988 if (!gPad) return;; 989 ; 990 Double_t wmin = fWmin;; 991 Double_t wmax = fWmax;; 992 Int_t ndiv = fNdiv;; 993 ; 994 // following code required to support toggle of lin/log scales; 995 Double_t x1 = gPad->XtoPad(fX1);; 996 Double_t y1 = gPad->YtoPad(fY1);; 997 Double_t x2 = gPad->XtoPad(fX2);; 998 Double_t y2 = gPad->YtoPad(fY2);; 999 ; 1000 PaintAxis(x1,y1,x2,y2,wmin,wmax,ndiv,fChopt.Data(),fGridLength);; 1001}; 1002 ; 1003////////////////////////////////////////////////////////////////////////////////; 1004/// Control function to draw an axis.; 1005/// Original authors: O.Couet C.E.Vandoni N.Cremel-Somon.; 1006/// Modified and converted to C++ class by Rene Brun.; 1007 ; 1008void TGaxis::PaintAxis(Double_t xmin, Double_t ymin, Double_t xmax, Double_t ymax,; 1009 Double_t &wmin, Double_t &wmax, Int_t &ndiv, Option_t *chopt,; 1010 Double_t gridlength, Bool_t drawGridOnly); 1011{; 1012 if (!gPad) return;; 1013 ; 1014 const char *where = ""PaintAxis"";; 1015 ; 1016 Double_t alfa, beta, ratio1, ratio2, grid_side;; 1017 Double_t axis_lengthN = 0;; 1018 Double_t axis_length0 = 0;; 1019 Double_t axis_length1 = 0;; 1020 Double_t axis_length;; 1021 Double_t at",MatchSource.WIKI,doc/master/TGaxis_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGaxis_8cxx_source.html
https://root.cern/doc/master/TGaxis_8cxx_source.html:44499,Testability,log,logarithmic,44499,"1556736; // months (average # days); 1231 rangeOffset = (Double_t) ((Long_t)(timeoffset)%rangeBase);; 1232 if (range>31536000) {; 1233 tp0 = gmtime(&timetp);; 1234 tp0->tm_mon = 0;; 1235 tp0->tm_mday = 1;; 1236 tp0->tm_hour = 0;; 1237 tp0->tm_min = 0;; 1238 tp0->tm_sec = 0;; 1239 tp0->tm_isdst = 1; // daylight saving time is on.; 1240 rangeBase = (timetp-mktime(tp0)); // years; 1241 rangeOffset = (Double_t) (rangeBase);; 1242 }; 1243 wmax += rangeOffset;; 1244 wmin += rangeOffset;; 1245 }; 1246 ; 1247// Determine number of divisions 1, 2 and 3 and the maximum digits for this axis; 1248 n1a = (ndiv%100);; 1249 n2a = (ndiv%10000 - n1a)/100;; 1250 n3a = (ndiv%1000000 - n2a -n1a)/10000;; 1251 nn3 = TMath::Max(n3a,1);; 1252 nn2 = TMath::Max(n2a,1)*nn3;; 1253 nn1 = TMath::Max(n1a,1)*nn2+1;; 1254 nticks = nn1;; 1255 maxDigits = (ndiv/1000000);; 1256 if (maxDigits==0) maxDigits = gStyle->GetAxisMaxDigits();; 1257 ; 1258// Axis bining optimisation is ignored if:; 1259// - the first and the last label are equal; 1260// - the number of divisions is 0; 1261// - less than 1 primary division is requested; 1262// - logarithmic scale is requested; 1263 ; 1264 if (wmin == wmax || ndiv == 0 || n1a <= 1 || optionLog) {; 1265 optionNoopt = 1;; 1266 optionInt = 0;; 1267 }; 1268 ; 1269// Axis bining optimisation; 1270 if ( (wmax-wmin) < 1 && optionInt) {; 1271 Error(where, ""option I not available"");; 1272 optionInt = 0;; 1273 }; 1274 if (!optionNoopt || optionInt ) {; 1275 ; 1276// Primary divisions optimisation; 1277// When integer labelling is required, Optimize is invoked first; 1278// and only if the result is not an integer labelling, AdjustBinSize is invoked.; 1279 ; 1280 THLimitsFinder::Optimize(wmin,wmax,n1a,binLow,binHigh,nbins,binWidth,fChopt.Data());; 1281 if (optionInt) {; 1282 if (binLow != Double_t(int(binLow)) || binWidth != Double_t(int(binWidth))) {; 1283 AdjustBinSize(wmin,wmax,n1a,binLow,binHigh,nbins,binWidth);; 1284 }; 1285 }; 1286 if ((wmin-binLow) > epsilon) { binLo",MatchSource.WIKI,doc/master/TGaxis_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGaxis_8cxx_source.html
https://root.cern/doc/master/TGaxis_8cxx_source.html:73660,Testability,log,logarithmic,73660,"atex; 2139 textaxis.SetTextFont((Int_t)(GetLabelFont()/10)*10+2);; 2140 if (fAxis && !strcmp(fAxis->GetName(),""xaxis"")) {; 2141 Float_t xoff = 0., yoff = 0.;; 2142 gStyle->GetExponentOffset(xoff, yoff, ""x"");; 2143 xx += xoff;; 2144 yy += yoff;; 2145 }; 2146 if (fAxis && !strcmp(fAxis->GetName(),""yaxis"")) {; 2147 Float_t xoff = 0., yoff = 0.;; 2148 gStyle->GetExponentOffset(xoff, yoff, ""y"");; 2149 xx += xoff;; 2150 yy += yoff;; 2151 }; 2152 typolabel = label;; 2153 typolabel.ReplaceAll(""-"", ""#minus"");; 2154 textaxis.PaintLatex(gPad->GetX1() + xx*(gPad->GetX2() - gPad->GetX1()),; 2155 gPad->GetY1() + yy*(gPad->GetY2() - gPad->GetY1()),; 2156 0,; 2157 textaxis.GetTextSize(),; 2158 typolabel.Data());; 2159 }; 2160 }; 2161 }; 2162 }; 2163 ; 2164// Log axis; 2165 ; 2166 if (optionLog && ndiv) {; 2167 UInt_t xi1=0,xi2=0,wi=0,yi1=0,yi2=0,hi=0,xl=0,xh=0;; 2168 Bool_t firstintlab = kTRUE, overlap = kFALSE;; 2169 if ((wmin == wmax) || (ndiv == 0)) {; 2170 Error(where, ""wmin (%f) == wmax (%f), or ndiv == 0"", wmin, wmax);; 2171 return;; 2172 }; 2173 if (wmin <= 0) {; 2174 Error(where, ""negative logarithmic axis"");; 2175 return;; 2176 }; 2177 if (wmax <= 0) {; 2178 Error(where, ""negative logarithmic axis"");; 2179 return;; 2180 }; 2181 xmnlog = TMath::Log10(wmin);; 2182 if (xmnlog > 0) xmnlog += 1.E-6;; 2183 else xmnlog -= 1.E-6;; 2184 x00 = 0;; 2185 x11 = axis_length;; 2186 h2 = TMath::Log10(wmax);; 2187 h2sav = h2;; 2188 if (h2 > 0) h2 += 1.E-6;; 2189 else h2 -= 1.E-6;; 2190 ih1 = int(xmnlog);; 2191 ih2 = 1+int(h2);; 2192 nbinin = ih2-ih1+1;; 2193 axmul = (x11-x00)/(h2sav-xmnlog);; 2194 ; 2195// Plot decade and intermediate tick marks; 2196 decade = ih1-2;; 2197 labelnumber = ih1;; 2198 if ( xmnlog > 0 && (xmnlog-Double_t(ih1) > 0) ) labelnumber++;; 2199 Int_t changelablogid = 0;; 2200 Int_t changelablognum = 0;; 2201 for (j=1; j<=nbinin; j++) {; 2202 ; 2203// Plot decade; 2204 firstintlab = kTRUE, overlap = kFALSE;; 2205 decade++;; 2206 if (x0 == x1 && j == 1) ylabel += charheig",MatchSource.WIKI,doc/master/TGaxis_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGaxis_8cxx_source.html
https://root.cern/doc/master/TGaxis_8cxx_source.html:73754,Testability,log,logarithmic,73754,"atex; 2139 textaxis.SetTextFont((Int_t)(GetLabelFont()/10)*10+2);; 2140 if (fAxis && !strcmp(fAxis->GetName(),""xaxis"")) {; 2141 Float_t xoff = 0., yoff = 0.;; 2142 gStyle->GetExponentOffset(xoff, yoff, ""x"");; 2143 xx += xoff;; 2144 yy += yoff;; 2145 }; 2146 if (fAxis && !strcmp(fAxis->GetName(),""yaxis"")) {; 2147 Float_t xoff = 0., yoff = 0.;; 2148 gStyle->GetExponentOffset(xoff, yoff, ""y"");; 2149 xx += xoff;; 2150 yy += yoff;; 2151 }; 2152 typolabel = label;; 2153 typolabel.ReplaceAll(""-"", ""#minus"");; 2154 textaxis.PaintLatex(gPad->GetX1() + xx*(gPad->GetX2() - gPad->GetX1()),; 2155 gPad->GetY1() + yy*(gPad->GetY2() - gPad->GetY1()),; 2156 0,; 2157 textaxis.GetTextSize(),; 2158 typolabel.Data());; 2159 }; 2160 }; 2161 }; 2162 }; 2163 ; 2164// Log axis; 2165 ; 2166 if (optionLog && ndiv) {; 2167 UInt_t xi1=0,xi2=0,wi=0,yi1=0,yi2=0,hi=0,xl=0,xh=0;; 2168 Bool_t firstintlab = kTRUE, overlap = kFALSE;; 2169 if ((wmin == wmax) || (ndiv == 0)) {; 2170 Error(where, ""wmin (%f) == wmax (%f), or ndiv == 0"", wmin, wmax);; 2171 return;; 2172 }; 2173 if (wmin <= 0) {; 2174 Error(where, ""negative logarithmic axis"");; 2175 return;; 2176 }; 2177 if (wmax <= 0) {; 2178 Error(where, ""negative logarithmic axis"");; 2179 return;; 2180 }; 2181 xmnlog = TMath::Log10(wmin);; 2182 if (xmnlog > 0) xmnlog += 1.E-6;; 2183 else xmnlog -= 1.E-6;; 2184 x00 = 0;; 2185 x11 = axis_length;; 2186 h2 = TMath::Log10(wmax);; 2187 h2sav = h2;; 2188 if (h2 > 0) h2 += 1.E-6;; 2189 else h2 -= 1.E-6;; 2190 ih1 = int(xmnlog);; 2191 ih2 = 1+int(h2);; 2192 nbinin = ih2-ih1+1;; 2193 axmul = (x11-x00)/(h2sav-xmnlog);; 2194 ; 2195// Plot decade and intermediate tick marks; 2196 decade = ih1-2;; 2197 labelnumber = ih1;; 2198 if ( xmnlog > 0 && (xmnlog-Double_t(ih1) > 0) ) labelnumber++;; 2199 Int_t changelablogid = 0;; 2200 Int_t changelablognum = 0;; 2201 for (j=1; j<=nbinin; j++) {; 2202 ; 2203// Plot decade; 2204 firstintlab = kTRUE, overlap = kFALSE;; 2205 decade++;; 2206 if (x0 == x1 && j == 1) ylabel += charheig",MatchSource.WIKI,doc/master/TGaxis_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGaxis_8cxx_source.html
https://root.cern/doc/master/TGaxis_8cxx_source.html:90818,Testability,log,log,90818,"t(TAxis::kDecimals);; 2637 else ResetBit(TAxis::kDecimals);; 2638}; 2639 ; 2640////////////////////////////////////////////////////////////////////////////////; 2641/// Specify a function to map the axis values.; 2642 ; 2643void TGaxis::SetFunction(const char *funcname); 2644{; 2645 fFunctionName = funcname;; 2646 if (!funcname || !funcname[0]) {; 2647 fFunction = nullptr;; 2648 return;; 2649 }; 2650 fFunction = (TF1*)gROOT->GetFunction(funcname);; 2651 if (!fFunction) {; 2652 Error(""SetFunction"", ""unknown function: %s"", funcname);; 2653 } else {; 2654 fWmin = fFunction->GetXmin();; 2655 fWmax = fFunction->GetXmax();; 2656 }; 2657}; 2658 ; 2659////////////////////////////////////////////////////////////////////////////////; 2660/// Search for axis modifier by index or value; 2661 ; 2662TAxisModLab *TGaxis::FindModLab(Int_t indx, Int_t numlabels, Double_t v, Double_t eps) const; 2663{; 2664 if (!fModLabs); 2665 return nullptr;; 2666 ; 2667 TIter next(fModLabs);; 2668 while (auto ml = (TAxisModLab*)next()) {; 2669 ; 2670 if (ml->GetLabNum() == 0) {; 2671 if (TMath::Abs(v - ml->GetLabValue()) <= eps); 2672 return ml;; 2673 } else if (indx != 0) {; 2674 Bool_t match = ml->GetLabNum() == indx;; 2675 if (!match && (ml->GetLabNum() < 0) && (indx > 0) && (numlabels > 0)) {; 2676 if (TestBit(TAxis::kMoreLogLabels)) {; 2677 Error(""FindModLab"", ""reverse numbering in ChangeLabel doesn't work when more log labels are requested"");; 2678 return nullptr;; 2679 }; 2680 ; 2681 match = indx == (ml->GetLabNum() + 2 + numlabels);; 2682 }; 2683 if (match) return ml;; 2684 }; 2685 }; 2686 ; 2687 return nullptr;; 2688}; 2689 ; 2690 ; 2691////////////////////////////////////////////////////////////////////////////////; 2692/// Define new text attributes for the label number ""labNum"". It allows to do a; 2693/// fine tuning of the labels. All the attributes can be changed, even the; 2694/// label text itself.; 2695///; 2696/// \param[in] labNum Number of the label to be changed, negative numb",MatchSource.WIKI,doc/master/TGaxis_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGaxis_8cxx_source.html
https://root.cern/doc/master/TGaxis_8cxx_source.html:99451,Testability,log,logarithmic,99451,"tation with 10^N is used.For example, to accept 6 digits number like 900000; 2889/// on an axis call `TGaxis::SetMaxDigits(6)`. The default value is 5.; 2890/// `fgMaxDigits` must be greater than 0.; 2891/// Warning: this static function changes the max number of digits in all axes.; 2892/// If you only want to change the digits of the current TGaxis instance, use; 2893/// axis->SetNdivisions(N*1000000 + (axis->GetNdiv()%1000000)); 2894/// instead of axis->SetMaxDigits(N).; 2895 ; 2896void TGaxis::SetMaxDigits(Int_t maxd); 2897{; 2898 gStyle->SetAxisMaxDigits(maxd);; 2899}; 2900 ; 2901////////////////////////////////////////////////////////////////////////////////; 2902/// Change the name of the axis.; 2903 ; 2904void TGaxis::SetName(const char *name); 2905{; 2906 fName = name;; 2907}; 2908 ; 2909////////////////////////////////////////////////////////////////////////////////; 2910/// Set the kMoreLogLabels bit flag. When this option is selected more labels are; 2911/// drawn when in logarithmic scale and there is a small number of decades (less than 3).; 2912/// Note that this option is automatically inherited from TAxis; 2913 ; 2914void TGaxis::SetMoreLogLabels(Bool_t more); 2915{; 2916 if (more) SetBit(TAxis::kMoreLogLabels);; 2917 else ResetBit(TAxis::kMoreLogLabels);; 2918}; 2919 ; 2920////////////////////////////////////////////////////////////////////////////////; 2921/// Set the NoExponent flag. By default, an exponent of the form 10^N is used; 2922/// when the label values are either all very small or very large. One can disable; 2923/// the exponent by calling axis.SetNoExponent(kTRUE).; 2924 ; 2925void TGaxis::SetNoExponent(Bool_t noExponent); 2926{; 2927 if (noExponent) SetBit(TAxis::kNoExponent);; 2928 else ResetBit(TAxis::kNoExponent);; 2929}; 2930 ; 2931////////////////////////////////////////////////////////////////////////////////; 2932/// To set axis options.; 2933 ; 2934void TGaxis::SetOption(Option_t *option); 2935{; 2936 fChopt = option;; 2937};",MatchSource.WIKI,doc/master/TGaxis_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGaxis_8cxx_source.html
https://root.cern/doc/master/TGaxis_8cxx_source.html:130816,Testability,log,logarithm,130816," the notation with 10^N ...Definition TStyle.cxx:1880; TStyle::GetGridWidthWidth_t GetGridWidth() constDefinition TStyle.h:224; TStyle::GetStripDecimalsInt_t GetStripDecimals() constDefinition TStyle.h:268; TStyle::GetExponentOffsetvoid GetExponentOffset(Float_t &xoff, Float_t &yoff, Option_t *axis=""X"") constMethod returns X and Y offset of the axis 10^n notation.Definition TStyle.cxx:1855; TText::SetTextvirtual void SetText(Double_t x, Double_t y, const char *text)Definition TText.h:74; TTimeStamp::MktimeFromUTCstatic time_t MktimeFromUTC(tm_t *tmstruct)Equivalent of standard routine ""mktime"" but using the assumption that tm struct is filled with UTC,...Definition TTimeStamp.cxx:768; bool; double; int; unsigned int; yDouble_t y[n]Definition legend1.C:17; TMath::MaxShort_t Max(Short_t a, Short_t b)Returns the largest of a and b.Definition TMathBase.h:250; TMath::ATan2Double_t ATan2(Double_t y, Double_t x)Returns the principal value of the arc tangent of y/x, expressed in radians.Definition TMath.h:646; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662; TMath::PowerLongDouble_t Power(LongDouble_t x, LongDouble_t y)Returns x raised to the power y.Definition TMath.h:721; TMath::MinShort_t Min(Short_t a, Short_t b)Returns the smallest of a and b.Definition TMathBase.h:198; TMath::CosDouble_t Cos(Double_t)Returns the cosine of an angle of x radians.Definition TMath.h:594; TMath::Piconstexpr Double_t Pi()Definition TMath.h:37; TMath::SinDouble_t Sin(Double_t)Returns the sine of an angle of x radians.Definition TMath.h:588; TMath::Log10Double_t Log10(Double_t x)Returns the common (base-10) logarithm of x.Definition TMath.h:762; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123; v@ vDefinition rootcling_impl.cxx:3699; lTLine lDefinition textangle.C:4. graf2dgrafsrcTGaxis.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:18 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TGaxis_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGaxis_8cxx_source.html
https://root.cern/doc/master/TGaxis_8cxx_source.html:125688,Usability,simpl,simple,125688,":SetOptionvoid SetOption(Option_t *option="""")To set axis options.Definition TGaxis.cxx:2934; TGaxis::IsATClass * IsA() const overrideDefinition TGaxis.h:136; THLimitsFinder::Optimizestatic void Optimize(Double_t A1, Double_t A2, Int_t nold, Double_t &BinLow, Double_t &BinHigh, Int_t &nbins, Double_t &BWID, Option_t *option="""")Static function to compute reasonable axis limits.Definition THLimitsFinder.cxx:184; TIterDefinition TCollection.h:235; TLatexTo draw Mathematical Formula.Definition TLatex.h:18; TLatex::GetXsizeDouble_t GetXsize()Return size of the formula along X in pad coordinates when the text precision is smaller than 3.Definition TLatex.cxx:2569; TLatex::GetBoundingBoxvoid GetBoundingBox(UInt_t &w, UInt_t &h, Bool_t angle=kFALSE) overrideReturn text size in pixels.Definition TLatex.cxx:2600; TLatex::PaintLatexvirtual void PaintLatex(Double_t x, Double_t y, Double_t angle, Double_t size, const char *text)Main drawing function.Definition TLatex.cxx:2114; TLineUse the TLine constructor to create a simple line.Definition TLine.h:22; TLine::fY1Double_t fY1Y of 1st point.Definition TLine.h:26; TLine::fX1Double_t fX1X of 1st point.Definition TLine.h:25; TLine::fX2Double_t fX2X of 2nd point.Definition TLine.h:27; TLine::operator=TLine & operator=(const TLine &src)Assignment operator.Definition TLine.cxx:67; TLine::fY2Double_t fY2Y of 2nd point.Definition TLine.h:28; TLine::PaintLineNDCvirtual void PaintLineNDC(Double_t u1, Double_t v1, Double_t u2, Double_t v2)Draw this line with new coordinates in NDC.Definition TLine.cxx:409; TLine::Streamervoid Streamer(TBuffer &) overrideStream an object of class TLine.Definition TLine.cxx:518; TListA doubly linked list.Definition TList.h:38; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TList::Deletevoid Delete(Option_t *option="""") overrideRemove all objects from the list AND delete all heap based objects.Definition TList.cxx:468; TNamed::SetTitlevirtual void SetTitle(const char *title="""")Set the title of th",MatchSource.WIKI,doc/master/TGaxis_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGaxis_8cxx_source.html
https://root.cern/doc/master/TGaxis_8h.html:238,Integrability,depend,dependency,238,". ROOT: graf2d/graf/inc/TGaxis.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; TGaxis.h File Reference. #include ""TLine.h""; #include ""TAttText.h""; #include ""TString.h"". Include dependency graph for TGaxis.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  TGaxis;  The axis painter class. More...;  . graf2dgrafincTGaxis.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:16 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TGaxis_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGaxis_8h.html
https://root.cern/doc/master/TGaxis_8h_source.html:17866,Usability,simpl,simple,17866,"stDefinition TGaxis.h:88; TGaxis::Paintvoid Paint(Option_t *chopt="""") overrideDraw this axis with its current attributes.Definition TGaxis.cxx:986; TGaxis::fNModLabsInt_t fNModLabsNumber of modified labels.Definition TGaxis.h:39; TGaxis::fWminDouble_t fWminLowest value on the axis.Definition TGaxis.h:28; TGaxis::SetLabelSizevoid SetLabelSize(Float_t labelsize)Definition TGaxis.h:107; TGaxis::SetFunctionvoid SetFunction(const char *funcname="""")Specify a function to map the axis values.Definition TGaxis.cxx:2643; TGaxis::SetNamevirtual void SetName(const char *name)Change the name of the axis.Definition TGaxis.cxx:2904; TGaxis::SetExponentOffsetstatic void SetExponentOffset(Float_t xoff=0., Float_t yoff=0., Option_t *axis=""xy"")Static method to set X and Y offset of the axis 10^n notation.Definition TGaxis.cxx:3035; TGaxis::LabelsLimitsvoid LabelsLimits(const char *label, Int_t &first, Int_t &last)Internal method to find first and last character of a label.Definition TGaxis.cxx:2533; TGaxis::GetWmaxDouble_t GetWmax() constDefinition TGaxis.h:90; TGaxis::IsOwnedModLabsBool_t IsOwnedModLabs() constReturns kTRUE when fModLabs owned by TGaxis and should be cleaned up.Definition TGaxis.cxx:869; TGaxis::ResetLabelAttributesvoid ResetLabelAttributes(TLatex *t)Helper method used by TGaxis::ChangeLabel.Definition TGaxis.cxx:2880; TGaxis::GetLabelSizeFloat_t GetLabelSize() constDefinition TGaxis.h:81; TGaxis::SetOptionvoid SetOption(Option_t *option="""")To set axis options.Definition TGaxis.cxx:2934; TLatexTo draw Mathematical Formula.Definition TLatex.h:18; TLineUse the TLine constructor to create a simple line.Definition TLine.h:22; TListA doubly linked list.Definition TList.h:38; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; bool; double; int; v@ vDefinition rootcling_impl.cxx:3699. graf2dgrafincTGaxis.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:18 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TGaxis_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGaxis_8h_source.html
https://root.cern/doc/master/TGButton_8h_source.html:2652,Availability,down,down,2652,,MatchSource.WIKI,doc/master/TGButton_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGButton_8h_source.html
https://root.cern/doc/master/TGButton_8h_source.html:24694,Availability,down,downDefinition,24694,"const TGButton &)=delete; TGButton::fStateEButtonState fStatebutton stateDefinition TGButton.h:75; TGButton::SetEnabledvirtual void SetEnabled(Bool_t e=kTRUE)Set enabled or disabled state of button.Definition TGButton.cxx:459; TGButton::fgDefaultGCstatic const TGGC * fgDefaultGCDefinition TGButton.h:88; TGButton::~TGButton~TGButton() overrideDelete button.Definition TGButton.cxx:221; TGButton::SetStatevirtual void SetState(EButtonState state, Bool_t emit=kFALSE)Set button state.Definition TGButton.cxx:235; TGButton::fTipTGToolTip * fTiptool tip associated with buttonDefinition TGButton.h:79; TGButton::Toggledvirtual void Toggled(Bool_t on)Definition TGButton.h:136; TGButton::SetToggleButtonvirtual void SetToggleButton(Bool_t)Definition TGButton.h:85; TGButton::IsDownvirtual Bool_t IsDown() constDefinition TGButton.cxx:301; TGButton::HandleCrossingBool_t HandleCrossing(Event_t *event) overrideHandle mouse crossing event.Definition TGButton.cxx:404; TGButton::fStayDownBool_t fStayDowntrue if button has to stay downDefinition TGButton.h:76; TGButton::fNormGCGContext_t fNormGCgraphics context used for drawing buttonDefinition TGButton.h:77; TGCheckButtonSelects different options.Definition TGButton.h:264; TGCheckButton::fOffconst TGPicture * fOffbutton OFF pictureDefinition TGButton.h:274; TGCheckButton::fgDefaultFontstatic const TGFont * fgDefaultFontDefinition TGButton.h:283; TGCheckButton::fgDefaultGCstatic const TGGC * fgDefaultGCDefinition TGButton.h:284; TGCheckButton::HandleKeyBool_t HandleKey(Event_t *event) overrideHandle key event. This function will be called when the hotkey is hit.Definition TGButton.cxx:1403; TGCheckButton::fOnconst TGPicture * fOnbutton ON pictureDefinition TGButton.h:273; TGCheckButton::Initvoid Init()Common check button initialization.Definition TGButton.cxx:1179; TGCheckButton::HandleButtonBool_t HandleButton(Event_t *event) overrideHandle mouse button event.Definition TGButton.cxx:1330; TGCheckButton::GetDefaultGCstatic const TGGC & Get",MatchSource.WIKI,doc/master/TGButton_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGButton_8h_source.html
https://root.cern/doc/master/TGButton_8h_source.html:3287,Deployability,release,released,3287,"p;; 64class TGButtonGroup;; 65class TGPopupMenu;; 66class TGTextLayout;; 67 ; 68class TGButton : public TGFrame, public TGWidget {; 69 ; 70friend class TGButtonGroup;; 71 ; 72protected:; 73 UInt_t fTWidth; ///< button width; 74 UInt_t fTHeight; ///< button height; 75 EButtonState fState; ///< button state; 76 Bool_t fStayDown; ///< true if button has to stay down; 77 GContext_t fNormGC; ///< graphics context used for drawing button; 78 void *fUserData; ///< pointer to user data structure; 79 TGToolTip *fTip; ///< tool tip associated with button; 80 TGButtonGroup *fGroup; ///< button group this button belongs to; 81 Pixel_t fBgndColor; ///< actual background color; 82 Pixel_t fHighColor; ///< highlight color; 83 UInt_t fStyle; ///< button style (modern or classic); 84 ; 85 virtual void SetToggleButton(Bool_t) {}; 86 virtual void EmitSignals(Bool_t wasUp);; 87 ; 88 static const TGGC *fgDefaultGC;; 89 static const TGGC *fgHibckgndGC;; 90 ; 91 static Window_t fgReleaseBtn; // the last released button; 92 ; 93private:; 94 TGButton(const TGButton&) = delete;; 95 TGButton& operator=(const TGButton&) = delete;; 96 ; 97public:; 98 static const TGGC &GetDefaultGC();; 99 static const TGGC &GetHibckgndGC();; 100 ; 101 TGButton(const TGWindow *p = nullptr, Int_t id = -1, GContext_t norm = GetDefaultGC()(),; 102 UInt_t option = kRaisedFrame | kDoubleBorder);; 103 ~TGButton() override;; 104 ; 105 Bool_t HandleButton(Event_t *event) override;; 106 Bool_t HandleCrossing(Event_t *event) override;; 107 virtual void SetUserData(void *userData) { fUserData = userData; }; 108 virtual void *GetUserData() const { return fUserData; }; 109 virtual void SetToolTipText(const char *text, Long_t delayms = 400); //*MENU*; 110 virtual TGToolTip *GetToolTip() const { return fTip; }; 111 virtual void SetState(EButtonState state, Bool_t emit = kFALSE);; 112 virtual EButtonState GetState() const { return fState; }; 113 virtual void AllowStayDown(Bool_t a) { fStayDown = a; }; 114 virtual void SetGroup(T",MatchSource.WIKI,doc/master/TGButton_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGButton_8h_source.html
https://root.cern/doc/master/TGButton_8h_source.html:1709,Integrability,message,message,1709,"TGRadioButton //; 19// and TGSplitButton //; 20// //; 21// This header defines all GUI button widgets. //; 22// //; 23// TGButton is a button abstract base class. It defines general button //; 24// behaviour. //; 25// //; 26// Selecting a text or picture button will generate the event: //; 27// kC_COMMAND, kCM_BUTTON, button id, user data. //; 28// //; 29// Selecting a check button will generate the event: //; 30// kC_COMMAND, kCM_CHECKBUTTON, button id, user data. //; 31// //; 32// Selecting a radio button will generate the event: //; 33// kC_COMMAND, kCM_RADIOBUTTON, button id, user data. //; 34// //; 35// If a command string has been specified (via SetCommand()) then this //; 36// command string will be executed via the interpreter whenever a //; 37// button is selected. A command string can contain the macros: //; 38// $MSG -- kC_COMMAND, kCM[CHECK|RADIO]BUTTON packed message //; 39// (use GET_MSG() and GET_SUBMSG() to unpack) //; 40// $PARM1 -- button id //; 41// $PARM2 -- user data pointer //; 42// Before executing these macros are expanded into the respective //; 43// Long_t's //; 44// //; 45//////////////////////////////////////////////////////////////////////////; 46 ; 47#include ""TGFrame.h""; 48#include ""TGWidget.h""; 49 ; 50//--- Button states; 51 ; 52enum EButtonState {; 53 kButtonUp,; 54 kButtonDown,; 55 kButtonEngaged,; 56 kButtonDisabled; 57};; 58 ; 59 ; 60class TGWidget;; 61class TGHotString;; 62class TGPicture;; 63class TGToolTip;; 64class TGButtonGroup;; 65class TGPopupMenu;; 66class TGTextLayout;; 67 ; 68class TGButton : public TGFrame, public TGWidget {; 69 ; 70friend class TGButtonGroup;; 71 ; 72protected:; 73 UInt_t fTWidth; ///< button width; 74 UInt_t fTHeight; ///< button height; 75 EButtonState fState; ///< button state; 76 Bool_t fStayDown; ///< true if button has to stay down; 77 GContext_t fNormGC; ///< graphics context used for drawing button; 78 void *fUserData; ///< pointer to user data structure; 79 TGToolTip *fTip; ///< tool tip associ",MatchSource.WIKI,doc/master/TGButton_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGButton_8h_source.html
https://root.cern/doc/master/TGButton_8h_source.html:5934,Integrability,wrap,wrap,5934,"E* *GETTER=IsEnabled; 125 virtual UInt_t GetStyle() const { return fStyle; }; 126 virtual void SetStyle(UInt_t newstyle);; 127 virtual void SetStyle(const char *style);; 128 ; 129 void SavePrimitive(std::ostream &out, Option_t *option = """") override;; 130 ; 131 GContext_t GetNormGC() const { return fNormGC; }; 132 ; 133 virtual void Pressed() { Emit(""Pressed()""); } // *SIGNAL*; 134 virtual void Released() { Emit(""Released()""); } // *SIGNAL*; 135 virtual void Clicked() { Emit(""Clicked()""); } // *SIGNAL*; 136 virtual void Toggled(Bool_t on) { Emit(""Toggled(Bool_t)"", on); } // *SIGNAL*; 137 ; 138 ClassDefOverride(TGButton,0) // Button widget abstract base class; 139};; 140 ; 141 ; 142class TGTextButton : public TGButton {; 143 ; 144protected:; 145 TGHotString *fLabel; // button text; 146 Int_t fMLeft; // margin left; 147 Int_t fMRight; // margin right; 148 Int_t fMTop; // margin top; 149 Int_t fMBottom; // margin bottom; 150 Int_t fTMode; // text justify mode; 151 Int_t fWrapLength; // wrap length; 152 Int_t fHKeycode; // hotkey; 153 TGTextLayout *fTLayout; // text layout; 154 FontStruct_t fFontStruct; // font to draw text; 155 Bool_t fHasOwnFont; // kTRUE - font defined locally, kFALSE - globally; 156 Bool_t fStateOn; // bit to save the state across disable/enable; 157 Bool_t fPrevStateOn; // bit to save previous state On/Off; 158 ; 159 static const TGFont *fgDefaultFont;; 160 ; 161 void Init();; 162 void DoRedraw() override;; 163 ; 164private:; 165 TGTextButton(const TGTextButton&) = delete;; 166 TGTextButton& operator=(const TGTextButton&) = delete;; 167 ; 168public:; 169 static FontStruct_t GetDefaultFontStruct();; 170 ; 171 TGTextButton(const TGWindow *p, TGHotString *s, Int_t id = -1,; 172 GContext_t norm = GetDefaultGC()(),; 173 FontStruct_t font = GetDefaultFontStruct(),; 174 UInt_t option = kRaisedFrame | kDoubleBorder);; 175 TGTextButton(const TGWindow *p = nullptr, const char *s = nullptr, Int_t id = -1,; 176 GContext_t norm = GetDefaultGC()(),; 177 FontStruc",MatchSource.WIKI,doc/master/TGButton_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGButton_8h_source.html
https://root.cern/doc/master/TGButton_8h_source.html:37876,Integrability,wrap,wraps,37876,"Button::operator=TGSplitButton & operator=(const TGSplitButton &)=delete; TGSplitButton::fHeighestLabelTGString fHeighestLabelhighest label that can be on the buttonDefinition TGButton.h:406; TGSplitButton::fTBWidthUInt_t fTBWidthwidth of text buttonDefinition TGButton.h:398; TGSplitButton::MBPressedvirtual void MBPressed()Definition TGButton.h:438; TGSplitButton::SetMBStatevirtual void SetMBState(EButtonState state)Set the state of the Menu Button part.Definition TGButton.cxx:2883; TGSplitButton::fKeyNavigateBool_t fKeyNavigatekTRUE if key navigation is being usedDefinition TGButton.h:404; TGSplitButton::SetSplitvirtual void SetSplit(Bool_t split)Set the split status of a button.Definition TGButton.cxx:2894; TGSplitButton::fWidestLabelTGString fWidestLabellongest label that can be on the buttonDefinition TGButton.h:405; TGSplitButton::SetTextvoid SetText(TGHotString *new_label) overrideSet new button text.Definition TGButton.cxx:2767; TGStringTGString wraps a TString and adds some graphics routines like drawing, size of string on screen depen...Definition TGString.h:20; TGString::GetStringconst char * GetString() constDefinition TGString.h:30; TGTextButtonYield an action as soon as it is clicked.Definition TGButton.h:142; TGTextButton::Initvoid Init()Common initialization used by the different ctors.Definition TGButton.cxx:541; TGTextButton::GetWrapLengthInt_t GetWrapLength() constDefinition TGButton.h:203; TGTextButton::GetTextconst TGHotString * GetText() constDefinition TGButton.h:189; TGTextButton::GetLeftMarginInt_t GetLeftMargin() constDefinition TGButton.h:212; TGTextButton::GetRightMarginInt_t GetRightMargin() constDefinition TGButton.h:213; TGTextButton::GetDefaultFontStructstatic FontStruct_t GetDefaultFontStruct()Return default font structure.Definition TGButton.cxx:869; TGTextButton::Layoutvoid Layout() overridelayout text buttonDefinition TGButton.cxx:624; TGTextButton::SetTopMarginvirtual void SetTopMargin(Int_t val)Definition TGButton.h:209; TGTextBu",MatchSource.WIKI,doc/master/TGButton_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGButton_8h_source.html
https://root.cern/doc/master/TGButton_8h_source.html:37915,Integrability,rout,routines,37915,"Button::operator=TGSplitButton & operator=(const TGSplitButton &)=delete; TGSplitButton::fHeighestLabelTGString fHeighestLabelhighest label that can be on the buttonDefinition TGButton.h:406; TGSplitButton::fTBWidthUInt_t fTBWidthwidth of text buttonDefinition TGButton.h:398; TGSplitButton::MBPressedvirtual void MBPressed()Definition TGButton.h:438; TGSplitButton::SetMBStatevirtual void SetMBState(EButtonState state)Set the state of the Menu Button part.Definition TGButton.cxx:2883; TGSplitButton::fKeyNavigateBool_t fKeyNavigatekTRUE if key navigation is being usedDefinition TGButton.h:404; TGSplitButton::SetSplitvirtual void SetSplit(Bool_t split)Set the split status of a button.Definition TGButton.cxx:2894; TGSplitButton::fWidestLabelTGString fWidestLabellongest label that can be on the buttonDefinition TGButton.h:405; TGSplitButton::SetTextvoid SetText(TGHotString *new_label) overrideSet new button text.Definition TGButton.cxx:2767; TGStringTGString wraps a TString and adds some graphics routines like drawing, size of string on screen depen...Definition TGString.h:20; TGString::GetStringconst char * GetString() constDefinition TGString.h:30; TGTextButtonYield an action as soon as it is clicked.Definition TGButton.h:142; TGTextButton::Initvoid Init()Common initialization used by the different ctors.Definition TGButton.cxx:541; TGTextButton::GetWrapLengthInt_t GetWrapLength() constDefinition TGButton.h:203; TGTextButton::GetTextconst TGHotString * GetText() constDefinition TGButton.h:189; TGTextButton::GetLeftMarginInt_t GetLeftMargin() constDefinition TGButton.h:212; TGTextButton::GetRightMarginInt_t GetRightMargin() constDefinition TGButton.h:213; TGTextButton::GetDefaultFontStructstatic FontStruct_t GetDefaultFontStruct()Return default font structure.Definition TGButton.cxx:869; TGTextButton::Layoutvoid Layout() overridelayout text buttonDefinition TGButton.cxx:624; TGTextButton::SetTopMarginvirtual void SetTopMargin(Int_t val)Definition TGButton.h:209; TGTextBu",MatchSource.WIKI,doc/master/TGButton_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGButton_8h_source.html
https://root.cern/doc/master/TGButton_8h_source.html:28090,Usability,simpl,simple,28090,"ideEmit signals.Definition TGButton.cxx:1262; TGCheckButton::SetStatevoid SetState(EButtonState state, Bool_t emit=kFALSE) overrideSet check button state.Definition TGButton.cxx:1250; TGCheckButton::fPrevStateEButtonState fPrevStateprevious check button stateDefinition TGButton.h:272; TGCheckButton::DoRedrawvoid DoRedraw() overrideDraw the check button widget.Definition TGButton.cxx:1437; TGCheckButton::fDisOffconst TGPicture * fDisOffbutton disabled and was OFF pictureDefinition TGButton.h:276; TGCheckButton::fDisOnconst TGPicture * fDisOnbutton disabled and was ON pictureDefinition TGButton.h:275; TGCheckButton::GetDefaultSizeTGDimension GetDefaultSize() const overridedefault sizeDefinition TGButton.cxx:1236; TGCheckButton::PSetStatevoid PSetState(EButtonState state, Bool_t emit)Set check button state.Definition TGButton.cxx:1273; TGDimensionDefinition TGDimension.h:18; TGFontEncapsulate fonts used in the GUI system.Definition TGFont.h:140; TGFrameA subclasses of TGWindow, and is used as base class for some simple widgets (buttons,...Definition TGFrame.h:80; TGGCEncapsulate a graphics context used in the low level graphics.Definition TGGC.h:22; TGHotStringTGHotString is a string with a ""hot"" character underlined.Definition TGString.h:42; TGPictureButtonYield an action as soon as it is clicked.Definition TGButton.h:228; TGPictureButton::SetPicturevirtual void SetPicture(const TGPicture *new_pic)Change a picture in a picture button.Definition TGButton.cxx:1040; TGPictureButton::CreateDisabledPicturevirtual void CreateDisabledPicture()Creates disabled picture.Definition TGButton.cxx:1108; TGPictureButton::GetDisabledPictureconst TGPicture * GetDisabledPicture() constDefinition TGButton.h:257; TGPictureButton::SetDisabledPicturevirtual void SetDisabledPicture(const TGPicture *pic)Changes disabled picture.Definition TGButton.cxx:1135; TGPictureButton::GetPictureconst TGPicture * GetPicture() constDefinition TGButton.h:256; TGPictureButton::SavePrimitivevoid SavePrimiti",MatchSource.WIKI,doc/master/TGButton_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGButton_8h_source.html
https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:2004,Availability,error,error,2004,"amerInfoActions.h""; 23#include ""THashTable.h""; 24#include ""THashList.h""; 25#include <cstdlib>; 26 ; 27#define MESSAGE(which,text); 28 ; 29/**; 30\class TGenVectorProxy; 31\ingroup IO; 32Local optimization class.; 33 ; 34Collection proxies get copied. On copy we switch the type of the; 35proxy to the concrete STL type. The concrete types are optimized; 36for element access.; 37*/; 38 ; 39class TGenVectorProxy : public TGenCollectionProxy {; 40public:; 41 // Standard Destructor; 42 TGenVectorProxy(const TGenCollectionProxy& c) : TGenCollectionProxy(c); 43 {; 44 }; 45 // Standard Destructor; 46 ~TGenVectorProxy() override; 47 {; 48 }; 49 // Return the address of the value at index 'idx'; 50 void* At(UInt_t idx) override; 51 {; 52 if ( fEnv && fEnv->fObject ) {; 53 fEnv->fIdx = idx;; 54 switch( idx ) {; 55 case 0:; 56 return fEnv->fStart = fFirst.invoke(fEnv);; 57 default:; 58 if (! fEnv->fStart ) fEnv->fStart = fFirst.invoke(fEnv);; 59 return ((char*)fEnv->fStart) + fValDiff*idx;; 60 }; 61 }; 62 Fatal(""TGenVectorProxy"",""At> Logic error - no proxy object set."");; 63 return nullptr;; 64 }; 65 // Call to delete/destruct individual item; 66 void DeleteItem(Bool_t force, void* ptr) const override; 67 {; 68 if ( force && ptr ) {; 69 if ( fVal->fProperties&kNeedDelete) {; 70 TVirtualCollectionProxy *proxy = fVal->fType->GetCollectionProxy();; 71 TPushPop helper(proxy,ptr);; 72 proxy->Clear(""force"");; 73 }; 74 fVal->DeleteItem(ptr);; 75 }; 76 }; 77};; 78 ; 79/**; 80\class TGenVectorBoolProxy; 81\ingroup IO; 82Local optimization class.; 83 ; 84Collection proxies get copied. On copy we switch the type of the; 85proxy to the concrete STL type. The concrete types are optimized; 86for element access.; 87*/; 88class TGenVectorBoolProxy : public TGenCollectionProxy {; 89 Bool_t fLastValue;; 90 ; 91public:; 92 TGenVectorBoolProxy(const TGenCollectionProxy& c) : TGenCollectionProxy(c), fLastValue(false); 93 {; 94 // Standard Constructor.; 95 }; 96 ~TGenVectorBoolProxy() override; 97 {;",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:3393,Availability,error,error,3393,"llectionProxy();; 71 TPushPop helper(proxy,ptr);; 72 proxy->Clear(""force"");; 73 }; 74 fVal->DeleteItem(ptr);; 75 }; 76 }; 77};; 78 ; 79/**; 80\class TGenVectorBoolProxy; 81\ingroup IO; 82Local optimization class.; 83 ; 84Collection proxies get copied. On copy we switch the type of the; 85proxy to the concrete STL type. The concrete types are optimized; 86for element access.; 87*/; 88class TGenVectorBoolProxy : public TGenCollectionProxy {; 89 Bool_t fLastValue;; 90 ; 91public:; 92 TGenVectorBoolProxy(const TGenCollectionProxy& c) : TGenCollectionProxy(c), fLastValue(false); 93 {; 94 // Standard Constructor.; 95 }; 96 ~TGenVectorBoolProxy() override; 97 {; 98 // Standard Destructor.; 99 }; 100 void* At(UInt_t idx) override; 101 {; 102 // Return the address of the value at index 'idx'; 103 ; 104 // However we can 'take' the address of the content of std::vector<bool>.; 105 if ( fEnv && fEnv->fObject ) {; 106 auto vec = (std::vector<bool> *)(fEnv->fObject);; 107 fLastValue = (*vec)[idx];; 108 fEnv->fIdx = idx;; 109 return &fLastValue;; 110 }; 111 Fatal(""TGenVectorProxy"",""At> Logic error - no proxy object set."");; 112 return nullptr;; 113 }; 114 ; 115 void DeleteItem(Bool_t force, void* ptr) const override; 116 {; 117 // Call to delete/destruct individual item; 118 if ( force && ptr ) {; 119 fVal->DeleteItem(ptr);; 120 }; 121 }; 122};; 123 ; 124//////////////////////////////////////////////////////////////////////////; 125// //; 126// class TGenBitsetProxy; 127//; 128// Local optimization class.; 129//; 130// Collection proxies get copied. On copy we switch the type of the; 131// proxy to the concrete STL type. The concrete types are optimized; 132// for element access.; 133//; 134//////////////////////////////////////////////////////////////////////////; 135class TGenBitsetProxy : public TGenCollectionProxy {; 136 ; 137public:; 138 TGenBitsetProxy(const TGenCollectionProxy& c) : TGenCollectionProxy(c); 139 {; 140 // Standard Constructor.; 141 }; 142 ~TGenBitsetProxy() o",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:4986,Availability,error,error,4986," for element access.; 133//; 134//////////////////////////////////////////////////////////////////////////; 135class TGenBitsetProxy : public TGenCollectionProxy {; 136 ; 137public:; 138 TGenBitsetProxy(const TGenCollectionProxy& c) : TGenCollectionProxy(c); 139 {; 140 // Standard Constructor.; 141 }; 142 ~TGenBitsetProxy() override; 143 {; 144 // Standard Destructor.; 145 }; 146 void* At(UInt_t idx) override; 147 {; 148 // Return the address of the value at index 'idx'; 149 ; 150 if ( fEnv && fEnv->fObject ) {; 151 switch( idx ) {; 152 case 0:; 153 fEnv->fStart = fFirst.invoke(fEnv);; 154 fEnv->fIdx = idx;; 155 break;; 156 default:; 157 fEnv->fIdx = idx - fEnv->fIdx;; 158 if (! fEnv->fStart ) fEnv->fStart = fFirst.invoke(fEnv);; 159 fNext.invoke(fEnv);; 160 fEnv->fIdx = idx;; 161 break;; 162 }; 163 typedef ROOT::TCollectionProxyInfo::Environ<std::pair<size_t,Bool_t> > EnvType_t;; 164 EnvType_t *e = (EnvType_t*)fEnv;; 165 return &(e->fIterator.second);; 166 }; 167 Fatal(""TGenVectorProxy"",""At> Logic error - no proxy object set."");; 168 return 0;; 169 }; 170 ; 171 void DeleteItem(Bool_t force, void* ptr) const override; 172 {; 173 // Call to delete/destruct individual item; 174 if ( force && ptr ) {; 175 fVal->DeleteItem(ptr);; 176 }; 177 }; 178};; 179 ; 180/*; 181\class TGenListProxy; 182\ingroup IO; 183Local optimization class.; 184 ; 185Collection proxies get copied. On copy we switch the type of the; 186proxy to the concrete STL type. The concrete types are optimized; 187for element access.; 188**/; 189 ; 190class TGenListProxy : public TGenVectorProxy {; 191public:; 192 // Standard Destructor; 193 TGenListProxy(const TGenCollectionProxy& c) : TGenVectorProxy(c); 194 {; 195 }; 196 // Standard Destructor; 197 ~TGenListProxy() override; 198 {; 199 }; 200 // Return the address of the value at index 'idx'; 201 void* At(UInt_t idx) override; 202 {; 203 if ( fEnv && fEnv->fObject ) {; 204 switch( idx ) {; 205 case 0:; 206 fEnv->fIdx = idx;; 207 return fEnv->fStart = fFi",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:6246,Availability,error,error,6246,"leteItem(ptr);; 176 }; 177 }; 178};; 179 ; 180/*; 181\class TGenListProxy; 182\ingroup IO; 183Local optimization class.; 184 ; 185Collection proxies get copied. On copy we switch the type of the; 186proxy to the concrete STL type. The concrete types are optimized; 187for element access.; 188**/; 189 ; 190class TGenListProxy : public TGenVectorProxy {; 191public:; 192 // Standard Destructor; 193 TGenListProxy(const TGenCollectionProxy& c) : TGenVectorProxy(c); 194 {; 195 }; 196 // Standard Destructor; 197 ~TGenListProxy() override; 198 {; 199 }; 200 // Return the address of the value at index 'idx'; 201 void* At(UInt_t idx) override; 202 {; 203 if ( fEnv && fEnv->fObject ) {; 204 switch( idx ) {; 205 case 0:; 206 fEnv->fIdx = idx;; 207 return fEnv->fStart = fFirst.invoke(fEnv);; 208 default: {; 209 fEnv->fIdx = idx - fEnv->fIdx;; 210 if (! fEnv->fStart ) fEnv->fStart = fFirst.invoke(fEnv);; 211 void* result = fNext.invoke(fEnv);; 212 fEnv->fIdx = idx;; 213 return result;; 214 }; 215 }; 216 }; 217 Fatal(""TGenListProxy"",""At> Logic error - no proxy object set."");; 218 return nullptr;; 219 }; 220};; 221 ; 222/**; 223\class TGenSetProxy; 224\ingroup IO; 225Localoptimization class.; 226 ; 227Collection proxies get copied. On copy we switch the type of the; 228proxy to the concrete STL type. The concrete types are optimized; 229for element access.; 230*/; 231 ; 232class TGenSetProxy : public TGenVectorProxy {; 233public:; 234 // Standard Destructor; 235 TGenSetProxy(const TGenCollectionProxy& c) : TGenVectorProxy(c); 236 {; 237 }; 238 // Standard Destructor; 239 ~TGenSetProxy() override; 240 {; 241 }; 242 // Return the address of the value at index 'idx'; 243 void* At(UInt_t idx) override; 244 {; 245 if ( fEnv && fEnv->fObject ) {; 246 if ( fEnv->fUseTemp ) {; 247 return (((char*)fEnv->fTemp)+idx*fValDiff);; 248 }; 249 switch( idx ) {; 250 case 0:; 251 fEnv->fIdx = idx;; 252 return fEnv->fStart = fFirst.invoke(fEnv);; 253 default: {; 254 fEnv->fIdx = idx - fEnv->fIdx;; 255 ",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:7400,Availability,error,error,7400,"ingroup IO; 225Localoptimization class.; 226 ; 227Collection proxies get copied. On copy we switch the type of the; 228proxy to the concrete STL type. The concrete types are optimized; 229for element access.; 230*/; 231 ; 232class TGenSetProxy : public TGenVectorProxy {; 233public:; 234 // Standard Destructor; 235 TGenSetProxy(const TGenCollectionProxy& c) : TGenVectorProxy(c); 236 {; 237 }; 238 // Standard Destructor; 239 ~TGenSetProxy() override; 240 {; 241 }; 242 // Return the address of the value at index 'idx'; 243 void* At(UInt_t idx) override; 244 {; 245 if ( fEnv && fEnv->fObject ) {; 246 if ( fEnv->fUseTemp ) {; 247 return (((char*)fEnv->fTemp)+idx*fValDiff);; 248 }; 249 switch( idx ) {; 250 case 0:; 251 fEnv->fIdx = idx;; 252 return fEnv->fStart = fFirst.invoke(fEnv);; 253 default: {; 254 fEnv->fIdx = idx - fEnv->fIdx;; 255 if (! fEnv->fStart ) fEnv->fStart = fFirst.invoke(fEnv);; 256 void* result = fNext.invoke(fEnv);; 257 fEnv->fIdx = idx;; 258 return result;; 259 }; 260 }; 261 }; 262 Fatal(""TGenSetProxy"",""At> Logic error - no proxy object set."");; 263 return nullptr;; 264 }; 265};; 266 ; 267/**; 268\class TGenMapProxy; 269\ingroup IO; 270Localoptimization class.; 271 ; 272Collection proxies get copied. On copy we switch the type of the; 273proxy to the concrete STL type. The concrete types are optimized; 274for element access.; 275*/; 276 ; 277class TGenMapProxy : public TGenSetProxy {; 278public:; 279 // Standard Destructor; 280 TGenMapProxy(const TGenCollectionProxy& c) : TGenSetProxy(c); 281 {; 282 }; 283 // Standard Destructor; 284 ~TGenMapProxy() override; 285 {; 286 }; 287 // Call to delete/destruct individual item; 288 void DeleteItem(Bool_t force, void* ptr) const override; 289 {; 290 if (force) {; 291 if ( fKey->fProperties&kNeedDelete) {; 292 TVirtualCollectionProxy *proxy = fKey->fType->GetCollectionProxy();; 293 TPushPop helper(proxy,fKey->fCase&kIsPointer ? *(void**)ptr : ptr);; 294 proxy->Clear(""force"");; 295 }; 296 if ( fVal->fProperties&k",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:25797,Availability,error,error,25797," %s present."",fName.c_str());; 809 }; 810 if ( 0 == fConstruct ) {; 811 Fatal(""TGenCollectionProxy"",""No 'block constructor' function for class %s present."",fName.c_str());; 812 }; 813 if ( 0 == fDestruct ) {; 814 Fatal(""TGenCollectionProxy"",""No 'block destructor' function for class %s present."",fName.c_str());; 815 }; 816 if ( 0 == fFeed ) {; 817 Fatal(""TGenCollectionProxy"",""No 'data feed' function for class %s present."",fName.c_str());; 818 }; 819 if ( 0 == fCollect ) {; 820 Fatal(""TGenCollectionProxy"",""No 'data collect' function for class %s present."",fName.c_str());; 821 }; 822 if (0 == fCreateEnv.call ) {; 823 Fatal(""TGenCollectionProxy"",""No 'environment creation' function for class %s present."",fName.c_str());; 824 }; 825}; 826 ; 827////////////////////////////////////////////////////////////////////////////////; 828/// Utility routine to issue a Fatal error is the Value object is not valid; 829 ; 830static TGenCollectionProxy::Value *R__CreateValue(const std::string &name, Bool_t silent,; 831 size_t hint_pair_offset = 0, size_t hint_pair_size = 0); 832{; 833 TGenCollectionProxy::Value *val = new TGenCollectionProxy::Value( name, silent, hint_pair_offset, hint_pair_size );; 834 if ( !val->IsValid() ) {; 835 Fatal(""TGenCollectionProxy"",""Could not find %s!"",name.c_str());; 836 }; 837 return val;; 838}; 839 ; 840////////////////////////////////////////////////////////////////////////////////; 841/// Proxy initializer; 842 ; 843TGenCollectionProxy *TGenCollectionProxy::InitializeEx(Bool_t silent); 844{; 845 R__LOCKGUARD(gInterpreterMutex);; 846 if (fValue.load()) return this;; 847 ; 848 TClass *cl = fClass ? fClass.GetClass() : TClass::GetClass(fTypeinfo,kTRUE,silent);; 849 if ( cl ) {; 850 fEnv = 0;; 851 fName = cl->GetName();; 852 fPointers = false;; 853 int nested = 0;; 854 std::vector<std::string> inside;; 855 int num = TClassEdit::GetSplit(cl->GetName(),inside,nested);; 856 if ( num > 1 ) {; 857 std::string nam;; 858 Value* newfValue = nullptr;; 859 if ( inside",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:36663,Availability,error,error,36663,"st.invoke(fEnv);; 1094 fNext.invoke(fEnv);; 1095 fEnv->fIdx = idx;; 1096 break;; 1097 }; 1098 typedef ROOT::TCollectionProxyInfo::Environ <std::pair<size_t, Bool_t>> EnvType_t;; 1099 EnvType_t *e = (EnvType_t *) fEnv;; 1100 return &(e->fIterator.second);; 1101 }; 1102 case ROOT::kSTLset:; 1103 case ROOT::kSTLunorderedset:; 1104 case ROOT::kSTLmultiset:; 1105 case ROOT::kSTLunorderedmultiset:; 1106 case ROOT::kSTLmap:; 1107 case ROOT::kSTLunorderedmap:; 1108 case ROOT::kSTLmultimap:; 1109 case ROOT::kSTLunorderedmultimap:; 1110 if ( fEnv->fUseTemp ) {; 1111 return (((char*)fEnv->fTemp)+idx*fValDiff);; 1112 }; 1113 // Intentional fall through.; 1114 default:; 1115 switch( idx ) {; 1116 case 0:; 1117 fEnv->fIdx = idx;; 1118 return fEnv->fStart = fFirst.invoke(fEnv);; 1119 default: {; 1120 fEnv->fIdx = idx - fEnv->fIdx;; 1121 if (! fEnv->fStart ) fEnv->fStart = fFirst.invoke(fEnv);; 1122 void* result = fNext.invoke(fEnv);; 1123 fEnv->fIdx = idx;; 1124 return result;; 1125 }; 1126 }; 1127 }; 1128 }; 1129 Fatal(""TGenCollectionProxy"",""At> Logic error - no proxy object set."");; 1130 return 0;; 1131}; 1132 ; 1133////////////////////////////////////////////////////////////////////////////////; 1134/// Clear the emulated collection.; 1135 ; 1136void TGenCollectionProxy::Clear(const char* opt); 1137{; 1138 if ( fEnv && fEnv->fObject ) {; 1139 if ( (fProperties & kNeedDelete) && opt && *opt=='f' ) {; 1140 size_t i, n = *(size_t*)fSize.invoke(fEnv);; 1141 if ( n > 0 ) {; 1142 for (i=0; i<n; ++i); 1143 DeleteItem(true, TGenCollectionProxy::At(i));; 1144 }; 1145 }; 1146 fClear.invoke(fEnv);; 1147 }; 1148}; 1149 ; 1150////////////////////////////////////////////////////////////////////////////////; 1151/// Return the current size of the container; 1152 ; 1153UInt_t TGenCollectionProxy::Size() const; 1154{; 1155 if ( fEnv && fEnv->fObject ) {; 1156 if (fEnv->fUseTemp) {; 1157 return fEnv->fSize;; 1158 } else {; 1159 return *(size_t*)fSize.invoke(fEnv);; 1160 }; 1161 }; 1162 Fatal(""TG",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:37641,Availability,error,error,37641,"}; 1129 Fatal(""TGenCollectionProxy"",""At> Logic error - no proxy object set."");; 1130 return 0;; 1131}; 1132 ; 1133////////////////////////////////////////////////////////////////////////////////; 1134/// Clear the emulated collection.; 1135 ; 1136void TGenCollectionProxy::Clear(const char* opt); 1137{; 1138 if ( fEnv && fEnv->fObject ) {; 1139 if ( (fProperties & kNeedDelete) && opt && *opt=='f' ) {; 1140 size_t i, n = *(size_t*)fSize.invoke(fEnv);; 1141 if ( n > 0 ) {; 1142 for (i=0; i<n; ++i); 1143 DeleteItem(true, TGenCollectionProxy::At(i));; 1144 }; 1145 }; 1146 fClear.invoke(fEnv);; 1147 }; 1148}; 1149 ; 1150////////////////////////////////////////////////////////////////////////////////; 1151/// Return the current size of the container; 1152 ; 1153UInt_t TGenCollectionProxy::Size() const; 1154{; 1155 if ( fEnv && fEnv->fObject ) {; 1156 if (fEnv->fUseTemp) {; 1157 return fEnv->fSize;; 1158 } else {; 1159 return *(size_t*)fSize.invoke(fEnv);; 1160 }; 1161 }; 1162 Fatal(""TGenCollectionProxy"",""Size> Logic error - no proxy object set."");; 1163 return 0;; 1164}; 1165 ; 1166////////////////////////////////////////////////////////////////////////////////; 1167/// Resize the container; 1168 ; 1169void TGenCollectionProxy::Resize(UInt_t n, Bool_t force); 1170{; 1171 if ( fEnv && fEnv->fObject ) {; 1172 if ( force && fPointers ) {; 1173 size_t i, nold = *(size_t*)fSize.invoke(fEnv);; 1174 if ( n != nold ) {; 1175 for (i=n; i<nold; ++i); 1176 DeleteItem(true, *(void**)TGenCollectionProxy::At(i));; 1177 }; 1178 }; 1179 MESSAGE(3, ""Resize(n)"" );; 1180 fEnv->fSize = n;; 1181 fResize(fEnv->fObject,fEnv->fSize);; 1182 return;; 1183 }; 1184 Fatal(""TGenCollectionProxy"",""Resize> Logic error - no proxy object set."");; 1185}; 1186 ; 1187////////////////////////////////////////////////////////////////////////////////; 1188/// Allocate the needed space.; 1189/// For associative collection, this returns a TStaging object that; 1190/// need to be deleted manually __or__ returned by ca",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:38318,Availability,error,error,38318,"; 1145 }; 1146 fClear.invoke(fEnv);; 1147 }; 1148}; 1149 ; 1150////////////////////////////////////////////////////////////////////////////////; 1151/// Return the current size of the container; 1152 ; 1153UInt_t TGenCollectionProxy::Size() const; 1154{; 1155 if ( fEnv && fEnv->fObject ) {; 1156 if (fEnv->fUseTemp) {; 1157 return fEnv->fSize;; 1158 } else {; 1159 return *(size_t*)fSize.invoke(fEnv);; 1160 }; 1161 }; 1162 Fatal(""TGenCollectionProxy"",""Size> Logic error - no proxy object set."");; 1163 return 0;; 1164}; 1165 ; 1166////////////////////////////////////////////////////////////////////////////////; 1167/// Resize the container; 1168 ; 1169void TGenCollectionProxy::Resize(UInt_t n, Bool_t force); 1170{; 1171 if ( fEnv && fEnv->fObject ) {; 1172 if ( force && fPointers ) {; 1173 size_t i, nold = *(size_t*)fSize.invoke(fEnv);; 1174 if ( n != nold ) {; 1175 for (i=n; i<nold; ++i); 1176 DeleteItem(true, *(void**)TGenCollectionProxy::At(i));; 1177 }; 1178 }; 1179 MESSAGE(3, ""Resize(n)"" );; 1180 fEnv->fSize = n;; 1181 fResize(fEnv->fObject,fEnv->fSize);; 1182 return;; 1183 }; 1184 Fatal(""TGenCollectionProxy"",""Resize> Logic error - no proxy object set."");; 1185}; 1186 ; 1187////////////////////////////////////////////////////////////////////////////////; 1188/// Allocate the needed space.; 1189/// For associative collection, this returns a TStaging object that; 1190/// need to be deleted manually __or__ returned by calling Commit(TStaging*); 1191 ; 1192void* TGenCollectionProxy::Allocate(UInt_t n, Bool_t /* forceDelete */ ); 1193{; 1194 if ( fEnv && fEnv->fObject ) {; 1195 switch ( fSTL_type ) {; 1196 case ROOT::kSTLset:; 1197 case ROOT::kSTLunorderedset:; 1198 case ROOT::kSTLmultiset:; 1199 case ROOT::kSTLunorderedmultiset:; 1200 case ROOT::kSTLmap:; 1201 case ROOT::kSTLunorderedmap:; 1202 case ROOT::kSTLmultimap:; 1203 case ROOT::kSTLunorderedmultimap:{; 1204 if ( (fProperties & kNeedDelete) ); 1205 Clear(""force"");; 1206 else; 1207 fClear.invoke(fEnv);; 1208 // Co",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:45930,Availability,error,error,45930,"ionProxy *proxy = fVal->fType->GetCollectionProxy();; 1400 TPushPop helper(proxy,ptr);; 1401 proxy->Clear(""force"");; 1402 }; 1403 }; 1404 break;; 1405 }; 1406 }; 1407 }; 1408}; 1409 ; 1410////////////////////////////////////////////////////////////////////////////////; 1411 ; 1412void TGenCollectionProxy::ReadBuffer(TBuffer & /* b */, void * /* obj */, const TClass * /* onfileClass */); 1413{; 1414 MayNotUse(""TGenCollectionProxy::ReadBuffer(TBuffer &, void *, const TClass *)"");; 1415}; 1416 ; 1417////////////////////////////////////////////////////////////////////////////////; 1418 ; 1419void TGenCollectionProxy::ReadBuffer(TBuffer & /* b */, void * /* obj */); 1420{; 1421 MayNotUse(""TGenCollectionProxy::ReadBuffer(TBuffer &, void *)"");; 1422}; 1423 ; 1424////////////////////////////////////////////////////////////////////////////////; 1425/// Streamer Function.; 1426 ; 1427void TGenCollectionProxy::Streamer(TBuffer &buff); 1428{; 1429 if ( fEnv ) {; 1430 GetCollectionClass()->Streamer( fEnv->fObject, buff );; 1431 return;; 1432 }; 1433 Fatal(""TGenCollectionProxy"",""Streamer> Logic error - no proxy object set."");; 1434}; 1435 ; 1436////////////////////////////////////////////////////////////////////////////////; 1437/// Streamer I/O overload; 1438 ; 1439void TGenCollectionProxy::Streamer(TBuffer &buff, void *objp, int /* siz */ ); 1440{; 1441 TPushPop env(this, objp);; 1442 Streamer(buff);; 1443}; 1444 ; 1445////////////////////////////////////////////////////////////////////////////////; 1446/// TClassStreamer IO overload; 1447 ; 1448void TGenCollectionProxy::operator()(TBuffer &b, void *objp); 1449{; 1450 Streamer(b, objp, 0);; 1451}; 1452 ; 1453 ; 1454struct TGenCollectionProxy__SlowIterator {; 1455 TVirtualCollectionProxy *fProxy;; 1456 UInt_t fIndex;; 1457 TGenCollectionProxy__SlowIterator(TVirtualCollectionProxy *proxy) : fProxy(proxy), fIndex(0) {}; 1458};; 1459 ; 1460////////////////////////////////////////////////////////////////////////////////; 1461 ; 1462",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:63232,Availability,error,error,63232,"Sha256.hxx:103; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; ULong_tunsigned long ULong_tDefinition RtypesCore.h:55; Long_tlong Long_tDefinition RtypesCore.h:54; UInt_tunsigned int UInt_tDefinition RtypesCore.h:46; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; TClassEdit.h; TClass.h; EDataTypeEDataTypeDefinition TDataType.h:28; kNoType_t@ kNoType_tDefinition TDataType.h:33; kInt_t@ kInt_tDefinition TDataType.h:30; kBool_t@ kBool_tDefinition TDataType.h:32; kVoid_t@ kVoid_tDefinition TDataType.h:35; kIsPointer@ kIsPointerDefinition TDictionary.h:78; kIsClass@ kIsClassDefinition TDictionary.h:65; kIsEnum@ kIsEnumDefinition TDictionary.h:68; kIsFundamental@ kIsFundamentalDefinition TDictionary.h:70; kIsStruct@ kIsStructDefinition TDictionary.h:66; TEnum.h; TError.h; R__ASSERT#define R__ASSERT(e)Checks condition e and reports a fatal error if it's false.Definition TError.h:125; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; MayNotUsevoid MayNotUse(const char *method)This function can be used in classes that should override a certain function, but in the inherited cl...Definition TError.cxx:168; Warningvoid Warning(const char *location, const char *msgfmt,...)Use this function in warning situations.Definition TError.cxx:229; Fatalvoid Fatal(const char *location, const char *msgfmt,...)Use this function in case of a fatal error. It will abort the program.Definition TError.cxx:244; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; destOption_t Option_t TPoint TPoint const ",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:63367,Availability,error,error,63367,"finition RtypesCore.h:45; ULong_tunsigned long ULong_tDefinition RtypesCore.h:55; Long_tlong Long_tDefinition RtypesCore.h:54; UInt_tunsigned int UInt_tDefinition RtypesCore.h:46; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; TClassEdit.h; TClass.h; EDataTypeEDataTypeDefinition TDataType.h:28; kNoType_t@ kNoType_tDefinition TDataType.h:33; kInt_t@ kInt_tDefinition TDataType.h:30; kBool_t@ kBool_tDefinition TDataType.h:32; kVoid_t@ kVoid_tDefinition TDataType.h:35; kIsPointer@ kIsPointerDefinition TDictionary.h:78; kIsClass@ kIsClassDefinition TDictionary.h:65; kIsEnum@ kIsEnumDefinition TDictionary.h:68; kIsFundamental@ kIsFundamentalDefinition TDictionary.h:70; kIsStruct@ kIsStructDefinition TDictionary.h:66; TEnum.h; TError.h; R__ASSERT#define R__ASSERT(e)Checks condition e and reports a fatal error if it's false.Definition TError.h:125; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; MayNotUsevoid MayNotUse(const char *method)This function can be used in classes that should override a certain function, but in the inherited cl...Definition TError.cxx:168; Warningvoid Warning(const char *location, const char *msgfmt,...)Use this function in warning situations.Definition TError.cxx:229; Fatalvoid Fatal(const char *location, const char *msgfmt,...)Use this function in case of a fatal error. It will abort the program.Definition TError.cxx:244; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; destOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t destDefin",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:63813,Availability,error,error,63813,"Type.h:30; kBool_t@ kBool_tDefinition TDataType.h:32; kVoid_t@ kVoid_tDefinition TDataType.h:35; kIsPointer@ kIsPointerDefinition TDictionary.h:78; kIsClass@ kIsClassDefinition TDictionary.h:65; kIsEnum@ kIsEnumDefinition TDictionary.h:68; kIsFundamental@ kIsFundamentalDefinition TDictionary.h:70; kIsStruct@ kIsStructDefinition TDictionary.h:66; TEnum.h; TError.h; R__ASSERT#define R__ASSERT(e)Checks condition e and reports a fatal error if it's false.Definition TError.h:125; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; MayNotUsevoid MayNotUse(const char *method)This function can be used in classes that should override a certain function, but in the inherited cl...Definition TError.cxx:168; Warningvoid Warning(const char *location, const char *msgfmt,...)Use this function in warning situations.Definition TError.cxx:229; Fatalvoid Fatal(const char *location, const char *msgfmt,...)Use this function in case of a fatal error. It will abort the program.Definition TError.cxx:244; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; destOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t destDefinition TGWin32VirtualXProxy.cxx:164; propOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char cons",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:66452,Availability,error,error,66452,"t_t Int_t Int_t UInt_t UInt_t Rectangle_t resultDefinition TGWin32VirtualXProxy.cxx:174; valueOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void valueDefinition TGWin32VirtualXProxy.cxx:142; namechar name[80]Definition TGX11.cxx:110; MESSAGE#define MESSAGE(which, text)Definition TGenCollectionProxy.cxx:27; TGenCollectionProxy__VectorCopyIteratorvoid * TGenCollectionProxy__VectorCopyIterator(void *dest, const void *source)Definition TGenCollectionProxy.cxx:1538; TGenCollectionProxy__StagingDeleteTwoIteratorsvoid TGenCollectionProxy__StagingDeleteTwoIterators(void *, void *)Nothing to do.Definition TGenCollectionProxy.cxx:1596; TGenCollectionProxy__VectorNextvoid * TGenCollectionProxy__VectorNext(void *, const void *)Should not be used.Definition TGenCollectionProxy.cxx:1530; R__CreateValuestatic TGenCollectionProxy::Value * R__CreateValue(const std::string &name, Bool_t silent, size_t hint_pair_offset=0, size_t hint_pair_size=0)Utility routine to issue a Fatal error is the Value object is not valid.Definition TGenCollectionProxy.cxx:830; TGenCollectionProxy__StagingDeleteSingleIteratorsvoid TGenCollectionProxy__StagingDeleteSingleIterators(void *)Nothing to do.Definition TGenCollectionProxy.cxx:1589; TGenCollectionProxy__SlowCreateIteratorsvoid TGenCollectionProxy__SlowCreateIterators(void *, void **begin_arena, void **end_arena, TVirtualCollectionProxy *proxy)Definition TGenCollectionProxy.cxx:1462; TGenCollectionProxy__SlowNextvoid * TGenCollectionProxy__SlowNext(void *iter, const void *end)Definition TGenCollectionProxy.cxx:1470; TGenCollectionProxy__VectorCreateIteratorsvoid TGenCollectionProxy__VectorCreateIterators(void *obj, void **begin_arena, void **end_arena, TVirtualCollectionProxy *)We can safely assume that the std::vector layout does not really depend on the content!Definition TGenCollectionProxy.cxx:1509; TGenCollectionProxy__StagingCopyIteratorvoi",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:51818,Energy Efficiency,allocate,allocated,51818,"onProxy__StagingCopyIterator(void *dest, const void *source); 1581{; 1582 *(void**)dest = *(void**)source;; 1583 return dest;; 1584}; 1585 ; 1586////////////////////////////////////////////////////////////////////////////////; 1587/// Nothing to do; 1588 ; 1589void TGenCollectionProxy__StagingDeleteSingleIterators(void *); 1590{; 1591}; 1592 ; 1593////////////////////////////////////////////////////////////////////////////////; 1594/// Nothing to do; 1595 ; 1596void TGenCollectionProxy__StagingDeleteTwoIterators(void *, void *); 1597{; 1598}; 1599 ; 1600 ; 1601////////////////////////////////////////////////////////////////////////////////; 1602/// See typedef void (*CreateIterators_t)(void *collection, void *&begin_arena, void *&end_arena);; 1603/// begin_arena and end_arena should contain the location of memory arena of size fgIteratorSize.; 1604/// If the collection iterator are of that size or less, the iterators will be constructed in place in those location (new with placement); 1605/// Otherwise the iterators will be allocated via a regular new and their address returned by modifying the value of begin_arena and end_arena.; 1606 ; 1607TVirtualCollectionProxy::CreateIterators_t TGenCollectionProxy::GetFunctionCreateIterators(Bool_t read); 1608{; 1609 if (read) {; 1610 if ( !fValue.load(std::memory_order_relaxed) ) InitializeEx(kFALSE);; 1611 if ( (fProperties & kIsAssociative) && read); 1612 return TGenCollectionProxy__StagingCreateIterators;; 1613 }; 1614 ; 1615 if ( fFunctionCreateIterators ) return fFunctionCreateIterators;; 1616 ; 1617 if ( !fValue.load(std::memory_order_relaxed) ) InitializeEx(kFALSE);; 1618 ; 1619// fprintf(stderr,""GetFunctinCreateIterator for %s will give: "",fClass.GetClassName());; 1620// if (fSTL_type==ROOT::kSTLvector || (fProperties & kIsEmulated)); 1621// fprintf(stderr,""vector/emulated iterator\n"");; 1622// else if ( (fProperties & kIsAssociative) && read); 1623// fprintf(stderr,""an associative read iterator\n"");; 1624// else; 1625",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:53752,Energy Efficiency,allocate,allocated,53752,"; 1623// fprintf(stderr,""an associative read iterator\n"");; 1624// else; 1625// fprintf(stderr,""a generic iterator\n"");; 1626 ; 1627 // TODO could we do better than SlowCreateIterators for RVec?; 1628 if (fSTL_type==ROOT::kSTLvector || (fProperties & kIsEmulated)); 1629 return fFunctionCreateIterators = TGenCollectionProxy__VectorCreateIterators;; 1630 else if ( (fProperties & kIsAssociative) && read); 1631 return TGenCollectionProxy__StagingCreateIterators;; 1632 else; 1633 return fFunctionCreateIterators = TGenCollectionProxy__SlowCreateIterators;; 1634}; 1635 ; 1636////////////////////////////////////////////////////////////////////////////////; 1637/// See typedef void (*CopyIterator_t)(void *&dest, const void *source);; 1638/// Copy the iterator source, into dest. dest should contain should contain the location of memory arena of size fgIteratorSize.; 1639/// If the collection iterator are of that size or less, the iterator will be constructed in place in this location (new with placement); 1640/// Otherwise the iterator will be allocated via a regular new and its address returned by modifying the value of dest.; 1641 ; 1642TVirtualCollectionProxy::CopyIterator_t TGenCollectionProxy::GetFunctionCopyIterator(Bool_t read); 1643{; 1644 if (read) {; 1645 if ( !fValue.load(std::memory_order_relaxed) ) InitializeEx(kFALSE);; 1646 if ( (fProperties & kIsAssociative) && read); 1647 return TGenCollectionProxy__StagingCopyIterator;; 1648 }; 1649 ; 1650 if ( fFunctionCopyIterator ) return fFunctionCopyIterator;; 1651 ; 1652 if ( !fValue.load(std::memory_order_relaxed) ) InitializeEx(kFALSE);; 1653 ; 1654 // TODO can we do better than the default for RVec?; 1655 if (fSTL_type==ROOT::kSTLvector || (fProperties & kIsEmulated)); 1656 return fFunctionCopyIterator = TGenCollectionProxy__VectorCopyIterator;; 1657 else if ( (fProperties & kIsAssociative) && read); 1658 return TGenCollectionProxy__StagingCopyIterator;; 1659 else; 1660 return fFunctionCopyIterator = TGenCollectionPr",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:81840,Energy Efficiency,allocate,allocate,81840,"Proxy.cxx:1169; TGenCollectionProxy::GetCollectionTypeInt_t GetCollectionType() const overrideReturn the type of collection see TClassEdit::ESTLType.Definition TGenCollectionProxy.cxx:993; TGenCollectionProxy::Clearvoid Clear(const char *opt="""") overrideClear the emulated collection.Definition TGenCollectionProxy.cxx:1136; TGenCollectionProxy::fProxyListProxies_t fProxyListStack of recursive proxies.Definition TGenCollectionProxy.h:317; TGenCollectionProxy::GetFunctionDeleteIteratorDeleteIterator_t GetFunctionDeleteIterator(Bool_t read=kTRUE) overrideSee typedef void (*DeleteIterator_t)(void *iter); If the sizeof iterator is greater than fgIteratorAr...Definition TGenCollectionProxy.cxx:1696; TGenCollectionProxy::SizeUInt_t Size() const overrideReturn the current size of the container.Definition TGenCollectionProxy.cxx:1153; TGenCollectionProxy::fDestructSizing_t fDestructContainer accessors: block destruct.Definition TGenCollectionProxy.h:307; TGenCollectionProxy::fCreateEnvMethod0 fCreateEnvMethod to allocate an Environment holder.Definition TGenCollectionProxy.h:310; TGenCollectionProxy::fValValue * fValDescriptor of the Value_type.Definition TGenCollectionProxy.h:312; TGenCollectionProxy::GetFunctionNextNext_t GetFunctionNext(Bool_t read=kTRUE) overrideSee typedef void* (*Next_t)(void *iter, void *end); iter and end should be pointer to respectively an...Definition TGenCollectionProxy.cxx:1670; TGenCollectionProxy::operator()virtual void operator()(TBuffer &refBuffer, void *pObject)TClassStreamer IO overload.Definition TGenCollectionProxy.cxx:1448; TGenCollectionProxy::fOnFileClassTClass * fOnFileClassOn file class.Definition TGenCollectionProxy.h:322; TGenCollectionProxy::fResizeSizing_t fResizeContainer accessors: resize container.Definition TGenCollectionProxy.h:303; TGenCollectionProxy::fConstructArrIterfunc_t fConstructContainer accessors: block construct.Definition TGenCollectionProxy.h:306; TGenCollectionProxy::Atvoid * At(UInt_t idx) overrideReturn the ad",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:25772,Integrability,rout,routine,25772," %s present."",fName.c_str());; 809 }; 810 if ( 0 == fConstruct ) {; 811 Fatal(""TGenCollectionProxy"",""No 'block constructor' function for class %s present."",fName.c_str());; 812 }; 813 if ( 0 == fDestruct ) {; 814 Fatal(""TGenCollectionProxy"",""No 'block destructor' function for class %s present."",fName.c_str());; 815 }; 816 if ( 0 == fFeed ) {; 817 Fatal(""TGenCollectionProxy"",""No 'data feed' function for class %s present."",fName.c_str());; 818 }; 819 if ( 0 == fCollect ) {; 820 Fatal(""TGenCollectionProxy"",""No 'data collect' function for class %s present."",fName.c_str());; 821 }; 822 if (0 == fCreateEnv.call ) {; 823 Fatal(""TGenCollectionProxy"",""No 'environment creation' function for class %s present."",fName.c_str());; 824 }; 825}; 826 ; 827////////////////////////////////////////////////////////////////////////////////; 828/// Utility routine to issue a Fatal error is the Value object is not valid; 829 ; 830static TGenCollectionProxy::Value *R__CreateValue(const std::string &name, Bool_t silent,; 831 size_t hint_pair_offset = 0, size_t hint_pair_size = 0); 832{; 833 TGenCollectionProxy::Value *val = new TGenCollectionProxy::Value( name, silent, hint_pair_offset, hint_pair_size );; 834 if ( !val->IsValid() ) {; 835 Fatal(""TGenCollectionProxy"",""Could not find %s!"",name.c_str());; 836 }; 837 return val;; 838}; 839 ; 840////////////////////////////////////////////////////////////////////////////////; 841/// Proxy initializer; 842 ; 843TGenCollectionProxy *TGenCollectionProxy::InitializeEx(Bool_t silent); 844{; 845 R__LOCKGUARD(gInterpreterMutex);; 846 if (fValue.load()) return this;; 847 ; 848 TClass *cl = fClass ? fClass.GetClass() : TClass::GetClass(fTypeinfo,kTRUE,silent);; 849 if ( cl ) {; 850 fEnv = 0;; 851 fName = cl->GetName();; 852 fPointers = false;; 853 int nested = 0;; 854 std::vector<std::string> inside;; 855 int num = TClassEdit::GetSplit(cl->GetName(),inside,nested);; 856 if ( num > 1 ) {; 857 std::string nam;; 858 Value* newfValue = nullptr;; 859 if ( inside",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:48465,Integrability,depend,depend,48465,"oxy *proxy); 1463{; 1464 new (*begin_arena) TGenCollectionProxy__SlowIterator(proxy);; 1465 *(UInt_t*)*end_arena = proxy->Size();; 1466}; 1467 ; 1468////////////////////////////////////////////////////////////////////////////////; 1469 ; 1470void *TGenCollectionProxy__SlowNext(void *iter, const void *end); 1471{; 1472 TGenCollectionProxy__SlowIterator *iterator = (TGenCollectionProxy__SlowIterator*)iter;; 1473 if (iterator->fIndex != *(UInt_t*)end) {; 1474 void *result = iterator->fProxy->At(iterator->fIndex);; 1475 ++(iterator->fIndex);; 1476 return result;; 1477 } else {; 1478 return 0;; 1479 }; 1480}; 1481 ; 1482////////////////////////////////////////////////////////////////////////////////; 1483 ; 1484void * TGenCollectionProxy__SlowCopyIterator(void *dest, const void *source); 1485{; 1486 *(TGenCollectionProxy__SlowIterator*)dest = *(TGenCollectionProxy__SlowIterator*)source;; 1487 return dest;; 1488}; 1489 ; 1490////////////////////////////////////////////////////////////////////////////////; 1491/// Nothing to do; 1492 ; 1493void TGenCollectionProxy__SlowDeleteSingleIterators(void *); 1494{; 1495}; 1496 ; 1497////////////////////////////////////////////////////////////////////////////////; 1498/// Nothing to do; 1499 ; 1500void TGenCollectionProxy__SlowDeleteTwoIterators(void *, void *); 1501{; 1502}; 1503 ; 1504 ; 1505////////////////////////////////////////////////////////////////////////////////; 1506/// We can safely assume that the std::vector layout does not really depend on; 1507/// the content!; 1508 ; 1509void TGenCollectionProxy__VectorCreateIterators(void *obj, void **begin_arena, void **end_arena, TVirtualCollectionProxy*); 1510{; 1511 std::vector<char> *vec = (std::vector<char>*)obj;; 1512 if (vec->empty()) {; 1513 *begin_arena = 0;; 1514 *end_arena = 0;; 1515 return;; 1516 }; 1517 *begin_arena = &(*vec->begin());; 1518#ifdef R__VISUAL_CPLUSPLUS; 1519 *end_arena = &(*(vec->end()-1)) + 1; // On windows we can not dererence the end iterator at all.",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:66427,Integrability,rout,routine,66427,"t_t Int_t Int_t UInt_t UInt_t Rectangle_t resultDefinition TGWin32VirtualXProxy.cxx:174; valueOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void valueDefinition TGWin32VirtualXProxy.cxx:142; namechar name[80]Definition TGX11.cxx:110; MESSAGE#define MESSAGE(which, text)Definition TGenCollectionProxy.cxx:27; TGenCollectionProxy__VectorCopyIteratorvoid * TGenCollectionProxy__VectorCopyIterator(void *dest, const void *source)Definition TGenCollectionProxy.cxx:1538; TGenCollectionProxy__StagingDeleteTwoIteratorsvoid TGenCollectionProxy__StagingDeleteTwoIterators(void *, void *)Nothing to do.Definition TGenCollectionProxy.cxx:1596; TGenCollectionProxy__VectorNextvoid * TGenCollectionProxy__VectorNext(void *, const void *)Should not be used.Definition TGenCollectionProxy.cxx:1530; R__CreateValuestatic TGenCollectionProxy::Value * R__CreateValue(const std::string &name, Bool_t silent, size_t hint_pair_offset=0, size_t hint_pair_size=0)Utility routine to issue a Fatal error is the Value object is not valid.Definition TGenCollectionProxy.cxx:830; TGenCollectionProxy__StagingDeleteSingleIteratorsvoid TGenCollectionProxy__StagingDeleteSingleIterators(void *)Nothing to do.Definition TGenCollectionProxy.cxx:1589; TGenCollectionProxy__SlowCreateIteratorsvoid TGenCollectionProxy__SlowCreateIterators(void *, void **begin_arena, void **end_arena, TVirtualCollectionProxy *proxy)Definition TGenCollectionProxy.cxx:1462; TGenCollectionProxy__SlowNextvoid * TGenCollectionProxy__SlowNext(void *iter, const void *end)Definition TGenCollectionProxy.cxx:1470; TGenCollectionProxy__VectorCreateIteratorsvoid TGenCollectionProxy__VectorCreateIterators(void *obj, void **begin_arena, void **end_arena, TVirtualCollectionProxy *)We can safely assume that the std::vector layout does not really depend on the content!Definition TGenCollectionProxy.cxx:1509; TGenCollectionProxy__StagingCopyIteratorvoi",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:67266,Integrability,depend,depend,67266,"ectorNext(void *, const void *)Should not be used.Definition TGenCollectionProxy.cxx:1530; R__CreateValuestatic TGenCollectionProxy::Value * R__CreateValue(const std::string &name, Bool_t silent, size_t hint_pair_offset=0, size_t hint_pair_size=0)Utility routine to issue a Fatal error is the Value object is not valid.Definition TGenCollectionProxy.cxx:830; TGenCollectionProxy__StagingDeleteSingleIteratorsvoid TGenCollectionProxy__StagingDeleteSingleIterators(void *)Nothing to do.Definition TGenCollectionProxy.cxx:1589; TGenCollectionProxy__SlowCreateIteratorsvoid TGenCollectionProxy__SlowCreateIterators(void *, void **begin_arena, void **end_arena, TVirtualCollectionProxy *proxy)Definition TGenCollectionProxy.cxx:1462; TGenCollectionProxy__SlowNextvoid * TGenCollectionProxy__SlowNext(void *iter, const void *end)Definition TGenCollectionProxy.cxx:1470; TGenCollectionProxy__VectorCreateIteratorsvoid TGenCollectionProxy__VectorCreateIterators(void *obj, void **begin_arena, void **end_arena, TVirtualCollectionProxy *)We can safely assume that the std::vector layout does not really depend on the content!Definition TGenCollectionProxy.cxx:1509; TGenCollectionProxy__StagingCopyIteratorvoid * TGenCollectionProxy__StagingCopyIterator(void *dest, const void *source)Definition TGenCollectionProxy.cxx:1580; TGenCollectionProxy__StagingNextvoid * TGenCollectionProxy__StagingNext(void *, const void *)Should not be used.Definition TGenCollectionProxy.cxx:1572; TGenCollectionProxy__VectorDeleteSingleIteratorsvoid TGenCollectionProxy__VectorDeleteSingleIterators(void *)Nothing to do.Definition TGenCollectionProxy.cxx:1547; TGenCollectionProxy__SlowCopyIteratorvoid * TGenCollectionProxy__SlowCopyIterator(void *dest, const void *source)Definition TGenCollectionProxy.cxx:1484; TGenCollectionProxy__StagingCreateIteratorsvoid TGenCollectionProxy__StagingCreateIterators(void *obj, void **begin_arena, void **end_arena, TVirtualCollectionProxy *)Definition TGenCollectionProxy.cxx:1562; TGenC",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:72101,Integrability,wrap,wrapper,72101,"CollectionProxyInfo::fValueOffsetint fValueOffsetDefinition TCollectionProxyInfo.h:502; ROOT::Detail::TCollectionProxyInfo::fNextvoid *(* fNext)(void *iter, const void *end)Definition TCollectionProxyInfo.h:525; ROOT::Detail::TCollectionProxyInfo::fCreateEnvvoid *(* fCreateEnv)()Definition TCollectionProxyInfo.h:512; TBufferBuffer base class used for serializing objects.Definition TBuffer.h:43; TClassRef::GetClassTClass * GetClass() constDefinition TClassRef.h:66; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::IsSyntheticPairBool_t IsSyntheticPair() constDefinition TClass.h:521; TClass::Streamervoid Streamer(void *obj, TBuffer &b, const TClass *onfile_class=nullptr) constDefinition TClass.h:607; TClass::ForceReloadvoid ForceReload(TClass *oldcl)we found at least one equivalent.Definition TClass.cxx:1403; TClass::GetStateEState GetState() constDefinition TClass.h:488; TClass::GetDestructorROOT::DesFunc_t GetDestructor() constReturn the wrapper around the destructor.Definition TClass.cxx:7546; TClass::GetNewROOT::NewFunc_t GetNew() constReturn the wrapper around new ThisClass().Definition TClass.cxx:7514; TClass::HasInterpreterInfoBool_t HasInterpreterInfo() constDefinition TClass.h:410; TClass::SizeInt_t Size() constReturn size of object of this class.Definition TClass.cxx:5771; TClass::IsLoadedBool_t IsLoaded() constReturn true if the shared library of this class is currently in the a process's memory.Definition TClass.cxx:5979; TClass::GetStreamerInfoTVirtualStreamerInfo * GetStreamerInfo(Int_t version=0, Bool_t isTransient=kFALSE) constreturns a pointer to the TVirtualStreamerInfo object for version If the object does not exist,...Definition TClass.cxx:4666; TClass::GetCollectionProxyTVirtualCollectionProxy * GetCollectionProxy() constReturn the proxy describing the collection (if any).Definition TClass.cxx:2964; TClass::GetClassSizeInt_t GetClassSize() constDefinition TClass.h:425; TClass::",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:72214,Integrability,wrap,wrapper,72214,"nfo::fNextvoid *(* fNext)(void *iter, const void *end)Definition TCollectionProxyInfo.h:525; ROOT::Detail::TCollectionProxyInfo::fCreateEnvvoid *(* fCreateEnv)()Definition TCollectionProxyInfo.h:512; TBufferBuffer base class used for serializing objects.Definition TBuffer.h:43; TClassRef::GetClassTClass * GetClass() constDefinition TClassRef.h:66; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::IsSyntheticPairBool_t IsSyntheticPair() constDefinition TClass.h:521; TClass::Streamervoid Streamer(void *obj, TBuffer &b, const TClass *onfile_class=nullptr) constDefinition TClass.h:607; TClass::ForceReloadvoid ForceReload(TClass *oldcl)we found at least one equivalent.Definition TClass.cxx:1403; TClass::GetStateEState GetState() constDefinition TClass.h:488; TClass::GetDestructorROOT::DesFunc_t GetDestructor() constReturn the wrapper around the destructor.Definition TClass.cxx:7546; TClass::GetNewROOT::NewFunc_t GetNew() constReturn the wrapper around new ThisClass().Definition TClass.cxx:7514; TClass::HasInterpreterInfoBool_t HasInterpreterInfo() constDefinition TClass.h:410; TClass::SizeInt_t Size() constReturn size of object of this class.Definition TClass.cxx:5771; TClass::IsLoadedBool_t IsLoaded() constReturn true if the shared library of this class is currently in the a process's memory.Definition TClass.cxx:5979; TClass::GetStreamerInfoTVirtualStreamerInfo * GetStreamerInfo(Int_t version=0, Bool_t isTransient=kFALSE) constreturns a pointer to the TVirtualStreamerInfo object for version If the object does not exist,...Definition TClass.cxx:4666; TClass::GetCollectionProxyTVirtualCollectionProxy * GetCollectionProxy() constReturn the proxy describing the collection (if any).Definition TClass.cxx:2964; TClass::GetClassSizeInt_t GetClassSize() constDefinition TClass.h:425; TClass::GetConversionStreamerInfoTVirtualStreamerInfo * GetConversionStreamerInfo(const char *onfile_classname, Int_t version) ",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:73454,Integrability,wrap,wrapper,73454,"lass.cxx:5771; TClass::IsLoadedBool_t IsLoaded() constReturn true if the shared library of this class is currently in the a process's memory.Definition TClass.cxx:5979; TClass::GetStreamerInfoTVirtualStreamerInfo * GetStreamerInfo(Int_t version=0, Bool_t isTransient=kFALSE) constreturns a pointer to the TVirtualStreamerInfo object for version If the object does not exist,...Definition TClass.cxx:4666; TClass::GetCollectionProxyTVirtualCollectionProxy * GetCollectionProxy() constReturn the proxy describing the collection (if any).Definition TClass.cxx:2964; TClass::GetClassSizeInt_t GetClassSize() constDefinition TClass.h:425; TClass::GetConversionStreamerInfoTVirtualStreamerInfo * GetConversionStreamerInfo(const char *onfile_classname, Int_t version) constReturn a Conversion StreamerInfo from the class 'classname' for version number 'version' to this clas...Definition TClass.cxx:7153; TClass::kInterpreted@ kInterpretedDefinition TClass.h:126; TClass::GetDeleteROOT::DelFunc_t GetDelete() constReturn the wrapper around delete ThiObject.Definition TClass.cxx:7530; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TCollection::kInitCapacity@ kInitCapacityDefinition TCollection.h:159; TCollection::GetSizevirtual Int_t GetSize() constReturn the capacity of the collection, i.e.Definition TCollection.h:184; TDataTypeBasic data type descriptor (datatype information is obtained from CINT).Definition TDataType.h:44; TDataType::GetTypeInt_t GetType() constDefinition TDataType.h:68; TDataType::SizeInt_t Size() constGet size of basic typedef'ed type.Definition TDataType.cxx:375; TEnum::GetEnumstatic TEnum * GetEnum(const std::type_info &ti, ESearchAction sa=kALoadAndInterpLookup)Definition TEnum.cxx:175; TEnum::kNone@ kNoneDefinition TEnum.h:48; TGenBitsetProxyDefinition TGenCollectionProxy.cxx:135; TGenBitsetProxy::TGenBitsetProxyTGen",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:91386,Integrability,interface,interface,91386,"StreamerInfoActions::TActionSequenceDefinition TStreamerInfoActions.h:177; TStreamerInfoActions::TActionSequence::CreateReadMemberWiseActionsstatic TActionSequence * CreateReadMemberWiseActions(TVirtualStreamerInfo *info, TVirtualCollectionProxy &proxy)Create the bundle of the actions necessary for the streaming memberwise of the content described by '...Definition TStreamerInfoActions.cxx:3886; TStreamerInfoActions::TActionSequence::CreateWriteMemberWiseActionsstatic TActionSequence * CreateWriteMemberWiseActions(TVirtualStreamerInfo *info, TVirtualCollectionProxy &proxy)Create the bundle of the actions necessary for the streaming memberwise of the content described by '...Definition TStreamerInfoActions.cxx:3999; TString::Classstatic TClass * Class(); TVirtualCollectionProxy::TPushPopRAII helper class that ensures that PushProxy() / PopProxy() are called when entering / leaving a C++...Definition TVirtualCollectionProxy.h:75; TVirtualCollectionProxyDefines a common interface to inspect/change the contents of an object that represents a collection.Definition TVirtualCollectionProxy.h:52; TVirtualCollectionProxy::GetPropertiesvirtual Int_t GetProperties() constReturn miscallenous properties of the proxy (see TVirtualCollectionProxy::EProperty)Definition TVirtualCollectionProxy.h:108; TVirtualCollectionProxy::CreateIterators_tvoid(* CreateIterators_t)(void *collection, void **begin_arena, void **end_arena, TVirtualCollectionProxy *proxy)*begin_arena and *end_arena should contain the location of a memory arena of size fgIteratorArenaSize...Definition TVirtualCollectionProxy.h:215; TVirtualCollectionProxy::kCustomAlloc@ kCustomAllocThe collection has a custom allocator.Definition TVirtualCollectionProxy.h:71; TVirtualCollectionProxy::kIsEmulated@ kIsEmulatedDefinition TVirtualCollectionProxy.h:67; TVirtualCollectionProxy::kNeedDelete@ kNeedDeleteThe collection contains directly or indirectly (via other collection) some pointers that need explici...Definition TVirtualCol",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:63541,Modifiability,inherit,inherited,63541,"re.h:54; UInt_tunsigned int UInt_tDefinition RtypesCore.h:46; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; TClassEdit.h; TClass.h; EDataTypeEDataTypeDefinition TDataType.h:28; kNoType_t@ kNoType_tDefinition TDataType.h:33; kInt_t@ kInt_tDefinition TDataType.h:30; kBool_t@ kBool_tDefinition TDataType.h:32; kVoid_t@ kVoid_tDefinition TDataType.h:35; kIsPointer@ kIsPointerDefinition TDictionary.h:78; kIsClass@ kIsClassDefinition TDictionary.h:65; kIsEnum@ kIsEnumDefinition TDictionary.h:68; kIsFundamental@ kIsFundamentalDefinition TDictionary.h:70; kIsStruct@ kIsStructDefinition TDictionary.h:66; TEnum.h; TError.h; R__ASSERT#define R__ASSERT(e)Checks condition e and reports a fatal error if it's false.Definition TError.h:125; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; MayNotUsevoid MayNotUse(const char *method)This function can be used in classes that should override a certain function, but in the inherited cl...Definition TError.cxx:168; Warningvoid Warning(const char *location, const char *msgfmt,...)Use this function in warning situations.Definition TError.cxx:229; Fatalvoid Fatal(const char *location, const char *msgfmt,...)Use this function in case of a fatal error. It will abort the program.Definition TError.cxx:244; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; destOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t destDefinition TGWin32VirtualXProxy.cxx:164; propOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetL",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:1153,Performance,optimiz,optimization,1153,"ding...; Searching...; No Matches. TGenCollectionProxy.cxx. Go to the documentation of this file. 1// @(#)root/io:$Id$; 2// Author: Markus Frank 28/10/04; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#include ""TGenCollectionProxy.h""; 13#include ""TVirtualStreamerInfo.h""; 14#include ""TStreamerElement.h""; 15#include ""TClassEdit.h""; 16#include ""TClass.h""; 17#include ""TError.h""; 18#include ""TEnum.h""; 19#include ""TROOT.h""; 20#include ""TInterpreter.h"" // For gInterpreterMutex; 21#include ""TVirtualMutex.h""; 22#include ""TStreamerInfoActions.h""; 23#include ""THashTable.h""; 24#include ""THashList.h""; 25#include <cstdlib>; 26 ; 27#define MESSAGE(which,text); 28 ; 29/**; 30\class TGenVectorProxy; 31\ingroup IO; 32Local optimization class.; 33 ; 34Collection proxies get copied. On copy we switch the type of the; 35proxy to the concrete STL type. The concrete types are optimized; 36for element access.; 37*/; 38 ; 39class TGenVectorProxy : public TGenCollectionProxy {; 40public:; 41 // Standard Destructor; 42 TGenVectorProxy(const TGenCollectionProxy& c) : TGenCollectionProxy(c); 43 {; 44 }; 45 // Standard Destructor; 46 ~TGenVectorProxy() override; 47 {; 48 }; 49 // Return the address of the value at index 'idx'; 50 void* At(UInt_t idx) override; 51 {; 52 if ( fEnv && fEnv->fObject ) {; 53 fEnv->fIdx = idx;; 54 switch( idx ) {; 55 case 0:; 56 return fEnv->fStart = fFirst.invoke(fEnv);; 57 default:; 58 if (! fEnv->fStart ) fEnv->fStart = fFirst.invoke(fEnv);; 59 return ((char*)fEnv->fStart) + fValDiff*idx;; 60 }; 61 }; 62 Fatal(""TGenVectorProxy"",""At> Logic error - no proxy object set."");; 63 return nullptr;; 64 }; 65 // Call to delete/destruct individu",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:1304,Performance,optimiz,optimized,1304,"***************************; 5 * Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#include ""TGenCollectionProxy.h""; 13#include ""TVirtualStreamerInfo.h""; 14#include ""TStreamerElement.h""; 15#include ""TClassEdit.h""; 16#include ""TClass.h""; 17#include ""TError.h""; 18#include ""TEnum.h""; 19#include ""TROOT.h""; 20#include ""TInterpreter.h"" // For gInterpreterMutex; 21#include ""TVirtualMutex.h""; 22#include ""TStreamerInfoActions.h""; 23#include ""THashTable.h""; 24#include ""THashList.h""; 25#include <cstdlib>; 26 ; 27#define MESSAGE(which,text); 28 ; 29/**; 30\class TGenVectorProxy; 31\ingroup IO; 32Local optimization class.; 33 ; 34Collection proxies get copied. On copy we switch the type of the; 35proxy to the concrete STL type. The concrete types are optimized; 36for element access.; 37*/; 38 ; 39class TGenVectorProxy : public TGenCollectionProxy {; 40public:; 41 // Standard Destructor; 42 TGenVectorProxy(const TGenCollectionProxy& c) : TGenCollectionProxy(c); 43 {; 44 }; 45 // Standard Destructor; 46 ~TGenVectorProxy() override; 47 {; 48 }; 49 // Return the address of the value at index 'idx'; 50 void* At(UInt_t idx) override; 51 {; 52 if ( fEnv && fEnv->fObject ) {; 53 fEnv->fIdx = idx;; 54 switch( idx ) {; 55 case 0:; 56 return fEnv->fStart = fFirst.invoke(fEnv);; 57 default:; 58 if (! fEnv->fStart ) fEnv->fStart = fFirst.invoke(fEnv);; 59 return ((char*)fEnv->fStart) + fValDiff*idx;; 60 }; 61 }; 62 Fatal(""TGenVectorProxy"",""At> Logic error - no proxy object set."");; 63 return nullptr;; 64 }; 65 // Call to delete/destruct individual item; 66 void DeleteItem(Bool_t force, void* ptr) const override; 67 {; 68 if ( force && ptr ) {; 69 if ( fVal->fProperties&kNeedDelete) {; 70 TVirtualCollectionProxy *proxy = fVal->fType->GetCollectionPr",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:2491,Performance,optimiz,optimization,2491,"STL type. The concrete types are optimized; 36for element access.; 37*/; 38 ; 39class TGenVectorProxy : public TGenCollectionProxy {; 40public:; 41 // Standard Destructor; 42 TGenVectorProxy(const TGenCollectionProxy& c) : TGenCollectionProxy(c); 43 {; 44 }; 45 // Standard Destructor; 46 ~TGenVectorProxy() override; 47 {; 48 }; 49 // Return the address of the value at index 'idx'; 50 void* At(UInt_t idx) override; 51 {; 52 if ( fEnv && fEnv->fObject ) {; 53 fEnv->fIdx = idx;; 54 switch( idx ) {; 55 case 0:; 56 return fEnv->fStart = fFirst.invoke(fEnv);; 57 default:; 58 if (! fEnv->fStart ) fEnv->fStart = fFirst.invoke(fEnv);; 59 return ((char*)fEnv->fStart) + fValDiff*idx;; 60 }; 61 }; 62 Fatal(""TGenVectorProxy"",""At> Logic error - no proxy object set."");; 63 return nullptr;; 64 }; 65 // Call to delete/destruct individual item; 66 void DeleteItem(Bool_t force, void* ptr) const override; 67 {; 68 if ( force && ptr ) {; 69 if ( fVal->fProperties&kNeedDelete) {; 70 TVirtualCollectionProxy *proxy = fVal->fType->GetCollectionProxy();; 71 TPushPop helper(proxy,ptr);; 72 proxy->Clear(""force"");; 73 }; 74 fVal->DeleteItem(ptr);; 75 }; 76 }; 77};; 78 ; 79/**; 80\class TGenVectorBoolProxy; 81\ingroup IO; 82Local optimization class.; 83 ; 84Collection proxies get copied. On copy we switch the type of the; 85proxy to the concrete STL type. The concrete types are optimized; 86for element access.; 87*/; 88class TGenVectorBoolProxy : public TGenCollectionProxy {; 89 Bool_t fLastValue;; 90 ; 91public:; 92 TGenVectorBoolProxy(const TGenCollectionProxy& c) : TGenCollectionProxy(c), fLastValue(false); 93 {; 94 // Standard Constructor.; 95 }; 96 ~TGenVectorBoolProxy() override; 97 {; 98 // Standard Destructor.; 99 }; 100 void* At(UInt_t idx) override; 101 {; 102 // Return the address of the value at index 'idx'; 103 ; 104 // However we can 'take' the address of the content of std::vector<bool>.; 105 if ( fEnv && fEnv->fObject ) {; 106 auto vec = (std::vector<bool> *)(fEnv->fObject);; 107",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:2642,Performance,optimiz,optimized,2642,"x 'idx'; 50 void* At(UInt_t idx) override; 51 {; 52 if ( fEnv && fEnv->fObject ) {; 53 fEnv->fIdx = idx;; 54 switch( idx ) {; 55 case 0:; 56 return fEnv->fStart = fFirst.invoke(fEnv);; 57 default:; 58 if (! fEnv->fStart ) fEnv->fStart = fFirst.invoke(fEnv);; 59 return ((char*)fEnv->fStart) + fValDiff*idx;; 60 }; 61 }; 62 Fatal(""TGenVectorProxy"",""At> Logic error - no proxy object set."");; 63 return nullptr;; 64 }; 65 // Call to delete/destruct individual item; 66 void DeleteItem(Bool_t force, void* ptr) const override; 67 {; 68 if ( force && ptr ) {; 69 if ( fVal->fProperties&kNeedDelete) {; 70 TVirtualCollectionProxy *proxy = fVal->fType->GetCollectionProxy();; 71 TPushPop helper(proxy,ptr);; 72 proxy->Clear(""force"");; 73 }; 74 fVal->DeleteItem(ptr);; 75 }; 76 }; 77};; 78 ; 79/**; 80\class TGenVectorBoolProxy; 81\ingroup IO; 82Local optimization class.; 83 ; 84Collection proxies get copied. On copy we switch the type of the; 85proxy to the concrete STL type. The concrete types are optimized; 86for element access.; 87*/; 88class TGenVectorBoolProxy : public TGenCollectionProxy {; 89 Bool_t fLastValue;; 90 ; 91public:; 92 TGenVectorBoolProxy(const TGenCollectionProxy& c) : TGenCollectionProxy(c), fLastValue(false); 93 {; 94 // Standard Constructor.; 95 }; 96 ~TGenVectorBoolProxy() override; 97 {; 98 // Standard Destructor.; 99 }; 100 void* At(UInt_t idx) override; 101 {; 102 // Return the address of the value at index 'idx'; 103 ; 104 // However we can 'take' the address of the content of std::vector<bool>.; 105 if ( fEnv && fEnv->fObject ) {; 106 auto vec = (std::vector<bool> *)(fEnv->fObject);; 107 fLastValue = (*vec)[idx];; 108 fEnv->fIdx = idx;; 109 return &fLastValue;; 110 }; 111 Fatal(""TGenVectorProxy"",""At> Logic error - no proxy object set."");; 112 return nullptr;; 113 }; 114 ; 115 void DeleteItem(Bool_t force, void* ptr) const override; 116 {; 117 // Call to delete/destruct individual item; 118 if ( force && ptr ) {; 119 fVal->DeleteItem(ptr);; 120 }; 121 }; 1",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:3795,Performance,optimiz,optimization,3795,". The concrete types are optimized; 86for element access.; 87*/; 88class TGenVectorBoolProxy : public TGenCollectionProxy {; 89 Bool_t fLastValue;; 90 ; 91public:; 92 TGenVectorBoolProxy(const TGenCollectionProxy& c) : TGenCollectionProxy(c), fLastValue(false); 93 {; 94 // Standard Constructor.; 95 }; 96 ~TGenVectorBoolProxy() override; 97 {; 98 // Standard Destructor.; 99 }; 100 void* At(UInt_t idx) override; 101 {; 102 // Return the address of the value at index 'idx'; 103 ; 104 // However we can 'take' the address of the content of std::vector<bool>.; 105 if ( fEnv && fEnv->fObject ) {; 106 auto vec = (std::vector<bool> *)(fEnv->fObject);; 107 fLastValue = (*vec)[idx];; 108 fEnv->fIdx = idx;; 109 return &fLastValue;; 110 }; 111 Fatal(""TGenVectorProxy"",""At> Logic error - no proxy object set."");; 112 return nullptr;; 113 }; 114 ; 115 void DeleteItem(Bool_t force, void* ptr) const override; 116 {; 117 // Call to delete/destruct individual item; 118 if ( force && ptr ) {; 119 fVal->DeleteItem(ptr);; 120 }; 121 }; 122};; 123 ; 124//////////////////////////////////////////////////////////////////////////; 125// //; 126// class TGenBitsetProxy; 127//; 128// Local optimization class.; 129//; 130// Collection proxies get copied. On copy we switch the type of the; 131// proxy to the concrete STL type. The concrete types are optimized; 132// for element access.; 133//; 134//////////////////////////////////////////////////////////////////////////; 135class TGenBitsetProxy : public TGenCollectionProxy {; 136 ; 137public:; 138 TGenBitsetProxy(const TGenCollectionProxy& c) : TGenCollectionProxy(c); 139 {; 140 // Standard Constructor.; 141 }; 142 ~TGenBitsetProxy() override; 143 {; 144 // Standard Destructor.; 145 }; 146 void* At(UInt_t idx) override; 147 {; 148 // Return the address of the value at index 'idx'; 149 ; 150 if ( fEnv && fEnv->fObject ) {; 151 switch( idx ) {; 152 case 0:; 153 fEnv->fStart = fFirst.invoke(fEnv);; 154 fEnv->fIdx = idx;; 155 break;; 156 default:; 157 ",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:3956,Performance,optimiz,optimized,3956,"98 // Standard Destructor.; 99 }; 100 void* At(UInt_t idx) override; 101 {; 102 // Return the address of the value at index 'idx'; 103 ; 104 // However we can 'take' the address of the content of std::vector<bool>.; 105 if ( fEnv && fEnv->fObject ) {; 106 auto vec = (std::vector<bool> *)(fEnv->fObject);; 107 fLastValue = (*vec)[idx];; 108 fEnv->fIdx = idx;; 109 return &fLastValue;; 110 }; 111 Fatal(""TGenVectorProxy"",""At> Logic error - no proxy object set."");; 112 return nullptr;; 113 }; 114 ; 115 void DeleteItem(Bool_t force, void* ptr) const override; 116 {; 117 // Call to delete/destruct individual item; 118 if ( force && ptr ) {; 119 fVal->DeleteItem(ptr);; 120 }; 121 }; 122};; 123 ; 124//////////////////////////////////////////////////////////////////////////; 125// //; 126// class TGenBitsetProxy; 127//; 128// Local optimization class.; 129//; 130// Collection proxies get copied. On copy we switch the type of the; 131// proxy to the concrete STL type. The concrete types are optimized; 132// for element access.; 133//; 134//////////////////////////////////////////////////////////////////////////; 135class TGenBitsetProxy : public TGenCollectionProxy {; 136 ; 137public:; 138 TGenBitsetProxy(const TGenCollectionProxy& c) : TGenCollectionProxy(c); 139 {; 140 // Standard Constructor.; 141 }; 142 ~TGenBitsetProxy() override; 143 {; 144 // Standard Destructor.; 145 }; 146 void* At(UInt_t idx) override; 147 {; 148 // Return the address of the value at index 'idx'; 149 ; 150 if ( fEnv && fEnv->fObject ) {; 151 switch( idx ) {; 152 case 0:; 153 fEnv->fStart = fFirst.invoke(fEnv);; 154 fEnv->fIdx = idx;; 155 break;; 156 default:; 157 fEnv->fIdx = idx - fEnv->fIdx;; 158 if (! fEnv->fStart ) fEnv->fStart = fFirst.invoke(fEnv);; 159 fNext.invoke(fEnv);; 160 fEnv->fIdx = idx;; 161 break;; 162 }; 163 typedef ROOT::TCollectionProxyInfo::Environ<std::pair<size_t,Bool_t> > EnvType_t;; 164 EnvType_t *e = (EnvType_t*)fEnv;; 165 return &(e->fIterator.second);; 166 }; 167 Fatal(""TGen",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:5302,Performance,optimiz,optimization,5302,"etProxy(const TGenCollectionProxy& c) : TGenCollectionProxy(c); 139 {; 140 // Standard Constructor.; 141 }; 142 ~TGenBitsetProxy() override; 143 {; 144 // Standard Destructor.; 145 }; 146 void* At(UInt_t idx) override; 147 {; 148 // Return the address of the value at index 'idx'; 149 ; 150 if ( fEnv && fEnv->fObject ) {; 151 switch( idx ) {; 152 case 0:; 153 fEnv->fStart = fFirst.invoke(fEnv);; 154 fEnv->fIdx = idx;; 155 break;; 156 default:; 157 fEnv->fIdx = idx - fEnv->fIdx;; 158 if (! fEnv->fStart ) fEnv->fStart = fFirst.invoke(fEnv);; 159 fNext.invoke(fEnv);; 160 fEnv->fIdx = idx;; 161 break;; 162 }; 163 typedef ROOT::TCollectionProxyInfo::Environ<std::pair<size_t,Bool_t> > EnvType_t;; 164 EnvType_t *e = (EnvType_t*)fEnv;; 165 return &(e->fIterator.second);; 166 }; 167 Fatal(""TGenVectorProxy"",""At> Logic error - no proxy object set."");; 168 return 0;; 169 }; 170 ; 171 void DeleteItem(Bool_t force, void* ptr) const override; 172 {; 173 // Call to delete/destruct individual item; 174 if ( force && ptr ) {; 175 fVal->DeleteItem(ptr);; 176 }; 177 }; 178};; 179 ; 180/*; 181\class TGenListProxy; 182\ingroup IO; 183Local optimization class.; 184 ; 185Collection proxies get copied. On copy we switch the type of the; 186proxy to the concrete STL type. The concrete types are optimized; 187for element access.; 188**/; 189 ; 190class TGenListProxy : public TGenVectorProxy {; 191public:; 192 // Standard Destructor; 193 TGenListProxy(const TGenCollectionProxy& c) : TGenVectorProxy(c); 194 {; 195 }; 196 // Standard Destructor; 197 ~TGenListProxy() override; 198 {; 199 }; 200 // Return the address of the value at index 'idx'; 201 void* At(UInt_t idx) override; 202 {; 203 if ( fEnv && fEnv->fObject ) {; 204 switch( idx ) {; 205 case 0:; 206 fEnv->fIdx = idx;; 207 return fEnv->fStart = fFirst.invoke(fEnv);; 208 default: {; 209 fEnv->fIdx = idx - fEnv->fIdx;; 210 if (! fEnv->fStart ) fEnv->fStart = fFirst.invoke(fEnv);; 211 void* result = fNext.invoke(fEnv);; 212 fEnv->fIdx = idx;; ",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:5456,Performance,optimiz,optimized,5456," ( fEnv && fEnv->fObject ) {; 151 switch( idx ) {; 152 case 0:; 153 fEnv->fStart = fFirst.invoke(fEnv);; 154 fEnv->fIdx = idx;; 155 break;; 156 default:; 157 fEnv->fIdx = idx - fEnv->fIdx;; 158 if (! fEnv->fStart ) fEnv->fStart = fFirst.invoke(fEnv);; 159 fNext.invoke(fEnv);; 160 fEnv->fIdx = idx;; 161 break;; 162 }; 163 typedef ROOT::TCollectionProxyInfo::Environ<std::pair<size_t,Bool_t> > EnvType_t;; 164 EnvType_t *e = (EnvType_t*)fEnv;; 165 return &(e->fIterator.second);; 166 }; 167 Fatal(""TGenVectorProxy"",""At> Logic error - no proxy object set."");; 168 return 0;; 169 }; 170 ; 171 void DeleteItem(Bool_t force, void* ptr) const override; 172 {; 173 // Call to delete/destruct individual item; 174 if ( force && ptr ) {; 175 fVal->DeleteItem(ptr);; 176 }; 177 }; 178};; 179 ; 180/*; 181\class TGenListProxy; 182\ingroup IO; 183Local optimization class.; 184 ; 185Collection proxies get copied. On copy we switch the type of the; 186proxy to the concrete STL type. The concrete types are optimized; 187for element access.; 188**/; 189 ; 190class TGenListProxy : public TGenVectorProxy {; 191public:; 192 // Standard Destructor; 193 TGenListProxy(const TGenCollectionProxy& c) : TGenVectorProxy(c); 194 {; 195 }; 196 // Standard Destructor; 197 ~TGenListProxy() override; 198 {; 199 }; 200 // Return the address of the value at index 'idx'; 201 void* At(UInt_t idx) override; 202 {; 203 if ( fEnv && fEnv->fObject ) {; 204 switch( idx ) {; 205 case 0:; 206 fEnv->fIdx = idx;; 207 return fEnv->fStart = fFirst.invoke(fEnv);; 208 default: {; 209 fEnv->fIdx = idx - fEnv->fIdx;; 210 if (! fEnv->fStart ) fEnv->fStart = fFirst.invoke(fEnv);; 211 void* result = fNext.invoke(fEnv);; 212 fEnv->fIdx = idx;; 213 return result;; 214 }; 215 }; 216 }; 217 Fatal(""TGenListProxy"",""At> Logic error - no proxy object set."");; 218 return nullptr;; 219 }; 220};; 221 ; 222/**; 223\class TGenSetProxy; 224\ingroup IO; 225Localoptimization class.; 226 ; 227Collection proxies get copied. On copy we switch the ty",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:6530,Performance,optimiz,optimized,6530,"ic TGenVectorProxy {; 191public:; 192 // Standard Destructor; 193 TGenListProxy(const TGenCollectionProxy& c) : TGenVectorProxy(c); 194 {; 195 }; 196 // Standard Destructor; 197 ~TGenListProxy() override; 198 {; 199 }; 200 // Return the address of the value at index 'idx'; 201 void* At(UInt_t idx) override; 202 {; 203 if ( fEnv && fEnv->fObject ) {; 204 switch( idx ) {; 205 case 0:; 206 fEnv->fIdx = idx;; 207 return fEnv->fStart = fFirst.invoke(fEnv);; 208 default: {; 209 fEnv->fIdx = idx - fEnv->fIdx;; 210 if (! fEnv->fStart ) fEnv->fStart = fFirst.invoke(fEnv);; 211 void* result = fNext.invoke(fEnv);; 212 fEnv->fIdx = idx;; 213 return result;; 214 }; 215 }; 216 }; 217 Fatal(""TGenListProxy"",""At> Logic error - no proxy object set."");; 218 return nullptr;; 219 }; 220};; 221 ; 222/**; 223\class TGenSetProxy; 224\ingroup IO; 225Localoptimization class.; 226 ; 227Collection proxies get copied. On copy we switch the type of the; 228proxy to the concrete STL type. The concrete types are optimized; 229for element access.; 230*/; 231 ; 232class TGenSetProxy : public TGenVectorProxy {; 233public:; 234 // Standard Destructor; 235 TGenSetProxy(const TGenCollectionProxy& c) : TGenVectorProxy(c); 236 {; 237 }; 238 // Standard Destructor; 239 ~TGenSetProxy() override; 240 {; 241 }; 242 // Return the address of the value at index 'idx'; 243 void* At(UInt_t idx) override; 244 {; 245 if ( fEnv && fEnv->fObject ) {; 246 if ( fEnv->fUseTemp ) {; 247 return (((char*)fEnv->fTemp)+idx*fValDiff);; 248 }; 249 switch( idx ) {; 250 case 0:; 251 fEnv->fIdx = idx;; 252 return fEnv->fStart = fFirst.invoke(fEnv);; 253 default: {; 254 fEnv->fIdx = idx - fEnv->fIdx;; 255 if (! fEnv->fStart ) fEnv->fStart = fFirst.invoke(fEnv);; 256 void* result = fNext.invoke(fEnv);; 257 fEnv->fIdx = idx;; 258 return result;; 259 }; 260 }; 261 }; 262 Fatal(""TGenSetProxy"",""At> Logic error - no proxy object set."");; 263 return nullptr;; 264 }; 265};; 266 ; 267/**; 268\class TGenMapProxy; 269\ingroup IO; 270Localoptim",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:7684,Performance,optimiz,optimized,7684,"st TGenCollectionProxy& c) : TGenVectorProxy(c); 236 {; 237 }; 238 // Standard Destructor; 239 ~TGenSetProxy() override; 240 {; 241 }; 242 // Return the address of the value at index 'idx'; 243 void* At(UInt_t idx) override; 244 {; 245 if ( fEnv && fEnv->fObject ) {; 246 if ( fEnv->fUseTemp ) {; 247 return (((char*)fEnv->fTemp)+idx*fValDiff);; 248 }; 249 switch( idx ) {; 250 case 0:; 251 fEnv->fIdx = idx;; 252 return fEnv->fStart = fFirst.invoke(fEnv);; 253 default: {; 254 fEnv->fIdx = idx - fEnv->fIdx;; 255 if (! fEnv->fStart ) fEnv->fStart = fFirst.invoke(fEnv);; 256 void* result = fNext.invoke(fEnv);; 257 fEnv->fIdx = idx;; 258 return result;; 259 }; 260 }; 261 }; 262 Fatal(""TGenSetProxy"",""At> Logic error - no proxy object set."");; 263 return nullptr;; 264 }; 265};; 266 ; 267/**; 268\class TGenMapProxy; 269\ingroup IO; 270Localoptimization class.; 271 ; 272Collection proxies get copied. On copy we switch the type of the; 273proxy to the concrete STL type. The concrete types are optimized; 274for element access.; 275*/; 276 ; 277class TGenMapProxy : public TGenSetProxy {; 278public:; 279 // Standard Destructor; 280 TGenMapProxy(const TGenCollectionProxy& c) : TGenSetProxy(c); 281 {; 282 }; 283 // Standard Destructor; 284 ~TGenMapProxy() override; 285 {; 286 }; 287 // Call to delete/destruct individual item; 288 void DeleteItem(Bool_t force, void* ptr) const override; 289 {; 290 if (force) {; 291 if ( fKey->fProperties&kNeedDelete) {; 292 TVirtualCollectionProxy *proxy = fKey->fType->GetCollectionProxy();; 293 TPushPop helper(proxy,fKey->fCase&kIsPointer ? *(void**)ptr : ptr);; 294 proxy->Clear(""force"");; 295 }; 296 if ( fVal->fProperties&kNeedDelete) {; 297 TVirtualCollectionProxy *proxy = fVal->fType->GetCollectionProxy();; 298 char *addr = ((char*)ptr)+fValOffset;; 299 TPushPop helper(proxy,fVal->fCase&kIsPointer ? *(void**)addr : addr);; 300 proxy->Clear(""force"");; 301 }; 302 }; 303 if ( fKey->fCase&kIsPointer ) {; 304 fKey->DeleteItem(*(void**)ptr);; 305 }; 306",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:17405,Performance,load,load,17405," the abstract iteration sequence and functionality like; 550 size(), clear(), resize(). resize() may be a void operation.; 551*/; 552 ; 553////////////////////////////////////////////////////////////////////////////////; 554/// Build a proxy for an emulated container.; 555 ; 556TGenCollectionProxy::TGenCollectionProxy(const TGenCollectionProxy& copy); 557 : TVirtualCollectionProxy(copy.fClass),; 558 fTypeinfo(copy.fTypeinfo); 559{; 560 fEnv = 0;; 561 fName = copy.fName;; 562 fPointers = copy.fPointers;; 563 fSTL_type = copy.fSTL_type;; 564 fSize.call = copy.fSize.call;; 565 fNext.call = copy.fNext.call;; 566 fFirst.call = copy.fFirst.call;; 567 fClear.call = copy.fClear.call;; 568 fResize = copy.fResize;; 569 fDestruct = copy.fDestruct;; 570 fConstruct = copy.fConstruct;; 571 fFeed = copy.fFeed;; 572 fCollect = copy.fCollect;; 573 fCreateEnv.call = copy.fCreateEnv.call;; 574 fValOffset = copy.fValOffset;; 575 fValDiff = copy.fValDiff;; 576 fValue = copy.fValue.load(std::memory_order_relaxed) ? new Value(*copy.fValue) : 0;; 577 fVal = copy.fVal ? new Value(*copy.fVal) : 0;; 578 fKey = copy.fKey ? new Value(*copy.fKey) : 0;; 579 fOnFileClass = copy.fOnFileClass;; 580 fReadMemberWise = new TObjArray(TCollection::kInitCapacity,-1);; 581 fConversionReadMemberWise = 0;; 582 fWriteMemberWise = 0;; 583 fProperties = copy.fProperties;; 584 fFunctionCreateIterators = copy.fFunctionCreateIterators;; 585 fFunctionCopyIterator = copy.fFunctionCopyIterator;; 586 fFunctionNextIterator = copy.fFunctionNextIterator;; 587 fFunctionDeleteIterator = copy.fFunctionDeleteIterator;; 588 fFunctionDeleteTwoIterators = copy.fFunctionDeleteTwoIterators;; 589}; 590 ; 591////////////////////////////////////////////////////////////////////////////////; 592/// Build a proxy for a collection whose type is described by 'collectionClass'.; 593 ; 594TGenCollectionProxy::TGenCollectionProxy(Info_t info, size_t iter_size); 595 : TVirtualCollectionProxy(0),; 596 fTypeinfo(info); 597{; 598 fEnv = 0;; 599",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:21662,Performance,load,load,21662," }; 677 fReadMemberWise = new TObjArray(TCollection::kInitCapacity,-1);; 678 fConversionReadMemberWise = 0;; 679 fWriteMemberWise = 0;; 680 fFunctionCreateIterators = info.fCreateIterators;; 681 fFunctionCopyIterator = info.fCopyIterator;; 682 fFunctionNextIterator = info.fNext;; 683 fFunctionDeleteIterator = info.fDeleteSingleIterator;; 684 fFunctionDeleteTwoIterators = info.fDeleteTwoIterators;; 685}; 686 ; 687namespace {; 688 template <class vec>; 689 void clearVector(vec& v); 690 {; 691 // Clear out the proxies.; 692 ; 693 for(typename vec::iterator i=v.begin(); i != v.end(); ++i) {; 694 typename vec::value_type e = *i;; 695 if ( e ) {; 696 delete e;; 697 }; 698 }; 699 v.clear();; 700 }; 701}; 702////////////////////////////////////////////////////////////////////////////////; 703/// Standard destructor; 704 ; 705TGenCollectionProxy::~TGenCollectionProxy(); 706{; 707 clearVector(fProxyList);; 708 clearVector(fProxyKept);; 709 clearVector(fStaged);; 710 ; 711 if ( fValue.load() ) delete fValue.load();; 712 if ( fVal ) delete fVal;; 713 if ( fKey ) delete fKey;; 714 ; 715 delete fReadMemberWise;; 716 if (fConversionReadMemberWise) {; 717 std::map<std::string, TObjArray*>::iterator it;; 718 std::map<std::string, TObjArray*>::iterator end = fConversionReadMemberWise->end();; 719 for( it = fConversionReadMemberWise->begin(); it != end; ++it ) {; 720 delete it->second;; 721 }; 722 delete fConversionReadMemberWise;; 723 fConversionReadMemberWise = 0;; 724 }; 725 delete fWriteMemberWise;; 726}; 727 ; 728////////////////////////////////////////////////////////////////////////////////; 729/// Virtual copy constructor; 730 ; 731TVirtualCollectionProxy* TGenCollectionProxy::Generate() const; 732{; 733 if ( !fValue.load(std::memory_order_relaxed) ) Initialize(kFALSE);; 734 ; 735 if( fPointers ); 736 return new TGenCollectionProxy(*this);; 737 ; 738 switch(fSTL_type) {; 739 case ROOT::kSTLbitset: {; 740 return new TGenBitsetProxy(*this);; 741 }; 742 case ROOT::kSTLvector: {; 7",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:21685,Performance,load,load,21685,"info.fDeleteTwoIterators;; 685}; 686 ; 687namespace {; 688 template <class vec>; 689 void clearVector(vec& v); 690 {; 691 // Clear out the proxies.; 692 ; 693 for(typename vec::iterator i=v.begin(); i != v.end(); ++i) {; 694 typename vec::value_type e = *i;; 695 if ( e ) {; 696 delete e;; 697 }; 698 }; 699 v.clear();; 700 }; 701}; 702////////////////////////////////////////////////////////////////////////////////; 703/// Standard destructor; 704 ; 705TGenCollectionProxy::~TGenCollectionProxy(); 706{; 707 clearVector(fProxyList);; 708 clearVector(fProxyKept);; 709 clearVector(fStaged);; 710 ; 711 if ( fValue.load() ) delete fValue.load();; 712 if ( fVal ) delete fVal;; 713 if ( fKey ) delete fKey;; 714 ; 715 delete fReadMemberWise;; 716 if (fConversionReadMemberWise) {; 717 std::map<std::string, TObjArray*>::iterator it;; 718 std::map<std::string, TObjArray*>::iterator end = fConversionReadMemberWise->end();; 719 for( it = fConversionReadMemberWise->begin(); it != end; ++it ) {; 720 delete it->second;; 721 }; 722 delete fConversionReadMemberWise;; 723 fConversionReadMemberWise = 0;; 724 }; 725 delete fWriteMemberWise;; 726}; 727 ; 728////////////////////////////////////////////////////////////////////////////////; 729/// Virtual copy constructor; 730 ; 731TVirtualCollectionProxy* TGenCollectionProxy::Generate() const; 732{; 733 if ( !fValue.load(std::memory_order_relaxed) ) Initialize(kFALSE);; 734 ; 735 if( fPointers ); 736 return new TGenCollectionProxy(*this);; 737 ; 738 switch(fSTL_type) {; 739 case ROOT::kSTLbitset: {; 740 return new TGenBitsetProxy(*this);; 741 }; 742 case ROOT::kSTLvector: {; 743 if ((*fValue).fKind == kBool_t) {; 744 return new TGenVectorBoolProxy(*this);; 745 } else {; 746 return new TGenVectorProxy(*this);; 747 }; 748 }; 749 case ROOT::kSTLlist:; 750 case ROOT::kSTLforwardlist:; 751 return new TGenListProxy(*this);; 752 case ROOT::kSTLmap:; 753 case ROOT::kSTLunorderedmap:; 754 case ROOT::kSTLmultimap:; 755 case ROOT::kSTLunorderedmultimap:",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:22409,Performance,load,load,22409,"{; 707 clearVector(fProxyList);; 708 clearVector(fProxyKept);; 709 clearVector(fStaged);; 710 ; 711 if ( fValue.load() ) delete fValue.load();; 712 if ( fVal ) delete fVal;; 713 if ( fKey ) delete fKey;; 714 ; 715 delete fReadMemberWise;; 716 if (fConversionReadMemberWise) {; 717 std::map<std::string, TObjArray*>::iterator it;; 718 std::map<std::string, TObjArray*>::iterator end = fConversionReadMemberWise->end();; 719 for( it = fConversionReadMemberWise->begin(); it != end; ++it ) {; 720 delete it->second;; 721 }; 722 delete fConversionReadMemberWise;; 723 fConversionReadMemberWise = 0;; 724 }; 725 delete fWriteMemberWise;; 726}; 727 ; 728////////////////////////////////////////////////////////////////////////////////; 729/// Virtual copy constructor; 730 ; 731TVirtualCollectionProxy* TGenCollectionProxy::Generate() const; 732{; 733 if ( !fValue.load(std::memory_order_relaxed) ) Initialize(kFALSE);; 734 ; 735 if( fPointers ); 736 return new TGenCollectionProxy(*this);; 737 ; 738 switch(fSTL_type) {; 739 case ROOT::kSTLbitset: {; 740 return new TGenBitsetProxy(*this);; 741 }; 742 case ROOT::kSTLvector: {; 743 if ((*fValue).fKind == kBool_t) {; 744 return new TGenVectorBoolProxy(*this);; 745 } else {; 746 return new TGenVectorProxy(*this);; 747 }; 748 }; 749 case ROOT::kSTLlist:; 750 case ROOT::kSTLforwardlist:; 751 return new TGenListProxy(*this);; 752 case ROOT::kSTLmap:; 753 case ROOT::kSTLunorderedmap:; 754 case ROOT::kSTLmultimap:; 755 case ROOT::kSTLunorderedmultimap:; 756 return new TGenMapProxy(*this);; 757 case ROOT::kSTLset:; 758 case ROOT::kSTLunorderedset:; 759 case ROOT::kSTLmultiset:; 760 case ROOT::kSTLunorderedmultiset:; 761 return new TGenSetProxy(*this);; 762 default:; 763 return new TGenCollectionProxy(*this);; 764 }; 765}; 766 ; 767////////////////////////////////////////////////////////////////////////////////; 768/// Proxy initializer; 769 ; 770TGenCollectionProxy *TGenCollectionProxy::Initialize(Bool_t silent) const; 771{; 772 TGenCollectionPro",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:23615,Performance,load,load,23615," TGenVectorBoolProxy(*this);; 745 } else {; 746 return new TGenVectorProxy(*this);; 747 }; 748 }; 749 case ROOT::kSTLlist:; 750 case ROOT::kSTLforwardlist:; 751 return new TGenListProxy(*this);; 752 case ROOT::kSTLmap:; 753 case ROOT::kSTLunorderedmap:; 754 case ROOT::kSTLmultimap:; 755 case ROOT::kSTLunorderedmultimap:; 756 return new TGenMapProxy(*this);; 757 case ROOT::kSTLset:; 758 case ROOT::kSTLunorderedset:; 759 case ROOT::kSTLmultiset:; 760 case ROOT::kSTLunorderedmultiset:; 761 return new TGenSetProxy(*this);; 762 default:; 763 return new TGenCollectionProxy(*this);; 764 }; 765}; 766 ; 767////////////////////////////////////////////////////////////////////////////////; 768/// Proxy initializer; 769 ; 770TGenCollectionProxy *TGenCollectionProxy::Initialize(Bool_t silent) const; 771{; 772 TGenCollectionProxy* p = const_cast<TGenCollectionProxy*>(this);; 773 if ( fValue.load() ) return p;; 774 return p->InitializeEx(silent);; 775}; 776 ; 777////////////////////////////////////////////////////////////////////////////////; 778/// Reset the info gathered from StreamerInfos and value's TClass.; 779Bool_t TGenCollectionProxy::Reset(); 780{; 781 if (fReadMemberWise); 782 fReadMemberWise->Clear();; 783 delete fWriteMemberWise;; 784 fWriteMemberWise = nullptr;; 785 if (fConversionReadMemberWise); 786 fConversionReadMemberWise->clear();; 787 return kTRUE;; 788}; 789 ; 790////////////////////////////////////////////////////////////////////////////////; 791/// Check existence of function pointers; 792 ; 793void TGenCollectionProxy::CheckFunctions() const; 794{; 795 if ( 0 == fSize.call ) {; 796 Fatal(""TGenCollectionProxy"",""No 'size' function pointer for class %s present."",fName.c_str());; 797 }; 798 if ( 0 == fResize ) {; 799 Fatal(""TGenCollectionProxy"",""No 'resize' function for class %s present."",fName.c_str());; 800 }; 801 if ( 0 == fNext.call ) {; 802 Fatal(""TGenCollectionProxy"",""No 'next' function for class %s present."",fName.c_str());; 803 }; 804 if ( 0 == fFirst.cal",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:26510,Performance,load,load,26510,") {; 823 Fatal(""TGenCollectionProxy"",""No 'environment creation' function for class %s present."",fName.c_str());; 824 }; 825}; 826 ; 827////////////////////////////////////////////////////////////////////////////////; 828/// Utility routine to issue a Fatal error is the Value object is not valid; 829 ; 830static TGenCollectionProxy::Value *R__CreateValue(const std::string &name, Bool_t silent,; 831 size_t hint_pair_offset = 0, size_t hint_pair_size = 0); 832{; 833 TGenCollectionProxy::Value *val = new TGenCollectionProxy::Value( name, silent, hint_pair_offset, hint_pair_size );; 834 if ( !val->IsValid() ) {; 835 Fatal(""TGenCollectionProxy"",""Could not find %s!"",name.c_str());; 836 }; 837 return val;; 838}; 839 ; 840////////////////////////////////////////////////////////////////////////////////; 841/// Proxy initializer; 842 ; 843TGenCollectionProxy *TGenCollectionProxy::InitializeEx(Bool_t silent); 844{; 845 R__LOCKGUARD(gInterpreterMutex);; 846 if (fValue.load()) return this;; 847 ; 848 TClass *cl = fClass ? fClass.GetClass() : TClass::GetClass(fTypeinfo,kTRUE,silent);; 849 if ( cl ) {; 850 fEnv = 0;; 851 fName = cl->GetName();; 852 fPointers = false;; 853 int nested = 0;; 854 std::vector<std::string> inside;; 855 int num = TClassEdit::GetSplit(cl->GetName(),inside,nested);; 856 if ( num > 1 ) {; 857 std::string nam;; 858 Value* newfValue = nullptr;; 859 if ( inside[0].find(""stdext::hash_"") != std::string::npos ); 860 inside[0].replace(3,10,""::"");; 861 if ( inside[0].find(""__gnu_cxx::hash_"") != std::string::npos ); 862 inside[0].replace(0,16,""std::"");; 863 fSTL_type = TClassEdit::STLKind(inside[0]);; 864 switch ( fSTL_type ) {; 865 case ROOT::kSTLmap:; 866 case ROOT::kSTLunorderedmap:; 867 case ROOT::kSTLmultimap:; 868 case ROOT::kSTLunorderedmultimap:; 869 case ROOT::kSTLset:; 870 case ROOT::kSTLunorderedset:; 871 case ROOT::kSTLmultiset:; 872 case ROOT::kSTLunorderedmultiset:; 873 case ROOT::kSTLbitset: // not really an associate container but it has no real iterat",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:28568,Performance,load,load,28568,"STLbitset: // not really an associate container but it has no real iterator.; 874 fProperties |= kIsAssociative;; 875 if (num > 3 && !inside[3].empty()) {; 876 if (! TClassEdit::IsDefAlloc(inside[3].c_str(),inside[0].c_str())) {; 877 fProperties |= kCustomAlloc;; 878 }; 879 }; 880 break;; 881 };; 882 ; 883 int slong = sizeof(void*);; 884 switch ( fSTL_type ) {; 885 case ROOT::kSTLmap:; 886 case ROOT::kSTLunorderedmap:; 887 case ROOT::kSTLmultimap:; 888 case ROOT::kSTLunorderedmultimap:; 889 nam = ""pair<""+inside[1]+"",""+inside[2];; 890 nam += (nam[nam.length()-1]=='>') ? "" >"" : "">"";; 891 ; 892 fVal = R__CreateValue(inside[2], silent);; 893 fKey = R__CreateValue(inside[1], silent);; 894 ; 895 {; 896 TInterpreter::SuspendAutoParsing autoParseRaii(gCling);; 897 TClass *paircl = TClass::GetClass(nam.c_str(), true, false, fValOffset, fValDiff);; 898 if (paircl == nullptr) {; 899 // We need to emulate the pair; 900 auto info = TVirtualStreamerInfo::Factory()->GenerateInfoForPair(inside[1], inside[2], silent, fValOffset, fValDiff);; 901 if (!info) {; 902 Fatal(""InitializeEx"",; 903 ""Could not load nor generate the dictionary for \""%s\"", some element might be missing their dictionary (eg. enums)"",; 904 nam.c_str());; 905 }; 906 } else {; 907 if ((!paircl->IsSyntheticPair() && paircl->GetState() < TClass::kInterpreted) || paircl->GetClassSize() != fValDiff) {; 908 if (paircl->GetState() >= TClass::kInterpreted); 909 Fatal(""InitializeEx"",; 910 ""The %s for %s reports a class size that is inconsistent with the one registered ""; 911 ""through the CollectionProxy for %s: %d vs %d\n"",; 912 paircl->IsLoaded() ? ""dictionary"" : ""interpreter information for"", nam.c_str(),; 913 cl->GetName(), (int)paircl->GetClassSize(), (int)fValDiff);; 914 else {; 915 gROOT->GetListOfClasses()->Remove(paircl);; 916 TClass *newpaircl = TClass::GetClass(nam.c_str(), true, false, fValOffset, fValDiff);; 917 if (!newpaircl || newpaircl == paircl || newpaircl->GetClassSize() != fValDiff); 918 Fatal(""Initialize",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:31035,Performance,load,loaded,31035,"ey->fProperties&kNeedDelete))) {; 930 fProperties |= kNeedDelete;; 931 }; 932 if ( 0 == fValDiff ) {; 933 fValDiff = fKey->fSize + fVal->fSize;; 934 fValDiff += (slong - fKey->fSize%slong)%slong;; 935 fValDiff += (slong - fValDiff%slong)%slong;; 936 }; 937 if ( 0 == fValOffset ) {; 938 fValOffset = fKey->fSize;; 939 fValOffset += (slong - fKey->fSize%slong)%slong;; 940 }; 941 break;; 942 case ROOT::kSTLbitset:; 943 inside[1] = ""bool"";; 944 // Intentional fall through; 945 default:; 946 newfValue = R__CreateValue(inside[1], silent);; 947 ; 948 fVal = new Value(*newfValue);; 949 if ( 0 == fValDiff ) {; 950 fValDiff = fVal->fSize;; 951 fValDiff += (slong - fValDiff%slong)%slong;; 952 }; 953 if (num > 2 && !inside[2].empty()) {; 954 if (! TClassEdit::IsDefAlloc(inside[2].c_str(),inside[0].c_str())) {; 955 fProperties |= kCustomAlloc;; 956 }; 957 }; 958 break;; 959 }; 960 if (!(fProperties & kIsEmulated) && newfValue->fType && !newfValue->fType->IsSyntheticPair()) {; 961 if (!newfValue->fType->IsLoaded() && !newfValue->fType->HasInterpreterInfo()); 962 Error(""TGenCollectionProxy::InitializeEx"",; 963 ""The TClass for %s used as the value type of the compiled collection proxy %s is not loaded."",; 964 newfValue->fType->GetName(), cl->GetName());; 965 }; 966 ; 967 fPointers = fPointers || (0 != (fVal->fCase&kIsPointer));; 968 if (fPointers || (0 != (fVal->fProperties&kNeedDelete))) {; 969 fProperties |= kNeedDelete;; 970 }; 971 fClass = cl;; 972 //fValue must be set last since we use it to indicate that we are initialized; 973 fValue = newfValue;; 974 return this;; 975 }; 976 Fatal(""TGenCollectionProxy"",""Components of %s not analysed!"",cl->GetName());; 977 }; 978 Fatal(""TGenCollectionProxy"",""Collection class %s not found!"",fTypeinfo.name());; 979 return 0;; 980}; 981 ; 982////////////////////////////////////////////////////////////////////////////////; 983/// Return a pointer to the TClass representing the container; 984 ; 985TClass *TGenCollectionProxy::GetCollectionClass() ",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:32154,Performance,load,load,32154," cl;; 972 //fValue must be set last since we use it to indicate that we are initialized; 973 fValue = newfValue;; 974 return this;; 975 }; 976 Fatal(""TGenCollectionProxy"",""Components of %s not analysed!"",cl->GetName());; 977 }; 978 Fatal(""TGenCollectionProxy"",""Collection class %s not found!"",fTypeinfo.name());; 979 return 0;; 980}; 981 ; 982////////////////////////////////////////////////////////////////////////////////; 983/// Return a pointer to the TClass representing the container; 984 ; 985TClass *TGenCollectionProxy::GetCollectionClass() const; 986{; 987 return fClass ? fClass : Initialize(kFALSE)->fClass;; 988}; 989 ; 990////////////////////////////////////////////////////////////////////////////////; 991/// Return the type of collection see TClassEdit::ESTLType; 992 ; 993Int_t TGenCollectionProxy::GetCollectionType() const; 994{; 995 if (!fValue.load(std::memory_order_relaxed)) {; 996 Initialize(kFALSE);; 997 }; 998 return fSTL_type;; 999}; 1000 ; 1001////////////////////////////////////////////////////////////////////////////////; 1002/// Return the offset between two consecutive value_types (memory layout).; 1003 ; 1004ULong_t TGenCollectionProxy::GetIncrement() const {; 1005 if (!fValue.load(std::memory_order_relaxed)) {; 1006 Initialize(kFALSE);; 1007 }; 1008 return fValDiff;; 1009}; 1010 ; 1011////////////////////////////////////////////////////////////////////////////////; 1012/// Return the sizeof the collection object.; 1013 ; 1014UInt_t TGenCollectionProxy::Sizeof() const; 1015{; 1016 return fClass->Size();; 1017}; 1018 ; 1019////////////////////////////////////////////////////////////////////////////////; 1020/// Return true if the content is of type 'pointer to'; 1021 ; 1022Bool_t TGenCollectionProxy::HasPointers() const; 1023{; 1024 // Initialize proxy in case it hasn't been initialized yet; 1025 if( !fValue.load(std::memory_order_relaxed) ); 1026 Initialize(kFALSE);; 1027 ; 1028 // The content of a map and multimap is always a 'pair' and hence; ",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:32505,Performance,load,load,32505," ; 982////////////////////////////////////////////////////////////////////////////////; 983/// Return a pointer to the TClass representing the container; 984 ; 985TClass *TGenCollectionProxy::GetCollectionClass() const; 986{; 987 return fClass ? fClass : Initialize(kFALSE)->fClass;; 988}; 989 ; 990////////////////////////////////////////////////////////////////////////////////; 991/// Return the type of collection see TClassEdit::ESTLType; 992 ; 993Int_t TGenCollectionProxy::GetCollectionType() const; 994{; 995 if (!fValue.load(std::memory_order_relaxed)) {; 996 Initialize(kFALSE);; 997 }; 998 return fSTL_type;; 999}; 1000 ; 1001////////////////////////////////////////////////////////////////////////////////; 1002/// Return the offset between two consecutive value_types (memory layout).; 1003 ; 1004ULong_t TGenCollectionProxy::GetIncrement() const {; 1005 if (!fValue.load(std::memory_order_relaxed)) {; 1006 Initialize(kFALSE);; 1007 }; 1008 return fValDiff;; 1009}; 1010 ; 1011////////////////////////////////////////////////////////////////////////////////; 1012/// Return the sizeof the collection object.; 1013 ; 1014UInt_t TGenCollectionProxy::Sizeof() const; 1015{; 1016 return fClass->Size();; 1017}; 1018 ; 1019////////////////////////////////////////////////////////////////////////////////; 1020/// Return true if the content is of type 'pointer to'; 1021 ; 1022Bool_t TGenCollectionProxy::HasPointers() const; 1023{; 1024 // Initialize proxy in case it hasn't been initialized yet; 1025 if( !fValue.load(std::memory_order_relaxed) ); 1026 Initialize(kFALSE);; 1027 ; 1028 // The content of a map and multimap is always a 'pair' and hence; 1029 // fPointers means ""Flag to indicate if containee has pointers (key or value)""; 1030 // so we need to ignore its value for map and multimap;; 1031 return fPointers && !(fSTL_type == ROOT::kSTLmap || fSTL_type == ROOT::kSTLmultimap ||; 1032 fSTL_type == ROOT::kSTLunorderedmap || fSTL_type == ROOT::kSTLunorderedmultimap);; 1033}; 103",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:33148,Performance,load,load,33148,"GetIncrement() const {; 1005 if (!fValue.load(std::memory_order_relaxed)) {; 1006 Initialize(kFALSE);; 1007 }; 1008 return fValDiff;; 1009}; 1010 ; 1011////////////////////////////////////////////////////////////////////////////////; 1012/// Return the sizeof the collection object.; 1013 ; 1014UInt_t TGenCollectionProxy::Sizeof() const; 1015{; 1016 return fClass->Size();; 1017}; 1018 ; 1019////////////////////////////////////////////////////////////////////////////////; 1020/// Return true if the content is of type 'pointer to'; 1021 ; 1022Bool_t TGenCollectionProxy::HasPointers() const; 1023{; 1024 // Initialize proxy in case it hasn't been initialized yet; 1025 if( !fValue.load(std::memory_order_relaxed) ); 1026 Initialize(kFALSE);; 1027 ; 1028 // The content of a map and multimap is always a 'pair' and hence; 1029 // fPointers means ""Flag to indicate if containee has pointers (key or value)""; 1030 // so we need to ignore its value for map and multimap;; 1031 return fPointers && !(fSTL_type == ROOT::kSTLmap || fSTL_type == ROOT::kSTLmultimap ||; 1032 fSTL_type == ROOT::kSTLunorderedmap || fSTL_type == ROOT::kSTLunorderedmultimap);; 1033}; 1034 ; 1035////////////////////////////////////////////////////////////////////////////////; 1036/// Return a pointer to the TClass representing the content.; 1037 ; 1038TClass *TGenCollectionProxy::GetValueClass() const; 1039{; 1040 auto value = fValue.load(std::memory_order_relaxed);; 1041 if (!value) {; 1042 Initialize(kFALSE);; 1043 value = fValue.load(std::memory_order_relaxed);; 1044 }; 1045 return value ? (*value).fType.GetClass() : 0;; 1046}; 1047 ; 1048////////////////////////////////////////////////////////////////////////////////; 1049/// If the content is a simple numerical value, return its type (see TDataType); 1050 ; 1051EDataType TGenCollectionProxy::GetType() const; 1052{; 1053 auto value = fValue.load(std::memory_order_relaxed);; 1054 if (!value) {; 1055 Initialize(kFALSE);; 1056 value = fValue.load(std::memory_",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:33877,Performance,load,load,33877,"//////////; 1020/// Return true if the content is of type 'pointer to'; 1021 ; 1022Bool_t TGenCollectionProxy::HasPointers() const; 1023{; 1024 // Initialize proxy in case it hasn't been initialized yet; 1025 if( !fValue.load(std::memory_order_relaxed) ); 1026 Initialize(kFALSE);; 1027 ; 1028 // The content of a map and multimap is always a 'pair' and hence; 1029 // fPointers means ""Flag to indicate if containee has pointers (key or value)""; 1030 // so we need to ignore its value for map and multimap;; 1031 return fPointers && !(fSTL_type == ROOT::kSTLmap || fSTL_type == ROOT::kSTLmultimap ||; 1032 fSTL_type == ROOT::kSTLunorderedmap || fSTL_type == ROOT::kSTLunorderedmultimap);; 1033}; 1034 ; 1035////////////////////////////////////////////////////////////////////////////////; 1036/// Return a pointer to the TClass representing the content.; 1037 ; 1038TClass *TGenCollectionProxy::GetValueClass() const; 1039{; 1040 auto value = fValue.load(std::memory_order_relaxed);; 1041 if (!value) {; 1042 Initialize(kFALSE);; 1043 value = fValue.load(std::memory_order_relaxed);; 1044 }; 1045 return value ? (*value).fType.GetClass() : 0;; 1046}; 1047 ; 1048////////////////////////////////////////////////////////////////////////////////; 1049/// If the content is a simple numerical value, return its type (see TDataType); 1050 ; 1051EDataType TGenCollectionProxy::GetType() const; 1052{; 1053 auto value = fValue.load(std::memory_order_relaxed);; 1054 if (!value) {; 1055 Initialize(kFALSE);; 1056 value = fValue.load(std::memory_order_relaxed);; 1057 }; 1058 return value ? (*value).fKind : kNoType_t;; 1059}; 1060 ; 1061////////////////////////////////////////////////////////////////////////////////; 1062/// Return the address of the value at index 'idx'; 1063 ; 1064void* TGenCollectionProxy::At(UInt_t idx); 1065{; 1066 if ( fEnv && fEnv->fObject ) {; 1067 switch (fSTL_type) {; 1068 case ROOT::kSTLvector:; 1069 if ((*fValue).fKind == kBool_t) {; 1070 auto vec = (std::vector<bool> *)(f",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:33977,Performance,load,load,33977,"ol_t TGenCollectionProxy::HasPointers() const; 1023{; 1024 // Initialize proxy in case it hasn't been initialized yet; 1025 if( !fValue.load(std::memory_order_relaxed) ); 1026 Initialize(kFALSE);; 1027 ; 1028 // The content of a map and multimap is always a 'pair' and hence; 1029 // fPointers means ""Flag to indicate if containee has pointers (key or value)""; 1030 // so we need to ignore its value for map and multimap;; 1031 return fPointers && !(fSTL_type == ROOT::kSTLmap || fSTL_type == ROOT::kSTLmultimap ||; 1032 fSTL_type == ROOT::kSTLunorderedmap || fSTL_type == ROOT::kSTLunorderedmultimap);; 1033}; 1034 ; 1035////////////////////////////////////////////////////////////////////////////////; 1036/// Return a pointer to the TClass representing the content.; 1037 ; 1038TClass *TGenCollectionProxy::GetValueClass() const; 1039{; 1040 auto value = fValue.load(std::memory_order_relaxed);; 1041 if (!value) {; 1042 Initialize(kFALSE);; 1043 value = fValue.load(std::memory_order_relaxed);; 1044 }; 1045 return value ? (*value).fType.GetClass() : 0;; 1046}; 1047 ; 1048////////////////////////////////////////////////////////////////////////////////; 1049/// If the content is a simple numerical value, return its type (see TDataType); 1050 ; 1051EDataType TGenCollectionProxy::GetType() const; 1052{; 1053 auto value = fValue.load(std::memory_order_relaxed);; 1054 if (!value) {; 1055 Initialize(kFALSE);; 1056 value = fValue.load(std::memory_order_relaxed);; 1057 }; 1058 return value ? (*value).fKind : kNoType_t;; 1059}; 1060 ; 1061////////////////////////////////////////////////////////////////////////////////; 1062/// Return the address of the value at index 'idx'; 1063 ; 1064void* TGenCollectionProxy::At(UInt_t idx); 1065{; 1066 if ( fEnv && fEnv->fObject ) {; 1067 switch (fSTL_type) {; 1068 case ROOT::kSTLvector:; 1069 if ((*fValue).fKind == kBool_t) {; 1070 auto vec = (std::vector<bool> *)(fEnv->fObject);; 1071 fEnv->fLastValueVecBool = (*vec)[idx];; 1072 fEnv->fIdx = idx;; 1",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:34347,Performance,load,load,34347,"nore its value for map and multimap;; 1031 return fPointers && !(fSTL_type == ROOT::kSTLmap || fSTL_type == ROOT::kSTLmultimap ||; 1032 fSTL_type == ROOT::kSTLunorderedmap || fSTL_type == ROOT::kSTLunorderedmultimap);; 1033}; 1034 ; 1035////////////////////////////////////////////////////////////////////////////////; 1036/// Return a pointer to the TClass representing the content.; 1037 ; 1038TClass *TGenCollectionProxy::GetValueClass() const; 1039{; 1040 auto value = fValue.load(std::memory_order_relaxed);; 1041 if (!value) {; 1042 Initialize(kFALSE);; 1043 value = fValue.load(std::memory_order_relaxed);; 1044 }; 1045 return value ? (*value).fType.GetClass() : 0;; 1046}; 1047 ; 1048////////////////////////////////////////////////////////////////////////////////; 1049/// If the content is a simple numerical value, return its type (see TDataType); 1050 ; 1051EDataType TGenCollectionProxy::GetType() const; 1052{; 1053 auto value = fValue.load(std::memory_order_relaxed);; 1054 if (!value) {; 1055 Initialize(kFALSE);; 1056 value = fValue.load(std::memory_order_relaxed);; 1057 }; 1058 return value ? (*value).fKind : kNoType_t;; 1059}; 1060 ; 1061////////////////////////////////////////////////////////////////////////////////; 1062/// Return the address of the value at index 'idx'; 1063 ; 1064void* TGenCollectionProxy::At(UInt_t idx); 1065{; 1066 if ( fEnv && fEnv->fObject ) {; 1067 switch (fSTL_type) {; 1068 case ROOT::kSTLvector:; 1069 if ((*fValue).fKind == kBool_t) {; 1070 auto vec = (std::vector<bool> *)(fEnv->fObject);; 1071 fEnv->fLastValueVecBool = (*vec)[idx];; 1072 fEnv->fIdx = idx;; 1073 return &(fEnv->fLastValueVecBool);; 1074 }; 1075 // intentional fall through; 1076 case ROOT::kROOTRVec:; 1077 fEnv->fIdx = idx;; 1078 switch( idx ) {; 1079 case 0:; 1080 return fEnv->fStart = fFirst.invoke(fEnv);; 1081 default:; 1082 if (! fEnv->fStart ) fEnv->fStart = fFirst.invoke(fEnv);; 1083 return ((char*)fEnv->fStart) + fValDiff*idx;; 1084 }; 1085 case ROOT::kSTLbitset: ",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:34447,Performance,load,load,34447,"STLmap || fSTL_type == ROOT::kSTLmultimap ||; 1032 fSTL_type == ROOT::kSTLunorderedmap || fSTL_type == ROOT::kSTLunorderedmultimap);; 1033}; 1034 ; 1035////////////////////////////////////////////////////////////////////////////////; 1036/// Return a pointer to the TClass representing the content.; 1037 ; 1038TClass *TGenCollectionProxy::GetValueClass() const; 1039{; 1040 auto value = fValue.load(std::memory_order_relaxed);; 1041 if (!value) {; 1042 Initialize(kFALSE);; 1043 value = fValue.load(std::memory_order_relaxed);; 1044 }; 1045 return value ? (*value).fType.GetClass() : 0;; 1046}; 1047 ; 1048////////////////////////////////////////////////////////////////////////////////; 1049/// If the content is a simple numerical value, return its type (see TDataType); 1050 ; 1051EDataType TGenCollectionProxy::GetType() const; 1052{; 1053 auto value = fValue.load(std::memory_order_relaxed);; 1054 if (!value) {; 1055 Initialize(kFALSE);; 1056 value = fValue.load(std::memory_order_relaxed);; 1057 }; 1058 return value ? (*value).fKind : kNoType_t;; 1059}; 1060 ; 1061////////////////////////////////////////////////////////////////////////////////; 1062/// Return the address of the value at index 'idx'; 1063 ; 1064void* TGenCollectionProxy::At(UInt_t idx); 1065{; 1066 if ( fEnv && fEnv->fObject ) {; 1067 switch (fSTL_type) {; 1068 case ROOT::kSTLvector:; 1069 if ((*fValue).fKind == kBool_t) {; 1070 auto vec = (std::vector<bool> *)(fEnv->fObject);; 1071 fEnv->fLastValueVecBool = (*vec)[idx];; 1072 fEnv->fIdx = idx;; 1073 return &(fEnv->fLastValueVecBool);; 1074 }; 1075 // intentional fall through; 1076 case ROOT::kROOTRVec:; 1077 fEnv->fIdx = idx;; 1078 switch( idx ) {; 1079 case 0:; 1080 return fEnv->fStart = fFirst.invoke(fEnv);; 1081 default:; 1082 if (! fEnv->fStart ) fEnv->fStart = fFirst.invoke(fEnv);; 1083 return ((char*)fEnv->fStart) + fValDiff*idx;; 1084 }; 1085 case ROOT::kSTLbitset: {; 1086 switch (idx) {; 1087 case 0:; 1088 fEnv->fStart = fFirst.invoke(fEnv);; 1089 f",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:41801,Performance,load,load,41801,"TGenCollectionProxy::Insert(const void *data, void *container, size_t size); 1270{; 1271 fFeed((void*)data,container,size);; 1272}; 1273 ; 1274////////////////////////////////////////////////////////////////////////////////; 1275/// Commit the change.; 1276 ; 1277void TGenCollectionProxy::Commit(void* from); 1278{; 1279 if (fProperties & kIsAssociative) {; 1280// case ROOT::kSTLmap:; 1281// case ROOT::kSTLmultimap:; 1282// case ROOT::kSTLset:; 1283// case ROOT::kSTLmultiset:; 1284 if ( from ) {; 1285 TStaging *s = (TStaging*) from;; 1286 if ( s->GetTarget() ) {; 1287 fFeed(s->GetContent(),s->GetTarget(),s->GetSize());; 1288 }; 1289 fDestruct(s->GetContent(),s->GetSize());; 1290 s->SetTarget(0);; 1291 fStaged.push_back(s);; 1292 }; 1293 }; 1294}; 1295 ; 1296////////////////////////////////////////////////////////////////////////////////; 1297/// Add an object.; 1298 ; 1299void TGenCollectionProxy::PushProxy(void *objstart); 1300{; 1301 if ( !fValue.load(std::memory_order_relaxed) ) Initialize(kFALSE);; 1302 if ( !fProxyList.empty() ) {; 1303 EnvironBase_t* back = fProxyList.back();; 1304 if ( back->fObject == objstart ) {; 1305 ++back->fRefCount;; 1306 fProxyList.push_back(back);; 1307 fEnv = back;; 1308 return;; 1309 }; 1310 }; 1311 EnvironBase_t* e = 0;; 1312 if ( fProxyKept.empty() ) {; 1313 e = (EnvironBase_t*)fCreateEnv.invoke();; 1314 e->fTemp = 0;; 1315 e->fUseTemp = kFALSE;; 1316 }; 1317 else {; 1318 e = fProxyKept.back();; 1319 fProxyKept.pop_back();; 1320 }; 1321 e->fSize = 0;; 1322 e->fRefCount = 1;; 1323 e->fObject = objstart;; 1324 e->fStart = 0;; 1325 e->fIdx = 0;; 1326 // ::memset(e->buff,0,sizeof(e->buff));; 1327 fProxyList.push_back(e);; 1328 fEnv = e;; 1329}; 1330 ; 1331////////////////////////////////////////////////////////////////////////////////; 1332/// Remove the last object.; 1333 ; 1334void TGenCollectionProxy::PopProxy(); 1335{; 1336 if ( !fProxyList.empty() ) {; 1337 EnvironBase_t* e = fProxyList.back();; 1338 if ( --e->fRefCount <= 0 ) {; ",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:52086,Performance,load,load,52086,"g to do; 1595 ; 1596void TGenCollectionProxy__StagingDeleteTwoIterators(void *, void *); 1597{; 1598}; 1599 ; 1600 ; 1601////////////////////////////////////////////////////////////////////////////////; 1602/// See typedef void (*CreateIterators_t)(void *collection, void *&begin_arena, void *&end_arena);; 1603/// begin_arena and end_arena should contain the location of memory arena of size fgIteratorSize.; 1604/// If the collection iterator are of that size or less, the iterators will be constructed in place in those location (new with placement); 1605/// Otherwise the iterators will be allocated via a regular new and their address returned by modifying the value of begin_arena and end_arena.; 1606 ; 1607TVirtualCollectionProxy::CreateIterators_t TGenCollectionProxy::GetFunctionCreateIterators(Bool_t read); 1608{; 1609 if (read) {; 1610 if ( !fValue.load(std::memory_order_relaxed) ) InitializeEx(kFALSE);; 1611 if ( (fProperties & kIsAssociative) && read); 1612 return TGenCollectionProxy__StagingCreateIterators;; 1613 }; 1614 ; 1615 if ( fFunctionCreateIterators ) return fFunctionCreateIterators;; 1616 ; 1617 if ( !fValue.load(std::memory_order_relaxed) ) InitializeEx(kFALSE);; 1618 ; 1619// fprintf(stderr,""GetFunctinCreateIterator for %s will give: "",fClass.GetClassName());; 1620// if (fSTL_type==ROOT::kSTLvector || (fProperties & kIsEmulated)); 1621// fprintf(stderr,""vector/emulated iterator\n"");; 1622// else if ( (fProperties & kIsAssociative) && read); 1623// fprintf(stderr,""an associative read iterator\n"");; 1624// else; 1625// fprintf(stderr,""a generic iterator\n"");; 1626 ; 1627 // TODO could we do better than SlowCreateIterators for RVec?; 1628 if (fSTL_type==ROOT::kSTLvector || (fProperties & kIsEmulated)); 1629 return fFunctionCreateIterators = TGenCollectionProxy__VectorCreateIterators;; 1630 else if ( (fProperties & kIsAssociative) && read); 1631 return TGenCollectionProxy__StagingCreateIterators;; 1632 else; 1633 return fFunctionCreateIterators = TGenColle",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:52363,Performance,load,load,52363,"// See typedef void (*CreateIterators_t)(void *collection, void *&begin_arena, void *&end_arena);; 1603/// begin_arena and end_arena should contain the location of memory arena of size fgIteratorSize.; 1604/// If the collection iterator are of that size or less, the iterators will be constructed in place in those location (new with placement); 1605/// Otherwise the iterators will be allocated via a regular new and their address returned by modifying the value of begin_arena and end_arena.; 1606 ; 1607TVirtualCollectionProxy::CreateIterators_t TGenCollectionProxy::GetFunctionCreateIterators(Bool_t read); 1608{; 1609 if (read) {; 1610 if ( !fValue.load(std::memory_order_relaxed) ) InitializeEx(kFALSE);; 1611 if ( (fProperties & kIsAssociative) && read); 1612 return TGenCollectionProxy__StagingCreateIterators;; 1613 }; 1614 ; 1615 if ( fFunctionCreateIterators ) return fFunctionCreateIterators;; 1616 ; 1617 if ( !fValue.load(std::memory_order_relaxed) ) InitializeEx(kFALSE);; 1618 ; 1619// fprintf(stderr,""GetFunctinCreateIterator for %s will give: "",fClass.GetClassName());; 1620// if (fSTL_type==ROOT::kSTLvector || (fProperties & kIsEmulated)); 1621// fprintf(stderr,""vector/emulated iterator\n"");; 1622// else if ( (fProperties & kIsAssociative) && read); 1623// fprintf(stderr,""an associative read iterator\n"");; 1624// else; 1625// fprintf(stderr,""a generic iterator\n"");; 1626 ; 1627 // TODO could we do better than SlowCreateIterators for RVec?; 1628 if (fSTL_type==ROOT::kSTLvector || (fProperties & kIsEmulated)); 1629 return fFunctionCreateIterators = TGenCollectionProxy__VectorCreateIterators;; 1630 else if ( (fProperties & kIsAssociative) && read); 1631 return TGenCollectionProxy__StagingCreateIterators;; 1632 else; 1633 return fFunctionCreateIterators = TGenCollectionProxy__SlowCreateIterators;; 1634}; 1635 ; 1636////////////////////////////////////////////////////////////////////////////////; 1637/// See typedef void (*CopyIterator_t)(void *&dest, const void *source",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:53991,Performance,load,load,53991,"ollectionProxy__StagingCreateIterators;; 1632 else; 1633 return fFunctionCreateIterators = TGenCollectionProxy__SlowCreateIterators;; 1634}; 1635 ; 1636////////////////////////////////////////////////////////////////////////////////; 1637/// See typedef void (*CopyIterator_t)(void *&dest, const void *source);; 1638/// Copy the iterator source, into dest. dest should contain should contain the location of memory arena of size fgIteratorSize.; 1639/// If the collection iterator are of that size or less, the iterator will be constructed in place in this location (new with placement); 1640/// Otherwise the iterator will be allocated via a regular new and its address returned by modifying the value of dest.; 1641 ; 1642TVirtualCollectionProxy::CopyIterator_t TGenCollectionProxy::GetFunctionCopyIterator(Bool_t read); 1643{; 1644 if (read) {; 1645 if ( !fValue.load(std::memory_order_relaxed) ) InitializeEx(kFALSE);; 1646 if ( (fProperties & kIsAssociative) && read); 1647 return TGenCollectionProxy__StagingCopyIterator;; 1648 }; 1649 ; 1650 if ( fFunctionCopyIterator ) return fFunctionCopyIterator;; 1651 ; 1652 if ( !fValue.load(std::memory_order_relaxed) ) InitializeEx(kFALSE);; 1653 ; 1654 // TODO can we do better than the default for RVec?; 1655 if (fSTL_type==ROOT::kSTLvector || (fProperties & kIsEmulated)); 1656 return fFunctionCopyIterator = TGenCollectionProxy__VectorCopyIterator;; 1657 else if ( (fProperties & kIsAssociative) && read); 1658 return TGenCollectionProxy__StagingCopyIterator;; 1659 else; 1660 return fFunctionCopyIterator = TGenCollectionProxy__SlowCopyIterator;; 1661}; 1662 ; 1663////////////////////////////////////////////////////////////////////////////////; 1664/// See typedef void* (*Next_t)(void *iter, void *end);; 1665/// iter and end should be pointer to respectively an iterator to be incremented and the result of colleciton.end(); 1666/// 'Next' will increment the iterator 'iter' and return 0 if the iterator reached the end.; 1667/// If the end ",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:54259,Performance,load,load,54259,", the iterator will be constructed in place in this location (new with placement); 1640/// Otherwise the iterator will be allocated via a regular new and its address returned by modifying the value of dest.; 1641 ; 1642TVirtualCollectionProxy::CopyIterator_t TGenCollectionProxy::GetFunctionCopyIterator(Bool_t read); 1643{; 1644 if (read) {; 1645 if ( !fValue.load(std::memory_order_relaxed) ) InitializeEx(kFALSE);; 1646 if ( (fProperties & kIsAssociative) && read); 1647 return TGenCollectionProxy__StagingCopyIterator;; 1648 }; 1649 ; 1650 if ( fFunctionCopyIterator ) return fFunctionCopyIterator;; 1651 ; 1652 if ( !fValue.load(std::memory_order_relaxed) ) InitializeEx(kFALSE);; 1653 ; 1654 // TODO can we do better than the default for RVec?; 1655 if (fSTL_type==ROOT::kSTLvector || (fProperties & kIsEmulated)); 1656 return fFunctionCopyIterator = TGenCollectionProxy__VectorCopyIterator;; 1657 else if ( (fProperties & kIsAssociative) && read); 1658 return TGenCollectionProxy__StagingCopyIterator;; 1659 else; 1660 return fFunctionCopyIterator = TGenCollectionProxy__SlowCopyIterator;; 1661}; 1662 ; 1663////////////////////////////////////////////////////////////////////////////////; 1664/// See typedef void* (*Next_t)(void *iter, void *end);; 1665/// iter and end should be pointer to respectively an iterator to be incremented and the result of colleciton.end(); 1666/// 'Next' will increment the iterator 'iter' and return 0 if the iterator reached the end.; 1667/// If the end is not reached, 'Next' will return the address of the content unless the collection contains pointers in; 1668/// which case 'Next' will return the value of the pointer.; 1669 ; 1670TVirtualCollectionProxy::Next_t TGenCollectionProxy::GetFunctionNext(Bool_t read); 1671{; 1672 if (read) {; 1673 if ( !fValue.load(std::memory_order_relaxed) ) InitializeEx(kFALSE);; 1674 if ( (fProperties & kIsAssociative) && read); 1675 return TGenCollectionProxy__StagingNext;; 1676 }; 1677 ; 1678 if ( fFunctionNextItera",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:55433,Performance,load,load,55433,"ssociative) && read); 1658 return TGenCollectionProxy__StagingCopyIterator;; 1659 else; 1660 return fFunctionCopyIterator = TGenCollectionProxy__SlowCopyIterator;; 1661}; 1662 ; 1663////////////////////////////////////////////////////////////////////////////////; 1664/// See typedef void* (*Next_t)(void *iter, void *end);; 1665/// iter and end should be pointer to respectively an iterator to be incremented and the result of colleciton.end(); 1666/// 'Next' will increment the iterator 'iter' and return 0 if the iterator reached the end.; 1667/// If the end is not reached, 'Next' will return the address of the content unless the collection contains pointers in; 1668/// which case 'Next' will return the value of the pointer.; 1669 ; 1670TVirtualCollectionProxy::Next_t TGenCollectionProxy::GetFunctionNext(Bool_t read); 1671{; 1672 if (read) {; 1673 if ( !fValue.load(std::memory_order_relaxed) ) InitializeEx(kFALSE);; 1674 if ( (fProperties & kIsAssociative) && read); 1675 return TGenCollectionProxy__StagingNext;; 1676 }; 1677 ; 1678 if ( fFunctionNextIterator ) return fFunctionNextIterator;; 1679 ; 1680 if ( !fValue.load(std::memory_order_relaxed) ) InitializeEx(kFALSE);; 1681 ; 1682 // TODO can we do better than the default for RVec?; 1683 if (fSTL_type==ROOT::kSTLvector || (fProperties & kIsEmulated)); 1684 return fFunctionNextIterator = TGenCollectionProxy__VectorNext;; 1685 else if ( (fProperties & kIsAssociative) && read); 1686 return TGenCollectionProxy__StagingNext;; 1687 else; 1688 return fFunctionNextIterator = TGenCollectionProxy__SlowNext;; 1689}; 1690 ; 1691////////////////////////////////////////////////////////////////////////////////; 1692/// See typedef void (*DeleteIterator_t)(void *iter);; 1693/// If the sizeof iterator is greater than fgIteratorArenaSize, call delete on the addresses,; 1694/// Otherwise just call the iterator's destructor.; 1695 ; 1696TVirtualCollectionProxy::DeleteIterator_t TGenCollectionProxy::GetFunctionDeleteIterator(Bool_t read)",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:55693,Performance,load,load,55693," if the iterator reached the end.; 1667/// If the end is not reached, 'Next' will return the address of the content unless the collection contains pointers in; 1668/// which case 'Next' will return the value of the pointer.; 1669 ; 1670TVirtualCollectionProxy::Next_t TGenCollectionProxy::GetFunctionNext(Bool_t read); 1671{; 1672 if (read) {; 1673 if ( !fValue.load(std::memory_order_relaxed) ) InitializeEx(kFALSE);; 1674 if ( (fProperties & kIsAssociative) && read); 1675 return TGenCollectionProxy__StagingNext;; 1676 }; 1677 ; 1678 if ( fFunctionNextIterator ) return fFunctionNextIterator;; 1679 ; 1680 if ( !fValue.load(std::memory_order_relaxed) ) InitializeEx(kFALSE);; 1681 ; 1682 // TODO can we do better than the default for RVec?; 1683 if (fSTL_type==ROOT::kSTLvector || (fProperties & kIsEmulated)); 1684 return fFunctionNextIterator = TGenCollectionProxy__VectorNext;; 1685 else if ( (fProperties & kIsAssociative) && read); 1686 return TGenCollectionProxy__StagingNext;; 1687 else; 1688 return fFunctionNextIterator = TGenCollectionProxy__SlowNext;; 1689}; 1690 ; 1691////////////////////////////////////////////////////////////////////////////////; 1692/// See typedef void (*DeleteIterator_t)(void *iter);; 1693/// If the sizeof iterator is greater than fgIteratorArenaSize, call delete on the addresses,; 1694/// Otherwise just call the iterator's destructor.; 1695 ; 1696TVirtualCollectionProxy::DeleteIterator_t TGenCollectionProxy::GetFunctionDeleteIterator(Bool_t read); 1697{; 1698 if (read) {; 1699 if ( !fValue.load(std::memory_order_relaxed) ) InitializeEx(kFALSE);; 1700 if ( (fProperties & kIsAssociative) && read); 1701 return TGenCollectionProxy__StagingDeleteSingleIterators;; 1702 }; 1703 ; 1704 if ( fFunctionDeleteIterator ) return fFunctionDeleteIterator;; 1705 ; 1706 if ( !fValue.load(std::memory_order_relaxed) ) InitializeEx(kFALSE);; 1707 ; 1708 // TODO can we do better than the default for RVec?; 1709 if (fSTL_type==ROOT::kSTLvector || (fProperties & kIsEm",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:56608,Performance,load,load,56608,"; 1681 ; 1682 // TODO can we do better than the default for RVec?; 1683 if (fSTL_type==ROOT::kSTLvector || (fProperties & kIsEmulated)); 1684 return fFunctionNextIterator = TGenCollectionProxy__VectorNext;; 1685 else if ( (fProperties & kIsAssociative) && read); 1686 return TGenCollectionProxy__StagingNext;; 1687 else; 1688 return fFunctionNextIterator = TGenCollectionProxy__SlowNext;; 1689}; 1690 ; 1691////////////////////////////////////////////////////////////////////////////////; 1692/// See typedef void (*DeleteIterator_t)(void *iter);; 1693/// If the sizeof iterator is greater than fgIteratorArenaSize, call delete on the addresses,; 1694/// Otherwise just call the iterator's destructor.; 1695 ; 1696TVirtualCollectionProxy::DeleteIterator_t TGenCollectionProxy::GetFunctionDeleteIterator(Bool_t read); 1697{; 1698 if (read) {; 1699 if ( !fValue.load(std::memory_order_relaxed) ) InitializeEx(kFALSE);; 1700 if ( (fProperties & kIsAssociative) && read); 1701 return TGenCollectionProxy__StagingDeleteSingleIterators;; 1702 }; 1703 ; 1704 if ( fFunctionDeleteIterator ) return fFunctionDeleteIterator;; 1705 ; 1706 if ( !fValue.load(std::memory_order_relaxed) ) InitializeEx(kFALSE);; 1707 ; 1708 // TODO can we do better than the default for RVec?; 1709 if (fSTL_type==ROOT::kSTLvector || (fProperties & kIsEmulated)); 1710 return fFunctionDeleteIterator = TGenCollectionProxy__VectorDeleteSingleIterators;; 1711 else if ( (fProperties & kIsAssociative) && read); 1712 return TGenCollectionProxy__StagingDeleteSingleIterators;; 1713 else; 1714 return fFunctionDeleteIterator = TGenCollectionProxy__SlowDeleteSingleIterators;; 1715}; 1716 ; 1717////////////////////////////////////////////////////////////////////////////////; 1718/// See typedef void (*DeleteTwoIterators_t)(void *begin, void *end);; 1719/// If the sizeof iterator is greater than fgIteratorArenaSize, call delete on the addresses,; 1720/// Otherwise just call the iterator's destructor.; 1721 ; 1722TVirtualCollectionPr",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:56889,Performance,load,load,56889,"/ If the sizeof iterator is greater than fgIteratorArenaSize, call delete on the addresses,; 1694/// Otherwise just call the iterator's destructor.; 1695 ; 1696TVirtualCollectionProxy::DeleteIterator_t TGenCollectionProxy::GetFunctionDeleteIterator(Bool_t read); 1697{; 1698 if (read) {; 1699 if ( !fValue.load(std::memory_order_relaxed) ) InitializeEx(kFALSE);; 1700 if ( (fProperties & kIsAssociative) && read); 1701 return TGenCollectionProxy__StagingDeleteSingleIterators;; 1702 }; 1703 ; 1704 if ( fFunctionDeleteIterator ) return fFunctionDeleteIterator;; 1705 ; 1706 if ( !fValue.load(std::memory_order_relaxed) ) InitializeEx(kFALSE);; 1707 ; 1708 // TODO can we do better than the default for RVec?; 1709 if (fSTL_type==ROOT::kSTLvector || (fProperties & kIsEmulated)); 1710 return fFunctionDeleteIterator = TGenCollectionProxy__VectorDeleteSingleIterators;; 1711 else if ( (fProperties & kIsAssociative) && read); 1712 return TGenCollectionProxy__StagingDeleteSingleIterators;; 1713 else; 1714 return fFunctionDeleteIterator = TGenCollectionProxy__SlowDeleteSingleIterators;; 1715}; 1716 ; 1717////////////////////////////////////////////////////////////////////////////////; 1718/// See typedef void (*DeleteTwoIterators_t)(void *begin, void *end);; 1719/// If the sizeof iterator is greater than fgIteratorArenaSize, call delete on the addresses,; 1720/// Otherwise just call the iterator's destructor.; 1721 ; 1722TVirtualCollectionProxy::DeleteTwoIterators_t TGenCollectionProxy::GetFunctionDeleteTwoIterators(Bool_t read); 1723{; 1724 if (read) {; 1725 if ( !fValue.load(std::memory_order_relaxed) ) InitializeEx(kFALSE);; 1726 if ( (fProperties & kIsAssociative) && read); 1727 return TGenCollectionProxy__StagingDeleteTwoIterators;; 1728 }; 1729 ; 1730 if ( fFunctionDeleteTwoIterators ) return fFunctionDeleteTwoIterators;; 1731 ; 1732 if ( !fValue.load(std::memory_order_relaxed) ) InitializeEx(kFALSE);; 1733 ; 1734 // TODO could RVec use something faster than SlowCopyIterator?; 1",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:57883,Performance,load,load,57883,"ype==ROOT::kSTLvector || (fProperties & kIsEmulated)); 1710 return fFunctionDeleteIterator = TGenCollectionProxy__VectorDeleteSingleIterators;; 1711 else if ( (fProperties & kIsAssociative) && read); 1712 return TGenCollectionProxy__StagingDeleteSingleIterators;; 1713 else; 1714 return fFunctionDeleteIterator = TGenCollectionProxy__SlowDeleteSingleIterators;; 1715}; 1716 ; 1717////////////////////////////////////////////////////////////////////////////////; 1718/// See typedef void (*DeleteTwoIterators_t)(void *begin, void *end);; 1719/// If the sizeof iterator is greater than fgIteratorArenaSize, call delete on the addresses,; 1720/// Otherwise just call the iterator's destructor.; 1721 ; 1722TVirtualCollectionProxy::DeleteTwoIterators_t TGenCollectionProxy::GetFunctionDeleteTwoIterators(Bool_t read); 1723{; 1724 if (read) {; 1725 if ( !fValue.load(std::memory_order_relaxed) ) InitializeEx(kFALSE);; 1726 if ( (fProperties & kIsAssociative) && read); 1727 return TGenCollectionProxy__StagingDeleteTwoIterators;; 1728 }; 1729 ; 1730 if ( fFunctionDeleteTwoIterators ) return fFunctionDeleteTwoIterators;; 1731 ; 1732 if ( !fValue.load(std::memory_order_relaxed) ) InitializeEx(kFALSE);; 1733 ; 1734 // TODO could RVec use something faster than SlowCopyIterator?; 1735 if (fSTL_type==ROOT::kSTLvector || (fProperties & kIsEmulated)); 1736 return fFunctionDeleteTwoIterators = TGenCollectionProxy__VectorDeleteTwoIterators;; 1737 else if ( (fProperties & kIsAssociative) && read); 1738 return TGenCollectionProxy__StagingDeleteTwoIterators;; 1739 else; 1740 return fFunctionDeleteTwoIterators = TGenCollectionProxy__SlowDeleteTwoIterators;; 1741}; 1742 ; 1743////////////////////////////////////////////////////////////////////////////////; 1744/// Return the set of action necessary to stream in this collection member-wise coming from; 1745/// the old value class layout refered to by 'version'.; 1746 ; 1747TStreamerInfoActions::TActionSequence *TGenCollectionProxy::GetConversionReadMe",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:58169,Performance,load,load,58169,"oid *end);; 1719/// If the sizeof iterator is greater than fgIteratorArenaSize, call delete on the addresses,; 1720/// Otherwise just call the iterator's destructor.; 1721 ; 1722TVirtualCollectionProxy::DeleteTwoIterators_t TGenCollectionProxy::GetFunctionDeleteTwoIterators(Bool_t read); 1723{; 1724 if (read) {; 1725 if ( !fValue.load(std::memory_order_relaxed) ) InitializeEx(kFALSE);; 1726 if ( (fProperties & kIsAssociative) && read); 1727 return TGenCollectionProxy__StagingDeleteTwoIterators;; 1728 }; 1729 ; 1730 if ( fFunctionDeleteTwoIterators ) return fFunctionDeleteTwoIterators;; 1731 ; 1732 if ( !fValue.load(std::memory_order_relaxed) ) InitializeEx(kFALSE);; 1733 ; 1734 // TODO could RVec use something faster than SlowCopyIterator?; 1735 if (fSTL_type==ROOT::kSTLvector || (fProperties & kIsEmulated)); 1736 return fFunctionDeleteTwoIterators = TGenCollectionProxy__VectorDeleteTwoIterators;; 1737 else if ( (fProperties & kIsAssociative) && read); 1738 return TGenCollectionProxy__StagingDeleteTwoIterators;; 1739 else; 1740 return fFunctionDeleteTwoIterators = TGenCollectionProxy__SlowDeleteTwoIterators;; 1741}; 1742 ; 1743////////////////////////////////////////////////////////////////////////////////; 1744/// Return the set of action necessary to stream in this collection member-wise coming from; 1745/// the old value class layout refered to by 'version'.; 1746 ; 1747TStreamerInfoActions::TActionSequence *TGenCollectionProxy::GetConversionReadMemberWiseActions(TClass *oldClass, Int_t version); 1748{; 1749 if (oldClass == 0) {; 1750 return 0;; 1751 }; 1752 TObjArray* arr = 0;; 1753 TStreamerInfoActions::TActionSequence *result = 0;; 1754 if (fConversionReadMemberWise) {; 1755 std::map<std::string, TObjArray*>::iterator it;; 1756 ; 1757 it = fConversionReadMemberWise->find( oldClass->GetName() );; 1758 ; 1759 if( it != fConversionReadMemberWise->end() ) {; 1760 arr = it->second;; 1761 }; 1762 ; 1763 if (arr) {; 1764 result = (TStreamerInfoActions::TActionSequence",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:73580,Performance,load,load,73580,"s.cxx:5979; TClass::GetStreamerInfoTVirtualStreamerInfo * GetStreamerInfo(Int_t version=0, Bool_t isTransient=kFALSE) constreturns a pointer to the TVirtualStreamerInfo object for version If the object does not exist,...Definition TClass.cxx:4666; TClass::GetCollectionProxyTVirtualCollectionProxy * GetCollectionProxy() constReturn the proxy describing the collection (if any).Definition TClass.cxx:2964; TClass::GetClassSizeInt_t GetClassSize() constDefinition TClass.h:425; TClass::GetConversionStreamerInfoTVirtualStreamerInfo * GetConversionStreamerInfo(const char *onfile_classname, Int_t version) constReturn a Conversion StreamerInfo from the class 'classname' for version number 'version' to this clas...Definition TClass.cxx:7153; TClass::kInterpreted@ kInterpretedDefinition TClass.h:126; TClass::GetDeleteROOT::DelFunc_t GetDelete() constReturn the wrapper around delete ThiObject.Definition TClass.cxx:7530; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TCollection::kInitCapacity@ kInitCapacityDefinition TCollection.h:159; TCollection::GetSizevirtual Int_t GetSize() constReturn the capacity of the collection, i.e.Definition TCollection.h:184; TDataTypeBasic data type descriptor (datatype information is obtained from CINT).Definition TDataType.h:44; TDataType::GetTypeInt_t GetType() constDefinition TDataType.h:68; TDataType::SizeInt_t Size() constGet size of basic typedef'ed type.Definition TDataType.cxx:375; TEnum::GetEnumstatic TEnum * GetEnum(const std::type_info &ti, ESearchAction sa=kALoadAndInterpLookup)Definition TEnum.cxx:175; TEnum::kNone@ kNoneDefinition TEnum.h:48; TGenBitsetProxyDefinition TGenCollectionProxy.cxx:135; TGenBitsetProxy::TGenBitsetProxyTGenBitsetProxy(const TGenCollectionProxy &c)Definition TGenCollectionProxy.cxx:138; TGenBitsetProxy::DeleteItemvoid DeleteItem(Bool_t force, void *ptr) const ove",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:85472,Performance,cache,cache,85472,"iseActions(TClass *oldClass, Int_t version) overrideReturn the set of action necessary to stream in this collection member-wise coming from the old value...Definition TGenCollectionProxy.cxx:1747; TGenCollectionProxy::fReadMemberWiseTObjArray * fReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read)Definition TGenCollectionProxy.h:291; TGenCollectionProxy::DeleteItemvirtual void DeleteItem(Bool_t force, void *ptr) constCall to delete/destruct individual item.Definition TGenCollectionProxy.cxx:1350; TGenCollectionProxy::GetCollectionClassTClass * GetCollectionClass() const overrideReturn a pointer to the TClass representing the container.Definition TGenCollectionProxy.cxx:985; TGenCollectionProxy::fStagedStaged_t fStagedOptimization: Keep staged array once they were created.Definition TGenCollectionProxy.h:319; TGenCollectionProxy::fSizeMethod fSizeContainer accessors: size of container.Definition TGenCollectionProxy.h:302; TGenCollectionProxy::fClearMethod fClearMethod cache for container accessors: clear container.Definition TGenCollectionProxy.h:301; TGenCollectionProxy::fFeedFeedfunc_t fFeedContainer accessors: block feed.Definition TGenCollectionProxy.h:308; TGenCollectionProxy::GetFunctionCreateIteratorsCreateIterators_t GetFunctionCreateIterators(Bool_t read=kTRUE) overrideSee typedef void (*CreateIterators_t)(void *collection, void *&begin_arena, void *&end_arena); begin_...Definition TGenCollectionProxy.cxx:1607; TGenCollectionProxy::fValDiffint fValDiffOffset between two consecutive value_types (memory layout).Definition TGenCollectionProxy.h:316; TGenCollectionProxy::ReadBuffervirtual void ReadBuffer(TBuffer &b, void *obj)Definition TGenCollectionProxy.cxx:1419; TGenCollectionProxy::fProxyKeptProxies_t fProxyKeptOptimization: Keep proxies once they were created.Definition TGenCollectionProxy.h:318; TGenCollectionProxy::SizeofUInt_t Sizeof() const overrideReturn the sizeof the collection object.Definition TGenCollectionProxy.cxx:1014; TGe",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:87818,Performance,optimiz,optimization,87818," TGenCollectionProxy.cxx:201; TGenListProxy::TGenListProxyTGenListProxy(const TGenCollectionProxy &c)Definition TGenCollectionProxy.cxx:193; TGenMapProxyLocaloptimization class.Definition TGenCollectionProxy.cxx:277; TGenMapProxy::TGenMapProxyTGenMapProxy(const TGenCollectionProxy &c)Definition TGenCollectionProxy.cxx:280; TGenMapProxy::~TGenMapProxy~TGenMapProxy() overrideDefinition TGenCollectionProxy.cxx:284; TGenMapProxy::DeleteItemvoid DeleteItem(Bool_t force, void *ptr) const overrideCall to delete/destruct individual item.Definition TGenCollectionProxy.cxx:288; TGenSetProxyLocaloptimization class.Definition TGenCollectionProxy.cxx:232; TGenSetProxy::Atvoid * At(UInt_t idx) overrideReturn the address of the value at index 'idx'.Definition TGenCollectionProxy.cxx:243; TGenSetProxy::~TGenSetProxy~TGenSetProxy() overrideDefinition TGenCollectionProxy.cxx:239; TGenSetProxy::TGenSetProxyTGenSetProxy(const TGenCollectionProxy &c)Definition TGenCollectionProxy.cxx:235; TGenVectorBoolProxyLocal optimization class.Definition TGenCollectionProxy.cxx:88; TGenVectorBoolProxy::fLastValueBool_t fLastValueDefinition TGenCollectionProxy.cxx:89; TGenVectorBoolProxy::Atvoid * At(UInt_t idx) overrideReturn the address of the value at index 'idx'.Definition TGenCollectionProxy.cxx:100; TGenVectorBoolProxy::TGenVectorBoolProxyTGenVectorBoolProxy(const TGenCollectionProxy &c)Definition TGenCollectionProxy.cxx:92; TGenVectorBoolProxy::~TGenVectorBoolProxy~TGenVectorBoolProxy() overrideDefinition TGenCollectionProxy.cxx:96; TGenVectorBoolProxy::DeleteItemvoid DeleteItem(Bool_t force, void *ptr) const overrideCall to delete/destruct individual item.Definition TGenCollectionProxy.cxx:115; TGenVectorProxyLocal optimization class.Definition TGenCollectionProxy.cxx:39; TGenVectorProxy::DeleteItemvoid DeleteItem(Bool_t force, void *ptr) const overrideCall to delete/destruct individual item.Definition TGenCollectionProxy.cxx:66; TGenVectorProxy::Atvoid * At(UInt_t idx) overrideReturn the add",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:88529,Performance,optimiz,optimization,88529,"ss of the value at index 'idx'.Definition TGenCollectionProxy.cxx:243; TGenSetProxy::~TGenSetProxy~TGenSetProxy() overrideDefinition TGenCollectionProxy.cxx:239; TGenSetProxy::TGenSetProxyTGenSetProxy(const TGenCollectionProxy &c)Definition TGenCollectionProxy.cxx:235; TGenVectorBoolProxyLocal optimization class.Definition TGenCollectionProxy.cxx:88; TGenVectorBoolProxy::fLastValueBool_t fLastValueDefinition TGenCollectionProxy.cxx:89; TGenVectorBoolProxy::Atvoid * At(UInt_t idx) overrideReturn the address of the value at index 'idx'.Definition TGenCollectionProxy.cxx:100; TGenVectorBoolProxy::TGenVectorBoolProxyTGenVectorBoolProxy(const TGenCollectionProxy &c)Definition TGenCollectionProxy.cxx:92; TGenVectorBoolProxy::~TGenVectorBoolProxy~TGenVectorBoolProxy() overrideDefinition TGenCollectionProxy.cxx:96; TGenVectorBoolProxy::DeleteItemvoid DeleteItem(Bool_t force, void *ptr) const overrideCall to delete/destruct individual item.Definition TGenCollectionProxy.cxx:115; TGenVectorProxyLocal optimization class.Definition TGenCollectionProxy.cxx:39; TGenVectorProxy::DeleteItemvoid DeleteItem(Bool_t force, void *ptr) const overrideCall to delete/destruct individual item.Definition TGenCollectionProxy.cxx:66; TGenVectorProxy::Atvoid * At(UInt_t idx) overrideReturn the address of the value at index 'idx'.Definition TGenCollectionProxy.cxx:50; TGenVectorProxy::~TGenVectorProxy~TGenVectorProxy() overrideDefinition TGenCollectionProxy.cxx:46; TGenVectorProxy::TGenVectorProxyTGenVectorProxy(const TGenCollectionProxy &c)Definition TGenCollectionProxy.cxx:42; THashTableTHashTable implements a hash table to store TObject's.Definition THashTable.h:35; TInterpreter::SuspendAutoParsingDefinition TInterpreter.h:111; TInterpreter::TypeInfo_Initvirtual void TypeInfo_Init(TypeInfo_t *, const char *) constDefinition TInterpreter.h:528; TInterpreter::TypeInfo_Deletevirtual void TypeInfo_Delete(TypeInfo_t *) constDefinition TInterpreter.h:524; TInterpreter::TypeInfo_Factoryvirtual TypeInf",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:98018,Performance,cache,cache,98018,"ase::fObjectvoid * fObjectDefinition TCollectionProxyInfo.h:234; ROOT::Detail::TCollectionProxyInfo::EnvironSmall helper to save proxy environment in the event of recursive calls.Definition TCollectionProxyInfo.h:244; TGenCollectionProxy::ValueSmall helper to describe the Value_type or the key_type of an STL container.Definition TGenCollectionProxy.h:60; TGenCollectionProxy::Value::DeleteItemvoid DeleteItem(void *ptr)Definition TGenCollectionProxy.cxx:518; TGenCollectionProxy::Value::fCaseUInt_t fCasetype of data of Value_typeDefinition TGenCollectionProxy.h:64; TGenCollectionProxy::Value::fTypeTClassRef fTypeTClass reference of Value_type in collection.Definition TGenCollectionProxy.h:66; TGenCollectionProxy::Value::fPropertiesUInt_t fPropertiesAdditional properties of the value type (kNeedDelete)Definition TGenCollectionProxy.h:65; TGenCollectionProxy::Value::fSizesize_t fSizefSize of the contained objectDefinition TGenCollectionProxy.h:68; TGenCollectionProxy::Value::fDeleteROOT::DelFunc_t fDeleteMethod cache for containee delete.Definition TGenCollectionProxy.h:63; TGenCollectionProxy::Value::fDtorROOT::DesFunc_t fDtorMethod cache for containee destructor.Definition TGenCollectionProxy.h:62; TGenCollectionProxy::Value::fCtorROOT::NewFunc_t fCtorMethod cache for containee constructor.Definition TGenCollectionProxy.h:61; TGenCollectionProxy::Value::ValueValue(const std::string &info, Bool_t silent, size_t hint_pair_offset=0, size_t hint_pair_size=0)Constructor.Definition TGenCollectionProxy.cxx:316; TGenCollectionProxy::Value::fKindEDataType fKindkind of ROOT-fundamental typeDefinition TGenCollectionProxy.h:67; TGenCollectionProxy::Value::IsValidBool_t IsValid()Return true if the Value has been properly initialized.Definition TGenCollectionProxy.cxx:511; TGenCollectionProxy__SlowIteratorDefinition TGenCollectionProxy.cxx:1454; TGenCollectionProxy__SlowIterator::fProxyTVirtualCollectionProxy * fProxyDefinition TGenCollectionProxy.cxx:1455; TGenCollectionProxy__Slow",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:98143,Performance,cache,cache,98143,"proxy environment in the event of recursive calls.Definition TCollectionProxyInfo.h:244; TGenCollectionProxy::ValueSmall helper to describe the Value_type or the key_type of an STL container.Definition TGenCollectionProxy.h:60; TGenCollectionProxy::Value::DeleteItemvoid DeleteItem(void *ptr)Definition TGenCollectionProxy.cxx:518; TGenCollectionProxy::Value::fCaseUInt_t fCasetype of data of Value_typeDefinition TGenCollectionProxy.h:64; TGenCollectionProxy::Value::fTypeTClassRef fTypeTClass reference of Value_type in collection.Definition TGenCollectionProxy.h:66; TGenCollectionProxy::Value::fPropertiesUInt_t fPropertiesAdditional properties of the value type (kNeedDelete)Definition TGenCollectionProxy.h:65; TGenCollectionProxy::Value::fSizesize_t fSizefSize of the contained objectDefinition TGenCollectionProxy.h:68; TGenCollectionProxy::Value::fDeleteROOT::DelFunc_t fDeleteMethod cache for containee delete.Definition TGenCollectionProxy.h:63; TGenCollectionProxy::Value::fDtorROOT::DesFunc_t fDtorMethod cache for containee destructor.Definition TGenCollectionProxy.h:62; TGenCollectionProxy::Value::fCtorROOT::NewFunc_t fCtorMethod cache for containee constructor.Definition TGenCollectionProxy.h:61; TGenCollectionProxy::Value::ValueValue(const std::string &info, Bool_t silent, size_t hint_pair_offset=0, size_t hint_pair_size=0)Constructor.Definition TGenCollectionProxy.cxx:316; TGenCollectionProxy::Value::fKindEDataType fKindkind of ROOT-fundamental typeDefinition TGenCollectionProxy.h:67; TGenCollectionProxy::Value::IsValidBool_t IsValid()Return true if the Value has been properly initialized.Definition TGenCollectionProxy.cxx:511; TGenCollectionProxy__SlowIteratorDefinition TGenCollectionProxy.cxx:1454; TGenCollectionProxy__SlowIterator::fProxyTVirtualCollectionProxy * fProxyDefinition TGenCollectionProxy.cxx:1455; TGenCollectionProxy__SlowIterator::fIndexUInt_t fIndexDefinition TGenCollectionProxy.cxx:1456; TGenCollectionProxy__SlowIterator::TGenCollectionProxy__Slo",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:98272,Performance,cache,cache,98272,"o describe the Value_type or the key_type of an STL container.Definition TGenCollectionProxy.h:60; TGenCollectionProxy::Value::DeleteItemvoid DeleteItem(void *ptr)Definition TGenCollectionProxy.cxx:518; TGenCollectionProxy::Value::fCaseUInt_t fCasetype of data of Value_typeDefinition TGenCollectionProxy.h:64; TGenCollectionProxy::Value::fTypeTClassRef fTypeTClass reference of Value_type in collection.Definition TGenCollectionProxy.h:66; TGenCollectionProxy::Value::fPropertiesUInt_t fPropertiesAdditional properties of the value type (kNeedDelete)Definition TGenCollectionProxy.h:65; TGenCollectionProxy::Value::fSizesize_t fSizefSize of the contained objectDefinition TGenCollectionProxy.h:68; TGenCollectionProxy::Value::fDeleteROOT::DelFunc_t fDeleteMethod cache for containee delete.Definition TGenCollectionProxy.h:63; TGenCollectionProxy::Value::fDtorROOT::DesFunc_t fDtorMethod cache for containee destructor.Definition TGenCollectionProxy.h:62; TGenCollectionProxy::Value::fCtorROOT::NewFunc_t fCtorMethod cache for containee constructor.Definition TGenCollectionProxy.h:61; TGenCollectionProxy::Value::ValueValue(const std::string &info, Bool_t silent, size_t hint_pair_offset=0, size_t hint_pair_size=0)Constructor.Definition TGenCollectionProxy.cxx:316; TGenCollectionProxy::Value::fKindEDataType fKindkind of ROOT-fundamental typeDefinition TGenCollectionProxy.h:67; TGenCollectionProxy::Value::IsValidBool_t IsValid()Return true if the Value has been properly initialized.Definition TGenCollectionProxy.cxx:511; TGenCollectionProxy__SlowIteratorDefinition TGenCollectionProxy.cxx:1454; TGenCollectionProxy__SlowIterator::fProxyTVirtualCollectionProxy * fProxyDefinition TGenCollectionProxy.cxx:1455; TGenCollectionProxy__SlowIterator::fIndexUInt_t fIndexDefinition TGenCollectionProxy.cxx:1456; TGenCollectionProxy__SlowIterator::TGenCollectionProxy__SlowIteratorTGenCollectionProxy__SlowIterator(TVirtualCollectionProxy *proxy)Definition TGenCollectionProxy.cxx:1457; vecDefinition c",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:11235,Safety,avoid,avoid,11235," = kVoid_t;; 342 return;; 343 }; 344 }; 345 ; 346 if ( intype.substr(0,6) == ""string"" || intype.substr(0,11) == ""std::string"" ) {; 347 fCase = kBIT_ISSTRING;; 348 fType = TClass::GetClass(""string"");; 349 fCtor = fType->GetNew();; 350 fDtor = fType->GetDestructor();; 351 fDelete = fType->GetDelete();; 352 if (isPointer) {; 353 fCase |= kIsPointer;; 354 fSize = sizeof(void*);; 355 } else {; 356 fSize = sizeof(std::string);; 357 }; 358 }; 359 else {; 360 // In the case where we have an emulated class,; 361 // if the class is nested (in a class or a namespace),; 362 // calling G__TypeInfo ti(inside.c_str());; 363 // might fail because CINT does not known the nesting; 364 // scope, so let's first look for an emulated class:; 365 ; 366 fType = TClass::GetClass(intype.c_str(),kTRUE,silent, hint_pair_offset, hint_pair_size);; 367 ; 368 if (fType) {; 369 if (isPointer) {; 370 fCase |= kIsPointer;; 371 fSize = sizeof(void*);; 372 if (fType == TString::Class()) {; 373 fCase |= kBIT_ISTSTRING;; 374 }; 375 }; 376 fCase |= kIsClass;; 377 fCtor = fType->GetNew();; 378 fDtor = fType->GetDestructor();; 379 fDelete = fType->GetDelete();; 380 } else {; 381 R__LOCKGUARD(gInterpreterMutex);; 382 ; 383 // Try to avoid autoparsing.; 384 ; 385 THashTable *typeTable = dynamic_cast<THashTable*>( gROOT->GetListOfTypes() );; 386 assert(typeTable && ""The type of the list of type has changed"");; 387 ; 388 TDataType *fundType = (TDataType *)typeTable->THashTable::FindObject( intype.c_str() );; 389 if (fundType && fundType->GetType() < 0x17 && fundType->GetType() > 0) {; 390 fKind = (EDataType)fundType->GetType();; 391 // R__ASSERT((fKind>0 && fKind<0x17) || (fKind==-1&&(prop&kIsPointer)) );; 392 ; 393 fCase |= kIsFundamental;; 394 if (isPointer) {; 395 fCase |= kIsPointer;; 396 fSize = sizeof(void*);; 397 } else {; 398 fSize = fundType->Size();; 399 }; 400 } else if (TEnum::GetEnum( intype.c_str(), TEnum::kNone) ) {; 401 // This is a known enum.; 402 fCase = kIsEnum;; 403 fSize = sizeof(Int_t);; ",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:48407,Safety,safe,safely,48407,"oxy *proxy); 1463{; 1464 new (*begin_arena) TGenCollectionProxy__SlowIterator(proxy);; 1465 *(UInt_t*)*end_arena = proxy->Size();; 1466}; 1467 ; 1468////////////////////////////////////////////////////////////////////////////////; 1469 ; 1470void *TGenCollectionProxy__SlowNext(void *iter, const void *end); 1471{; 1472 TGenCollectionProxy__SlowIterator *iterator = (TGenCollectionProxy__SlowIterator*)iter;; 1473 if (iterator->fIndex != *(UInt_t*)end) {; 1474 void *result = iterator->fProxy->At(iterator->fIndex);; 1475 ++(iterator->fIndex);; 1476 return result;; 1477 } else {; 1478 return 0;; 1479 }; 1480}; 1481 ; 1482////////////////////////////////////////////////////////////////////////////////; 1483 ; 1484void * TGenCollectionProxy__SlowCopyIterator(void *dest, const void *source); 1485{; 1486 *(TGenCollectionProxy__SlowIterator*)dest = *(TGenCollectionProxy__SlowIterator*)source;; 1487 return dest;; 1488}; 1489 ; 1490////////////////////////////////////////////////////////////////////////////////; 1491/// Nothing to do; 1492 ; 1493void TGenCollectionProxy__SlowDeleteSingleIterators(void *); 1494{; 1495}; 1496 ; 1497////////////////////////////////////////////////////////////////////////////////; 1498/// Nothing to do; 1499 ; 1500void TGenCollectionProxy__SlowDeleteTwoIterators(void *, void *); 1501{; 1502}; 1503 ; 1504 ; 1505////////////////////////////////////////////////////////////////////////////////; 1506/// We can safely assume that the std::vector layout does not really depend on; 1507/// the content!; 1508 ; 1509void TGenCollectionProxy__VectorCreateIterators(void *obj, void **begin_arena, void **end_arena, TVirtualCollectionProxy*); 1510{; 1511 std::vector<char> *vec = (std::vector<char>*)obj;; 1512 if (vec->empty()) {; 1513 *begin_arena = 0;; 1514 *end_arena = 0;; 1515 return;; 1516 }; 1517 *begin_arena = &(*vec->begin());; 1518#ifdef R__VISUAL_CPLUSPLUS; 1519 *end_arena = &(*(vec->end()-1)) + 1; // On windows we can not dererence the end iterator at all.",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:63828,Safety,abort,abort,63828,"on TDataType.h:32; kVoid_t@ kVoid_tDefinition TDataType.h:35; kIsPointer@ kIsPointerDefinition TDictionary.h:78; kIsClass@ kIsClassDefinition TDictionary.h:65; kIsEnum@ kIsEnumDefinition TDictionary.h:68; kIsFundamental@ kIsFundamentalDefinition TDictionary.h:70; kIsStruct@ kIsStructDefinition TDictionary.h:66; TEnum.h; TError.h; R__ASSERT#define R__ASSERT(e)Checks condition e and reports a fatal error if it's false.Definition TError.h:125; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; MayNotUsevoid MayNotUse(const char *method)This function can be used in classes that should override a certain function, but in the inherited cl...Definition TError.cxx:168; Warningvoid Warning(const char *location, const char *msgfmt,...)Use this function in warning situations.Definition TError.cxx:229; Fatalvoid Fatal(const char *location, const char *msgfmt,...)Use this function in case of a fatal error. It will abort the program.Definition TError.cxx:244; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; destOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t destDefinition TGWin32VirtualXProxy.cxx:164; propOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:67208,Safety,safe,safely,67208,"ectorNext(void *, const void *)Should not be used.Definition TGenCollectionProxy.cxx:1530; R__CreateValuestatic TGenCollectionProxy::Value * R__CreateValue(const std::string &name, Bool_t silent, size_t hint_pair_offset=0, size_t hint_pair_size=0)Utility routine to issue a Fatal error is the Value object is not valid.Definition TGenCollectionProxy.cxx:830; TGenCollectionProxy__StagingDeleteSingleIteratorsvoid TGenCollectionProxy__StagingDeleteSingleIterators(void *)Nothing to do.Definition TGenCollectionProxy.cxx:1589; TGenCollectionProxy__SlowCreateIteratorsvoid TGenCollectionProxy__SlowCreateIterators(void *, void **begin_arena, void **end_arena, TVirtualCollectionProxy *proxy)Definition TGenCollectionProxy.cxx:1462; TGenCollectionProxy__SlowNextvoid * TGenCollectionProxy__SlowNext(void *iter, const void *end)Definition TGenCollectionProxy.cxx:1470; TGenCollectionProxy__VectorCreateIteratorsvoid TGenCollectionProxy__VectorCreateIterators(void *obj, void **begin_arena, void **end_arena, TVirtualCollectionProxy *)We can safely assume that the std::vector layout does not really depend on the content!Definition TGenCollectionProxy.cxx:1509; TGenCollectionProxy__StagingCopyIteratorvoid * TGenCollectionProxy__StagingCopyIterator(void *dest, const void *source)Definition TGenCollectionProxy.cxx:1580; TGenCollectionProxy__StagingNextvoid * TGenCollectionProxy__StagingNext(void *, const void *)Should not be used.Definition TGenCollectionProxy.cxx:1572; TGenCollectionProxy__VectorDeleteSingleIteratorsvoid TGenCollectionProxy__VectorDeleteSingleIterators(void *)Nothing to do.Definition TGenCollectionProxy.cxx:1547; TGenCollectionProxy__SlowCopyIteratorvoid * TGenCollectionProxy__SlowCopyIterator(void *dest, const void *source)Definition TGenCollectionProxy.cxx:1484; TGenCollectionProxy__StagingCreateIteratorsvoid TGenCollectionProxy__StagingCreateIterators(void *obj, void **begin_arena, void **end_arena, TVirtualCollectionProxy *)Definition TGenCollectionProxy.cxx:1562; TGenC",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:1329,Security,access,access,1329,"***************************; 5 * Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#include ""TGenCollectionProxy.h""; 13#include ""TVirtualStreamerInfo.h""; 14#include ""TStreamerElement.h""; 15#include ""TClassEdit.h""; 16#include ""TClass.h""; 17#include ""TError.h""; 18#include ""TEnum.h""; 19#include ""TROOT.h""; 20#include ""TInterpreter.h"" // For gInterpreterMutex; 21#include ""TVirtualMutex.h""; 22#include ""TStreamerInfoActions.h""; 23#include ""THashTable.h""; 24#include ""THashList.h""; 25#include <cstdlib>; 26 ; 27#define MESSAGE(which,text); 28 ; 29/**; 30\class TGenVectorProxy; 31\ingroup IO; 32Local optimization class.; 33 ; 34Collection proxies get copied. On copy we switch the type of the; 35proxy to the concrete STL type. The concrete types are optimized; 36for element access.; 37*/; 38 ; 39class TGenVectorProxy : public TGenCollectionProxy {; 40public:; 41 // Standard Destructor; 42 TGenVectorProxy(const TGenCollectionProxy& c) : TGenCollectionProxy(c); 43 {; 44 }; 45 // Standard Destructor; 46 ~TGenVectorProxy() override; 47 {; 48 }; 49 // Return the address of the value at index 'idx'; 50 void* At(UInt_t idx) override; 51 {; 52 if ( fEnv && fEnv->fObject ) {; 53 fEnv->fIdx = idx;; 54 switch( idx ) {; 55 case 0:; 56 return fEnv->fStart = fFirst.invoke(fEnv);; 57 default:; 58 if (! fEnv->fStart ) fEnv->fStart = fFirst.invoke(fEnv);; 59 return ((char*)fEnv->fStart) + fValDiff*idx;; 60 }; 61 }; 62 Fatal(""TGenVectorProxy"",""At> Logic error - no proxy object set."");; 63 return nullptr;; 64 }; 65 // Call to delete/destruct individual item; 66 void DeleteItem(Bool_t force, void* ptr) const override; 67 {; 68 if ( force && ptr ) {; 69 if ( fVal->fProperties&kNeedDelete) {; 70 TVirtualCollectionProxy *proxy = fVal->fType->GetCollectionPr",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:2667,Security,access,access,2667,"x 'idx'; 50 void* At(UInt_t idx) override; 51 {; 52 if ( fEnv && fEnv->fObject ) {; 53 fEnv->fIdx = idx;; 54 switch( idx ) {; 55 case 0:; 56 return fEnv->fStart = fFirst.invoke(fEnv);; 57 default:; 58 if (! fEnv->fStart ) fEnv->fStart = fFirst.invoke(fEnv);; 59 return ((char*)fEnv->fStart) + fValDiff*idx;; 60 }; 61 }; 62 Fatal(""TGenVectorProxy"",""At> Logic error - no proxy object set."");; 63 return nullptr;; 64 }; 65 // Call to delete/destruct individual item; 66 void DeleteItem(Bool_t force, void* ptr) const override; 67 {; 68 if ( force && ptr ) {; 69 if ( fVal->fProperties&kNeedDelete) {; 70 TVirtualCollectionProxy *proxy = fVal->fType->GetCollectionProxy();; 71 TPushPop helper(proxy,ptr);; 72 proxy->Clear(""force"");; 73 }; 74 fVal->DeleteItem(ptr);; 75 }; 76 }; 77};; 78 ; 79/**; 80\class TGenVectorBoolProxy; 81\ingroup IO; 82Local optimization class.; 83 ; 84Collection proxies get copied. On copy we switch the type of the; 85proxy to the concrete STL type. The concrete types are optimized; 86for element access.; 87*/; 88class TGenVectorBoolProxy : public TGenCollectionProxy {; 89 Bool_t fLastValue;; 90 ; 91public:; 92 TGenVectorBoolProxy(const TGenCollectionProxy& c) : TGenCollectionProxy(c), fLastValue(false); 93 {; 94 // Standard Constructor.; 95 }; 96 ~TGenVectorBoolProxy() override; 97 {; 98 // Standard Destructor.; 99 }; 100 void* At(UInt_t idx) override; 101 {; 102 // Return the address of the value at index 'idx'; 103 ; 104 // However we can 'take' the address of the content of std::vector<bool>.; 105 if ( fEnv && fEnv->fObject ) {; 106 auto vec = (std::vector<bool> *)(fEnv->fObject);; 107 fLastValue = (*vec)[idx];; 108 fEnv->fIdx = idx;; 109 return &fLastValue;; 110 }; 111 Fatal(""TGenVectorProxy"",""At> Logic error - no proxy object set."");; 112 return nullptr;; 113 }; 114 ; 115 void DeleteItem(Bool_t force, void* ptr) const override; 116 {; 117 // Call to delete/destruct individual item; 118 if ( force && ptr ) {; 119 fVal->DeleteItem(ptr);; 120 }; 121 }; 1",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:3985,Security,access,access,3985,"98 // Standard Destructor.; 99 }; 100 void* At(UInt_t idx) override; 101 {; 102 // Return the address of the value at index 'idx'; 103 ; 104 // However we can 'take' the address of the content of std::vector<bool>.; 105 if ( fEnv && fEnv->fObject ) {; 106 auto vec = (std::vector<bool> *)(fEnv->fObject);; 107 fLastValue = (*vec)[idx];; 108 fEnv->fIdx = idx;; 109 return &fLastValue;; 110 }; 111 Fatal(""TGenVectorProxy"",""At> Logic error - no proxy object set."");; 112 return nullptr;; 113 }; 114 ; 115 void DeleteItem(Bool_t force, void* ptr) const override; 116 {; 117 // Call to delete/destruct individual item; 118 if ( force && ptr ) {; 119 fVal->DeleteItem(ptr);; 120 }; 121 }; 122};; 123 ; 124//////////////////////////////////////////////////////////////////////////; 125// //; 126// class TGenBitsetProxy; 127//; 128// Local optimization class.; 129//; 130// Collection proxies get copied. On copy we switch the type of the; 131// proxy to the concrete STL type. The concrete types are optimized; 132// for element access.; 133//; 134//////////////////////////////////////////////////////////////////////////; 135class TGenBitsetProxy : public TGenCollectionProxy {; 136 ; 137public:; 138 TGenBitsetProxy(const TGenCollectionProxy& c) : TGenCollectionProxy(c); 139 {; 140 // Standard Constructor.; 141 }; 142 ~TGenBitsetProxy() override; 143 {; 144 // Standard Destructor.; 145 }; 146 void* At(UInt_t idx) override; 147 {; 148 // Return the address of the value at index 'idx'; 149 ; 150 if ( fEnv && fEnv->fObject ) {; 151 switch( idx ) {; 152 case 0:; 153 fEnv->fStart = fFirst.invoke(fEnv);; 154 fEnv->fIdx = idx;; 155 break;; 156 default:; 157 fEnv->fIdx = idx - fEnv->fIdx;; 158 if (! fEnv->fStart ) fEnv->fStart = fFirst.invoke(fEnv);; 159 fNext.invoke(fEnv);; 160 fEnv->fIdx = idx;; 161 break;; 162 }; 163 typedef ROOT::TCollectionProxyInfo::Environ<std::pair<size_t,Bool_t> > EnvType_t;; 164 EnvType_t *e = (EnvType_t*)fEnv;; 165 return &(e->fIterator.second);; 166 }; 167 Fatal(""TGen",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:5482,Security,access,access,5482," ( fEnv && fEnv->fObject ) {; 151 switch( idx ) {; 152 case 0:; 153 fEnv->fStart = fFirst.invoke(fEnv);; 154 fEnv->fIdx = idx;; 155 break;; 156 default:; 157 fEnv->fIdx = idx - fEnv->fIdx;; 158 if (! fEnv->fStart ) fEnv->fStart = fFirst.invoke(fEnv);; 159 fNext.invoke(fEnv);; 160 fEnv->fIdx = idx;; 161 break;; 162 }; 163 typedef ROOT::TCollectionProxyInfo::Environ<std::pair<size_t,Bool_t> > EnvType_t;; 164 EnvType_t *e = (EnvType_t*)fEnv;; 165 return &(e->fIterator.second);; 166 }; 167 Fatal(""TGenVectorProxy"",""At> Logic error - no proxy object set."");; 168 return 0;; 169 }; 170 ; 171 void DeleteItem(Bool_t force, void* ptr) const override; 172 {; 173 // Call to delete/destruct individual item; 174 if ( force && ptr ) {; 175 fVal->DeleteItem(ptr);; 176 }; 177 }; 178};; 179 ; 180/*; 181\class TGenListProxy; 182\ingroup IO; 183Local optimization class.; 184 ; 185Collection proxies get copied. On copy we switch the type of the; 186proxy to the concrete STL type. The concrete types are optimized; 187for element access.; 188**/; 189 ; 190class TGenListProxy : public TGenVectorProxy {; 191public:; 192 // Standard Destructor; 193 TGenListProxy(const TGenCollectionProxy& c) : TGenVectorProxy(c); 194 {; 195 }; 196 // Standard Destructor; 197 ~TGenListProxy() override; 198 {; 199 }; 200 // Return the address of the value at index 'idx'; 201 void* At(UInt_t idx) override; 202 {; 203 if ( fEnv && fEnv->fObject ) {; 204 switch( idx ) {; 205 case 0:; 206 fEnv->fIdx = idx;; 207 return fEnv->fStart = fFirst.invoke(fEnv);; 208 default: {; 209 fEnv->fIdx = idx - fEnv->fIdx;; 210 if (! fEnv->fStart ) fEnv->fStart = fFirst.invoke(fEnv);; 211 void* result = fNext.invoke(fEnv);; 212 fEnv->fIdx = idx;; 213 return result;; 214 }; 215 }; 216 }; 217 Fatal(""TGenListProxy"",""At> Logic error - no proxy object set."");; 218 return nullptr;; 219 }; 220};; 221 ; 222/**; 223\class TGenSetProxy; 224\ingroup IO; 225Localoptimization class.; 226 ; 227Collection proxies get copied. On copy we switch the ty",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:6556,Security,access,access,6556,"ic TGenVectorProxy {; 191public:; 192 // Standard Destructor; 193 TGenListProxy(const TGenCollectionProxy& c) : TGenVectorProxy(c); 194 {; 195 }; 196 // Standard Destructor; 197 ~TGenListProxy() override; 198 {; 199 }; 200 // Return the address of the value at index 'idx'; 201 void* At(UInt_t idx) override; 202 {; 203 if ( fEnv && fEnv->fObject ) {; 204 switch( idx ) {; 205 case 0:; 206 fEnv->fIdx = idx;; 207 return fEnv->fStart = fFirst.invoke(fEnv);; 208 default: {; 209 fEnv->fIdx = idx - fEnv->fIdx;; 210 if (! fEnv->fStart ) fEnv->fStart = fFirst.invoke(fEnv);; 211 void* result = fNext.invoke(fEnv);; 212 fEnv->fIdx = idx;; 213 return result;; 214 }; 215 }; 216 }; 217 Fatal(""TGenListProxy"",""At> Logic error - no proxy object set."");; 218 return nullptr;; 219 }; 220};; 221 ; 222/**; 223\class TGenSetProxy; 224\ingroup IO; 225Localoptimization class.; 226 ; 227Collection proxies get copied. On copy we switch the type of the; 228proxy to the concrete STL type. The concrete types are optimized; 229for element access.; 230*/; 231 ; 232class TGenSetProxy : public TGenVectorProxy {; 233public:; 234 // Standard Destructor; 235 TGenSetProxy(const TGenCollectionProxy& c) : TGenVectorProxy(c); 236 {; 237 }; 238 // Standard Destructor; 239 ~TGenSetProxy() override; 240 {; 241 }; 242 // Return the address of the value at index 'idx'; 243 void* At(UInt_t idx) override; 244 {; 245 if ( fEnv && fEnv->fObject ) {; 246 if ( fEnv->fUseTemp ) {; 247 return (((char*)fEnv->fTemp)+idx*fValDiff);; 248 }; 249 switch( idx ) {; 250 case 0:; 251 fEnv->fIdx = idx;; 252 return fEnv->fStart = fFirst.invoke(fEnv);; 253 default: {; 254 fEnv->fIdx = idx - fEnv->fIdx;; 255 if (! fEnv->fStart ) fEnv->fStart = fFirst.invoke(fEnv);; 256 void* result = fNext.invoke(fEnv);; 257 fEnv->fIdx = idx;; 258 return result;; 259 }; 260 }; 261 }; 262 Fatal(""TGenSetProxy"",""At> Logic error - no proxy object set."");; 263 return nullptr;; 264 }; 265};; 266 ; 267/**; 268\class TGenMapProxy; 269\ingroup IO; 270Localoptim",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:7710,Security,access,access,7710,"st TGenCollectionProxy& c) : TGenVectorProxy(c); 236 {; 237 }; 238 // Standard Destructor; 239 ~TGenSetProxy() override; 240 {; 241 }; 242 // Return the address of the value at index 'idx'; 243 void* At(UInt_t idx) override; 244 {; 245 if ( fEnv && fEnv->fObject ) {; 246 if ( fEnv->fUseTemp ) {; 247 return (((char*)fEnv->fTemp)+idx*fValDiff);; 248 }; 249 switch( idx ) {; 250 case 0:; 251 fEnv->fIdx = idx;; 252 return fEnv->fStart = fFirst.invoke(fEnv);; 253 default: {; 254 fEnv->fIdx = idx - fEnv->fIdx;; 255 if (! fEnv->fStart ) fEnv->fStart = fFirst.invoke(fEnv);; 256 void* result = fNext.invoke(fEnv);; 257 fEnv->fIdx = idx;; 258 return result;; 259 }; 260 }; 261 }; 262 Fatal(""TGenSetProxy"",""At> Logic error - no proxy object set."");; 263 return nullptr;; 264 }; 265};; 266 ; 267/**; 268\class TGenMapProxy; 269\ingroup IO; 270Localoptimization class.; 271 ; 272Collection proxies get copied. On copy we switch the type of the; 273proxy to the concrete STL type. The concrete types are optimized; 274for element access.; 275*/; 276 ; 277class TGenMapProxy : public TGenSetProxy {; 278public:; 279 // Standard Destructor; 280 TGenMapProxy(const TGenCollectionProxy& c) : TGenSetProxy(c); 281 {; 282 }; 283 // Standard Destructor; 284 ~TGenMapProxy() override; 285 {; 286 }; 287 // Call to delete/destruct individual item; 288 void DeleteItem(Bool_t force, void* ptr) const override; 289 {; 290 if (force) {; 291 if ( fKey->fProperties&kNeedDelete) {; 292 TVirtualCollectionProxy *proxy = fKey->fType->GetCollectionProxy();; 293 TPushPop helper(proxy,fKey->fCase&kIsPointer ? *(void**)ptr : ptr);; 294 proxy->Clear(""force"");; 295 }; 296 if ( fVal->fProperties&kNeedDelete) {; 297 TVirtualCollectionProxy *proxy = fVal->fType->GetCollectionProxy();; 298 char *addr = ((char*)ptr)+fValOffset;; 299 TPushPop helper(proxy,fVal->fCase&kIsPointer ? *(void**)addr : addr);; 300 proxy->Clear(""force"");; 301 }; 302 }; 303 if ( fKey->fCase&kIsPointer ) {; 304 fKey->DeleteItem(*(void**)ptr);; 305 }; 306",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:16228,Security,expose,expose,16228," The caller should check the validity by calling IsValid(); 502 } else {; 503 fSize = fType->Size();; 504 }; 505 }; 506}; 507 ; 508////////////////////////////////////////////////////////////////////////////////; 509/// Return true if the Value has been properly initialized.; 510 ; 511Bool_t TGenCollectionProxy::Value::IsValid(); 512{; 513 ; 514 ; 515 return fSize != std::string::npos;; 516}; 517 ; 518void TGenCollectionProxy::Value::DeleteItem(void* ptr); 519{; 520 // Delete an item.; 521 ; 522 if ( ptr && fCase&kIsPointer ) {; 523 if ( fDelete ) {; 524 (*fDelete)(ptr);; 525 }; 526 else if ( fType ) {; 527 fType->Destructor(ptr);; 528 }; 529 else {; 530 ::operator delete(ptr);; 531 }; 532 }; 533}; 534 ; 535/**; 536 \class TGenCollectionProxy TGenCollectionProxy.cxx; 537 \ingroup IO; 538 ; 539 Proxy around an arbitrary container, which implements basic; 540 functionality and iteration.; 541 ; 542 The purpose of this implementation; 543 is to shield any generated dictionary implementation from the; 544 underlying streamer/proxy implementation and only expose; 545 the creation functions.; 546 ; 547 In particular this is used to implement splitting and abstract; 548 element access of any container. Access to compiled code is necessary; 549 to implement the abstract iteration sequence and functionality like; 550 size(), clear(), resize(). resize() may be a void operation.; 551*/; 552 ; 553////////////////////////////////////////////////////////////////////////////////; 554/// Build a proxy for an emulated container.; 555 ; 556TGenCollectionProxy::TGenCollectionProxy(const TGenCollectionProxy& copy); 557 : TVirtualCollectionProxy(copy.fClass),; 558 fTypeinfo(copy.fTypeinfo); 559{; 560 fEnv = 0;; 561 fName = copy.fName;; 562 fPointers = copy.fPointers;; 563 fSTL_type = copy.fSTL_type;; 564 fSize.call = copy.fSize.call;; 565 fNext.call = copy.fNext.call;; 566 fFirst.call = copy.fFirst.call;; 567 fClear.call = copy.fClear.call;; 568 fResize = copy.fResize;; 569 fDestruct = ",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:16351,Security,access,access,16351,"/////////////////////////////////////////////////////; 509/// Return true if the Value has been properly initialized.; 510 ; 511Bool_t TGenCollectionProxy::Value::IsValid(); 512{; 513 ; 514 ; 515 return fSize != std::string::npos;; 516}; 517 ; 518void TGenCollectionProxy::Value::DeleteItem(void* ptr); 519{; 520 // Delete an item.; 521 ; 522 if ( ptr && fCase&kIsPointer ) {; 523 if ( fDelete ) {; 524 (*fDelete)(ptr);; 525 }; 526 else if ( fType ) {; 527 fType->Destructor(ptr);; 528 }; 529 else {; 530 ::operator delete(ptr);; 531 }; 532 }; 533}; 534 ; 535/**; 536 \class TGenCollectionProxy TGenCollectionProxy.cxx; 537 \ingroup IO; 538 ; 539 Proxy around an arbitrary container, which implements basic; 540 functionality and iteration.; 541 ; 542 The purpose of this implementation; 543 is to shield any generated dictionary implementation from the; 544 underlying streamer/proxy implementation and only expose; 545 the creation functions.; 546 ; 547 In particular this is used to implement splitting and abstract; 548 element access of any container. Access to compiled code is necessary; 549 to implement the abstract iteration sequence and functionality like; 550 size(), clear(), resize(). resize() may be a void operation.; 551*/; 552 ; 553////////////////////////////////////////////////////////////////////////////////; 554/// Build a proxy for an emulated container.; 555 ; 556TGenCollectionProxy::TGenCollectionProxy(const TGenCollectionProxy& copy); 557 : TVirtualCollectionProxy(copy.fClass),; 558 fTypeinfo(copy.fTypeinfo); 559{; 560 fEnv = 0;; 561 fName = copy.fName;; 562 fPointers = copy.fPointers;; 563 fSTL_type = copy.fSTL_type;; 564 fSize.call = copy.fSize.call;; 565 fNext.call = copy.fNext.call;; 566 fFirst.call = copy.fFirst.call;; 567 fClear.call = copy.fClear.call;; 568 fResize = copy.fResize;; 569 fDestruct = copy.fDestruct;; 570 fConstruct = copy.fConstruct;; 571 fFeed = copy.fFeed;; 572 fCollect = copy.fCollect;; 573 fCreateEnv.call = copy.fCreateEnv.call;; 574 f",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:76503,Security,access,accessors,76503," * GetContent()Definition TGenCollectionProxy.h:257; TGenCollectionProxy::TStaging::GetSizesize_t GetSize()Definition TGenCollectionProxy.h:265; TGenCollectionProxy::TStaging::GetTargetvoid * GetTarget()Definition TGenCollectionProxy.h:269; TGenCollectionProxy::TStaging::Resizevoid Resize(size_t nelement)Definition TGenCollectionProxy.h:273; TGenCollectionProxy::TStaging::GetEndvoid * GetEnd()Definition TGenCollectionProxy.h:261; TGenCollectionProxy::TStaging::SetTargetvoid SetTarget(void *target)Definition TGenCollectionProxy.h:280; TGenCollectionProxyProxy around an arbitrary container, which implements basic functionality and iteration.Definition TGenCollectionProxy.h:31; TGenCollectionProxy::GetReadMemberWiseActionsTStreamerInfoActions::TActionSequence * GetReadMemberWiseActions(Int_t version) overrideReturn the set of action necessary to stream in this collection member-wise coming from the old value...Definition TGenCollectionProxy.cxx:1798; TGenCollectionProxy::fFirstMethod fFirstContainer accessors: generic iteration: first.Definition TGenCollectionProxy.h:304; TGenCollectionProxy::fValuestd::atomic< Value * > fValueDescriptor of the container value type.Definition TGenCollectionProxy.h:311; TGenCollectionProxy::fFunctionNextIteratorNext_t fFunctionNextIteratorDefinition TGenCollectionProxy.h:326; TGenCollectionProxy::Insertvoid Insert(const void *data, void *container, size_t size) overrideInsert data into the container where data is a C-style array of the actual type contained in the coll...Definition TGenCollectionProxy.cxx:1269; TGenCollectionProxy::fPointersBool_t fPointersFlag to indicate if containee has pointers (key or value)Definition TGenCollectionProxy.h:300; TGenCollectionProxy::fNextMethod fNextContainer accessors: generic iteration: next.Definition TGenCollectionProxy.h:305; TGenCollectionProxy::Streamervirtual void Streamer(TBuffer &refBuffer)Streamer Function.Definition TGenCollectionProxy.cxx:1427; TGenCollectionProxy::fWriteMemberWiseTStre",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:77247,Security,access,accessors,77247,"ons::TActionSequence * GetReadMemberWiseActions(Int_t version) overrideReturn the set of action necessary to stream in this collection member-wise coming from the old value...Definition TGenCollectionProxy.cxx:1798; TGenCollectionProxy::fFirstMethod fFirstContainer accessors: generic iteration: first.Definition TGenCollectionProxy.h:304; TGenCollectionProxy::fValuestd::atomic< Value * > fValueDescriptor of the container value type.Definition TGenCollectionProxy.h:311; TGenCollectionProxy::fFunctionNextIteratorNext_t fFunctionNextIteratorDefinition TGenCollectionProxy.h:326; TGenCollectionProxy::Insertvoid Insert(const void *data, void *container, size_t size) overrideInsert data into the container where data is a C-style array of the actual type contained in the coll...Definition TGenCollectionProxy.cxx:1269; TGenCollectionProxy::fPointersBool_t fPointersFlag to indicate if containee has pointers (key or value)Definition TGenCollectionProxy.h:300; TGenCollectionProxy::fNextMethod fNextContainer accessors: generic iteration: next.Definition TGenCollectionProxy.h:305; TGenCollectionProxy::Streamervirtual void Streamer(TBuffer &refBuffer)Streamer Function.Definition TGenCollectionProxy.cxx:1427; TGenCollectionProxy::fWriteMemberWiseTStreamerInfoActions::TActionSequence * fWriteMemberWiseDefinition TGenCollectionProxy.h:293; TGenCollectionProxy::Allocatevoid * Allocate(UInt_t n, Bool_t forceDelete) overrideAllocate the needed space.Definition TGenCollectionProxy.cxx:1192; TGenCollectionProxy::ResetBool_t Reset() overrideReset the info gathered from StreamerInfos and value's TClass.Definition TGenCollectionProxy.cxx:779; TGenCollectionProxy::fTypeinfoInfo_t fTypeinfoType information.Definition TGenCollectionProxy.h:321; TGenCollectionProxy::fValOffsetint fValOffsetOffset from key to value (in maps)Definition TGenCollectionProxy.h:315; TGenCollectionProxy::TGenCollectionProxyTGenCollectionProxy(); TGenCollectionProxy::GetValueClassTClass * GetValueClass() const overrideRe",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:81717,Security,access,accessors,81717,"3; TGenCollectionProxy::Resizevirtual void Resize(UInt_t n, Bool_t force_delete)Resize the container.Definition TGenCollectionProxy.cxx:1169; TGenCollectionProxy::GetCollectionTypeInt_t GetCollectionType() const overrideReturn the type of collection see TClassEdit::ESTLType.Definition TGenCollectionProxy.cxx:993; TGenCollectionProxy::Clearvoid Clear(const char *opt="""") overrideClear the emulated collection.Definition TGenCollectionProxy.cxx:1136; TGenCollectionProxy::fProxyListProxies_t fProxyListStack of recursive proxies.Definition TGenCollectionProxy.h:317; TGenCollectionProxy::GetFunctionDeleteIteratorDeleteIterator_t GetFunctionDeleteIterator(Bool_t read=kTRUE) overrideSee typedef void (*DeleteIterator_t)(void *iter); If the sizeof iterator is greater than fgIteratorAr...Definition TGenCollectionProxy.cxx:1696; TGenCollectionProxy::SizeUInt_t Size() const overrideReturn the current size of the container.Definition TGenCollectionProxy.cxx:1153; TGenCollectionProxy::fDestructSizing_t fDestructContainer accessors: block destruct.Definition TGenCollectionProxy.h:307; TGenCollectionProxy::fCreateEnvMethod0 fCreateEnvMethod to allocate an Environment holder.Definition TGenCollectionProxy.h:310; TGenCollectionProxy::fValValue * fValDescriptor of the Value_type.Definition TGenCollectionProxy.h:312; TGenCollectionProxy::GetFunctionNextNext_t GetFunctionNext(Bool_t read=kTRUE) overrideSee typedef void* (*Next_t)(void *iter, void *end); iter and end should be pointer to respectively an...Definition TGenCollectionProxy.cxx:1670; TGenCollectionProxy::operator()virtual void operator()(TBuffer &refBuffer, void *pObject)TClassStreamer IO overload.Definition TGenCollectionProxy.cxx:1448; TGenCollectionProxy::fOnFileClassTClass * fOnFileClassOn file class.Definition TGenCollectionProxy.h:322; TGenCollectionProxy::fResizeSizing_t fResizeContainer accessors: resize container.Definition TGenCollectionProxy.h:303; TGenCollectionProxy::fConstructArrIterfunc_t fConstructContainer acce",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:82561,Security,access,accessors,82561,":SizeUInt_t Size() const overrideReturn the current size of the container.Definition TGenCollectionProxy.cxx:1153; TGenCollectionProxy::fDestructSizing_t fDestructContainer accessors: block destruct.Definition TGenCollectionProxy.h:307; TGenCollectionProxy::fCreateEnvMethod0 fCreateEnvMethod to allocate an Environment holder.Definition TGenCollectionProxy.h:310; TGenCollectionProxy::fValValue * fValDescriptor of the Value_type.Definition TGenCollectionProxy.h:312; TGenCollectionProxy::GetFunctionNextNext_t GetFunctionNext(Bool_t read=kTRUE) overrideSee typedef void* (*Next_t)(void *iter, void *end); iter and end should be pointer to respectively an...Definition TGenCollectionProxy.cxx:1670; TGenCollectionProxy::operator()virtual void operator()(TBuffer &refBuffer, void *pObject)TClassStreamer IO overload.Definition TGenCollectionProxy.cxx:1448; TGenCollectionProxy::fOnFileClassTClass * fOnFileClassOn file class.Definition TGenCollectionProxy.h:322; TGenCollectionProxy::fResizeSizing_t fResizeContainer accessors: resize container.Definition TGenCollectionProxy.h:303; TGenCollectionProxy::fConstructArrIterfunc_t fConstructContainer accessors: block construct.Definition TGenCollectionProxy.h:306; TGenCollectionProxy::Atvoid * At(UInt_t idx) overrideReturn the address of the value at index 'idx'.Definition TGenCollectionProxy.cxx:1064; TGenCollectionProxy::GetFunctionDeleteTwoIteratorsDeleteTwoIterators_t GetFunctionDeleteTwoIterators(Bool_t read=kTRUE) overrideSee typedef void (*DeleteTwoIterators_t)(void *begin, void *end); If the sizeof iterator is greater t...Definition TGenCollectionProxy.cxx:1722; TGenCollectionProxy::fConversionReadMemberWisestd::map< std::string, TObjArray * > * fConversionReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read) derived from another class.Definition TGenCollectionProxy.h:292; TGenCollectionProxy::CheckFunctionsvoid CheckFunctions() constCheck existence of function pointers.Definition TGenCollectionProxy.cxx:793;",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:82692,Security,access,accessors,82692,"tionProxy::fDestructSizing_t fDestructContainer accessors: block destruct.Definition TGenCollectionProxy.h:307; TGenCollectionProxy::fCreateEnvMethod0 fCreateEnvMethod to allocate an Environment holder.Definition TGenCollectionProxy.h:310; TGenCollectionProxy::fValValue * fValDescriptor of the Value_type.Definition TGenCollectionProxy.h:312; TGenCollectionProxy::GetFunctionNextNext_t GetFunctionNext(Bool_t read=kTRUE) overrideSee typedef void* (*Next_t)(void *iter, void *end); iter and end should be pointer to respectively an...Definition TGenCollectionProxy.cxx:1670; TGenCollectionProxy::operator()virtual void operator()(TBuffer &refBuffer, void *pObject)TClassStreamer IO overload.Definition TGenCollectionProxy.cxx:1448; TGenCollectionProxy::fOnFileClassTClass * fOnFileClassOn file class.Definition TGenCollectionProxy.h:322; TGenCollectionProxy::fResizeSizing_t fResizeContainer accessors: resize container.Definition TGenCollectionProxy.h:303; TGenCollectionProxy::fConstructArrIterfunc_t fConstructContainer accessors: block construct.Definition TGenCollectionProxy.h:306; TGenCollectionProxy::Atvoid * At(UInt_t idx) overrideReturn the address of the value at index 'idx'.Definition TGenCollectionProxy.cxx:1064; TGenCollectionProxy::GetFunctionDeleteTwoIteratorsDeleteTwoIterators_t GetFunctionDeleteTwoIterators(Bool_t read=kTRUE) overrideSee typedef void (*DeleteTwoIterators_t)(void *begin, void *end); If the sizeof iterator is greater t...Definition TGenCollectionProxy.cxx:1722; TGenCollectionProxy::fConversionReadMemberWisestd::map< std::string, TObjArray * > * fConversionReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read) derived from another class.Definition TGenCollectionProxy.h:292; TGenCollectionProxy::CheckFunctionsvoid CheckFunctions() constCheck existence of function pointers.Definition TGenCollectionProxy.cxx:793; TGenCollectionProxy::GenerateTVirtualCollectionProxy * Generate() const overrideVirtual copy constructor.Definition TGenColl",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:85358,Security,access,accessors,85358,"24; TGenCollectionProxy::GetConversionReadMemberWiseActionsTStreamerInfoActions::TActionSequence * GetConversionReadMemberWiseActions(TClass *oldClass, Int_t version) overrideReturn the set of action necessary to stream in this collection member-wise coming from the old value...Definition TGenCollectionProxy.cxx:1747; TGenCollectionProxy::fReadMemberWiseTObjArray * fReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read)Definition TGenCollectionProxy.h:291; TGenCollectionProxy::DeleteItemvirtual void DeleteItem(Bool_t force, void *ptr) constCall to delete/destruct individual item.Definition TGenCollectionProxy.cxx:1350; TGenCollectionProxy::GetCollectionClassTClass * GetCollectionClass() const overrideReturn a pointer to the TClass representing the container.Definition TGenCollectionProxy.cxx:985; TGenCollectionProxy::fStagedStaged_t fStagedOptimization: Keep staged array once they were created.Definition TGenCollectionProxy.h:319; TGenCollectionProxy::fSizeMethod fSizeContainer accessors: size of container.Definition TGenCollectionProxy.h:302; TGenCollectionProxy::fClearMethod fClearMethod cache for container accessors: clear container.Definition TGenCollectionProxy.h:301; TGenCollectionProxy::fFeedFeedfunc_t fFeedContainer accessors: block feed.Definition TGenCollectionProxy.h:308; TGenCollectionProxy::GetFunctionCreateIteratorsCreateIterators_t GetFunctionCreateIterators(Bool_t read=kTRUE) overrideSee typedef void (*CreateIterators_t)(void *collection, void *&begin_arena, void *&end_arena); begin_...Definition TGenCollectionProxy.cxx:1607; TGenCollectionProxy::fValDiffint fValDiffOffset between two consecutive value_types (memory layout).Definition TGenCollectionProxy.h:316; TGenCollectionProxy::ReadBuffervirtual void ReadBuffer(TBuffer &b, void *obj)Definition TGenCollectionProxy.cxx:1419; TGenCollectionProxy::fProxyKeptProxies_t fProxyKeptOptimization: Keep proxies once they were created.Definition TGenCollectionProxy.h:318; TGenCollectionPro",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:85492,Security,access,accessors,85492,"iseActions(TClass *oldClass, Int_t version) overrideReturn the set of action necessary to stream in this collection member-wise coming from the old value...Definition TGenCollectionProxy.cxx:1747; TGenCollectionProxy::fReadMemberWiseTObjArray * fReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read)Definition TGenCollectionProxy.h:291; TGenCollectionProxy::DeleteItemvirtual void DeleteItem(Bool_t force, void *ptr) constCall to delete/destruct individual item.Definition TGenCollectionProxy.cxx:1350; TGenCollectionProxy::GetCollectionClassTClass * GetCollectionClass() const overrideReturn a pointer to the TClass representing the container.Definition TGenCollectionProxy.cxx:985; TGenCollectionProxy::fStagedStaged_t fStagedOptimization: Keep staged array once they were created.Definition TGenCollectionProxy.h:319; TGenCollectionProxy::fSizeMethod fSizeContainer accessors: size of container.Definition TGenCollectionProxy.h:302; TGenCollectionProxy::fClearMethod fClearMethod cache for container accessors: clear container.Definition TGenCollectionProxy.h:301; TGenCollectionProxy::fFeedFeedfunc_t fFeedContainer accessors: block feed.Definition TGenCollectionProxy.h:308; TGenCollectionProxy::GetFunctionCreateIteratorsCreateIterators_t GetFunctionCreateIterators(Bool_t read=kTRUE) overrideSee typedef void (*CreateIterators_t)(void *collection, void *&begin_arena, void *&end_arena); begin_...Definition TGenCollectionProxy.cxx:1607; TGenCollectionProxy::fValDiffint fValDiffOffset between two consecutive value_types (memory layout).Definition TGenCollectionProxy.h:316; TGenCollectionProxy::ReadBuffervirtual void ReadBuffer(TBuffer &b, void *obj)Definition TGenCollectionProxy.cxx:1419; TGenCollectionProxy::fProxyKeptProxies_t fProxyKeptOptimization: Keep proxies once they were created.Definition TGenCollectionProxy.h:318; TGenCollectionProxy::SizeofUInt_t Sizeof() const overrideReturn the sizeof the collection object.Definition TGenCollectionProxy.cxx:1014; TGe",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:85609,Security,access,accessors,85609,"-wise coming from the old value...Definition TGenCollectionProxy.cxx:1747; TGenCollectionProxy::fReadMemberWiseTObjArray * fReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read)Definition TGenCollectionProxy.h:291; TGenCollectionProxy::DeleteItemvirtual void DeleteItem(Bool_t force, void *ptr) constCall to delete/destruct individual item.Definition TGenCollectionProxy.cxx:1350; TGenCollectionProxy::GetCollectionClassTClass * GetCollectionClass() const overrideReturn a pointer to the TClass representing the container.Definition TGenCollectionProxy.cxx:985; TGenCollectionProxy::fStagedStaged_t fStagedOptimization: Keep staged array once they were created.Definition TGenCollectionProxy.h:319; TGenCollectionProxy::fSizeMethod fSizeContainer accessors: size of container.Definition TGenCollectionProxy.h:302; TGenCollectionProxy::fClearMethod fClearMethod cache for container accessors: clear container.Definition TGenCollectionProxy.h:301; TGenCollectionProxy::fFeedFeedfunc_t fFeedContainer accessors: block feed.Definition TGenCollectionProxy.h:308; TGenCollectionProxy::GetFunctionCreateIteratorsCreateIterators_t GetFunctionCreateIterators(Bool_t read=kTRUE) overrideSee typedef void (*CreateIterators_t)(void *collection, void *&begin_arena, void *&end_arena); begin_...Definition TGenCollectionProxy.cxx:1607; TGenCollectionProxy::fValDiffint fValDiffOffset between two consecutive value_types (memory layout).Definition TGenCollectionProxy.h:316; TGenCollectionProxy::ReadBuffervirtual void ReadBuffer(TBuffer &b, void *obj)Definition TGenCollectionProxy.cxx:1419; TGenCollectionProxy::fProxyKeptProxies_t fProxyKeptOptimization: Keep proxies once they were created.Definition TGenCollectionProxy.h:318; TGenCollectionProxy::SizeofUInt_t Sizeof() const overrideReturn the sizeof the collection object.Definition TGenCollectionProxy.cxx:1014; TGenCollectionProxy::Info_tconst std::type_info & Info_tDefinition TGenCollectionProxy.h:41; TGenListProxyDefinition TGenColl",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:89132,Security,hash,hash,89132,"enVectorBoolProxyTGenVectorBoolProxy(const TGenCollectionProxy &c)Definition TGenCollectionProxy.cxx:92; TGenVectorBoolProxy::~TGenVectorBoolProxy~TGenVectorBoolProxy() overrideDefinition TGenCollectionProxy.cxx:96; TGenVectorBoolProxy::DeleteItemvoid DeleteItem(Bool_t force, void *ptr) const overrideCall to delete/destruct individual item.Definition TGenCollectionProxy.cxx:115; TGenVectorProxyLocal optimization class.Definition TGenCollectionProxy.cxx:39; TGenVectorProxy::DeleteItemvoid DeleteItem(Bool_t force, void *ptr) const overrideCall to delete/destruct individual item.Definition TGenCollectionProxy.cxx:66; TGenVectorProxy::Atvoid * At(UInt_t idx) overrideReturn the address of the value at index 'idx'.Definition TGenCollectionProxy.cxx:50; TGenVectorProxy::~TGenVectorProxy~TGenVectorProxy() overrideDefinition TGenCollectionProxy.cxx:46; TGenVectorProxy::TGenVectorProxyTGenVectorProxy(const TGenCollectionProxy &c)Definition TGenCollectionProxy.cxx:42; THashTableTHashTable implements a hash table to store TObject's.Definition THashTable.h:35; TInterpreter::SuspendAutoParsingDefinition TInterpreter.h:111; TInterpreter::TypeInfo_Initvirtual void TypeInfo_Init(TypeInfo_t *, const char *) constDefinition TInterpreter.h:528; TInterpreter::TypeInfo_Deletevirtual void TypeInfo_Delete(TypeInfo_t *) constDefinition TInterpreter.h:524; TInterpreter::TypeInfo_Factoryvirtual TypeInfo_t * TypeInfo_Factory() constDefinition TInterpreter.h:525; TInterpreter::TypeInfo_Propertyvirtual Long_t TypeInfo_Property(TypeInfo_t *) constDefinition TInterpreter.h:531; TInterpreter::TypeInfo_Sizevirtual int TypeInfo_Size(TypeInfo_t *) constDefinition TInterpreter.h:533; TInterpreter::TypeInfo_IsValidvirtual Bool_t TypeInfo_IsValid(TypeInfo_t *) constDefinition TInterpreter.h:529; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjArray::Clearvoid Clear(Option_t *option="""") override",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:11348,Testability,assert,assert,11348,"4 fSize = sizeof(void*);; 355 } else {; 356 fSize = sizeof(std::string);; 357 }; 358 }; 359 else {; 360 // In the case where we have an emulated class,; 361 // if the class is nested (in a class or a namespace),; 362 // calling G__TypeInfo ti(inside.c_str());; 363 // might fail because CINT does not known the nesting; 364 // scope, so let's first look for an emulated class:; 365 ; 366 fType = TClass::GetClass(intype.c_str(),kTRUE,silent, hint_pair_offset, hint_pair_size);; 367 ; 368 if (fType) {; 369 if (isPointer) {; 370 fCase |= kIsPointer;; 371 fSize = sizeof(void*);; 372 if (fType == TString::Class()) {; 373 fCase |= kBIT_ISTSTRING;; 374 }; 375 }; 376 fCase |= kIsClass;; 377 fCtor = fType->GetNew();; 378 fDtor = fType->GetDestructor();; 379 fDelete = fType->GetDelete();; 380 } else {; 381 R__LOCKGUARD(gInterpreterMutex);; 382 ; 383 // Try to avoid autoparsing.; 384 ; 385 THashTable *typeTable = dynamic_cast<THashTable*>( gROOT->GetListOfTypes() );; 386 assert(typeTable && ""The type of the list of type has changed"");; 387 ; 388 TDataType *fundType = (TDataType *)typeTable->THashTable::FindObject( intype.c_str() );; 389 if (fundType && fundType->GetType() < 0x17 && fundType->GetType() > 0) {; 390 fKind = (EDataType)fundType->GetType();; 391 // R__ASSERT((fKind>0 && fKind<0x17) || (fKind==-1&&(prop&kIsPointer)) );; 392 ; 393 fCase |= kIsFundamental;; 394 if (isPointer) {; 395 fCase |= kIsPointer;; 396 fSize = sizeof(void*);; 397 } else {; 398 fSize = fundType->Size();; 399 }; 400 } else if (TEnum::GetEnum( intype.c_str(), TEnum::kNone) ) {; 401 // This is a known enum.; 402 fCase = kIsEnum;; 403 fSize = sizeof(Int_t);; 404 fKind = kInt_t;; 405 if (isPointer) {; 406 fCase |= kIsPointer;; 407 fSize = sizeof(void*);; 408 }; 409 } else {; 410 // This fallback solution should be hardly used ...; 411 // One of the common use case is to 'discover' that this is a; 412 // collection for the content of which we do not have a dictionary; 413 // which can happen at least in th",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:16499,Usability,clear,clear,16499,"1Bool_t TGenCollectionProxy::Value::IsValid(); 512{; 513 ; 514 ; 515 return fSize != std::string::npos;; 516}; 517 ; 518void TGenCollectionProxy::Value::DeleteItem(void* ptr); 519{; 520 // Delete an item.; 521 ; 522 if ( ptr && fCase&kIsPointer ) {; 523 if ( fDelete ) {; 524 (*fDelete)(ptr);; 525 }; 526 else if ( fType ) {; 527 fType->Destructor(ptr);; 528 }; 529 else {; 530 ::operator delete(ptr);; 531 }; 532 }; 533}; 534 ; 535/**; 536 \class TGenCollectionProxy TGenCollectionProxy.cxx; 537 \ingroup IO; 538 ; 539 Proxy around an arbitrary container, which implements basic; 540 functionality and iteration.; 541 ; 542 The purpose of this implementation; 543 is to shield any generated dictionary implementation from the; 544 underlying streamer/proxy implementation and only expose; 545 the creation functions.; 546 ; 547 In particular this is used to implement splitting and abstract; 548 element access of any container. Access to compiled code is necessary; 549 to implement the abstract iteration sequence and functionality like; 550 size(), clear(), resize(). resize() may be a void operation.; 551*/; 552 ; 553////////////////////////////////////////////////////////////////////////////////; 554/// Build a proxy for an emulated container.; 555 ; 556TGenCollectionProxy::TGenCollectionProxy(const TGenCollectionProxy& copy); 557 : TVirtualCollectionProxy(copy.fClass),; 558 fTypeinfo(copy.fTypeinfo); 559{; 560 fEnv = 0;; 561 fName = copy.fName;; 562 fPointers = copy.fPointers;; 563 fSTL_type = copy.fSTL_type;; 564 fSize.call = copy.fSize.call;; 565 fNext.call = copy.fNext.call;; 566 fFirst.call = copy.fFirst.call;; 567 fClear.call = copy.fClear.call;; 568 fResize = copy.fResize;; 569 fDestruct = copy.fDestruct;; 570 fConstruct = copy.fConstruct;; 571 fFeed = copy.fFeed;; 572 fCollect = copy.fCollect;; 573 fCreateEnv.call = copy.fCreateEnv.call;; 574 fValOffset = copy.fValOffset;; 575 fValDiff = copy.fValDiff;; 576 fValue = copy.fValue.load(std::memory_order_relaxed) ? new Val",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:21137,Usability,clear,clearVector,21137,"4 fCollect = info.fCollectFunc;; 655 fCreateEnv.call = info.fCreateEnv;; 656 ; 657 if (cl) {; 658 fName = cl->GetName();; 659 }; 660 CheckFunctions();; 661 ; 662 fValue = 0;; 663 fKey = 0;; 664 fVal = 0;; 665 fPointers = false;; 666 fSTL_type = ROOT::kNotSTL;; 667 ; 668 Env_t e;; 669 if ( info.fIterSize > sizeof(e.fIterator) ) {; 670 Fatal(""TGenCollectionProxy"",; 671 ""%s %s are too large:%ld bytes. Maximum is:%ld bytes"",; 672 ""Iterators for collection"",; 673 fClass->GetName(),; 674 (Long_t)info.fIterSize,; 675 (Long_t)sizeof(e.fIterator));; 676 }; 677 fReadMemberWise = new TObjArray(TCollection::kInitCapacity,-1);; 678 fConversionReadMemberWise = 0;; 679 fWriteMemberWise = 0;; 680 fFunctionCreateIterators = info.fCreateIterators;; 681 fFunctionCopyIterator = info.fCopyIterator;; 682 fFunctionNextIterator = info.fNext;; 683 fFunctionDeleteIterator = info.fDeleteSingleIterator;; 684 fFunctionDeleteTwoIterators = info.fDeleteTwoIterators;; 685}; 686 ; 687namespace {; 688 template <class vec>; 689 void clearVector(vec& v); 690 {; 691 // Clear out the proxies.; 692 ; 693 for(typename vec::iterator i=v.begin(); i != v.end(); ++i) {; 694 typename vec::value_type e = *i;; 695 if ( e ) {; 696 delete e;; 697 }; 698 }; 699 v.clear();; 700 }; 701}; 702////////////////////////////////////////////////////////////////////////////////; 703/// Standard destructor; 704 ; 705TGenCollectionProxy::~TGenCollectionProxy(); 706{; 707 clearVector(fProxyList);; 708 clearVector(fProxyKept);; 709 clearVector(fStaged);; 710 ; 711 if ( fValue.load() ) delete fValue.load();; 712 if ( fVal ) delete fVal;; 713 if ( fKey ) delete fKey;; 714 ; 715 delete fReadMemberWise;; 716 if (fConversionReadMemberWise) {; 717 std::map<std::string, TObjArray*>::iterator it;; 718 std::map<std::string, TObjArray*>::iterator end = fConversionReadMemberWise->end();; 719 for( it = fConversionReadMemberWise->begin(); it != end; ++it ) {; 720 delete it->second;; 721 }; 722 delete fConversionReadMemberWise;; 723 fConversi",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:21357,Usability,clear,clear,21357,"arge:%ld bytes. Maximum is:%ld bytes"",; 672 ""Iterators for collection"",; 673 fClass->GetName(),; 674 (Long_t)info.fIterSize,; 675 (Long_t)sizeof(e.fIterator));; 676 }; 677 fReadMemberWise = new TObjArray(TCollection::kInitCapacity,-1);; 678 fConversionReadMemberWise = 0;; 679 fWriteMemberWise = 0;; 680 fFunctionCreateIterators = info.fCreateIterators;; 681 fFunctionCopyIterator = info.fCopyIterator;; 682 fFunctionNextIterator = info.fNext;; 683 fFunctionDeleteIterator = info.fDeleteSingleIterator;; 684 fFunctionDeleteTwoIterators = info.fDeleteTwoIterators;; 685}; 686 ; 687namespace {; 688 template <class vec>; 689 void clearVector(vec& v); 690 {; 691 // Clear out the proxies.; 692 ; 693 for(typename vec::iterator i=v.begin(); i != v.end(); ++i) {; 694 typename vec::value_type e = *i;; 695 if ( e ) {; 696 delete e;; 697 }; 698 }; 699 v.clear();; 700 }; 701}; 702////////////////////////////////////////////////////////////////////////////////; 703/// Standard destructor; 704 ; 705TGenCollectionProxy::~TGenCollectionProxy(); 706{; 707 clearVector(fProxyList);; 708 clearVector(fProxyKept);; 709 clearVector(fStaged);; 710 ; 711 if ( fValue.load() ) delete fValue.load();; 712 if ( fVal ) delete fVal;; 713 if ( fKey ) delete fKey;; 714 ; 715 delete fReadMemberWise;; 716 if (fConversionReadMemberWise) {; 717 std::map<std::string, TObjArray*>::iterator it;; 718 std::map<std::string, TObjArray*>::iterator end = fConversionReadMemberWise->end();; 719 for( it = fConversionReadMemberWise->begin(); it != end; ++it ) {; 720 delete it->second;; 721 }; 722 delete fConversionReadMemberWise;; 723 fConversionReadMemberWise = 0;; 724 }; 725 delete fWriteMemberWise;; 726}; 727 ; 728////////////////////////////////////////////////////////////////////////////////; 729/// Virtual copy constructor; 730 ; 731TVirtualCollectionProxy* TGenCollectionProxy::Generate() const; 732{; 733 if ( !fValue.load(std::memory_order_relaxed) ) Initialize(kFALSE);; 734 ; 735 if( fPointers ); 736 return new TGen",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:21557,Usability,clear,clearVector,21557,"arge:%ld bytes. Maximum is:%ld bytes"",; 672 ""Iterators for collection"",; 673 fClass->GetName(),; 674 (Long_t)info.fIterSize,; 675 (Long_t)sizeof(e.fIterator));; 676 }; 677 fReadMemberWise = new TObjArray(TCollection::kInitCapacity,-1);; 678 fConversionReadMemberWise = 0;; 679 fWriteMemberWise = 0;; 680 fFunctionCreateIterators = info.fCreateIterators;; 681 fFunctionCopyIterator = info.fCopyIterator;; 682 fFunctionNextIterator = info.fNext;; 683 fFunctionDeleteIterator = info.fDeleteSingleIterator;; 684 fFunctionDeleteTwoIterators = info.fDeleteTwoIterators;; 685}; 686 ; 687namespace {; 688 template <class vec>; 689 void clearVector(vec& v); 690 {; 691 // Clear out the proxies.; 692 ; 693 for(typename vec::iterator i=v.begin(); i != v.end(); ++i) {; 694 typename vec::value_type e = *i;; 695 if ( e ) {; 696 delete e;; 697 }; 698 }; 699 v.clear();; 700 }; 701}; 702////////////////////////////////////////////////////////////////////////////////; 703/// Standard destructor; 704 ; 705TGenCollectionProxy::~TGenCollectionProxy(); 706{; 707 clearVector(fProxyList);; 708 clearVector(fProxyKept);; 709 clearVector(fStaged);; 710 ; 711 if ( fValue.load() ) delete fValue.load();; 712 if ( fVal ) delete fVal;; 713 if ( fKey ) delete fKey;; 714 ; 715 delete fReadMemberWise;; 716 if (fConversionReadMemberWise) {; 717 std::map<std::string, TObjArray*>::iterator it;; 718 std::map<std::string, TObjArray*>::iterator end = fConversionReadMemberWise->end();; 719 for( it = fConversionReadMemberWise->begin(); it != end; ++it ) {; 720 delete it->second;; 721 }; 722 delete fConversionReadMemberWise;; 723 fConversionReadMemberWise = 0;; 724 }; 725 delete fWriteMemberWise;; 726}; 727 ; 728////////////////////////////////////////////////////////////////////////////////; 729/// Virtual copy constructor; 730 ; 731TVirtualCollectionProxy* TGenCollectionProxy::Generate() const; 732{; 733 if ( !fValue.load(std::memory_order_relaxed) ) Initialize(kFALSE);; 734 ; 735 if( fPointers ); 736 return new TGen",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:21587,Usability,clear,clearVector,21587,"arge:%ld bytes. Maximum is:%ld bytes"",; 672 ""Iterators for collection"",; 673 fClass->GetName(),; 674 (Long_t)info.fIterSize,; 675 (Long_t)sizeof(e.fIterator));; 676 }; 677 fReadMemberWise = new TObjArray(TCollection::kInitCapacity,-1);; 678 fConversionReadMemberWise = 0;; 679 fWriteMemberWise = 0;; 680 fFunctionCreateIterators = info.fCreateIterators;; 681 fFunctionCopyIterator = info.fCopyIterator;; 682 fFunctionNextIterator = info.fNext;; 683 fFunctionDeleteIterator = info.fDeleteSingleIterator;; 684 fFunctionDeleteTwoIterators = info.fDeleteTwoIterators;; 685}; 686 ; 687namespace {; 688 template <class vec>; 689 void clearVector(vec& v); 690 {; 691 // Clear out the proxies.; 692 ; 693 for(typename vec::iterator i=v.begin(); i != v.end(); ++i) {; 694 typename vec::value_type e = *i;; 695 if ( e ) {; 696 delete e;; 697 }; 698 }; 699 v.clear();; 700 }; 701}; 702////////////////////////////////////////////////////////////////////////////////; 703/// Standard destructor; 704 ; 705TGenCollectionProxy::~TGenCollectionProxy(); 706{; 707 clearVector(fProxyList);; 708 clearVector(fProxyKept);; 709 clearVector(fStaged);; 710 ; 711 if ( fValue.load() ) delete fValue.load();; 712 if ( fVal ) delete fVal;; 713 if ( fKey ) delete fKey;; 714 ; 715 delete fReadMemberWise;; 716 if (fConversionReadMemberWise) {; 717 std::map<std::string, TObjArray*>::iterator it;; 718 std::map<std::string, TObjArray*>::iterator end = fConversionReadMemberWise->end();; 719 for( it = fConversionReadMemberWise->begin(); it != end; ++it ) {; 720 delete it->second;; 721 }; 722 delete fConversionReadMemberWise;; 723 fConversionReadMemberWise = 0;; 724 }; 725 delete fWriteMemberWise;; 726}; 727 ; 728////////////////////////////////////////////////////////////////////////////////; 729/// Virtual copy constructor; 730 ; 731TVirtualCollectionProxy* TGenCollectionProxy::Generate() const; 732{; 733 if ( !fValue.load(std::memory_order_relaxed) ) Initialize(kFALSE);; 734 ; 735 if( fPointers ); 736 return new TGen",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:21617,Usability,clear,clearVector,21617,"arge:%ld bytes. Maximum is:%ld bytes"",; 672 ""Iterators for collection"",; 673 fClass->GetName(),; 674 (Long_t)info.fIterSize,; 675 (Long_t)sizeof(e.fIterator));; 676 }; 677 fReadMemberWise = new TObjArray(TCollection::kInitCapacity,-1);; 678 fConversionReadMemberWise = 0;; 679 fWriteMemberWise = 0;; 680 fFunctionCreateIterators = info.fCreateIterators;; 681 fFunctionCopyIterator = info.fCopyIterator;; 682 fFunctionNextIterator = info.fNext;; 683 fFunctionDeleteIterator = info.fDeleteSingleIterator;; 684 fFunctionDeleteTwoIterators = info.fDeleteTwoIterators;; 685}; 686 ; 687namespace {; 688 template <class vec>; 689 void clearVector(vec& v); 690 {; 691 // Clear out the proxies.; 692 ; 693 for(typename vec::iterator i=v.begin(); i != v.end(); ++i) {; 694 typename vec::value_type e = *i;; 695 if ( e ) {; 696 delete e;; 697 }; 698 }; 699 v.clear();; 700 }; 701}; 702////////////////////////////////////////////////////////////////////////////////; 703/// Standard destructor; 704 ; 705TGenCollectionProxy::~TGenCollectionProxy(); 706{; 707 clearVector(fProxyList);; 708 clearVector(fProxyKept);; 709 clearVector(fStaged);; 710 ; 711 if ( fValue.load() ) delete fValue.load();; 712 if ( fVal ) delete fVal;; 713 if ( fKey ) delete fKey;; 714 ; 715 delete fReadMemberWise;; 716 if (fConversionReadMemberWise) {; 717 std::map<std::string, TObjArray*>::iterator it;; 718 std::map<std::string, TObjArray*>::iterator end = fConversionReadMemberWise->end();; 719 for( it = fConversionReadMemberWise->begin(); it != end; ++it ) {; 720 delete it->second;; 721 }; 722 delete fConversionReadMemberWise;; 723 fConversionReadMemberWise = 0;; 724 }; 725 delete fWriteMemberWise;; 726}; 727 ; 728////////////////////////////////////////////////////////////////////////////////; 729/// Virtual copy constructor; 730 ; 731TVirtualCollectionProxy* TGenCollectionProxy::Generate() const; 732{; 733 if ( !fValue.load(std::memory_order_relaxed) ) Initialize(kFALSE);; 734 ; 735 if( fPointers ); 736 return new TGen",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:24073,Usability,clear,clear,24073,";; 757 case ROOT::kSTLset:; 758 case ROOT::kSTLunorderedset:; 759 case ROOT::kSTLmultiset:; 760 case ROOT::kSTLunorderedmultiset:; 761 return new TGenSetProxy(*this);; 762 default:; 763 return new TGenCollectionProxy(*this);; 764 }; 765}; 766 ; 767////////////////////////////////////////////////////////////////////////////////; 768/// Proxy initializer; 769 ; 770TGenCollectionProxy *TGenCollectionProxy::Initialize(Bool_t silent) const; 771{; 772 TGenCollectionProxy* p = const_cast<TGenCollectionProxy*>(this);; 773 if ( fValue.load() ) return p;; 774 return p->InitializeEx(silent);; 775}; 776 ; 777////////////////////////////////////////////////////////////////////////////////; 778/// Reset the info gathered from StreamerInfos and value's TClass.; 779Bool_t TGenCollectionProxy::Reset(); 780{; 781 if (fReadMemberWise); 782 fReadMemberWise->Clear();; 783 delete fWriteMemberWise;; 784 fWriteMemberWise = nullptr;; 785 if (fConversionReadMemberWise); 786 fConversionReadMemberWise->clear();; 787 return kTRUE;; 788}; 789 ; 790////////////////////////////////////////////////////////////////////////////////; 791/// Check existence of function pointers; 792 ; 793void TGenCollectionProxy::CheckFunctions() const; 794{; 795 if ( 0 == fSize.call ) {; 796 Fatal(""TGenCollectionProxy"",""No 'size' function pointer for class %s present."",fName.c_str());; 797 }; 798 if ( 0 == fResize ) {; 799 Fatal(""TGenCollectionProxy"",""No 'resize' function for class %s present."",fName.c_str());; 800 }; 801 if ( 0 == fNext.call ) {; 802 Fatal(""TGenCollectionProxy"",""No 'next' function for class %s present."",fName.c_str());; 803 }; 804 if ( 0 == fFirst.call ) {; 805 Fatal(""TGenCollectionProxy"",""No 'begin' function for class %s present."",fName.c_str());; 806 }; 807 if ( 0 == fClear.call ) {; 808 Fatal(""TGenCollectionProxy"",""No 'clear' function for class %s present."",fName.c_str());; 809 }; 810 if ( 0 == fConstruct ) {; 811 Fatal(""TGenCollectionProxy"",""No 'block constructor' function for class %s present."",f",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:24902,Usability,clear,clear,24902,"adMemberWise); 782 fReadMemberWise->Clear();; 783 delete fWriteMemberWise;; 784 fWriteMemberWise = nullptr;; 785 if (fConversionReadMemberWise); 786 fConversionReadMemberWise->clear();; 787 return kTRUE;; 788}; 789 ; 790////////////////////////////////////////////////////////////////////////////////; 791/// Check existence of function pointers; 792 ; 793void TGenCollectionProxy::CheckFunctions() const; 794{; 795 if ( 0 == fSize.call ) {; 796 Fatal(""TGenCollectionProxy"",""No 'size' function pointer for class %s present."",fName.c_str());; 797 }; 798 if ( 0 == fResize ) {; 799 Fatal(""TGenCollectionProxy"",""No 'resize' function for class %s present."",fName.c_str());; 800 }; 801 if ( 0 == fNext.call ) {; 802 Fatal(""TGenCollectionProxy"",""No 'next' function for class %s present."",fName.c_str());; 803 }; 804 if ( 0 == fFirst.call ) {; 805 Fatal(""TGenCollectionProxy"",""No 'begin' function for class %s present."",fName.c_str());; 806 }; 807 if ( 0 == fClear.call ) {; 808 Fatal(""TGenCollectionProxy"",""No 'clear' function for class %s present."",fName.c_str());; 809 }; 810 if ( 0 == fConstruct ) {; 811 Fatal(""TGenCollectionProxy"",""No 'block constructor' function for class %s present."",fName.c_str());; 812 }; 813 if ( 0 == fDestruct ) {; 814 Fatal(""TGenCollectionProxy"",""No 'block destructor' function for class %s present."",fName.c_str());; 815 }; 816 if ( 0 == fFeed ) {; 817 Fatal(""TGenCollectionProxy"",""No 'data feed' function for class %s present."",fName.c_str());; 818 }; 819 if ( 0 == fCollect ) {; 820 Fatal(""TGenCollectionProxy"",""No 'data collect' function for class %s present."",fName.c_str());; 821 }; 822 if (0 == fCreateEnv.call ) {; 823 Fatal(""TGenCollectionProxy"",""No 'environment creation' function for class %s present."",fName.c_str());; 824 }; 825}; 826 ; 827////////////////////////////////////////////////////////////////////////////////; 828/// Utility routine to issue a Fatal error is the Value object is not valid; 829 ; 830static TGenCollectionProxy::Value *R__CreateValue(c",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:34199,Usability,simpl,simple,34199,"FALSE);; 1027 ; 1028 // The content of a map and multimap is always a 'pair' and hence; 1029 // fPointers means ""Flag to indicate if containee has pointers (key or value)""; 1030 // so we need to ignore its value for map and multimap;; 1031 return fPointers && !(fSTL_type == ROOT::kSTLmap || fSTL_type == ROOT::kSTLmultimap ||; 1032 fSTL_type == ROOT::kSTLunorderedmap || fSTL_type == ROOT::kSTLunorderedmultimap);; 1033}; 1034 ; 1035////////////////////////////////////////////////////////////////////////////////; 1036/// Return a pointer to the TClass representing the content.; 1037 ; 1038TClass *TGenCollectionProxy::GetValueClass() const; 1039{; 1040 auto value = fValue.load(std::memory_order_relaxed);; 1041 if (!value) {; 1042 Initialize(kFALSE);; 1043 value = fValue.load(std::memory_order_relaxed);; 1044 }; 1045 return value ? (*value).fType.GetClass() : 0;; 1046}; 1047 ; 1048////////////////////////////////////////////////////////////////////////////////; 1049/// If the content is a simple numerical value, return its type (see TDataType); 1050 ; 1051EDataType TGenCollectionProxy::GetType() const; 1052{; 1053 auto value = fValue.load(std::memory_order_relaxed);; 1054 if (!value) {; 1055 Initialize(kFALSE);; 1056 value = fValue.load(std::memory_order_relaxed);; 1057 }; 1058 return value ? (*value).fKind : kNoType_t;; 1059}; 1060 ; 1061////////////////////////////////////////////////////////////////////////////////; 1062/// Return the address of the value at index 'idx'; 1063 ; 1064void* TGenCollectionProxy::At(UInt_t idx); 1065{; 1066 if ( fEnv && fEnv->fObject ) {; 1067 switch (fSTL_type) {; 1068 case ROOT::kSTLvector:; 1069 if ((*fValue).fKind == kBool_t) {; 1070 auto vec = (std::vector<bool> *)(fEnv->fObject);; 1071 fEnv->fLastValueVecBool = (*vec)[idx];; 1072 fEnv->fIdx = idx;; 1073 return &(fEnv->fLastValueVecBool);; 1074 }; 1075 // intentional fall through; 1076 case ROOT::kROOTRVec:; 1077 fEnv->fIdx = idx;; 1078 switch( idx ) {; 1079 case 0:; 1080 return fEnv->",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:79204,Usability,simpl,simple,79204,"s * GetValueClass() const overrideReturn a pointer to the TClass representing the content.Definition TGenCollectionProxy.cxx:1038; TGenCollectionProxy::fEnvEnvironBase_t * fEnvAddress of the currently proxied object.Definition TGenCollectionProxy.h:314; TGenCollectionProxy::kBIT_ISSTRING@ kBIT_ISSTRINGDefinition TGenCollectionProxy.h:47; TGenCollectionProxy::kBIT_ISTSTRING@ kBIT_ISTSTRINGDefinition TGenCollectionProxy.h:48; TGenCollectionProxy::fFunctionDeleteIteratorDeleteIterator_t fFunctionDeleteIteratorDefinition TGenCollectionProxy.h:327; TGenCollectionProxy::fCollectCollectfunc_t fCollectMethod to collect objects from container.Definition TGenCollectionProxy.h:309; TGenCollectionProxy::PushProxyvoid PushProxy(void *objstart) overrideAdd an object.Definition TGenCollectionProxy.cxx:1299; TGenCollectionProxy::PopProxyvoid PopProxy() overrideRemove the last object.Definition TGenCollectionProxy.cxx:1334; TGenCollectionProxy::GetTypeEDataType GetType() const overrideIf the content is a simple numerical value, return its type (see TDataType)Definition TGenCollectionProxy.cxx:1051; TGenCollectionProxy::InitializeTGenCollectionProxy * Initialize(Bool_t silent) constProxy initializer.Definition TGenCollectionProxy.cxx:770; TGenCollectionProxy::InitializeExvirtual TGenCollectionProxy * InitializeEx(Bool_t silent)Proxy initializer.Definition TGenCollectionProxy.cxx:843; TGenCollectionProxy::Commitvoid Commit(void *env) overrideCommit the change.Definition TGenCollectionProxy.cxx:1277; TGenCollectionProxy::fNamestd::string fNameName of the class being proxied.Definition TGenCollectionProxy.h:299; TGenCollectionProxy::GetFunctionCopyIteratorCopyIterator_t GetFunctionCopyIterator(Bool_t read=kTRUE) overrideSee typedef void (*CopyIterator_t)(void *&dest, const void *source); Copy the iterator source,...Definition TGenCollectionProxy.cxx:1642; TGenCollectionProxy::fSTL_typeint fSTL_typeSTL container type.Definition TGenCollectionProxy.h:320; TGenCollectionProxy::fFunctionCop",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:85503,Usability,clear,clear,85503,"iseActions(TClass *oldClass, Int_t version) overrideReturn the set of action necessary to stream in this collection member-wise coming from the old value...Definition TGenCollectionProxy.cxx:1747; TGenCollectionProxy::fReadMemberWiseTObjArray * fReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read)Definition TGenCollectionProxy.h:291; TGenCollectionProxy::DeleteItemvirtual void DeleteItem(Bool_t force, void *ptr) constCall to delete/destruct individual item.Definition TGenCollectionProxy.cxx:1350; TGenCollectionProxy::GetCollectionClassTClass * GetCollectionClass() const overrideReturn a pointer to the TClass representing the container.Definition TGenCollectionProxy.cxx:985; TGenCollectionProxy::fStagedStaged_t fStagedOptimization: Keep staged array once they were created.Definition TGenCollectionProxy.h:319; TGenCollectionProxy::fSizeMethod fSizeContainer accessors: size of container.Definition TGenCollectionProxy.h:302; TGenCollectionProxy::fClearMethod fClearMethod cache for container accessors: clear container.Definition TGenCollectionProxy.h:301; TGenCollectionProxy::fFeedFeedfunc_t fFeedContainer accessors: block feed.Definition TGenCollectionProxy.h:308; TGenCollectionProxy::GetFunctionCreateIteratorsCreateIterators_t GetFunctionCreateIterators(Bool_t read=kTRUE) overrideSee typedef void (*CreateIterators_t)(void *collection, void *&begin_arena, void *&end_arena); begin_...Definition TGenCollectionProxy.cxx:1607; TGenCollectionProxy::fValDiffint fValDiffOffset between two consecutive value_types (memory layout).Definition TGenCollectionProxy.h:316; TGenCollectionProxy::ReadBuffervirtual void ReadBuffer(TBuffer &b, void *obj)Definition TGenCollectionProxy.cxx:1419; TGenCollectionProxy::fProxyKeptProxies_t fProxyKeptOptimization: Keep proxies once they were created.Definition TGenCollectionProxy.h:318; TGenCollectionProxy::SizeofUInt_t Sizeof() const overrideReturn the sizeof the collection object.Definition TGenCollectionProxy.cxx:1014; TGe",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
https://root.cern/doc/master/TGeoArb8_8h_source.html:2222,Safety,safe,safe,2222,"8 &) = delete;; 32 ; 33 void CopyTwist(Double_t *twist = nullptr);; 34 ; 35public:; 36 // constructors; 37 TGeoArb8();; 38 TGeoArb8(Double_t dz, Double_t *vertices = nullptr);; 39 TGeoArb8(const char *name, Double_t dz, Double_t *vertices = nullptr);; 40 // destructor; 41 ~TGeoArb8() override;; 42 // methods; 43 Double_t Capacity() const override;; 44 void ComputeBBox() override;; 45 void ComputeNormal(const Double_t *point, const Double_t *dir, Double_t *norm) override;; 46 void ComputeNormal_v(const Double_t *points, const Double_t *dirs, Double_t *norms, Int_t vecsize) override;; 47 void ComputeTwist();; 48 Bool_t Contains(const Double_t *point) const override;; 49 void Contains_v(const Double_t *points, Bool_t *inside, Int_t vecsize) const override;; 50 Double_t DistToPlane(const Double_t *point, const Double_t *dir, Int_t ipl, Bool_t in) const;; 51 Double_t DistFromInside(const Double_t *point, const Double_t *dir, Int_t iact = 1, Double_t step = TGeoShape::Big(),; 52 Double_t *safe = nullptr) const override;; 53 void DistFromInside_v(const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize,; 54 Double_t *step) const override;; 55 Double_t DistFromOutside(const Double_t *point, const Double_t *dir, Int_t iact = 1,; 56 Double_t step = TGeoShape::Big(), Double_t *safe = nullptr) const override;; 57 void DistFromOutside_v(const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize,; 58 Double_t *step) const override;; 59 TGeoVolume *; 60 Divide(TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override;; 61 Double_t GetAxisRange(Int_t iaxis, Double_t &xlo, Double_t &xhi) const override;; 62 void GetBoundingCylinder(Double_t *param) const override;; 63 Int_t GetByteCount() const override { return 100; }; 64 Double_t GetClosestEdge(const Double_t *point, Double_t *vert, Int_t &isegment) const;; 65 Bool_t GetPointsOnFacet(Int_t /*index*/, Int_t /*npoints*/, Double_t * /*array*/) const ",MatchSource.WIKI,doc/master/TGeoArb8_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoArb8_8h_source.html
https://root.cern/doc/master/TGeoArb8_8h_source.html:2531,Safety,safe,safe,2531,"; 43 Double_t Capacity() const override;; 44 void ComputeBBox() override;; 45 void ComputeNormal(const Double_t *point, const Double_t *dir, Double_t *norm) override;; 46 void ComputeNormal_v(const Double_t *points, const Double_t *dirs, Double_t *norms, Int_t vecsize) override;; 47 void ComputeTwist();; 48 Bool_t Contains(const Double_t *point) const override;; 49 void Contains_v(const Double_t *points, Bool_t *inside, Int_t vecsize) const override;; 50 Double_t DistToPlane(const Double_t *point, const Double_t *dir, Int_t ipl, Bool_t in) const;; 51 Double_t DistFromInside(const Double_t *point, const Double_t *dir, Int_t iact = 1, Double_t step = TGeoShape::Big(),; 52 Double_t *safe = nullptr) const override;; 53 void DistFromInside_v(const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize,; 54 Double_t *step) const override;; 55 Double_t DistFromOutside(const Double_t *point, const Double_t *dir, Int_t iact = 1,; 56 Double_t step = TGeoShape::Big(), Double_t *safe = nullptr) const override;; 57 void DistFromOutside_v(const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize,; 58 Double_t *step) const override;; 59 TGeoVolume *; 60 Divide(TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override;; 61 Double_t GetAxisRange(Int_t iaxis, Double_t &xlo, Double_t &xhi) const override;; 62 void GetBoundingCylinder(Double_t *param) const override;; 63 Int_t GetByteCount() const override { return 100; }; 64 Double_t GetClosestEdge(const Double_t *point, Double_t *vert, Int_t &isegment) const;; 65 Bool_t GetPointsOnFacet(Int_t /*index*/, Int_t /*npoints*/, Double_t * /*array*/) const override;; 66 Double_t GetDz() const { return fDz; }; 67 Int_t; 68 GetFittingBox(const TGeoBBox *parambox, TGeoMatrix *mat, Double_t &dx, Double_t &dy, Double_t &dz) const override;; 69 TGeoShape *GetMakeRuntimeShape(TGeoShape * /*mother*/, TGeoMatrix * /*mat*/) const override { return nullptr; }; 70 static ",MatchSource.WIKI,doc/master/TGeoArb8_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoArb8_8h_source.html
https://root.cern/doc/master/TGeoArb8_8h_source.html:4357,Safety,safe,safe,4357,,MatchSource.WIKI,doc/master/TGeoArb8_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoArb8_8h_source.html
https://root.cern/doc/master/TGeoArb8_8h_source.html:6250,Safety,safe,safe,6250,"t fAlpha1; // angle between centers of x edges an y axis at low z; 105 Double_t fH2; // half length in y at high z; 106 Double_t fBl2; // half length in x at high z and y low edge; 107 Double_t fTl2; // half length in x at high z and y high edge; 108 Double_t fAlpha2; // angle between centers of x edges an y axis at low z; 109 ; 110public:; 111 // constructors; 112 TGeoTrap();; 113 TGeoTrap(Double_t dz, Double_t theta, Double_t phi);; 114 TGeoTrap(Double_t dz, Double_t theta, Double_t phi, Double_t h1, Double_t bl1, Double_t tl1, Double_t alpha1,; 115 Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2);; 116 TGeoTrap(const char *name, Double_t dz, Double_t theta, Double_t phi, Double_t h1, Double_t bl1, Double_t tl1,; 117 Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2);; 118 // destructor; 119 ~TGeoTrap() override;; 120 Double_t DistFromInside(const Double_t *point, const Double_t *dir, Int_t iact = 1, Double_t step = TGeoShape::Big(),; 121 Double_t *safe = nullptr) const override;; 122 void DistFromInside_v(const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize,; 123 Double_t *step) const override;; 124 Double_t DistFromOutside(const Double_t *point, const Double_t *dir, Int_t iact = 1,; 125 Double_t step = TGeoShape::Big(), Double_t *safe = nullptr) const override;; 126 void DistFromOutside_v(const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize,; 127 Double_t *step) const override;; 128 TGeoVolume *; 129 Divide(TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override;; 130 Double_t GetTheta() const { return fTheta; }; 131 Double_t GetPhi() const { return fPhi; }; 132 Double_t GetH1() const { return fH1; }; 133 Double_t GetBl1() const { return fBl1; }; 134 Double_t GetTl1() const { return fTl1; }; 135 Double_t GetAlpha1() const { return fAlpha1; }; 136 Double_t GetH2() const { return fH2; }; 137 Double_t GetBl2() const { return fBl2; }; 138",MatchSource.WIKI,doc/master/TGeoArb8_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoArb8_8h_source.html
https://root.cern/doc/master/TGeoArb8_8h_source.html:6563,Safety,safe,safe,6563,"s at low z; 109 ; 110public:; 111 // constructors; 112 TGeoTrap();; 113 TGeoTrap(Double_t dz, Double_t theta, Double_t phi);; 114 TGeoTrap(Double_t dz, Double_t theta, Double_t phi, Double_t h1, Double_t bl1, Double_t tl1, Double_t alpha1,; 115 Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2);; 116 TGeoTrap(const char *name, Double_t dz, Double_t theta, Double_t phi, Double_t h1, Double_t bl1, Double_t tl1,; 117 Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2);; 118 // destructor; 119 ~TGeoTrap() override;; 120 Double_t DistFromInside(const Double_t *point, const Double_t *dir, Int_t iact = 1, Double_t step = TGeoShape::Big(),; 121 Double_t *safe = nullptr) const override;; 122 void DistFromInside_v(const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize,; 123 Double_t *step) const override;; 124 Double_t DistFromOutside(const Double_t *point, const Double_t *dir, Int_t iact = 1,; 125 Double_t step = TGeoShape::Big(), Double_t *safe = nullptr) const override;; 126 void DistFromOutside_v(const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize,; 127 Double_t *step) const override;; 128 TGeoVolume *; 129 Divide(TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override;; 130 Double_t GetTheta() const { return fTheta; }; 131 Double_t GetPhi() const { return fPhi; }; 132 Double_t GetH1() const { return fH1; }; 133 Double_t GetBl1() const { return fBl1; }; 134 Double_t GetTl1() const { return fTl1; }; 135 Double_t GetAlpha1() const { return fAlpha1; }; 136 Double_t GetH2() const { return fH2; }; 137 Double_t GetBl2() const { return fBl2; }; 138 Double_t GetTl2() const { return fTl2; }; 139 Double_t GetAlpha2() const { return fAlpha2; }; 140 TGeoShape *GetMakeRuntimeShape(TGeoShape *mother, TGeoMatrix *mat) const override;; 141 void SetDimensions(Double_t *param) override;; 142 Double_t Safety(const Double_t *point, Bool_t in = kTRUE) const override;; ",MatchSource.WIKI,doc/master/TGeoArb8_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoArb8_8h_source.html
https://root.cern/doc/master/TGeoArb8_8h_source.html:7640,Safety,safe,safe,7640,"nts, const Double_t *dirs, Double_t *dists, Int_t vecsize,; 127 Double_t *step) const override;; 128 TGeoVolume *; 129 Divide(TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override;; 130 Double_t GetTheta() const { return fTheta; }; 131 Double_t GetPhi() const { return fPhi; }; 132 Double_t GetH1() const { return fH1; }; 133 Double_t GetBl1() const { return fBl1; }; 134 Double_t GetTl1() const { return fTl1; }; 135 Double_t GetAlpha1() const { return fAlpha1; }; 136 Double_t GetH2() const { return fH2; }; 137 Double_t GetBl2() const { return fBl2; }; 138 Double_t GetTl2() const { return fTl2; }; 139 Double_t GetAlpha2() const { return fAlpha2; }; 140 TGeoShape *GetMakeRuntimeShape(TGeoShape *mother, TGeoMatrix *mat) const override;; 141 void SetDimensions(Double_t *param) override;; 142 Double_t Safety(const Double_t *point, Bool_t in = kTRUE) const override;; 143 void Safety_v(const Double_t *points, const Bool_t *inside, Double_t *safe, Int_t vecsize) const override;; 144 void SavePrimitive(std::ostream &out, Option_t *option = """") override;; 145 ; 146 ClassDefOverride(TGeoTrap, 1) // G3 TRAP shape; 147};; 148 ; 149class TGeoGtra : public TGeoTrap {; 150protected:; 151 // data members; 152 Double_t fTwistAngle; // twist angle in degrees; 153public:; 154 // constructors; 155 TGeoGtra();; 156 TGeoGtra(Double_t dz, Double_t theta, Double_t phi, Double_t twist, Double_t h1, Double_t bl1, Double_t tl1,; 157 Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2);; 158 TGeoGtra(const char *name, Double_t dz, Double_t theta, Double_t phi, Double_t twist, Double_t h1, Double_t bl1,; 159 Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2);; 160 // destructor; 161 ~TGeoGtra() override;; 162 Double_t DistFromInside(const Double_t *point, const Double_t *dir, Int_t iact = 1, Double_t step = TGeoShape::Big(),; 163 Double_t *safe = nullptr) const override;; 164 void DistFro",MatchSource.WIKI,doc/master/TGeoArb8_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoArb8_8h_source.html
https://root.cern/doc/master/TGeoArb8_8h_source.html:8594,Safety,safe,safe,8594,"_t *points, const Bool_t *inside, Double_t *safe, Int_t vecsize) const override;; 144 void SavePrimitive(std::ostream &out, Option_t *option = """") override;; 145 ; 146 ClassDefOverride(TGeoTrap, 1) // G3 TRAP shape; 147};; 148 ; 149class TGeoGtra : public TGeoTrap {; 150protected:; 151 // data members; 152 Double_t fTwistAngle; // twist angle in degrees; 153public:; 154 // constructors; 155 TGeoGtra();; 156 TGeoGtra(Double_t dz, Double_t theta, Double_t phi, Double_t twist, Double_t h1, Double_t bl1, Double_t tl1,; 157 Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2);; 158 TGeoGtra(const char *name, Double_t dz, Double_t theta, Double_t phi, Double_t twist, Double_t h1, Double_t bl1,; 159 Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2);; 160 // destructor; 161 ~TGeoGtra() override;; 162 Double_t DistFromInside(const Double_t *point, const Double_t *dir, Int_t iact = 1, Double_t step = TGeoShape::Big(),; 163 Double_t *safe = nullptr) const override;; 164 void DistFromInside_v(const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize,; 165 Double_t *step) const override;; 166 Double_t DistFromOutside(const Double_t *point, const Double_t *dir, Int_t iact = 1,; 167 Double_t step = TGeoShape::Big(), Double_t *safe = nullptr) const override;; 168 void DistFromOutside_v(const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize,; 169 Double_t *step) const override;; 170 TGeoShape *GetMakeRuntimeShape(TGeoShape *mother, TGeoMatrix *mat) const override;; 171 Double_t GetTwistAngle() const { return fTwistAngle; }; 172 Double_t Safety(const Double_t *point, Bool_t in = kTRUE) const override;; 173 void Safety_v(const Double_t *points, const Bool_t *inside, Double_t *safe, Int_t vecsize) const override;; 174 void SetDimensions(Double_t *param) override;; 175 void SavePrimitive(std::ostream &out, Option_t *option = """") override;; 176 ; 177 ClassDefOverride(TGeoGtra, 1) // G3 GT",MatchSource.WIKI,doc/master/TGeoArb8_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoArb8_8h_source.html
https://root.cern/doc/master/TGeoArb8_8h_source.html:8907,Safety,safe,safe,8907," override;; 144 void SavePrimitive(std::ostream &out, Option_t *option = """") override;; 145 ; 146 ClassDefOverride(TGeoTrap, 1) // G3 TRAP shape; 147};; 148 ; 149class TGeoGtra : public TGeoTrap {; 150protected:; 151 // data members; 152 Double_t fTwistAngle; // twist angle in degrees; 153public:; 154 // constructors; 155 TGeoGtra();; 156 TGeoGtra(Double_t dz, Double_t theta, Double_t phi, Double_t twist, Double_t h1, Double_t bl1, Double_t tl1,; 157 Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2);; 158 TGeoGtra(const char *name, Double_t dz, Double_t theta, Double_t phi, Double_t twist, Double_t h1, Double_t bl1,; 159 Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2);; 160 // destructor; 161 ~TGeoGtra() override;; 162 Double_t DistFromInside(const Double_t *point, const Double_t *dir, Int_t iact = 1, Double_t step = TGeoShape::Big(),; 163 Double_t *safe = nullptr) const override;; 164 void DistFromInside_v(const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize,; 165 Double_t *step) const override;; 166 Double_t DistFromOutside(const Double_t *point, const Double_t *dir, Int_t iact = 1,; 167 Double_t step = TGeoShape::Big(), Double_t *safe = nullptr) const override;; 168 void DistFromOutside_v(const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize,; 169 Double_t *step) const override;; 170 TGeoShape *GetMakeRuntimeShape(TGeoShape *mother, TGeoMatrix *mat) const override;; 171 Double_t GetTwistAngle() const { return fTwistAngle; }; 172 Double_t Safety(const Double_t *point, Bool_t in = kTRUE) const override;; 173 void Safety_v(const Double_t *points, const Bool_t *inside, Double_t *safe, Int_t vecsize) const override;; 174 void SetDimensions(Double_t *param) override;; 175 void SavePrimitive(std::ostream &out, Option_t *option = """") override;; 176 ; 177 ClassDefOverride(TGeoGtra, 1) // G3 GTRA shape; 178};; 179 ; 180#endif; Int_tint Int_tDefinition RtypesCore.",MatchSource.WIKI,doc/master/TGeoArb8_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoArb8_8h_source.html
https://root.cern/doc/master/TGeoArb8_8h_source.html:9384,Safety,safe,safe,9384," override;; 144 void SavePrimitive(std::ostream &out, Option_t *option = """") override;; 145 ; 146 ClassDefOverride(TGeoTrap, 1) // G3 TRAP shape; 147};; 148 ; 149class TGeoGtra : public TGeoTrap {; 150protected:; 151 // data members; 152 Double_t fTwistAngle; // twist angle in degrees; 153public:; 154 // constructors; 155 TGeoGtra();; 156 TGeoGtra(Double_t dz, Double_t theta, Double_t phi, Double_t twist, Double_t h1, Double_t bl1, Double_t tl1,; 157 Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2);; 158 TGeoGtra(const char *name, Double_t dz, Double_t theta, Double_t phi, Double_t twist, Double_t h1, Double_t bl1,; 159 Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2);; 160 // destructor; 161 ~TGeoGtra() override;; 162 Double_t DistFromInside(const Double_t *point, const Double_t *dir, Int_t iact = 1, Double_t step = TGeoShape::Big(),; 163 Double_t *safe = nullptr) const override;; 164 void DistFromInside_v(const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize,; 165 Double_t *step) const override;; 166 Double_t DistFromOutside(const Double_t *point, const Double_t *dir, Int_t iact = 1,; 167 Double_t step = TGeoShape::Big(), Double_t *safe = nullptr) const override;; 168 void DistFromOutside_v(const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize,; 169 Double_t *step) const override;; 170 TGeoShape *GetMakeRuntimeShape(TGeoShape *mother, TGeoMatrix *mat) const override;; 171 Double_t GetTwistAngle() const { return fTwistAngle; }; 172 Double_t Safety(const Double_t *point, Bool_t in = kTRUE) const override;; 173 void Safety_v(const Double_t *points, const Bool_t *inside, Double_t *safe, Int_t vecsize) const override;; 174 void SetDimensions(Double_t *param) override;; 175 void SavePrimitive(std::ostream &out, Option_t *option = """") override;; 176 ; 177 ClassDefOverride(TGeoGtra, 1) // G3 GTRA shape; 178};; 179 ; 180#endif; Int_tint Int_tDefinition RtypesCore.",MatchSource.WIKI,doc/master/TGeoArb8_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoArb8_8h_source.html
https://root.cern/doc/master/TGeoArb8_8h_source.html:10474,Safety,safe,safe,10474,"vePrimitive(std::ostream &out, Option_t *option = """") override;; 176 ; 177 ClassDefOverride(TGeoGtra, 1) // G3 GTRA shape; 178};; 179 ; 180#endif; Int_tint Int_tDefinition RtypesCore.h:45; Float_tfloat Float_tDefinition RtypesCore.h:57; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; Option_tconst char Option_tDefinition RtypesCore.h:66; BIT#define BIT(n)Definition Rtypes.h:90; ClassDefOverride#define ClassDefOverride(name, id)Definition Rtypes.h:346; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; pointsOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t pointsDefinition TGWin32VirtualXProxy.cxx:148; namechar name[80]Definition TGX11.cxx:110; TGeoBBox.h; TGeoArb8Definition TGeoArb8.h:17; TGeoArb8::Safety_vvoid Safety_v(const Double_t *points, const Bool_t *inside, Double_t *safe, Int_t vecsize) const override; TGeoArb8::GetByteCountInt_t GetByteCount() const overrideDefinition TGeoArb8.h:63; TGeoArb8::DistFromOutside_vvoid DistFromOutside_v(const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override; TGeoArb8::GetDzDouble_t GetDz() constDefinition TGeoArb8.h:66; TGeoArb8::GetClosestEdgeDouble_t GetClosestEdge(const Double_t *point, Double_t *vert, Int_t &isegment) const; TGeoArb8::fXYDouble_t fXY[8][2][4] tangents of twist anglesDefinition TGeoArb8.h:28; TGeoArb8::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave a primitive as a C++ statement(s) on output stream ""out"".; TGeoArb8::SetPointsvoid SetPoints(Double_t *points) const override; TGeoArb8::ComputeNormalvoid ComputeNormal(const Double_t *point, const Double_t *dir, Double_t *norm) override; TGeoArb8::TGeoArb8TGeoArb8(const char *name, Double_t dz, Double_t *vertices=nullptr); TGeoArb8::SetVertexvirtual void SetVertex(Int_t vn",MatchSource.WIKI,doc/master/TGeoArb8_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoArb8_8h_source.html
https://root.cern/doc/master/TGeoArb8_8h_source.html:13380,Safety,safe,safe,13380," const; TGeoArb8::InsidePolygonstatic Bool_t InsidePolygon(Double_t x, Double_t y, Double_t *pts); TGeoArb8::DivideTGeoVolume * Divide(TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override; TGeoArb8::fDzDouble_t fDzDefinition TGeoArb8.h:26; TGeoArb8::operator=TGeoArb8 & operator=(const TGeoArb8 &)=delete; TGeoArb8::GetBoundingCylindervoid GetBoundingCylinder(Double_t *param) const override; TGeoArb8::EGeoArb8TypeEGeoArb8TypeDefinition TGeoArb8.h:19; TGeoArb8::kArb8Trap@ kArb8TrapDefinition TGeoArb8.h:22; TGeoArb8::kArb8Tra@ kArb8TraDefinition TGeoArb8.h:23; TGeoArb8::fTwistDouble_t * fTwistDefinition TGeoArb8.h:27; TGeoArb8::GetAxisRangeDouble_t GetAxisRange(Int_t iaxis, Double_t &xlo, Double_t &xhi) const override; TGeoArb8::GetPlaneNormalstatic void GetPlaneNormal(Double_t *p1, Double_t *p2, Double_t *p3, Double_t *norm); TGeoArb8::CapacityDouble_t Capacity() const override; TGeoArb8::SafetyToFaceDouble_t SafetyToFace(const Double_t *point, Int_t iseg, Bool_t in) const; TGeoArb8::Sizeof3Dvoid Sizeof3D() const override; TGeoArb8::DistFromOutsideDouble_t DistFromOutside(const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override; TGeoArb8::IsTwistedBool_t IsTwisted() constDefinition TGeoArb8.h:80; TGeoArb8::GetVerticesDouble_t * GetVertices()Definition TGeoArb8.h:71; TGeoArb8::Contains_vvoid Contains_v(const Double_t *points, Bool_t *inside, Int_t vecsize) const override; TGeoArb8::InspectShapevoid InspectShape() const override; TGeoArb8::SafetyDouble_t Safety(const Double_t *point, Bool_t in=kTRUE) const override; TGeoArb8::TGeoArb8TGeoArb8(); TGeoArb8::GetTwistDouble_t GetTwist(Int_t iseg) const; TGeoArb8::TGeoArb8TGeoArb8(Double_t dz, Double_t *vertices=nullptr); TGeoArb8::DistFromInsideDouble_t DistFromInside(const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override; TGeoArb",MatchSource.WIKI,doc/master/TGeoArb8_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoArb8_8h_source.html
https://root.cern/doc/master/TGeoArb8_8h_source.html:14105,Safety,safe,safe,14105,"laneNormal(Double_t *p1, Double_t *p2, Double_t *p3, Double_t *norm); TGeoArb8::CapacityDouble_t Capacity() const override; TGeoArb8::SafetyToFaceDouble_t SafetyToFace(const Double_t *point, Int_t iseg, Bool_t in) const; TGeoArb8::Sizeof3Dvoid Sizeof3D() const override; TGeoArb8::DistFromOutsideDouble_t DistFromOutside(const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override; TGeoArb8::IsTwistedBool_t IsTwisted() constDefinition TGeoArb8.h:80; TGeoArb8::GetVerticesDouble_t * GetVertices()Definition TGeoArb8.h:71; TGeoArb8::Contains_vvoid Contains_v(const Double_t *points, Bool_t *inside, Int_t vecsize) const override; TGeoArb8::InspectShapevoid InspectShape() const override; TGeoArb8::SafetyDouble_t Safety(const Double_t *point, Bool_t in=kTRUE) const override; TGeoArb8::TGeoArb8TGeoArb8(); TGeoArb8::GetTwistDouble_t GetTwist(Int_t iseg) const; TGeoArb8::TGeoArb8TGeoArb8(Double_t dz, Double_t *vertices=nullptr); TGeoArb8::DistFromInsideDouble_t DistFromInside(const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override; TGeoArb8::ComputeNormal_vvoid ComputeNormal_v(const Double_t *points, const Double_t *dirs, Double_t *norms, Int_t vecsize) override; TGeoArb8::IsSamePointstatic Bool_t IsSamePoint(const Double_t *p1, const Double_t *p2)Definition TGeoArb8.h:74; TGeoArb8::~TGeoArb8~TGeoArb8() override; TGeoArb8::IsCylTypeBool_t IsCylType() const overrideDefinition TGeoArb8.h:73; TGeoArb8::GetMakeRuntimeShapeTGeoShape * GetMakeRuntimeShape(TGeoShape *, TGeoMatrix *) const overrideDefinition TGeoArb8.h:69; TGeoArb8::DistFromInside_vvoid DistFromInside_v(const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override; TGeoArb8::SetPlaneVerticesvoid SetPlaneVertices(Double_t zpl, Double_t *vertices) const; TGeoArb8::ComputeBBoxvoid ComputeBBox() override; TGeoArb8::GetFittingBoxInt_t GetFit",MatchSource.WIKI,doc/master/TGeoArb8_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoArb8_8h_source.html
https://root.cern/doc/master/TGeoArb8_8h_source.html:15355,Safety,safe,safe,15355,"ntstatic Bool_t IsSamePoint(const Double_t *p1, const Double_t *p2)Definition TGeoArb8.h:74; TGeoArb8::~TGeoArb8~TGeoArb8() override; TGeoArb8::IsCylTypeBool_t IsCylType() const overrideDefinition TGeoArb8.h:73; TGeoArb8::GetMakeRuntimeShapeTGeoShape * GetMakeRuntimeShape(TGeoShape *, TGeoMatrix *) const overrideDefinition TGeoArb8.h:69; TGeoArb8::DistFromInside_vvoid DistFromInside_v(const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override; TGeoArb8::SetPlaneVerticesvoid SetPlaneVertices(Double_t zpl, Double_t *vertices) const; TGeoArb8::ComputeBBoxvoid ComputeBBox() override; TGeoArb8::GetFittingBoxInt_t GetFittingBox(const TGeoBBox *parambox, TGeoMatrix *mat, Double_t &dx, Double_t &dy, Double_t &dz) const override; TGeoBBoxDefinition TGeoBBox.h:17; TGeoGtraDefinition TGeoArb8.h:149; TGeoGtra::SetDimensionsvoid SetDimensions(Double_t *param) override; TGeoGtra::DistFromInsideDouble_t DistFromInside(const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override; TGeoGtra::fTwistAngleDouble_t fTwistAngleDefinition TGeoArb8.h:152; TGeoGtra::TGeoGtraTGeoGtra(Double_t dz, Double_t theta, Double_t phi, Double_t twist, Double_t h1, Double_t bl1, Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2); TGeoGtra::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave a primitive as a C++ statement(s) on output stream ""out"".; TGeoGtra::DistFromInside_vvoid DistFromInside_v(const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override; TGeoGtra::TGeoGtraTGeoGtra(); TGeoGtra::TGeoGtraTGeoGtra(const char *name, Double_t dz, Double_t theta, Double_t phi, Double_t twist, Double_t h1, Double_t bl1, Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2); TGeoGtra::GetMakeRuntimeShapeTGeoShape * GetMakeRuntimeShape(TGeoShape",MatchSource.WIKI,doc/master/TGeoArb8_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoArb8_8h_source.html
https://root.cern/doc/master/TGeoArb8_8h_source.html:16588,Safety,safe,safe,16588,"ption="""") overrideSave a primitive as a C++ statement(s) on output stream ""out"".; TGeoGtra::DistFromInside_vvoid DistFromInside_v(const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override; TGeoGtra::TGeoGtraTGeoGtra(); TGeoGtra::TGeoGtraTGeoGtra(const char *name, Double_t dz, Double_t theta, Double_t phi, Double_t twist, Double_t h1, Double_t bl1, Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2); TGeoGtra::GetMakeRuntimeShapeTGeoShape * GetMakeRuntimeShape(TGeoShape *mother, TGeoMatrix *mat) const override; TGeoGtra::GetTwistAngleDouble_t GetTwistAngle() constDefinition TGeoArb8.h:171; TGeoGtra::SafetyDouble_t Safety(const Double_t *point, Bool_t in=kTRUE) const override; TGeoGtra::Safety_vvoid Safety_v(const Double_t *points, const Bool_t *inside, Double_t *safe, Int_t vecsize) const override; TGeoGtra::DistFromOutside_vvoid DistFromOutside_v(const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override; TGeoGtra::DistFromOutsideDouble_t DistFromOutside(const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override; TGeoGtra::~TGeoGtra~TGeoGtra() override; TGeoMatrixGeometrical transformation package.Definition TGeoMatrix.h:38; TGeoShapeBase abstract class for all shapes.Definition TGeoShape.h:25; TGeoShape::Bigstatic Double_t Big()Definition TGeoShape.h:87; TGeoTrapDefinition TGeoArb8.h:96; TGeoTrap::~TGeoTrap~TGeoTrap() override; TGeoTrap::TGeoTrapTGeoTrap(const char *name, Double_t dz, Double_t theta, Double_t phi, Double_t h1, Double_t bl1, Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2); TGeoTrap::fTl2Double_t fTl2Definition TGeoArb8.h:107; TGeoTrap::GetTl1Double_t GetTl1() constDefinition TGeoArb8.h:134; TGeoTrap::GetPhiDouble_t GetPhi() constDefinition TGeoArb8.h:131; TGeoTrap::fBl2Double_t fBl2Definition TGeoArb8.h:1",MatchSource.WIKI,doc/master/TGeoArb8_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoArb8_8h_source.html
https://root.cern/doc/master/TGeoArb8_8h_source.html:16935,Safety,safe,safe,16935,"ption="""") overrideSave a primitive as a C++ statement(s) on output stream ""out"".; TGeoGtra::DistFromInside_vvoid DistFromInside_v(const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override; TGeoGtra::TGeoGtraTGeoGtra(); TGeoGtra::TGeoGtraTGeoGtra(const char *name, Double_t dz, Double_t theta, Double_t phi, Double_t twist, Double_t h1, Double_t bl1, Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2); TGeoGtra::GetMakeRuntimeShapeTGeoShape * GetMakeRuntimeShape(TGeoShape *mother, TGeoMatrix *mat) const override; TGeoGtra::GetTwistAngleDouble_t GetTwistAngle() constDefinition TGeoArb8.h:171; TGeoGtra::SafetyDouble_t Safety(const Double_t *point, Bool_t in=kTRUE) const override; TGeoGtra::Safety_vvoid Safety_v(const Double_t *points, const Bool_t *inside, Double_t *safe, Int_t vecsize) const override; TGeoGtra::DistFromOutside_vvoid DistFromOutside_v(const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override; TGeoGtra::DistFromOutsideDouble_t DistFromOutside(const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override; TGeoGtra::~TGeoGtra~TGeoGtra() override; TGeoMatrixGeometrical transformation package.Definition TGeoMatrix.h:38; TGeoShapeBase abstract class for all shapes.Definition TGeoShape.h:25; TGeoShape::Bigstatic Double_t Big()Definition TGeoShape.h:87; TGeoTrapDefinition TGeoArb8.h:96; TGeoTrap::~TGeoTrap~TGeoTrap() override; TGeoTrap::TGeoTrapTGeoTrap(const char *name, Double_t dz, Double_t theta, Double_t phi, Double_t h1, Double_t bl1, Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2); TGeoTrap::fTl2Double_t fTl2Definition TGeoArb8.h:107; TGeoTrap::GetTl1Double_t GetTl1() constDefinition TGeoArb8.h:134; TGeoTrap::GetPhiDouble_t GetPhi() constDefinition TGeoArb8.h:131; TGeoTrap::fBl2Double_t fBl2Definition TGeoArb8.h:1",MatchSource.WIKI,doc/master/TGeoArb8_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoArb8_8h_source.html
https://root.cern/doc/master/TGeoArb8_8h_source.html:18009,Safety,safe,safe,18009,"sformation package.Definition TGeoMatrix.h:38; TGeoShapeBase abstract class for all shapes.Definition TGeoShape.h:25; TGeoShape::Bigstatic Double_t Big()Definition TGeoShape.h:87; TGeoTrapDefinition TGeoArb8.h:96; TGeoTrap::~TGeoTrap~TGeoTrap() override; TGeoTrap::TGeoTrapTGeoTrap(const char *name, Double_t dz, Double_t theta, Double_t phi, Double_t h1, Double_t bl1, Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2); TGeoTrap::fTl2Double_t fTl2Definition TGeoArb8.h:107; TGeoTrap::GetTl1Double_t GetTl1() constDefinition TGeoArb8.h:134; TGeoTrap::GetPhiDouble_t GetPhi() constDefinition TGeoArb8.h:131; TGeoTrap::fBl2Double_t fBl2Definition TGeoArb8.h:106; TGeoTrap::fAlpha2Double_t fAlpha2Definition TGeoArb8.h:108; TGeoTrap::SetDimensionsvoid SetDimensions(Double_t *param) override; TGeoTrap::DistFromInsideDouble_t DistFromInside(const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override; TGeoTrap::SafetyDouble_t Safety(const Double_t *point, Bool_t in=kTRUE) const override; TGeoTrap::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave a primitive as a C++ statement(s) on output stream ""out"".; TGeoTrap::fBl1Double_t fBl1Definition TGeoArb8.h:102; TGeoTrap::DistFromInside_vvoid DistFromInside_v(const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override; TGeoTrap::fH1Double_t fH1Definition TGeoArb8.h:101; TGeoTrap::Safety_vvoid Safety_v(const Double_t *points, const Bool_t *inside, Double_t *safe, Int_t vecsize) const override; TGeoTrap::fPhiDouble_t fPhiDefinition TGeoArb8.h:100; TGeoTrap::GetAlpha2Double_t GetAlpha2() constDefinition TGeoArb8.h:139; TGeoTrap::GetThetaDouble_t GetTheta() constDefinition TGeoArb8.h:130; TGeoTrap::TGeoTrapTGeoTrap(); TGeoTrap::TGeoTrapTGeoTrap(Double_t dz, Double_t theta, Double_t phi); TGeoTrap::fTl1Double_t fTl1Definition TGeoArb8.h:103; TGeoTrap::f",MatchSource.WIKI,doc/master/TGeoArb8_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoArb8_8h_source.html
https://root.cern/doc/master/TGeoArb8_8h_source.html:18633,Safety,safe,safe,18633,"iDouble_t GetPhi() constDefinition TGeoArb8.h:131; TGeoTrap::fBl2Double_t fBl2Definition TGeoArb8.h:106; TGeoTrap::fAlpha2Double_t fAlpha2Definition TGeoArb8.h:108; TGeoTrap::SetDimensionsvoid SetDimensions(Double_t *param) override; TGeoTrap::DistFromInsideDouble_t DistFromInside(const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override; TGeoTrap::SafetyDouble_t Safety(const Double_t *point, Bool_t in=kTRUE) const override; TGeoTrap::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave a primitive as a C++ statement(s) on output stream ""out"".; TGeoTrap::fBl1Double_t fBl1Definition TGeoArb8.h:102; TGeoTrap::DistFromInside_vvoid DistFromInside_v(const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override; TGeoTrap::fH1Double_t fH1Definition TGeoArb8.h:101; TGeoTrap::Safety_vvoid Safety_v(const Double_t *points, const Bool_t *inside, Double_t *safe, Int_t vecsize) const override; TGeoTrap::fPhiDouble_t fPhiDefinition TGeoArb8.h:100; TGeoTrap::GetAlpha2Double_t GetAlpha2() constDefinition TGeoArb8.h:139; TGeoTrap::GetThetaDouble_t GetTheta() constDefinition TGeoArb8.h:130; TGeoTrap::TGeoTrapTGeoTrap(); TGeoTrap::TGeoTrapTGeoTrap(Double_t dz, Double_t theta, Double_t phi); TGeoTrap::fTl1Double_t fTl1Definition TGeoArb8.h:103; TGeoTrap::fH2Double_t fH2Definition TGeoArb8.h:105; TGeoTrap::GetAlpha1Double_t GetAlpha1() constDefinition TGeoArb8.h:135; TGeoTrap::DivideTGeoVolume * Divide(TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override; TGeoTrap::GetBl2Double_t GetBl2() constDefinition TGeoArb8.h:137; TGeoTrap::GetTl2Double_t GetTl2() constDefinition TGeoArb8.h:138; TGeoTrap::DistFromOutside_vvoid DistFromOutside_v(const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override; TGeoTrap::GetH1Double_t GetH1() constDefinition ",MatchSource.WIKI,doc/master/TGeoArb8_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoArb8_8h_source.html
https://root.cern/doc/master/TGeoArb8_8h_source.html:19964,Safety,safe,safe,19964," TGeoArb8.h:130; TGeoTrap::TGeoTrapTGeoTrap(); TGeoTrap::TGeoTrapTGeoTrap(Double_t dz, Double_t theta, Double_t phi); TGeoTrap::fTl1Double_t fTl1Definition TGeoArb8.h:103; TGeoTrap::fH2Double_t fH2Definition TGeoArb8.h:105; TGeoTrap::GetAlpha1Double_t GetAlpha1() constDefinition TGeoArb8.h:135; TGeoTrap::DivideTGeoVolume * Divide(TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override; TGeoTrap::GetBl2Double_t GetBl2() constDefinition TGeoArb8.h:137; TGeoTrap::GetTl2Double_t GetTl2() constDefinition TGeoArb8.h:138; TGeoTrap::DistFromOutside_vvoid DistFromOutside_v(const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override; TGeoTrap::GetH1Double_t GetH1() constDefinition TGeoArb8.h:132; TGeoTrap::fThetaDouble_t fThetaDefinition TGeoArb8.h:99; TGeoTrap::GetMakeRuntimeShapeTGeoShape * GetMakeRuntimeShape(TGeoShape *mother, TGeoMatrix *mat) const override; TGeoTrap::DistFromOutsideDouble_t DistFromOutside(const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override; TGeoTrap::fAlpha1Double_t fAlpha1Definition TGeoArb8.h:104; TGeoTrap::GetH2Double_t GetH2() constDefinition TGeoArb8.h:136; TGeoTrap::GetBl1Double_t GetBl1() constDefinition TGeoArb8.h:133; TGeoTrap::TGeoTrapTGeoTrap(Double_t dz, Double_t theta, Double_t phi, Double_t h1, Double_t bl1, Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2); TGeoVolumeTGeoVolume, TGeoVolumeMulti, TGeoVolumeAssembly are the volume classes.Definition TGeoVolume.h:43; bool; double; int; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; h1TH1F * h1Definition legend1.C:5; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123. geomgeomincTGeoArb8.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:13 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TGeoArb8_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoArb8_8h_source.html
https://root.cern/doc/master/TGeoElement_8cxx_source.html:29578,Availability,down,down,29578,";; 852 }; 853}; 854 ; 855////////////////////////////////////////////////////////////////////////////////; 856/// Destructor.; 857 ; 858TGeoElemIter::~TGeoElemIter(); 859{; 860 if (fBranch); 861 delete fBranch;; 862}; 863 ; 864////////////////////////////////////////////////////////////////////////////////; 865/// Assignment.; 866 ; 867TGeoElemIter &TGeoElemIter::operator=(const TGeoElemIter &iter); 868{; 869 if (&iter == this); 870 return *this;; 871 fTop = iter.fTop;; 872 fElem = iter.fElem;; 873 fLevel = iter.fLevel;; 874 if (iter.fBranch) {; 875 fBranch = new TObjArray(10);; 876 for (Int_t i = 0; i < fLevel; i++); 877 fBranch->Add(iter.fBranch->At(i));; 878 }; 879 fLimitRatio = iter.fLimitRatio;; 880 fRatio = iter.fRatio;; 881 return *this;; 882}; 883 ; 884////////////////////////////////////////////////////////////////////////////////; 885/// () operator.; 886 ; 887TGeoElementRN *TGeoElemIter::operator()(); 888{; 889 return Next();; 890}; 891 ; 892////////////////////////////////////////////////////////////////////////////////; 893/// Go upwards from the current location until the next branching, then down.; 894 ; 895TGeoElementRN *TGeoElemIter::Up(); 896{; 897 TGeoDecayChannel *dc;; 898 Int_t ind, nd;; 899 while (fLevel) {; 900 // Current decay channel; 901 dc = (TGeoDecayChannel *)fBranch->At(fLevel - 1);; 902 ind = dc->GetIndex();; 903 nd = dc->Parent()->GetNdecays();; 904 fRatio /= 0.01 * dc->BranchingRatio();; 905 fElem = dc->Parent();; 906 fBranch->RemoveAt(--fLevel);; 907 ind++;; 908 while (ind < nd) {; 909 if (Down(ind++)); 910 return (TGeoElementRN *)fElem;; 911 }; 912 }; 913 fElem = nullptr;; 914 return nullptr;; 915}; 916 ; 917////////////////////////////////////////////////////////////////////////////////; 918/// Go downwards from current level via ibranch as low in the tree as possible.; 919/// Return value flags if the operation was successful.; 920 ; 921TGeoElementRN *TGeoElemIter::Down(Int_t ibranch); 922{; 923 if (!fElem); 924 return nullptr;; 9",MatchSource.WIKI,doc/master/TGeoElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoElement_8cxx_source.html
https://root.cern/doc/master/TGeoElement_8cxx_source.html:30217,Availability,down,downwards,30217," 877 fBranch->Add(iter.fBranch->At(i));; 878 }; 879 fLimitRatio = iter.fLimitRatio;; 880 fRatio = iter.fRatio;; 881 return *this;; 882}; 883 ; 884////////////////////////////////////////////////////////////////////////////////; 885/// () operator.; 886 ; 887TGeoElementRN *TGeoElemIter::operator()(); 888{; 889 return Next();; 890}; 891 ; 892////////////////////////////////////////////////////////////////////////////////; 893/// Go upwards from the current location until the next branching, then down.; 894 ; 895TGeoElementRN *TGeoElemIter::Up(); 896{; 897 TGeoDecayChannel *dc;; 898 Int_t ind, nd;; 899 while (fLevel) {; 900 // Current decay channel; 901 dc = (TGeoDecayChannel *)fBranch->At(fLevel - 1);; 902 ind = dc->GetIndex();; 903 nd = dc->Parent()->GetNdecays();; 904 fRatio /= 0.01 * dc->BranchingRatio();; 905 fElem = dc->Parent();; 906 fBranch->RemoveAt(--fLevel);; 907 ind++;; 908 while (ind < nd) {; 909 if (Down(ind++)); 910 return (TGeoElementRN *)fElem;; 911 }; 912 }; 913 fElem = nullptr;; 914 return nullptr;; 915}; 916 ; 917////////////////////////////////////////////////////////////////////////////////; 918/// Go downwards from current level via ibranch as low in the tree as possible.; 919/// Return value flags if the operation was successful.; 920 ; 921TGeoElementRN *TGeoElemIter::Down(Int_t ibranch); 922{; 923 if (!fElem); 924 return nullptr;; 925 TGeoDecayChannel *dc = (TGeoDecayChannel *)fElem->Decays()->At(ibranch);; 926 if (!dc->Daughter()); 927 return nullptr;; 928 Double_t br = 0.01 * fRatio * dc->BranchingRatio();; 929 if (br < fLimitRatio); 930 return nullptr;; 931 fLevel++;; 932 fRatio = br;; 933 fBranch->Add(dc);; 934 fElem = dc->Daughter();; 935 return (TGeoElementRN *)fElem;; 936}; 937 ; 938////////////////////////////////////////////////////////////////////////////////; 939/// Return next element.; 940 ; 941TGeoElementRN *TGeoElemIter::Next(); 942{; 943 if (!fElem); 944 return nullptr;; 945 // Check if this is the first iteration.; 946 Int_t nd ",MatchSource.WIKI,doc/master/TGeoElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoElement_8cxx_source.html
https://root.cern/doc/master/TGeoElement_8cxx_source.html:65479,Availability,down,down,65479,"oid Print(Option_t *option="""") constPrint info about the current decay branch.Definition TGeoElement.cxx:956; TGeoElemIter::fRatioDouble_t fRatioDefinition TGeoElement.h:365; TGeoElemIter::GetBranchTObjArray * GetBranch() constDefinition TGeoElement.h:381; TGeoElemIter::fElemconst TGeoElementRN * fElemDefinition TGeoElement.h:361; TGeoElemIter::fBranchTObjArray * fBranchDefinition TGeoElement.h:362; TGeoElemIter::NextTGeoElementRN * Next()Return next element.Definition TGeoElement.cxx:941; TGeoElemIter::operator=TGeoElemIter & operator=(const TGeoElemIter &iter)Assignment.Definition TGeoElement.cxx:867; TGeoElemIter::~TGeoElemItervirtual ~TGeoElemIter()Destructor.Definition TGeoElement.cxx:858; TGeoElemIter::operator()TGeoElementRN * operator()()() operator.Definition TGeoElement.cxx:887; TGeoElemIter::fTopconst TGeoElementRN * fTopDefinition TGeoElement.h:360; TGeoElemIter::fLimitRatioDouble_t fLimitRatioDefinition TGeoElement.h:364; TGeoElemIter::UpTGeoElementRN * Up()Go upwards from the current location until the next branching, then down.Definition TGeoElement.cxx:895; TGeoElemIter::DownTGeoElementRN * Down(Int_t ibranch)Go downwards from current level via ibranch as low in the tree as possible.Definition TGeoElement.cxx:921; TGeoElemIter::fLevelInt_t fLevelDefinition TGeoElement.h:363; TGeoElemIter::TGeoElemIterTGeoElemIter()Definition TGeoElement.h:368; TGeoElementRNClass representing a radionuclidevoid TGeoManager::SetDefaultRootUnits() { if ( fgDefaultUnits == kRo...Definition TGeoElement.h:132; TGeoElementRN::fNatAbunDouble_t fNatAbunDefinition TGeoElement.h:139; TGeoElementRN::AddRatiovoid AddRatio(TGeoBatemanSol &ratio)Adds a proportion ratio to the existing one.Definition TGeoElement.cxx:684; TGeoElementRN::FillPopulationvoid FillPopulation(TObjArray *population, Double_t precision=0.001, Double_t factor=1.)Fills the input array with the set of RN elements resulting from the decay of this one.Definition TGeoElement.cxx:550; TGeoElementRN::AddDecayvoid Ad",MatchSource.WIKI,doc/master/TGeoElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoElement_8cxx_source.html
https://root.cern/doc/master/TGeoElement_8cxx_source.html:65572,Availability,down,downwards,65572,"nition TGeoElement.h:365; TGeoElemIter::GetBranchTObjArray * GetBranch() constDefinition TGeoElement.h:381; TGeoElemIter::fElemconst TGeoElementRN * fElemDefinition TGeoElement.h:361; TGeoElemIter::fBranchTObjArray * fBranchDefinition TGeoElement.h:362; TGeoElemIter::NextTGeoElementRN * Next()Return next element.Definition TGeoElement.cxx:941; TGeoElemIter::operator=TGeoElemIter & operator=(const TGeoElemIter &iter)Assignment.Definition TGeoElement.cxx:867; TGeoElemIter::~TGeoElemItervirtual ~TGeoElemIter()Destructor.Definition TGeoElement.cxx:858; TGeoElemIter::operator()TGeoElementRN * operator()()() operator.Definition TGeoElement.cxx:887; TGeoElemIter::fTopconst TGeoElementRN * fTopDefinition TGeoElement.h:360; TGeoElemIter::fLimitRatioDouble_t fLimitRatioDefinition TGeoElement.h:364; TGeoElemIter::UpTGeoElementRN * Up()Go upwards from the current location until the next branching, then down.Definition TGeoElement.cxx:895; TGeoElemIter::DownTGeoElementRN * Down(Int_t ibranch)Go downwards from current level via ibranch as low in the tree as possible.Definition TGeoElement.cxx:921; TGeoElemIter::fLevelInt_t fLevelDefinition TGeoElement.h:363; TGeoElemIter::TGeoElemIterTGeoElemIter()Definition TGeoElement.h:368; TGeoElementRNClass representing a radionuclidevoid TGeoManager::SetDefaultRootUnits() { if ( fgDefaultUnits == kRo...Definition TGeoElement.h:132; TGeoElementRN::fNatAbunDouble_t fNatAbunDefinition TGeoElement.h:139; TGeoElementRN::AddRatiovoid AddRatio(TGeoBatemanSol &ratio)Adds a proportion ratio to the existing one.Definition TGeoElement.cxx:684; TGeoElementRN::FillPopulationvoid FillPopulation(TObjArray *population, Double_t precision=0.001, Double_t factor=1.)Fills the input array with the set of RN elements resulting from the decay of this one.Definition TGeoElement.cxx:550; TGeoElementRN::AddDecayvoid AddDecay(Int_t decay, Int_t diso, Double_t branchingRatio, Double_t qValue)Adds a decay mode for this element.Definition TGeoElement.cxx:438; TGeoElemen",MatchSource.WIKI,doc/master/TGeoElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoElement_8cxx_source.html
https://root.cern/doc/master/TGeoElement_8cxx_source.html:77950,Availability,error,error,77950,"_t idx) const overrideDefinition TObjArray.h:164; TObjArray::RemoveAtTObject * RemoveAt(Int_t idx) overrideRemove object at index idx.Definition TObjArray.cxx:694; TObjArray::FindObjectTObject * FindObject(const char *name) const overrideFind an object in this collection using its name.Definition TObjArray.cxx:415; TObjArray::Addvoid Add(TObject *obj) overrideDefinition TObjArray.h:68; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::operator=TObject & operator=(const TObject &rhs)TObject assignment operator.Definition TObject.h:296; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::Printvirtual void Print(Option_t *option="""") constThis method must be overridden when a class wants to print itself.Definition TObject.cxx:642; TROOT::GetEtcDirstatic const TString & GetEtcDir()Get the sysconfig directory in the installation. Static utility function.Definition TROOT.cxx:3056; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::Dataconst char * Data() constDefinition TString.h:376; TString::ReplaceAllTString & ReplaceAll(const TString &s1, const TString &s2)Definition TString.h:704; TString::ToUppervoid ToUpper()Change string to upper case.Definition TString.cxx:1195; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TStri",MatchSource.WIKI,doc/master/TGeoElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoElement_8cxx_source.html
https://root.cern/doc/master/TGeoElement_8cxx_source.html:78086,Availability,error,error,78086,".Definition TObjArray.cxx:694; TObjArray::FindObjectTObject * FindObject(const char *name) const overrideFind an object in this collection using its name.Definition TObjArray.cxx:415; TObjArray::Addvoid Add(TObject *obj) overrideDefinition TObjArray.h:68; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::operator=TObject & operator=(const TObject &rhs)TObject assignment operator.Definition TObject.h:296; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::Printvirtual void Print(Option_t *option="""") constThis method must be overridden when a class wants to print itself.Definition TObject.cxx:642; TROOT::GetEtcDirstatic const TString & GetEtcDir()Get the sysconfig directory in the installation. Static utility function.Definition TROOT.cxx:3056; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::Dataconst char * Data() constDefinition TString.h:376; TString::ReplaceAllTString & ReplaceAll(const TString &s1, const TString &s2)Definition TString.h:704; TString::ToUppervoid ToUpper()Change string to upper case.Definition TString.cxx:1195; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TString::Formvoid Form(const char *fmt,...)Formats a string using a printf style format descriptor.De",MatchSource.WIKI,doc/master/TGeoElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoElement_8cxx_source.html
https://root.cern/doc/master/TGeoElement_8cxx_source.html:78367,Deployability,install,installation,78367,"jArray.h:68; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::operator=TObject & operator=(const TObject &rhs)TObject assignment operator.Definition TObject.h:296; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::Printvirtual void Print(Option_t *option="""") constThis method must be overridden when a class wants to print itself.Definition TObject.cxx:642; TROOT::GetEtcDirstatic const TString & GetEtcDir()Get the sysconfig directory in the installation. Static utility function.Definition TROOT.cxx:3056; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::Dataconst char * Data() constDefinition TString.h:376; TString::ReplaceAllTString & ReplaceAll(const TString &s1, const TString &s2)Definition TString.h:704; TString::ToUppervoid ToUpper()Change string to upper case.Definition TString.cxx:1195; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TString::Formvoid Form(const char *fmt,...)Formats a string using a printf style format descriptor.Definition TString.cxx:2356; TSystem::PrependPathNamevirtual const char * PrependPathName(const char *dir, TString &name)Concatenate a directory and a file name.Definition TSystem.cxx:1081; TVirtualGeoPainter::DrawBatemanSolvirtual void DrawBate",MatchSource.WIKI,doc/master/TGeoElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoElement_8cxx_source.html
https://root.cern/doc/master/TGeoElement_8cxx_source.html:80037,Energy Efficiency,power,power,80037,"ing.h:704; TString::ToUppervoid ToUpper()Change string to upper case.Definition TString.cxx:1195; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TString::Formvoid Form(const char *fmt,...)Formats a string using a printf style format descriptor.Definition TString.cxx:2356; TSystem::PrependPathNamevirtual const char * PrependPathName(const char *dir, TString &name)Concatenate a directory and a file name.Definition TSystem.cxx:1081; TVirtualGeoPainter::DrawBatemanSolvirtual void DrawBatemanSol(TGeoBatemanSol *sol, Option_t *option="""")=0; bool; double; int; unsigned int; lineTLine * lineDefinition entrylistblock_figure1.C:235; nconst Int_t nDefinition legend1.C:16; TGeant4Unit::alpha_rcl2static constexpr double alpha_rcl2Definition TGeant4PhysicalConstants.h:95; TGeant4Unit::fine_structure_conststatic constexpr double fine_structure_constDefinition TGeant4PhysicalConstants.h:90; TGeoUnit::fine_structure_conststatic constexpr double fine_structure_constDefinition TGeoPhysicalConstants.h:90; TGeoUnit::alpha_rcl2static constexpr double alpha_rcl2Definition TGeoPhysicalConstants.h:95; TMath::ExpDouble_t Exp(Double_t x)Returns the base-e exponential function of x, which is e raised to the power x.Definition TMath.h:709; TMath::LogDouble_t Log(Double_t x)Returns the natural logarithm of x.Definition TMath.h:756; TMath::Naconstexpr Double_t Na()Avogadro constant (Avogadro's Number) in .Definition TMath.h:284; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123; TGeoBatemanSol::BtCoef_tDefinition TGeoElement.h:288; TGeoBatemanSol::BtCoef_t::cnDouble_t cnDefinition TGeoElement.h:289; TGeoBatemanSol::BtCoef_t::lambdaDouble_t lambdaDefinition TGeoElement.h:290. geomgeomsrcTGeoElement.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:14 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TGeoElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoElement_8cxx_source.html
https://root.cern/doc/master/TGeoElement_8cxx_source.html:77698,Integrability,message,message,77698,"eReturn the number of objects in array (i.e.Definition TObjArray.cxx:523; TObjArray::Deletevoid Delete(Option_t *option="""") overrideRemove all objects from the array AND delete all heap based objects.Definition TObjArray.cxx:356; TObjArray::AtTObject * At(Int_t idx) const overrideDefinition TObjArray.h:164; TObjArray::RemoveAtTObject * RemoveAt(Int_t idx) overrideRemove object at index idx.Definition TObjArray.cxx:694; TObjArray::FindObjectTObject * FindObject(const char *name) const overrideFind an object in this collection using its name.Definition TObjArray.cxx:415; TObjArray::Addvoid Add(TObject *obj) overrideDefinition TObjArray.h:68; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::operator=TObject & operator=(const TObject &rhs)TObject assignment operator.Definition TObject.h:296; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::Printvirtual void Print(Option_t *option="""") constThis method must be overridden when a class wants to print itself.Definition TObject.cxx:642; TROOT::GetEtcDirstatic const TString & GetEtcDir()Get the sysconfig directory in the installation. Static utility function.Definition TROOT.cxx:3056; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::Dataconst char * Data() constDefinition TString.h:376; TString::ReplaceAllTString & ReplaceAll(const TString &s1, const TString &s2)Defin",MatchSource.WIKI,doc/master/TGeoElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoElement_8cxx_source.html
https://root.cern/doc/master/TGeoElement_8cxx_source.html:77956,Integrability,message,message,77956,"_t idx) const overrideDefinition TObjArray.h:164; TObjArray::RemoveAtTObject * RemoveAt(Int_t idx) overrideRemove object at index idx.Definition TObjArray.cxx:694; TObjArray::FindObjectTObject * FindObject(const char *name) const overrideFind an object in this collection using its name.Definition TObjArray.cxx:415; TObjArray::Addvoid Add(TObject *obj) overrideDefinition TObjArray.h:68; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::operator=TObject & operator=(const TObject &rhs)TObject assignment operator.Definition TObject.h:296; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::Printvirtual void Print(Option_t *option="""") constThis method must be overridden when a class wants to print itself.Definition TObject.cxx:642; TROOT::GetEtcDirstatic const TString & GetEtcDir()Get the sysconfig directory in the installation. Static utility function.Definition TROOT.cxx:3056; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::Dataconst char * Data() constDefinition TString.h:376; TString::ReplaceAllTString & ReplaceAll(const TString &s1, const TString &s2)Definition TString.h:704; TString::ToUppervoid ToUpper()Change string to upper case.Definition TString.cxx:1195; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TStri",MatchSource.WIKI,doc/master/TGeoElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoElement_8cxx_source.html
https://root.cern/doc/master/TGeoElement_8cxx_source.html:78092,Integrability,message,message,78092,".Definition TObjArray.cxx:694; TObjArray::FindObjectTObject * FindObject(const char *name) const overrideFind an object in this collection using its name.Definition TObjArray.cxx:415; TObjArray::Addvoid Add(TObject *obj) overrideDefinition TObjArray.h:68; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::operator=TObject & operator=(const TObject &rhs)TObject assignment operator.Definition TObject.h:296; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::Printvirtual void Print(Option_t *option="""") constThis method must be overridden when a class wants to print itself.Definition TObject.cxx:642; TROOT::GetEtcDirstatic const TString & GetEtcDir()Get the sysconfig directory in the installation. Static utility function.Definition TROOT.cxx:3056; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::Dataconst char * Data() constDefinition TString.h:376; TString::ReplaceAllTString & ReplaceAll(const TString &s1, const TString &s2)Definition TString.h:704; TString::ToUppervoid ToUpper()Change string to upper case.Definition TString.cxx:1195; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TString::Formvoid Form(const char *fmt,...)Formats a string using a printf style format descriptor.De",MatchSource.WIKI,doc/master/TGeoElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoElement_8cxx_source.html
https://root.cern/doc/master/TGeoElement_8cxx_source.html:9125,Modifiability,extend,extend,9125,"TGeoElementTable *TGeoElement::GetElementTable(); 232{; 233 if (!gGeoManager) {; 234 ::Error(""TGeoElementTable::GetElementTable"", ""Create a geometry manager first"");; 235 return nullptr;; 236 }; 237 return gGeoManager->GetElementTable();; 238}; 239 ; 240////////////////////////////////////////////////////////////////////////////////; 241/// Add an isotope for this element. All isotopes have to be isotopes of the same element.; 242 ; 243void TGeoElement::AddIsotope(TGeoIsotope *isotope, Double_t relativeAbundance); 244{; 245 if (!fIsotopes) {; 246 fNisotopes = 1;; 247 fIsotopes = new TObjArray();; 248 fAbundances = new Double_t[1];; 249 }; 250 Int_t ncurrent = 0;; 251 TGeoIsotope *isocrt;; 252 for (ncurrent = 0; ncurrent < fNisotopes; ncurrent++); 253 if (!fIsotopes->At(ncurrent)); 254 break;; 255 if (ncurrent == fNisotopes) {; 256 // User requested overwriting a standard element - we need to extend dynamically the support arrays; 257 Double_t *abundances = new Double_t[fNisotopes + 1];; 258 memcpy(abundances, fAbundances, fNisotopes * sizeof(Double_t));; 259 delete[] fAbundances;; 260 fAbundances = abundances;; 261 fNisotopes++;; 262 }; 263 // Check Z of the new isotope; 264 if ((fZ != 0) && (isotope->GetZ() != fZ)) {; 265 Fatal(""AddIsotope"", ""Trying to add isotope %s with different Z to the same element %s"", isotope->GetName(),; 266 GetName());; 267 return;; 268 } else {; 269 fZ = isotope->GetZ();; 270 }; 271 fIsotopes->Add(isotope);; 272 fAbundances[ncurrent] = relativeAbundance;; 273 if (ncurrent == fNisotopes - 1) {; 274 Double_t weight = 0.0;; 275 Double_t aeff = 0.0;; 276 Double_t neff = 0.0;; 277 for (Int_t i = 0; i < fNisotopes; i++) {; 278 isocrt = (TGeoIsotope *)fIsotopes->At(i);; 279 aeff += fAbundances[i] * isocrt->GetA();; 280 neff += fAbundances[i] * isocrt->GetN();; 281 weight += fAbundances[i];; 282 }; 283 aeff /= weight;; 284 neff /= weight;; 285 fN = (Int_t)neff;; 286 fA = aeff;; 287 }; 288 ComputeDerivedQuantities();; 289}; 290 ; 291//////////////",MatchSource.WIKI,doc/master/TGeoElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoElement_8cxx_source.html
https://root.cern/doc/master/TGeoElement_8cxx_source.html:45926,Performance,optimiz,optimized,45926,"imitive(out, ""h"");; 1323 else; 1324 elem->SavePrimitive(out);; 1325 i++;; 1326 }; 1327 out.close();; 1328}; 1329 ; 1330////////////////////////////////////////////////////////////////////////////////; 1331/// Search an element by symbol or full name; 1332/// Exact matching; 1333 ; 1334TGeoElement *TGeoElementTable::FindElement(const char *name) const; 1335{; 1336 TGeoElement *elem;; 1337 elem = (TGeoElement *)fList->FindObject(name);; 1338 if (elem); 1339 return elem;; 1340 // Search case insensitive by element name; 1341 TString s(name);; 1342 s.ToUpper();; 1343 elem = (TGeoElement *)fList->FindObject(s.Data());; 1344 if (elem); 1345 return elem;; 1346 // Search by full name; 1347 TIter next(fList);; 1348 while ((elem = (TGeoElement *)next())) {; 1349 if (s == elem->GetTitle()); 1350 return elem;; 1351 }; 1352 return nullptr;; 1353}; 1354 ; 1355////////////////////////////////////////////////////////////////////////////////; 1356/// Find existing isotope by name. Not optimized for a big number of isotopes.; 1357 ; 1358TGeoIsotope *TGeoElementTable::FindIsotope(const char *name) const; 1359{; 1360 if (!fIsotopes); 1361 return nullptr;; 1362 return (TGeoIsotope *)fIsotopes->FindObject(name);; 1363}; 1364 ; 1365////////////////////////////////////////////////////////////////////////////////; 1366/// Retrieve a radionuclide by ENDF code.; 1367 ; 1368TGeoElementRN *TGeoElementTable::GetElementRN(Int_t ENDFcode) const; 1369{; 1370 if (!HasRNElements()) {; 1371 TGeoElementTable *table = (TGeoElementTable *)this;; 1372 table->ImportElementsRN();; 1373 if (!fListRN); 1374 return nullptr;; 1375 }; 1376 ElementRNMap_t::const_iterator it = fElementsRN.find(ENDFcode);; 1377 if (it != fElementsRN.end()); 1378 return it->second;; 1379 return nullptr;; 1380}; 1381 ; 1382////////////////////////////////////////////////////////////////////////////////; 1383/// Retrieve a radionuclide by a, z, and isomeric state.; 1384 ; 1385TGeoElementRN *TGeoElementTable::GetElementRN(Int_t a, Int_",MatchSource.WIKI,doc/master/TGeoElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoElement_8cxx_source.html
https://root.cern/doc/master/TGeoElement_8cxx_source.html:71622,Performance,optimiz,optimized,71622,"ement.h:404; TGeoElementTable::fIsotopesTObjArray * fIsotopesDefinition TGeoElement.h:406; TGeoElementTable::kETRNElements@ kETRNElementsDefinition TGeoElement.h:424; TGeoElementTable::kETDefaultElements@ kETDefaultElementsDefinition TGeoElement.h:424; TGeoElementTable::CheckTableBool_t CheckTable() constChecks status of element table.Definition TGeoElement.cxx:1286; TGeoElementTable::Printvoid Print(Option_t *option="""") const overridePrint table of elements.Definition TGeoElement.cxx:1398; TGeoElementTable::ImportElementsRNvoid ImportElementsRN()Creates the list of radionuclides.Definition TGeoElement.cxx:1247; TGeoElementTable::AddElementvoid AddElement(const char *name, const char *title, Int_t z, Double_t a)Add an element to the table. Obsolete.Definition TGeoElement.cxx:1058; TGeoElementTable::fNelementsRNInt_t fNelementsRNDefinition TGeoElement.h:402; TGeoElementTable::FindIsotopeTGeoIsotope * FindIsotope(const char *name) constFind existing isotope by name. Not optimized for a big number of isotopes.Definition TGeoElement.cxx:1358; TGeoElementTable::BuildDefaultElementsvoid BuildDefaultElements()Creates the default element table.Definition TGeoElement.cxx:1123; TGeoElementTable::TGeoElementTableTGeoElementTable()default constructorDefinition TGeoElement.cxx:980; TGeoElementTable::FindElementTGeoElement * FindElement(const char *name) constSearch an element by symbol or full name Exact matching.Definition TGeoElement.cxx:1334; TGeoElementBase class for chemical elements.Definition TGeoElement.h:36; TGeoElement::fADouble_t fADefinition TGeoElement.h:43; TGeoElement::fNisotopesInt_t fNisotopesDefinition TGeoElement.h:42; TGeoElement::fRadTsaiDouble_t fRadTsaiDefinition TGeoElement.h:47; TGeoElement::TGeoElementTGeoElement()Default constructor.Definition TGeoElement.cxx:90; TGeoElement::SetDefinedvoid SetDefined(Bool_t flag=kTRUE)Definition TGeoElement.h:85; TGeoElement::ComputeDerivedQuantitiesvoid ComputeDerivedQuantities()Calculate properties for an atomic num",MatchSource.WIKI,doc/master/TGeoElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoElement_8cxx_source.html
https://root.cern/doc/master/TGeoElement_8cxx_source.html:80123,Testability,log,logarithm,80123,"ing.h:704; TString::ToUppervoid ToUpper()Change string to upper case.Definition TString.cxx:1195; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TString::Formvoid Form(const char *fmt,...)Formats a string using a printf style format descriptor.Definition TString.cxx:2356; TSystem::PrependPathNamevirtual const char * PrependPathName(const char *dir, TString &name)Concatenate a directory and a file name.Definition TSystem.cxx:1081; TVirtualGeoPainter::DrawBatemanSolvirtual void DrawBatemanSol(TGeoBatemanSol *sol, Option_t *option="""")=0; bool; double; int; unsigned int; lineTLine * lineDefinition entrylistblock_figure1.C:235; nconst Int_t nDefinition legend1.C:16; TGeant4Unit::alpha_rcl2static constexpr double alpha_rcl2Definition TGeant4PhysicalConstants.h:95; TGeant4Unit::fine_structure_conststatic constexpr double fine_structure_constDefinition TGeant4PhysicalConstants.h:90; TGeoUnit::fine_structure_conststatic constexpr double fine_structure_constDefinition TGeoPhysicalConstants.h:90; TGeoUnit::alpha_rcl2static constexpr double alpha_rcl2Definition TGeoPhysicalConstants.h:95; TMath::ExpDouble_t Exp(Double_t x)Returns the base-e exponential function of x, which is e raised to the power x.Definition TMath.h:709; TMath::LogDouble_t Log(Double_t x)Returns the natural logarithm of x.Definition TMath.h:756; TMath::Naconstexpr Double_t Na()Avogadro constant (Avogadro's Number) in .Definition TMath.h:284; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123; TGeoBatemanSol::BtCoef_tDefinition TGeoElement.h:288; TGeoBatemanSol::BtCoef_t::cnDouble_t cnDefinition TGeoElement.h:289; TGeoBatemanSol::BtCoef_t::lambdaDouble_t lambdaDefinition TGeoElement.h:290. geomgeomsrcTGeoElement.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:14 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TGeoElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoElement_8cxx_source.html
https://root.cern/doc/master/TGeoElement_8h_source.html:26305,Availability,down,down,26305,"h:365; TGeoElemIter::SetLimitRatiovoid SetLimitRatio(Double_t limit)Definition TGeoElement.h:387; TGeoElemIter::GetBranchTObjArray * GetBranch() constDefinition TGeoElement.h:381; TGeoElemIter::GetRatioDouble_t GetRatio() constDefinition TGeoElement.h:385; TGeoElemIter::fElemconst TGeoElementRN * fElemDefinition TGeoElement.h:361; TGeoElemIter::fBranchTObjArray * fBranchDefinition TGeoElement.h:362; TGeoElemIter::NextTGeoElementRN * Next()Return next element.Definition TGeoElement.cxx:941; TGeoElemIter::operator=TGeoElemIter & operator=(const TGeoElemIter &iter)Assignment.Definition TGeoElement.cxx:867; TGeoElemIter::~TGeoElemItervirtual ~TGeoElemIter()Destructor.Definition TGeoElement.cxx:858; TGeoElemIter::operator()TGeoElementRN * operator()()() operator.Definition TGeoElement.cxx:887; TGeoElemIter::fTopconst TGeoElementRN * fTopDefinition TGeoElement.h:360; TGeoElemIter::fLimitRatioDouble_t fLimitRatioDefinition TGeoElement.h:364; TGeoElemIter::UpTGeoElementRN * Up()Go upwards from the current location until the next branching, then down.Definition TGeoElement.cxx:895; TGeoElemIter::GetElementconst TGeoElementRN * GetElement() constDefinition TGeoElement.h:383; TGeoElemIter::DownTGeoElementRN * Down(Int_t ibranch)Go downwards from current level via ibranch as low in the tree as possible.Definition TGeoElement.cxx:921; TGeoElemIter::GetTopconst TGeoElementRN * GetTop() constDefinition TGeoElement.h:382; TGeoElemIter::fLevelInt_t fLevelDefinition TGeoElement.h:363; TGeoElemIter::TGeoElemIterTGeoElemIter()Definition TGeoElement.h:368; TGeoElemIter::GetLevelInt_t GetLevel() constDefinition TGeoElement.h:384; TGeoElementRNClass representing a radionuclidevoid TGeoManager::SetDefaultRootUnits() { if ( fgDefaultUnits == kRo...Definition TGeoElement.h:132; TGeoElementRN::fNatAbunDouble_t fNatAbunDefinition TGeoElement.h:139; TGeoElementRN::AddRatiovoid AddRatio(TGeoBatemanSol &ratio)Adds a proportion ratio to the existing one.Definition TGeoElement.cxx:684; TGeoElementR",MatchSource.WIKI,doc/master/TGeoElement_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoElement_8h_source.html
https://root.cern/doc/master/TGeoElement_8h_source.html:26492,Availability,down,downwards,26492,"ement.h:385; TGeoElemIter::fElemconst TGeoElementRN * fElemDefinition TGeoElement.h:361; TGeoElemIter::fBranchTObjArray * fBranchDefinition TGeoElement.h:362; TGeoElemIter::NextTGeoElementRN * Next()Return next element.Definition TGeoElement.cxx:941; TGeoElemIter::operator=TGeoElemIter & operator=(const TGeoElemIter &iter)Assignment.Definition TGeoElement.cxx:867; TGeoElemIter::~TGeoElemItervirtual ~TGeoElemIter()Destructor.Definition TGeoElement.cxx:858; TGeoElemIter::operator()TGeoElementRN * operator()()() operator.Definition TGeoElement.cxx:887; TGeoElemIter::fTopconst TGeoElementRN * fTopDefinition TGeoElement.h:360; TGeoElemIter::fLimitRatioDouble_t fLimitRatioDefinition TGeoElement.h:364; TGeoElemIter::UpTGeoElementRN * Up()Go upwards from the current location until the next branching, then down.Definition TGeoElement.cxx:895; TGeoElemIter::GetElementconst TGeoElementRN * GetElement() constDefinition TGeoElement.h:383; TGeoElemIter::DownTGeoElementRN * Down(Int_t ibranch)Go downwards from current level via ibranch as low in the tree as possible.Definition TGeoElement.cxx:921; TGeoElemIter::GetTopconst TGeoElementRN * GetTop() constDefinition TGeoElement.h:382; TGeoElemIter::fLevelInt_t fLevelDefinition TGeoElement.h:363; TGeoElemIter::TGeoElemIterTGeoElemIter()Definition TGeoElement.h:368; TGeoElemIter::GetLevelInt_t GetLevel() constDefinition TGeoElement.h:384; TGeoElementRNClass representing a radionuclidevoid TGeoManager::SetDefaultRootUnits() { if ( fgDefaultUnits == kRo...Definition TGeoElement.h:132; TGeoElementRN::fNatAbunDouble_t fNatAbunDefinition TGeoElement.h:139; TGeoElementRN::AddRatiovoid AddRatio(TGeoBatemanSol &ratio)Adds a proportion ratio to the existing one.Definition TGeoElement.cxx:684; TGeoElementRN::FillPopulationvoid FillPopulation(TObjArray *population, Double_t precision=0.001, Double_t factor=1.)Fills the input array with the set of RN elements resulting from the decay of this one.Definition TGeoElement.cxx:550; TGeoElementRN::operat",MatchSource.WIKI,doc/master/TGeoElement_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoElement_8h_source.html
https://root.cern/doc/master/TGeoElement_8h_source.html:34465,Performance,optimiz,optimized,34465,"le() constChecks status of element table.Definition TGeoElement.cxx:1286; TGeoElementTable::Printvoid Print(Option_t *option="""") const overridePrint table of elements.Definition TGeoElement.cxx:1398; TGeoElementTable::ImportElementsRNvoid ImportElementsRN()Creates the list of radionuclides.Definition TGeoElement.cxx:1247; TGeoElementTable::ElementRNMap_tstd::map< Int_t, TGeoElementRN * > ElementRNMap_tDefinition TGeoElement.h:408; TGeoElementTable::GetElementTGeoElement * GetElement(Int_t z)Definition TGeoElement.h:435; TGeoElementTable::AddElementvoid AddElement(const char *name, const char *title, Int_t z, Double_t a)Add an element to the table. Obsolete.Definition TGeoElement.cxx:1058; TGeoElementTable::fNelementsRNInt_t fNelementsRNDefinition TGeoElement.h:402; TGeoElementTable::GetElementsRNTObjArray * GetElementsRN() constDefinition TGeoElement.h:438; TGeoElementTable::FindIsotopeTGeoIsotope * FindIsotope(const char *name) constFind existing isotope by name. Not optimized for a big number of isotopes.Definition TGeoElement.cxx:1358; TGeoElementTable::BuildDefaultElementsvoid BuildDefaultElements()Creates the default element table.Definition TGeoElement.cxx:1123; TGeoElementTable::GetNelementsInt_t GetNelements() constDefinition TGeoElement.h:442; TGeoElementTable::TGeoElementTableTGeoElementTable()default constructorDefinition TGeoElement.cxx:980; TGeoElementTable::FindElementTGeoElement * FindElement(const char *name) constSearch an element by symbol or full name Exact matching.Definition TGeoElement.cxx:1334; TGeoElementBase class for chemical elements.Definition TGeoElement.h:36; TGeoElement::fADouble_t fADefinition TGeoElement.h:43; TGeoElement::NInt_t N() constDefinition TGeoElement.h:69; TGeoElement::GetSpecificActivityvirtual Double_t GetSpecificActivity() constDefinition TGeoElement.h:79; TGeoElement::fNisotopesInt_t fNisotopesDefinition TGeoElement.h:42; TGeoElement::fRadTsaiDouble_t fRadTsaiDefinition TGeoElement.h:47; TGeoElement::IsDefinedBool_t Is",MatchSource.WIKI,doc/master/TGeoElement_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoElement_8h_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:9369,Availability,down,down,9369," instance the; 141previous example $ROOTSYS/tutorials/geom/rootgeom.C ), the manager class will register; 142itself to ROOT and the logical/physical structures will become immediately browsable.; 143The ROOT browser will display starting from the geometry folder : the list of; 144transformations and media, the top volume and the top logical node. These last; 145two can be fully expanded, any intermediate volume/node in the browser being subject; 146of direct access context menu operations (right mouse button click). All user; 147utilities of classes TGeoManager, TGeoVolume and TGeoNode can be called via the; 148context menu.; 149 ; 150\image html geom_browser.jpg; 151 ; 152### Drawing the geometry; 153 ; 154 Any logical volume can be drawn via TGeoVolume::Draw() member function.; 155This can be directly accessed from the context menu of the volume object; 156directly from the browser.; 157 There are several drawing options that can be set with; 158TGeoManager::SetVisOption(Int_t opt) method :; 159 ; 160#### opt=0; 161 only the content of the volume is drawn, N levels down (default N=3).; 162 This is the default behavior. The number of levels to be drawn can be changed; 163 via TGeoManager::SetVisLevel(Int_t level) method.; 164 ; 165\image html geom_frame0.jpg; 166 ; 167#### opt=1; 168 the final leaves (e.g. daughters with no containment) of the branch; 169 starting from volume are drawn down to the current number of levels.; 170 WARNING : This mode is memory consuming; 171 depending of the size of geometry, so drawing from top level within this mode; 172 should be handled with care for expensive geometries. In future there will be; 173 a limitation on the maximum number of nodes to be visualized.; 174 ; 175\image html geom_frame1.jpg; 176 ; 177#### opt=2; 178 only the clicked volume is visualized. This is automatically set by; 179 TGeoVolume::DrawOnly() method; 180 ; 181#### opt=3 - only a given path is visualized. This is automatically set by; 182 TGeoVolume::DrawP",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:9695,Availability,down,down,9695,"ed, any intermediate volume/node in the browser being subject; 146of direct access context menu operations (right mouse button click). All user; 147utilities of classes TGeoManager, TGeoVolume and TGeoNode can be called via the; 148context menu.; 149 ; 150\image html geom_browser.jpg; 151 ; 152### Drawing the geometry; 153 ; 154 Any logical volume can be drawn via TGeoVolume::Draw() member function.; 155This can be directly accessed from the context menu of the volume object; 156directly from the browser.; 157 There are several drawing options that can be set with; 158TGeoManager::SetVisOption(Int_t opt) method :; 159 ; 160#### opt=0; 161 only the content of the volume is drawn, N levels down (default N=3).; 162 This is the default behavior. The number of levels to be drawn can be changed; 163 via TGeoManager::SetVisLevel(Int_t level) method.; 164 ; 165\image html geom_frame0.jpg; 166 ; 167#### opt=1; 168 the final leaves (e.g. daughters with no containment) of the branch; 169 starting from volume are drawn down to the current number of levels.; 170 WARNING : This mode is memory consuming; 171 depending of the size of geometry, so drawing from top level within this mode; 172 should be handled with care for expensive geometries. In future there will be; 173 a limitation on the maximum number of nodes to be visualized.; 174 ; 175\image html geom_frame1.jpg; 176 ; 177#### opt=2; 178 only the clicked volume is visualized. This is automatically set by; 179 TGeoVolume::DrawOnly() method; 180 ; 181#### opt=3 - only a given path is visualized. This is automatically set by; 182 TGeoVolume::DrawPath(const char *path) method; 183 ; 184 The current view can be exploded in cartesian, cylindrical or spherical; 185coordinates :; 186 TGeoManager::SetExplodedView(Int_t opt). Options may be :; 187- 0 - default (no bombing); 188- 1 - cartesian coordinates. The bomb factor on each axis can be set with; 189 TGeoManager::SetBombX(Double_t bomb) and corresponding Y and Z.; 190- 2 - bomb in",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:11660,Availability,down,down,11660,"nd Z.; 190- 2 - bomb in cylindrical coordinates. Only the bomb factors on Z and R; 191 are considered; 192 \image html geom_frameexp.jpg; 193 ; 194- 3 - bomb in radial spherical coordinate : TGeoManager::SetBombR(); 195 ; 196Volumes themselves support different visualization settings :; 197 - TGeoVolume::SetVisibility() : set volume visibility.; 198 - TGeoVolume::VisibleDaughters() : set daughters visibility.; 199All these actions automatically updates the current view if any.; 200 ; 201### Checking the geometry; 202 ; 203 Several checking methods are accessible from the volume context menu. They; 204generally apply only to the visible parts of the drawn geometry in order to; 205ease geometry checking, and their implementation is in the TGeoChecker class; 206from the painting package.; 207 ; 208#### Checking a given point.; 209 Can be called from TGeoManager::CheckPoint(Double_t x, Double_t y, Double_t z).; 210This method is drawing the daughters of the volume containing the point one; 211level down, printing the path to the deepest physical node holding this point.; 212It also computes the closest distance to any boundary. The point will be drawn; 213in red, as well as a sphere having this closest distance as radius. In case a; 214non-zero distance is given by the user as fifth argument of CheckPoint, this; 215distance will be used as radius of the safety sphere.; 216 ; 217\image html geom_checkpoint.jpg; 218 ; 219#### Shooting random points.; 220 Can be called from TGeoVolume::RandomPoints() (context menu function) and; 221it will draw this volume with current visualization settings. Random points; 222are generated in the bounding box of the top drawn volume. The points are; 223classified and drawn with the color of their deepest container. Only points; 224in visible nodes will be drawn.; 225 ; 226\image html geom_random1.jpg; 227 ; 228 ; 229#### Raytracing.; 230 Can be called from TGeoVolume::RandomRays() (context menu of volumes) and; 231will shoot rays from a gi",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:25061,Availability,error,error,25061,"6 Int_t size = fOverlaps->GetEntriesFast();; 627 fOverlaps->Add((TObject *)ovlp);; 628 return size;; 629}; 630 ; 631////////////////////////////////////////////////////////////////////////////////; 632/// Add a new region of volumes.; 633Int_t TGeoManager::AddRegion(TGeoRegion *region); 634{; 635 Int_t size = fRegions->GetEntriesFast();; 636 fRegions->Add(region);; 637 return size;; 638}; 639 ; 640////////////////////////////////////////////////////////////////////////////////; 641/// Add a user-defined property. Returns true if added, false if existing.; 642 ; 643Bool_t TGeoManager::AddProperty(const char *property, Double_t value); 644{; 645 auto pos = fProperties.insert(ConstPropMap_t::value_type(property, value));; 646 if (!pos.second) {; 647 Warning(""AddProperty"", ""Property \""%s\"" already exists with value %g"", property, (pos.first)->second);; 648 return false;; 649 }; 650 return true;; 651}; 652 ; 653////////////////////////////////////////////////////////////////////////////////; 654/// Get a user-defined property; 655 ; 656Double_t TGeoManager::GetProperty(const char *property, Bool_t *error) const; 657{; 658 auto pos = fProperties.find(property);; 659 if (pos == fProperties.end()) {; 660 if (error); 661 *error = kTRUE;; 662 return 0.;; 663 }; 664 if (error); 665 *error = kFALSE;; 666 return pos->second;; 667}; 668 ; 669////////////////////////////////////////////////////////////////////////////////; 670/// Get a user-defined property from a given index; 671 ; 672Double_t TGeoManager::GetProperty(size_t i, TString &name, Bool_t *error) const; 673{; 674 // This is a quite inefficient way to access map elements, but needed for the GDML writer to; 675 if (i >= fProperties.size()) {; 676 if (error); 677 *error = kTRUE;; 678 return 0.;; 679 }; 680 size_t pos = 0;; 681 auto it = fProperties.begin();; 682 while (pos < i) {; 683 ++it;; 684 ++pos;; 685 }; 686 if (error); 687 *error = kFALSE;; 688 name = (*it).first;; 689 return (*it).second;; 690}; 691 ; 692//////////",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:25170,Availability,error,error,25170,".; 633Int_t TGeoManager::AddRegion(TGeoRegion *region); 634{; 635 Int_t size = fRegions->GetEntriesFast();; 636 fRegions->Add(region);; 637 return size;; 638}; 639 ; 640////////////////////////////////////////////////////////////////////////////////; 641/// Add a user-defined property. Returns true if added, false if existing.; 642 ; 643Bool_t TGeoManager::AddProperty(const char *property, Double_t value); 644{; 645 auto pos = fProperties.insert(ConstPropMap_t::value_type(property, value));; 646 if (!pos.second) {; 647 Warning(""AddProperty"", ""Property \""%s\"" already exists with value %g"", property, (pos.first)->second);; 648 return false;; 649 }; 650 return true;; 651}; 652 ; 653////////////////////////////////////////////////////////////////////////////////; 654/// Get a user-defined property; 655 ; 656Double_t TGeoManager::GetProperty(const char *property, Bool_t *error) const; 657{; 658 auto pos = fProperties.find(property);; 659 if (pos == fProperties.end()) {; 660 if (error); 661 *error = kTRUE;; 662 return 0.;; 663 }; 664 if (error); 665 *error = kFALSE;; 666 return pos->second;; 667}; 668 ; 669////////////////////////////////////////////////////////////////////////////////; 670/// Get a user-defined property from a given index; 671 ; 672Double_t TGeoManager::GetProperty(size_t i, TString &name, Bool_t *error) const; 673{; 674 // This is a quite inefficient way to access map elements, but needed for the GDML writer to; 675 if (i >= fProperties.size()) {; 676 if (error); 677 *error = kTRUE;; 678 return 0.;; 679 }; 680 size_t pos = 0;; 681 auto it = fProperties.begin();; 682 while (pos < i) {; 683 ++it;; 684 ++pos;; 685 }; 686 if (error); 687 *error = kFALSE;; 688 name = (*it).first;; 689 return (*it).second;; 690}; 691 ; 692////////////////////////////////////////////////////////////////////////////////; 693/// Add a matrix to the list. Returns index of the matrix in list.; 694 ; 695Int_t TGeoManager::AddTransformation(const TGeoMatrix *matrix); 696{; 697 retur",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:25183,Availability,error,error,25183,".; 633Int_t TGeoManager::AddRegion(TGeoRegion *region); 634{; 635 Int_t size = fRegions->GetEntriesFast();; 636 fRegions->Add(region);; 637 return size;; 638}; 639 ; 640////////////////////////////////////////////////////////////////////////////////; 641/// Add a user-defined property. Returns true if added, false if existing.; 642 ; 643Bool_t TGeoManager::AddProperty(const char *property, Double_t value); 644{; 645 auto pos = fProperties.insert(ConstPropMap_t::value_type(property, value));; 646 if (!pos.second) {; 647 Warning(""AddProperty"", ""Property \""%s\"" already exists with value %g"", property, (pos.first)->second);; 648 return false;; 649 }; 650 return true;; 651}; 652 ; 653////////////////////////////////////////////////////////////////////////////////; 654/// Get a user-defined property; 655 ; 656Double_t TGeoManager::GetProperty(const char *property, Bool_t *error) const; 657{; 658 auto pos = fProperties.find(property);; 659 if (pos == fProperties.end()) {; 660 if (error); 661 *error = kTRUE;; 662 return 0.;; 663 }; 664 if (error); 665 *error = kFALSE;; 666 return pos->second;; 667}; 668 ; 669////////////////////////////////////////////////////////////////////////////////; 670/// Get a user-defined property from a given index; 671 ; 672Double_t TGeoManager::GetProperty(size_t i, TString &name, Bool_t *error) const; 673{; 674 // This is a quite inefficient way to access map elements, but needed for the GDML writer to; 675 if (i >= fProperties.size()) {; 676 if (error); 677 *error = kTRUE;; 678 return 0.;; 679 }; 680 size_t pos = 0;; 681 auto it = fProperties.begin();; 682 while (pos < i) {; 683 ++it;; 684 ++pos;; 685 }; 686 if (error); 687 *error = kFALSE;; 688 name = (*it).first;; 689 return (*it).second;; 690}; 691 ; 692////////////////////////////////////////////////////////////////////////////////; 693/// Add a matrix to the list. Returns index of the matrix in list.; 694 ; 695Int_t TGeoManager::AddTransformation(const TGeoMatrix *matrix); 696{; 697 retur",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:25230,Availability,error,error,25230,"41/// Add a user-defined property. Returns true if added, false if existing.; 642 ; 643Bool_t TGeoManager::AddProperty(const char *property, Double_t value); 644{; 645 auto pos = fProperties.insert(ConstPropMap_t::value_type(property, value));; 646 if (!pos.second) {; 647 Warning(""AddProperty"", ""Property \""%s\"" already exists with value %g"", property, (pos.first)->second);; 648 return false;; 649 }; 650 return true;; 651}; 652 ; 653////////////////////////////////////////////////////////////////////////////////; 654/// Get a user-defined property; 655 ; 656Double_t TGeoManager::GetProperty(const char *property, Bool_t *error) const; 657{; 658 auto pos = fProperties.find(property);; 659 if (pos == fProperties.end()) {; 660 if (error); 661 *error = kTRUE;; 662 return 0.;; 663 }; 664 if (error); 665 *error = kFALSE;; 666 return pos->second;; 667}; 668 ; 669////////////////////////////////////////////////////////////////////////////////; 670/// Get a user-defined property from a given index; 671 ; 672Double_t TGeoManager::GetProperty(size_t i, TString &name, Bool_t *error) const; 673{; 674 // This is a quite inefficient way to access map elements, but needed for the GDML writer to; 675 if (i >= fProperties.size()) {; 676 if (error); 677 *error = kTRUE;; 678 return 0.;; 679 }; 680 size_t pos = 0;; 681 auto it = fProperties.begin();; 682 while (pos < i) {; 683 ++it;; 684 ++pos;; 685 }; 686 if (error); 687 *error = kFALSE;; 688 name = (*it).first;; 689 return (*it).second;; 690}; 691 ; 692////////////////////////////////////////////////////////////////////////////////; 693/// Add a matrix to the list. Returns index of the matrix in list.; 694 ; 695Int_t TGeoManager::AddTransformation(const TGeoMatrix *matrix); 696{; 697 return TGeoBuilder::Instance(this)->AddTransformation((TGeoMatrix *)matrix);; 698}; 699 ; 700////////////////////////////////////////////////////////////////////////////////; 701/// Add a shape to the list. Returns index of the shape in list.; 702 ; 703Int_",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:25243,Availability,error,error,25243,"41/// Add a user-defined property. Returns true if added, false if existing.; 642 ; 643Bool_t TGeoManager::AddProperty(const char *property, Double_t value); 644{; 645 auto pos = fProperties.insert(ConstPropMap_t::value_type(property, value));; 646 if (!pos.second) {; 647 Warning(""AddProperty"", ""Property \""%s\"" already exists with value %g"", property, (pos.first)->second);; 648 return false;; 649 }; 650 return true;; 651}; 652 ; 653////////////////////////////////////////////////////////////////////////////////; 654/// Get a user-defined property; 655 ; 656Double_t TGeoManager::GetProperty(const char *property, Bool_t *error) const; 657{; 658 auto pos = fProperties.find(property);; 659 if (pos == fProperties.end()) {; 660 if (error); 661 *error = kTRUE;; 662 return 0.;; 663 }; 664 if (error); 665 *error = kFALSE;; 666 return pos->second;; 667}; 668 ; 669////////////////////////////////////////////////////////////////////////////////; 670/// Get a user-defined property from a given index; 671 ; 672Double_t TGeoManager::GetProperty(size_t i, TString &name, Bool_t *error) const; 673{; 674 // This is a quite inefficient way to access map elements, but needed for the GDML writer to; 675 if (i >= fProperties.size()) {; 676 if (error); 677 *error = kTRUE;; 678 return 0.;; 679 }; 680 size_t pos = 0;; 681 auto it = fProperties.begin();; 682 while (pos < i) {; 683 ++it;; 684 ++pos;; 685 }; 686 if (error); 687 *error = kFALSE;; 688 name = (*it).first;; 689 return (*it).second;; 690}; 691 ; 692////////////////////////////////////////////////////////////////////////////////; 693/// Add a matrix to the list. Returns index of the matrix in list.; 694 ; 695Int_t TGeoManager::AddTransformation(const TGeoMatrix *matrix); 696{; 697 return TGeoBuilder::Instance(this)->AddTransformation((TGeoMatrix *)matrix);; 698}; 699 ; 700////////////////////////////////////////////////////////////////////////////////; 701/// Add a shape to the list. Returns index of the shape in list.; 702 ; 703Int_",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:25513,Availability,error,error,25513,"41/// Add a user-defined property. Returns true if added, false if existing.; 642 ; 643Bool_t TGeoManager::AddProperty(const char *property, Double_t value); 644{; 645 auto pos = fProperties.insert(ConstPropMap_t::value_type(property, value));; 646 if (!pos.second) {; 647 Warning(""AddProperty"", ""Property \""%s\"" already exists with value %g"", property, (pos.first)->second);; 648 return false;; 649 }; 650 return true;; 651}; 652 ; 653////////////////////////////////////////////////////////////////////////////////; 654/// Get a user-defined property; 655 ; 656Double_t TGeoManager::GetProperty(const char *property, Bool_t *error) const; 657{; 658 auto pos = fProperties.find(property);; 659 if (pos == fProperties.end()) {; 660 if (error); 661 *error = kTRUE;; 662 return 0.;; 663 }; 664 if (error); 665 *error = kFALSE;; 666 return pos->second;; 667}; 668 ; 669////////////////////////////////////////////////////////////////////////////////; 670/// Get a user-defined property from a given index; 671 ; 672Double_t TGeoManager::GetProperty(size_t i, TString &name, Bool_t *error) const; 673{; 674 // This is a quite inefficient way to access map elements, but needed for the GDML writer to; 675 if (i >= fProperties.size()) {; 676 if (error); 677 *error = kTRUE;; 678 return 0.;; 679 }; 680 size_t pos = 0;; 681 auto it = fProperties.begin();; 682 while (pos < i) {; 683 ++it;; 684 ++pos;; 685 }; 686 if (error); 687 *error = kFALSE;; 688 name = (*it).first;; 689 return (*it).second;; 690}; 691 ; 692////////////////////////////////////////////////////////////////////////////////; 693/// Add a matrix to the list. Returns index of the matrix in list.; 694 ; 695Int_t TGeoManager::AddTransformation(const TGeoMatrix *matrix); 696{; 697 return TGeoBuilder::Instance(this)->AddTransformation((TGeoMatrix *)matrix);; 698}; 699 ; 700////////////////////////////////////////////////////////////////////////////////; 701/// Add a shape to the list. Returns index of the shape in list.; 702 ; 703Int_",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:25675,Availability,error,error,25675,"(!pos.second) {; 647 Warning(""AddProperty"", ""Property \""%s\"" already exists with value %g"", property, (pos.first)->second);; 648 return false;; 649 }; 650 return true;; 651}; 652 ; 653////////////////////////////////////////////////////////////////////////////////; 654/// Get a user-defined property; 655 ; 656Double_t TGeoManager::GetProperty(const char *property, Bool_t *error) const; 657{; 658 auto pos = fProperties.find(property);; 659 if (pos == fProperties.end()) {; 660 if (error); 661 *error = kTRUE;; 662 return 0.;; 663 }; 664 if (error); 665 *error = kFALSE;; 666 return pos->second;; 667}; 668 ; 669////////////////////////////////////////////////////////////////////////////////; 670/// Get a user-defined property from a given index; 671 ; 672Double_t TGeoManager::GetProperty(size_t i, TString &name, Bool_t *error) const; 673{; 674 // This is a quite inefficient way to access map elements, but needed for the GDML writer to; 675 if (i >= fProperties.size()) {; 676 if (error); 677 *error = kTRUE;; 678 return 0.;; 679 }; 680 size_t pos = 0;; 681 auto it = fProperties.begin();; 682 while (pos < i) {; 683 ++it;; 684 ++pos;; 685 }; 686 if (error); 687 *error = kFALSE;; 688 name = (*it).first;; 689 return (*it).second;; 690}; 691 ; 692////////////////////////////////////////////////////////////////////////////////; 693/// Add a matrix to the list. Returns index of the matrix in list.; 694 ; 695Int_t TGeoManager::AddTransformation(const TGeoMatrix *matrix); 696{; 697 return TGeoBuilder::Instance(this)->AddTransformation((TGeoMatrix *)matrix);; 698}; 699 ; 700////////////////////////////////////////////////////////////////////////////////; 701/// Add a shape to the list. Returns index of the shape in list.; 702 ; 703Int_t TGeoManager::AddShape(const TGeoShape *shape); 704{; 705 return TGeoBuilder::Instance(this)->AddShape((TGeoShape *)shape);; 706}; 707 ; 708////////////////////////////////////////////////////////////////////////////////; 709/// Add a track to the list",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:25688,Availability,error,error,25688,"(!pos.second) {; 647 Warning(""AddProperty"", ""Property \""%s\"" already exists with value %g"", property, (pos.first)->second);; 648 return false;; 649 }; 650 return true;; 651}; 652 ; 653////////////////////////////////////////////////////////////////////////////////; 654/// Get a user-defined property; 655 ; 656Double_t TGeoManager::GetProperty(const char *property, Bool_t *error) const; 657{; 658 auto pos = fProperties.find(property);; 659 if (pos == fProperties.end()) {; 660 if (error); 661 *error = kTRUE;; 662 return 0.;; 663 }; 664 if (error); 665 *error = kFALSE;; 666 return pos->second;; 667}; 668 ; 669////////////////////////////////////////////////////////////////////////////////; 670/// Get a user-defined property from a given index; 671 ; 672Double_t TGeoManager::GetProperty(size_t i, TString &name, Bool_t *error) const; 673{; 674 // This is a quite inefficient way to access map elements, but needed for the GDML writer to; 675 if (i >= fProperties.size()) {; 676 if (error); 677 *error = kTRUE;; 678 return 0.;; 679 }; 680 size_t pos = 0;; 681 auto it = fProperties.begin();; 682 while (pos < i) {; 683 ++it;; 684 ++pos;; 685 }; 686 if (error); 687 *error = kFALSE;; 688 name = (*it).first;; 689 return (*it).second;; 690}; 691 ; 692////////////////////////////////////////////////////////////////////////////////; 693/// Add a matrix to the list. Returns index of the matrix in list.; 694 ; 695Int_t TGeoManager::AddTransformation(const TGeoMatrix *matrix); 696{; 697 return TGeoBuilder::Instance(this)->AddTransformation((TGeoMatrix *)matrix);; 698}; 699 ; 700////////////////////////////////////////////////////////////////////////////////; 701/// Add a shape to the list. Returns index of the shape in list.; 702 ; 703Int_t TGeoManager::AddShape(const TGeoShape *shape); 704{; 705 return TGeoBuilder::Instance(this)->AddShape((TGeoShape *)shape);; 706}; 707 ; 708////////////////////////////////////////////////////////////////////////////////; 709/// Add a track to the list",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:25845,Availability,error,error,25845," }; 650 return true;; 651}; 652 ; 653////////////////////////////////////////////////////////////////////////////////; 654/// Get a user-defined property; 655 ; 656Double_t TGeoManager::GetProperty(const char *property, Bool_t *error) const; 657{; 658 auto pos = fProperties.find(property);; 659 if (pos == fProperties.end()) {; 660 if (error); 661 *error = kTRUE;; 662 return 0.;; 663 }; 664 if (error); 665 *error = kFALSE;; 666 return pos->second;; 667}; 668 ; 669////////////////////////////////////////////////////////////////////////////////; 670/// Get a user-defined property from a given index; 671 ; 672Double_t TGeoManager::GetProperty(size_t i, TString &name, Bool_t *error) const; 673{; 674 // This is a quite inefficient way to access map elements, but needed for the GDML writer to; 675 if (i >= fProperties.size()) {; 676 if (error); 677 *error = kTRUE;; 678 return 0.;; 679 }; 680 size_t pos = 0;; 681 auto it = fProperties.begin();; 682 while (pos < i) {; 683 ++it;; 684 ++pos;; 685 }; 686 if (error); 687 *error = kFALSE;; 688 name = (*it).first;; 689 return (*it).second;; 690}; 691 ; 692////////////////////////////////////////////////////////////////////////////////; 693/// Add a matrix to the list. Returns index of the matrix in list.; 694 ; 695Int_t TGeoManager::AddTransformation(const TGeoMatrix *matrix); 696{; 697 return TGeoBuilder::Instance(this)->AddTransformation((TGeoMatrix *)matrix);; 698}; 699 ; 700////////////////////////////////////////////////////////////////////////////////; 701/// Add a shape to the list. Returns index of the shape in list.; 702 ; 703Int_t TGeoManager::AddShape(const TGeoShape *shape); 704{; 705 return TGeoBuilder::Instance(this)->AddShape((TGeoShape *)shape);; 706}; 707 ; 708////////////////////////////////////////////////////////////////////////////////; 709/// Add a track to the list of tracks. Use this for primaries only. For secondaries,; 710/// add them to the parent track. The method create objects that are registered; 711",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:25858,Availability,error,error,25858," }; 650 return true;; 651}; 652 ; 653////////////////////////////////////////////////////////////////////////////////; 654/// Get a user-defined property; 655 ; 656Double_t TGeoManager::GetProperty(const char *property, Bool_t *error) const; 657{; 658 auto pos = fProperties.find(property);; 659 if (pos == fProperties.end()) {; 660 if (error); 661 *error = kTRUE;; 662 return 0.;; 663 }; 664 if (error); 665 *error = kFALSE;; 666 return pos->second;; 667}; 668 ; 669////////////////////////////////////////////////////////////////////////////////; 670/// Get a user-defined property from a given index; 671 ; 672Double_t TGeoManager::GetProperty(size_t i, TString &name, Bool_t *error) const; 673{; 674 // This is a quite inefficient way to access map elements, but needed for the GDML writer to; 675 if (i >= fProperties.size()) {; 676 if (error); 677 *error = kTRUE;; 678 return 0.;; 679 }; 680 size_t pos = 0;; 681 auto it = fProperties.begin();; 682 while (pos < i) {; 683 ++it;; 684 ++pos;; 685 }; 686 if (error); 687 *error = kFALSE;; 688 name = (*it).first;; 689 return (*it).second;; 690}; 691 ; 692////////////////////////////////////////////////////////////////////////////////; 693/// Add a matrix to the list. Returns index of the matrix in list.; 694 ; 695Int_t TGeoManager::AddTransformation(const TGeoMatrix *matrix); 696{; 697 return TGeoBuilder::Instance(this)->AddTransformation((TGeoMatrix *)matrix);; 698}; 699 ; 700////////////////////////////////////////////////////////////////////////////////; 701/// Add a shape to the list. Returns index of the shape in list.; 702 ; 703Int_t TGeoManager::AddShape(const TGeoShape *shape); 704{; 705 return TGeoBuilder::Instance(this)->AddShape((TGeoShape *)shape);; 706}; 707 ; 708////////////////////////////////////////////////////////////////////////////////; 709/// Add a track to the list of tracks. Use this for primaries only. For secondaries,; 710/// add them to the parent track. The method create objects that are registered; 711",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:66364,Availability,down,down,66364,"se();; 1769 if (fgVerboseLevel > 1 && fixrefs); 1770 Info(""CountLevels"", ""Fixing volume reference counts"");; 1771 TGeoNode *node;; 1772 Int_t maxlevel = 1;; 1773 Int_t maxnodes = fTopVolume->GetNdaughters();; 1774 Int_t maxvertices = 1;; 1775 while ((node = next())) {; 1776 if (fixrefs) {; 1777 node->GetVolume()->Grab();; 1778 for (Int_t ibit = 10; ibit < 14; ibit++) {; 1779 node->SetBit(BIT(ibit + 4), node->TestBit(BIT(ibit)));; 1780 // node->ResetBit(BIT(ibit)); // cannot overwrite old crap for reproducibility; 1781 }; 1782 }; 1783 if (node->GetNdaughters() > maxnodes); 1784 maxnodes = node->GetNdaughters();; 1785 if (next.GetLevel() > maxlevel); 1786 maxlevel = next.GetLevel();; 1787 if (node->GetVolume()->GetShape()->IsA() == TGeoXtru::Class()) {; 1788 TGeoXtru *xtru = (TGeoXtru *)node->GetVolume()->GetShape();; 1789 if (xtru->GetNvert() > maxvertices); 1790 maxvertices = xtru->GetNvert();; 1791 }; 1792 }; 1793 fgMaxLevel = maxlevel;; 1794 fgMaxDaughters = maxnodes;; 1795 fgMaxXtruVert = maxvertices;; 1796 if (fgVerboseLevel > 0); 1797 Info(""CountLevels"", ""max level = %d, max placements = %d"", fgMaxLevel, fgMaxDaughters);; 1798}; 1799 ; 1800////////////////////////////////////////////////////////////////////////////////; 1801/// Count the total number of nodes starting from a volume, nlevels down.; 1802 ; 1803Int_t TGeoManager::CountNodes(const TGeoVolume *vol, Int_t nlevels, Int_t option); 1804{; 1805 TGeoVolume *top;; 1806 if (!vol) {; 1807 top = fTopVolume;; 1808 } else {; 1809 top = (TGeoVolume *)vol;; 1810 }; 1811 Int_t count = top->CountNodes(nlevels, option);; 1812 return count;; 1813}; 1814 ; 1815////////////////////////////////////////////////////////////////////////////////; 1816/// Set default angles for a given view.; 1817 ; 1818void TGeoManager::DefaultAngles(); 1819{; 1820 if (fPainter); 1821 fPainter->DefaultAngles();; 1822}; 1823 ; 1824////////////////////////////////////////////////////////////////////////////////; 1825/// Draw current point in ",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:86774,Availability,down,down,86774,//////////////////////////////////////////////////////////; 2403/// Assign a given node to be checked for overlaps. Any other overlaps will be ignored.; 2404 ; 2405void TGeoManager::SetCheckedNode(TGeoNode *node); 2406{; 2407 GetGeomPainter()->SetCheckedNode(node);; 2408}; 2409 ; 2410////////////////////////////////////////////////////////////////////////////////; 2411/// Set the number of points to be generated on the shape outline when checking; 2412/// for overlaps.; 2413 ; 2414void TGeoManager::SetNmeshPoints(Int_t npoints); 2415{; 2416 GetGeomPainter()->SetNmeshPoints(npoints);; 2417}; 2418 ; 2419////////////////////////////////////////////////////////////////////////////////; 2420/// set drawing mode :; 2421/// - option=0 (default) all nodes drawn down to vislevel; 2422/// - option=1 leaves and nodes at vislevel drawn; 2423/// - option=2 path is drawn; 2424/// - option=4 visibility changed; 2425 ; 2426void TGeoManager::SetVisOption(Int_t option); 2427{; 2428 if ((option >= 0) && (option < 3)); 2429 fVisOption = option;; 2430 if (fPainter); 2431 fPainter->SetVisOption(option);; 2432}; 2433 ; 2434////////////////////////////////////////////////////////////////////////////////; 2435/// Set visualization option (leaves only OR all volumes); 2436 ; 2437void TGeoManager::ViewLeaves(Bool_t flag); 2438{; 2439 if (flag); 2440 SetVisOption(1);; 2441 else; 2442 SetVisOption(0);; 2443}; 2444 ; 2445////////////////////////////////////////////////////////////////////////////////; 2446/// Set density threshold. Volumes with densities lower than this become; 2447/// transparent.; 2448 ; 2449void TGeoManager::SetVisDensity(Double_t density); 2450{; 2451 fVisDensity = density;; 2452 if (fPainter); 2453 fPainter->ModifiedPad();; 2454}; 2455 ; 2456////////////////////////////////////////////////////////////////////////////////; 2457/// set default level down to which visualization is performed; 2458 ; 2459void TGeoManager::SetVisLevel(Int_t level); 2460{; 2461 if (level > 0) {; 2,MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:87882,Availability,down,down,87882," && (option < 3)); 2429 fVisOption = option;; 2430 if (fPainter); 2431 fPainter->SetVisOption(option);; 2432}; 2433 ; 2434////////////////////////////////////////////////////////////////////////////////; 2435/// Set visualization option (leaves only OR all volumes); 2436 ; 2437void TGeoManager::ViewLeaves(Bool_t flag); 2438{; 2439 if (flag); 2440 SetVisOption(1);; 2441 else; 2442 SetVisOption(0);; 2443}; 2444 ; 2445////////////////////////////////////////////////////////////////////////////////; 2446/// Set density threshold. Volumes with densities lower than this become; 2447/// transparent.; 2448 ; 2449void TGeoManager::SetVisDensity(Double_t density); 2450{; 2451 fVisDensity = density;; 2452 if (fPainter); 2453 fPainter->ModifiedPad();; 2454}; 2455 ; 2456////////////////////////////////////////////////////////////////////////////////; 2457/// set default level down to which visualization is performed; 2458 ; 2459void TGeoManager::SetVisLevel(Int_t level); 2460{; 2461 if (level > 0) {; 2462 fVisLevel = level;; 2463 fMaxVisNodes = 0;; 2464 if (fgVerboseLevel > 0); 2465 Info(""SetVisLevel"", ""Automatic visible depth disabled"");; 2466 if (fPainter); 2467 fPainter->CountVisibleNodes();; 2468 } else {; 2469 SetMaxVisNodes();; 2470 }; 2471}; 2472 ; 2473////////////////////////////////////////////////////////////////////////////////; 2474/// Sort overlaps by decreasing overlap distance. Extrusions comes first.; 2475 ; 2476void TGeoManager::SortOverlaps(); 2477{; 2478 fOverlaps->Sort();; 2479}; 2480 ; 2481////////////////////////////////////////////////////////////////////////////////; 2482/// Optimize voxelization type for all volumes. Save best choice in a macro.; 2483 ; 2484void TGeoManager::OptimizeVoxels(const char *filename); 2485{; 2486 if (!fTopNode) {; 2487 Error(""OptimizeVoxels"", ""Geometry must be closed first"");; 2488 return;; 2489 }; 2490 std::ofstream out;; 2491 TString fname = filename;; 2492 if (fname.IsNull()); 2493 fname = ""tgeovox.C"";; 2494 out.open(fname, ",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:90551,Availability,error,error,90551,"2509 out << "" // parse all voxelized volumes"" << std::endl;; 2510 TGeoVolume *vol = nullptr;; 2511 Bool_t cyltype;; 2512 TIter next(fVolumes);; 2513 while ((vol = (TGeoVolume *)next())) {; 2514 if (!vol->GetVoxels()); 2515 continue;; 2516 out << "" vol = gGeoManager->GetVolume(\"""" << vol->GetName() << ""\"");"" << std::endl;; 2517 cyltype = vol->OptimizeVoxels();; 2518 if (cyltype) {; 2519 out << "" vol->SetCylVoxels();"" << std::endl;; 2520 } else {; 2521 out << "" vol->SetCylVoxels(kFALSE);"" << std::endl;; 2522 }; 2523 }; 2524 out << ""}"" << std::endl;; 2525 out.close();; 2526}; 2527////////////////////////////////////////////////////////////////////////////////; 2528/// Parse a string boolean expression and do a syntax check. Find top; 2529/// level boolean operator and returns its type. Fill the two; 2530/// substrings to which this operator applies. The returned integer is :; 2531/// - -1 : parse error; 2532/// - 0 : no boolean operator; 2533/// - 1 : union - represented as '+' in expression; 2534/// - 2 : difference (subtraction) - represented as '-' in expression; 2535/// - 3 : intersection - represented as '*' in expression.; 2536/// Parentheses should be used to avoid ambiguities. For instance :; 2537/// - A+B-C will be interpreted as (A+B)-C which is not the same as A+(B-C); 2538/// eliminate not needed parentheses; 2539 ; 2540Int_t TGeoManager::Parse(const char *expr, TString &expr1, TString &expr2, TString &expr3); 2541{; 2542 TString startstr(expr);; 2543 Int_t len = startstr.Length();; 2544 Int_t i;; 2545 TString e0 = """";; 2546 expr3 = """";; 2547 // eliminate blanks; 2548 for (i = 0; i < len; i++) {; 2549 if (startstr(i) == ' '); 2550 continue;; 2551 e0 += startstr(i, 1);; 2552 }; 2553 Int_t level = 0;; 2554 Int_t levmin = 999;; 2555 Int_t boolop = 0;; 2556 Int_t indop = 0;; 2557 Int_t iloop = 1;; 2558 Int_t lastop = 0;; 2559 Int_t lastdp = 0;; 2560 Int_t lastpp = 0;; 2561 Bool_t foundmat = kFALSE;; 2562 // check/eliminate parentheses; 2563 while (iloop == 1) {",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:96484,Availability,down,downwards,96484,"<< bomby << "","" << bombz << "","" << bombr << "");""; 2696 << std::endl;; 2697 out << "" // iterate volumes container and set new attributes"" << std::endl;; 2698 // out << "" TIter next(gGeoManager->GetListOfVolumes());""<<std::endl;; 2699 TGeoVolume *vol = nullptr;; 2700 fTopNode->SaveAttributes(out);; 2701 ; 2702 TIter next(fVolumes);; 2703 while ((vol = (TGeoVolume *)next())) {; 2704 vol->SetVisStreamed(kFALSE);; 2705 }; 2706 out << "" // draw top volume with new settings"" << std::endl;; 2707 out << "" top->Draw();"" << std::endl;; 2708 out << "" gPad->x3d();"" << std::endl;; 2709 out << ""}"" << std::endl;; 2710 out.close();; 2711}; 2712 ; 2713////////////////////////////////////////////////////////////////////////////////; 2714/// Returns the deepest node containing fPoint, which must be set a priori.; 2715 ; 2716TGeoNode *TGeoManager::SearchNode(Bool_t downwards, const TGeoNode *skipnode); 2717{; 2718 return GetCurrentNavigator()->SearchNode(downwards, skipnode);; 2719}; 2720 ; 2721////////////////////////////////////////////////////////////////////////////////; 2722/// Cross next boundary and locate within current node; 2723/// The current point must be on the boundary of fCurrentNode.; 2724 ; 2725TGeoNode *TGeoManager::CrossBoundaryAndLocate(Bool_t downwards, TGeoNode *skipnode); 2726{; 2727 return GetCurrentNavigator()->CrossBoundaryAndLocate(downwards, skipnode);; 2728}; 2729 ; 2730////////////////////////////////////////////////////////////////////////////////; 2731/// Compute distance to next boundary within STEPMAX. If no boundary is found,; 2732/// propagate current point along current direction with fStep=STEPMAX. Otherwise; 2733/// propagate with fStep=SNEXT (distance to boundary) and locate/return the next; 2734/// node.; 2735 ; 2736TGeoNode *TGeoManager::FindNextBoundaryAndStep(Double_t stepmax, Bool_t compsafe); 2737{; 2738 return GetCurrentNavigator()->FindNextBoundaryAndStep(stepmax, compsafe);; 2739}; 2740 ; 2741//////////////////////////////////////////////",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:96575,Availability,down,downwards,96575,"<< bomby << "","" << bombz << "","" << bombr << "");""; 2696 << std::endl;; 2697 out << "" // iterate volumes container and set new attributes"" << std::endl;; 2698 // out << "" TIter next(gGeoManager->GetListOfVolumes());""<<std::endl;; 2699 TGeoVolume *vol = nullptr;; 2700 fTopNode->SaveAttributes(out);; 2701 ; 2702 TIter next(fVolumes);; 2703 while ((vol = (TGeoVolume *)next())) {; 2704 vol->SetVisStreamed(kFALSE);; 2705 }; 2706 out << "" // draw top volume with new settings"" << std::endl;; 2707 out << "" top->Draw();"" << std::endl;; 2708 out << "" gPad->x3d();"" << std::endl;; 2709 out << ""}"" << std::endl;; 2710 out.close();; 2711}; 2712 ; 2713////////////////////////////////////////////////////////////////////////////////; 2714/// Returns the deepest node containing fPoint, which must be set a priori.; 2715 ; 2716TGeoNode *TGeoManager::SearchNode(Bool_t downwards, const TGeoNode *skipnode); 2717{; 2718 return GetCurrentNavigator()->SearchNode(downwards, skipnode);; 2719}; 2720 ; 2721////////////////////////////////////////////////////////////////////////////////; 2722/// Cross next boundary and locate within current node; 2723/// The current point must be on the boundary of fCurrentNode.; 2724 ; 2725TGeoNode *TGeoManager::CrossBoundaryAndLocate(Bool_t downwards, TGeoNode *skipnode); 2726{; 2727 return GetCurrentNavigator()->CrossBoundaryAndLocate(downwards, skipnode);; 2728}; 2729 ; 2730////////////////////////////////////////////////////////////////////////////////; 2731/// Compute distance to next boundary within STEPMAX. If no boundary is found,; 2732/// propagate current point along current direction with fStep=STEPMAX. Otherwise; 2733/// propagate with fStep=SNEXT (distance to boundary) and locate/return the next; 2734/// node.; 2735 ; 2736TGeoNode *TGeoManager::FindNextBoundaryAndStep(Double_t stepmax, Bool_t compsafe); 2737{; 2738 return GetCurrentNavigator()->FindNextBoundaryAndStep(stepmax, compsafe);; 2739}; 2740 ; 2741//////////////////////////////////////////////",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:96890,Availability,down,downwards,96890,"xt())) {; 2704 vol->SetVisStreamed(kFALSE);; 2705 }; 2706 out << "" // draw top volume with new settings"" << std::endl;; 2707 out << "" top->Draw();"" << std::endl;; 2708 out << "" gPad->x3d();"" << std::endl;; 2709 out << ""}"" << std::endl;; 2710 out.close();; 2711}; 2712 ; 2713////////////////////////////////////////////////////////////////////////////////; 2714/// Returns the deepest node containing fPoint, which must be set a priori.; 2715 ; 2716TGeoNode *TGeoManager::SearchNode(Bool_t downwards, const TGeoNode *skipnode); 2717{; 2718 return GetCurrentNavigator()->SearchNode(downwards, skipnode);; 2719}; 2720 ; 2721////////////////////////////////////////////////////////////////////////////////; 2722/// Cross next boundary and locate within current node; 2723/// The current point must be on the boundary of fCurrentNode.; 2724 ; 2725TGeoNode *TGeoManager::CrossBoundaryAndLocate(Bool_t downwards, TGeoNode *skipnode); 2726{; 2727 return GetCurrentNavigator()->CrossBoundaryAndLocate(downwards, skipnode);; 2728}; 2729 ; 2730////////////////////////////////////////////////////////////////////////////////; 2731/// Compute distance to next boundary within STEPMAX. If no boundary is found,; 2732/// propagate current point along current direction with fStep=STEPMAX. Otherwise; 2733/// propagate with fStep=SNEXT (distance to boundary) and locate/return the next; 2734/// node.; 2735 ; 2736TGeoNode *TGeoManager::FindNextBoundaryAndStep(Double_t stepmax, Bool_t compsafe); 2737{; 2738 return GetCurrentNavigator()->FindNextBoundaryAndStep(stepmax, compsafe);; 2739}; 2740 ; 2741////////////////////////////////////////////////////////////////////////////////; 2742/// Find distance to next boundary and store it in fStep. Returns node to which this; 2743/// boundary belongs. If PATH is specified, compute only distance to the node to which; 2744/// PATH points. If STEPMAX is specified, compute distance only in case fSafety is smaller; 2745/// than this value. STEPMAX represent the step to ",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:96987,Availability,down,downwards,96987,"xt())) {; 2704 vol->SetVisStreamed(kFALSE);; 2705 }; 2706 out << "" // draw top volume with new settings"" << std::endl;; 2707 out << "" top->Draw();"" << std::endl;; 2708 out << "" gPad->x3d();"" << std::endl;; 2709 out << ""}"" << std::endl;; 2710 out.close();; 2711}; 2712 ; 2713////////////////////////////////////////////////////////////////////////////////; 2714/// Returns the deepest node containing fPoint, which must be set a priori.; 2715 ; 2716TGeoNode *TGeoManager::SearchNode(Bool_t downwards, const TGeoNode *skipnode); 2717{; 2718 return GetCurrentNavigator()->SearchNode(downwards, skipnode);; 2719}; 2720 ; 2721////////////////////////////////////////////////////////////////////////////////; 2722/// Cross next boundary and locate within current node; 2723/// The current point must be on the boundary of fCurrentNode.; 2724 ; 2725TGeoNode *TGeoManager::CrossBoundaryAndLocate(Bool_t downwards, TGeoNode *skipnode); 2726{; 2727 return GetCurrentNavigator()->CrossBoundaryAndLocate(downwards, skipnode);; 2728}; 2729 ; 2730////////////////////////////////////////////////////////////////////////////////; 2731/// Compute distance to next boundary within STEPMAX. If no boundary is found,; 2732/// propagate current point along current direction with fStep=STEPMAX. Otherwise; 2733/// propagate with fStep=SNEXT (distance to boundary) and locate/return the next; 2734/// node.; 2735 ; 2736TGeoNode *TGeoManager::FindNextBoundaryAndStep(Double_t stepmax, Bool_t compsafe); 2737{; 2738 return GetCurrentNavigator()->FindNextBoundaryAndStep(stepmax, compsafe);; 2739}; 2740 ; 2741////////////////////////////////////////////////////////////////////////////////; 2742/// Find distance to next boundary and store it in fStep. Returns node to which this; 2743/// boundary belongs. If PATH is specified, compute only distance to the node to which; 2744/// PATH points. If STEPMAX is specified, compute distance only in case fSafety is smaller; 2745/// than this value. STEPMAX represent the step to ",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:136961,Availability,error,errors,136961,"->Print();; 3722 }; 3723 return;; 3724 }; 3725 mat->SetMedia(imedia);; 3726 media[0] = imedia++;; 3727 mat->Print();; 3728 for (Int_t i=0; i<nmat; i++) {; 3729 mat = (TGeoMaterial*)fMaterials->At(i);; 3730 for (Int_t j=0; j<i; j++) {; 3731 matref = (TGeoMaterial*)fMaterials->At(j);; 3732 if (mat->IsEq(matref)) {; 3733 mat->SetMedia(media[j]);; 3734 break;; 3735 }; 3736 if (j==(i-1)) {; 3737 // different material; 3738 mat->SetMedia(imedia);; 3739 media[i] = imedia++;; 3740 mat->Print();; 3741 }; 3742 }; 3743 }; 3744 */; 3745}; 3746 ; 3747////////////////////////////////////////////////////////////////////////////////; 3748/// Check pushes and pulls needed to cross the next boundary with respect to the; 3749/// position given by FindNextBoundary. If radius is not mentioned the full bounding; 3750/// box will be sampled.; 3751 ; 3752void TGeoManager::CheckBoundaryErrors(Int_t ntracks, Double_t radius); 3753{; 3754 GetGeomPainter()->CheckBoundaryErrors(ntracks, radius);; 3755}; 3756 ; 3757////////////////////////////////////////////////////////////////////////////////; 3758/// Check the boundary errors reference file created by CheckBoundaryErrors method.; 3759/// The shape for which the crossing failed is drawn with the starting point in red; 3760/// and the extrapolated point to boundary (+/- failing push/pull) in yellow.; 3761 ; 3762void TGeoManager::CheckBoundaryReference(Int_t icheck); 3763{; 3764 GetGeomPainter()->CheckBoundaryReference(icheck);; 3765}; 3766 ; 3767////////////////////////////////////////////////////////////////////////////////; 3768/// Classify a given point. See TGeoChecker::CheckPoint().; 3769 ; 3770void TGeoManager::CheckPoint(Double_t x, Double_t y, Double_t z, Option_t *option, Double_t safety); 3771{; 3772 GetGeomPainter()->CheckPoint(x, y, z, option, safety);; 3773}; 3774 ; 3775////////////////////////////////////////////////////////////////////////////////; 3776/// Test for shape navigation methods. Summary for test numbers:; 3777/// - 1:",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:185095,Availability,down,downwards,185095,"id ClearOverlaps()Clear the list of overlaps.Definition TGeoManager.cxx:1605; TGeoManager::MakeConsTGeoVolume * MakeCons(const char *name, TGeoMedium *medium, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t phi1, Double_t phi2)Make in one step a volume pointing to a cone segment shape with given medium.Definition TGeoManager.cxx:3266; TGeoManager::fHashGVolumesTHashList * fHashGVolumeshash list of volumes providing fast searchDefinition TGeoManager.h:137; TGeoManager::fVisOptionInt_t fVisOptionDefinition TGeoManager.h:71; TGeoManager::fgMutexstatic std::mutex fgMutexDefinition TGeoManager.h:49; TGeoManager::IsInPhiRangeBool_t IsInPhiRange() constTrue if current node is in phi range.Definition TGeoManager.cxx:2834; TGeoManager::cdvirtual Bool_t cd(const char *path="""")Browse the tree of nodes starting from fTopNode according to pathname.Definition TGeoManager.cxx:1707; TGeoManager::SearchNodeTGeoNode * SearchNode(Bool_t downwards=kFALSE, const TGeoNode *skipnode=nullptr)Returns the deepest node containing fPoint, which must be set a priori.Definition TGeoManager.cxx:2716; TGeoManager::MaterialTGeoMaterial * Material(const char *name, Double_t a, Double_t z, Double_t dens, Int_t uid, Double_t radlen=0, Double_t intlen=0)Create material with given A, Z and density, having an unique id.Definition TGeoManager.cxx:1285; TGeoManager::LocalToMastervoid LocalToMaster(const Double_t *local, Double_t *master) constDefinition TGeoManager.h:526; TGeoManager::fPhiminDouble_t fPhiminDefinition TGeoManager.h:62; TGeoManager::fgLockNavigatorsstatic Bool_t fgLockNavigatorsNumber of registered threads.Definition TGeoManager.h:122; TGeoManager::SaveAttributesvoid SaveAttributes(const char *filename=""tgeoatt.C"")Save current attributes in a macro.Definition TGeoManager.cxx:2658; TGeoManager::RestoreMasterVolumevoid RestoreMasterVolume()Restore the master volume of the geometry.Definition TGeoManager.cxx:3118; TGeoManager::fDrawExtraBool_t fDrawExtraDe",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:192266,Availability,down,down,192266,"6; TGeoManager::ClearAttributesvoid ClearAttributes()Reset all attributes to default ones.Definition TGeoManager.cxx:1455; TGeoManager::fgMaxDaughtersstatic Int_t fgMaxDaughtersMaximum level in geometry.Definition TGeoManager.h:53; TGeoManager::fUsePWNavBool_t fUsePWNavRaytrace mode: 0=normal, 1=pass through, 2=transparent.Definition TGeoManager.h:147; TGeoManager::SetRTmodevoid SetRTmode(Int_t mode)Change raytracing mode.Definition TGeoManager.cxx:3108; TGeoManager::CheckPathBool_t CheckPath(const char *path) constCheck if a geometry path is valid without changing the state of the current navigator.Definition TGeoManager.cxx:1715; TGeoManager::InspectStatevoid InspectState() constInspects path and all flags for the current state.Definition TGeoManager.cxx:2873; TGeoManager::ConvertReflectionsvoid ConvertReflections()Convert all reflections in geometry to normal rotations + reflected shapes.Definition TGeoManager.cxx:1723; TGeoManager::SetVisLevelvoid SetVisLevel(Int_t level=3)set default level down to which visualization is performedDefinition TGeoManager.cxx:2459; TGeoManager::FindNextBoundaryTGeoNode * FindNextBoundary(Double_t stepmax=TGeoShape::Big(), const char *path="""", Bool_t frombdr=kFALSE)Find distance to next boundary and store it in fStep.Definition TGeoManager.cxx:2755; TGeoManager::Importstatic TGeoManager * Import(const char *filename, const char *name="""", Option_t *option="""")static function Import a geometry from a gdml or ROOT fileDefinition TGeoManager.cxx:4096; TGeoManager::MakePhysicalNodeTGeoPhysicalNode * MakePhysicalNode(const char *path=nullptr)Makes a physical node corresponding to a path.Definition TGeoManager.cxx:3506; TGeoManager::CountLevelsvoid CountLevels()Count maximum number of nodes per volume, maximum depth and maximum number of xtru vertices.Definition TGeoManager.cxx:1759; TGeoManager::fMaxThreadsInt_t fMaxThreadsDefinition TGeoManager.h:144; TGeoManager::fIsGeomReadingBool_t fIsGeomReadingDefinition TGeoManager.h:82; TGeoManager",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:204672,Availability,down,downwards,204672,"tion TGeoManager.cxx:2437; TGeoManager::MakeCtubTGeoVolume * MakeCtub(const char *name, TGeoMedium *medium, Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2, Double_t lx, Double_t ly, Double_t lz, Double_t tx, Double_t ty, Double_t tz)Make in one step a volume pointing to a tube segment shape with given medium.Definition TGeoManager.cxx:3247; TGeoManager::SetTminTmaxvoid SetTminTmax(Double_t tmin=0, Double_t tmax=999)Set time cut interval for drawing tracks.Definition TGeoManager.cxx:4242; TGeoManager::fNavigatorsNavigatorsMap_t fNavigatorsDefinition TGeoManager.h:119; TGeoManager::GetBranchNumbersvoid GetBranchNumbers(Int_t *copyNumbers, Int_t *volumeNumbers) constFill node copy numbers of current branch into an array.Definition TGeoManager.cxx:2079; TGeoManager::fPhiCutBool_t fPhiCutflag to notify that the manager is being destructedDefinition TGeoManager.h:84; TGeoManager::CrossBoundaryAndLocateTGeoNode * CrossBoundaryAndLocate(Bool_t downwards, TGeoNode *skipnode)Cross next boundary and locate within current node The current point must be on the boundary of fCurr...Definition TGeoManager.cxx:2725; TGeoManager::DrawTracksvoid DrawTracks(Option_t *option="""")Draw tracks over the geometry, according to option.Definition TGeoManager.cxx:1905; TGeoManager::Streamervoid Streamer(TBuffer &) overrideStream an object of class TGeoManager.Definition TGeoManager.cxx:3934; TGeoManager::BuildDefaultMaterialsvoid BuildDefaultMaterials()Now just a shortcut for GetElementTable.Definition TGeoManager.cxx:3615; TGeoManager::SetMaxThreadsvoid SetMaxThreads(Int_t nthreads)Set maximum number of threads for navigation.Definition TGeoManager.cxx:924; TGeoManager::MediumTGeoMedium * Medium(const char *name, Int_t numed, Int_t nmat, Int_t isvol, Int_t ifield, Double_t fieldm, Double_t tmaxfd, Double_t stemax, Double_t deemax, Double_t epsil, Double_t stmin)Create tracking medium.Definition TGeoManager.cxx:1331; TGeoManager::SetExplodedViewvoid SetExplodedView(Int_t",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:206651,Availability,error,error,206651,"xx:1331; TGeoManager::SetExplodedViewvoid SetExplodedView(Int_t iopt=0)Set type of exploding view (see TGeoPainter::SetExplodedView())Definition TGeoManager.cxx:3569; TGeoManager::WeightDouble_t Weight(Double_t precision=0.01, Option_t *option=""va"")Estimate weight of volume VOL with a precision SIGMA(W)/W better than PRECISION.Definition TGeoManager.cxx:3896; TGeoManager::ClearPhysicalNodesvoid ClearPhysicalNodes(Bool_t mustdelete=kFALSE)Clear the current list of physical nodes, so that we can start over with a new list.Definition TGeoManager.cxx:3542; TGeoManager::Parsestatic Int_t Parse(const char *expr, TString &expr1, TString &expr2, TString &expr3)Parse a string boolean expression and do a syntax check.Definition TGeoManager.cxx:2540; TGeoManager::GetBombFactorsvoid GetBombFactors(Double_t &bombx, Double_t &bomby, Double_t &bombz, Double_t &bombr) constRetrieve cartesian and radial bomb factors.Definition TGeoManager.cxx:2095; TGeoManager::GetPropertyDouble_t GetProperty(const char *name, Bool_t *error=nullptr) constGet a user-defined property.Definition TGeoManager.cxx:656; TGeoManager::fTracksTObjArray * fTrackslist of runtime volumesDefinition TGeoManager.h:99; TGeoManager::IsAnimatingTracksBool_t IsAnimatingTracks() constDefinition TGeoManager.h:388; TGeoManager::GetPathconst char * GetPath() constGet path to the current node in the form /node0/node1/...Definition TGeoManager.cxx:2881; TGeoManager::fgNumThreadsstatic Int_t fgNumThreadsThread id's map.Definition TGeoManager.h:121; TGeoManager::fGDMLMatricesTObjArray * fGDMLMatricesDefinition TGeoManager.h:101; TGeoManager::MakeAlignablePNTGeoPhysicalNode * MakeAlignablePN(const char *name)Make a physical node from the path pointed by an alignable object with a given name.Definition TGeoManager.cxx:3473; TGeoManager::SetCheckedNodevoid SetCheckedNode(TGeoNode *node)Assign a given node to be checked for overlaps. Any other overlaps will be ignored.Definition TGeoManager.cxx:2405; TGeoManager::AddOverlapInt_t Ad",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:210617,Availability,error,errors,210617,"tVerboseLevelstatic void SetVerboseLevel(Int_t vl)Return current verbosity level (static function).Definition TGeoManager.cxx:4074; TGeoManager::GetOpticalSurfaceTGeoOpticalSurface * GetOpticalSurface(const char *name) constGet optical surface with a given name;.Definition TGeoManager.cxx:2022; TGeoManager::SetNsegmentsvoid SetNsegments(Int_t nseg)Set number of segments for approximating circles in drawing.Definition TGeoManager.cxx:3594; TGeoManager::GetExportPrecisionstatic UInt_t GetExportPrecision()Definition TGeoManager.cxx:4341; TGeoManager::IsSamePointBool_t IsSamePoint(Double_t x, Double_t y, Double_t z) constCheck if a new point with given coordinates is the same as the last located one.Definition TGeoManager.cxx:2826; TGeoManager::SetNmeshPointsvoid SetNmeshPoints(Int_t npoints=1000)Set the number of points to be generated on the shape outline when checking for overlaps.Definition TGeoManager.cxx:2414; TGeoManager::CheckBoundaryReferencevoid CheckBoundaryReference(Int_t icheck=-1)Check the boundary errors reference file created by CheckBoundaryErrors method.Definition TGeoManager.cxx:3762; TGeoManager::GetVerboseLevelstatic Int_t GetVerboseLevel()Set verbosity level (static function).Definition TGeoManager.cxx:4066; TGeoManager::GetVisLevelInt_t GetVisLevel() constReturns current depth to which geometry is drawn.Definition TGeoManager.cxx:2149; TGeoManager::fgDefaultUnitsstatic EDefaultUnits fgDefaultUnitsPrecision to be used in ASCII exports.Definition TGeoManager.h:56; TGeoManager::Editvirtual void Edit(Option_t *option="""")Append a pad for this geometry.Definition TGeoManager.cxx:1051; TGeoManager::AddPropertyBool_t AddProperty(const char *property, Double_t value)Add a user-defined property. Returns true if added, false if existing.Definition TGeoManager.cxx:643; TGeoManager::~TGeoManager~TGeoManager() overrideDestructor.Definition TGeoManager.cxx:505; TGeoManager::fNodesTObjArray * fNodesDefinition TGeoManager.h:107; TGeoManager::CountNodesInt_t CountN",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:211729,Availability,down,down,211729,"ated by CheckBoundaryErrors method.Definition TGeoManager.cxx:3762; TGeoManager::GetVerboseLevelstatic Int_t GetVerboseLevel()Set verbosity level (static function).Definition TGeoManager.cxx:4066; TGeoManager::GetVisLevelInt_t GetVisLevel() constReturns current depth to which geometry is drawn.Definition TGeoManager.cxx:2149; TGeoManager::fgDefaultUnitsstatic EDefaultUnits fgDefaultUnitsPrecision to be used in ASCII exports.Definition TGeoManager.h:56; TGeoManager::Editvirtual void Edit(Option_t *option="""")Append a pad for this geometry.Definition TGeoManager.cxx:1051; TGeoManager::AddPropertyBool_t AddProperty(const char *property, Double_t value)Add a user-defined property. Returns true if added, false if existing.Definition TGeoManager.cxx:643; TGeoManager::~TGeoManager~TGeoManager() overrideDestructor.Definition TGeoManager.cxx:505; TGeoManager::fNodesTObjArray * fNodesDefinition TGeoManager.h:107; TGeoManager::CountNodesInt_t CountNodes(const TGeoVolume *vol=nullptr, Int_t nlevels=10000, Int_t option=0)Count the total number of nodes starting from a volume, nlevels down.Definition TGeoManager.cxx:1803; TGeoManager::GetMaterialTGeoMaterial * GetMaterial(const char *matname) constSearch for a named material. All trailing blanks stripped.Definition TGeoManager.cxx:3011; TGeoManager::CheckGeometryvoid CheckGeometry(Option_t *option="""")Perform last checks on the geometry.Definition TGeoManager.cxx:3831; TGeoManager::ExecuteEventvoid ExecuteEvent(Int_t event, Int_t px, Int_t py) overrideExecute mouse actions on this manager.Definition TGeoManager.cxx:3950; TGeoManager::MakeVolumeAssemblyTGeoVolumeAssembly * MakeVolumeAssembly(const char *name)Make an assembly of volumes.Definition TGeoManager.cxx:3553; TGeoManager::GetBombModeInt_t GetBombMode() constDefinition TGeoManager.h:210; TGeoManager::AddRegionInt_t AddRegion(TGeoRegion *region)Add a new region of volumes.Definition TGeoManager.cxx:633; TGeoManager::SelectTrackingMediavoid SelectTrackingMedia()Define different",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:223987,Availability,down,downwards,223987,"ial.cxx:1122; TGeoNavigatorArrayDefinition TGeoNavigator.h:294; TGeoNavigatorArray::AddNavigatorTGeoNavigator * AddNavigator()Add a new navigator to the array.Definition TGeoNavigator.cxx:2745; TGeoNavigatorArray::GetCurrentNavigatorTGeoNavigator * GetCurrentNavigator() constDefinition TGeoNavigator.h:308; TGeoNavigatorArray::SetCurrentNavigatorTGeoNavigator * SetCurrentNavigator(Int_t inav)Definition TGeoNavigator.h:309; TGeoNavigatorClass providing navigation API for TGeo geometries.Definition TGeoNavigator.h:32; TGeoNavigator::CdUpvoid CdUp()Go one level up in geometry.Definition TGeoNavigator.cxx:352; TGeoNavigator::DoBackupStatevoid DoBackupState()Backup the current state without affecting the cache stack.Definition TGeoNavigator.cxx:2648; TGeoNavigator::DoRestoreStatevoid DoRestoreState()Restore a backed-up state without affecting the cache stack.Definition TGeoNavigator.cxx:2657; TGeoNavigator::CrossBoundaryAndLocateTGeoNode * CrossBoundaryAndLocate(Bool_t downwards, TGeoNode *skipnode)Cross next boundary and locate within current node The current point must be on the boundary of fCurr...Definition TGeoNavigator.cxx:523; TGeoNavigator::GetHMatrixTGeoHMatrix * GetHMatrix()Return stored current matrix (global matrix of the next touched node).Definition TGeoNavigator.cxx:2670; TGeoNavigator::LocalToMastervoid LocalToMaster(const Double_t *local, Double_t *master) constDefinition TGeoNavigator.h:235; TGeoNavigator::CdNextvoid CdNext()Do a cd to the node found next by FindNextBoundary.Definition TGeoNavigator.cxx:405; TGeoNavigator::SafetyDouble_t Safety(Bool_t inside=kFALSE)Compute safe distance from the current point.Definition TGeoNavigator.cxx:1689; TGeoNavigator::GotoSafeLevelBool_t GotoSafeLevel()Go upwards the tree until a non-overlapping node.Definition TGeoNavigator.cxx:2357; TGeoNavigator::cdBool_t cd(const char *path="""")Browse the tree of nodes starting from top node according to pathname.Definition TGeoNavigator.cxx:210; TGeoNavigator::IsSameLocationBo",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:228053,Availability,down,downwards,228053,"624; TGeoNavigator::FindNodeTGeoNode * FindNode(Bool_t safe_start=kTRUE)Returns deepest node containing current point.Definition TGeoNavigator.cxx:1543; TGeoNavigator::FindNextBoundaryAndStepTGeoNode * FindNextBoundaryAndStep(Double_t stepmax=TGeoShape::Big(), Bool_t compsafe=kFALSE)Compute distance to next boundary within STEPMAX.Definition TGeoNavigator.cxx:1178; TGeoNavigator::CdTopvoid CdTop()Make top level node the current node.Definition TGeoNavigator.cxx:386; TGeoNavigator::GetCurrentNodeIdInt_t GetCurrentNodeId() constDefinition TGeoNavigator.h:160; TGeoNavigator::FindNormalFastDouble_t * FindNormalFast()Computes fast normal to next crossed boundary, assuming that the current point is close enough to the...Definition TGeoNavigator.cxx:1593; TGeoNavigator::GetBranchOnlysvoid GetBranchOnlys(Int_t *isonly) constFill node copy numbers of current branch into an array.Definition TGeoNavigator.cxx:452; TGeoNavigator::SearchNodeTGeoNode * SearchNode(Bool_t downwards=kFALSE, const TGeoNode *skipnode=nullptr)Returns the deepest node containing fPoint, which must be set a priori.Definition TGeoNavigator.cxx:1924; TGeoNavigator::CdNodevoid CdNode(Int_t nodeid)Change current path to point to the node having this id.Definition TGeoNavigator.cxx:301; TGeoNavigator::GetCacheTGeoNodeCache * GetCache() constDefinition TGeoNavigator.h:243; TGeoNavigator::ResetAllvoid ResetAll()Reset the navigator.Definition TGeoNavigator.cxx:2708; TGeoNavigator::IsSamePointBool_t IsSamePoint(Double_t x, Double_t y, Double_t z) constCheck if a new point with given coordinates is the same as the last located one.Definition TGeoNavigator.cxx:2634; TGeoNavigator::CdDownvoid CdDown(Int_t index)Make a daughter of current node current.Definition TGeoNavigator.cxx:313; TGeoNavigator::GetPathconst char * GetPath() constGet path to the current node in the form /node0/node1/...Definition TGeoNavigator.cxx:2682; TGeoNavigator::GetSafeLevelInt_t GetSafeLevel() constGo upwards the tree until a non-overlappin",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:235379,Availability,down,down,235379,"dium * GetMedium() constDefinition TGeoVolume.h:175; TGeoVolume::GetRefCountInt_t GetRefCount() constDefinition TGeoVolume.h:131; TGeoVolume::SortNodesvoid SortNodes()sort nodes by decreasing volume of the bounding box.Definition TGeoVolume.cxx:2080; TGeoVolume::Voxelizevoid Voxelize(Option_t *option)build the voxels for this volumeDefinition TGeoVolume.cxx:2464; TGeoVolume::IsRunTimeBool_t IsRunTime() constDefinition TGeoVolume.h:109; TGeoVolume::CreateThreadDatavirtual void CreateThreadData(Int_t nthreads)Definition TGeoVolume.cxx:435; TGeoVolume::GetByteCountvirtual Int_t GetByteCount() constget the total size in bytes for this volumeDefinition TGeoVolume.cxx:2204; TGeoVolume::OptimizeVoxelsBool_t OptimizeVoxels()Perform an extensive sampling to find which type of voxelization is most efficient.Definition TGeoVolume.cxx:1247; TGeoVolume::IsVolumeMultivirtual Bool_t IsVolumeMulti() constDefinition TGeoVolume.h:110; TGeoVolume::CountNodesInt_t CountNodes(Int_t nlevels=1000, Int_t option=0)Count total number of subnodes starting from this volume, nlevels down.Definition TGeoVolume.cxx:730; TGeoVolume::UnmarkSavedvoid UnmarkSaved()Reset SavePrimitive bits.Definition TGeoVolume.cxx:1699; TGeoVolume::SetFindervoid SetFinder(TGeoPatternFinder *finder)Definition TGeoVolume.h:244; TGeoVolume::GetNdaughtersInt_t GetNdaughters() constDefinition TGeoVolume.h:362; TGeoVolume::Grabvoid Grab()Definition TGeoVolume.h:136; TGeoVolume::Classstatic TClass * Class(); TGeoVolume::SetTransparencyvoid SetTransparency(Char_t transparency=0)Definition TGeoVolume.h:376; TGeoVolume::Releasevoid Release()Definition TGeoVolume.h:137; TGeoVolume::FindOverlapsvoid FindOverlaps() constloop all nodes marked as overlaps and find overlapping brothersDefinition TGeoVolume.cxx:2227; TGeoVolume::GetNodeTGeoNode * GetNode(const char *name) constget the pointer to a daughter nodeDefinition TGeoVolume.cxx:2193; TGeoVolume::SetMediumvirtual void SetMedium(TGeoMedium *medium)Definition TGeoVolume.h:242; T",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:242710,Availability,error,error,242710,":41; TObject::GetNamevirtual const char * GetName() constReturns name of object.Definition TObject.cxx:444; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::AppendPadvirtual void AppendPad(Option_t *option="""")Append graphics object to current pad.Definition TObject.cxx:190; TObject::Writevirtual Int_t Write(const char *name=nullptr, Int_t option=0, Int_t bufsize=0)Write this object to the current directory.Definition TObject.cxx:886; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::SetUniqueIDvirtual void SetUniqueID(UInt_t uid)Set the unique object id.Definition TObject.cxx:797; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TObject::Drawvirtual void Draw(Option_t *option="""")Default Draw method for all objects.Definition TObject.cxx:280; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TQObject::ConnectBool_t Connect(const char *signal, const char *receiver_class, void *receiver, const char *slot)Non-static method is used to connect from the signal of this object to the receiver slot.Definition TQObject.cxx:869; TSeqCollectionSequenceable collection abstract base class.Definition TSeqCollection.h:28; TSeqCollection::In",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:242846,Availability,error,error,242846,"_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::AppendPadvirtual void AppendPad(Option_t *option="""")Append graphics object to current pad.Definition TObject.cxx:190; TObject::Writevirtual Int_t Write(const char *name=nullptr, Int_t option=0, Int_t bufsize=0)Write this object to the current directory.Definition TObject.cxx:886; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::SetUniqueIDvirtual void SetUniqueID(UInt_t uid)Set the unique object id.Definition TObject.cxx:797; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TObject::Drawvirtual void Draw(Option_t *option="""")Default Draw method for all objects.Definition TObject.cxx:280; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TQObject::ConnectBool_t Connect(const char *signal, const char *receiver_class, void *receiver, const char *slot)Non-static method is used to connect from the signal of this object to the receiver slot.Definition TQObject.cxx:869; TSeqCollectionSequenceable collection abstract base class.Definition TSeqCollection.h:28; TSeqCollection::IndexOfvirtual Int_t IndexOf(const TObject *obj) constReturn index of object in collection.Definition TSeqCollection.cxx:30; TStringBas",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:11099,Deployability,update,updates,11099,"me is visualized. This is automatically set by; 179 TGeoVolume::DrawOnly() method; 180 ; 181#### opt=3 - only a given path is visualized. This is automatically set by; 182 TGeoVolume::DrawPath(const char *path) method; 183 ; 184 The current view can be exploded in cartesian, cylindrical or spherical; 185coordinates :; 186 TGeoManager::SetExplodedView(Int_t opt). Options may be :; 187- 0 - default (no bombing); 188- 1 - cartesian coordinates. The bomb factor on each axis can be set with; 189 TGeoManager::SetBombX(Double_t bomb) and corresponding Y and Z.; 190- 2 - bomb in cylindrical coordinates. Only the bomb factors on Z and R; 191 are considered; 192 \image html geom_frameexp.jpg; 193 ; 194- 3 - bomb in radial spherical coordinate : TGeoManager::SetBombR(); 195 ; 196Volumes themselves support different visualization settings :; 197 - TGeoVolume::SetVisibility() : set volume visibility.; 198 - TGeoVolume::VisibleDaughters() : set daughters visibility.; 199All these actions automatically updates the current view if any.; 200 ; 201### Checking the geometry; 202 ; 203 Several checking methods are accessible from the volume context menu. They; 204generally apply only to the visible parts of the drawn geometry in order to; 205ease geometry checking, and their implementation is in the TGeoChecker class; 206from the painting package.; 207 ; 208#### Checking a given point.; 209 Can be called from TGeoManager::CheckPoint(Double_t x, Double_t y, Double_t z).; 210This method is drawing the daughters of the volume containing the point one; 211level down, printing the path to the deepest physical node holding this point.; 212It also computes the closest distance to any boundary. The point will be drawn; 213in red, as well as a sphere having this closest distance as radius. In case a; 214non-zero distance is given by the user as fifth argument of CheckPoint, this; 215distance will be used as radius of the safety sphere.; 216 ; 217\image html geom_checkpoint.jpg; 218 ; 219#### Sho",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:36640,Deployability,update,updated,36640,"))); 976 vol->CreateThreadData(fMaxThreads);; 977 fgMutex.unlock();; 978}; 979 ; 980////////////////////////////////////////////////////////////////////////////////; 981/// Clear the current map of threads. This will be filled again by the calling; 982/// threads via ThreadId calls.; 983 ; 984void TGeoManager::ClearThreadsMap(); 985{; 986 if (gGeoManager && !gGeoManager->IsMultiThread()); 987 return;; 988 fgMutex.lock();; 989 if (!fgThreadId->empty()); 990 fgThreadId->clear();; 991 fgNumThreads = 0;; 992 fgMutex.unlock();; 993}; 994 ; 995////////////////////////////////////////////////////////////////////////////////; 996/// Translates the current thread id to an ordinal number. This can be used to; 997/// manage data which is specific for a given thread.; 998 ; 999Int_t TGeoManager::ThreadId(); 1000{; 1001 TTHREAD_TLS(Int_t) tid = -1;; 1002 Int_t ttid = tid; // TTHREAD_TLS_GET(Int_t,tid);; 1003 if (ttid > -1); 1004 return ttid;; 1005 if (gGeoManager && !gGeoManager->IsMultiThread()); 1006 return 0;; 1007 std::thread::id threadId = std::this_thread::get_id();; 1008 TGeoManager::ThreadsMapIt_t it = fgThreadId->find(threadId);; 1009 if (it != fgThreadId->end()); 1010 return it->second;; 1011 // Map needs to be updated.; 1012 fgMutex.lock();; 1013 (*fgThreadId)[threadId] = fgNumThreads;; 1014 tid = fgNumThreads; // TTHREAD_TLS_SET(Int_t,tid,fgNumThreads);; 1015 ttid = fgNumThreads++;; 1016 fgMutex.unlock();; 1017 return ttid;; 1018}; 1019 ; 1020////////////////////////////////////////////////////////////////////////////////; 1021/// Describe how to browse this object.; 1022 ; 1023void TGeoManager::Browse(TBrowser *b); 1024{; 1025 if (!b); 1026 return;; 1027 if (fMaterials); 1028 b->Add(fMaterials, ""Materials"");; 1029 if (fMedia); 1030 b->Add(fMedia, ""Media"");; 1031 if (fMatrices); 1032 b->Add(fMatrices, ""Local transformations"");; 1033 if (fOverlaps); 1034 b->Add(fOverlaps, ""Illegal overlaps"");; 1035 if (fTracks); 1036 b->Add(fTracks, ""Tracks"");; 1037 if (fMasterVolume);",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:48708,Deployability,continuous,continuous,48708," having an unique id.; 1304 ; 1305TGeoMaterial *; 1306TGeoManager::Mixture(const char *name, Double_t *a, Double_t *z, Double_t dens, Int_t nelem, Double_t *wmat, Int_t uid); 1307{; 1308 return TGeoBuilder::Instance(this)->Mixture(name, a, z, dens, nelem, wmat, uid);; 1309}; 1310 ; 1311////////////////////////////////////////////////////////////////////////////////; 1312/// Create tracking medium; 1313///; 1314/// - numed tracking medium number assigned; 1315/// - name tracking medium name; 1316/// - nmat material number; 1317/// - isvol sensitive volume flag; 1318/// - ifield magnetic field; 1319/// - fieldm max. field value (kilogauss); 1320/// - tmaxfd max. angle due to field (deg/step); 1321/// - stemax max. step allowed; 1322/// - deemax max. fraction of energy lost in a step; 1323/// - epsil tracking precision (cm); 1324/// - stmin min. step due to continuous processes (cm); 1325///; 1326/// - ifield = 0 if no magnetic field; ifield = -1 if user decision in guswim;; 1327/// - ifield = 1 if tracking performed with g3rkuta; ifield = 2 if tracking; 1328/// performed with g3helix; ifield = 3 if tracking performed with g3helx3.; 1329///; 1330 ; 1331TGeoMedium *TGeoManager::Medium(const char *name, Int_t numed, Int_t nmat, Int_t isvol, Int_t ifield, Double_t fieldm,; 1332 Double_t tmaxfd, Double_t stemax, Double_t deemax, Double_t epsil, Double_t stmin); 1333{; 1334 return TGeoBuilder::Instance(this)->Medium(name, numed, nmat, isvol, ifield, fieldm, tmaxfd, stemax, deemax, epsil,; 1335 stmin);; 1336}; 1337 ; 1338////////////////////////////////////////////////////////////////////////////////; 1339/// Create a node called `<name_nr>` pointing to the volume called `<name>`; 1340/// as daughter of the volume called `<mother>` (gspos). The relative matrix is; 1341/// made of : a translation (x,y,z) and a rotation matrix named `<matIROT>`.; 1342/// In case npar>0, create the volume to be positioned in mother, according; 1343/// its actual parameters (gsposp).; 1344/// - ",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:245518,Deployability,update,update,245518,"ceAllTString & ReplaceAll(const TString &s1, const TString &s2)Definition TString.h:704; TString::IsNullBool_t IsNull() constDefinition TString.h:414; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TVirtualGeoPainterAbstract class for geometry painters.Definition TVirtualGeoPainter.h:32; TVirtualGeoPainter::SamplePointsvirtual TGeoNode * SamplePoints(Int_t npoints, Double_t &dist, Double_t epsil, const char *g3path)=0; TVirtualGeoPainter::SetTopVisiblevirtual void SetTopVisible(Bool_t vis=kTRUE)=0; TVirtualGeoPainter::GetVisLevelvirtual Int_t GetVisLevel() const =0; TVirtualGeoPainter::Weightvirtual Double_t Weight(Double_t precision, Option_t *option=""v"")=0; TVirtualGeoPainter::CheckGeometryFullvirtual void CheckGeometryFull(Bool_t checkoverlaps=kTRUE, Bool_t checkcrossings=kTRUE, Int_t nrays=10000, const Double_t *vertex=nullptr)=0; TVirtualGeoPainter::DrawPathvirtual void DrawPath(const char *path, Option_t *option="""")=0; TVirtualGeoPainter::ModifiedPadvirtual void ModifiedPad(Bool_t update=kFALSE) const =0; TVirtualGeoPainter::SetCheckedNodevirtual void SetCheckedNode(TGeoNode *node)=0; TVirtualGeoPainter::GetViewAnglesvirtual void GetViewAngles(Double_t &, Double_t &, Double_t &)Definition TVirtualGeoPainter.h:94; TVirtualGeoPainter::AddTrackvirtual TVirtualGeoTrack * AddTrack(Int_t id, Int_t pdgcode, TObject *particle)=0; TVirtualGeoPainter::SetExplodedViewvirtual void SetExplodedView(Int_t iopt=0)=0; TVirtualGeoPainter::IsRaytracingvirtual Bool_t IsRaytracing() const =0; TVirtualGeoPainter::DrawCurrentPointvirtual void DrawCurrentPoint(Int_t color)=0; TVirtualGeoPainter::SetClippingShapevirtual void SetClippingShape(TGeoShape *shape)=0; TVirtualGeoPainter::TestOverlapsvirtual void TestOverlaps(const char *path)=0; TVirtua",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:48611,Energy Efficiency,energy,energy,48611,"////////////////////////////////////////////////////////////////////////; 1302/// Create mixture OR COMPOUND IMAT as composed by THE BASIC nelem; 1303/// materials defined by arrays A,Z and WMAT, having an unique id.; 1304 ; 1305TGeoMaterial *; 1306TGeoManager::Mixture(const char *name, Double_t *a, Double_t *z, Double_t dens, Int_t nelem, Double_t *wmat, Int_t uid); 1307{; 1308 return TGeoBuilder::Instance(this)->Mixture(name, a, z, dens, nelem, wmat, uid);; 1309}; 1310 ; 1311////////////////////////////////////////////////////////////////////////////////; 1312/// Create tracking medium; 1313///; 1314/// - numed tracking medium number assigned; 1315/// - name tracking medium name; 1316/// - nmat material number; 1317/// - isvol sensitive volume flag; 1318/// - ifield magnetic field; 1319/// - fieldm max. field value (kilogauss); 1320/// - tmaxfd max. angle due to field (deg/step); 1321/// - stemax max. step allowed; 1322/// - deemax max. fraction of energy lost in a step; 1323/// - epsil tracking precision (cm); 1324/// - stmin min. step due to continuous processes (cm); 1325///; 1326/// - ifield = 0 if no magnetic field; ifield = -1 if user decision in guswim;; 1327/// - ifield = 1 if tracking performed with g3rkuta; ifield = 2 if tracking; 1328/// performed with g3helix; ifield = 3 if tracking performed with g3helx3.; 1329///; 1330 ; 1331TGeoMedium *TGeoManager::Medium(const char *name, Int_t numed, Int_t nmat, Int_t isvol, Int_t ifield, Double_t fieldm,; 1332 Double_t tmaxfd, Double_t stemax, Double_t deemax, Double_t epsil, Double_t stmin); 1333{; 1334 return TGeoBuilder::Instance(this)->Medium(name, numed, nmat, isvol, ifield, fieldm, tmaxfd, stemax, deemax, epsil,; 1335 stmin);; 1336}; 1337 ; 1338////////////////////////////////////////////////////////////////////////////////; 1339/// Create a node called `<name_nr>` pointing to the volume called `<name>`; 1340/// as daughter of the volume called `<mother>` (gspos). The relative matrix is; 1341/// made of : a ",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:235107,Energy Efficiency,efficient,efficient,235107,"s volumeDefinition TGeoVolume.cxx:2347; TGeoVolume::SetNumbervoid SetNumber(Int_t number)Definition TGeoVolume.h:245; TGeoVolume::SetLineWidthvoid SetLineWidth(Width_t lwidth) overrideSet the line width.Definition TGeoVolume.cxx:2185; TGeoVolume::GetMediumTGeoMedium * GetMedium() constDefinition TGeoVolume.h:175; TGeoVolume::GetRefCountInt_t GetRefCount() constDefinition TGeoVolume.h:131; TGeoVolume::SortNodesvoid SortNodes()sort nodes by decreasing volume of the bounding box.Definition TGeoVolume.cxx:2080; TGeoVolume::Voxelizevoid Voxelize(Option_t *option)build the voxels for this volumeDefinition TGeoVolume.cxx:2464; TGeoVolume::IsRunTimeBool_t IsRunTime() constDefinition TGeoVolume.h:109; TGeoVolume::CreateThreadDatavirtual void CreateThreadData(Int_t nthreads)Definition TGeoVolume.cxx:435; TGeoVolume::GetByteCountvirtual Int_t GetByteCount() constget the total size in bytes for this volumeDefinition TGeoVolume.cxx:2204; TGeoVolume::OptimizeVoxelsBool_t OptimizeVoxels()Perform an extensive sampling to find which type of voxelization is most efficient.Definition TGeoVolume.cxx:1247; TGeoVolume::IsVolumeMultivirtual Bool_t IsVolumeMulti() constDefinition TGeoVolume.h:110; TGeoVolume::CountNodesInt_t CountNodes(Int_t nlevels=1000, Int_t option=0)Count total number of subnodes starting from this volume, nlevels down.Definition TGeoVolume.cxx:730; TGeoVolume::UnmarkSavedvoid UnmarkSaved()Reset SavePrimitive bits.Definition TGeoVolume.cxx:1699; TGeoVolume::SetFindervoid SetFinder(TGeoPatternFinder *finder)Definition TGeoVolume.h:244; TGeoVolume::GetNdaughtersInt_t GetNdaughters() constDefinition TGeoVolume.h:362; TGeoVolume::Grabvoid Grab()Definition TGeoVolume.h:136; TGeoVolume::Classstatic TClass * Class(); TGeoVolume::SetTransparencyvoid SetTransparency(Char_t transparency=0)Definition TGeoVolume.h:376; TGeoVolume::Releasevoid Release()Definition TGeoVolume.h:137; TGeoVolume::FindOverlapsvoid FindOverlaps() constloop all nodes marked as overlaps and find overlappin",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:9783,Integrability,depend,depending,9783,"ties of classes TGeoManager, TGeoVolume and TGeoNode can be called via the; 148context menu.; 149 ; 150\image html geom_browser.jpg; 151 ; 152### Drawing the geometry; 153 ; 154 Any logical volume can be drawn via TGeoVolume::Draw() member function.; 155This can be directly accessed from the context menu of the volume object; 156directly from the browser.; 157 There are several drawing options that can be set with; 158TGeoManager::SetVisOption(Int_t opt) method :; 159 ; 160#### opt=0; 161 only the content of the volume is drawn, N levels down (default N=3).; 162 This is the default behavior. The number of levels to be drawn can be changed; 163 via TGeoManager::SetVisLevel(Int_t level) method.; 164 ; 165\image html geom_frame0.jpg; 166 ; 167#### opt=1; 168 the final leaves (e.g. daughters with no containment) of the branch; 169 starting from volume are drawn down to the current number of levels.; 170 WARNING : This mode is memory consuming; 171 depending of the size of geometry, so drawing from top level within this mode; 172 should be handled with care for expensive geometries. In future there will be; 173 a limitation on the maximum number of nodes to be visualized.; 174 ; 175\image html geom_frame1.jpg; 176 ; 177#### opt=2; 178 only the clicked volume is visualized. This is automatically set by; 179 TGeoVolume::DrawOnly() method; 180 ; 181#### opt=3 - only a given path is visualized. This is automatically set by; 182 TGeoVolume::DrawPath(const char *path) method; 183 ; 184 The current view can be exploded in cartesian, cylindrical or spherical; 185coordinates :; 186 TGeoManager::SetExplodedView(Int_t opt). Options may be :; 187- 0 - default (no bombing); 188- 1 - cartesian coordinates. The bomb factor on each axis can be set with; 189 TGeoManager::SetBombX(Double_t bomb) and corresponding Y and Z.; 190- 2 - bomb in cylindrical coordinates. Only the bomb factors on Z and R; 191 are considered; 192 \image html geom_frameexp.jpg; 193 ; 194- 3 - bomb in radial spherica",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:41574,Integrability,depend,dependent,41574,"// VNEW instead. Returns number of occurrences changed.; 1124 ; 1125Int_t TGeoManager::ReplaceVolume(TGeoVolume *vorig, TGeoVolume *vnew); 1126{; 1127 Int_t nref = 0;; 1128 if (!vorig || !vnew); 1129 return nref;; 1130 TGeoMedium *morig = vorig->GetMedium();; 1131 Bool_t checkmed = kFALSE;; 1132 if (morig); 1133 checkmed = kTRUE;; 1134 TGeoMedium *mnew = vnew->GetMedium();; 1135 // Try to limit the damage produced by incorrect usage.; 1136 if (!mnew && !vnew->IsAssembly()) {; 1137 Error(""ReplaceVolume"", ""Replacement volume %s has no medium and it is not an assembly"", vnew->GetName());; 1138 return nref;; 1139 }; 1140 if (mnew && checkmed) {; 1141 if (mnew->GetId() != morig->GetId()); 1142 Warning(""ReplaceVolume"", ""Replacement volume %s has different medium than original volume %s"", vnew->GetName(),; 1143 vorig->GetName());; 1144 checkmed = kFALSE;; 1145 }; 1146 ; 1147 // Medium checking now performed only if replacement is an assembly and old volume a real one.; 1148 // Check result is dependent on positioning.; 1149 Int_t nvol = fVolumes->GetEntriesFast();; 1150 Int_t i, j, nd;; 1151 Int_t ierr = 0;; 1152 TGeoVolume *vol;; 1153 TGeoNode *node;; 1154 TGeoVoxelFinder *voxels;; 1155 for (i = 0; i < nvol; i++) {; 1156 vol = (TGeoVolume *)fVolumes->At(i);; 1157 if (!vol); 1158 continue;; 1159 if (vol == vorig || vol == vnew); 1160 continue;; 1161 nd = vol->GetNdaughters();; 1162 for (j = 0; j < nd; j++) {; 1163 node = vol->GetNode(j);; 1164 if (node->GetVolume() == vorig) {; 1165 if (checkmed) {; 1166 mnew = node->GetMotherVolume()->GetMedium();; 1167 if (mnew && mnew->GetId() != morig->GetId()); 1168 ierr++;; 1169 }; 1170 nref++;; 1171 if (node->IsOverlapping()) {; 1172 node->SetOverlapping(kFALSE);; 1173 Info(""ReplaceVolume"", ""%s replaced with assembly and declared NON-OVERLAPPING!"", node->GetName());; 1174 }; 1175 node->SetVolume(vnew);; 1176 voxels = node->GetMotherVolume()->GetVoxels();; 1177 if (voxels); 1178 voxels->SetNeedRebuild();; 1179 } else {; 1180 if (node-",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:116683,Integrability,rout,rout,116683,"End, the angles are expressed in degree; 3212 ; 3213TGeoVolume *TGeoManager::MakeTubs(const char *name, TGeoMedium *medium, Double_t rmin, Double_t rmax, Double_t dz,; 3214 Double_t phiStart, Double_t phiEnd); 3215{; 3216 return TGeoBuilder::Instance(this)->MakeTubs(name, medium, rmin, rmax, dz, phiStart, phiEnd);; 3217}; 3218 ; 3219////////////////////////////////////////////////////////////////////////////////; 3220/// Make in one step a volume pointing to a tube shape with given medium; 3221 ; 3222TGeoVolume *TGeoManager::MakeEltu(const char *name, TGeoMedium *medium, Double_t a, Double_t b, Double_t dz); 3223{; 3224 return TGeoBuilder::Instance(this)->MakeEltu(name, medium, a, b, dz);; 3225}; 3226 ; 3227////////////////////////////////////////////////////////////////////////////////; 3228/// Make in one step a volume pointing to a tube shape with given medium; 3229 ; 3230TGeoVolume *TGeoManager::MakeHype(const char *name, TGeoMedium *medium, Double_t rin, Double_t stin, Double_t rout,; 3231 Double_t stout, Double_t dz); 3232{; 3233 return TGeoBuilder::Instance(this)->MakeHype(name, medium, rin, stin, rout, stout, dz);; 3234}; 3235 ; 3236////////////////////////////////////////////////////////////////////////////////; 3237/// Make in one step a volume pointing to a tube shape with given medium; 3238 ; 3239TGeoVolume *TGeoManager::MakeParaboloid(const char *name, TGeoMedium *medium, Double_t rlo, Double_t rhi, Double_t dz); 3240{; 3241 return TGeoBuilder::Instance(this)->MakeParaboloid(name, medium, rlo, rhi, dz);; 3242}; 3243 ; 3244////////////////////////////////////////////////////////////////////////////////; 3245/// Make in one step a volume pointing to a tube segment shape with given medium; 3246 ; 3247TGeoVolume *TGeoManager::MakeCtub(const char *name, TGeoMedium *medium, Double_t rmin, Double_t rmax, Double_t dz,; 3248 Double_t phi1, Double_t phi2, Double_t lx, Double_t ly, Double_t lz, Double_t tx,; 3249 Double_t ty, Double_t tz); 3250{; 3251 return TGeoBu",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:116807,Integrability,rout,rout,116807,"Double_t rmin, Double_t rmax, Double_t dz,; 3214 Double_t phiStart, Double_t phiEnd); 3215{; 3216 return TGeoBuilder::Instance(this)->MakeTubs(name, medium, rmin, rmax, dz, phiStart, phiEnd);; 3217}; 3218 ; 3219////////////////////////////////////////////////////////////////////////////////; 3220/// Make in one step a volume pointing to a tube shape with given medium; 3221 ; 3222TGeoVolume *TGeoManager::MakeEltu(const char *name, TGeoMedium *medium, Double_t a, Double_t b, Double_t dz); 3223{; 3224 return TGeoBuilder::Instance(this)->MakeEltu(name, medium, a, b, dz);; 3225}; 3226 ; 3227////////////////////////////////////////////////////////////////////////////////; 3228/// Make in one step a volume pointing to a tube shape with given medium; 3229 ; 3230TGeoVolume *TGeoManager::MakeHype(const char *name, TGeoMedium *medium, Double_t rin, Double_t stin, Double_t rout,; 3231 Double_t stout, Double_t dz); 3232{; 3233 return TGeoBuilder::Instance(this)->MakeHype(name, medium, rin, stin, rout, stout, dz);; 3234}; 3235 ; 3236////////////////////////////////////////////////////////////////////////////////; 3237/// Make in one step a volume pointing to a tube shape with given medium; 3238 ; 3239TGeoVolume *TGeoManager::MakeParaboloid(const char *name, TGeoMedium *medium, Double_t rlo, Double_t rhi, Double_t dz); 3240{; 3241 return TGeoBuilder::Instance(this)->MakeParaboloid(name, medium, rlo, rhi, dz);; 3242}; 3243 ; 3244////////////////////////////////////////////////////////////////////////////////; 3245/// Make in one step a volume pointing to a tube segment shape with given medium; 3246 ; 3247TGeoVolume *TGeoManager::MakeCtub(const char *name, TGeoMedium *medium, Double_t rmin, Double_t rmax, Double_t dz,; 3248 Double_t phi1, Double_t phi2, Double_t lx, Double_t ly, Double_t lz, Double_t tx,; 3249 Double_t ty, Double_t tz); 3250{; 3251 return TGeoBuilder::Instance(this)->MakeCtub(name, medium, rmin, rmax, dz, phi1, phi2, lx, ly, lz, tx, ty, tz);; 3252}; 3253 ; 3254//////",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:148505,Integrability,message,messages,148505,"4033 }; 4034 return 0;; 4035}; 4036 ; 4037////////////////////////////////////////////////////////////////////////////////; 4038/// Lock current geometry so that no other geometry can be imported.; 4039 ; 4040void TGeoManager::LockGeometry(); 4041{; 4042 fgLock = kTRUE;; 4043}; 4044 ; 4045////////////////////////////////////////////////////////////////////////////////; 4046/// Unlock current geometry.; 4047 ; 4048void TGeoManager::UnlockGeometry(); 4049{; 4050 fgLock = kFALSE;; 4051}; 4052 ; 4053////////////////////////////////////////////////////////////////////////////////; 4054/// Check lock state.; 4055 ; 4056Bool_t TGeoManager::IsLocked(); 4057{; 4058 return fgLock;; 4059}; 4060 ; 4061////////////////////////////////////////////////////////////////////////////////; 4062/// Set verbosity level (static function).; 4063/// - 0 - suppress messages related to geom-painter visibility level; 4064/// - 1 - default value; 4065 ; 4066Int_t TGeoManager::GetVerboseLevel(); 4067{; 4068 return fgVerboseLevel;; 4069}; 4070 ; 4071////////////////////////////////////////////////////////////////////////////////; 4072/// Return current verbosity level (static function).; 4073 ; 4074void TGeoManager::SetVerboseLevel(Int_t vl); 4075{; 4076 fgVerboseLevel = vl;; 4077}; 4078 ; 4079////////////////////////////////////////////////////////////////////////////////; 4080/// static function; 4081/// Import a geometry from a gdml or ROOT file; 4082///; 4083/// - Case 1: gdml; 4084/// if filename ends with "".gdml"" the foreign geometry described with gdml; 4085/// is imported executing some python scripts in $ROOTSYS/gdml.; 4086/// NOTE that to use this option, the PYTHONPATH must be defined like; 4087/// export PYTHONPATH=$ROOTSYS/lib:$ROOTSYS/gdml; 4088///; 4089/// - Case 2: root file (.root) or root/xml file (.xml); 4090/// Import in memory from filename the geometry with key=name.; 4091/// if name="""" (default), the first TGeoManager object in the file is returned.; 4092///; 4093/// Note th",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:169542,Integrability,rout,rout,169542,"bl2, Double_t tl2, Double_t alpha2)Make in one step a volume pointing to a trapezoid shape with given medium.Definition TGeoBuilder.cxx:401; TGeoBuilder::AddShapeInt_t AddShape(TGeoShape *shape)Add a shape to the list. Returns index of the shape in list.Definition TGeoBuilder.cxx:116; TGeoBuilder::MakeTorusTGeoVolume * MakeTorus(const char *name, TGeoMedium *medium, Double_t r, Double_t rmin, Double_t rmax, Double_t phi1=0, Double_t dphi=360)Make in one step a volume pointing to a torus shape with given medium.Definition TGeoBuilder.cxx:204; TGeoBuilder::Instancestatic TGeoBuilder * Instance(TGeoManager *geom)Return pointer to singleton.Definition TGeoBuilder.cxx:73; TGeoBuilder::MakeEltuTGeoVolume * MakeEltu(const char *name, TGeoMedium *medium, Double_t a, Double_t b, Double_t dz)Make in one step a volume pointing to a tube shape with given medium.Definition TGeoBuilder.cxx:251; TGeoBuilder::MakeHypeTGeoVolume * MakeHype(const char *name, TGeoMedium *medium, Double_t rin, Double_t stin, Double_t rout, Double_t stout, Double_t dz)Make in one step a volume pointing to a tube shape with given medium.Definition TGeoBuilder.cxx:267; TGeoBuilder::MakeArb8TGeoVolume * MakeArb8(const char *name, TGeoMedium *medium, Double_t dz, Double_t *vertices=nullptr)Make an TGeoArb8 volume.Definition TGeoBuilder.cxx:145; TGeoBuilder::MaterialTGeoMaterial * Material(const char *name, Double_t a, Double_t z, Double_t dens, Int_t uid, Double_t radlen=0, Double_t intlen=0)Create material with given A, Z and density, having an unique id.Definition TGeoBuilder.cxx:508; TGeoBuilder::MakeTubeTGeoVolume * MakeTube(const char *name, TGeoMedium *medium, Double_t rmin, Double_t rmax, Double_t dz)Make in one step a volume pointing to a tube shape with given medium.Definition TGeoBuilder.cxx:215; TGeoBuilder::MakeParaTGeoVolume * MakePara(const char *name, TGeoMedium *medium, Double_t dx, Double_t dy, Double_t dz, Double_t alpha, Double_t theta, Double_t phi)Make in one step a volume pointing to a ",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:199878,Integrability,message,messages,199878,"tstatic Int_t fgMaxXtruVertMaximum number of daughters.Definition TGeoManager.h:54; TGeoManager::FindNodeTGeoNode * FindNode(Bool_t safe_start=kTRUE)Returns deepest node containing current point.Definition TGeoManager.cxx:2782; TGeoManager::GetVisOptionInt_t GetVisOption() constReturns current depth to which geometry is drawn.Definition TGeoManager.cxx:2157; TGeoManager::LockGeometrystatic void LockGeometry()Lock current geometry so that no other geometry can be imported.Definition TGeoManager.cxx:4040; TGeoManager::MakeBoxTGeoVolume * MakeBox(const char *name, TGeoMedium *medium, Double_t dx, Double_t dy, Double_t dz)Make in one step a volume pointing to a box shape with given medium.Definition TGeoManager.cxx:3169; TGeoManager::fNPNEIdInt_t fNPNEIdDefinition TGeoManager.h:141; TGeoManager::CheckShapevoid CheckShape(TGeoShape *shape, Int_t testNo, Int_t nsamples, Option_t *option)Test for shape navigation methods.Definition TGeoManager.cxx:3783; TGeoManager::fgMaxLevelstatic Int_t fgMaxLevelVerbosity level for Info messages (no IO).Definition TGeoManager.h:52; TGeoManager::fNpdgInt_t fNpdgcurrent trackDefinition TGeoManager.h:77; TGeoManager::PrintOverlapsvoid PrintOverlaps() constPrints the current list of overlaps.Definition TGeoManager.cxx:3881; TGeoManager::MakeTrd1TGeoVolume * MakeTrd1(const char *name, TGeoMedium *medium, Double_t dx1, Double_t dx2, Double_t dy, Double_t dz)Make in one step a volume pointing to a TGeoTrd1 shape with given medium.Definition TGeoManager.cxx:3293; TGeoManager::MakeSphereTGeoVolume * MakeSphere(const char *name, TGeoMedium *medium, Double_t rmin, Double_t rmax, Double_t themin=0, Double_t themax=180, Double_t phimin=0, Double_t phimax=360)Make in one step a volume pointing to a sphere shape with given medium.Definition TGeoManager.cxx:3186; TGeoManager::ResetUserDatavoid ResetUserData()Sets all pointers TGeoVolume::fField to NULL.Definition TGeoManager.cxx:3097; TGeoManager::FindVolumeFastTGeoVolume * FindVolumeFast(const char *n",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:218043,Integrability,rout,rout,218043,"er.cxx:3580; TGeoManager::fGLMatrixTGeoHMatrix * fGLMatrixDefinition TGeoManager.h:128; TGeoManager::fCurrentTrackTVirtualGeoTrack * fCurrentTrackDefinition TGeoManager.h:76; TGeoManager::fPdgNamesTObjArray * fPdgNamesDefinition TGeoManager.h:100; TGeoManager::DrawPathvoid DrawPath(const char *path, Option_t *option="""")Draw current path.Definition TGeoManager.cxx:1923; TGeoManager::GetListOfPhysicalNodesTObjArray * GetListOfPhysicalNodes()Definition TGeoManager.h:468; TGeoManager::ThreadIdstatic Int_t ThreadId()Translates the current thread id to an ordinal number.Definition TGeoManager.cxx:999; TGeoManager::SetCurrentNavigatorBool_t SetCurrentNavigator(Int_t index)Switch to another existing navigator for the calling thread.Definition TGeoManager.cxx:849; TGeoManager::SetTopVisiblevoid SetTopVisible(Bool_t vis=kTRUE)make top volume visible on screenDefinition TGeoManager.cxx:2396; TGeoManager::MakeHypeTGeoVolume * MakeHype(const char *name, TGeoMedium *medium, Double_t rin, Double_t stin, Double_t rout, Double_t stout, Double_t dz)Make in one step a volume pointing to a tube shape with given medium.Definition TGeoManager.cxx:3230; TGeoManager::MakeParaboloidTGeoVolume * MakeParaboloid(const char *name, TGeoMedium *medium, Double_t rlo, Double_t rhi, Double_t dz)Make in one step a volume pointing to a tube shape with given medium.Definition TGeoManager.cxx:3239; TGeoManager::AddShapeInt_t AddShape(const TGeoShape *shape)Add a shape to the list. Returns index of the shape in list.Definition TGeoManager.cxx:703; TGeoManager::SetMaxVisNodesvoid SetMaxVisNodes(Int_t maxnodes=10000)set the maximum number of visible nodes.Definition TGeoManager.cxx:2380; TGeoManager::CleanGarbagevoid CleanGarbage()Clean temporary volumes and shapes from garbage collection.Definition TGeoManager.cxx:1627; TGeoManager::Voxelizevoid Voxelize(Option_t *option=nullptr)Voxelize all non-divided volumes.Definition TGeoManager.cxx:3129; TGeoManager::GetVirtualLevelInt_t GetVirtualLevel()Find level ",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:231375,Integrability,wrap,wrapper,231375,"olume)Definition TGeoNode.h:117; TGeoNode::CheckShapesvoid CheckShapes()check for wrong parameters in shapesDefinition TGeoNode.cxx:329; TGeoNode::SetOverlappingvoid SetOverlapping(Bool_t flag=kTRUE)Definition TGeoNode.h:120; TGeoNode::GetNdaughtersInt_t GetNdaughters() constDefinition TGeoNode.h:91; TGeoNode::GetMatrixvirtual TGeoMatrix * GetMatrix() const =0; TGeoNode::SetVisibilityvoid SetVisibility(Bool_t vis=kTRUE) overrideSet visibility of the node (obsolete).Definition TGeoNode.cxx:718; TGeoNode::SetMotherVolumevoid SetMotherVolume(TGeoVolume *mother)Definition TGeoNode.h:125; TGeoNode::Classstatic TClass * Class(); TGeoNode::GetMotherVolumeTGeoVolume * GetMotherVolume() constDefinition TGeoNode.h:90; TGeoNode::SetNumbervoid SetNumber(Int_t number)Definition TGeoNode.h:118; TGeoNode::CheckOverlapsvoid CheckOverlaps(Double_t ovlp=0.1, Option_t *option="""")Check overlaps bigger than OVLP hierarchically, starting with this node.Definition TGeoNode.cxx:192; TGeoOpticalSurfaceThis is a wrapper class to G4OpticalSurface.Definition TGeoOpticalSurface.h:27; TGeoPNEntryThe knowledge of the path to the objects that need to be misaligned is essential since there is no ot...Definition TGeoPhysicalNode.h:100; TGeoPNEntry::SetPhysicalNodevoid SetPhysicalNode(TGeoPhysicalNode *node)Setter for the corresponding physical node.Definition TGeoPhysicalNode.cxx:618; TGeoParallelWorldBase class for a flat parallel geometry.Definition TGeoParallelWorld.h:23; TGeoParallelWorld::CloseGeometryBool_t CloseGeometry()The main geometry must be closed.Definition TGeoParallelWorld.cxx:165; TGeoParallelWorld::RefreshPhysicalNodesvoid RefreshPhysicalNodes()Refresh the node pointers and re-voxelize.Definition TGeoParallelWorld.cxx:198; TGeoParallelWorld::IsClosedBool_t IsClosed() constDefinition TGeoParallelWorld.h:143; TGeoPhysicalNodePhysical nodes are the actual 'touchable' objects in the geometry, representing a path of positioned ...Definition TGeoPhysicalNode.h:35; TGeoPhysicalNode::Refres",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:242007,Integrability,message,message,242007,"TObjArray::Deletevoid Delete(Option_t *option="""") overrideRemove all objects from the array AND delete all heap based objects.Definition TObjArray.cxx:356; TObjArray::AtTObject * At(Int_t idx) const overrideDefinition TObjArray.h:164; TObjArray::UncheckedAtTObject * UncheckedAt(Int_t i) constDefinition TObjArray.h:84; TObjArray::RemoveTObject * Remove(TObject *obj) overrideRemove object from array.Definition TObjArray.cxx:719; TObjArray::FindObjectTObject * FindObject(const char *name) const overrideFind an object in this collection using its name.Definition TObjArray.cxx:415; TObjArray::Addvoid Add(TObject *obj) overrideDefinition TObjArray.h:68; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::GetNamevirtual const char * GetName() constReturns name of object.Definition TObject.cxx:444; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::AppendPadvirtual void AppendPad(Option_t *option="""")Append graphics object to current pad.Definition TObject.cxx:190; TObject::Writevirtual Int_t Write(const char *name=nullptr, Int_t option=0, Int_t bufsize=0)Write this object to the current directory.Definition TObject.cxx:886; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::SetUniqueIDvirtual void SetUniqueID(UInt_t uid)Set the unique object id.Definition TObject.cxx:797; TOb",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:242716,Integrability,message,message,242716,":41; TObject::GetNamevirtual const char * GetName() constReturns name of object.Definition TObject.cxx:444; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::AppendPadvirtual void AppendPad(Option_t *option="""")Append graphics object to current pad.Definition TObject.cxx:190; TObject::Writevirtual Int_t Write(const char *name=nullptr, Int_t option=0, Int_t bufsize=0)Write this object to the current directory.Definition TObject.cxx:886; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::SetUniqueIDvirtual void SetUniqueID(UInt_t uid)Set the unique object id.Definition TObject.cxx:797; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TObject::Drawvirtual void Draw(Option_t *option="""")Default Draw method for all objects.Definition TObject.cxx:280; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TQObject::ConnectBool_t Connect(const char *signal, const char *receiver_class, void *receiver, const char *slot)Non-static method is used to connect from the signal of this object to the receiver slot.Definition TQObject.cxx:869; TSeqCollectionSequenceable collection abstract base class.Definition TSeqCollection.h:28; TSeqCollection::In",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:242852,Integrability,message,message,242852,"_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::AppendPadvirtual void AppendPad(Option_t *option="""")Append graphics object to current pad.Definition TObject.cxx:190; TObject::Writevirtual Int_t Write(const char *name=nullptr, Int_t option=0, Int_t bufsize=0)Write this object to the current directory.Definition TObject.cxx:886; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::SetUniqueIDvirtual void SetUniqueID(UInt_t uid)Set the unique object id.Definition TObject.cxx:797; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TObject::Drawvirtual void Draw(Option_t *option="""")Default Draw method for all objects.Definition TObject.cxx:280; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TQObject::ConnectBool_t Connect(const char *signal, const char *receiver_class, void *receiver, const char *slot)Non-static method is used to connect from the signal of this object to the receiver slot.Definition TQObject.cxx:869; TSeqCollectionSequenceable collection abstract base class.Definition TSeqCollection.h:28; TSeqCollection::IndexOfvirtual Int_t IndexOf(const TObject *obj) constReturn index of object in collection.Definition TSeqCollection.cxx:30; TStringBas",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:243336,Integrability,message,message,243336,"; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::SetUniqueIDvirtual void SetUniqueID(UInt_t uid)Set the unique object id.Definition TObject.cxx:797; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TObject::Drawvirtual void Draw(Option_t *option="""")Default Draw method for all objects.Definition TObject.cxx:280; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TQObject::ConnectBool_t Connect(const char *signal, const char *receiver_class, void *receiver, const char *slot)Non-static method is used to connect from the signal of this object to the receiver slot.Definition TQObject.cxx:869; TSeqCollectionSequenceable collection abstract base class.Definition TSeqCollection.h:28; TSeqCollection::IndexOfvirtual Int_t IndexOf(const TObject *obj) constReturn index of object in collection.Definition TSeqCollection.cxx:30; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::StripTSubString Strip(EStripType s=kTrailing, char c=' ') constReturn a substring of self stripped at beginning and/or end.Definition TString.cxx:1163; TString::Dataconst char * Data() constDefinition TString.h:376; TString::ReplaceAllTString & ReplaceAll(const TString &s1, const TStrin",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:4745,Modifiability,inherit,inherits,4745,"graph. Any volume in the logical graph; 63can become the actual top volume at run time (see TGeoManager::SetTopVolume()).; 64All functionalities of the modeler will behave in this case as if only the; 65corresponding branch starting from this volume is the registered geometry.; 66 ; 67\image html geom_graf.jpg; 68 ; 69 A given volume can be positioned several times in the geometry. A volume; 70can be divided according default or user-defined patterns, creating automatically; 71the list of division nodes inside. The elementary volumes created during the; 72dividing process follow the same scheme as usual volumes, therefore it is possible; 73to position further geometrical structures inside or to divide them further more; 74(see TGeoVolume::Divide()).; 75 ; 76 The primitive shapes supported by the package are basically the GEANT3; 77shapes (see class TGeoShape), arbitrary wedges with eight vertices on two parallel; 78planes. All basic primitives inherits from class TGeoBBox since the bounding box; 79of a solid is essential for the tracking algorithms. They also implement the; 80virtual methods defined in the virtual class TGeoShape (point and segment; 81classification). User-defined primitives can be directly plugged into the modeler; 82provided that they override these methods. Composite shapes will be soon supported; 83by the modeler. In order to build a TGeoCompositeShape, one will have to define; 84first the primitive components. The object that handle boolean; 85operations among components is called TGeoBoolCombinator and it has to be; 86constructed providing a string boolean expression between the components names.; 87 ; 88 ; 89## Example for building a simple geometry; 90 ; 91Begin_Macro(source); 92../../../tutorials/geom/rootgeom.C; 93End_Macro; 94 ; 95## TGeoManager - the manager class for the geometry package.; 96 ; 97 TGeoManager class is embedding all the API needed for building and tracking; 98a geometry. It defines a global pointer (gGeoManager) in order ",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:12882,Modifiability,enhance,enhance,12882,"s closest distance as radius. In case a; 214non-zero distance is given by the user as fifth argument of CheckPoint, this; 215distance will be used as radius of the safety sphere.; 216 ; 217\image html geom_checkpoint.jpg; 218 ; 219#### Shooting random points.; 220 Can be called from TGeoVolume::RandomPoints() (context menu function) and; 221it will draw this volume with current visualization settings. Random points; 222are generated in the bounding box of the top drawn volume. The points are; 223classified and drawn with the color of their deepest container. Only points; 224in visible nodes will be drawn.; 225 ; 226\image html geom_random1.jpg; 227 ; 228 ; 229#### Raytracing.; 230 Can be called from TGeoVolume::RandomRays() (context menu of volumes) and; 231will shoot rays from a given point in the local reference frame with random; 232directions. The intersections with displayed nodes will appear as segments; 233having the color of the touched node. Drawn geometry will be then made invisible; 234in order to enhance rays.; 235 ; 236\image html geom_random2.jpg; 237*/; 238 ; 239#include <cstdlib>; 240#include <iostream>; 241#include <fstream>; 242 ; 243#include ""TROOT.h""; 244#include ""TGeoManager.h""; 245#include ""TStyle.h""; 246#include ""TVirtualPad.h""; 247#include ""TBrowser.h""; 248#include ""TFile.h""; 249#include ""TKey.h""; 250#include ""THashList.h""; 251#include ""TClass.h""; 252#include ""ThreadLocalStorage.h""; 253#include ""TBufferText.h""; 254 ; 255#include ""TGeoVoxelFinder.h""; 256#include ""TGeoElement.h""; 257#include ""TGeoMaterial.h""; 258#include ""TGeoMedium.h""; 259#include ""TGeoMatrix.h""; 260#include ""TGeoNode.h""; 261#include ""TGeoPhysicalNode.h""; 262#include ""TGeoPara.h""; 263#include ""TGeoParaboloid.h""; 264#include ""TGeoTube.h""; 265#include ""TGeoEltu.h""; 266#include ""TGeoHype.h""; 267#include ""TGeoCone.h""; 268#include ""TGeoSphere.h""; 269#include ""TGeoArb8.h""; 270#include ""TGeoPgon.h""; 271#include ""TGeoTrd1.h""; 272#include ""TGeoTrd2.h""; 273#include ""TGeoTorus.h""; 274#inc",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:105390,Modifiability,plugin,plugin,105390,"mat->GetByteCount();; 2904 TIter next3(fMedia);; 2905 TGeoMedium *med;; 2906 while ((med = (TGeoMedium *)next3())); 2907 count += med->GetByteCount();; 2908 if (fgVerboseLevel > 0); 2909 Info(""GetByteCount"", ""Total size of logical tree : %i bytes"", count);; 2910 return count;; 2911}; 2912 ; 2913////////////////////////////////////////////////////////////////////////////////; 2914/// Make a default painter if none present. Returns pointer to it.; 2915 ; 2916TVirtualGeoPainter *TGeoManager::GetGeomPainter(); 2917{; 2918 if (!fPainter) {; 2919 const char *kind = gEnv->GetValue(""GeomPainter.Name"", """");; 2920 if (!kind || !*kind); 2921 kind = (gROOT->IsWebDisplay() && !gROOT->IsWebDisplayBatch()) ? ""web"" : ""root"";; 2922 if (auto h = gROOT->GetPluginManager()->FindHandler(""TVirtualGeoPainter"", kind)) {; 2923 if (h->LoadPlugin() == -1) {; 2924 Error(""GetGeomPainter"", ""could not load plugin for %s geo_painter"", kind);; 2925 return nullptr;; 2926 }; 2927 fPainter = (TVirtualGeoPainter *)h->ExecPlugin(1, this);; 2928 if (!fPainter) {; 2929 Error(""GetGeomPainter"", ""could not create %s geo_painter"", kind);; 2930 return nullptr;; 2931 }; 2932 } else {; 2933 Error(""GetGeomPainter"", ""not found plugin %s for geo_painter"", kind);; 2934 }; 2935 }; 2936 return fPainter;; 2937}; 2938 ; 2939////////////////////////////////////////////////////////////////////////////////; 2940/// Search for a named volume. All trailing blanks stripped.; 2941 ; 2942TGeoVolume *TGeoManager::GetVolume(const char *name) const; 2943{; 2944 TString sname = name;; 2945 sname = sname.Strip();; 2946 TGeoVolume *vol = (TGeoVolume *)fVolumes->FindObject(sname.Data());; 2947 return vol;; 2948}; 2949 ; 2950////////////////////////////////////////////////////////////////////////////////; 2951/// Fast search for a named volume. All trailing blanks stripped.; 2952 ; 2953TGeoVolume *TGeoManager::FindVolumeFast(const char *name, Bool_t multi); 2954{; 2955 if (!fHashVolumes) {; 2956 Int_t nvol = fVolumes->GetEntriesFast();;",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:105699,Modifiability,plugin,plugin,105699,"mat->GetByteCount();; 2904 TIter next3(fMedia);; 2905 TGeoMedium *med;; 2906 while ((med = (TGeoMedium *)next3())); 2907 count += med->GetByteCount();; 2908 if (fgVerboseLevel > 0); 2909 Info(""GetByteCount"", ""Total size of logical tree : %i bytes"", count);; 2910 return count;; 2911}; 2912 ; 2913////////////////////////////////////////////////////////////////////////////////; 2914/// Make a default painter if none present. Returns pointer to it.; 2915 ; 2916TVirtualGeoPainter *TGeoManager::GetGeomPainter(); 2917{; 2918 if (!fPainter) {; 2919 const char *kind = gEnv->GetValue(""GeomPainter.Name"", """");; 2920 if (!kind || !*kind); 2921 kind = (gROOT->IsWebDisplay() && !gROOT->IsWebDisplayBatch()) ? ""web"" : ""root"";; 2922 if (auto h = gROOT->GetPluginManager()->FindHandler(""TVirtualGeoPainter"", kind)) {; 2923 if (h->LoadPlugin() == -1) {; 2924 Error(""GetGeomPainter"", ""could not load plugin for %s geo_painter"", kind);; 2925 return nullptr;; 2926 }; 2927 fPainter = (TVirtualGeoPainter *)h->ExecPlugin(1, this);; 2928 if (!fPainter) {; 2929 Error(""GetGeomPainter"", ""could not create %s geo_painter"", kind);; 2930 return nullptr;; 2931 }; 2932 } else {; 2933 Error(""GetGeomPainter"", ""not found plugin %s for geo_painter"", kind);; 2934 }; 2935 }; 2936 return fPainter;; 2937}; 2938 ; 2939////////////////////////////////////////////////////////////////////////////////; 2940/// Search for a named volume. All trailing blanks stripped.; 2941 ; 2942TGeoVolume *TGeoManager::GetVolume(const char *name) const; 2943{; 2944 TString sname = name;; 2945 sname = sname.Strip();; 2946 TGeoVolume *vol = (TGeoVolume *)fVolumes->FindObject(sname.Data());; 2947 return vol;; 2948}; 2949 ; 2950////////////////////////////////////////////////////////////////////////////////; 2951/// Fast search for a named volume. All trailing blanks stripped.; 2952 ; 2953TGeoVolume *TGeoManager::FindVolumeFast(const char *name, Bool_t multi); 2954{; 2955 if (!fHashVolumes) {; 2956 Int_t nvol = fVolumes->GetEntriesFast();;",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:242562,Modifiability,inherit,inherits,242562,"this collection using its name.Definition TObjArray.cxx:415; TObjArray::Addvoid Add(TObject *obj) overrideDefinition TObjArray.h:68; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::GetNamevirtual const char * GetName() constReturns name of object.Definition TObject.cxx:444; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::AppendPadvirtual void AppendPad(Option_t *option="""")Append graphics object to current pad.Definition TObject.cxx:190; TObject::Writevirtual Int_t Write(const char *name=nullptr, Int_t option=0, Int_t bufsize=0)Write this object to the current directory.Definition TObject.cxx:886; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::SetUniqueIDvirtual void SetUniqueID(UInt_t uid)Set the unique object id.Definition TObject.cxx:797; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TObject::Drawvirtual void Draw(Option_t *option="""")Default Draw method for all objects.Definition TObject.cxx:280; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TQObject::ConnectBool_t Connect(const char *signal, const char *receiver_class, void *receiver, const char *slot)Non-static method is used to connect f",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:6516,Performance,cache,cache,6516,"etry; 90 ; 91Begin_Macro(source); 92../../../tutorials/geom/rootgeom.C; 93End_Macro; 94 ; 95## TGeoManager - the manager class for the geometry package.; 96 ; 97 TGeoManager class is embedding all the API needed for building and tracking; 98a geometry. It defines a global pointer (gGeoManager) in order to be fully; 99accessible from external code. The mechanism of handling multiple geometries; 100at the same time will be soon implemented.; 101 ; 102 TGeoManager is the owner of all geometry objects defined in a session,; 103therefore users must not try to control their deletion. It contains lists of; 104media, materials, transformations, shapes and volumes. Logical nodes (positioned; 105volumes) are created and destroyed by the TGeoVolume class. Physical; 106nodes and their global transformations are subjected to a caching mechanism; 107due to the sometimes very large memory requirements of logical graph expansion.; 108The caching mechanism is triggered by the total number of physical instances; 109of volumes and the cache manager is a client of TGeoManager. The manager class; 110also controls the painter client. This is linked with ROOT graphical libraries; 111loaded on demand in order to control visualization actions.; 112 ; 113## Rules for building a valid geometry; 114 ; 115 A given geometry can be built in various ways, but there are mandatory steps; 116that have to be followed in order to be validated by the modeler. There are; 117general rules : volumes needs media and shapes in order to be created,; 118both container and containee volumes must be created before linking them together,; 119and the relative transformation matrix must be provided. All branches must; 120have an upper link point otherwise they will not be considered as part of the; 121geometry. Visibility or tracking properties of volumes can be provided both; 122at build time or after geometry is closed, but global visualization settings; 123(see TGeoPainter class) should not be provided at build ",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:7532,Performance,load,loaded,7532,"ion.; 108The caching mechanism is triggered by the total number of physical instances; 109of volumes and the cache manager is a client of TGeoManager. The manager class; 110also controls the painter client. This is linked with ROOT graphical libraries; 111loaded on demand in order to control visualization actions.; 112 ; 113## Rules for building a valid geometry; 114 ; 115 A given geometry can be built in various ways, but there are mandatory steps; 116that have to be followed in order to be validated by the modeler. There are; 117general rules : volumes needs media and shapes in order to be created,; 118both container and containee volumes must be created before linking them together,; 119and the relative transformation matrix must be provided. All branches must; 120have an upper link point otherwise they will not be considered as part of the; 121geometry. Visibility or tracking properties of volumes can be provided both; 122at build time or after geometry is closed, but global visualization settings; 123(see TGeoPainter class) should not be provided at build time, otherwise the; 124drawing package will be loaded. There is also a list of specific rules :; 125positioned daughters should not extrude their mother or intersect with sisters; 126unless this is specified (see TGeoVolume::AddNodeOverlap()), the top volume; 127(containing all geometry tree) must be specified before closing the geometry; 128and must not be positioned - it represents the global reference frame. After; 129building the full geometry tree, the geometry must be closed; 130(see TGeoManager::CloseGeometry()). Voxelization can be redone per volume after; 131this process.; 132 ; 133 ; 134 Below is the general scheme of the manager class.; 135 ; 136\image html geom_mgr.jpg; 137 ; 138## An interactive session; 139 ; 140 Provided that a geometry was successfully built and closed (for instance the; 141previous example $ROOTSYS/tutorials/geom/rootgeom.C ), the manager class will register; 142itself to ROOT",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:39525,Performance,cache,cache,39525,"TGeoVolume *vol = (TGeoVolume *)obj;; 1064 vol->SetVisibility(vis);; 1065 } else {; 1066 if (obj->InheritsFrom(TGeoNode::Class())) {; 1067 TGeoNode *node = (TGeoNode *)obj;; 1068 node->SetVisibility(vis);; 1069 } else; 1070 return;; 1071 }; 1072 GetGeomPainter()->ModifiedPad(kTRUE);; 1073}; 1074 ; 1075////////////////////////////////////////////////////////////////////////////////; 1076/// Get the new 'bombed' translation vector according current exploded view mode.; 1077 ; 1078void TGeoManager::BombTranslation(const Double_t *tr, Double_t *bombtr); 1079{; 1080 if (fPainter); 1081 fPainter->BombTranslation(tr, bombtr);; 1082 return;; 1083}; 1084 ; 1085////////////////////////////////////////////////////////////////////////////////; 1086/// Get the new 'unbombed' translation vector according current exploded view mode.; 1087 ; 1088void TGeoManager::UnbombTranslation(const Double_t *tr, Double_t *bombtr); 1089{; 1090 if (fPainter); 1091 fPainter->UnbombTranslation(tr, bombtr);; 1092 return;; 1093}; 1094 ; 1095////////////////////////////////////////////////////////////////////////////////; 1096/// Backup the current state without affecting the cache stack.; 1097 ; 1098void TGeoManager::DoBackupState(); 1099{; 1100 GetCurrentNavigator()->DoBackupState();; 1101}; 1102 ; 1103////////////////////////////////////////////////////////////////////////////////; 1104/// Restore a backed-up state without affecting the cache stack.; 1105 ; 1106void TGeoManager::DoRestoreState(); 1107{; 1108 GetCurrentNavigator()->DoRestoreState();; 1109}; 1110 ; 1111////////////////////////////////////////////////////////////////////////////////; 1112/// Register a matrix to the list of matrices. It will be cleaned-up at the; 1113/// destruction TGeoManager.; 1114 ; 1115void TGeoManager::RegisterMatrix(const TGeoMatrix *matrix); 1116{; 1117 return TGeoBuilder::Instance(this)->RegisterMatrix((TGeoMatrix *)matrix);; 1118}; 1119 ; 1120//////////////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:39794,Performance,cache,cache,39794,"/////////////////////////////////////////////////////////////////////////////; 1076/// Get the new 'bombed' translation vector according current exploded view mode.; 1077 ; 1078void TGeoManager::BombTranslation(const Double_t *tr, Double_t *bombtr); 1079{; 1080 if (fPainter); 1081 fPainter->BombTranslation(tr, bombtr);; 1082 return;; 1083}; 1084 ; 1085////////////////////////////////////////////////////////////////////////////////; 1086/// Get the new 'unbombed' translation vector according current exploded view mode.; 1087 ; 1088void TGeoManager::UnbombTranslation(const Double_t *tr, Double_t *bombtr); 1089{; 1090 if (fPainter); 1091 fPainter->UnbombTranslation(tr, bombtr);; 1092 return;; 1093}; 1094 ; 1095////////////////////////////////////////////////////////////////////////////////; 1096/// Backup the current state without affecting the cache stack.; 1097 ; 1098void TGeoManager::DoBackupState(); 1099{; 1100 GetCurrentNavigator()->DoBackupState();; 1101}; 1102 ; 1103////////////////////////////////////////////////////////////////////////////////; 1104/// Restore a backed-up state without affecting the cache stack.; 1105 ; 1106void TGeoManager::DoRestoreState(); 1107{; 1108 GetCurrentNavigator()->DoRestoreState();; 1109}; 1110 ; 1111////////////////////////////////////////////////////////////////////////////////; 1112/// Register a matrix to the list of matrices. It will be cleaned-up at the; 1113/// destruction TGeoManager.; 1114 ; 1115void TGeoManager::RegisterMatrix(const TGeoMatrix *matrix); 1116{; 1117 return TGeoBuilder::Instance(this)->RegisterMatrix((TGeoMatrix *)matrix);; 1118}; 1119 ; 1120////////////////////////////////////////////////////////////////////////////////; 1121/// Replaces all occurrences of VORIG with VNEW in the geometry tree. The volume VORIG; 1122/// is not replaced from the list of volumes, but all node referencing it will reference; 1123/// VNEW instead. Returns number of occurrences changed.; 1124 ; 1125Int_t TGeoManager::ReplaceVolum",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:41477,Performance,perform,performed,41477,";; 1118}; 1119 ; 1120////////////////////////////////////////////////////////////////////////////////; 1121/// Replaces all occurrences of VORIG with VNEW in the geometry tree. The volume VORIG; 1122/// is not replaced from the list of volumes, but all node referencing it will reference; 1123/// VNEW instead. Returns number of occurrences changed.; 1124 ; 1125Int_t TGeoManager::ReplaceVolume(TGeoVolume *vorig, TGeoVolume *vnew); 1126{; 1127 Int_t nref = 0;; 1128 if (!vorig || !vnew); 1129 return nref;; 1130 TGeoMedium *morig = vorig->GetMedium();; 1131 Bool_t checkmed = kFALSE;; 1132 if (morig); 1133 checkmed = kTRUE;; 1134 TGeoMedium *mnew = vnew->GetMedium();; 1135 // Try to limit the damage produced by incorrect usage.; 1136 if (!mnew && !vnew->IsAssembly()) {; 1137 Error(""ReplaceVolume"", ""Replacement volume %s has no medium and it is not an assembly"", vnew->GetName());; 1138 return nref;; 1139 }; 1140 if (mnew && checkmed) {; 1141 if (mnew->GetId() != morig->GetId()); 1142 Warning(""ReplaceVolume"", ""Replacement volume %s has different medium than original volume %s"", vnew->GetName(),; 1143 vorig->GetName());; 1144 checkmed = kFALSE;; 1145 }; 1146 ; 1147 // Medium checking now performed only if replacement is an assembly and old volume a real one.; 1148 // Check result is dependent on positioning.; 1149 Int_t nvol = fVolumes->GetEntriesFast();; 1150 Int_t i, j, nd;; 1151 Int_t ierr = 0;; 1152 TGeoVolume *vol;; 1153 TGeoNode *node;; 1154 TGeoVoxelFinder *voxels;; 1155 for (i = 0; i < nvol; i++) {; 1156 vol = (TGeoVolume *)fVolumes->At(i);; 1157 if (!vol); 1158 continue;; 1159 if (vol == vorig || vol == vnew); 1160 continue;; 1161 nd = vol->GetNdaughters();; 1162 for (j = 0; j < nd; j++) {; 1163 node = vol->GetNode(j);; 1164 if (node->GetVolume() == vorig) {; 1165 if (checkmed) {; 1166 mnew = node->GetMotherVolume()->GetMedium();; 1167 if (mnew && mnew->GetId() != morig->GetId()); 1168 ierr++;; 1169 }; 1170 nref++;; 1171 if (node->IsOverlapping()) {; 1172 node->SetO",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:48861,Performance,perform,performed,48861," having an unique id.; 1304 ; 1305TGeoMaterial *; 1306TGeoManager::Mixture(const char *name, Double_t *a, Double_t *z, Double_t dens, Int_t nelem, Double_t *wmat, Int_t uid); 1307{; 1308 return TGeoBuilder::Instance(this)->Mixture(name, a, z, dens, nelem, wmat, uid);; 1309}; 1310 ; 1311////////////////////////////////////////////////////////////////////////////////; 1312/// Create tracking medium; 1313///; 1314/// - numed tracking medium number assigned; 1315/// - name tracking medium name; 1316/// - nmat material number; 1317/// - isvol sensitive volume flag; 1318/// - ifield magnetic field; 1319/// - fieldm max. field value (kilogauss); 1320/// - tmaxfd max. angle due to field (deg/step); 1321/// - stemax max. step allowed; 1322/// - deemax max. fraction of energy lost in a step; 1323/// - epsil tracking precision (cm); 1324/// - stmin min. step due to continuous processes (cm); 1325///; 1326/// - ifield = 0 if no magnetic field; ifield = -1 if user decision in guswim;; 1327/// - ifield = 1 if tracking performed with g3rkuta; ifield = 2 if tracking; 1328/// performed with g3helix; ifield = 3 if tracking performed with g3helx3.; 1329///; 1330 ; 1331TGeoMedium *TGeoManager::Medium(const char *name, Int_t numed, Int_t nmat, Int_t isvol, Int_t ifield, Double_t fieldm,; 1332 Double_t tmaxfd, Double_t stemax, Double_t deemax, Double_t epsil, Double_t stmin); 1333{; 1334 return TGeoBuilder::Instance(this)->Medium(name, numed, nmat, isvol, ifield, fieldm, tmaxfd, stemax, deemax, epsil,; 1335 stmin);; 1336}; 1337 ; 1338////////////////////////////////////////////////////////////////////////////////; 1339/// Create a node called `<name_nr>` pointing to the volume called `<name>`; 1340/// as daughter of the volume called `<mother>` (gspos). The relative matrix is; 1341/// made of : a translation (x,y,z) and a rotation matrix named `<matIROT>`.; 1342/// In case npar>0, create the volume to be positioned in mother, according; 1343/// its actual parameters (gsposp).; 1344/// - ",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:48917,Performance,perform,performed,48917," having an unique id.; 1304 ; 1305TGeoMaterial *; 1306TGeoManager::Mixture(const char *name, Double_t *a, Double_t *z, Double_t dens, Int_t nelem, Double_t *wmat, Int_t uid); 1307{; 1308 return TGeoBuilder::Instance(this)->Mixture(name, a, z, dens, nelem, wmat, uid);; 1309}; 1310 ; 1311////////////////////////////////////////////////////////////////////////////////; 1312/// Create tracking medium; 1313///; 1314/// - numed tracking medium number assigned; 1315/// - name tracking medium name; 1316/// - nmat material number; 1317/// - isvol sensitive volume flag; 1318/// - ifield magnetic field; 1319/// - fieldm max. field value (kilogauss); 1320/// - tmaxfd max. angle due to field (deg/step); 1321/// - stemax max. step allowed; 1322/// - deemax max. fraction of energy lost in a step; 1323/// - epsil tracking precision (cm); 1324/// - stmin min. step due to continuous processes (cm); 1325///; 1326/// - ifield = 0 if no magnetic field; ifield = -1 if user decision in guswim;; 1327/// - ifield = 1 if tracking performed with g3rkuta; ifield = 2 if tracking; 1328/// performed with g3helix; ifield = 3 if tracking performed with g3helx3.; 1329///; 1330 ; 1331TGeoMedium *TGeoManager::Medium(const char *name, Int_t numed, Int_t nmat, Int_t isvol, Int_t ifield, Double_t fieldm,; 1332 Double_t tmaxfd, Double_t stemax, Double_t deemax, Double_t epsil, Double_t stmin); 1333{; 1334 return TGeoBuilder::Instance(this)->Medium(name, numed, nmat, isvol, ifield, fieldm, tmaxfd, stemax, deemax, epsil,; 1335 stmin);; 1336}; 1337 ; 1338////////////////////////////////////////////////////////////////////////////////; 1339/// Create a node called `<name_nr>` pointing to the volume called `<name>`; 1340/// as daughter of the volume called `<mother>` (gspos). The relative matrix is; 1341/// made of : a translation (x,y,z) and a rotation matrix named `<matIROT>`.; 1342/// In case npar>0, create the volume to be positioned in mother, according; 1343/// its actual parameters (gsposp).; 1344/// - ",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:48964,Performance,perform,performed,48964," having an unique id.; 1304 ; 1305TGeoMaterial *; 1306TGeoManager::Mixture(const char *name, Double_t *a, Double_t *z, Double_t dens, Int_t nelem, Double_t *wmat, Int_t uid); 1307{; 1308 return TGeoBuilder::Instance(this)->Mixture(name, a, z, dens, nelem, wmat, uid);; 1309}; 1310 ; 1311////////////////////////////////////////////////////////////////////////////////; 1312/// Create tracking medium; 1313///; 1314/// - numed tracking medium number assigned; 1315/// - name tracking medium name; 1316/// - nmat material number; 1317/// - isvol sensitive volume flag; 1318/// - ifield magnetic field; 1319/// - fieldm max. field value (kilogauss); 1320/// - tmaxfd max. angle due to field (deg/step); 1321/// - stemax max. step allowed; 1322/// - deemax max. fraction of energy lost in a step; 1323/// - epsil tracking precision (cm); 1324/// - stmin min. step due to continuous processes (cm); 1325///; 1326/// - ifield = 0 if no magnetic field; ifield = -1 if user decision in guswim;; 1327/// - ifield = 1 if tracking performed with g3rkuta; ifield = 2 if tracking; 1328/// performed with g3helix; ifield = 3 if tracking performed with g3helx3.; 1329///; 1330 ; 1331TGeoMedium *TGeoManager::Medium(const char *name, Int_t numed, Int_t nmat, Int_t isvol, Int_t ifield, Double_t fieldm,; 1332 Double_t tmaxfd, Double_t stemax, Double_t deemax, Double_t epsil, Double_t stmin); 1333{; 1334 return TGeoBuilder::Instance(this)->Medium(name, numed, nmat, isvol, ifield, fieldm, tmaxfd, stemax, deemax, epsil,; 1335 stmin);; 1336}; 1337 ; 1338////////////////////////////////////////////////////////////////////////////////; 1339/// Create a node called `<name_nr>` pointing to the volume called `<name>`; 1340/// as daughter of the volume called `<mother>` (gspos). The relative matrix is; 1341/// made of : a translation (x,y,z) and a rotation matrix named `<matIROT>`.; 1342/// In case npar>0, create the volume to be positioned in mother, according; 1343/// its actual parameters (gsposp).; 1344/// - ",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:54981,Performance,cache,cache,54981,"ix->RegisterYourself();; 1438 }; 1439 TIter next4(fMatrices);; 1440 index = 1;; 1441 while ((matrix = (TGeoMatrix *)next4())) {; 1442 matrix->SetUniqueID(index++);; 1443 matrix->ResetBit(TGeoMatrix::kGeoSavePrimitive);; 1444 }; 1445 TIter next5(fVolumes);; 1446 TGeoVolume *vol;; 1447 while ((vol = (TGeoVolume *)next5())); 1448 vol->UnmarkSaved();; 1449}; 1450 ; 1451////////////////////////////////////////////////////////////////////////////////; 1452/// Reset all attributes to default ones. Default attributes for visualization; 1453/// are those defined before closing the geometry.; 1454 ; 1455void TGeoManager::ClearAttributes(); 1456{; 1457 if (gPad); 1458 delete gPad;; 1459 gPad = nullptr;; 1460 SetVisOption(0);; 1461 SetVisLevel(3);; 1462 SetExplodedView(0);; 1463 SetBombFactors();; 1464 if (!gStyle); 1465 return;; 1466 TIter next(fVolumes);; 1467 TGeoVolume *vol = nullptr;; 1468 while ((vol = (TGeoVolume *)next())) {; 1469 if (!vol->IsVisTouched()); 1470 continue;; 1471 vol->SetVisTouched(kFALSE);; 1472 }; 1473}; 1474////////////////////////////////////////////////////////////////////////////////; 1475/// Closing geometry implies checking the geometry validity, fixing shapes; 1476/// with negative parameters (run-time shapes)building the cache manager,; 1477/// voxelizing all volumes, counting the total number of physical nodes and; 1478/// registering the manager class to the browser.; 1479 ; 1480void TGeoManager::CloseGeometry(Option_t *option); 1481{; 1482 if (fClosed) {; 1483 Warning(""CloseGeometry"", ""geometry already closed"");; 1484 return;; 1485 }; 1486 if (!fMasterVolume) {; 1487 Error(""CloseGeometry"", ""you MUST call SetTopVolume() first !"");; 1488 return;; 1489 }; 1490 if (!gROOT->GetListOfGeometries()->FindObject(this)); 1491 gROOT->GetListOfGeometries()->Add(this);; 1492 if (!gROOT->GetListOfBrowsables()->FindObject(this)); 1493 gROOT->GetListOfBrowsables()->Add(this);; 1494 // TSeqCollection *brlist = gROOT->GetListOfBrowsers();; 1495 // TIter next(br",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:56221,Performance,load,loaded,56221,"istering the manager class to the browser.; 1479 ; 1480void TGeoManager::CloseGeometry(Option_t *option); 1481{; 1482 if (fClosed) {; 1483 Warning(""CloseGeometry"", ""geometry already closed"");; 1484 return;; 1485 }; 1486 if (!fMasterVolume) {; 1487 Error(""CloseGeometry"", ""you MUST call SetTopVolume() first !"");; 1488 return;; 1489 }; 1490 if (!gROOT->GetListOfGeometries()->FindObject(this)); 1491 gROOT->GetListOfGeometries()->Add(this);; 1492 if (!gROOT->GetListOfBrowsables()->FindObject(this)); 1493 gROOT->GetListOfBrowsables()->Add(this);; 1494 // TSeqCollection *brlist = gROOT->GetListOfBrowsers();; 1495 // TIter next(brlist);; 1496 // TBrowser *browser = 0;; 1497 // while ((browser=(TBrowser*)next())) browser->Refresh();; 1498 TString opt(option);; 1499 opt.ToLower();; 1500 // Bool_t dummy = opt.Contains(""d"");; 1501 Bool_t nodeid = opt.Contains(""i"");; 1502 // Create a geometry navigator if not present; 1503 TGeoNavigator *nav = nullptr;; 1504 Int_t nnavigators = 0;; 1505 // Check if the geometry is streamed from file; 1506 if (fIsGeomReading) {; 1507 if (fgVerboseLevel > 0); 1508 Info(""CloseGeometry"", ""Geometry loaded from file..."");; 1509 gGeoIdentity = (TGeoIdentity *)fMatrices->At(0);; 1510 if (!fElementTable); 1511 fElementTable = new TGeoElementTable(200);; 1512 if (!fTopNode) {; 1513 if (!fMasterVolume) {; 1514 Error(""CloseGeometry"", ""Master volume not streamed"");; 1515 return;; 1516 }; 1517 SetTopVolume(fMasterVolume);; 1518 if (fStreamVoxels && fgVerboseLevel > 0); 1519 Info(""CloseGeometry"", ""Voxelization retrieved from file"");; 1520 }; 1521 // Create a geometry navigator if not present; 1522 if (!GetCurrentNavigator()); 1523 fCurrentNavigator = AddNavigator();; 1524 nnavigators = GetListOfNavigators()->GetEntriesFast();; 1525 if (!opt.Contains(""nv"")) {; 1526 Voxelize(""ALL"");; 1527 }; 1528 CountLevels();; 1529 for (Int_t i = 0; i < nnavigators; i++) {; 1530 nav = (TGeoNavigator *)GetListOfNavigators()->At(i);; 1531 nav->GetCache()->BuildInfoBranch();; 153",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:58900,Performance,cache,cache,58900,"552 ; 1553 if (fgVerboseLevel > 0); 1554 Info(""CloseGeometry"", ""%i nodes/ %i volume UID's in %s"", fNNodes, fUniqueVolumes->GetEntriesFast() - 1,; 1555 GetTitle());; 1556 if (fgVerboseLevel > 0); 1557 Info(""CloseGeometry"", ""----------------modeler ready----------------"");; 1558 return;; 1559 }; 1560 ; 1561 // Create a geometry navigator if not present; 1562 if (!GetCurrentNavigator()); 1563 fCurrentNavigator = AddNavigator();; 1564 nnavigators = GetListOfNavigators()->GetEntriesFast();; 1565 SelectTrackingMedia();; 1566 CheckGeometry();; 1567 if (fgVerboseLevel > 0); 1568 Info(""CloseGeometry"", ""Counting nodes..."");; 1569 fNNodes = CountNodes();; 1570 fNLevel = fMasterVolume->CountNodes(1, 3) + 1;; 1571 if (fNLevel < 30); 1572 fNLevel = 100;; 1573 ; 1574 // BuildIdArray();; 1575 // avoid voxelization if requested to speed up geometry startup; 1576 if (!opt.Contains(""nv"")) {; 1577 Voxelize(""ALL"");; 1578 } else {; 1579 TGeoVolume *vol;; 1580 TIter next(fVolumes);; 1581 while ((vol = (TGeoVolume *)next())) {; 1582 vol->SortNodes();; 1583 }; 1584 }; 1585 if (fgVerboseLevel > 0); 1586 Info(""CloseGeometry"", ""Building cache..."");; 1587 CountLevels();; 1588 for (Int_t i = 0; i < nnavigators; i++) {; 1589 nav = (TGeoNavigator *)GetListOfNavigators()->At(i);; 1590 nav->GetCache()->BuildInfoBranch();; 1591 if (nodeid); 1592 nav->GetCache()->BuildIdArray();; 1593 }; 1594 fClosed = kTRUE;; 1595 if (fgVerboseLevel > 0) {; 1596 Info(""CloseGeometry"", ""%i nodes/ %i volume UID's in %s"", fNNodes, fUniqueVolumes->GetEntriesFast() - 1,; 1597 GetTitle());; 1598 Info(""CloseGeometry"", ""----------------modeler ready----------------"");; 1599 }; 1600}; 1601 ; 1602////////////////////////////////////////////////////////////////////////////////; 1603/// Clear the list of overlaps.; 1604 ; 1605void TGeoManager::ClearOverlaps(); 1606{; 1607 if (fOverlaps) {; 1608 fOverlaps->Delete();; 1609 delete fOverlaps;; 1610 }; 1611 fOverlaps = new TObjArray();; 1612}; 1613 ; 1614//////////////////////////////",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:61000,Performance,perform,performance,61000,"////////////////////////////////////////////; 1625/// Clean temporary volumes and shapes from garbage collection.; 1626 ; 1627void TGeoManager::CleanGarbage(); 1628{; 1629 if (!fGVolumes && !fGShapes); 1630 return;; 1631 Int_t i, nentries;; 1632 if (fGVolumes) {; 1633 nentries = fGVolumes->GetEntries();; 1634 TGeoVolume *vol = nullptr;; 1635 for (i = 0; i < nentries; i++) {; 1636 vol = (TGeoVolume *)fGVolumes->At(i);; 1637 if (vol); 1638 vol->SetFinder(nullptr);; 1639 }; 1640 fGVolumes->Delete();; 1641 delete fGVolumes;; 1642 fGVolumes = nullptr;; 1643 }; 1644 if (fGShapes) {; 1645 fGShapes->Delete();; 1646 delete fGShapes;; 1647 fGShapes = nullptr;; 1648 }; 1649}; 1650 ; 1651////////////////////////////////////////////////////////////////////////////////; 1652/// Change current path to point to the node having this id.; 1653/// Node id has to be in range : 0 to fNNodes-1 (no check for performance reasons); 1654 ; 1655void TGeoManager::CdNode(Int_t nodeid); 1656{; 1657 GetCurrentNavigator()->CdNode(nodeid);; 1658}; 1659 ; 1660////////////////////////////////////////////////////////////////////////////////; 1661/// Get the unique ID of the current node.; 1662 ; 1663Int_t TGeoManager::GetCurrentNodeId() const; 1664{; 1665 return GetCurrentNavigator()->GetCurrentNodeId();; 1666}; 1667 ; 1668////////////////////////////////////////////////////////////////////////////////; 1669/// Make top level node the current node. Updates the cache accordingly.; 1670/// Determine the overlapping state of current node.; 1671 ; 1672void TGeoManager::CdTop(); 1673{; 1674 GetCurrentNavigator()->CdTop();; 1675}; 1676 ; 1677////////////////////////////////////////////////////////////////////////////////; 1678/// Go one level up in geometry. Updates cache accordingly.; 1679/// Determine the overlapping state of current node.; 1680 ; 1681void TGeoManager::CdUp(); 1682{; 1683 GetCurrentNavigator()->CdUp();; 1684}; 1685 ; 1686/////////////////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:61550,Performance,cache,cache,61550,inder(nullptr);; 1639 }; 1640 fGVolumes->Delete();; 1641 delete fGVolumes;; 1642 fGVolumes = nullptr;; 1643 }; 1644 if (fGShapes) {; 1645 fGShapes->Delete();; 1646 delete fGShapes;; 1647 fGShapes = nullptr;; 1648 }; 1649}; 1650 ; 1651////////////////////////////////////////////////////////////////////////////////; 1652/// Change current path to point to the node having this id.; 1653/// Node id has to be in range : 0 to fNNodes-1 (no check for performance reasons); 1654 ; 1655void TGeoManager::CdNode(Int_t nodeid); 1656{; 1657 GetCurrentNavigator()->CdNode(nodeid);; 1658}; 1659 ; 1660////////////////////////////////////////////////////////////////////////////////; 1661/// Get the unique ID of the current node.; 1662 ; 1663Int_t TGeoManager::GetCurrentNodeId() const; 1664{; 1665 return GetCurrentNavigator()->GetCurrentNodeId();; 1666}; 1667 ; 1668////////////////////////////////////////////////////////////////////////////////; 1669/// Make top level node the current node. Updates the cache accordingly.; 1670/// Determine the overlapping state of current node.; 1671 ; 1672void TGeoManager::CdTop(); 1673{; 1674 GetCurrentNavigator()->CdTop();; 1675}; 1676 ; 1677////////////////////////////////////////////////////////////////////////////////; 1678/// Go one level up in geometry. Updates cache accordingly.; 1679/// Determine the overlapping state of current node.; 1680 ; 1681void TGeoManager::CdUp(); 1682{; 1683 GetCurrentNavigator()->CdUp();; 1684}; 1685 ; 1686////////////////////////////////////////////////////////////////////////////////; 1687/// Make a daughter of current node current. Can be called only with a valid; 1688/// daughter index (no check). Updates cache accordingly.; 1689 ; 1690void TGeoManager::CdDown(Int_t index); 1691{; 1692 GetCurrentNavigator()->CdDown(index);; 1693}; 1694 ; 1695////////////////////////////////////////////////////////////////////////////////; 1696/// Do a cd to the node found next by FindNextBoundary; 1697 ; 1698void TGeoManager::CdN,MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:61856,Performance,cache,cache,61856,//////; 1652/// Change current path to point to the node having this id.; 1653/// Node id has to be in range : 0 to fNNodes-1 (no check for performance reasons); 1654 ; 1655void TGeoManager::CdNode(Int_t nodeid); 1656{; 1657 GetCurrentNavigator()->CdNode(nodeid);; 1658}; 1659 ; 1660////////////////////////////////////////////////////////////////////////////////; 1661/// Get the unique ID of the current node.; 1662 ; 1663Int_t TGeoManager::GetCurrentNodeId() const; 1664{; 1665 return GetCurrentNavigator()->GetCurrentNodeId();; 1666}; 1667 ; 1668////////////////////////////////////////////////////////////////////////////////; 1669/// Make top level node the current node. Updates the cache accordingly.; 1670/// Determine the overlapping state of current node.; 1671 ; 1672void TGeoManager::CdTop(); 1673{; 1674 GetCurrentNavigator()->CdTop();; 1675}; 1676 ; 1677////////////////////////////////////////////////////////////////////////////////; 1678/// Go one level up in geometry. Updates cache accordingly.; 1679/// Determine the overlapping state of current node.; 1680 ; 1681void TGeoManager::CdUp(); 1682{; 1683 GetCurrentNavigator()->CdUp();; 1684}; 1685 ; 1686////////////////////////////////////////////////////////////////////////////////; 1687/// Make a daughter of current node current. Can be called only with a valid; 1688/// daughter index (no check). Updates cache accordingly.; 1689 ; 1690void TGeoManager::CdDown(Int_t index); 1691{; 1692 GetCurrentNavigator()->CdDown(index);; 1693}; 1694 ; 1695////////////////////////////////////////////////////////////////////////////////; 1696/// Do a cd to the node found next by FindNextBoundary; 1697 ; 1698void TGeoManager::CdNext(); 1699{; 1700 GetCurrentNavigator()->CdNext();; 1701}; 1702 ; 1703////////////////////////////////////////////////////////////////////////////////; 1704/// Browse the tree of nodes starting from fTopNode according to pathname.; 1705/// Changes the path accordingly.; 1706 ; 1707Bool_t TGeoManager::cd(co,MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:62240,Performance,cache,cache,62240,que ID of the current node.; 1662 ; 1663Int_t TGeoManager::GetCurrentNodeId() const; 1664{; 1665 return GetCurrentNavigator()->GetCurrentNodeId();; 1666}; 1667 ; 1668////////////////////////////////////////////////////////////////////////////////; 1669/// Make top level node the current node. Updates the cache accordingly.; 1670/// Determine the overlapping state of current node.; 1671 ; 1672void TGeoManager::CdTop(); 1673{; 1674 GetCurrentNavigator()->CdTop();; 1675}; 1676 ; 1677////////////////////////////////////////////////////////////////////////////////; 1678/// Go one level up in geometry. Updates cache accordingly.; 1679/// Determine the overlapping state of current node.; 1680 ; 1681void TGeoManager::CdUp(); 1682{; 1683 GetCurrentNavigator()->CdUp();; 1684}; 1685 ; 1686////////////////////////////////////////////////////////////////////////////////; 1687/// Make a daughter of current node current. Can be called only with a valid; 1688/// daughter index (no check). Updates cache accordingly.; 1689 ; 1690void TGeoManager::CdDown(Int_t index); 1691{; 1692 GetCurrentNavigator()->CdDown(index);; 1693}; 1694 ; 1695////////////////////////////////////////////////////////////////////////////////; 1696/// Do a cd to the node found next by FindNextBoundary; 1697 ; 1698void TGeoManager::CdNext(); 1699{; 1700 GetCurrentNavigator()->CdNext();; 1701}; 1702 ; 1703////////////////////////////////////////////////////////////////////////////////; 1704/// Browse the tree of nodes starting from fTopNode according to pathname.; 1705/// Changes the path accordingly.; 1706 ; 1707Bool_t TGeoManager::cd(const char *path); 1708{; 1709 return GetCurrentNavigator()->cd(path);; 1710}; 1711 ; 1712////////////////////////////////////////////////////////////////////////////////; 1713/// Check if a geometry path is valid without changing the state of the current navigator.; 1714 ; 1715Bool_t TGeoManager::CheckPath(const char *path) const; 1716{; 1717 return GetCurrentNavigator()->CheckPath(,MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:87913,Performance,perform,performed,87913," && (option < 3)); 2429 fVisOption = option;; 2430 if (fPainter); 2431 fPainter->SetVisOption(option);; 2432}; 2433 ; 2434////////////////////////////////////////////////////////////////////////////////; 2435/// Set visualization option (leaves only OR all volumes); 2436 ; 2437void TGeoManager::ViewLeaves(Bool_t flag); 2438{; 2439 if (flag); 2440 SetVisOption(1);; 2441 else; 2442 SetVisOption(0);; 2443}; 2444 ; 2445////////////////////////////////////////////////////////////////////////////////; 2446/// Set density threshold. Volumes with densities lower than this become; 2447/// transparent.; 2448 ; 2449void TGeoManager::SetVisDensity(Double_t density); 2450{; 2451 fVisDensity = density;; 2452 if (fPainter); 2453 fPainter->ModifiedPad();; 2454}; 2455 ; 2456////////////////////////////////////////////////////////////////////////////////; 2457/// set default level down to which visualization is performed; 2458 ; 2459void TGeoManager::SetVisLevel(Int_t level); 2460{; 2461 if (level > 0) {; 2462 fVisLevel = level;; 2463 fMaxVisNodes = 0;; 2464 if (fgVerboseLevel > 0); 2465 Info(""SetVisLevel"", ""Automatic visible depth disabled"");; 2466 if (fPainter); 2467 fPainter->CountVisibleNodes();; 2468 } else {; 2469 SetMaxVisNodes();; 2470 }; 2471}; 2472 ; 2473////////////////////////////////////////////////////////////////////////////////; 2474/// Sort overlaps by decreasing overlap distance. Extrusions comes first.; 2475 ; 2476void TGeoManager::SortOverlaps(); 2477{; 2478 fOverlaps->Sort();; 2479}; 2480 ; 2481////////////////////////////////////////////////////////////////////////////////; 2482/// Optimize voxelization type for all volumes. Save best choice in a macro.; 2483 ; 2484void TGeoManager::OptimizeVoxels(const char *filename); 2485{; 2486 if (!fTopNode) {; 2487 Error(""OptimizeVoxels"", ""Geometry must be closed first"");; 2488 return;; 2489 }; 2490 std::ofstream out;; 2491 TString fname = filename;; 2492 if (fname.IsNull()); 2493 fname = ""tgeovox.C"";; 2494 out.open(fname, ",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:89443,Performance,optimiz,optimization,89443,"r(""OptimizeVoxels"", ""Geometry must be closed first"");; 2488 return;; 2489 }; 2490 std::ofstream out;; 2491 TString fname = filename;; 2492 if (fname.IsNull()); 2493 fname = ""tgeovox.C"";; 2494 out.open(fname, std::ios::out);; 2495 if (!out.good()) {; 2496 Error(""OptimizeVoxels"", ""cannot open file"");; 2497 return;; 2498 }; 2499 // write header; 2500 TDatime t;; 2501 TString sname(fname);; 2502 sname.ReplaceAll("".C"", """");; 2503 out << sname.Data() << ""()"" << std::endl;; 2504 out << ""{"" << std::endl;; 2505 out << ""//=== Macro generated by ROOT version "" << gROOT->GetVersion() << "" : "" << t.AsString() << std::endl;; 2506 out << ""//=== Voxel optimization for "" << GetTitle() << "" geometry"" << std::endl;; 2507 out << ""//===== <run this macro JUST BEFORE closing the geometry>"" << std::endl;; 2508 out << "" TGeoVolume *vol = 0;"" << std::endl;; 2509 out << "" // parse all voxelized volumes"" << std::endl;; 2510 TGeoVolume *vol = nullptr;; 2511 Bool_t cyltype;; 2512 TIter next(fVolumes);; 2513 while ((vol = (TGeoVolume *)next())) {; 2514 if (!vol->GetVoxels()); 2515 continue;; 2516 out << "" vol = gGeoManager->GetVolume(\"""" << vol->GetName() << ""\"");"" << std::endl;; 2517 cyltype = vol->OptimizeVoxels();; 2518 if (cyltype) {; 2519 out << "" vol->SetCylVoxels();"" << std::endl;; 2520 } else {; 2521 out << "" vol->SetCylVoxels(kFALSE);"" << std::endl;; 2522 }; 2523 }; 2524 out << ""}"" << std::endl;; 2525 out.close();; 2526}; 2527////////////////////////////////////////////////////////////////////////////////; 2528/// Parse a string boolean expression and do a syntax check. Find top; 2529/// level boolean operator and returns its type. Fill the two; 2530/// substrings to which this operator applies. The returned integer is :; 2531/// - -1 : parse error; 2532/// - 0 : no boolean operator; 2533/// - 1 : union - represented as '+' in expression; 2534/// - 2 : difference (subtraction) - represented as '-' in expression; 2535/// - 3 : intersection - represented as '*' in expression.; 2536/// Pare",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:94660,Performance,load,loading,94660,"< std::endl;; 2678 out << ""{"" << std::endl;; 2679 out << ""//=== Macro generated by ROOT version "" << gROOT->GetVersion() << "" : "" << t.AsString() << std::endl;; 2680 out << ""//=== Attributes for "" << GetTitle() << "" geometry"" << std::endl;; 2681 out << ""//===== <run this macro AFTER loading the geometry in memory>"" << std::endl;; 2682 // save current top volume; 2683 out << "" TGeoVolume *top = gGeoManager->GetVolume(\"""" << fTopVolume->GetName() << ""\"");"" << std::endl;; 2684 out << "" TGeoVolume *vol = 0;"" << std::endl;; 2685 out << "" TGeoNode *node = 0;"" << std::endl;; 2686 out << "" // clear all volume attributes and get painter"" << std::endl;; 2687 out << "" gGeoManager->ClearAttributes();"" << std::endl;; 2688 out << "" gGeoManager->GetGeomPainter();"" << std::endl;; 2689 out << "" // set visualization modes and bomb factors"" << std::endl;; 2690 out << "" gGeoManager->SetVisOption("" << GetVisOption() << "");"" << std::endl;; 2691 out << "" gGeoManager->SetVisLevel("" << GetVisLevel() << "");"" << std::endl;; 2692 out << "" gGeoManager->SetExplodedView("" << GetBombMode() << "");"" << std::endl;; 2693 Double_t bombx, bomby, bombz, bombr;; 2694 GetBombFactors(bombx, bomby, bombz, bombr);; 2695 out << "" gGeoManager->SetBombFactors("" << bombx << "","" << bomby << "","" << bombz << "","" << bombr << "");""; 2696 << std::endl;; 2697 out << "" // iterate volumes container and set new attributes"" << std::endl;; 2698 // out << "" TIter next(gGeoManager->GetListOfVolumes());""<<std::endl;; 2699 TGeoVolume *vol = nullptr;; 2700 fTopNode->SaveAttributes(out);; 2701 ; 2702 TIter next(fVolumes);; 2703 while ((vol = (TGeoVolume *)next())) {; 2704 vol->SetVisStreamed(kFALSE);; 2705 }; 2706 out << "" // draw top volume with new settings"" << std::endl;; 2707 out << "" top->Draw();"" << std::endl;; 2708 out << "" gPad->x3d();"" << std::endl;; 2709 out << ""}"" << std::endl;; 2710 out.close();; 2711}; 2712 ; 2713////////////////////////////////////////////////////////////////////////////////; 2714/// Returns the deepe",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:105385,Performance,load,load,105385,"mat->GetByteCount();; 2904 TIter next3(fMedia);; 2905 TGeoMedium *med;; 2906 while ((med = (TGeoMedium *)next3())); 2907 count += med->GetByteCount();; 2908 if (fgVerboseLevel > 0); 2909 Info(""GetByteCount"", ""Total size of logical tree : %i bytes"", count);; 2910 return count;; 2911}; 2912 ; 2913////////////////////////////////////////////////////////////////////////////////; 2914/// Make a default painter if none present. Returns pointer to it.; 2915 ; 2916TVirtualGeoPainter *TGeoManager::GetGeomPainter(); 2917{; 2918 if (!fPainter) {; 2919 const char *kind = gEnv->GetValue(""GeomPainter.Name"", """");; 2920 if (!kind || !*kind); 2921 kind = (gROOT->IsWebDisplay() && !gROOT->IsWebDisplayBatch()) ? ""web"" : ""root"";; 2922 if (auto h = gROOT->GetPluginManager()->FindHandler(""TVirtualGeoPainter"", kind)) {; 2923 if (h->LoadPlugin() == -1) {; 2924 Error(""GetGeomPainter"", ""could not load plugin for %s geo_painter"", kind);; 2925 return nullptr;; 2926 }; 2927 fPainter = (TVirtualGeoPainter *)h->ExecPlugin(1, this);; 2928 if (!fPainter) {; 2929 Error(""GetGeomPainter"", ""could not create %s geo_painter"", kind);; 2930 return nullptr;; 2931 }; 2932 } else {; 2933 Error(""GetGeomPainter"", ""not found plugin %s for geo_painter"", kind);; 2934 }; 2935 }; 2936 return fPainter;; 2937}; 2938 ; 2939////////////////////////////////////////////////////////////////////////////////; 2940/// Search for a named volume. All trailing blanks stripped.; 2941 ; 2942TGeoVolume *TGeoManager::GetVolume(const char *name) const; 2943{; 2944 TString sname = name;; 2945 sname = sname.Strip();; 2946 TGeoVolume *vol = (TGeoVolume *)fVolumes->FindObject(sname.Data());; 2947 return vol;; 2948}; 2949 ; 2950////////////////////////////////////////////////////////////////////////////////; 2951/// Fast search for a named volume. All trailing blanks stripped.; 2952 ; 2953TGeoVolume *TGeoManager::FindVolumeFast(const char *name, Bool_t multi); 2954{; 2955 if (!fHashVolumes) {; 2956 Int_t nvol = fVolumes->GetEntriesFast();;",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:150981,Performance,cache,cacheread,150981,"tr;; 4110 ; 4111 if (strstr(filename, "".gdml"")) {; 4112 // import from a gdml file; 4113 new TGeoManager(""GDMLImport"", ""Geometry imported from GDML"");; 4114 TString cmd = TString::Format(""TGDMLParse::StartGDML(\""%s\"")"", filename);; 4115 TGeoVolume *world = (TGeoVolume *)gROOT->ProcessLineFast(cmd);; 4116 ; 4117 if (world == nullptr) {; 4118 delete gGeoManager;; 4119 gGeoManager = nullptr;; 4120 ::Error(""TGeoManager::Import"", ""Cannot read file %s"", filename);; 4121 } else {; 4122 gGeoManager->SetTopVolume(world);; 4123 gGeoManager->CloseGeometry();; 4124 gGeoManager->DefaultColors();; 4125 }; 4126 } else {; 4127 // import from a root file; 4128 TDirectory::TContext ctxt;; 4129 // in case a web file is specified, use the cacheread option to cache; 4130 // this file in the cache directory; 4131 TFile *f = nullptr;; 4132 if (strstr(filename, ""http"")); 4133 f = TFile::Open(filename, ""CACHEREAD"");; 4134 else; 4135 f = TFile::Open(filename);; 4136 if (!f || f->IsZombie()) {; 4137 ::Error(""TGeoManager::Import"", ""Cannot open file"");; 4138 return nullptr;; 4139 }; 4140 if (name && strlen(name) > 0) {; 4141 gGeoManager = (TGeoManager *)f->Get(name);; 4142 } else {; 4143 TIter next(f->GetListOfKeys());; 4144 TKey *key;; 4145 while ((key = (TKey *)next())) {; 4146 if (strcmp(key->GetClassName(), ""TGeoManager"") != 0); 4147 continue;; 4148 gGeoManager = (TGeoManager *)key->ReadObj();; 4149 break;; 4150 }; 4151 }; 4152 delete f;; 4153 }; 4154 if (!gGeoManager); 4155 return nullptr;; 4156 if (!gROOT->GetListOfGeometries()->FindObject(gGeoManager)); 4157 gROOT->GetListOfGeometries()->Add(gGeoManager);; 4158 if (!gROOT->GetListOfBrowsables()->FindObject(gGeoManager)); 4159 gROOT->GetListOfBrowsables()->Add(gGeoManager);; 4160 gGeoManager->UpdateElements();; 4161 return gGeoManager;; 4162}; 4163 ; 4164////////////////////////////////////////////////////////////////////////////////; 4165/// Update element flags when geometry is loaded from a file.; 4166 ; 4167void TGeoManager::UpdateEle",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:151001,Performance,cache,cache,151001,"tr;; 4110 ; 4111 if (strstr(filename, "".gdml"")) {; 4112 // import from a gdml file; 4113 new TGeoManager(""GDMLImport"", ""Geometry imported from GDML"");; 4114 TString cmd = TString::Format(""TGDMLParse::StartGDML(\""%s\"")"", filename);; 4115 TGeoVolume *world = (TGeoVolume *)gROOT->ProcessLineFast(cmd);; 4116 ; 4117 if (world == nullptr) {; 4118 delete gGeoManager;; 4119 gGeoManager = nullptr;; 4120 ::Error(""TGeoManager::Import"", ""Cannot read file %s"", filename);; 4121 } else {; 4122 gGeoManager->SetTopVolume(world);; 4123 gGeoManager->CloseGeometry();; 4124 gGeoManager->DefaultColors();; 4125 }; 4126 } else {; 4127 // import from a root file; 4128 TDirectory::TContext ctxt;; 4129 // in case a web file is specified, use the cacheread option to cache; 4130 // this file in the cache directory; 4131 TFile *f = nullptr;; 4132 if (strstr(filename, ""http"")); 4133 f = TFile::Open(filename, ""CACHEREAD"");; 4134 else; 4135 f = TFile::Open(filename);; 4136 if (!f || f->IsZombie()) {; 4137 ::Error(""TGeoManager::Import"", ""Cannot open file"");; 4138 return nullptr;; 4139 }; 4140 if (name && strlen(name) > 0) {; 4141 gGeoManager = (TGeoManager *)f->Get(name);; 4142 } else {; 4143 TIter next(f->GetListOfKeys());; 4144 TKey *key;; 4145 while ((key = (TKey *)next())) {; 4146 if (strcmp(key->GetClassName(), ""TGeoManager"") != 0); 4147 continue;; 4148 gGeoManager = (TGeoManager *)key->ReadObj();; 4149 break;; 4150 }; 4151 }; 4152 delete f;; 4153 }; 4154 if (!gGeoManager); 4155 return nullptr;; 4156 if (!gROOT->GetListOfGeometries()->FindObject(gGeoManager)); 4157 gROOT->GetListOfGeometries()->Add(gGeoManager);; 4158 if (!gROOT->GetListOfBrowsables()->FindObject(gGeoManager)); 4159 gROOT->GetListOfBrowsables()->Add(gGeoManager);; 4160 gGeoManager->UpdateElements();; 4161 return gGeoManager;; 4162}; 4163 ; 4164////////////////////////////////////////////////////////////////////////////////; 4165/// Update element flags when geometry is loaded from a file.; 4166 ; 4167void TGeoManager::UpdateEle",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:151033,Performance,cache,cache,151033,"tr;; 4110 ; 4111 if (strstr(filename, "".gdml"")) {; 4112 // import from a gdml file; 4113 new TGeoManager(""GDMLImport"", ""Geometry imported from GDML"");; 4114 TString cmd = TString::Format(""TGDMLParse::StartGDML(\""%s\"")"", filename);; 4115 TGeoVolume *world = (TGeoVolume *)gROOT->ProcessLineFast(cmd);; 4116 ; 4117 if (world == nullptr) {; 4118 delete gGeoManager;; 4119 gGeoManager = nullptr;; 4120 ::Error(""TGeoManager::Import"", ""Cannot read file %s"", filename);; 4121 } else {; 4122 gGeoManager->SetTopVolume(world);; 4123 gGeoManager->CloseGeometry();; 4124 gGeoManager->DefaultColors();; 4125 }; 4126 } else {; 4127 // import from a root file; 4128 TDirectory::TContext ctxt;; 4129 // in case a web file is specified, use the cacheread option to cache; 4130 // this file in the cache directory; 4131 TFile *f = nullptr;; 4132 if (strstr(filename, ""http"")); 4133 f = TFile::Open(filename, ""CACHEREAD"");; 4134 else; 4135 f = TFile::Open(filename);; 4136 if (!f || f->IsZombie()) {; 4137 ::Error(""TGeoManager::Import"", ""Cannot open file"");; 4138 return nullptr;; 4139 }; 4140 if (name && strlen(name) > 0) {; 4141 gGeoManager = (TGeoManager *)f->Get(name);; 4142 } else {; 4143 TIter next(f->GetListOfKeys());; 4144 TKey *key;; 4145 while ((key = (TKey *)next())) {; 4146 if (strcmp(key->GetClassName(), ""TGeoManager"") != 0); 4147 continue;; 4148 gGeoManager = (TGeoManager *)key->ReadObj();; 4149 break;; 4150 }; 4151 }; 4152 delete f;; 4153 }; 4154 if (!gGeoManager); 4155 return nullptr;; 4156 if (!gROOT->GetListOfGeometries()->FindObject(gGeoManager)); 4157 gROOT->GetListOfGeometries()->Add(gGeoManager);; 4158 if (!gROOT->GetListOfBrowsables()->FindObject(gGeoManager)); 4159 gROOT->GetListOfBrowsables()->Add(gGeoManager);; 4160 gGeoManager->UpdateElements();; 4161 return gGeoManager;; 4162}; 4163 ; 4164////////////////////////////////////////////////////////////////////////////////; 4165/// Update element flags when geometry is loaded from a file.; 4166 ; 4167void TGeoManager::UpdateEle",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:152193,Performance,load,loaded,152193,"tr;; 4110 ; 4111 if (strstr(filename, "".gdml"")) {; 4112 // import from a gdml file; 4113 new TGeoManager(""GDMLImport"", ""Geometry imported from GDML"");; 4114 TString cmd = TString::Format(""TGDMLParse::StartGDML(\""%s\"")"", filename);; 4115 TGeoVolume *world = (TGeoVolume *)gROOT->ProcessLineFast(cmd);; 4116 ; 4117 if (world == nullptr) {; 4118 delete gGeoManager;; 4119 gGeoManager = nullptr;; 4120 ::Error(""TGeoManager::Import"", ""Cannot read file %s"", filename);; 4121 } else {; 4122 gGeoManager->SetTopVolume(world);; 4123 gGeoManager->CloseGeometry();; 4124 gGeoManager->DefaultColors();; 4125 }; 4126 } else {; 4127 // import from a root file; 4128 TDirectory::TContext ctxt;; 4129 // in case a web file is specified, use the cacheread option to cache; 4130 // this file in the cache directory; 4131 TFile *f = nullptr;; 4132 if (strstr(filename, ""http"")); 4133 f = TFile::Open(filename, ""CACHEREAD"");; 4134 else; 4135 f = TFile::Open(filename);; 4136 if (!f || f->IsZombie()) {; 4137 ::Error(""TGeoManager::Import"", ""Cannot open file"");; 4138 return nullptr;; 4139 }; 4140 if (name && strlen(name) > 0) {; 4141 gGeoManager = (TGeoManager *)f->Get(name);; 4142 } else {; 4143 TIter next(f->GetListOfKeys());; 4144 TKey *key;; 4145 while ((key = (TKey *)next())) {; 4146 if (strcmp(key->GetClassName(), ""TGeoManager"") != 0); 4147 continue;; 4148 gGeoManager = (TGeoManager *)key->ReadObj();; 4149 break;; 4150 }; 4151 }; 4152 delete f;; 4153 }; 4154 if (!gGeoManager); 4155 return nullptr;; 4156 if (!gROOT->GetListOfGeometries()->FindObject(gGeoManager)); 4157 gROOT->GetListOfGeometries()->Add(gGeoManager);; 4158 if (!gROOT->GetListOfBrowsables()->FindObject(gGeoManager)); 4159 gROOT->GetListOfBrowsables()->Add(gGeoManager);; 4160 gGeoManager->UpdateElements();; 4161 return gGeoManager;; 4162}; 4163 ; 4164////////////////////////////////////////////////////////////////////////////////; 4165/// Update element flags when geometry is loaded from a file.; 4166 ; 4167void TGeoManager::UpdateEle",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:177601,Performance,multi-thread,multi-threading,177601,"a volume pointing to a cone shape with given medium.Definition TGeoManager.cxx:3257; TGeoManager::AnimateTracksvoid AnimateTracks(Double_t tmin=0, Double_t tmax=5E-8, Int_t nframes=200, Option_t *option=""/*"")Draw animation of tracks.Definition TGeoManager.cxx:1836; TGeoManager::AddSkinSurfacevoid AddSkinSurface(TGeoSkinSurface *surf)Add skin surface;.Definition TGeoManager.cxx:2048; TGeoManager::MakeXtruTGeoVolume * MakeXtru(const char *name, TGeoMedium *medium, Int_t nz)Make a TGeoXtru-shaped volume with nz planes.Definition TGeoManager.cxx:3332; TGeoManager::FindNormalFastDouble_t * FindNormalFast()Computes fast normal to next crossed boundary, assuming that the current point is close enough to the...Definition TGeoManager.cxx:2799; TGeoManager::MakePconTGeoVolume * MakePcon(const char *name, TGeoMedium *medium, Double_t phi, Double_t dphi, Int_t nz)Make in one step a volume pointing to a polycone shape with given medium.Definition TGeoManager.cxx:3275; TGeoManager::fRaytraceModeInt_t fRaytraceModeFlag for multi-threading.Definition TGeoManager.h:146; TGeoManager::fVisDensityDouble_t fVisDensityparticles to be drawnDefinition TGeoManager.h:69; TGeoManager::AddNavigatorTGeoNavigator * AddNavigator()Add a navigator in the list of navigators.Definition TGeoManager.cxx:789; TGeoManager::GetTrackOfIdTVirtualGeoTrack * GetTrackOfId(Int_t id) constGet track with a given ID.Definition TGeoManager.cxx:2200; TGeoManager::FindDuplicateMaterialTGeoMaterial * FindDuplicateMaterial(const TGeoMaterial *mat) constFind if a given material duplicates an existing one.Definition TGeoManager.cxx:2992; TGeoManager::DivisionTGeoVolume * Division(const char *name, const char *mother, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step, Int_t numed=0, Option_t *option="""")Create a new volume by dividing an existing one (GEANT3 like)Definition TGeoManager.cxx:1258; TGeoManager::VolumeTGeoVolume * Volume(const char *name, const char *shape, Int_t nmed, Float_t *upar, Int_t npar=0)Create a",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:178910,Performance,cache,cache,178910,"x:789; TGeoManager::GetTrackOfIdTVirtualGeoTrack * GetTrackOfId(Int_t id) constGet track with a given ID.Definition TGeoManager.cxx:2200; TGeoManager::FindDuplicateMaterialTGeoMaterial * FindDuplicateMaterial(const TGeoMaterial *mat) constFind if a given material duplicates an existing one.Definition TGeoManager.cxx:2992; TGeoManager::DivisionTGeoVolume * Division(const char *name, const char *mother, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step, Int_t numed=0, Option_t *option="""")Create a new volume by dividing an existing one (GEANT3 like)Definition TGeoManager.cxx:1258; TGeoManager::VolumeTGeoVolume * Volume(const char *name, const char *shape, Int_t nmed, Float_t *upar, Int_t npar=0)Create a volume in GEANT3 style.Definition TGeoManager.cxx:1388; TGeoManager::ReplaceVolumeInt_t ReplaceVolume(TGeoVolume *vorig, TGeoVolume *vnew)Replaces all occurrences of VORIG with VNEW in the geometry tree.Definition TGeoManager.cxx:1125; TGeoManager::DoRestoreStatevoid DoRestoreState()Restore a backed-up state without affecting the cache stack.Definition TGeoManager.cxx:1106; TGeoManager::GetCurrentNodeIdInt_t GetCurrentNodeId() constGet the unique ID of the current node.Definition TGeoManager.cxx:1663; TGeoManager::GetAlignableEntryTGeoPNEntry * GetAlignableEntry(const char *name) constRetrieves an existing alignable object.Definition TGeoManager.cxx:3370; TGeoManager::fMasterVolumeTGeoVolume * fMasterVolumetop physical nodeDefinition TGeoManager.h:127; TGeoManager::FindTrackWithIdTVirtualGeoTrack * FindTrackWithId(Int_t id) constSearch the track hierarchy to find the track with the given id.Definition TGeoManager.cxx:2180; TGeoManager::fArrayPNETObjArray * fArrayPNEDefinition TGeoManager.h:139; TGeoManager::TestOverlapsvoid TestOverlaps(const char *path="""")Geometry overlap checker based on sampling.Definition TGeoManager.cxx:1950; TGeoManager::GetDefaultUnitsstatic EDefaultUnits GetDefaultUnits()Definition TGeoManager.cxx:4314; TGeoManager::RemoveMaterialvoid Remov",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:180588,Performance,load,loaded,180588,"Array * fArrayPNEDefinition TGeoManager.h:139; TGeoManager::TestOverlapsvoid TestOverlaps(const char *path="""")Geometry overlap checker based on sampling.Definition TGeoManager.cxx:1950; TGeoManager::GetDefaultUnitsstatic EDefaultUnits GetDefaultUnits()Definition TGeoManager.cxx:4314; TGeoManager::RemoveMaterialvoid RemoveMaterial(Int_t index)Remove material at given index.Definition TGeoManager.cxx:3086; TGeoManager::Matrixvoid Matrix(Int_t index, Double_t theta1, Double_t phi1, Double_t theta2, Double_t phi2, Double_t theta3, Double_t phi3)Create rotation matrix named 'mat<index>'.Definition TGeoManager.cxx:1276; TGeoManager::GetElementTableTGeoElementTable * GetElementTable()Returns material table. Creates it if not existing.Definition TGeoManager.cxx:3624; TGeoManager::fNtracksInt_t fNtracksDefinition TGeoManager.h:74; TGeoManager::fHashPNETHashList * fHashPNEhash list of group volumes providing fast searchDefinition TGeoManager.h:138; TGeoManager::fgVerboseLevelstatic Int_t fgVerboseLevelLock preventing a second geometry to be loaded.Definition TGeoManager.h:51; TGeoManager::Initvoid Init()Initialize manager class.Definition TGeoManager.cxx:416; TGeoManager::InitArrayPNEBool_t InitArrayPNE() constInitialize PNE array for fast access via index and unique-id.Definition TGeoManager.cxx:4214; TGeoManager::fPhysicalNodesTObjArray * fPhysicalNodesDefinition TGeoManager.h:96; TGeoManager::SizeOfvirtual ULong_t SizeOf(const TGeoNode *node, Option_t *option)computes the total size in bytes of the branch starting with node.Definition TGeoManager.cxx:3926; TGeoManager::fUniqueVolumesTObjArray * fUniqueVolumesDefinition TGeoManager.h:129; TGeoManager::fgExportPrecisionstatic UInt_t fgExportPrecisionMaximum number of Xtru vertices.Definition TGeoManager.h:55; TGeoManager::fRegionsTObjArray * fRegionsDefinition TGeoManager.h:109; TGeoManager::Nodevoid Node(const char *name, Int_t nr, const char *mother, Double_t x, Double_t y, Double_t z, Int_t irot, Bool_t isOnly, Float_t *u",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:182084,Performance,load,loaded,182084,"bytes of the branch starting with node.Definition TGeoManager.cxx:3926; TGeoManager::fUniqueVolumesTObjArray * fUniqueVolumesDefinition TGeoManager.h:129; TGeoManager::fgExportPrecisionstatic UInt_t fgExportPrecisionMaximum number of Xtru vertices.Definition TGeoManager.h:55; TGeoManager::fRegionsTObjArray * fRegionsDefinition TGeoManager.h:109; TGeoManager::Nodevoid Node(const char *name, Int_t nr, const char *mother, Double_t x, Double_t y, Double_t z, Int_t irot, Bool_t isOnly, Float_t *upar, Int_t npar=0)Create a node called <name_nr> pointing to the volume called <name> as daughter of the volume called ...Definition TGeoManager.cxx:1353; TGeoManager::fGShapesTObjArray * fGShapesDefinition TGeoManager.h:97; TGeoManager::fPaintVolumeTGeoVolume * fPaintVolumeDefinition TGeoManager.h:134; TGeoManager::GetSkinSurfaceTGeoSkinSurface * GetSkinSurface(const char *name) constGet skin surface with a given name;.Definition TGeoManager.cxx:2041; TGeoManager::UpdateElementsvoid UpdateElements()Update element flags when geometry is loaded from a file.Definition TGeoManager.cxx:4167; TGeoManager::TGeoManagerTGeoManager()Default constructor.Definition TGeoManager.cxx:311; TGeoManager::Classstatic TClass * Class(); TGeoManager::fPropertiesConstPropMap_t fPropertiesDefinition TGeoManager.h:149; TGeoManager::MakeTubeTGeoVolume * MakeTube(const char *name, TGeoMedium *medium, Double_t rmin, Double_t rmax, Double_t dz)Make in one step a volume pointing to a tube shape with given medium.Definition TGeoManager.cxx:3204; TGeoManager::CdUpvoid CdUp()Go one level up in geometry.Definition TGeoManager.cxx:1681; TGeoManager::DoBackupStatevoid DoBackupState()Backup the current state without affecting the cache stack.Definition TGeoManager.cxx:1098; TGeoManager::fMaterialsTList * fMaterialsDefinition TGeoManager.h:105; TGeoManager::CheckBoundaryErrorsvoid CheckBoundaryErrors(Int_t ntracks=1000000, Double_t radius=-1.)Check pushes and pulls needed to cross the next boundary with respect to th",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:182755,Performance,cache,cache,182755,"fGShapesTObjArray * fGShapesDefinition TGeoManager.h:97; TGeoManager::fPaintVolumeTGeoVolume * fPaintVolumeDefinition TGeoManager.h:134; TGeoManager::GetSkinSurfaceTGeoSkinSurface * GetSkinSurface(const char *name) constGet skin surface with a given name;.Definition TGeoManager.cxx:2041; TGeoManager::UpdateElementsvoid UpdateElements()Update element flags when geometry is loaded from a file.Definition TGeoManager.cxx:4167; TGeoManager::TGeoManagerTGeoManager()Default constructor.Definition TGeoManager.cxx:311; TGeoManager::Classstatic TClass * Class(); TGeoManager::fPropertiesConstPropMap_t fPropertiesDefinition TGeoManager.h:149; TGeoManager::MakeTubeTGeoVolume * MakeTube(const char *name, TGeoMedium *medium, Double_t rmin, Double_t rmax, Double_t dz)Make in one step a volume pointing to a tube shape with given medium.Definition TGeoManager.cxx:3204; TGeoManager::CdUpvoid CdUp()Go one level up in geometry.Definition TGeoManager.cxx:1681; TGeoManager::DoBackupStatevoid DoBackupState()Backup the current state without affecting the cache stack.Definition TGeoManager.cxx:1098; TGeoManager::fMaterialsTList * fMaterialsDefinition TGeoManager.h:105; TGeoManager::CheckBoundaryErrorsvoid CheckBoundaryErrors(Int_t ntracks=1000000, Double_t radius=-1.)Check pushes and pulls needed to cross the next boundary with respect to the position given by FindNe...Definition TGeoManager.cxx:3752; TGeoManager::fVolumesTObjArray * fVolumesDefinition TGeoManager.h:95; TGeoManager::fValuePNEIdInt_t * fValuePNEIdDefinition TGeoManager.h:143; TGeoManager::GetAlignableEntryByUIDTGeoPNEntry * GetAlignableEntryByUID(Int_t uid) constRetrieves an existing alignable object having a preset UID.Definition TGeoManager.cxx:3390; TGeoManager::AddGDMLMatrixvoid AddGDMLMatrix(TGDMLMatrix *mat)Add GDML matrix;.Definition TGeoManager.cxx:2010; TGeoManager::fTimeCutBool_t fTimeCutDefinition TGeoManager.h:85; TGeoManager::SetExportPrecisionstatic void SetExportPrecision(UInt_t prec)Definition TGeoManager.cxx:4",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:192297,Performance,perform,performedDefinition,192297,"6; TGeoManager::ClearAttributesvoid ClearAttributes()Reset all attributes to default ones.Definition TGeoManager.cxx:1455; TGeoManager::fgMaxDaughtersstatic Int_t fgMaxDaughtersMaximum level in geometry.Definition TGeoManager.h:53; TGeoManager::fUsePWNavBool_t fUsePWNavRaytrace mode: 0=normal, 1=pass through, 2=transparent.Definition TGeoManager.h:147; TGeoManager::SetRTmodevoid SetRTmode(Int_t mode)Change raytracing mode.Definition TGeoManager.cxx:3108; TGeoManager::CheckPathBool_t CheckPath(const char *path) constCheck if a geometry path is valid without changing the state of the current navigator.Definition TGeoManager.cxx:1715; TGeoManager::InspectStatevoid InspectState() constInspects path and all flags for the current state.Definition TGeoManager.cxx:2873; TGeoManager::ConvertReflectionsvoid ConvertReflections()Convert all reflections in geometry to normal rotations + reflected shapes.Definition TGeoManager.cxx:1723; TGeoManager::SetVisLevelvoid SetVisLevel(Int_t level=3)set default level down to which visualization is performedDefinition TGeoManager.cxx:2459; TGeoManager::FindNextBoundaryTGeoNode * FindNextBoundary(Double_t stepmax=TGeoShape::Big(), const char *path="""", Bool_t frombdr=kFALSE)Find distance to next boundary and store it in fStep.Definition TGeoManager.cxx:2755; TGeoManager::Importstatic TGeoManager * Import(const char *filename, const char *name="""", Option_t *option="""")static function Import a geometry from a gdml or ROOT fileDefinition TGeoManager.cxx:4096; TGeoManager::MakePhysicalNodeTGeoPhysicalNode * MakePhysicalNode(const char *path=nullptr)Makes a physical node corresponding to a path.Definition TGeoManager.cxx:3506; TGeoManager::CountLevelsvoid CountLevels()Count maximum number of nodes per volume, maximum depth and maximum number of xtru vertices.Definition TGeoManager.cxx:1759; TGeoManager::fMaxThreadsInt_t fMaxThreadsDefinition TGeoManager.h:144; TGeoManager::fIsGeomReadingBool_t fIsGeomReadingDefinition TGeoManager.h:82; TGeoManager",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:223717,Performance,cache,cache,223717,"finition TGeoMedium.h:44; TGeoMixtureMixtures of elements.Definition TGeoMaterial.h:159; TGeoMixture::GetNelementsInt_t GetNelements() const overrideDefinition TGeoMaterial.h:201; TGeoMixture::GetElementTGeoElement * GetElement(Int_t i=0) const overrideRetrieve the pointer to the element corresponding to component I.Definition TGeoMaterial.cxx:1122; TGeoNavigatorArrayDefinition TGeoNavigator.h:294; TGeoNavigatorArray::AddNavigatorTGeoNavigator * AddNavigator()Add a new navigator to the array.Definition TGeoNavigator.cxx:2745; TGeoNavigatorArray::GetCurrentNavigatorTGeoNavigator * GetCurrentNavigator() constDefinition TGeoNavigator.h:308; TGeoNavigatorArray::SetCurrentNavigatorTGeoNavigator * SetCurrentNavigator(Int_t inav)Definition TGeoNavigator.h:309; TGeoNavigatorClass providing navigation API for TGeo geometries.Definition TGeoNavigator.h:32; TGeoNavigator::CdUpvoid CdUp()Go one level up in geometry.Definition TGeoNavigator.cxx:352; TGeoNavigator::DoBackupStatevoid DoBackupState()Backup the current state without affecting the cache stack.Definition TGeoNavigator.cxx:2648; TGeoNavigator::DoRestoreStatevoid DoRestoreState()Restore a backed-up state without affecting the cache stack.Definition TGeoNavigator.cxx:2657; TGeoNavigator::CrossBoundaryAndLocateTGeoNode * CrossBoundaryAndLocate(Bool_t downwards, TGeoNode *skipnode)Cross next boundary and locate within current node The current point must be on the boundary of fCurr...Definition TGeoNavigator.cxx:523; TGeoNavigator::GetHMatrixTGeoHMatrix * GetHMatrix()Return stored current matrix (global matrix of the next touched node).Definition TGeoNavigator.cxx:2670; TGeoNavigator::LocalToMastervoid LocalToMaster(const Double_t *local, Double_t *master) constDefinition TGeoNavigator.h:235; TGeoNavigator::CdNextvoid CdNext()Do a cd to the node found next by FindNextBoundary.Definition TGeoNavigator.cxx:405; TGeoNavigator::SafetyDouble_t Safety(Bool_t inside=kFALSE)Compute safe distance from the current point.Definition TG",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:223862,Performance,cache,cache,223862,"errideDefinition TGeoMaterial.h:201; TGeoMixture::GetElementTGeoElement * GetElement(Int_t i=0) const overrideRetrieve the pointer to the element corresponding to component I.Definition TGeoMaterial.cxx:1122; TGeoNavigatorArrayDefinition TGeoNavigator.h:294; TGeoNavigatorArray::AddNavigatorTGeoNavigator * AddNavigator()Add a new navigator to the array.Definition TGeoNavigator.cxx:2745; TGeoNavigatorArray::GetCurrentNavigatorTGeoNavigator * GetCurrentNavigator() constDefinition TGeoNavigator.h:308; TGeoNavigatorArray::SetCurrentNavigatorTGeoNavigator * SetCurrentNavigator(Int_t inav)Definition TGeoNavigator.h:309; TGeoNavigatorClass providing navigation API for TGeo geometries.Definition TGeoNavigator.h:32; TGeoNavigator::CdUpvoid CdUp()Go one level up in geometry.Definition TGeoNavigator.cxx:352; TGeoNavigator::DoBackupStatevoid DoBackupState()Backup the current state without affecting the cache stack.Definition TGeoNavigator.cxx:2648; TGeoNavigator::DoRestoreStatevoid DoRestoreState()Restore a backed-up state without affecting the cache stack.Definition TGeoNavigator.cxx:2657; TGeoNavigator::CrossBoundaryAndLocateTGeoNode * CrossBoundaryAndLocate(Bool_t downwards, TGeoNode *skipnode)Cross next boundary and locate within current node The current point must be on the boundary of fCurr...Definition TGeoNavigator.cxx:523; TGeoNavigator::GetHMatrixTGeoHMatrix * GetHMatrix()Return stored current matrix (global matrix of the next touched node).Definition TGeoNavigator.cxx:2670; TGeoNavigator::LocalToMastervoid LocalToMaster(const Double_t *local, Double_t *master) constDefinition TGeoNavigator.h:235; TGeoNavigator::CdNextvoid CdNext()Do a cd to the node found next by FindNextBoundary.Definition TGeoNavigator.cxx:405; TGeoNavigator::SafetyDouble_t Safety(Bool_t inside=kFALSE)Compute safe distance from the current point.Definition TGeoNavigator.cxx:1689; TGeoNavigator::GotoSafeLevelBool_t GotoSafeLevel()Go upwards the tree until a non-overlapping node.Definition TGeoNavigat",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:236374,Performance,optimiz,optimization,236374,"ting from this volume, nlevels down.Definition TGeoVolume.cxx:730; TGeoVolume::UnmarkSavedvoid UnmarkSaved()Reset SavePrimitive bits.Definition TGeoVolume.cxx:1699; TGeoVolume::SetFindervoid SetFinder(TGeoPatternFinder *finder)Definition TGeoVolume.h:244; TGeoVolume::GetNdaughtersInt_t GetNdaughters() constDefinition TGeoVolume.h:362; TGeoVolume::Grabvoid Grab()Definition TGeoVolume.h:136; TGeoVolume::Classstatic TClass * Class(); TGeoVolume::SetTransparencyvoid SetTransparency(Char_t transparency=0)Definition TGeoVolume.h:376; TGeoVolume::Releasevoid Release()Definition TGeoVolume.h:137; TGeoVolume::FindOverlapsvoid FindOverlaps() constloop all nodes marked as overlaps and find overlapping brothersDefinition TGeoVolume.cxx:2227; TGeoVolume::GetNodeTGeoNode * GetNode(const char *name) constget the pointer to a daughter nodeDefinition TGeoVolume.cxx:2193; TGeoVolume::SetMediumvirtual void SetMedium(TGeoMedium *medium)Definition TGeoVolume.h:242; TGeoVolume::GetVoxelsTGeoVoxelFinder * GetVoxels() constGetter for optimization structure.Definition TGeoVolume.cxx:1802; TGeoVolume::DummyMediumstatic TGeoMedium * DummyMedium()Definition TGeoVolume.cxx:445; TGeoVolume::SetLineColorvoid SetLineColor(Color_t lcolor) overrideSet the line color.Definition TGeoVolume.cxx:2169; TGeoVolume::GetNumberInt_t GetNumber() constDefinition TGeoVolume.h:184; TGeoVolume::GetShapeTGeoShape * GetShape() constDefinition TGeoVolume.h:190; TGeoVolume::SaveAsvoid SaveAs(const char *filename="""", Option_t *option="""") const overrideSave geometry having this as top volume as a C++ macro.Definition TGeoVolume.cxx:1447; TGeoVolume::SetFieldvoid SetField(TObject *field)Definition TGeoVolume.h:231; TGeoVolume::CreateDummyMediumstatic void CreateDummyMedium()Create a dummy medium.Definition TGeoVolume.cxx:412; TGeoVolume::SetLineStylevoid SetLineStyle(Style_t lstyle) overrideSet the line style.Definition TGeoVolume.cxx:2177; TGeoVolume::IsAssemblyvirtual Bool_t IsAssembly() constReturns true if the volume",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:249419,Performance,multi-thread,multi-threading,249419,"btr)=0; TVirtualGeoPainter::CheckShapevirtual void CheckShape(TGeoShape *shape, Int_t testNo, Int_t nsamples, Option_t *option)=0; TVirtualGeoPainter::ExecuteManagerEventvirtual void ExecuteManagerEvent(TGeoManager *geom, Int_t event, Int_t px, Int_t py)=0; TVirtualGeoPainter::SetBombFactorsvirtual void SetBombFactors(Double_t bombx=1.3, Double_t bomby=1.3, Double_t bombz=1.3, Double_t bombr=1.3)=0; TVirtualGeoPainter::CheckBoundaryErrorsvirtual void CheckBoundaryErrors(Int_t ntracks=1000000, Double_t radius=-1.)=0; TVirtualGeoTrackBase class for user-defined tracks attached to a geometry.Definition TVirtualGeoTrack.h:23; TVirtualGeoTrack::GetIdInt_t GetId() constDefinition TVirtualGeoTrack.h:43; TVirtualGeoTrack::GetMotherTVirtualGeoTrack * GetMother() constDefinition TVirtualGeoTrack.h:46; TVirtualGeoTrack::FindTrackWithIdvirtual TVirtualGeoTrack * FindTrackWithId(Int_t id) constRecursively search through this track for a daughter particle (at any depth) with the specified id.Definition TVirtualGeoTrack.cxx:83; bool; double; int; unsigned int; boxvoid box(Int_t pat, Double_t x1, Double_t y1, Double_t x2, Double_t y2)Definition fillpatterns.C:1; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; h1TH1F * h1Definition legend1.C:5; ROOT::EnableThreadSafetyvoid EnableThreadSafety()Enable support for multi-threading within the ROOT code in particular, enables the global mutex to ma...Definition TROOT.cxx:501; TMath::ATan2Double_t ATan2(Double_t y, Double_t x)Returns the principal value of the arc tangent of y/x, expressed in radians.Definition TMath.h:646; TMath::BinarySearchLong64_t BinarySearch(Long64_t n, const T *array, T value)Binary search in an array of n values to locate value.Definition TMathBase.h:347; TMath::RadToDegconstexpr Double_t RadToDeg()Conversion from radian to degree: .Definition TMath.h:72. geomgeomsrcTGeoManager.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:14 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:1010,Safety,detect,detector,1010,". ROOT: geom/geom/src/TGeoManager.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TGeoManager.cxx. Go to the documentation of this file. 1// @(#)root/geom:$Id$; 2// Author: Andrei Gheata 25/10/01; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/** \class TGeoManager; 13\ingroup Geometry_classes; 14 ; 15The manager class for any TGeo geometry. Provides user; 16interface for geometry creation, navigation, state querying,; 17visualization, IO, geometry checking and other utilities.; 18 ; 19## General architecture; 20 ; 21 The ROOT geometry package is a tool designed for building, browsing,; 22tracking and visualizing a detector geometry. The code is independent from; 23other external MC for simulation, therefore it does not contain any; 24constraints related to physics. However, the package defines a number of; 25hooks for tracking, such as media, materials, magnetic field or track state flags,; 26in order to allow interfacing to tracking MC's. The final goal is to be; 27able to use the same geometry for several purposes, such as tracking,; 28reconstruction or visualization, taking advantage of the ROOT features; 29related to bookkeeping, I/O, histogramming, browsing and GUI's.; 30 ; 31 The geometrical modeler is the most important component of the package and; 32it provides answers to the basic questions like ""Where am I ?"" or ""How far; 33from the next boundary ?"", but also to more complex ones like ""How far from; 34the closest surface ?"" or ""Which is the next crossing along a helix ?"".; 35 ; 36 The architecture of the modeler is a combination between a GEANT-like; 37containment scheme and ",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:2088,Safety,detect,detector,2088,"ore it does not contain any; 24constraints related to physics. However, the package defines a number of; 25hooks for tracking, such as media, materials, magnetic field or track state flags,; 26in order to allow interfacing to tracking MC's. The final goal is to be; 27able to use the same geometry for several purposes, such as tracking,; 28reconstruction or visualization, taking advantage of the ROOT features; 29related to bookkeeping, I/O, histogramming, browsing and GUI's.; 30 ; 31 The geometrical modeler is the most important component of the package and; 32it provides answers to the basic questions like ""Where am I ?"" or ""How far; 33from the next boundary ?"", but also to more complex ones like ""How far from; 34the closest surface ?"" or ""Which is the next crossing along a helix ?"".; 35 ; 36 The architecture of the modeler is a combination between a GEANT-like; 37containment scheme and a normal CSG binary tree at the level of shapes. An; 38important common feature of all detector geometry descriptions is the; 39mother-daughter concept. This is the most natural approach when tracking; 40is concerned and imposes a set of constraints to the way geometry is defined.; 41Constructive solid geometry composition is used only in order to create more; 42complex shapes from an existing set of primitives through boolean operations.; 43This feature is not implemented yet but in future full definition of boolean; 44expressions will be supported.; 45 ; 46 Practically every geometry defined in GEANT style can be mapped by the modeler.; 47The basic components used for building the logical hierarchy of the geometry; 48are called ""volumes"" and ""nodes"". Volumes (sometimes called ""solids"") are fully; 49defined geometrical objects having a given shape and medium and possibly; 50containing a list of nodes. Nodes represent just positioned instances of volumes; 51inside a container volume and they are not directly defined by user. They are; 52automatically created as a result of adding one",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:12022,Safety,safe,safety,12022,"sibility() : set volume visibility.; 198 - TGeoVolume::VisibleDaughters() : set daughters visibility.; 199All these actions automatically updates the current view if any.; 200 ; 201### Checking the geometry; 202 ; 203 Several checking methods are accessible from the volume context menu. They; 204generally apply only to the visible parts of the drawn geometry in order to; 205ease geometry checking, and their implementation is in the TGeoChecker class; 206from the painting package.; 207 ; 208#### Checking a given point.; 209 Can be called from TGeoManager::CheckPoint(Double_t x, Double_t y, Double_t z).; 210This method is drawing the daughters of the volume containing the point one; 211level down, printing the path to the deepest physical node holding this point.; 212It also computes the closest distance to any boundary. The point will be drawn; 213in red, as well as a sphere having this closest distance as radius. In case a; 214non-zero distance is given by the user as fifth argument of CheckPoint, this; 215distance will be used as radius of the safety sphere.; 216 ; 217\image html geom_checkpoint.jpg; 218 ; 219#### Shooting random points.; 220 Can be called from TGeoVolume::RandomPoints() (context menu function) and; 221it will draw this volume with current visualization settings. Random points; 222are generated in the bounding box of the top drawn volume. The points are; 223classified and drawn with the color of their deepest container. Only points; 224in visible nodes will be drawn.; 225 ; 226\image html geom_random1.jpg; 227 ; 228 ; 229#### Raytracing.; 230 Can be called from TGeoVolume::RandomRays() (context menu of volumes) and; 231will shoot rays from a given point in the local reference frame with random; 232directions. The intersections with displayed nodes will appear as segments; 233having the color of the touched node. Drawn geometry will be then made invisible; 234in order to enhance rays.; 235 ; 236\image html geom_random2.jpg; 237*/; 238 ; 239#include <",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:58564,Safety,avoid,avoid,58564,"->AddLast(fVolumes->At(i));; 1545 }; 1546 fClosed = kTRUE;; 1547 if (fParallelWorld) {; 1548 if (fgVerboseLevel > 0); 1549 Info(""CloseGeometry"", ""Recreating parallel world %s ..."", fParallelWorld->GetName());; 1550 fParallelWorld->CloseGeometry();; 1551 }; 1552 ; 1553 if (fgVerboseLevel > 0); 1554 Info(""CloseGeometry"", ""%i nodes/ %i volume UID's in %s"", fNNodes, fUniqueVolumes->GetEntriesFast() - 1,; 1555 GetTitle());; 1556 if (fgVerboseLevel > 0); 1557 Info(""CloseGeometry"", ""----------------modeler ready----------------"");; 1558 return;; 1559 }; 1560 ; 1561 // Create a geometry navigator if not present; 1562 if (!GetCurrentNavigator()); 1563 fCurrentNavigator = AddNavigator();; 1564 nnavigators = GetListOfNavigators()->GetEntriesFast();; 1565 SelectTrackingMedia();; 1566 CheckGeometry();; 1567 if (fgVerboseLevel > 0); 1568 Info(""CloseGeometry"", ""Counting nodes..."");; 1569 fNNodes = CountNodes();; 1570 fNLevel = fMasterVolume->CountNodes(1, 3) + 1;; 1571 if (fNLevel < 30); 1572 fNLevel = 100;; 1573 ; 1574 // BuildIdArray();; 1575 // avoid voxelization if requested to speed up geometry startup; 1576 if (!opt.Contains(""nv"")) {; 1577 Voxelize(""ALL"");; 1578 } else {; 1579 TGeoVolume *vol;; 1580 TIter next(fVolumes);; 1581 while ((vol = (TGeoVolume *)next())) {; 1582 vol->SortNodes();; 1583 }; 1584 }; 1585 if (fgVerboseLevel > 0); 1586 Info(""CloseGeometry"", ""Building cache..."");; 1587 CountLevels();; 1588 for (Int_t i = 0; i < nnavigators; i++) {; 1589 nav = (TGeoNavigator *)GetListOfNavigators()->At(i);; 1590 nav->GetCache()->BuildInfoBranch();; 1591 if (nodeid); 1592 nav->GetCache()->BuildIdArray();; 1593 }; 1594 fClosed = kTRUE;; 1595 if (fgVerboseLevel > 0) {; 1596 Info(""CloseGeometry"", ""%i nodes/ %i volume UID's in %s"", fNNodes, fUniqueVolumes->GetEntriesFast() - 1,; 1597 GetTitle());; 1598 Info(""CloseGeometry"", ""----------------modeler ready----------------"");; 1599 }; 1600}; 1601 ; 1602////////////////////////////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:82535,Safety,safe,safe,82535,"; i++); 2264 col[i] = kGray;; 2265 ; 2266 // here we should create a new TColor with the same rgb as in the default; 2267 // ROOT colors used below; 2268 col[3] = kYellow - 10;; 2269 col[4] = col[5] = kGreen - 10;; 2270 col[6] = col[7] = kBlue - 7;; 2271 col[8] = col[9] = kMagenta - 3;; 2272 col[10] = col[11] = kRed - 10;; 2273 col[12] = kGray + 1;; 2274 col[13] = kBlue - 10;; 2275 col[14] = kOrange + 7;; 2276 col[16] = kYellow + 1;; 2277 col[20] = kYellow - 10;; 2278 col[24] = col[25] = col[26] = kBlue - 8;; 2279 col[29] = kOrange + 9;; 2280 col[79] = kOrange - 2;; 2281 ; 2282 TGeoVolume *vol;; 2283 TIter next(fVolumes);; 2284 while ((vol = (TGeoVolume *)next())) {; 2285 TGeoMedium *med = vol->GetMedium();; 2286 if (!med); 2287 continue;; 2288 TGeoMaterial *mat = med->GetMaterial();; 2289 Int_t matZ = (Int_t)mat->GetZ();; 2290 vol->SetLineColor(col[matZ]);; 2291 if (mat->GetDensity() < 0.1); 2292 vol->SetTransparency(60);; 2293 }; 2294}; 2295 ; 2296////////////////////////////////////////////////////////////////////////////////; 2297/// Compute safe distance from the current point. This represent the distance; 2298/// from POINT to the closest boundary.; 2299 ; 2300Double_t TGeoManager::Safety(Bool_t inside); 2301{; 2302 return GetCurrentNavigator()->Safety(inside);; 2303}; 2304 ; 2305////////////////////////////////////////////////////////////////////////////////; 2306/// Set volume attributes in G3 style.; 2307 ; 2308void TGeoManager::SetVolumeAttribute(const char *name, const char *att, Int_t val); 2309{; 2310 TGeoVolume *volume;; 2311 Bool_t all = kFALSE;; 2312 if (strstr(name, ""*"")); 2313 all = kTRUE;; 2314 Int_t ivo = 0;; 2315 TIter next(fVolumes);; 2316 TString chatt = att;; 2317 chatt.ToLower();; 2318 while ((volume = (TGeoVolume *)next())) {; 2319 if (strcmp(volume->GetName(), name) && !all); 2320 continue;; 2321 ivo++;; 2322 if (chatt.Contains(""colo"")); 2323 volume->SetLineColor(val);; 2324 if (chatt.Contains(""lsty"")); 2325 volume->SetLineStyle(val);; 2326",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:90826,Safety,avoid,avoid,90826,"ume *)next())) {; 2514 if (!vol->GetVoxels()); 2515 continue;; 2516 out << "" vol = gGeoManager->GetVolume(\"""" << vol->GetName() << ""\"");"" << std::endl;; 2517 cyltype = vol->OptimizeVoxels();; 2518 if (cyltype) {; 2519 out << "" vol->SetCylVoxels();"" << std::endl;; 2520 } else {; 2521 out << "" vol->SetCylVoxels(kFALSE);"" << std::endl;; 2522 }; 2523 }; 2524 out << ""}"" << std::endl;; 2525 out.close();; 2526}; 2527////////////////////////////////////////////////////////////////////////////////; 2528/// Parse a string boolean expression and do a syntax check. Find top; 2529/// level boolean operator and returns its type. Fill the two; 2530/// substrings to which this operator applies. The returned integer is :; 2531/// - -1 : parse error; 2532/// - 0 : no boolean operator; 2533/// - 1 : union - represented as '+' in expression; 2534/// - 2 : difference (subtraction) - represented as '-' in expression; 2535/// - 3 : intersection - represented as '*' in expression.; 2536/// Parentheses should be used to avoid ambiguities. For instance :; 2537/// - A+B-C will be interpreted as (A+B)-C which is not the same as A+(B-C); 2538/// eliminate not needed parentheses; 2539 ; 2540Int_t TGeoManager::Parse(const char *expr, TString &expr1, TString &expr2, TString &expr3); 2541{; 2542 TString startstr(expr);; 2543 Int_t len = startstr.Length();; 2544 Int_t i;; 2545 TString e0 = """";; 2546 expr3 = """";; 2547 // eliminate blanks; 2548 for (i = 0; i < len; i++) {; 2549 if (startstr(i) == ' '); 2550 continue;; 2551 e0 += startstr(i, 1);; 2552 }; 2553 Int_t level = 0;; 2554 Int_t levmin = 999;; 2555 Int_t boolop = 0;; 2556 Int_t indop = 0;; 2557 Int_t iloop = 1;; 2558 Int_t lastop = 0;; 2559 Int_t lastdp = 0;; 2560 Int_t lastpp = 0;; 2561 Bool_t foundmat = kFALSE;; 2562 // check/eliminate parentheses; 2563 while (iloop == 1) {; 2564 iloop = 0;; 2565 lastop = 0;; 2566 lastdp = 0;; 2567 lastpp = 0;; 2568 len = e0.Length();; 2569 for (i = 0; i < len; i++) {; 2570 if (e0(i) == '(') {; 2571 if (!lev",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:98177,Safety,safe,safe,98177,"If no boundary is found,; 2732/// propagate current point along current direction with fStep=STEPMAX. Otherwise; 2733/// propagate with fStep=SNEXT (distance to boundary) and locate/return the next; 2734/// node.; 2735 ; 2736TGeoNode *TGeoManager::FindNextBoundaryAndStep(Double_t stepmax, Bool_t compsafe); 2737{; 2738 return GetCurrentNavigator()->FindNextBoundaryAndStep(stepmax, compsafe);; 2739}; 2740 ; 2741////////////////////////////////////////////////////////////////////////////////; 2742/// Find distance to next boundary and store it in fStep. Returns node to which this; 2743/// boundary belongs. If PATH is specified, compute only distance to the node to which; 2744/// PATH points. If STEPMAX is specified, compute distance only in case fSafety is smaller; 2745/// than this value. STEPMAX represent the step to be made imposed by other reasons than; 2746/// geometry (usually physics processes). Therefore in this case this method provides the; 2747/// answer to the question : ""Is STEPMAX a safe step ?"" returning a NULL node and filling; 2748/// fStep with a big number.; 2749/// In case frombdr=kTRUE, the isotropic safety is set to zero.; 2750///; 2751/// Note : safety distance for the current point is computed ONLY in case STEPMAX is; 2752/// specified, otherwise users have to call explicitly TGeoManager::Safety() if; 2753/// they want this computed for the current point.; 2754 ; 2755TGeoNode *TGeoManager::FindNextBoundary(Double_t stepmax, const char *path, Bool_t frombdr); 2756{; 2757 // convert current point and direction to local reference; 2758 return GetCurrentNavigator()->FindNextBoundary(stepmax, path, frombdr);; 2759}; 2760 ; 2761////////////////////////////////////////////////////////////////////////////////; 2762/// Computes as fStep the distance to next daughter of the current volume.; 2763/// The point and direction must be converted in the coordinate system of the current volume.; 2764/// The proposed step limit is fStep.; 2765 ; 2766TGeoNode *TGeoM",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:98304,Safety,safe,safety,98304,"opagate with fStep=SNEXT (distance to boundary) and locate/return the next; 2734/// node.; 2735 ; 2736TGeoNode *TGeoManager::FindNextBoundaryAndStep(Double_t stepmax, Bool_t compsafe); 2737{; 2738 return GetCurrentNavigator()->FindNextBoundaryAndStep(stepmax, compsafe);; 2739}; 2740 ; 2741////////////////////////////////////////////////////////////////////////////////; 2742/// Find distance to next boundary and store it in fStep. Returns node to which this; 2743/// boundary belongs. If PATH is specified, compute only distance to the node to which; 2744/// PATH points. If STEPMAX is specified, compute distance only in case fSafety is smaller; 2745/// than this value. STEPMAX represent the step to be made imposed by other reasons than; 2746/// geometry (usually physics processes). Therefore in this case this method provides the; 2747/// answer to the question : ""Is STEPMAX a safe step ?"" returning a NULL node and filling; 2748/// fStep with a big number.; 2749/// In case frombdr=kTRUE, the isotropic safety is set to zero.; 2750///; 2751/// Note : safety distance for the current point is computed ONLY in case STEPMAX is; 2752/// specified, otherwise users have to call explicitly TGeoManager::Safety() if; 2753/// they want this computed for the current point.; 2754 ; 2755TGeoNode *TGeoManager::FindNextBoundary(Double_t stepmax, const char *path, Bool_t frombdr); 2756{; 2757 // convert current point and direction to local reference; 2758 return GetCurrentNavigator()->FindNextBoundary(stepmax, path, frombdr);; 2759}; 2760 ; 2761////////////////////////////////////////////////////////////////////////////////; 2762/// Computes as fStep the distance to next daughter of the current volume.; 2763/// The point and direction must be converted in the coordinate system of the current volume.; 2764/// The proposed step limit is fStep.; 2765 ; 2766TGeoNode *TGeoManager::FindNextDaughterBoundary(Double_t *point, Double_t *dir, Int_t &idaughter, Bool_t compmatrix); 2767{; 2768 return G",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:98352,Safety,safe,safety,98352,"_t stepmax, Bool_t compsafe); 2737{; 2738 return GetCurrentNavigator()->FindNextBoundaryAndStep(stepmax, compsafe);; 2739}; 2740 ; 2741////////////////////////////////////////////////////////////////////////////////; 2742/// Find distance to next boundary and store it in fStep. Returns node to which this; 2743/// boundary belongs. If PATH is specified, compute only distance to the node to which; 2744/// PATH points. If STEPMAX is specified, compute distance only in case fSafety is smaller; 2745/// than this value. STEPMAX represent the step to be made imposed by other reasons than; 2746/// geometry (usually physics processes). Therefore in this case this method provides the; 2747/// answer to the question : ""Is STEPMAX a safe step ?"" returning a NULL node and filling; 2748/// fStep with a big number.; 2749/// In case frombdr=kTRUE, the isotropic safety is set to zero.; 2750///; 2751/// Note : safety distance for the current point is computed ONLY in case STEPMAX is; 2752/// specified, otherwise users have to call explicitly TGeoManager::Safety() if; 2753/// they want this computed for the current point.; 2754 ; 2755TGeoNode *TGeoManager::FindNextBoundary(Double_t stepmax, const char *path, Bool_t frombdr); 2756{; 2757 // convert current point and direction to local reference; 2758 return GetCurrentNavigator()->FindNextBoundary(stepmax, path, frombdr);; 2759}; 2760 ; 2761////////////////////////////////////////////////////////////////////////////////; 2762/// Computes as fStep the distance to next daughter of the current volume.; 2763/// The point and direction must be converted in the coordinate system of the current volume.; 2764/// The proposed step limit is fStep.; 2765 ; 2766TGeoNode *TGeoManager::FindNextDaughterBoundary(Double_t *point, Double_t *dir, Int_t &idaughter, Bool_t compmatrix); 2767{; 2768 return GetCurrentNavigator()->FindNextDaughterBoundary(point, dir, idaughter, compmatrix);; 2769}; 2770 ; 2771////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:137592,Safety,safe,safety,137592,"ng; 3750/// box will be sampled.; 3751 ; 3752void TGeoManager::CheckBoundaryErrors(Int_t ntracks, Double_t radius); 3753{; 3754 GetGeomPainter()->CheckBoundaryErrors(ntracks, radius);; 3755}; 3756 ; 3757////////////////////////////////////////////////////////////////////////////////; 3758/// Check the boundary errors reference file created by CheckBoundaryErrors method.; 3759/// The shape for which the crossing failed is drawn with the starting point in red; 3760/// and the extrapolated point to boundary (+/- failing push/pull) in yellow.; 3761 ; 3762void TGeoManager::CheckBoundaryReference(Int_t icheck); 3763{; 3764 GetGeomPainter()->CheckBoundaryReference(icheck);; 3765}; 3766 ; 3767////////////////////////////////////////////////////////////////////////////////; 3768/// Classify a given point. See TGeoChecker::CheckPoint().; 3769 ; 3770void TGeoManager::CheckPoint(Double_t x, Double_t y, Double_t z, Option_t *option, Double_t safety); 3771{; 3772 GetGeomPainter()->CheckPoint(x, y, z, option, safety);; 3773}; 3774 ; 3775////////////////////////////////////////////////////////////////////////////////; 3776/// Test for shape navigation methods. Summary for test numbers:; 3777/// - 1: DistFromInside/Outside. Sample points inside the shape. Generate; 3778/// directions randomly in cos(theta). Compute DistFromInside and move the; 3779/// point with bigger distance. Compute DistFromOutside back from new point.; 3780/// Plot d-(d1+d2); 3781///; 3782 ; 3783void TGeoManager::CheckShape(TGeoShape *shape, Int_t testNo, Int_t nsamples, Option_t *option); 3784{; 3785 GetGeomPainter()->CheckShape(shape, testNo, nsamples, option);; 3786}; 3787 ; 3788////////////////////////////////////////////////////////////////////////////////; 3789/// Geometry checking.; 3790/// - if option contains 'o': Optional overlap checkings (by sampling and by mesh).; 3791/// - if option contains 'b': Optional boundary crossing check + timing per volume.; 3792///; 3793/// STAGE 1: extensive overlap che",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:137659,Safety,safe,safety,137659,"ng; 3750/// box will be sampled.; 3751 ; 3752void TGeoManager::CheckBoundaryErrors(Int_t ntracks, Double_t radius); 3753{; 3754 GetGeomPainter()->CheckBoundaryErrors(ntracks, radius);; 3755}; 3756 ; 3757////////////////////////////////////////////////////////////////////////////////; 3758/// Check the boundary errors reference file created by CheckBoundaryErrors method.; 3759/// The shape for which the crossing failed is drawn with the starting point in red; 3760/// and the extrapolated point to boundary (+/- failing push/pull) in yellow.; 3761 ; 3762void TGeoManager::CheckBoundaryReference(Int_t icheck); 3763{; 3764 GetGeomPainter()->CheckBoundaryReference(icheck);; 3765}; 3766 ; 3767////////////////////////////////////////////////////////////////////////////////; 3768/// Classify a given point. See TGeoChecker::CheckPoint().; 3769 ; 3770void TGeoManager::CheckPoint(Double_t x, Double_t y, Double_t z, Option_t *option, Double_t safety); 3771{; 3772 GetGeomPainter()->CheckPoint(x, y, z, option, safety);; 3773}; 3774 ; 3775////////////////////////////////////////////////////////////////////////////////; 3776/// Test for shape navigation methods. Summary for test numbers:; 3777/// - 1: DistFromInside/Outside. Sample points inside the shape. Generate; 3778/// directions randomly in cos(theta). Compute DistFromInside and move the; 3779/// point with bigger distance. Compute DistFromOutside back from new point.; 3780/// Plot d-(d1+d2); 3781///; 3782 ; 3783void TGeoManager::CheckShape(TGeoShape *shape, Int_t testNo, Int_t nsamples, Option_t *option); 3784{; 3785 GetGeomPainter()->CheckShape(shape, testNo, nsamples, option);; 3786}; 3787 ; 3788////////////////////////////////////////////////////////////////////////////////; 3789/// Geometry checking.; 3790/// - if option contains 'o': Optional overlap checkings (by sampling and by mesh).; 3791/// - if option contains 'b': Optional boundary crossing check + timing per volume.; 3792///; 3793/// STAGE 1: extensive overlap che",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:157415,Safety,risk,risk,157415," ; 4283////////////////////////////////////////////////////////////////////////////////; 4284/// Activate/deactivate usage of parallel world navigation. Can only be done if; 4285/// there is a parallel world. Activating navigation will automatically close; 4286/// the parallel geometry.; 4287 ; 4288void TGeoManager::SetUseParallelWorldNav(Bool_t flag); 4289{; 4290 if (!fParallelWorld) {; 4291 Error(""SetUseParallelWorldNav"", ""No parallel world geometry defined. Use CreateParallelWorld."");; 4292 return;; 4293 }; 4294 if (!flag) {; 4295 fUsePWNav = flag;; 4296 return;; 4297 }; 4298 if (!fClosed) {; 4299 Error(""SetUseParallelWorldNav"", ""The geometry must be closed first"");; 4300 return;; 4301 }; 4302 // Closing the parallel world geometry is mandatory; 4303 if (fParallelWorld->CloseGeometry()); 4304 fUsePWNav = kTRUE;; 4305}; 4306 ; 4307Bool_t TGeoManager::LockDefaultUnits(Bool_t new_value); 4308{; 4309 Bool_t val = gGeometryLocked;; 4310 gGeometryLocked = new_value;; 4311 return val;; 4312}; 4313 ; 4314TGeoManager::EDefaultUnits TGeoManager::GetDefaultUnits(); 4315{; 4316 return fgDefaultUnits;; 4317}; 4318 ; 4319void TGeoManager::SetDefaultUnits(EDefaultUnits new_value); 4320{; 4321 if (fgDefaultUnits == new_value) {; 4322 gGeometryLocked = true;; 4323 return;; 4324 } else if (gGeometryLocked) {; 4325 ::Fatal(""TGeoManager"", ""The system of units may only be changed once, \n""; 4326 ""BEFORE any elements and materials are created! \n""; 4327 ""Alternatively unlock the default units at own risk."");; 4328 } else if (new_value == kG4Units) {; 4329 ::Info(""TGeoManager"", ""Changing system of units to Geant4 units (mm, ns, MeV)."");; 4330 } else if (new_value == kRootUnits) {; 4331 ::Info(""TGeoManager"", ""Changing system of units to ROOT units (cm, s, GeV)."");; 4332 }; 4333 fgDefaultUnits = new_value;; 4334}; 4335 ; 4336void TGeoManager::SetExportPrecision(UInt_t prec); 4337{; 4338 fgExportPrecision = prec;; 4339}; 4340 ; 4341UInt_t TGeoManager::GetExportPrecision(); 4342{; 4343 ret",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:212972,Safety,safe,safe,212972,"Geometryvoid CheckGeometry(Option_t *option="""")Perform last checks on the geometry.Definition TGeoManager.cxx:3831; TGeoManager::ExecuteEventvoid ExecuteEvent(Int_t event, Int_t px, Int_t py) overrideExecute mouse actions on this manager.Definition TGeoManager.cxx:3950; TGeoManager::MakeVolumeAssemblyTGeoVolumeAssembly * MakeVolumeAssembly(const char *name)Make an assembly of volumes.Definition TGeoManager.cxx:3553; TGeoManager::GetBombModeInt_t GetBombMode() constDefinition TGeoManager.h:210; TGeoManager::AddRegionInt_t AddRegion(TGeoRegion *region)Add a new region of volumes.Definition TGeoManager.cxx:633; TGeoManager::SelectTrackingMediavoid SelectTrackingMedia()Define different tracking media.Definition TGeoManager.cxx:3708; TGeoManager::CdNextvoid CdNext()Do a cd to the node found next by FindNextBoundary.Definition TGeoManager.cxx:1698; TGeoManager::CdTopvoid CdTop()Make top level node the current node.Definition TGeoManager.cxx:1672; TGeoManager::SafetyDouble_t Safety(Bool_t inside=kFALSE)Compute safe distance from the current point.Definition TGeoManager.cxx:2300; TGeoManager::fKeyPNEIdInt_t * fKeyPNEIdDefinition TGeoManager.h:142; TGeoManager::DefaultAnglesvoid DefaultAngles()Set default angles for a given view.Definition TGeoManager.cxx:1818; TGeoManager::MixtureTGeoMaterial * Mixture(const char *name, Float_t *a, Float_t *z, Double_t dens, Int_t nelem, Float_t *wmat, Int_t uid)Create mixture OR COMPOUND IMAT as composed by THE BASIC nelem materials defined by arrays A,...Definition TGeoManager.cxx:1296; TGeoManager::ThreadsMap_tstd::map< std::thread::id, Int_t > ThreadsMap_tDefinition TGeoManager.h:114; TGeoManager::CheckPointvoid CheckPoint(Double_t x=0, Double_t y=0, Double_t z=0, Option_t *option="""", Double_t safety=0.)Classify a given point. See TGeoChecker::CheckPoint().Definition TGeoManager.cxx:3770; TGeoManager::SetUseParallelWorldNavvoid SetUseParallelWorldNav(Bool_t flag)Activate/deactivate usage of parallel world navigation.Definition TGeoManage",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:213706,Safety,safe,safety,213706,"g media.Definition TGeoManager.cxx:3708; TGeoManager::CdNextvoid CdNext()Do a cd to the node found next by FindNextBoundary.Definition TGeoManager.cxx:1698; TGeoManager::CdTopvoid CdTop()Make top level node the current node.Definition TGeoManager.cxx:1672; TGeoManager::SafetyDouble_t Safety(Bool_t inside=kFALSE)Compute safe distance from the current point.Definition TGeoManager.cxx:2300; TGeoManager::fKeyPNEIdInt_t * fKeyPNEIdDefinition TGeoManager.h:142; TGeoManager::DefaultAnglesvoid DefaultAngles()Set default angles for a given view.Definition TGeoManager.cxx:1818; TGeoManager::MixtureTGeoMaterial * Mixture(const char *name, Float_t *a, Float_t *z, Double_t dens, Int_t nelem, Float_t *wmat, Int_t uid)Create mixture OR COMPOUND IMAT as composed by THE BASIC nelem materials defined by arrays A,...Definition TGeoManager.cxx:1296; TGeoManager::ThreadsMap_tstd::map< std::thread::id, Int_t > ThreadsMap_tDefinition TGeoManager.h:114; TGeoManager::CheckPointvoid CheckPoint(Double_t x=0, Double_t y=0, Double_t z=0, Option_t *option="""", Double_t safety=0.)Classify a given point. See TGeoChecker::CheckPoint().Definition TGeoManager.cxx:3770; TGeoManager::SetUseParallelWorldNavvoid SetUseParallelWorldNav(Bool_t flag)Activate/deactivate usage of parallel world navigation.Definition TGeoManager.cxx:4288; TGeoManager::Browsevoid Browse(TBrowser *b) overrideDescribe how to browse this object.Definition TGeoManager.cxx:1023; TGeoManager::Testvoid Test(Int_t npoints=1000000, Option_t *option="""")Check time of finding ""Where am I"" for n points.Definition TGeoManager.cxx:1942; TGeoManager::GetSafeLevelInt_t GetSafeLevel() constGo upwards the tree until a non-overlapping node.Definition TGeoManager.cxx:2251; TGeoManager::fGVolumesTObjArray * fGVolumeslist of runtime shapesDefinition TGeoManager.h:98; TGeoManager::SetBombFactorsvoid SetBombFactors(Double_t bombx=1.3, Double_t bomby=1.3, Double_t bombz=1.3, Double_t bombr=1.3)Set factors that will ""bomb"" all translations in cartesian and",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:224621,Safety,safe,safe,224621,"oNavigator.cxx:352; TGeoNavigator::DoBackupStatevoid DoBackupState()Backup the current state without affecting the cache stack.Definition TGeoNavigator.cxx:2648; TGeoNavigator::DoRestoreStatevoid DoRestoreState()Restore a backed-up state without affecting the cache stack.Definition TGeoNavigator.cxx:2657; TGeoNavigator::CrossBoundaryAndLocateTGeoNode * CrossBoundaryAndLocate(Bool_t downwards, TGeoNode *skipnode)Cross next boundary and locate within current node The current point must be on the boundary of fCurr...Definition TGeoNavigator.cxx:523; TGeoNavigator::GetHMatrixTGeoHMatrix * GetHMatrix()Return stored current matrix (global matrix of the next touched node).Definition TGeoNavigator.cxx:2670; TGeoNavigator::LocalToMastervoid LocalToMaster(const Double_t *local, Double_t *master) constDefinition TGeoNavigator.h:235; TGeoNavigator::CdNextvoid CdNext()Do a cd to the node found next by FindNextBoundary.Definition TGeoNavigator.cxx:405; TGeoNavigator::SafetyDouble_t Safety(Bool_t inside=kFALSE)Compute safe distance from the current point.Definition TGeoNavigator.cxx:1689; TGeoNavigator::GotoSafeLevelBool_t GotoSafeLevel()Go upwards the tree until a non-overlapping node.Definition TGeoNavigator.cxx:2357; TGeoNavigator::cdBool_t cd(const char *path="""")Browse the tree of nodes starting from top node according to pathname.Definition TGeoNavigator.cxx:210; TGeoNavigator::IsSameLocationBool_t IsSameLocation(Double_t x, Double_t y, Double_t z, Bool_t change=kFALSE)Checks if point (x,y,z) is still in the current node.Definition TGeoNavigator.cxx:2446; TGeoNavigator::MasterToLocalvoid MasterToLocal(const Double_t *master, Double_t *local) constDefinition TGeoNavigator.h:238; TGeoNavigator::GetVirtualLevelInt_t GetVirtualLevel()Find level of virtuality of current overlapping node (number of levels up having the same tracking me...Definition TGeoNavigator.cxx:2331; TGeoNavigator::InitTrackTGeoNode * InitTrack(const Double_t *point, const Double_t *dir)Initialize current poin",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:247962,Safety,safe,safety,247962," nfr=0, Double_t dlong=0, Double_t dlat=0, Double_t dpsi=0)=0; TVirtualGeoPainter::Testvirtual void Test(Int_t npoints, Option_t *option)=0; TVirtualGeoPainter::SetVisOptionvirtual void SetVisOption(Int_t option=0)=0; TVirtualGeoPainter::GetViewBoxvirtual Double_t * GetViewBox()=0; TVirtualGeoPainter::EstimateCameraMovevirtual void EstimateCameraMove(Double_t, Double_t, Double_t *, Double_t *)Definition TVirtualGeoPainter.h:83; TVirtualGeoPainter::CheckBoundaryReferencevirtual void CheckBoundaryReference(Int_t icheck=-1)=0; TVirtualGeoPainter::SetNsegmentsvirtual void SetNsegments(Int_t nseg=20)=0; TVirtualGeoPainter::RandomRaysvirtual void RandomRays(Int_t nrays, Double_t startx, Double_t starty, Double_t startz, const char *target_vol, Bool_t check_norm)=0; TVirtualGeoPainter::RandomPointsvirtual void RandomPoints(const TGeoVolume *vol, Int_t npoints, Option_t *option="""")=0; TVirtualGeoPainter::CountVisibleNodesvirtual Int_t CountVisibleNodes()=0; TVirtualGeoPainter::DefaultAnglesvirtual void DefaultAngles()=0; TVirtualGeoPainter::SetNmeshPointsvirtual void SetNmeshPoints(Int_t npoints)=0; TVirtualGeoPainter::UnbombTranslationvirtual void UnbombTranslation(const Double_t *tr, Double_t *bombtr)=0; TVirtualGeoPainter::EditGeometryvirtual void EditGeometry(Option_t *option="""")=0; TVirtualGeoPainter::GetBombFactorsvirtual void GetBombFactors(Double_t &bombx, Double_t &bomby, Double_t &bombz, Double_t &bombr) const =0; TVirtualGeoPainter::CheckPointvirtual void CheckPoint(Double_t x=0, Double_t y=0, Double_t z=0, Option_t *option="""", Double_t safety=0.)=0; TVirtualGeoPainter::BombTranslationvirtual void BombTranslation(const Double_t *tr, Double_t *bombtr)=0; TVirtualGeoPainter::CheckShapevirtual void CheckShape(TGeoShape *shape, Int_t testNo, Int_t nsamples, Option_t *option)=0; TVirtualGeoPainter::ExecuteManagerEventvirtual void ExecuteManagerEvent(TGeoManager *geom, Int_t event, Int_t px, Int_t py)=0; TVirtualGeoPainter::SetBombFactorsvirtual void SetBombFactors(Doub",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:6904,Security,validat,validated,6904,"al code. The mechanism of handling multiple geometries; 100at the same time will be soon implemented.; 101 ; 102 TGeoManager is the owner of all geometry objects defined in a session,; 103therefore users must not try to control their deletion. It contains lists of; 104media, materials, transformations, shapes and volumes. Logical nodes (positioned; 105volumes) are created and destroyed by the TGeoVolume class. Physical; 106nodes and their global transformations are subjected to a caching mechanism; 107due to the sometimes very large memory requirements of logical graph expansion.; 108The caching mechanism is triggered by the total number of physical instances; 109of volumes and the cache manager is a client of TGeoManager. The manager class; 110also controls the painter client. This is linked with ROOT graphical libraries; 111loaded on demand in order to control visualization actions.; 112 ; 113## Rules for building a valid geometry; 114 ; 115 A given geometry can be built in various ways, but there are mandatory steps; 116that have to be followed in order to be validated by the modeler. There are; 117general rules : volumes needs media and shapes in order to be created,; 118both container and containee volumes must be created before linking them together,; 119and the relative transformation matrix must be provided. All branches must; 120have an upper link point otherwise they will not be considered as part of the; 121geometry. Visibility or tracking properties of volumes can be provided both; 122at build time or after geometry is closed, but global visualization settings; 123(see TGeoPainter class) should not be provided at build time, otherwise the; 124drawing package will be loaded. There is also a list of specific rules :; 125positioned daughters should not extrude their mother or intersect with sisters; 126unless this is specified (see TGeoVolume::AddNodeOverlap()), the top volume; 127(containing all geometry tree) must be specified before closing the geometry; ",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:8748,Security,access,access,8748,"erlap()), the top volume; 127(containing all geometry tree) must be specified before closing the geometry; 128and must not be positioned - it represents the global reference frame. After; 129building the full geometry tree, the geometry must be closed; 130(see TGeoManager::CloseGeometry()). Voxelization can be redone per volume after; 131this process.; 132 ; 133 ; 134 Below is the general scheme of the manager class.; 135 ; 136\image html geom_mgr.jpg; 137 ; 138## An interactive session; 139 ; 140 Provided that a geometry was successfully built and closed (for instance the; 141previous example $ROOTSYS/tutorials/geom/rootgeom.C ), the manager class will register; 142itself to ROOT and the logical/physical structures will become immediately browsable.; 143The ROOT browser will display starting from the geometry folder : the list of; 144transformations and media, the top volume and the top logical node. These last; 145two can be fully expanded, any intermediate volume/node in the browser being subject; 146of direct access context menu operations (right mouse button click). All user; 147utilities of classes TGeoManager, TGeoVolume and TGeoNode can be called via the; 148context menu.; 149 ; 150\image html geom_browser.jpg; 151 ; 152### Drawing the geometry; 153 ; 154 Any logical volume can be drawn via TGeoVolume::Draw() member function.; 155This can be directly accessed from the context menu of the volume object; 156directly from the browser.; 157 There are several drawing options that can be set with; 158TGeoManager::SetVisOption(Int_t opt) method :; 159 ; 160#### opt=0; 161 only the content of the volume is drawn, N levels down (default N=3).; 162 This is the default behavior. The number of levels to be drawn can be changed; 163 via TGeoManager::SetVisLevel(Int_t level) method.; 164 ; 165\image html geom_frame0.jpg; 166 ; 167#### opt=1; 168 the final leaves (e.g. daughters with no containment) of the branch; 169 starting from volume are drawn down to the current numbe",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:9100,Security,access,accessed,9100,"ager class.; 135 ; 136\image html geom_mgr.jpg; 137 ; 138## An interactive session; 139 ; 140 Provided that a geometry was successfully built and closed (for instance the; 141previous example $ROOTSYS/tutorials/geom/rootgeom.C ), the manager class will register; 142itself to ROOT and the logical/physical structures will become immediately browsable.; 143The ROOT browser will display starting from the geometry folder : the list of; 144transformations and media, the top volume and the top logical node. These last; 145two can be fully expanded, any intermediate volume/node in the browser being subject; 146of direct access context menu operations (right mouse button click). All user; 147utilities of classes TGeoManager, TGeoVolume and TGeoNode can be called via the; 148context menu.; 149 ; 150\image html geom_browser.jpg; 151 ; 152### Drawing the geometry; 153 ; 154 Any logical volume can be drawn via TGeoVolume::Draw() member function.; 155This can be directly accessed from the context menu of the volume object; 156directly from the browser.; 157 There are several drawing options that can be set with; 158TGeoManager::SetVisOption(Int_t opt) method :; 159 ; 160#### opt=0; 161 only the content of the volume is drawn, N levels down (default N=3).; 162 This is the default behavior. The number of levels to be drawn can be changed; 163 via TGeoManager::SetVisLevel(Int_t level) method.; 164 ; 165\image html geom_frame0.jpg; 166 ; 167#### opt=1; 168 the final leaves (e.g. daughters with no containment) of the branch; 169 starting from volume are drawn down to the current number of levels.; 170 WARNING : This mode is memory consuming; 171 depending of the size of geometry, so drawing from top level within this mode; 172 should be handled with care for expensive geometries. In future there will be; 173 a limitation on the maximum number of nodes to be visualized.; 174 ; 175\image html geom_frame1.jpg; 176 ; 177#### opt=2; 178 only the clicked volume is visualized. This is automa",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:11208,Security,access,accessible,11208,"### opt=3 - only a given path is visualized. This is automatically set by; 182 TGeoVolume::DrawPath(const char *path) method; 183 ; 184 The current view can be exploded in cartesian, cylindrical or spherical; 185coordinates :; 186 TGeoManager::SetExplodedView(Int_t opt). Options may be :; 187- 0 - default (no bombing); 188- 1 - cartesian coordinates. The bomb factor on each axis can be set with; 189 TGeoManager::SetBombX(Double_t bomb) and corresponding Y and Z.; 190- 2 - bomb in cylindrical coordinates. Only the bomb factors on Z and R; 191 are considered; 192 \image html geom_frameexp.jpg; 193 ; 194- 3 - bomb in radial spherical coordinate : TGeoManager::SetBombR(); 195 ; 196Volumes themselves support different visualization settings :; 197 - TGeoVolume::SetVisibility() : set volume visibility.; 198 - TGeoVolume::VisibleDaughters() : set daughters visibility.; 199All these actions automatically updates the current view if any.; 200 ; 201### Checking the geometry; 202 ; 203 Several checking methods are accessible from the volume context menu. They; 204generally apply only to the visible parts of the drawn geometry in order to; 205ease geometry checking, and their implementation is in the TGeoChecker class; 206from the painting package.; 207 ; 208#### Checking a given point.; 209 Can be called from TGeoManager::CheckPoint(Double_t x, Double_t y, Double_t z).; 210This method is drawing the daughters of the volume containing the point one; 211level down, printing the path to the deepest physical node holding this point.; 212It also computes the closest distance to any boundary. The point will be drawn; 213in red, as well as a sphere having this closest distance as radius. In case a; 214non-zero distance is given by the user as fifth argument of CheckPoint, this; 215distance will be used as radius of the safety sphere.; 216 ; 217\image html geom_checkpoint.jpg; 218 ; 219#### Shooting random points.; 220 Can be called from TGeoVolume::RandomPoints() (context menu functio",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:25575,Security,access,access,25575,"41/// Add a user-defined property. Returns true if added, false if existing.; 642 ; 643Bool_t TGeoManager::AddProperty(const char *property, Double_t value); 644{; 645 auto pos = fProperties.insert(ConstPropMap_t::value_type(property, value));; 646 if (!pos.second) {; 647 Warning(""AddProperty"", ""Property \""%s\"" already exists with value %g"", property, (pos.first)->second);; 648 return false;; 649 }; 650 return true;; 651}; 652 ; 653////////////////////////////////////////////////////////////////////////////////; 654/// Get a user-defined property; 655 ; 656Double_t TGeoManager::GetProperty(const char *property, Bool_t *error) const; 657{; 658 auto pos = fProperties.find(property);; 659 if (pos == fProperties.end()) {; 660 if (error); 661 *error = kTRUE;; 662 return 0.;; 663 }; 664 if (error); 665 *error = kFALSE;; 666 return pos->second;; 667}; 668 ; 669////////////////////////////////////////////////////////////////////////////////; 670/// Get a user-defined property from a given index; 671 ; 672Double_t TGeoManager::GetProperty(size_t i, TString &name, Bool_t *error) const; 673{; 674 // This is a quite inefficient way to access map elements, but needed for the GDML writer to; 675 if (i >= fProperties.size()) {; 676 if (error); 677 *error = kTRUE;; 678 return 0.;; 679 }; 680 size_t pos = 0;; 681 auto it = fProperties.begin();; 682 while (pos < i) {; 683 ++it;; 684 ++pos;; 685 }; 686 if (error); 687 *error = kFALSE;; 688 name = (*it).first;; 689 return (*it).second;; 690}; 691 ; 692////////////////////////////////////////////////////////////////////////////////; 693/// Add a matrix to the list. Returns index of the matrix in list.; 694 ; 695Int_t TGeoManager::AddTransformation(const TGeoMatrix *matrix); 696{; 697 return TGeoBuilder::Instance(this)->AddTransformation((TGeoMatrix *)matrix);; 698}; 699 ; 700////////////////////////////////////////////////////////////////////////////////; 701/// Add a shape to the list. Returns index of the shape in list.; 702 ; 703Int_",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:153482,Security,access,access,153482,"; 4158 if (!gROOT->GetListOfBrowsables()->FindObject(gGeoManager)); 4159 gROOT->GetListOfBrowsables()->Add(gGeoManager);; 4160 gGeoManager->UpdateElements();; 4161 return gGeoManager;; 4162}; 4163 ; 4164////////////////////////////////////////////////////////////////////////////////; 4165/// Update element flags when geometry is loaded from a file.; 4166 ; 4167void TGeoManager::UpdateElements(); 4168{; 4169 if (!fElementTable); 4170 return;; 4171 TIter next(fMaterials);; 4172 TGeoMaterial *mat;; 4173 TGeoMixture *mix;; 4174 TGeoElement *elem, *elem_table;; 4175 Int_t i, nelem;; 4176 while ((mat = (TGeoMaterial *)next())) {; 4177 if (mat->IsMixture()) {; 4178 mix = (TGeoMixture *)mat;; 4179 nelem = mix->GetNelements();; 4180 for (i = 0; i < nelem; i++) {; 4181 elem = mix->GetElement(i);; 4182 if (!elem); 4183 continue;; 4184 elem_table = fElementTable->GetElement(elem->Z());; 4185 if (!elem_table); 4186 continue;; 4187 if (elem != elem_table) {; 4188 elem_table->SetDefined(elem->IsDefined());; 4189 elem_table->SetUsed(elem->IsUsed());; 4190 } else {; 4191 elem_table->SetDefined();; 4192 }; 4193 }; 4194 } else {; 4195 elem = mat->GetElement();; 4196 if (!elem); 4197 continue;; 4198 elem_table = fElementTable->GetElement(elem->Z());; 4199 if (!elem_table); 4200 continue;; 4201 if (elem != elem_table) {; 4202 elem_table->SetDefined(elem->IsDefined());; 4203 elem_table->SetUsed(elem->IsUsed());; 4204 } else {; 4205 elem_table->SetUsed();; 4206 }; 4207 }; 4208 }; 4209}; 4210 ; 4211////////////////////////////////////////////////////////////////////////////////; 4212/// Initialize PNE array for fast access via index and unique-id.; 4213 ; 4214Bool_t TGeoManager::InitArrayPNE() const; 4215{; 4216 if (fHashPNE) {; 4217 fArrayPNE = new TObjArray(fHashPNE->GetSize());; 4218 TIter next(fHashPNE);; 4219 TObject *obj;; 4220 while ((obj = next())) {; 4221 fArrayPNE->Add(obj);; 4222 }; 4223 return kTRUE;; 4224 }; 4225 return kFALSE;; 4226}; 4227 ; 4228///////////////////////////////",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:180791,Security,access,access,180791," EDefaultUnits GetDefaultUnits()Definition TGeoManager.cxx:4314; TGeoManager::RemoveMaterialvoid RemoveMaterial(Int_t index)Remove material at given index.Definition TGeoManager.cxx:3086; TGeoManager::Matrixvoid Matrix(Int_t index, Double_t theta1, Double_t phi1, Double_t theta2, Double_t phi2, Double_t theta3, Double_t phi3)Create rotation matrix named 'mat<index>'.Definition TGeoManager.cxx:1276; TGeoManager::GetElementTableTGeoElementTable * GetElementTable()Returns material table. Creates it if not existing.Definition TGeoManager.cxx:3624; TGeoManager::fNtracksInt_t fNtracksDefinition TGeoManager.h:74; TGeoManager::fHashPNETHashList * fHashPNEhash list of group volumes providing fast searchDefinition TGeoManager.h:138; TGeoManager::fgVerboseLevelstatic Int_t fgVerboseLevelLock preventing a second geometry to be loaded.Definition TGeoManager.h:51; TGeoManager::Initvoid Init()Initialize manager class.Definition TGeoManager.cxx:416; TGeoManager::InitArrayPNEBool_t InitArrayPNE() constInitialize PNE array for fast access via index and unique-id.Definition TGeoManager.cxx:4214; TGeoManager::fPhysicalNodesTObjArray * fPhysicalNodesDefinition TGeoManager.h:96; TGeoManager::SizeOfvirtual ULong_t SizeOf(const TGeoNode *node, Option_t *option)computes the total size in bytes of the branch starting with node.Definition TGeoManager.cxx:3926; TGeoManager::fUniqueVolumesTObjArray * fUniqueVolumesDefinition TGeoManager.h:129; TGeoManager::fgExportPrecisionstatic UInt_t fgExportPrecisionMaximum number of Xtru vertices.Definition TGeoManager.h:55; TGeoManager::fRegionsTObjArray * fRegionsDefinition TGeoManager.h:109; TGeoManager::Nodevoid Node(const char *name, Int_t nr, const char *mother, Double_t x, Double_t y, Double_t z, Int_t irot, Bool_t isOnly, Float_t *upar, Int_t npar=0)Create a node called <name_nr> pointing to the volume called <name> as daughter of the volume called ...Definition TGeoManager.cxx:1353; TGeoManager::fGShapesTObjArray * fGShapesDefinition TGeoManager.h",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:238088,Security,hash,hash,238088,"::CreateDummyMediumstatic void CreateDummyMedium()Create a dummy medium.Definition TGeoVolume.cxx:412; TGeoVolume::SetLineStylevoid SetLineStyle(Style_t lstyle) overrideSet the line style.Definition TGeoVolume.cxx:2177; TGeoVolume::IsAssemblyvirtual Bool_t IsAssembly() constReturns true if the volume is an assembly or a scaled assembly.Definition TGeoVolume.cxx:1822; TGeoVolume::MakeReflectedVolumeTGeoVolume * MakeReflectedVolume(const char *newname="""") constMake a copy of this volume which is reflected with respect to XY plane.Definition TGeoVolume.cxx:1958; TGeoVolume::IsVisiblevirtual Bool_t IsVisible() constDefinition TGeoVolume.h:155; TGeoVoxelFinderFinder class handling voxels.Definition TGeoVoxelFinder.h:20; TGeoVoxelFinder::SetNeedRebuildvoid SetNeedRebuild(Bool_t flag=kTRUE)Definition TGeoVoxelFinder.h:107; TGeoXtruDefinition TGeoXtru.h:22; TGeoXtru::GetNvertInt_t GetNvert() constDefinition TGeoXtru.h:96; TGeoXtru::Classstatic TClass * Class(); THashListTHashList implements a hybrid collection class consisting of a hash table and a list to store TObject...Definition THashList.h:34; THashList::Deletevoid Delete(Option_t *option="""") overrideRemove all objects from the list AND delete all heap based objects.Definition THashList.cxx:207; THashList::Clearvoid Clear(Option_t *option="""") overrideRemove all objects from the list.Definition THashList.cxx:189; THashList::FindObjectTObject * FindObject(const char *name) const overrideFind object using its name.Definition THashList.cxx:262; THashList::AddLastvoid AddLast(TObject *obj) overrideAdd object at the end of the list.Definition THashList.cxx:95; TIterDefinition TCollection.h:235; TKeyBook space in a file, create I/O buffers, to fill them, (un)compress them.Definition TKey.h:28; TKey::GetClassNamevirtual const char * GetClassName() constDefinition TKey.h:75; TKey::ReadObjvirtual TObject * ReadObj()To read a TObject* from the file.Definition TKey.cxx:759; TList::FindObjectTObject * FindObject(const char *name) co",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:2693,Testability,log,logical,2693,"tions like ""Where am I ?"" or ""How far; 33from the next boundary ?"", but also to more complex ones like ""How far from; 34the closest surface ?"" or ""Which is the next crossing along a helix ?"".; 35 ; 36 The architecture of the modeler is a combination between a GEANT-like; 37containment scheme and a normal CSG binary tree at the level of shapes. An; 38important common feature of all detector geometry descriptions is the; 39mother-daughter concept. This is the most natural approach when tracking; 40is concerned and imposes a set of constraints to the way geometry is defined.; 41Constructive solid geometry composition is used only in order to create more; 42complex shapes from an existing set of primitives through boolean operations.; 43This feature is not implemented yet but in future full definition of boolean; 44expressions will be supported.; 45 ; 46 Practically every geometry defined in GEANT style can be mapped by the modeler.; 47The basic components used for building the logical hierarchy of the geometry; 48are called ""volumes"" and ""nodes"". Volumes (sometimes called ""solids"") are fully; 49defined geometrical objects having a given shape and medium and possibly; 50containing a list of nodes. Nodes represent just positioned instances of volumes; 51inside a container volume and they are not directly defined by user. They are; 52automatically created as a result of adding one volume inside other or dividing; 53a volume. The geometrical transformation hold by nodes is always defined with; 54respect to their mother (relative positioning). Reflection matrices are allowed.; 55All volumes have to be fully aware of their containees when the geometry is; 56closed. They will build additional structures (voxels) in order to fasten-up; 57the search algorithms. Finally, nodes can be regarded as bidirectional links; 58between containers and containees objects.; 59 ; 60 The structure defined in this way is a graph structure since volumes are; 61replicable (same volume can become d",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:3812,Testability,log,logical,3812,"given shape and medium and possibly; 50containing a list of nodes. Nodes represent just positioned instances of volumes; 51inside a container volume and they are not directly defined by user. They are; 52automatically created as a result of adding one volume inside other or dividing; 53a volume. The geometrical transformation hold by nodes is always defined with; 54respect to their mother (relative positioning). Reflection matrices are allowed.; 55All volumes have to be fully aware of their containees when the geometry is; 56closed. They will build additional structures (voxels) in order to fasten-up; 57the search algorithms. Finally, nodes can be regarded as bidirectional links; 58between containers and containees objects.; 59 ; 60 The structure defined in this way is a graph structure since volumes are; 61replicable (same volume can become daughter node of several other volumes),; 62every volume becoming a branch in this graph. Any volume in the logical graph; 63can become the actual top volume at run time (see TGeoManager::SetTopVolume()).; 64All functionalities of the modeler will behave in this case as if only the; 65corresponding branch starting from this volume is the registered geometry.; 66 ; 67\image html geom_graf.jpg; 68 ; 69 A given volume can be positioned several times in the geometry. A volume; 70can be divided according default or user-defined patterns, creating automatically; 71the list of division nodes inside. The elementary volumes created during the; 72dividing process follow the same scheme as usual volumes, therefore it is possible; 73to position further geometrical structures inside or to divide them further more; 74(see TGeoVolume::Divide()).; 75 ; 76 The primitive shapes supported by the package are basically the GEANT3; 77shapes (see class TGeoShape), arbitrary wedges with eight vertices on two parallel; 78planes. All basic primitives inherits from class TGeoBBox since the bounding box; 79of a solid is essential for the tracking algorithms",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:6387,Testability,log,logical,6387,"ombinator and it has to be; 86constructed providing a string boolean expression between the components names.; 87 ; 88 ; 89## Example for building a simple geometry; 90 ; 91Begin_Macro(source); 92../../../tutorials/geom/rootgeom.C; 93End_Macro; 94 ; 95## TGeoManager - the manager class for the geometry package.; 96 ; 97 TGeoManager class is embedding all the API needed for building and tracking; 98a geometry. It defines a global pointer (gGeoManager) in order to be fully; 99accessible from external code. The mechanism of handling multiple geometries; 100at the same time will be soon implemented.; 101 ; 102 TGeoManager is the owner of all geometry objects defined in a session,; 103therefore users must not try to control their deletion. It contains lists of; 104media, materials, transformations, shapes and volumes. Logical nodes (positioned; 105volumes) are created and destroyed by the TGeoVolume class. Physical; 106nodes and their global transformations are subjected to a caching mechanism; 107due to the sometimes very large memory requirements of logical graph expansion.; 108The caching mechanism is triggered by the total number of physical instances; 109of volumes and the cache manager is a client of TGeoManager. The manager class; 110also controls the painter client. This is linked with ROOT graphical libraries; 111loaded on demand in order to control visualization actions.; 112 ; 113## Rules for building a valid geometry; 114 ; 115 A given geometry can be built in various ways, but there are mandatory steps; 116that have to be followed in order to be validated by the modeler. There are; 117general rules : volumes needs media and shapes in order to be created,; 118both container and containee volumes must be created before linking them together,; 119and the relative transformation matrix must be provided. All branches must; 120have an upper link point otherwise they will not be considered as part of the; 121geometry. Visibility or tracking properties of volumes can",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:8417,Testability,log,logical,8417,"ettings; 123(see TGeoPainter class) should not be provided at build time, otherwise the; 124drawing package will be loaded. There is also a list of specific rules :; 125positioned daughters should not extrude their mother or intersect with sisters; 126unless this is specified (see TGeoVolume::AddNodeOverlap()), the top volume; 127(containing all geometry tree) must be specified before closing the geometry; 128and must not be positioned - it represents the global reference frame. After; 129building the full geometry tree, the geometry must be closed; 130(see TGeoManager::CloseGeometry()). Voxelization can be redone per volume after; 131this process.; 132 ; 133 ; 134 Below is the general scheme of the manager class.; 135 ; 136\image html geom_mgr.jpg; 137 ; 138## An interactive session; 139 ; 140 Provided that a geometry was successfully built and closed (for instance the; 141previous example $ROOTSYS/tutorials/geom/rootgeom.C ), the manager class will register; 142itself to ROOT and the logical/physical structures will become immediately browsable.; 143The ROOT browser will display starting from the geometry folder : the list of; 144transformations and media, the top volume and the top logical node. These last; 145two can be fully expanded, any intermediate volume/node in the browser being subject; 146of direct access context menu operations (right mouse button click). All user; 147utilities of classes TGeoManager, TGeoVolume and TGeoNode can be called via the; 148context menu.; 149 ; 150\image html geom_browser.jpg; 151 ; 152### Drawing the geometry; 153 ; 154 Any logical volume can be drawn via TGeoVolume::Draw() member function.; 155This can be directly accessed from the context menu of the volume object; 156directly from the browser.; 157 There are several drawing options that can be set with; 158TGeoManager::SetVisOption(Int_t opt) method :; 159 ; 160#### opt=0; 161 only the content of the volume is drawn, N levels down (default N=3).; 162 This is the default be",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:8620,Testability,log,logical,8620,"list of specific rules :; 125positioned daughters should not extrude their mother or intersect with sisters; 126unless this is specified (see TGeoVolume::AddNodeOverlap()), the top volume; 127(containing all geometry tree) must be specified before closing the geometry; 128and must not be positioned - it represents the global reference frame. After; 129building the full geometry tree, the geometry must be closed; 130(see TGeoManager::CloseGeometry()). Voxelization can be redone per volume after; 131this process.; 132 ; 133 ; 134 Below is the general scheme of the manager class.; 135 ; 136\image html geom_mgr.jpg; 137 ; 138## An interactive session; 139 ; 140 Provided that a geometry was successfully built and closed (for instance the; 141previous example $ROOTSYS/tutorials/geom/rootgeom.C ), the manager class will register; 142itself to ROOT and the logical/physical structures will become immediately browsable.; 143The ROOT browser will display starting from the geometry folder : the list of; 144transformations and media, the top volume and the top logical node. These last; 145two can be fully expanded, any intermediate volume/node in the browser being subject; 146of direct access context menu operations (right mouse button click). All user; 147utilities of classes TGeoManager, TGeoVolume and TGeoNode can be called via the; 148context menu.; 149 ; 150\image html geom_browser.jpg; 151 ; 152### Drawing the geometry; 153 ; 154 Any logical volume can be drawn via TGeoVolume::Draw() member function.; 155This can be directly accessed from the context menu of the volume object; 156directly from the browser.; 157 There are several drawing options that can be set with; 158TGeoManager::SetVisOption(Int_t opt) method :; 159 ; 160#### opt=0; 161 only the content of the volume is drawn, N levels down (default N=3).; 162 This is the default behavior. The number of levels to be drawn can be changed; 163 via TGeoManager::SetVisLevel(Int_t level) method.; 164 ; 165\image html geom_fr",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:9007,Testability,log,logical,9007,"xelization can be redone per volume after; 131this process.; 132 ; 133 ; 134 Below is the general scheme of the manager class.; 135 ; 136\image html geom_mgr.jpg; 137 ; 138## An interactive session; 139 ; 140 Provided that a geometry was successfully built and closed (for instance the; 141previous example $ROOTSYS/tutorials/geom/rootgeom.C ), the manager class will register; 142itself to ROOT and the logical/physical structures will become immediately browsable.; 143The ROOT browser will display starting from the geometry folder : the list of; 144transformations and media, the top volume and the top logical node. These last; 145two can be fully expanded, any intermediate volume/node in the browser being subject; 146of direct access context menu operations (right mouse button click). All user; 147utilities of classes TGeoManager, TGeoVolume and TGeoNode can be called via the; 148context menu.; 149 ; 150\image html geom_browser.jpg; 151 ; 152### Drawing the geometry; 153 ; 154 Any logical volume can be drawn via TGeoVolume::Draw() member function.; 155This can be directly accessed from the context menu of the volume object; 156directly from the browser.; 157 There are several drawing options that can be set with; 158TGeoManager::SetVisOption(Int_t opt) method :; 159 ; 160#### opt=0; 161 only the content of the volume is drawn, N levels down (default N=3).; 162 This is the default behavior. The number of levels to be drawn can be changed; 163 via TGeoManager::SetVisLevel(Int_t level) method.; 164 ; 165\image html geom_frame0.jpg; 166 ; 167#### opt=1; 168 the final leaves (e.g. daughters with no containment) of the branch; 169 starting from volume are drawn down to the current number of levels.; 170 WARNING : This mode is memory consuming; 171 depending of the size of geometry, so drawing from top level within this mode; 172 should be handled with care for expensive geometries. In future there will be; 173 a limitation on the maximum number of nodes to be visualized.; 17",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:104724,Testability,log,logical,104724,"or the current state.; 2872 ; 2873void TGeoManager::InspectState() const; 2874{; 2875 GetCurrentNavigator()->InspectState();; 2876}; 2877 ; 2878////////////////////////////////////////////////////////////////////////////////; 2879/// Get path to the current node in the form /node0/node1/...; 2880 ; 2881const char *TGeoManager::GetPath() const; 2882{; 2883 return GetCurrentNavigator()->GetPath();; 2884}; 2885 ; 2886////////////////////////////////////////////////////////////////////////////////; 2887/// Get total size of geometry in bytes.; 2888 ; 2889Int_t TGeoManager::GetByteCount(Option_t * /*option*/); 2890{; 2891 Int_t count = 0;; 2892 TIter next(fVolumes);; 2893 TGeoVolume *vol;; 2894 while ((vol = (TGeoVolume *)next())); 2895 count += vol->GetByteCount();; 2896 TIter next1(fMatrices);; 2897 TGeoMatrix *matrix;; 2898 while ((matrix = (TGeoMatrix *)next1())); 2899 count += matrix->GetByteCount();; 2900 TIter next2(fMaterials);; 2901 TGeoMaterial *mat;; 2902 while ((mat = (TGeoMaterial *)next2())); 2903 count += mat->GetByteCount();; 2904 TIter next3(fMedia);; 2905 TGeoMedium *med;; 2906 while ((med = (TGeoMedium *)next3())); 2907 count += med->GetByteCount();; 2908 if (fgVerboseLevel > 0); 2909 Info(""GetByteCount"", ""Total size of logical tree : %i bytes"", count);; 2910 return count;; 2911}; 2912 ; 2913////////////////////////////////////////////////////////////////////////////////; 2914/// Make a default painter if none present. Returns pointer to it.; 2915 ; 2916TVirtualGeoPainter *TGeoManager::GetGeomPainter(); 2917{; 2918 if (!fPainter) {; 2919 const char *kind = gEnv->GetValue(""GeomPainter.Name"", """");; 2920 if (!kind || !*kind); 2921 kind = (gROOT->IsWebDisplay() && !gROOT->IsWebDisplayBatch()) ? ""web"" : ""root"";; 2922 if (auto h = gROOT->GetPluginManager()->FindHandler(""TVirtualGeoPainter"", kind)) {; 2923 if (h->LoadPlugin() == -1) {; 2924 Error(""GetGeomPainter"", ""could not load plugin for %s geo_painter"", kind);; 2925 return nullptr;; 2926 }; 2927 fPainter ",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:134733,Testability,log,logical,134733,"lptr;; 3663 ; 3664 if (fTopVolume); 3665 fTopVolume->SetTitle("""");; 3666 fTopVolume = vol;; 3667 vol->SetTitle(""Top volume"");; 3668 if (fTopNode) {; 3669 TGeoNode *topn = fTopNode;; 3670 fTopNode = nullptr;; 3671 while ((browser = (TBrowser *)next())); 3672 browser->RecursiveRemove(topn);; 3673 delete topn;; 3674 } else {; 3675 fMasterVolume = vol;; 3676 fMasterVolume->Grab();; 3677 fUniqueVolumes->AddAtAndExpand(vol, 0);; 3678 if (fgVerboseLevel > 0); 3679 Info(""SetTopVolume"", ""Top volume is %s. Master volume is %s"", fTopVolume->GetName(), fMasterVolume->GetName());; 3680 }; 3681 // fMasterVolume->FindMatrixOfDaughterVolume(vol);; 3682 // fCurrentMatrix->Print();; 3683 fTopNode = new TGeoNodeMatrix(vol, gGeoIdentity);; 3684 fTopNode->SetName(TString::Format(""%s_1"", vol->GetName()));; 3685 fTopNode->SetNumber(1);; 3686 fTopNode->SetTitle(""Top logical node"");; 3687 fNodes->AddAt(fTopNode, 0);; 3688 if (!GetCurrentNavigator()) {; 3689 fCurrentNavigator = AddNavigator();; 3690 return;; 3691 }; 3692 Int_t nnavigators = 0;; 3693 TGeoNavigatorArray *arr = GetListOfNavigators();; 3694 if (!arr); 3695 return;; 3696 nnavigators = arr->GetEntriesFast();; 3697 for (Int_t i = 0; i < nnavigators; i++) {; 3698 TGeoNavigator *nav = (TGeoNavigator *)arr->At(i);; 3699 nav->ResetAll();; 3700 if (fClosed); 3701 nav->GetCache()->BuildInfoBranch();; 3702 }; 3703}; 3704 ; 3705////////////////////////////////////////////////////////////////////////////////; 3706/// Define different tracking media.; 3707 ; 3708void TGeoManager::SelectTrackingMedia(); 3709{; 3710 /*; 3711 Int_t nmat = fMaterials->GetSize();; 3712 if (!nmat) {printf("" No materials !\n""); return;}; 3713 Int_t *media = new Int_t[nmat];; 3714 memset(media, 0, nmat*sizeof(Int_t));; 3715 Int_t imedia = 1;; 3716 TGeoMaterial *mat, *matref;; 3717 mat = (TGeoMaterial*)fMaterials->At(0);; 3718 if (mat->GetMedia()) {; 3719 for (Int_t i=0; i<nmat; i++) {; 3720 mat = (TGeoMaterial*)fMaterials->At(i);; 3721 mat->Print();; 3722 }; 3723 re",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:137824,Testability,test,test,137824,"56 ; 3757////////////////////////////////////////////////////////////////////////////////; 3758/// Check the boundary errors reference file created by CheckBoundaryErrors method.; 3759/// The shape for which the crossing failed is drawn with the starting point in red; 3760/// and the extrapolated point to boundary (+/- failing push/pull) in yellow.; 3761 ; 3762void TGeoManager::CheckBoundaryReference(Int_t icheck); 3763{; 3764 GetGeomPainter()->CheckBoundaryReference(icheck);; 3765}; 3766 ; 3767////////////////////////////////////////////////////////////////////////////////; 3768/// Classify a given point. See TGeoChecker::CheckPoint().; 3769 ; 3770void TGeoManager::CheckPoint(Double_t x, Double_t y, Double_t z, Option_t *option, Double_t safety); 3771{; 3772 GetGeomPainter()->CheckPoint(x, y, z, option, safety);; 3773}; 3774 ; 3775////////////////////////////////////////////////////////////////////////////////; 3776/// Test for shape navigation methods. Summary for test numbers:; 3777/// - 1: DistFromInside/Outside. Sample points inside the shape. Generate; 3778/// directions randomly in cos(theta). Compute DistFromInside and move the; 3779/// point with bigger distance. Compute DistFromOutside back from new point.; 3780/// Plot d-(d1+d2); 3781///; 3782 ; 3783void TGeoManager::CheckShape(TGeoShape *shape, Int_t testNo, Int_t nsamples, Option_t *option); 3784{; 3785 GetGeomPainter()->CheckShape(shape, testNo, nsamples, option);; 3786}; 3787 ; 3788////////////////////////////////////////////////////////////////////////////////; 3789/// Geometry checking.; 3790/// - if option contains 'o': Optional overlap checkings (by sampling and by mesh).; 3791/// - if option contains 'b': Optional boundary crossing check + timing per volume.; 3792///; 3793/// STAGE 1: extensive overlap checking by sampling per volume. Stdout need to be; 3794/// checked by user to get report, then TGeoVolume::CheckOverlaps(0.01, ""s"") can; 3795/// be called for the suspicious volumes.; 3796///; 379",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:138177,Testability,test,testNo,138177,"_t icheck); 3763{; 3764 GetGeomPainter()->CheckBoundaryReference(icheck);; 3765}; 3766 ; 3767////////////////////////////////////////////////////////////////////////////////; 3768/// Classify a given point. See TGeoChecker::CheckPoint().; 3769 ; 3770void TGeoManager::CheckPoint(Double_t x, Double_t y, Double_t z, Option_t *option, Double_t safety); 3771{; 3772 GetGeomPainter()->CheckPoint(x, y, z, option, safety);; 3773}; 3774 ; 3775////////////////////////////////////////////////////////////////////////////////; 3776/// Test for shape navigation methods. Summary for test numbers:; 3777/// - 1: DistFromInside/Outside. Sample points inside the shape. Generate; 3778/// directions randomly in cos(theta). Compute DistFromInside and move the; 3779/// point with bigger distance. Compute DistFromOutside back from new point.; 3780/// Plot d-(d1+d2); 3781///; 3782 ; 3783void TGeoManager::CheckShape(TGeoShape *shape, Int_t testNo, Int_t nsamples, Option_t *option); 3784{; 3785 GetGeomPainter()->CheckShape(shape, testNo, nsamples, option);; 3786}; 3787 ; 3788////////////////////////////////////////////////////////////////////////////////; 3789/// Geometry checking.; 3790/// - if option contains 'o': Optional overlap checkings (by sampling and by mesh).; 3791/// - if option contains 'b': Optional boundary crossing check + timing per volume.; 3792///; 3793/// STAGE 1: extensive overlap checking by sampling per volume. Stdout need to be; 3794/// checked by user to get report, then TGeoVolume::CheckOverlaps(0.01, ""s"") can; 3795/// be called for the suspicious volumes.; 3796///; 3797/// STAGE 2: normal overlap checking using the shapes mesh - fills the list of; 3798/// overlaps.; 3799///; 3800/// STAGE 3: shooting NRAYS rays from VERTEX and counting the total number of; 3801/// crossings per volume (rays propagated from boundary to boundary until; 3802/// geometry exit). Timing computed and results stored in a histo.; 3803///; 3804/// STAGE 4: shooting 1 mil. random rays inside EAC",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:138268,Testability,test,testNo,138268,"_t icheck); 3763{; 3764 GetGeomPainter()->CheckBoundaryReference(icheck);; 3765}; 3766 ; 3767////////////////////////////////////////////////////////////////////////////////; 3768/// Classify a given point. See TGeoChecker::CheckPoint().; 3769 ; 3770void TGeoManager::CheckPoint(Double_t x, Double_t y, Double_t z, Option_t *option, Double_t safety); 3771{; 3772 GetGeomPainter()->CheckPoint(x, y, z, option, safety);; 3773}; 3774 ; 3775////////////////////////////////////////////////////////////////////////////////; 3776/// Test for shape navigation methods. Summary for test numbers:; 3777/// - 1: DistFromInside/Outside. Sample points inside the shape. Generate; 3778/// directions randomly in cos(theta). Compute DistFromInside and move the; 3779/// point with bigger distance. Compute DistFromOutside back from new point.; 3780/// Plot d-(d1+d2); 3781///; 3782 ; 3783void TGeoManager::CheckShape(TGeoShape *shape, Int_t testNo, Int_t nsamples, Option_t *option); 3784{; 3785 GetGeomPainter()->CheckShape(shape, testNo, nsamples, option);; 3786}; 3787 ; 3788////////////////////////////////////////////////////////////////////////////////; 3789/// Geometry checking.; 3790/// - if option contains 'o': Optional overlap checkings (by sampling and by mesh).; 3791/// - if option contains 'b': Optional boundary crossing check + timing per volume.; 3792///; 3793/// STAGE 1: extensive overlap checking by sampling per volume. Stdout need to be; 3794/// checked by user to get report, then TGeoVolume::CheckOverlaps(0.01, ""s"") can; 3795/// be called for the suspicious volumes.; 3796///; 3797/// STAGE 2: normal overlap checking using the shapes mesh - fills the list of; 3798/// overlaps.; 3799///; 3800/// STAGE 3: shooting NRAYS rays from VERTEX and counting the total number of; 3801/// crossings per volume (rays propagated from boundary to boundary until; 3802/// geometry exit). Timing computed and results stored in a histo.; 3803///; 3804/// STAGE 4: shooting 1 mil. random rays inside EAC",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:199699,Testability,test,testNo,199699,":SetNavigatorsLockstatic void SetNavigatorsLock(Bool_t flag)Set the lock for navigators.Definition TGeoManager.cxx:873; TGeoManager::fgMaxXtruVertstatic Int_t fgMaxXtruVertMaximum number of daughters.Definition TGeoManager.h:54; TGeoManager::FindNodeTGeoNode * FindNode(Bool_t safe_start=kTRUE)Returns deepest node containing current point.Definition TGeoManager.cxx:2782; TGeoManager::GetVisOptionInt_t GetVisOption() constReturns current depth to which geometry is drawn.Definition TGeoManager.cxx:2157; TGeoManager::LockGeometrystatic void LockGeometry()Lock current geometry so that no other geometry can be imported.Definition TGeoManager.cxx:4040; TGeoManager::MakeBoxTGeoVolume * MakeBox(const char *name, TGeoMedium *medium, Double_t dx, Double_t dy, Double_t dz)Make in one step a volume pointing to a box shape with given medium.Definition TGeoManager.cxx:3169; TGeoManager::fNPNEIdInt_t fNPNEIdDefinition TGeoManager.h:141; TGeoManager::CheckShapevoid CheckShape(TGeoShape *shape, Int_t testNo, Int_t nsamples, Option_t *option)Test for shape navigation methods.Definition TGeoManager.cxx:3783; TGeoManager::fgMaxLevelstatic Int_t fgMaxLevelVerbosity level for Info messages (no IO).Definition TGeoManager.h:52; TGeoManager::fNpdgInt_t fNpdgcurrent trackDefinition TGeoManager.h:77; TGeoManager::PrintOverlapsvoid PrintOverlaps() constPrints the current list of overlaps.Definition TGeoManager.cxx:3881; TGeoManager::MakeTrd1TGeoVolume * MakeTrd1(const char *name, TGeoMedium *medium, Double_t dx1, Double_t dx2, Double_t dy, Double_t dz)Make in one step a volume pointing to a TGeoTrd1 shape with given medium.Definition TGeoManager.cxx:3293; TGeoManager::MakeSphereTGeoVolume * MakeSphere(const char *name, TGeoMedium *medium, Double_t rmin, Double_t rmax, Double_t themin=0, Double_t themax=180, Double_t phimin=0, Double_t phimax=360)Make in one step a volume pointing to a sphere shape with given medium.Definition TGeoManager.cxx:3186; TGeoManager::ResetUserDatavoid ResetUserData()Se",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:248159,Testability,test,testNo,248159,"omPointsvirtual void RandomPoints(const TGeoVolume *vol, Int_t npoints, Option_t *option="""")=0; TVirtualGeoPainter::CountVisibleNodesvirtual Int_t CountVisibleNodes()=0; TVirtualGeoPainter::DefaultAnglesvirtual void DefaultAngles()=0; TVirtualGeoPainter::SetNmeshPointsvirtual void SetNmeshPoints(Int_t npoints)=0; TVirtualGeoPainter::UnbombTranslationvirtual void UnbombTranslation(const Double_t *tr, Double_t *bombtr)=0; TVirtualGeoPainter::EditGeometryvirtual void EditGeometry(Option_t *option="""")=0; TVirtualGeoPainter::GetBombFactorsvirtual void GetBombFactors(Double_t &bombx, Double_t &bomby, Double_t &bombz, Double_t &bombr) const =0; TVirtualGeoPainter::CheckPointvirtual void CheckPoint(Double_t x=0, Double_t y=0, Double_t z=0, Option_t *option="""", Double_t safety=0.)=0; TVirtualGeoPainter::BombTranslationvirtual void BombTranslation(const Double_t *tr, Double_t *bombtr)=0; TVirtualGeoPainter::CheckShapevirtual void CheckShape(TGeoShape *shape, Int_t testNo, Int_t nsamples, Option_t *option)=0; TVirtualGeoPainter::ExecuteManagerEventvirtual void ExecuteManagerEvent(TGeoManager *geom, Int_t event, Int_t px, Int_t py)=0; TVirtualGeoPainter::SetBombFactorsvirtual void SetBombFactors(Double_t bombx=1.3, Double_t bomby=1.3, Double_t bombz=1.3, Double_t bombr=1.3)=0; TVirtualGeoPainter::CheckBoundaryErrorsvirtual void CheckBoundaryErrors(Int_t ntracks=1000000, Double_t radius=-1.)=0; TVirtualGeoTrackBase class for user-defined tracks attached to a geometry.Definition TVirtualGeoTrack.h:23; TVirtualGeoTrack::GetIdInt_t GetId() constDefinition TVirtualGeoTrack.h:43; TVirtualGeoTrack::GetMotherTVirtualGeoTrack * GetMother() constDefinition TVirtualGeoTrack.h:46; TVirtualGeoTrack::FindTrackWithIdvirtual TVirtualGeoTrack * FindTrackWithId(Int_t id) constRecursively search through this track for a daughter particle (at any depth) with the specified id.Definition TVirtualGeoTrack.cxx:83; bool; double; int; unsigned int; boxvoid box(Int_t pat, Double_t x1, Double_t y1, Double_",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:5473,Usability,simpl,simple,5473," inside or to divide them further more; 74(see TGeoVolume::Divide()).; 75 ; 76 The primitive shapes supported by the package are basically the GEANT3; 77shapes (see class TGeoShape), arbitrary wedges with eight vertices on two parallel; 78planes. All basic primitives inherits from class TGeoBBox since the bounding box; 79of a solid is essential for the tracking algorithms. They also implement the; 80virtual methods defined in the virtual class TGeoShape (point and segment; 81classification). User-defined primitives can be directly plugged into the modeler; 82provided that they override these methods. Composite shapes will be soon supported; 83by the modeler. In order to build a TGeoCompositeShape, one will have to define; 84first the primitive components. The object that handle boolean; 85operations among components is called TGeoBoolCombinator and it has to be; 86constructed providing a string boolean expression between the components names.; 87 ; 88 ; 89## Example for building a simple geometry; 90 ; 91Begin_Macro(source); 92../../../tutorials/geom/rootgeom.C; 93End_Macro; 94 ; 95## TGeoManager - the manager class for the geometry package.; 96 ; 97 TGeoManager class is embedding all the API needed for building and tracking; 98a geometry. It defines a global pointer (gGeoManager) in order to be fully; 99accessible from external code. The mechanism of handling multiple geometries; 100at the same time will be soon implemented.; 101 ; 102 TGeoManager is the owner of all geometry objects defined in a session,; 103therefore users must not try to control their deletion. It contains lists of; 104media, materials, transformations, shapes and volumes. Logical nodes (positioned; 105volumes) are created and destroyed by the TGeoVolume class. Physical; 106nodes and their global transformations are subjected to a caching mechanism; 107due to the sometimes very large memory requirements of logical graph expansion.; 108The caching mechanism is triggered by the total number of phy",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:32979,Usability,clear,clear,32979,"tor *nav = array->SetCurrentNavigator(index);; 860 if (!nav) {; 861 Error(""SetCurrentNavigator"", ""Navigator %d not existing for this thread\n"", index);; 862 std::cout << "" thread id: "" << threadId << std::endl;; 863 return kFALSE;; 864 }; 865 if (!fMultiThread); 866 fCurrentNavigator = nav;; 867 return kTRUE;; 868}; 869 ; 870////////////////////////////////////////////////////////////////////////////////; 871/// Set the lock for navigators.; 872 ; 873void TGeoManager::SetNavigatorsLock(Bool_t flag); 874{; 875 fgLockNavigators = flag;; 876}; 877 ; 878////////////////////////////////////////////////////////////////////////////////; 879/// Clear all navigators.; 880 ; 881void TGeoManager::ClearNavigators(); 882{; 883 if (fMultiThread); 884 fgMutex.lock();; 885 TGeoNavigatorArray *arr = nullptr;; 886 for (NavigatorsMap_t::iterator it = fNavigators.begin(); it != fNavigators.end(); ++it) {; 887 arr = (*it).second;; 888 if (arr); 889 delete arr;; 890 }; 891 fNavigators.clear();; 892 if (fMultiThread); 893 fgMutex.unlock();; 894}; 895 ; 896////////////////////////////////////////////////////////////////////////////////; 897/// Clear a single navigator.; 898 ; 899void TGeoManager::RemoveNavigator(const TGeoNavigator *nav); 900{; 901 if (fMultiThread); 902 fgMutex.lock();; 903 for (NavigatorsMap_t::iterator it = fNavigators.begin(); it != fNavigators.end(); ++it) {; 904 TGeoNavigatorArray *arr = (*it).second;; 905 if (arr) {; 906 if ((TGeoNavigator *)arr->Remove((TObject *)nav)) {; 907 delete nav;; 908 if (!arr->GetEntries()); 909 fNavigators.erase(it);; 910 if (fMultiThread); 911 fgMutex.unlock();; 912 return;; 913 }; 914 }; 915 }; 916 Error(""Remove navigator"", ""Navigator %p not found"", nav);; 917 if (fMultiThread); 918 fgMutex.unlock();; 919}; 920 ; 921////////////////////////////////////////////////////////////////////////////////; 922/// Set maximum number of threads for navigation.; 923 ; 924void TGeoManager::SetMaxThreads(Int_t nthreads); 925{; 926 if (!fClosed) {; 927 ",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:35885,Usability,clear,clear,35885,"return;; 957 fgMutex.lock();; 958 TIter next(fVolumes);; 959 TGeoVolume *vol;; 960 while ((vol = (TGeoVolume *)next())); 961 vol->ClearThreadData();; 962 fgMutex.unlock();; 963}; 964 ; 965////////////////////////////////////////////////////////////////////////////////; 966/// Create thread private data for all geometry objects.; 967 ; 968void TGeoManager::CreateThreadData() const; 969{; 970 if (!fMaxThreads); 971 return;; 972 fgMutex.lock();; 973 TIter next(fVolumes);; 974 TGeoVolume *vol;; 975 while ((vol = (TGeoVolume *)next())); 976 vol->CreateThreadData(fMaxThreads);; 977 fgMutex.unlock();; 978}; 979 ; 980////////////////////////////////////////////////////////////////////////////////; 981/// Clear the current map of threads. This will be filled again by the calling; 982/// threads via ThreadId calls.; 983 ; 984void TGeoManager::ClearThreadsMap(); 985{; 986 if (gGeoManager && !gGeoManager->IsMultiThread()); 987 return;; 988 fgMutex.lock();; 989 if (!fgThreadId->empty()); 990 fgThreadId->clear();; 991 fgNumThreads = 0;; 992 fgMutex.unlock();; 993}; 994 ; 995////////////////////////////////////////////////////////////////////////////////; 996/// Translates the current thread id to an ordinal number. This can be used to; 997/// manage data which is specific for a given thread.; 998 ; 999Int_t TGeoManager::ThreadId(); 1000{; 1001 TTHREAD_TLS(Int_t) tid = -1;; 1002 Int_t ttid = tid; // TTHREAD_TLS_GET(Int_t,tid);; 1003 if (ttid > -1); 1004 return ttid;; 1005 if (gGeoManager && !gGeoManager->IsMultiThread()); 1006 return 0;; 1007 std::thread::id threadId = std::this_thread::get_id();; 1008 TGeoManager::ThreadsMapIt_t it = fgThreadId->find(threadId);; 1009 if (it != fgThreadId->end()); 1010 return it->second;; 1011 // Map needs to be updated.; 1012 fgMutex.lock();; 1013 (*fgThreadId)[threadId] = fgNumThreads;; 1014 tid = fgNumThreads; // TTHREAD_TLS_SET(Int_t,tid,fgNumThreads);; 1015 ttid = fgNumThreads++;; 1016 fgMutex.unlock();; 1017 return ttid;; 1018}; 1019 ; 1020//",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8cxx_source.html:94968,Usability,clear,clear,94968,"< std::endl;; 2678 out << ""{"" << std::endl;; 2679 out << ""//=== Macro generated by ROOT version "" << gROOT->GetVersion() << "" : "" << t.AsString() << std::endl;; 2680 out << ""//=== Attributes for "" << GetTitle() << "" geometry"" << std::endl;; 2681 out << ""//===== <run this macro AFTER loading the geometry in memory>"" << std::endl;; 2682 // save current top volume; 2683 out << "" TGeoVolume *top = gGeoManager->GetVolume(\"""" << fTopVolume->GetName() << ""\"");"" << std::endl;; 2684 out << "" TGeoVolume *vol = 0;"" << std::endl;; 2685 out << "" TGeoNode *node = 0;"" << std::endl;; 2686 out << "" // clear all volume attributes and get painter"" << std::endl;; 2687 out << "" gGeoManager->ClearAttributes();"" << std::endl;; 2688 out << "" gGeoManager->GetGeomPainter();"" << std::endl;; 2689 out << "" // set visualization modes and bomb factors"" << std::endl;; 2690 out << "" gGeoManager->SetVisOption("" << GetVisOption() << "");"" << std::endl;; 2691 out << "" gGeoManager->SetVisLevel("" << GetVisLevel() << "");"" << std::endl;; 2692 out << "" gGeoManager->SetExplodedView("" << GetBombMode() << "");"" << std::endl;; 2693 Double_t bombx, bomby, bombz, bombr;; 2694 GetBombFactors(bombx, bomby, bombz, bombr);; 2695 out << "" gGeoManager->SetBombFactors("" << bombx << "","" << bomby << "","" << bombz << "","" << bombr << "");""; 2696 << std::endl;; 2697 out << "" // iterate volumes container and set new attributes"" << std::endl;; 2698 // out << "" TIter next(gGeoManager->GetListOfVolumes());""<<std::endl;; 2699 TGeoVolume *vol = nullptr;; 2700 fTopNode->SaveAttributes(out);; 2701 ; 2702 TIter next(fVolumes);; 2703 while ((vol = (TGeoVolume *)next())) {; 2704 vol->SetVisStreamed(kFALSE);; 2705 }; 2706 out << "" // draw top volume with new settings"" << std::endl;; 2707 out << "" top->Draw();"" << std::endl;; 2708 out << "" gPad->x3d();"" << std::endl;; 2709 out << ""}"" << std::endl;; 2710 out.close();; 2711}; 2712 ; 2713////////////////////////////////////////////////////////////////////////////////; 2714/// Returns the deepe",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
https://root.cern/doc/master/TGeoManager_8h.html:320,Integrability,depend,dependency,320,". ROOT: geom/geom/inc/TGeoManager.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Variables ; TGeoManager.h File Reference. #include <mutex>; #include <thread>; #include <map>; #include ""TNamed.h""; #include ""TObjArray.h""; #include ""TGeoNavigator.h"". Include dependency graph for TGeoManager.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  TGeoManager;  The manager class for any TGeo geometry. More...;  . Variables; R__EXTERN TGeoManager * gGeoManager;  . Variable Documentation. ◆ gGeoManager. R__EXTERN TGeoManager* gGeoManager. Definition at line 608 of file TGeoManager.h. geomgeomincTGeoManager.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:15 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TGeoManager_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8h.html
https://root.cern/doc/master/TGeoManager_8h_source.html:8414,Availability,error,error,8414,"TObjArray *fArrayPNE; //! array of physical node entries; 140 Int_t fSizePNEId; // size of the array of unique ID's for PN entries; 141 Int_t fNPNEId; // number of PN entries having a unique ID; 142 Int_t *fKeyPNEId; //[fSizePNEId] array of uid values for PN entries; 143 Int_t *fValuePNEId; //[fSizePNEId] array of pointers to PN entries with ID's; 144 Int_t fMaxThreads; //! Max number of threads; 145 Bool_t fMultiThread; //! Flag for multi-threading; 146 Int_t fRaytraceMode; //! Raytrace mode: 0=normal, 1=pass through, 2=transparent; 147 Bool_t fUsePWNav; // Activate usage of parallel world in navigation; 148 TGeoParallelWorld *fParallelWorld; // Parallel world; 149 ConstPropMap_t fProperties; // Map of user-defined constant properties; 150 //--- private methods; 151 Bool_t IsLoopingVolumes() const { return fLoopVolumes; }; 152 void Init();; 153 Bool_t InitArrayPNE() const;; 154 Bool_t InsertPNEId(Int_t uid, Int_t ientry);; 155 void SetLoopVolumes(Bool_t flag = kTRUE) { fLoopVolumes = flag; }; 156 void UpdateElements();; 157 void Voxelize(Option_t *option = nullptr);; 158 ; 159public:; 160 // constructors; 161 TGeoManager();; 162 TGeoManager(const char *name, const char *title);; 163 // destructor; 164 ~TGeoManager() override;; 165 //--- adding geometrical objects; 166 Int_t AddMaterial(const TGeoMaterial *material);; 167 Int_t AddOverlap(const TNamed *ovlp);; 168 Int_t AddRegion(TGeoRegion *region);; 169 Int_t AddTransformation(const TGeoMatrix *matrix);; 170 Int_t AddShape(const TGeoShape *shape);; 171 Int_t AddTrack(Int_t id, Int_t pdgcode, TObject *particle = nullptr);; 172 Int_t AddTrack(TVirtualGeoTrack *track);; 173 Int_t AddVolume(TGeoVolume *volume);; 174 TGeoNavigator *AddNavigator();; 175 Bool_t AddProperty(const char *property, Double_t value);; 176 Double_t GetProperty(const char *name, Bool_t *error = nullptr) const;; 177 Double_t GetProperty(size_t i, TString &name, Bool_t *error = nullptr) const;; 178 Int_t GetNproperties() const { return fProperties.",MatchSource.WIKI,doc/master/TGeoManager_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8h_source.html
https://root.cern/doc/master/TGeoManager_8h_source.html:8497,Availability,error,error,8497,"TObjArray *fArrayPNE; //! array of physical node entries; 140 Int_t fSizePNEId; // size of the array of unique ID's for PN entries; 141 Int_t fNPNEId; // number of PN entries having a unique ID; 142 Int_t *fKeyPNEId; //[fSizePNEId] array of uid values for PN entries; 143 Int_t *fValuePNEId; //[fSizePNEId] array of pointers to PN entries with ID's; 144 Int_t fMaxThreads; //! Max number of threads; 145 Bool_t fMultiThread; //! Flag for multi-threading; 146 Int_t fRaytraceMode; //! Raytrace mode: 0=normal, 1=pass through, 2=transparent; 147 Bool_t fUsePWNav; // Activate usage of parallel world in navigation; 148 TGeoParallelWorld *fParallelWorld; // Parallel world; 149 ConstPropMap_t fProperties; // Map of user-defined constant properties; 150 //--- private methods; 151 Bool_t IsLoopingVolumes() const { return fLoopVolumes; }; 152 void Init();; 153 Bool_t InitArrayPNE() const;; 154 Bool_t InsertPNEId(Int_t uid, Int_t ientry);; 155 void SetLoopVolumes(Bool_t flag = kTRUE) { fLoopVolumes = flag; }; 156 void UpdateElements();; 157 void Voxelize(Option_t *option = nullptr);; 158 ; 159public:; 160 // constructors; 161 TGeoManager();; 162 TGeoManager(const char *name, const char *title);; 163 // destructor; 164 ~TGeoManager() override;; 165 //--- adding geometrical objects; 166 Int_t AddMaterial(const TGeoMaterial *material);; 167 Int_t AddOverlap(const TNamed *ovlp);; 168 Int_t AddRegion(TGeoRegion *region);; 169 Int_t AddTransformation(const TGeoMatrix *matrix);; 170 Int_t AddShape(const TGeoShape *shape);; 171 Int_t AddTrack(Int_t id, Int_t pdgcode, TObject *particle = nullptr);; 172 Int_t AddTrack(TVirtualGeoTrack *track);; 173 Int_t AddVolume(TGeoVolume *volume);; 174 TGeoNavigator *AddNavigator();; 175 Bool_t AddProperty(const char *property, Double_t value);; 176 Double_t GetProperty(const char *name, Bool_t *error = nullptr) const;; 177 Double_t GetProperty(size_t i, TString &name, Bool_t *error = nullptr) const;; 178 Int_t GetNproperties() const { return fProperties.",MatchSource.WIKI,doc/master/TGeoManager_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8h_source.html
https://root.cern/doc/master/TGeoManager_8h_source.html:19646,Availability,down,downwards,19646,"um *medium, Int_t nz);; 331 ; 332 TGeoPNEntry *SetAlignableEntry(const char *unique_name, const char *path, Int_t uid = -1);; 333 TGeoPNEntry *GetAlignableEntry(const char *name) const;; 334 TGeoPNEntry *GetAlignableEntry(Int_t index) const;; 335 TGeoPNEntry *GetAlignableEntryByUID(Int_t uid) const;; 336 Int_t GetNAlignable(Bool_t with_uid = kFALSE) const;; 337 TGeoPhysicalNode *MakeAlignablePN(const char *name);; 338 TGeoPhysicalNode *MakeAlignablePN(TGeoPNEntry *entry);; 339 TGeoPhysicalNode *MakePhysicalNode(const char *path = nullptr);; 340 void ClearPhysicalNodes(Bool_t mustdelete = kFALSE);; 341 void RefreshPhysicalNodes(Bool_t lock = kTRUE);; 342 TVirtualGeoTrack *MakeTrack(Int_t id, Int_t pdgcode, TObject *particle);; 343 TGeoVolumeAssembly *MakeVolumeAssembly(const char *name);; 344 TGeoVolumeMulti *MakeVolumeMulti(const char *name, TGeoMedium *medium);; 345 void SetTopVolume(TGeoVolume *vol);; 346 ; 347 //--- geometry queries; 348 TGeoNode *CrossBoundaryAndLocate(Bool_t downwards, TGeoNode *skipnode);; 349 TGeoNode *FindNextBoundary(Double_t stepmax = TGeoShape::Big(), const char *path = """", Bool_t frombdr = kFALSE);; 350 TGeoNode *FindNextDaughterBoundary(Double_t *point, Double_t *dir, Int_t &idaughter, Bool_t compmatrix = kFALSE);; 351 TGeoNode *FindNextBoundaryAndStep(Double_t stepmax = TGeoShape::Big(), Bool_t compsafe = kFALSE);; 352 TGeoNode *FindNode(Bool_t safe_start = kTRUE);; 353 TGeoNode *FindNode(Double_t x, Double_t y, Double_t z);; 354 Double_t *FindNormal(Bool_t forward = kTRUE);; 355 Double_t *FindNormalFast();; 356 TGeoNode *InitTrack(const Double_t *point, const Double_t *dir);; 357 TGeoNode *InitTrack(Double_t x, Double_t y, Double_t z, Double_t nx, Double_t ny, Double_t nz);; 358 void ResetState();; 359 Double_t Safety(Bool_t inside = kFALSE);; 360 TGeoNode *SearchNode(Bool_t downwards = kFALSE, const TGeoNode *skipnode = nullptr);; 361 TGeoNode *Step(Bool_t is_geom = kTRUE, Bool_t cross = kTRUE);; 362 void DisableInactiveVolumes() { f",MatchSource.WIKI,doc/master/TGeoManager_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8h_source.html
https://root.cern/doc/master/TGeoManager_8h_source.html:20489,Availability,down,downwards,20489,"har *name, TGeoMedium *medium);; 345 void SetTopVolume(TGeoVolume *vol);; 346 ; 347 //--- geometry queries; 348 TGeoNode *CrossBoundaryAndLocate(Bool_t downwards, TGeoNode *skipnode);; 349 TGeoNode *FindNextBoundary(Double_t stepmax = TGeoShape::Big(), const char *path = """", Bool_t frombdr = kFALSE);; 350 TGeoNode *FindNextDaughterBoundary(Double_t *point, Double_t *dir, Int_t &idaughter, Bool_t compmatrix = kFALSE);; 351 TGeoNode *FindNextBoundaryAndStep(Double_t stepmax = TGeoShape::Big(), Bool_t compsafe = kFALSE);; 352 TGeoNode *FindNode(Bool_t safe_start = kTRUE);; 353 TGeoNode *FindNode(Double_t x, Double_t y, Double_t z);; 354 Double_t *FindNormal(Bool_t forward = kTRUE);; 355 Double_t *FindNormalFast();; 356 TGeoNode *InitTrack(const Double_t *point, const Double_t *dir);; 357 TGeoNode *InitTrack(Double_t x, Double_t y, Double_t z, Double_t nx, Double_t ny, Double_t nz);; 358 void ResetState();; 359 Double_t Safety(Bool_t inside = kFALSE);; 360 TGeoNode *SearchNode(Bool_t downwards = kFALSE, const TGeoNode *skipnode = nullptr);; 361 TGeoNode *Step(Bool_t is_geom = kTRUE, Bool_t cross = kTRUE);; 362 void DisableInactiveVolumes() { fActivity = kTRUE; }; 363 void EnableInactiveVolumes() { fActivity = kFALSE; }; 364 void SetCurrentTrack(Int_t i) { fCurrentTrack = (TVirtualGeoTrack *)fTracks->At(i); }; 365 void SetCurrentTrack(TVirtualGeoTrack *track) { fCurrentTrack = track; }; 366 Int_t GetNtracks() const { return fNtracks; }; 367 TVirtualGeoTrack *GetCurrentTrack() { return fCurrentTrack; }; 368 TVirtualGeoTrack *GetLastTrack(); 369 {; 370 return (TVirtualGeoTrack *)((fNtracks > 0) ? fTracks->At(fNtracks - 1) : nullptr);; 371 }; 372 const Double_t *GetLastPoint() const { return GetCurrentNavigator()->GetLastPoint(); }; 373 TVirtualGeoTrack *GetTrack(Int_t index); 374 {; 375 return (index < fNtracks) ? (TVirtualGeoTrack *)fTracks->At(index) : nullptr;; 376 }; 377 Int_t GetTrackIndex(Int_t id) const;; 378 TVirtualGeoTrack *GetTrackOfId(Int_t id) const;; 379 TVir",MatchSource.WIKI,doc/master/TGeoManager_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8h_source.html
https://root.cern/doc/master/TGeoManager_8h_source.html:50517,Availability,down,downwards,50517,"ion TGeoManager.h:137; TGeoManager::GetListOfGDMLMatricesTObjArray * GetListOfGDMLMatrices() constDefinition TGeoManager.h:479; TGeoManager::GetLastSafetyDouble_t GetLastSafety() constDefinition TGeoManager.h:385; TGeoManager::fVisOptionInt_t fVisOptionDefinition TGeoManager.h:71; TGeoManager::fgMutexstatic std::mutex fgMutexDefinition TGeoManager.h:49; TGeoManager::IsLoopingVolumesBool_t IsLoopingVolumes() constDefinition TGeoManager.h:151; TGeoManager::IsInPhiRangeBool_t IsInPhiRange() constTrue if current node is in phi range.Definition TGeoManager.cxx:2834; TGeoManager::GetListOfGVolumesTObjArray * GetListOfGVolumes() constDefinition TGeoManager.h:474; TGeoManager::SetParticleNamevoid SetParticleName(const char *pname)Definition TGeoManager.h:260; TGeoManager::cdvirtual Bool_t cd(const char *path="""")Browse the tree of nodes starting from fTopNode according to pathname.Definition TGeoManager.cxx:1707; TGeoManager::SearchNodeTGeoNode * SearchNode(Bool_t downwards=kFALSE, const TGeoNode *skipnode=nullptr)Returns the deepest node containing fPoint, which must be set a priori.Definition TGeoManager.cxx:2716; TGeoManager::MaterialTGeoMaterial * Material(const char *name, Double_t a, Double_t z, Double_t dens, Int_t uid, Double_t radlen=0, Double_t intlen=0)Create material with given A, Z and density, having an unique id.Definition TGeoManager.cxx:1285; TGeoManager::LocalToMastervoid LocalToMaster(const Double_t *local, Double_t *master) constDefinition TGeoManager.h:526; TGeoManager::SetCurrentTrackvoid SetCurrentTrack(Int_t i)Definition TGeoManager.h:364; TGeoManager::fPhiminDouble_t fPhiminDefinition TGeoManager.h:62; TGeoManager::GetListOfMatricesTObjArray * GetListOfMatrices() constDefinition TGeoManager.h:470; TGeoManager::GetPaintVolumeTGeoVolume * GetPaintVolume() constDefinition TGeoManager.h:215; TGeoManager::fParticleNameTString fParticleNamepath to current nodeDefinition TGeoManager.h:68; TGeoManager::fgLockNavigatorsstatic Bool_t fgLockNavigatorsNumber of ",MatchSource.WIKI,doc/master/TGeoManager_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8h_source.html
https://root.cern/doc/master/TGeoManager_8h_source.html:59314,Availability,down,down,59314,"6; TGeoManager::ClearAttributesvoid ClearAttributes()Reset all attributes to default ones.Definition TGeoManager.cxx:1455; TGeoManager::fgMaxDaughtersstatic Int_t fgMaxDaughtersMaximum level in geometry.Definition TGeoManager.h:53; TGeoManager::fUsePWNavBool_t fUsePWNavRaytrace mode: 0=normal, 1=pass through, 2=transparent.Definition TGeoManager.h:147; TGeoManager::SetRTmodevoid SetRTmode(Int_t mode)Change raytracing mode.Definition TGeoManager.cxx:3108; TGeoManager::CheckPathBool_t CheckPath(const char *path) constCheck if a geometry path is valid without changing the state of the current navigator.Definition TGeoManager.cxx:1715; TGeoManager::InspectStatevoid InspectState() constInspects path and all flags for the current state.Definition TGeoManager.cxx:2873; TGeoManager::ConvertReflectionsvoid ConvertReflections()Convert all reflections in geometry to normal rotations + reflected shapes.Definition TGeoManager.cxx:1723; TGeoManager::SetVisLevelvoid SetVisLevel(Int_t level=3)set default level down to which visualization is performedDefinition TGeoManager.cxx:2459; TGeoManager::SetMatrixTransformvoid SetMatrixTransform(Bool_t on=kTRUE)Definition TGeoManager.h:398; TGeoManager::FindNextBoundaryTGeoNode * FindNextBoundary(Double_t stepmax=TGeoShape::Big(), const char *path="""", Bool_t frombdr=kFALSE)Find distance to next boundary and store it in fStep.Definition TGeoManager.cxx:2755; TGeoManager::MasterToLocalBombvoid MasterToLocalBomb(const Double_t *master, Double_t *local) constDefinition TGeoManager.h:546; TGeoManager::Importstatic TGeoManager * Import(const char *filename, const char *name="""", Option_t *option="""")static function Import a geometry from a gdml or ROOT fileDefinition TGeoManager.cxx:4096; TGeoManager::MakePhysicalNodeTGeoPhysicalNode * MakePhysicalNode(const char *path=nullptr)Makes a physical node corresponding to a path.Definition TGeoManager.cxx:3506; TGeoManager::CountLevelsvoid CountLevels()Count maximum number of nodes per volume, maximum dept",MatchSource.WIKI,doc/master/TGeoManager_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8h_source.html
https://root.cern/doc/master/TGeoManager_8h_source.html:75266,Availability,down,downwards,75266,"oNode * GetTopNode() constDefinition TGeoManager.h:513; TGeoManager::SetTminTmaxvoid SetTminTmax(Double_t tmin=0, Double_t tmax=999)Set time cut interval for drawing tracks.Definition TGeoManager.cxx:4242; TGeoManager::fNavigatorsNavigatorsMap_t fNavigatorsDefinition TGeoManager.h:119; TGeoManager::GetBranchNumbersvoid GetBranchNumbers(Int_t *copyNumbers, Int_t *volumeNumbers) constFill node copy numbers of current branch into an array.Definition TGeoManager.cxx:2079; TGeoManager::SetNodeSelectablevoid SetNodeSelectable(Bool_t flag=kTRUE)Definition TGeoManager.h:239; TGeoManager::GetNNodesInt_t GetNNodes()Definition TGeoManager.h:578; TGeoManager::fPathTString fPathDefinition TGeoManager.h:67; TGeoManager::fPhiCutBool_t fPhiCutflag to notify that the manager is being destructedDefinition TGeoManager.h:84; TGeoManager::GetCacheTGeoNodeCache * GetCache() constDefinition TGeoManager.h:584; TGeoManager::CrossBoundaryAndLocateTGeoNode * CrossBoundaryAndLocate(Bool_t downwards, TGeoNode *skipnode)Cross next boundary and locate within current node The current point must be on the boundary of fCurr...Definition TGeoManager.cxx:2725; TGeoManager::DrawTracksvoid DrawTracks(Option_t *option="""")Draw tracks over the geometry, according to option.Definition TGeoManager.cxx:1905; TGeoManager::BuildDefaultMaterialsvoid BuildDefaultMaterials()Now just a shortcut for GetElementTable.Definition TGeoManager.cxx:3615; TGeoManager::SetMaxThreadsvoid SetMaxThreads(Int_t nthreads)Set maximum number of threads for navigation.Definition TGeoManager.cxx:924; TGeoManager::IsMatrixReflectionBool_t IsMatrixReflection() constDefinition TGeoManager.h:391; TGeoManager::PushPointInt_t PushPoint(Int_t startlevel=0)Definition TGeoManager.h:594; TGeoManager::MediumTGeoMedium * Medium(const char *name, Int_t numed, Int_t nmat, Int_t isvol, Int_t ifield, Double_t fieldm, Double_t tmaxfd, Double_t stemax, Double_t deemax, Double_t epsil, Double_t stmin)Create tracking medium.Definition TGeoManager.cxx:1331",MatchSource.WIKI,doc/master/TGeoManager_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8h_source.html
https://root.cern/doc/master/TGeoManager_8h_source.html:81842,Availability,error,errors,81842,"vel (static function).Definition TGeoManager.cxx:4074; TGeoManager::GetOpticalSurfaceTGeoOpticalSurface * GetOpticalSurface(const char *name) constGet optical surface with a given name;.Definition TGeoManager.cxx:2022; TGeoManager::SetNsegmentsvoid SetNsegments(Int_t nseg)Set number of segments for approximating circles in drawing.Definition TGeoManager.cxx:3594; TGeoManager::GetExportPrecisionstatic UInt_t GetExportPrecision()Definition TGeoManager.cxx:4341; TGeoManager::IsSamePointBool_t IsSamePoint(Double_t x, Double_t y, Double_t z) constCheck if a new point with given coordinates is the same as the last located one.Definition TGeoManager.cxx:2826; TGeoManager::SetStepvoid SetStep(Double_t step)Definition TGeoManager.h:400; TGeoManager::SetNmeshPointsvoid SetNmeshPoints(Int_t npoints=1000)Set the number of points to be generated on the shape outline when checking for overlaps.Definition TGeoManager.cxx:2414; TGeoManager::CheckBoundaryReferencevoid CheckBoundaryReference(Int_t icheck=-1)Check the boundary errors reference file created by CheckBoundaryErrors method.Definition TGeoManager.cxx:3762; TGeoManager::GetCurrentVolumeTGeoVolume * GetCurrentVolume() constDefinition TGeoManager.h:503; TGeoManager::GetVerboseLevelstatic Int_t GetVerboseLevel()Set verbosity level (static function).Definition TGeoManager.cxx:4066; TGeoManager::GetVisLevelInt_t GetVisLevel() constReturns current depth to which geometry is drawn.Definition TGeoManager.cxx:2149; TGeoManager::fgDefaultUnitsstatic EDefaultUnits fgDefaultUnitsPrecision to be used in ASCII exports.Definition TGeoManager.h:56; TGeoManager::Editvirtual void Edit(Option_t *option="""")Append a pad for this geometry.Definition TGeoManager.cxx:1051; TGeoManager::AddPropertyBool_t AddProperty(const char *property, Double_t value)Add a user-defined property. Returns true if added, false if existing.Definition TGeoManager.cxx:643; TGeoManager::~TGeoManager~TGeoManager() overrideDestructor.Definition TGeoManager.cxx:505; TGeoMa",MatchSource.WIKI,doc/master/TGeoManager_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8h_source.html
https://root.cern/doc/master/TGeoManager_8h_source.html:83142,Availability,down,down,83142,"evelstatic Int_t GetVerboseLevel()Set verbosity level (static function).Definition TGeoManager.cxx:4066; TGeoManager::GetVisLevelInt_t GetVisLevel() constReturns current depth to which geometry is drawn.Definition TGeoManager.cxx:2149; TGeoManager::fgDefaultUnitsstatic EDefaultUnits fgDefaultUnitsPrecision to be used in ASCII exports.Definition TGeoManager.h:56; TGeoManager::Editvirtual void Edit(Option_t *option="""")Append a pad for this geometry.Definition TGeoManager.cxx:1051; TGeoManager::AddPropertyBool_t AddProperty(const char *property, Double_t value)Add a user-defined property. Returns true if added, false if existing.Definition TGeoManager.cxx:643; TGeoManager::~TGeoManager~TGeoManager() overrideDestructor.Definition TGeoManager.cxx:505; TGeoManager::GetPainterTVirtualGeoPainter * GetPainter() constDefinition TGeoManager.h:209; TGeoManager::fNodesTObjArray * fNodesDefinition TGeoManager.h:107; TGeoManager::CountNodesInt_t CountNodes(const TGeoVolume *vol=nullptr, Int_t nlevels=10000, Int_t option=0)Count the total number of nodes starting from a volume, nlevels down.Definition TGeoManager.cxx:1803; TGeoManager::GetMaterialTGeoMaterial * GetMaterial(const char *matname) constSearch for a named material. All trailing blanks stripped.Definition TGeoManager.cxx:3011; TGeoManager::CheckGeometryvoid CheckGeometry(Option_t *option="""")Perform last checks on the geometry.Definition TGeoManager.cxx:3831; TGeoManager::ExecuteEventvoid ExecuteEvent(Int_t event, Int_t px, Int_t py) overrideExecute mouse actions on this manager.Definition TGeoManager.cxx:3950; TGeoManager::GetTmaxDouble_t GetTmax() constDefinition TGeoManager.h:214; TGeoManager::MakeVolumeAssemblyTGeoVolumeAssembly * MakeVolumeAssembly(const char *name)Make an assembly of volumes.Definition TGeoManager.cxx:3553; TGeoManager::GetBombModeInt_t GetBombMode() constDefinition TGeoManager.h:210; TGeoManager::GetListOfOpticalSurfacesTObjArray * GetListOfOpticalSurfaces() constDefinition TGeoManager.h:480; TGeoMa",MatchSource.WIKI,doc/master/TGeoManager_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8h_source.html
https://root.cern/doc/master/TGeoManager_8h_source.html:1655,Integrability,message,messages,1655,"/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#ifndef ROOT_TGeoManager; 13#define ROOT_TGeoManager; 14 ; 15#include <mutex>; 16#include <thread>; 17#include <map>; 18 ; 19#include ""TNamed.h""; 20#include ""TObjArray.h""; 21#include ""TGeoNavigator.h""; 22 ; 23// forward declarations; 24class TVirtualGeoTrack;; 25class TGeoNode;; 26class TGeoPhysicalNode;; 27class TGeoPNEntry;; 28class TGeoVolume;; 29class TGeoVolumeMulti;; 30class TGeoMatrix;; 31class TGeoHMatrix;; 32class TGeoMaterial;; 33class TGeoMedium;; 34class TGeoShape;; 35class TVirtualGeoPainter;; 36class THashList;; 37class TGeoParallelWorld;; 38class TGeoRegion;; 39class TGDMLMatrix;; 40class TGeoOpticalSurface;; 41class TGeoSkinSurface;; 42class TGeoBorderSurface;; 43 ; 44class TGeoManager : public TNamed {; 45public:; 46 enum EDefaultUnits { kG4Units = 0, kRootUnits = 1 };; 47 ; 48protected:; 49 static std::mutex fgMutex; //! mutex for navigator booking in MT mode; 50 static Bool_t fgLock; //! Lock preventing a second geometry to be loaded; 51 static Int_t fgVerboseLevel; //! Verbosity level for Info messages (no IO).; 52 static Int_t fgMaxLevel; //! Maximum level in geometry; 53 static Int_t fgMaxDaughters; //! Maximum number of daughters; 54 static Int_t fgMaxXtruVert; //! Maximum number of Xtru vertices; 55 static UInt_t fgExportPrecision; //! Precision to be used in ASCII exports; 56 static EDefaultUnits fgDefaultUnits; //! Default units in GDML if not explicit in some tags; 57 ; 58 TGeoManager(const TGeoManager &) = delete;; 59 TGeoManager &operator=(const TGeoManager &) = delete;; 60 ; 61private:; 62 Double_t fPhimin; //! lowest range for phi cut; 63 Double_t fPhimax; //! high",MatchSource.WIKI,doc/master/TGeoManager_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8h_source.html
https://root.cern/doc/master/TGeoManager_8h_source.html:17353,Integrability,rout,rout,17353,"Medium *medium, Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1,; 305 Double_t phi2, Double_t lx, Double_t ly, Double_t lz, Double_t tx, Double_t ty, Double_t tz);; 306 TGeoVolume *MakeEltu(const char *name, TGeoMedium *medium, Double_t a, Double_t b, Double_t dz);; 307 TGeoVolume *MakeGtra(const char *name, TGeoMedium *medium, Double_t dz, Double_t theta, Double_t phi, Double_t twist,; 308 Double_t h1, Double_t bl1, Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2,; 309 Double_t tl2, Double_t alpha2);; 310 TGeoVolume *MakePara(const char *name, TGeoMedium *medium, Double_t dx, Double_t dy, Double_t dz, Double_t alpha,; 311 Double_t theta, Double_t phi);; 312 TGeoVolume *MakePcon(const char *name, TGeoMedium *medium, Double_t phi, Double_t dphi, Int_t nz);; 313 TGeoVolume *MakeParaboloid(const char *name, TGeoMedium *medium, Double_t rlo, Double_t rhi, Double_t dz);; 314 TGeoVolume *MakeHype(const char *name, TGeoMedium *medium, Double_t rin, Double_t stin, Double_t rout,; 315 Double_t stout, Double_t dz);; 316 TGeoVolume *MakePgon(const char *name, TGeoMedium *medium, Double_t phi, Double_t dphi, Int_t nedges, Int_t nz);; 317 TGeoVolume *MakeSphere(const char *name, TGeoMedium *medium, Double_t rmin, Double_t rmax, Double_t themin = 0,; 318 Double_t themax = 180, Double_t phimin = 0, Double_t phimax = 360);; 319 TGeoVolume *MakeTorus(const char *name, TGeoMedium *medium, Double_t r, Double_t rmin, Double_t rmax,; 320 Double_t phi1 = 0, Double_t dphi = 360);; 321 TGeoVolume *MakeTrap(const char *name, TGeoMedium *medium, Double_t dz, Double_t theta, Double_t phi, Double_t h1,; 322 Double_t bl1, Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2,; 323 Double_t alpha2);; 324 TGeoVolume *MakeTrd1(const char *name, TGeoMedium *medium, Double_t dx1, Double_t dx2, Double_t dy, Double_t dz);; 325 TGeoVolume *; 326 MakeTrd2(const char *name, TGeoMedium *medium, Double_t dx1, Double_t dx2, Double_t dy1, Double_t dy2, Double_t dz);; 327 TGe",MatchSource.WIKI,doc/master/TGeoManager_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8h_source.html
https://root.cern/doc/master/TGeoManager_8h_source.html:69328,Integrability,message,messages,69328,"ent depth to which geometry is drawn.Definition TGeoManager.cxx:2157; TGeoManager::LockGeometrystatic void LockGeometry()Lock current geometry so that no other geometry can be imported.Definition TGeoManager.cxx:4040; TGeoManager::GetCurrentPointconst Double_t * GetCurrentPoint() constDefinition TGeoManager.h:501; TGeoManager::MakeBoxTGeoVolume * MakeBox(const char *name, TGeoMedium *medium, Double_t dx, Double_t dy, Double_t dz)Make in one step a volume pointing to a box shape with given medium.Definition TGeoManager.cxx:3169; TGeoManager::fNPNEIdInt_t fNPNEIdDefinition TGeoManager.h:141; TGeoManager::CheckShapevoid CheckShape(TGeoShape *shape, Int_t testNo, Int_t nsamples, Option_t *option)Test for shape navigation methods.Definition TGeoManager.cxx:3783; TGeoManager::GetUserPaintVolumeTGeoVolume * GetUserPaintVolume() constDefinition TGeoManager.h:216; TGeoManager::IsActivityEnabledBool_t IsActivityEnabled() constDefinition TGeoManager.h:409; TGeoManager::fgMaxLevelstatic Int_t fgMaxLevelVerbosity level for Info messages (no IO).Definition TGeoManager.h:52; TGeoManager::fNpdgInt_t fNpdgcurrent trackDefinition TGeoManager.h:77; TGeoManager::PrintOverlapsvoid PrintOverlaps() constPrints the current list of overlaps.Definition TGeoManager.cxx:3881; TGeoManager::GetNormalconst Double_t * GetNormal() constDefinition TGeoManager.h:506; TGeoManager::MakeTrd1TGeoVolume * MakeTrd1(const char *name, TGeoMedium *medium, Double_t dx1, Double_t dx2, Double_t dy, Double_t dz)Make in one step a volume pointing to a TGeoTrd1 shape with given medium.Definition TGeoManager.cxx:3293; TGeoManager::MakeSphereTGeoVolume * MakeSphere(const char *name, TGeoMedium *medium, Double_t rmin, Double_t rmax, Double_t themin=0, Double_t themax=180, Double_t phimin=0, Double_t phimax=360)Make in one step a volume pointing to a sphere shape with given medium.Definition TGeoManager.cxx:3186; TGeoManager::ResetUserDatavoid ResetUserData()Sets all pointers TGeoVolume::fField to NULL.Definition TGeoMa",MatchSource.WIKI,doc/master/TGeoManager_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8h_source.html
https://root.cern/doc/master/TGeoManager_8h_source.html:91016,Integrability,rout,rout,91016,"222; TGeoManager::DrawPathvoid DrawPath(const char *path, Option_t *option="""")Draw current path.Definition TGeoManager.cxx:1923; TGeoManager::GetTopVolumeTGeoVolume * GetTopVolume() constDefinition TGeoManager.h:512; TGeoManager::GetNregionsint GetNregions() constDefinition TGeoManager.h:575; TGeoManager::GetListOfPhysicalNodesTObjArray * GetListOfPhysicalNodes()Definition TGeoManager.h:468; TGeoManager::IsCleaningBool_t IsCleaning() constDefinition TGeoManager.h:464; TGeoManager::ThreadIdstatic Int_t ThreadId()Translates the current thread id to an ordinal number.Definition TGeoManager.cxx:999; TGeoManager::SetCurrentNavigatorBool_t SetCurrentNavigator(Int_t index)Switch to another existing navigator for the calling thread.Definition TGeoManager.cxx:849; TGeoManager::SetTopVisiblevoid SetTopVisible(Bool_t vis=kTRUE)make top volume visible on screenDefinition TGeoManager.cxx:2396; TGeoManager::MakeHypeTGeoVolume * MakeHype(const char *name, TGeoMedium *medium, Double_t rin, Double_t stin, Double_t rout, Double_t stout, Double_t dz)Make in one step a volume pointing to a tube shape with given medium.Definition TGeoManager.cxx:3230; TGeoManager::MakeParaboloidTGeoVolume * MakeParaboloid(const char *name, TGeoMedium *medium, Double_t rlo, Double_t rhi, Double_t dz)Make in one step a volume pointing to a tube shape with given medium.Definition TGeoManager.cxx:3239; TGeoManager::AddShapeInt_t AddShape(const TGeoShape *shape)Add a shape to the list. Returns index of the shape in list.Definition TGeoManager.cxx:703; TGeoManager::SetMaxVisNodesvoid SetMaxVisNodes(Int_t maxnodes=10000)set the maximum number of visible nodes.Definition TGeoManager.cxx:2380; TGeoManager::CleanGarbagevoid CleanGarbage()Clean temporary volumes and shapes from garbage collection.Definition TGeoManager.cxx:1627; TGeoManager::Voxelizevoid Voxelize(Option_t *option=nullptr)Voxelize all non-divided volumes.Definition TGeoManager.cxx:3129; TGeoManager::GetVirtualLevelInt_t GetVirtualLevel()Find level ",MatchSource.WIKI,doc/master/TGeoManager_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8h_source.html
https://root.cern/doc/master/TGeoManager_8h_source.html:100114,Integrability,wrap,wrapper,100114,"deCache * GetCache() constDefinition TGeoNavigator.h:243; TGeoNavigator::GetLevelInt_t GetLevel() constDefinition TGeoNavigator.h:169; TGeoNavigator::IsOnBoundaryBool_t IsOnBoundary() constDefinition TGeoNavigator.h:145; TGeoNavigator::GetCurrentPointconst Double_t * GetCurrentPoint() constDefinition TGeoNavigator.h:161; TGeoNavigator::IsStartSafeBool_t IsStartSafe() constDefinition TGeoNavigator.h:135; TGeoNavigator::MasterToLocalVectvoid MasterToLocalVect(const Double_t *master, Double_t *local) constDefinition TGeoNavigator.h:239; TGeoNavigator::MasterToLocalBombvoid MasterToLocalBomb(const Double_t *master, Double_t *local) constDefinition TGeoNavigator.h:240; TGeoNavigator::IsStepEnteringBool_t IsStepEntering() constDefinition TGeoNavigator.h:142; TGeoNodeCacheSpecial pool of reusable nodes.Definition TGeoCache.h:56; TGeoNodeA node represent a volume positioned inside another.They store links to both volumes and to the TGeoM...Definition TGeoNode.h:39; TGeoOpticalSurfaceThis is a wrapper class to G4OpticalSurface.Definition TGeoOpticalSurface.h:27; TGeoPNEntryThe knowledge of the path to the objects that need to be misaligned is essential since there is no ot...Definition TGeoPhysicalNode.h:100; TGeoParallelWorldBase class for a flat parallel geometry.Definition TGeoParallelWorld.h:23; TGeoPhysicalNodePhysical nodes are the actual 'touchable' objects in the geometry, representing a path of positioned ...Definition TGeoPhysicalNode.h:35; TGeoRegionRegions are groups of volumes having a common set of user tracking cuts.Definition TGeoRegion.h:36; TGeoShapeBase abstract class for all shapes.Definition TGeoShape.h:25; TGeoShape::Bigstatic Double_t Big()Definition TGeoShape.h:87; TGeoSkinSurfaceDefinition TGeoOpticalSurface.h:177; TGeoVolumeAssemblyVolume assemblies.Definition TGeoVolume.h:316; TGeoVolumeMultiVolume families.Definition TGeoVolume.h:266; TGeoVolumeTGeoVolume, TGeoVolumeMulti, TGeoVolumeAssembly are the volume classes.Definition TGeoVolume.h:43; THash",MatchSource.WIKI,doc/master/TGeoManager_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8h_source.html
https://root.cern/doc/master/TGeoManager_8h_source.html:1586,Performance,load,loaded,1586,"/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#ifndef ROOT_TGeoManager; 13#define ROOT_TGeoManager; 14 ; 15#include <mutex>; 16#include <thread>; 17#include <map>; 18 ; 19#include ""TNamed.h""; 20#include ""TObjArray.h""; 21#include ""TGeoNavigator.h""; 22 ; 23// forward declarations; 24class TVirtualGeoTrack;; 25class TGeoNode;; 26class TGeoPhysicalNode;; 27class TGeoPNEntry;; 28class TGeoVolume;; 29class TGeoVolumeMulti;; 30class TGeoMatrix;; 31class TGeoHMatrix;; 32class TGeoMaterial;; 33class TGeoMedium;; 34class TGeoShape;; 35class TVirtualGeoPainter;; 36class THashList;; 37class TGeoParallelWorld;; 38class TGeoRegion;; 39class TGDMLMatrix;; 40class TGeoOpticalSurface;; 41class TGeoSkinSurface;; 42class TGeoBorderSurface;; 43 ; 44class TGeoManager : public TNamed {; 45public:; 46 enum EDefaultUnits { kG4Units = 0, kRootUnits = 1 };; 47 ; 48protected:; 49 static std::mutex fgMutex; //! mutex for navigator booking in MT mode; 50 static Bool_t fgLock; //! Lock preventing a second geometry to be loaded; 51 static Int_t fgVerboseLevel; //! Verbosity level for Info messages (no IO).; 52 static Int_t fgMaxLevel; //! Maximum level in geometry; 53 static Int_t fgMaxDaughters; //! Maximum number of daughters; 54 static Int_t fgMaxXtruVert; //! Maximum number of Xtru vertices; 55 static UInt_t fgExportPrecision; //! Precision to be used in ASCII exports; 56 static EDefaultUnits fgDefaultUnits; //! Default units in GDML if not explicit in some tags; 57 ; 58 TGeoManager(const TGeoManager &) = delete;; 59 TGeoManager &operator=(const TGeoManager &) = delete;; 60 ; 61private:; 62 Double_t fPhimin; //! lowest range for phi cut; 63 Double_t fPhimax; //! high",MatchSource.WIKI,doc/master/TGeoManager_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8h_source.html
https://root.cern/doc/master/TGeoManager_8h_source.html:7013,Performance,multi-thread,multi-threading,7013,"> list of unique volumes; 130 TGeoShape *fClippingShape; //! clipping shape for raytracing; 131 TGeoElementTable *fElementTable; //! table of elements; 132 ; 133 Int_t fNLevel; // maximum accepted level in geometry; 134 TGeoVolume *fPaintVolume; //! volume currently painted; 135 TGeoVolume *fUserPaintVolume; //!; 136 THashList *fHashVolumes; //! hash list of volumes providing fast search; 137 THashList *fHashGVolumes; //! hash list of group volumes providing fast search; 138 THashList *fHashPNE; //-> hash list of physical node entries; 139 mutable TObjArray *fArrayPNE; //! array of physical node entries; 140 Int_t fSizePNEId; // size of the array of unique ID's for PN entries; 141 Int_t fNPNEId; // number of PN entries having a unique ID; 142 Int_t *fKeyPNEId; //[fSizePNEId] array of uid values for PN entries; 143 Int_t *fValuePNEId; //[fSizePNEId] array of pointers to PN entries with ID's; 144 Int_t fMaxThreads; //! Max number of threads; 145 Bool_t fMultiThread; //! Flag for multi-threading; 146 Int_t fRaytraceMode; //! Raytrace mode: 0=normal, 1=pass through, 2=transparent; 147 Bool_t fUsePWNav; // Activate usage of parallel world in navigation; 148 TGeoParallelWorld *fParallelWorld; // Parallel world; 149 ConstPropMap_t fProperties; // Map of user-defined constant properties; 150 //--- private methods; 151 Bool_t IsLoopingVolumes() const { return fLoopVolumes; }; 152 void Init();; 153 Bool_t InitArrayPNE() const;; 154 Bool_t InsertPNEId(Int_t uid, Int_t ientry);; 155 void SetLoopVolumes(Bool_t flag = kTRUE) { fLoopVolumes = flag; }; 156 void UpdateElements();; 157 void Voxelize(Option_t *option = nullptr);; 158 ; 159public:; 160 // constructors; 161 TGeoManager();; 162 TGeoManager(const char *name, const char *title);; 163 // destructor; 164 ~TGeoManager() override;; 165 //--- adding geometrical objects; 166 Int_t AddMaterial(const TGeoMaterial *material);; 167 Int_t AddOverlap(const TNamed *ovlp);; 168 Int_t AddRegion(TGeoRegion *region);; 169 Int_t AddTransfor",MatchSource.WIKI,doc/master/TGeoManager_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8h_source.html
https://root.cern/doc/master/TGeoManager_8h_source.html:32632,Performance,cache,cache,32632,"trix(TGDMLMatrix *mat);; 565 TGeoOpticalSurface *GetOpticalSurface(const char *name) const;; 566 void AddOpticalSurface(TGeoOpticalSurface *optsurf);; 567 TGeoSkinSurface *GetSkinSurface(const char *name) const;; 568 void AddSkinSurface(TGeoSkinSurface *surf);; 569 TGeoBorderSurface *GetBorderSurface(const char *name) const;; 570 void AddBorderSurface(TGeoBorderSurface *surf);; 571 ; 572 // TGeoShape *GetShape(const char *name) const;; 573 TGeoVolume *GetVolume(const char *name) const;; 574 TGeoVolume *GetVolume(Int_t uid) const { return (TGeoVolume *)fUniqueVolumes->At(uid); }; 575 int GetNregions() const { return fRegions->GetEntriesFast(); }; 576 TGeoRegion *GetRegion(int i) { return (TGeoRegion *)fRegions->At(i); }; 577 Int_t GetUID(const char *volname) const;; 578 Int_t GetNNodes(); 579 {; 580 if (!fNNodes); 581 CountNodes();; 582 return fNNodes;; 583 }; 584 TGeoNodeCache *GetCache() const { return GetCurrentNavigator()->GetCache(); }; 585 // void SetCache(const TGeoNodeCache *cache) {fCache = (TGeoNodeCache*)cache;}; 586 void SetAnimateTracks(Bool_t flag = kTRUE) { fIsGeomReading = flag; }; 587 virtual ULong_t SizeOf(const TGeoNode *node, Option_t *option); // size of the geometry in memory; 588 void SelectTrackingMedia();; 589 ; 590 //--- stack manipulation; 591 Int_t PushPath(Int_t startlevel = 0) { return GetCurrentNavigator()->PushPath(startlevel); }; 592 Bool_t PopPath() { return GetCurrentNavigator()->PopPath(); }; 593 Bool_t PopPath(Int_t index) { return GetCurrentNavigator()->PopPath(index); }; 594 Int_t PushPoint(Int_t startlevel = 0) { return GetCurrentNavigator()->PushPoint(startlevel); }; 595 Bool_t PopPoint() { return GetCurrentNavigator()->PopPoint(); }; 596 Bool_t PopPoint(Int_t index) { return GetCurrentNavigator()->PopPoint(index); }; 597 void PopDummy(Int_t ipop = 9999) { return GetCurrentNavigator()->PopDummy(ipop); }; 598 ; 599 //--- parallel world navigation; 600 TGeoParallelWorld *CreateParallelWorld(const char *name);; 601 TGeoParallelWo",MatchSource.WIKI,doc/master/TGeoManager_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8h_source.html
https://root.cern/doc/master/TGeoManager_8h_source.html:32665,Performance,cache,cache,32665,"OpticalSurface *GetOpticalSurface(const char *name) const;; 566 void AddOpticalSurface(TGeoOpticalSurface *optsurf);; 567 TGeoSkinSurface *GetSkinSurface(const char *name) const;; 568 void AddSkinSurface(TGeoSkinSurface *surf);; 569 TGeoBorderSurface *GetBorderSurface(const char *name) const;; 570 void AddBorderSurface(TGeoBorderSurface *surf);; 571 ; 572 // TGeoShape *GetShape(const char *name) const;; 573 TGeoVolume *GetVolume(const char *name) const;; 574 TGeoVolume *GetVolume(Int_t uid) const { return (TGeoVolume *)fUniqueVolumes->At(uid); }; 575 int GetNregions() const { return fRegions->GetEntriesFast(); }; 576 TGeoRegion *GetRegion(int i) { return (TGeoRegion *)fRegions->At(i); }; 577 Int_t GetUID(const char *volname) const;; 578 Int_t GetNNodes(); 579 {; 580 if (!fNNodes); 581 CountNodes();; 582 return fNNodes;; 583 }; 584 TGeoNodeCache *GetCache() const { return GetCurrentNavigator()->GetCache(); }; 585 // void SetCache(const TGeoNodeCache *cache) {fCache = (TGeoNodeCache*)cache;}; 586 void SetAnimateTracks(Bool_t flag = kTRUE) { fIsGeomReading = flag; }; 587 virtual ULong_t SizeOf(const TGeoNode *node, Option_t *option); // size of the geometry in memory; 588 void SelectTrackingMedia();; 589 ; 590 //--- stack manipulation; 591 Int_t PushPath(Int_t startlevel = 0) { return GetCurrentNavigator()->PushPath(startlevel); }; 592 Bool_t PopPath() { return GetCurrentNavigator()->PopPath(); }; 593 Bool_t PopPath(Int_t index) { return GetCurrentNavigator()->PopPath(index); }; 594 Int_t PushPoint(Int_t startlevel = 0) { return GetCurrentNavigator()->PushPoint(startlevel); }; 595 Bool_t PopPoint() { return GetCurrentNavigator()->PopPoint(); }; 596 Bool_t PopPoint(Int_t index) { return GetCurrentNavigator()->PopPoint(index); }; 597 void PopDummy(Int_t ipop = 9999) { return GetCurrentNavigator()->PopDummy(ipop); }; 598 ; 599 //--- parallel world navigation; 600 TGeoParallelWorld *CreateParallelWorld(const char *name);; 601 TGeoParallelWorld *GetParallelWorld() const { r",MatchSource.WIKI,doc/master/TGeoManager_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8h_source.html
https://root.cern/doc/master/TGeoManager_8h_source.html:40357,Performance,multi-thread,multi-threading,40357,"anager::AnimateTracksvoid AnimateTracks(Double_t tmin=0, Double_t tmax=5E-8, Int_t nframes=200, Option_t *option=""/*"")Draw animation of tracks.Definition TGeoManager.cxx:1836; TGeoManager::AddSkinSurfacevoid AddSkinSurface(TGeoSkinSurface *surf)Add skin surface;.Definition TGeoManager.cxx:2048; TGeoManager::GetMotherTGeoNode * GetMother(Int_t up=1) constDefinition TGeoManager.h:493; TGeoManager::MakeXtruTGeoVolume * MakeXtru(const char *name, TGeoMedium *medium, Int_t nz)Make a TGeoXtru-shaped volume with nz planes.Definition TGeoManager.cxx:3332; TGeoManager::FindNormalFastDouble_t * FindNormalFast()Computes fast normal to next crossed boundary, assuming that the current point is close enough to the...Definition TGeoManager.cxx:2799; TGeoManager::MakePconTGeoVolume * MakePcon(const char *name, TGeoMedium *medium, Double_t phi, Double_t dphi, Int_t nz)Make in one step a volume pointing to a polycone shape with given medium.Definition TGeoManager.cxx:3275; TGeoManager::fRaytraceModeInt_t fRaytraceModeFlag for multi-threading.Definition TGeoManager.h:146; TGeoManager::fVisDensityDouble_t fVisDensityparticles to be drawnDefinition TGeoManager.h:69; TGeoManager::AddNavigatorTGeoNavigator * AddNavigator()Add a navigator in the list of navigators.Definition TGeoManager.cxx:789; TGeoManager::GetListOfUVolumesTObjArray * GetListOfUVolumes() constDefinition TGeoManager.h:477; TGeoManager::GetTrackOfIdTVirtualGeoTrack * GetTrackOfId(Int_t id) constGet track with a given ID.Definition TGeoManager.cxx:2200; TGeoManager::FindDuplicateMaterialTGeoMaterial * FindDuplicateMaterial(const TGeoMaterial *mat) constFind if a given material duplicates an existing one.Definition TGeoManager.cxx:2992; TGeoManager::PopPointBool_t PopPoint()Definition TGeoManager.h:595; TGeoManager::GetVolumeTGeoVolume * GetVolume(Int_t uid) constDefinition TGeoManager.h:574; TGeoManager::GetListOfOverlapsTObjArray * GetListOfOverlaps()Definition TGeoManager.h:469; TGeoManager::DivisionTGeoVolume * Division(",MatchSource.WIKI,doc/master/TGeoManager_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8h_source.html
https://root.cern/doc/master/TGeoManager_8h_source.html:42114,Performance,cache,cache,42114,"PopPoint()Definition TGeoManager.h:595; TGeoManager::GetVolumeTGeoVolume * GetVolume(Int_t uid) constDefinition TGeoManager.h:574; TGeoManager::GetListOfOverlapsTObjArray * GetListOfOverlaps()Definition TGeoManager.h:469; TGeoManager::DivisionTGeoVolume * Division(const char *name, const char *mother, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step, Int_t numed=0, Option_t *option="""")Create a new volume by dividing an existing one (GEANT3 like)Definition TGeoManager.cxx:1258; TGeoManager::VolumeTGeoVolume * Volume(const char *name, const char *shape, Int_t nmed, Float_t *upar, Int_t npar=0)Create a volume in GEANT3 style.Definition TGeoManager.cxx:1388; TGeoManager::ReplaceVolumeInt_t ReplaceVolume(TGeoVolume *vorig, TGeoVolume *vnew)Replaces all occurrences of VORIG with VNEW in the geometry tree.Definition TGeoManager.cxx:1125; TGeoManager::SetDrawExtraPathsvoid SetDrawExtraPaths(Bool_t flag=kTRUE)Definition TGeoManager.h:238; TGeoManager::DoRestoreStatevoid DoRestoreState()Restore a backed-up state without affecting the cache stack.Definition TGeoManager.cxx:1106; TGeoManager::GetCurrentNodeIdInt_t GetCurrentNodeId() constGet the unique ID of the current node.Definition TGeoManager.cxx:1663; TGeoManager::GetAlignableEntryTGeoPNEntry * GetAlignableEntry(const char *name) constRetrieves an existing alignable object.Definition TGeoManager.cxx:3370; TGeoManager::fMasterVolumeTGeoVolume * fMasterVolumetop physical nodeDefinition TGeoManager.h:127; TGeoManager::FindTrackWithIdTVirtualGeoTrack * FindTrackWithId(Int_t id) constSearch the track hierarchy to find the track with the given id.Definition TGeoManager.cxx:2180; TGeoManager::fArrayPNETObjArray * fArrayPNEDefinition TGeoManager.h:139; TGeoManager::IsStepEnteringBool_t IsStepEntering() constDefinition TGeoManager.h:404; TGeoManager::GetLastPointconst Double_t * GetLastPoint() constDefinition TGeoManager.h:372; TGeoManager::TestOverlapsvoid TestOverlaps(const char *path="""")Geometry overlap checker based on sa",MatchSource.WIKI,doc/master/TGeoManager_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8h_source.html
https://root.cern/doc/master/TGeoManager_8h_source.html:44394,Performance,load,loaded,44394,"ListOfMediaTList * GetListOfMedia() constDefinition TGeoManager.h:472; TGeoManager::SetCldirCheckedvoid SetCldirChecked(Double_t *dir)Definition TGeoManager.h:523; TGeoManager::GetCurrentDirectionconst Double_t * GetCurrentDirection() constDefinition TGeoManager.h:502; TGeoManager::GetElementTableTGeoElementTable * GetElementTable()Returns material table. Creates it if not existing.Definition TGeoManager.cxx:3624; TGeoManager::SetUserPaintVolumevoid SetUserPaintVolume(TGeoVolume *vol)Definition TGeoManager.h:235; TGeoManager::fNtracksInt_t fNtracksDefinition TGeoManager.h:74; TGeoManager::fHashPNETHashList * fHashPNEhash list of group volumes providing fast searchDefinition TGeoManager.h:138; TGeoManager::IsVisLeavesBool_t IsVisLeaves() constDefinition TGeoManager.h:223; TGeoManager::IsNullStepBool_t IsNullStep() constDefinition TGeoManager.h:408; TGeoManager::GetListOfTracksTObjArray * GetListOfTracks() constDefinition TGeoManager.h:478; TGeoManager::fgVerboseLevelstatic Int_t fgVerboseLevelLock preventing a second geometry to be loaded.Definition TGeoManager.h:51; TGeoManager::IsStartSafeBool_t IsStartSafe() constDefinition TGeoManager.h:395; TGeoManager::Initvoid Init()Initialize manager class.Definition TGeoManager.cxx:416; TGeoManager::InitArrayPNEBool_t InitArrayPNE() constInitialize PNE array for fast access via index and unique-id.Definition TGeoManager.cxx:4214; TGeoManager::fPhysicalNodesTObjArray * fPhysicalNodesDefinition TGeoManager.h:96; TGeoManager::SizeOfvirtual ULong_t SizeOf(const TGeoNode *node, Option_t *option)computes the total size in bytes of the branch starting with node.Definition TGeoManager.cxx:3926; TGeoManager::SetLoopVolumesvoid SetLoopVolumes(Bool_t flag=kTRUE)Definition TGeoManager.h:155; TGeoManager::fUniqueVolumesTObjArray * fUniqueVolumesDefinition TGeoManager.h:129; TGeoManager::fgExportPrecisionstatic UInt_t fgExportPrecisionMaximum number of Xtru vertices.Definition TGeoManager.h:55; TGeoManager::fRegionsTObjArray * fRegionsDef",MatchSource.WIKI,doc/master/TGeoManager_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8h_source.html
https://root.cern/doc/master/TGeoManager_8h_source.html:46144,Performance,load,loaded,46144,"ager::fUniqueVolumesTObjArray * fUniqueVolumesDefinition TGeoManager.h:129; TGeoManager::fgExportPrecisionstatic UInt_t fgExportPrecisionMaximum number of Xtru vertices.Definition TGeoManager.h:55; TGeoManager::fRegionsTObjArray * fRegionsDefinition TGeoManager.h:109; TGeoManager::Nodevoid Node(const char *name, Int_t nr, const char *mother, Double_t x, Double_t y, Double_t z, Int_t irot, Bool_t isOnly, Float_t *upar, Int_t npar=0)Create a node called <name_nr> pointing to the volume called <name> as daughter of the volume called ...Definition TGeoManager.cxx:1353; TGeoManager::fGShapesTObjArray * fGShapesDefinition TGeoManager.h:97; TGeoManager::fPaintVolumeTGeoVolume * fPaintVolumeDefinition TGeoManager.h:134; TGeoManager::PopPointBool_t PopPoint(Int_t index)Definition TGeoManager.h:596; TGeoManager::GetSkinSurfaceTGeoSkinSurface * GetSkinSurface(const char *name) constGet skin surface with a given name;.Definition TGeoManager.cxx:2041; TGeoManager::UpdateElementsvoid UpdateElements()Update element flags when geometry is loaded from a file.Definition TGeoManager.cxx:4167; TGeoManager::TGeoManagerTGeoManager()Default constructor.Definition TGeoManager.cxx:311; TGeoManager::fPropertiesConstPropMap_t fPropertiesDefinition TGeoManager.h:149; TGeoManager::MakeTubeTGeoVolume * MakeTube(const char *name, TGeoMedium *medium, Double_t rmin, Double_t rmax, Double_t dz)Make in one step a volume pointing to a tube shape with given medium.Definition TGeoManager.cxx:3204; TGeoManager::CdUpvoid CdUp()Go one level up in geometry.Definition TGeoManager.cxx:1681; TGeoManager::DoBackupStatevoid DoBackupState()Backup the current state without affecting the cache stack.Definition TGeoManager.cxx:1098; TGeoManager::fMaterialsTList * fMaterialsDefinition TGeoManager.h:105; TGeoManager::GetNmanyInt_t GetNmany() constDefinition TGeoManager.h:195; TGeoManager::CheckBoundaryErrorsvoid CheckBoundaryErrors(Int_t ntracks=1000000, Double_t radius=-1.)Check pushes and pulls needed to cross the ne",MatchSource.WIKI,doc/master/TGeoManager_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8h_source.html
https://root.cern/doc/master/TGeoManager_8h_source.html:46772,Performance,cache,cache,46772,"on TGeoManager.h:97; TGeoManager::fPaintVolumeTGeoVolume * fPaintVolumeDefinition TGeoManager.h:134; TGeoManager::PopPointBool_t PopPoint(Int_t index)Definition TGeoManager.h:596; TGeoManager::GetSkinSurfaceTGeoSkinSurface * GetSkinSurface(const char *name) constGet skin surface with a given name;.Definition TGeoManager.cxx:2041; TGeoManager::UpdateElementsvoid UpdateElements()Update element flags when geometry is loaded from a file.Definition TGeoManager.cxx:4167; TGeoManager::TGeoManagerTGeoManager()Default constructor.Definition TGeoManager.cxx:311; TGeoManager::fPropertiesConstPropMap_t fPropertiesDefinition TGeoManager.h:149; TGeoManager::MakeTubeTGeoVolume * MakeTube(const char *name, TGeoMedium *medium, Double_t rmin, Double_t rmax, Double_t dz)Make in one step a volume pointing to a tube shape with given medium.Definition TGeoManager.cxx:3204; TGeoManager::CdUpvoid CdUp()Go one level up in geometry.Definition TGeoManager.cxx:1681; TGeoManager::DoBackupStatevoid DoBackupState()Backup the current state without affecting the cache stack.Definition TGeoManager.cxx:1098; TGeoManager::fMaterialsTList * fMaterialsDefinition TGeoManager.h:105; TGeoManager::GetNmanyInt_t GetNmany() constDefinition TGeoManager.h:195; TGeoManager::CheckBoundaryErrorsvoid CheckBoundaryErrors(Int_t ntracks=1000000, Double_t radius=-1.)Check pushes and pulls needed to cross the next boundary with respect to the position given by FindNe...Definition TGeoManager.cxx:3752; TGeoManager::GetGLMatrixTGeoHMatrix * GetGLMatrix() constDefinition TGeoManager.h:497; TGeoManager::fVolumesTObjArray * fVolumesDefinition TGeoManager.h:95; TGeoManager::GetListOfVolumesTObjArray * GetListOfVolumes() constDefinition TGeoManager.h:473; TGeoManager::fValuePNEIdInt_t * fValuePNEIdDefinition TGeoManager.h:143; TGeoManager::GetNextNodeTGeoNode * GetNextNode() constDefinition TGeoManager.h:492; TGeoManager::GetAlignableEntryByUIDTGeoPNEntry * GetAlignableEntryByUID(Int_t uid) constRetrieves an existing alignable ",MatchSource.WIKI,doc/master/TGeoManager_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8h_source.html
https://root.cern/doc/master/TGeoManager_8h_source.html:59345,Performance,perform,performedDefinition,59345,"6; TGeoManager::ClearAttributesvoid ClearAttributes()Reset all attributes to default ones.Definition TGeoManager.cxx:1455; TGeoManager::fgMaxDaughtersstatic Int_t fgMaxDaughtersMaximum level in geometry.Definition TGeoManager.h:53; TGeoManager::fUsePWNavBool_t fUsePWNavRaytrace mode: 0=normal, 1=pass through, 2=transparent.Definition TGeoManager.h:147; TGeoManager::SetRTmodevoid SetRTmode(Int_t mode)Change raytracing mode.Definition TGeoManager.cxx:3108; TGeoManager::CheckPathBool_t CheckPath(const char *path) constCheck if a geometry path is valid without changing the state of the current navigator.Definition TGeoManager.cxx:1715; TGeoManager::InspectStatevoid InspectState() constInspects path and all flags for the current state.Definition TGeoManager.cxx:2873; TGeoManager::ConvertReflectionsvoid ConvertReflections()Convert all reflections in geometry to normal rotations + reflected shapes.Definition TGeoManager.cxx:1723; TGeoManager::SetVisLevelvoid SetVisLevel(Int_t level=3)set default level down to which visualization is performedDefinition TGeoManager.cxx:2459; TGeoManager::SetMatrixTransformvoid SetMatrixTransform(Bool_t on=kTRUE)Definition TGeoManager.h:398; TGeoManager::FindNextBoundaryTGeoNode * FindNextBoundary(Double_t stepmax=TGeoShape::Big(), const char *path="""", Bool_t frombdr=kFALSE)Find distance to next boundary and store it in fStep.Definition TGeoManager.cxx:2755; TGeoManager::MasterToLocalBombvoid MasterToLocalBomb(const Double_t *master, Double_t *local) constDefinition TGeoManager.h:546; TGeoManager::Importstatic TGeoManager * Import(const char *filename, const char *name="""", Option_t *option="""")static function Import a geometry from a gdml or ROOT fileDefinition TGeoManager.cxx:4096; TGeoManager::MakePhysicalNodeTGeoPhysicalNode * MakePhysicalNode(const char *path=nullptr)Makes a physical node corresponding to a path.Definition TGeoManager.cxx:3506; TGeoManager::CountLevelsvoid CountLevels()Count maximum number of nodes per volume, maximum dept",MatchSource.WIKI,doc/master/TGeoManager_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8h_source.html
https://root.cern/doc/master/TGeoManager_8h_source.html:12862,Safety,safe,safety,12862," void SetVisDensity(Double_t dens = 0.01); // *MENU*; 241 void SetVisLevel(Int_t level = 3); // *MENU*; 242 void SetVisOption(Int_t option = 0);; 243 void ViewLeaves(Bool_t flag = kTRUE); // *TOGGLE* *GETTER=IsVisLeaves; 244 void SaveAttributes(const char *filename = ""tgeoatt.C""); // *MENU*; 245 void RestoreMasterVolume(); // *MENU*; 246 void SetMaxVisNodes(Int_t maxnodes = 10000); // *MENU*; 247 //--- geometry checking; 248 void AnimateTracks(Double_t tmin = 0, Double_t tmax = 5E-8, Int_t nframes = 200, Option_t *option = ""/*""); // *MENU*; 249 void CheckBoundaryErrors(Int_t ntracks = 1000000, Double_t radius = -1.); // *MENU*; 250 void CheckBoundaryReference(Int_t icheck = -1);; 251 void CheckGeometryFull(Int_t ntracks = 1000000, Double_t vx = 0., Double_t vy = 0., Double_t vz = 0.,; 252 Option_t *option = ""ob""); // *MENU*; 253 void CheckGeometry(Option_t *option = """");; 254 void CheckOverlaps(Double_t ovlp = 0.1, Option_t *option = """"); // *MENU*; 255 void CheckPoint(Double_t x = 0, Double_t y = 0, Double_t z = 0, Option_t *option = """", Double_t safety = 0.); // *MENU*; 256 void CheckShape(TGeoShape *shape, Int_t testNo, Int_t nsamples, Option_t *option);; 257 void ConvertReflections();; 258 void DrawCurrentPoint(Int_t color = 2); // *MENU*; 259 void DrawTracks(Option_t *option = """"); // *MENU*; 260 void SetParticleName(const char *pname) { fParticleName = pname; }; 261 const char *GetParticleName() const { return fParticleName.Data(); }; 262 void DrawPath(const char *path, Option_t *option = """");; 263 void PrintOverlaps() const; // *MENU*; 264 void RandomPoints(const TGeoVolume *vol, Int_t npoints = 10000, Option_t *option = """");; 265 void RandomRays(Int_t nrays = 1000, Double_t startx = 0, Double_t starty = 0, Double_t startz = 0,; 266 const char *target_vol = nullptr, Bool_t check_norm = kFALSE);; 267 TGeoNode *SamplePoints(Int_t npoints, Double_t &dist, Double_t epsil = 1E-5, const char *g3path = """");; 268 void SetNmeshPoints(Int_t npoints = 1000);; 269 void Se",MatchSource.WIKI,doc/master/TGeoManager_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8h_source.html
https://root.cern/doc/master/TGeoManager_8h_source.html:84662,Safety,safe,safe,84662,"nager::GetTmaxDouble_t GetTmax() constDefinition TGeoManager.h:214; TGeoManager::MakeVolumeAssemblyTGeoVolumeAssembly * MakeVolumeAssembly(const char *name)Make an assembly of volumes.Definition TGeoManager.cxx:3553; TGeoManager::GetBombModeInt_t GetBombMode() constDefinition TGeoManager.h:210; TGeoManager::GetListOfOpticalSurfacesTObjArray * GetListOfOpticalSurfaces() constDefinition TGeoManager.h:480; TGeoManager::AddRegionInt_t AddRegion(TGeoRegion *region)Add a new region of volumes.Definition TGeoManager.cxx:633; TGeoManager::SelectTrackingMediavoid SelectTrackingMedia()Define different tracking media.Definition TGeoManager.cxx:3708; TGeoManager::EnableInactiveVolumesvoid EnableInactiveVolumes()Definition TGeoManager.h:363; TGeoManager::CdNextvoid CdNext()Do a cd to the node found next by FindNextBoundary.Definition TGeoManager.cxx:1698; TGeoManager::CdTopvoid CdTop()Make top level node the current node.Definition TGeoManager.cxx:1672; TGeoManager::SafetyDouble_t Safety(Bool_t inside=kFALSE)Compute safe distance from the current point.Definition TGeoManager.cxx:2300; TGeoManager::fKeyPNEIdInt_t * fKeyPNEIdDefinition TGeoManager.h:142; TGeoManager::DefaultAnglesvoid DefaultAngles()Set default angles for a given view.Definition TGeoManager.cxx:1818; TGeoManager::MixtureTGeoMaterial * Mixture(const char *name, Float_t *a, Float_t *z, Double_t dens, Int_t nelem, Float_t *wmat, Int_t uid)Create mixture OR COMPOUND IMAT as composed by THE BASIC nelem materials defined by arrays A,...Definition TGeoManager.cxx:1296; TGeoManager::ThreadsMap_tstd::map< std::thread::id, Int_t > ThreadsMap_tDefinition TGeoManager.h:114; TGeoManager::CheckPointvoid CheckPoint(Double_t x=0, Double_t y=0, Double_t z=0, Option_t *option="""", Double_t safety=0.)Classify a given point. See TGeoChecker::CheckPoint().Definition TGeoManager.cxx:3770; TGeoManager::SetUseParallelWorldNavvoid SetUseParallelWorldNav(Bool_t flag)Activate/deactivate usage of parallel world navigation.Definition TGeoManage",MatchSource.WIKI,doc/master/TGeoManager_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8h_source.html
https://root.cern/doc/master/TGeoManager_8h_source.html:85396,Safety,safe,safety,85396,"veVolumes()Definition TGeoManager.h:363; TGeoManager::CdNextvoid CdNext()Do a cd to the node found next by FindNextBoundary.Definition TGeoManager.cxx:1698; TGeoManager::CdTopvoid CdTop()Make top level node the current node.Definition TGeoManager.cxx:1672; TGeoManager::SafetyDouble_t Safety(Bool_t inside=kFALSE)Compute safe distance from the current point.Definition TGeoManager.cxx:2300; TGeoManager::fKeyPNEIdInt_t * fKeyPNEIdDefinition TGeoManager.h:142; TGeoManager::DefaultAnglesvoid DefaultAngles()Set default angles for a given view.Definition TGeoManager.cxx:1818; TGeoManager::MixtureTGeoMaterial * Mixture(const char *name, Float_t *a, Float_t *z, Double_t dens, Int_t nelem, Float_t *wmat, Int_t uid)Create mixture OR COMPOUND IMAT as composed by THE BASIC nelem materials defined by arrays A,...Definition TGeoManager.cxx:1296; TGeoManager::ThreadsMap_tstd::map< std::thread::id, Int_t > ThreadsMap_tDefinition TGeoManager.h:114; TGeoManager::CheckPointvoid CheckPoint(Double_t x=0, Double_t y=0, Double_t z=0, Option_t *option="""", Double_t safety=0.)Classify a given point. See TGeoChecker::CheckPoint().Definition TGeoManager.cxx:3770; TGeoManager::SetUseParallelWorldNavvoid SetUseParallelWorldNav(Bool_t flag)Activate/deactivate usage of parallel world navigation.Definition TGeoManager.cxx:4288; TGeoManager::IsCheckingOverlapsBool_t IsCheckingOverlaps() constDefinition TGeoManager.h:389; TGeoManager::MasterToLocalvoid MasterToLocal(const Double_t *master, Double_t *local) constDefinition TGeoManager.h:538; TGeoManager::GetPhysicalNodeTGeoPhysicalNode * GetPhysicalNode(Int_t i) constDefinition TGeoManager.h:514; TGeoManager::GetLastTrackTVirtualGeoTrack * GetLastTrack()Definition TGeoManager.h:368; TGeoManager::Browsevoid Browse(TBrowser *b) overrideDescribe how to browse this object.Definition TGeoManager.cxx:1023; TGeoManager::GetCldirCheckedconst Double_t * GetCldirChecked() constDefinition TGeoManager.h:504; TGeoManager::Testvoid Test(Int_t npoints=1000000, Option_t",MatchSource.WIKI,doc/master/TGeoManager_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8h_source.html
https://root.cern/doc/master/TGeoManager_8h_source.html:6369,Security,hash,hash,6369,"9 NavigatorsMap_t fNavigators; //! Map between thread id's and navigator arrays; 120 static ThreadsMap_t *fgThreadId; //! Thread id's map; 121 static Int_t fgNumThreads; //! Number of registered threads; 122 static Bool_t fgLockNavigators; //! Lock existing navigators; 123 TGeoNavigator *fCurrentNavigator; //! current navigator; 124 TGeoVolume *fCurrentVolume; //! current volume; 125 TGeoVolume *fTopVolume; //! top level volume in geometry; 126 TGeoNode *fTopNode; //! top physical node; 127 TGeoVolume *fMasterVolume; // master volume; 128 TGeoHMatrix *fGLMatrix; // matrix to be used for view transformations; 129 TObjArray *fUniqueVolumes; //-> list of unique volumes; 130 TGeoShape *fClippingShape; //! clipping shape for raytracing; 131 TGeoElementTable *fElementTable; //! table of elements; 132 ; 133 Int_t fNLevel; // maximum accepted level in geometry; 134 TGeoVolume *fPaintVolume; //! volume currently painted; 135 TGeoVolume *fUserPaintVolume; //!; 136 THashList *fHashVolumes; //! hash list of volumes providing fast search; 137 THashList *fHashGVolumes; //! hash list of group volumes providing fast search; 138 THashList *fHashPNE; //-> hash list of physical node entries; 139 mutable TObjArray *fArrayPNE; //! array of physical node entries; 140 Int_t fSizePNEId; // size of the array of unique ID's for PN entries; 141 Int_t fNPNEId; // number of PN entries having a unique ID; 142 Int_t *fKeyPNEId; //[fSizePNEId] array of uid values for PN entries; 143 Int_t *fValuePNEId; //[fSizePNEId] array of pointers to PN entries with ID's; 144 Int_t fMaxThreads; //! Max number of threads; 145 Bool_t fMultiThread; //! Flag for multi-threading; 146 Int_t fRaytraceMode; //! Raytrace mode: 0=normal, 1=pass through, 2=transparent; 147 Bool_t fUsePWNav; // Activate usage of parallel world in navigation; 148 TGeoParallelWorld *fParallelWorld; // Parallel world; 149 ConstPropMap_t fProperties; // Map of user-defined constant properties; 150 //--- private methods; 151 Bool_t IsLoopingVol",MatchSource.WIKI,doc/master/TGeoManager_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8h_source.html
https://root.cern/doc/master/TGeoManager_8h_source.html:6447,Security,hash,hash,6447,"s; 120 static ThreadsMap_t *fgThreadId; //! Thread id's map; 121 static Int_t fgNumThreads; //! Number of registered threads; 122 static Bool_t fgLockNavigators; //! Lock existing navigators; 123 TGeoNavigator *fCurrentNavigator; //! current navigator; 124 TGeoVolume *fCurrentVolume; //! current volume; 125 TGeoVolume *fTopVolume; //! top level volume in geometry; 126 TGeoNode *fTopNode; //! top physical node; 127 TGeoVolume *fMasterVolume; // master volume; 128 TGeoHMatrix *fGLMatrix; // matrix to be used for view transformations; 129 TObjArray *fUniqueVolumes; //-> list of unique volumes; 130 TGeoShape *fClippingShape; //! clipping shape for raytracing; 131 TGeoElementTable *fElementTable; //! table of elements; 132 ; 133 Int_t fNLevel; // maximum accepted level in geometry; 134 TGeoVolume *fPaintVolume; //! volume currently painted; 135 TGeoVolume *fUserPaintVolume; //!; 136 THashList *fHashVolumes; //! hash list of volumes providing fast search; 137 THashList *fHashGVolumes; //! hash list of group volumes providing fast search; 138 THashList *fHashPNE; //-> hash list of physical node entries; 139 mutable TObjArray *fArrayPNE; //! array of physical node entries; 140 Int_t fSizePNEId; // size of the array of unique ID's for PN entries; 141 Int_t fNPNEId; // number of PN entries having a unique ID; 142 Int_t *fKeyPNEId; //[fSizePNEId] array of uid values for PN entries; 143 Int_t *fValuePNEId; //[fSizePNEId] array of pointers to PN entries with ID's; 144 Int_t fMaxThreads; //! Max number of threads; 145 Bool_t fMultiThread; //! Flag for multi-threading; 146 Int_t fRaytraceMode; //! Raytrace mode: 0=normal, 1=pass through, 2=transparent; 147 Bool_t fUsePWNav; // Activate usage of parallel world in navigation; 148 TGeoParallelWorld *fParallelWorld; // Parallel world; 149 ConstPropMap_t fProperties; // Map of user-defined constant properties; 150 //--- private methods; 151 Bool_t IsLoopingVolumes() const { return fLoopVolumes; }; 152 void Init();; 153 Bool_t InitArrayP",MatchSource.WIKI,doc/master/TGeoManager_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8h_source.html
https://root.cern/doc/master/TGeoManager_8h_source.html:6527,Security,hash,hash,6527,"NumThreads; //! Number of registered threads; 122 static Bool_t fgLockNavigators; //! Lock existing navigators; 123 TGeoNavigator *fCurrentNavigator; //! current navigator; 124 TGeoVolume *fCurrentVolume; //! current volume; 125 TGeoVolume *fTopVolume; //! top level volume in geometry; 126 TGeoNode *fTopNode; //! top physical node; 127 TGeoVolume *fMasterVolume; // master volume; 128 TGeoHMatrix *fGLMatrix; // matrix to be used for view transformations; 129 TObjArray *fUniqueVolumes; //-> list of unique volumes; 130 TGeoShape *fClippingShape; //! clipping shape for raytracing; 131 TGeoElementTable *fElementTable; //! table of elements; 132 ; 133 Int_t fNLevel; // maximum accepted level in geometry; 134 TGeoVolume *fPaintVolume; //! volume currently painted; 135 TGeoVolume *fUserPaintVolume; //!; 136 THashList *fHashVolumes; //! hash list of volumes providing fast search; 137 THashList *fHashGVolumes; //! hash list of group volumes providing fast search; 138 THashList *fHashPNE; //-> hash list of physical node entries; 139 mutable TObjArray *fArrayPNE; //! array of physical node entries; 140 Int_t fSizePNEId; // size of the array of unique ID's for PN entries; 141 Int_t fNPNEId; // number of PN entries having a unique ID; 142 Int_t *fKeyPNEId; //[fSizePNEId] array of uid values for PN entries; 143 Int_t *fValuePNEId; //[fSizePNEId] array of pointers to PN entries with ID's; 144 Int_t fMaxThreads; //! Max number of threads; 145 Bool_t fMultiThread; //! Flag for multi-threading; 146 Int_t fRaytraceMode; //! Raytrace mode: 0=normal, 1=pass through, 2=transparent; 147 Bool_t fUsePWNav; // Activate usage of parallel world in navigation; 148 TGeoParallelWorld *fParallelWorld; // Parallel world; 149 ConstPropMap_t fProperties; // Map of user-defined constant properties; 150 //--- private methods; 151 Bool_t IsLoopingVolumes() const { return fLoopVolumes; }; 152 void Init();; 153 Bool_t InitArrayPNE() const;; 154 Bool_t InsertPNEId(Int_t uid, Int_t ientry);; 155 void SetLoopV",MatchSource.WIKI,doc/master/TGeoManager_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8h_source.html
https://root.cern/doc/master/TGeoManager_8h_source.html:31549,Security,access,accessors,31549," 539 {; 540 GetCurrentNavigator()->MasterToLocal(master, local);; 541 }; 542 void MasterToLocalVect(const Double_t *master, Double_t *local) const; 543 {; 544 GetCurrentNavigator()->MasterToLocalVect(master, local);; 545 }; 546 void MasterToLocalBomb(const Double_t *master, Double_t *local) const; 547 {; 548 GetCurrentNavigator()->MasterToLocalBomb(master, local);; 549 }; 550 void MasterToTop(const Double_t *master, Double_t *top) const;; 551 void TopToMaster(const Double_t *top, Double_t *master) const;; 552 ; 553 //--- general use getters/setters; 554 TGeoMaterial *FindDuplicateMaterial(const TGeoMaterial *mat) const;; 555 TGeoVolume *FindVolumeFast(const char *name, Bool_t multi = kFALSE);; 556 TGeoMaterial *GetMaterial(const char *matname) const;; 557 TGeoMaterial *GetMaterial(Int_t id) const;; 558 TGeoMedium *GetMedium(const char *medium) const;; 559 TGeoMedium *GetMedium(Int_t numed) const;; 560 Int_t GetMaterialIndex(const char *matname) const;; 561 ; 562 //--- GDML object accessors; 563 TGDMLMatrix *GetGDMLMatrix(const char *name) const;; 564 void AddGDMLMatrix(TGDMLMatrix *mat);; 565 TGeoOpticalSurface *GetOpticalSurface(const char *name) const;; 566 void AddOpticalSurface(TGeoOpticalSurface *optsurf);; 567 TGeoSkinSurface *GetSkinSurface(const char *name) const;; 568 void AddSkinSurface(TGeoSkinSurface *surf);; 569 TGeoBorderSurface *GetBorderSurface(const char *name) const;; 570 void AddBorderSurface(TGeoBorderSurface *surf);; 571 ; 572 // TGeoShape *GetShape(const char *name) const;; 573 TGeoVolume *GetVolume(const char *name) const;; 574 TGeoVolume *GetVolume(Int_t uid) const { return (TGeoVolume *)fUniqueVolumes->At(uid); }; 575 int GetNregions() const { return fRegions->GetEntriesFast(); }; 576 TGeoRegion *GetRegion(int i) { return (TGeoRegion *)fRegions->At(i); }; 577 Int_t GetUID(const char *volname) const;; 578 Int_t GetNNodes(); 579 {; 580 if (!fNNodes); 581 CountNodes();; 582 return fNNodes;; 583 }; 584 TGeoNodeCache *GetCache() const { return Ge",MatchSource.WIKI,doc/master/TGeoManager_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8h_source.html
https://root.cern/doc/master/TGeoManager_8h_source.html:44677,Security,access,access,44677,"eoElementTable * GetElementTable()Returns material table. Creates it if not existing.Definition TGeoManager.cxx:3624; TGeoManager::SetUserPaintVolumevoid SetUserPaintVolume(TGeoVolume *vol)Definition TGeoManager.h:235; TGeoManager::fNtracksInt_t fNtracksDefinition TGeoManager.h:74; TGeoManager::fHashPNETHashList * fHashPNEhash list of group volumes providing fast searchDefinition TGeoManager.h:138; TGeoManager::IsVisLeavesBool_t IsVisLeaves() constDefinition TGeoManager.h:223; TGeoManager::IsNullStepBool_t IsNullStep() constDefinition TGeoManager.h:408; TGeoManager::GetListOfTracksTObjArray * GetListOfTracks() constDefinition TGeoManager.h:478; TGeoManager::fgVerboseLevelstatic Int_t fgVerboseLevelLock preventing a second geometry to be loaded.Definition TGeoManager.h:51; TGeoManager::IsStartSafeBool_t IsStartSafe() constDefinition TGeoManager.h:395; TGeoManager::Initvoid Init()Initialize manager class.Definition TGeoManager.cxx:416; TGeoManager::InitArrayPNEBool_t InitArrayPNE() constInitialize PNE array for fast access via index and unique-id.Definition TGeoManager.cxx:4214; TGeoManager::fPhysicalNodesTObjArray * fPhysicalNodesDefinition TGeoManager.h:96; TGeoManager::SizeOfvirtual ULong_t SizeOf(const TGeoNode *node, Option_t *option)computes the total size in bytes of the branch starting with node.Definition TGeoManager.cxx:3926; TGeoManager::SetLoopVolumesvoid SetLoopVolumes(Bool_t flag=kTRUE)Definition TGeoManager.h:155; TGeoManager::fUniqueVolumesTObjArray * fUniqueVolumesDefinition TGeoManager.h:129; TGeoManager::fgExportPrecisionstatic UInt_t fgExportPrecisionMaximum number of Xtru vertices.Definition TGeoManager.h:55; TGeoManager::fRegionsTObjArray * fRegionsDefinition TGeoManager.h:109; TGeoManager::Nodevoid Node(const char *name, Int_t nr, const char *mother, Double_t x, Double_t y, Double_t z, Int_t irot, Bool_t isOnly, Float_t *upar, Int_t npar=0)Create a node called <name_nr> pointing to the volume called <name> as daughter of the volume called ...Def",MatchSource.WIKI,doc/master/TGeoManager_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8h_source.html
https://root.cern/doc/master/TGeoManager_8h_source.html:101181,Security,hash,hash,101181,"eoOpticalSurface.h:27; TGeoPNEntryThe knowledge of the path to the objects that need to be misaligned is essential since there is no ot...Definition TGeoPhysicalNode.h:100; TGeoParallelWorldBase class for a flat parallel geometry.Definition TGeoParallelWorld.h:23; TGeoPhysicalNodePhysical nodes are the actual 'touchable' objects in the geometry, representing a path of positioned ...Definition TGeoPhysicalNode.h:35; TGeoRegionRegions are groups of volumes having a common set of user tracking cuts.Definition TGeoRegion.h:36; TGeoShapeBase abstract class for all shapes.Definition TGeoShape.h:25; TGeoShape::Bigstatic Double_t Big()Definition TGeoShape.h:87; TGeoSkinSurfaceDefinition TGeoOpticalSurface.h:177; TGeoVolumeAssemblyVolume assemblies.Definition TGeoVolume.h:316; TGeoVolumeMultiVolume families.Definition TGeoVolume.h:266; TGeoVolumeTGeoVolume, TGeoVolumeMulti, TGeoVolumeAssembly are the volume classes.Definition TGeoVolume.h:43; THashListTHashList implements a hybrid collection class consisting of a hash table and a list to store TObject...Definition THashList.h:34; TListA doubly linked list.Definition TList.h:38; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjArray::GetEntriesFastInt_t GetEntriesFast() constDefinition TObjArray.h:58; TObjArray::Deletevoid Delete(Option_t *option="""") overrideRemove all objects from the array AND delete all heap based objects.Definition TObjArray.cxx:356; TObjArray::AtTObject * At(Int_t idx) const overrideDefinition TObjArray.h:164; TObjArray::UncheckedAtTObject * UncheckedAt(Int_t i) constDefinition TObjArray.h:84; TObjectMother of all ROOT objects.Definition TObject.h:41; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; TVirtualGeoPainterAbstract class for geometry painters.Definition TVirtualGeoPainter.h:32; TVirtualGeoTrackBase class for user-defined track",MatchSource.WIKI,doc/master/TGeoManager_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8h_source.html
https://root.cern/doc/master/TGeoManager_8h_source.html:12931,Testability,test,testNo,12931,"e = ""tgeoatt.C""); // *MENU*; 245 void RestoreMasterVolume(); // *MENU*; 246 void SetMaxVisNodes(Int_t maxnodes = 10000); // *MENU*; 247 //--- geometry checking; 248 void AnimateTracks(Double_t tmin = 0, Double_t tmax = 5E-8, Int_t nframes = 200, Option_t *option = ""/*""); // *MENU*; 249 void CheckBoundaryErrors(Int_t ntracks = 1000000, Double_t radius = -1.); // *MENU*; 250 void CheckBoundaryReference(Int_t icheck = -1);; 251 void CheckGeometryFull(Int_t ntracks = 1000000, Double_t vx = 0., Double_t vy = 0., Double_t vz = 0.,; 252 Option_t *option = ""ob""); // *MENU*; 253 void CheckGeometry(Option_t *option = """");; 254 void CheckOverlaps(Double_t ovlp = 0.1, Option_t *option = """"); // *MENU*; 255 void CheckPoint(Double_t x = 0, Double_t y = 0, Double_t z = 0, Option_t *option = """", Double_t safety = 0.); // *MENU*; 256 void CheckShape(TGeoShape *shape, Int_t testNo, Int_t nsamples, Option_t *option);; 257 void ConvertReflections();; 258 void DrawCurrentPoint(Int_t color = 2); // *MENU*; 259 void DrawTracks(Option_t *option = """"); // *MENU*; 260 void SetParticleName(const char *pname) { fParticleName = pname; }; 261 const char *GetParticleName() const { return fParticleName.Data(); }; 262 void DrawPath(const char *path, Option_t *option = """");; 263 void PrintOverlaps() const; // *MENU*; 264 void RandomPoints(const TGeoVolume *vol, Int_t npoints = 10000, Option_t *option = """");; 265 void RandomRays(Int_t nrays = 1000, Double_t startx = 0, Double_t starty = 0, Double_t startz = 0,; 266 const char *target_vol = nullptr, Bool_t check_norm = kFALSE);; 267 TGeoNode *SamplePoints(Int_t npoints, Double_t &dist, Double_t epsil = 1E-5, const char *g3path = """");; 268 void SetNmeshPoints(Int_t npoints = 1000);; 269 void SetCheckedNode(TGeoNode *node);; 270 void Test(Int_t npoints = 1000000, Option_t *option = """"); // *MENU*; 271 void TestOverlaps(const char *path = """"); // *MENU*; 272 Double_t Weight(Double_t precision = 0.01, Option_t *option = ""va""); // *MENU*; 273 ; 274 //--- GE",MatchSource.WIKI,doc/master/TGeoManager_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8h_source.html
https://root.cern/doc/master/TGeoManager_8h_source.html:68957,Testability,test,testNo,68957," TGeoManager.cxx:873; TGeoManager::fgMaxXtruVertstatic Int_t fgMaxXtruVertMaximum number of daughters.Definition TGeoManager.h:54; TGeoManager::FindNodeTGeoNode * FindNode(Bool_t safe_start=kTRUE)Returns deepest node containing current point.Definition TGeoManager.cxx:2782; TGeoManager::GetVisOptionInt_t GetVisOption() constReturns current depth to which geometry is drawn.Definition TGeoManager.cxx:2157; TGeoManager::LockGeometrystatic void LockGeometry()Lock current geometry so that no other geometry can be imported.Definition TGeoManager.cxx:4040; TGeoManager::GetCurrentPointconst Double_t * GetCurrentPoint() constDefinition TGeoManager.h:501; TGeoManager::MakeBoxTGeoVolume * MakeBox(const char *name, TGeoMedium *medium, Double_t dx, Double_t dy, Double_t dz)Make in one step a volume pointing to a box shape with given medium.Definition TGeoManager.cxx:3169; TGeoManager::fNPNEIdInt_t fNPNEIdDefinition TGeoManager.h:141; TGeoManager::CheckShapevoid CheckShape(TGeoShape *shape, Int_t testNo, Int_t nsamples, Option_t *option)Test for shape navigation methods.Definition TGeoManager.cxx:3783; TGeoManager::GetUserPaintVolumeTGeoVolume * GetUserPaintVolume() constDefinition TGeoManager.h:216; TGeoManager::IsActivityEnabledBool_t IsActivityEnabled() constDefinition TGeoManager.h:409; TGeoManager::fgMaxLevelstatic Int_t fgMaxLevelVerbosity level for Info messages (no IO).Definition TGeoManager.h:52; TGeoManager::fNpdgInt_t fNpdgcurrent trackDefinition TGeoManager.h:77; TGeoManager::PrintOverlapsvoid PrintOverlaps() constPrints the current list of overlaps.Definition TGeoManager.cxx:3881; TGeoManager::GetNormalconst Double_t * GetNormal() constDefinition TGeoManager.h:506; TGeoManager::MakeTrd1TGeoVolume * MakeTrd1(const char *name, TGeoMedium *medium, Double_t dx1, Double_t dx2, Double_t dy, Double_t dz)Make in one step a volume pointing to a TGeoTrd1 shape with given medium.Definition TGeoManager.cxx:3293; TGeoManager::MakeSphereTGeoVolume * MakeSphere(const char *name, TGe",MatchSource.WIKI,doc/master/TGeoManager_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8h_source.html
https://root.cern/doc/master/TGeoMaterial_8cxx_source.html:55693,Availability,error,error,55693,"xtensionABC for user objects attached to TGeoVolume or TGeoNode.Definition TGeoExtension.h:17; TGeoExtension::Grabvirtual TGeoExtension * Grab()=0; TGeoExtension::Releasevirtual void Release() const =0; TGeoManagerThe manager class for any TGeo geometry.Definition TGeoManager.h:44; TGeoManager::GetDefaultUnitsstatic EDefaultUnits GetDefaultUnits()Definition TGeoManager.cxx:4314; TGeoManager::GetElementTableTGeoElementTable * GetElementTable()Returns material table. Creates it if not existing.Definition TGeoManager.cxx:3624; TGeoManager::SetDefaultUnitsstatic void SetDefaultUnits(EDefaultUnits new_value)Definition TGeoManager.cxx:4319; TGeoManager::AddMaterialInt_t AddMaterial(const TGeoMaterial *material)Add a material to the list. Returns index of the material in list.Definition TGeoManager.cxx:616; TGeoManager::EDefaultUnitsEDefaultUnitsDefinition TGeoManager.h:46; TGeoManager::kRootUnits@ kRootUnitsDefinition TGeoManager.h:46; TGeoManager::GetPropertyDouble_t GetProperty(const char *name, Bool_t *error=nullptr) constGet a user-defined property.Definition TGeoManager.cxx:656; TGeoManager::GetGDMLMatrixTGDMLMatrix * GetGDMLMatrix(const char *name) constGet GDML matrix with a given name;.Definition TGeoManager.cxx:2003; TGeoManager::GetListOfMaterialsTList * GetListOfMaterials() constDefinition TGeoManager.h:471; TGeoMaterialBase class describing materials.Definition TGeoMaterial.h:34; TGeoMaterial::GetConstPropertyDouble_t GetConstProperty(const char *property, Bool_t *error=nullptr) constDefinition TGeoMaterial.cxx:392; TGeoMaterial::SetUserExtensionvoid SetUserExtension(TGeoExtension *ext)Connect user-defined extension to the material.Definition TGeoMaterial.cxx:346; TGeoMaterial::GetCerenkovPropertiesvirtual TObject * GetCerenkovProperties() constDefinition TGeoMaterial.h:112; TGeoMaterial::fStateEGeoMaterialState fStateDefinition TGeoMaterial.h:48; TGeoMaterial::GetPointerNameconst char * GetPointerName() constProvide a pointer name containing uid.Definition TGe",MatchSource.WIKI,doc/master/TGeoMaterial_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoMaterial_8cxx_source.html
https://root.cern/doc/master/TGeoMaterial_8cxx_source.html:56173,Availability,error,error,56173,"reates it if not existing.Definition TGeoManager.cxx:3624; TGeoManager::SetDefaultUnitsstatic void SetDefaultUnits(EDefaultUnits new_value)Definition TGeoManager.cxx:4319; TGeoManager::AddMaterialInt_t AddMaterial(const TGeoMaterial *material)Add a material to the list. Returns index of the material in list.Definition TGeoManager.cxx:616; TGeoManager::EDefaultUnitsEDefaultUnitsDefinition TGeoManager.h:46; TGeoManager::kRootUnits@ kRootUnitsDefinition TGeoManager.h:46; TGeoManager::GetPropertyDouble_t GetProperty(const char *name, Bool_t *error=nullptr) constGet a user-defined property.Definition TGeoManager.cxx:656; TGeoManager::GetGDMLMatrixTGDMLMatrix * GetGDMLMatrix(const char *name) constGet GDML matrix with a given name;.Definition TGeoManager.cxx:2003; TGeoManager::GetListOfMaterialsTList * GetListOfMaterials() constDefinition TGeoManager.h:471; TGeoMaterialBase class describing materials.Definition TGeoMaterial.h:34; TGeoMaterial::GetConstPropertyDouble_t GetConstProperty(const char *property, Bool_t *error=nullptr) constDefinition TGeoMaterial.cxx:392; TGeoMaterial::SetUserExtensionvoid SetUserExtension(TGeoExtension *ext)Connect user-defined extension to the material.Definition TGeoMaterial.cxx:346; TGeoMaterial::GetCerenkovPropertiesvirtual TObject * GetCerenkovProperties() constDefinition TGeoMaterial.h:112; TGeoMaterial::fStateEGeoMaterialState fStateDefinition TGeoMaterial.h:48; TGeoMaterial::GetPointerNameconst char * GetPointerName() constProvide a pointer name containing uid.Definition TGeoMaterial.cxx:485; TGeoMaterial::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave a primitive as a C++ statement(s) on output stream ""out"".Definition TGeoMaterial.cxx:594; TGeoMaterial::ScreenFactorstatic Double_t ScreenFactor(Double_t z)static function Compute screening factor for pair production and Bremsstrahlung REFERENCE : EGS MANUA...Definition TGeoMaterial.cxx:1343; TGeoMaterial::GetConstPropertyRefconst char * GetConstProp",MatchSource.WIKI,doc/master/TGeoMaterial_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoMaterial_8cxx_source.html
https://root.cern/doc/master/TGeoMaterial_8cxx_source.html:67734,Availability,error,error,67734,"dAtAndExpandvirtual void AddAtAndExpand(TObject *obj, Int_t idx)Add object at position idx.Definition TObjArray.cxx:235; TObjArray::AtTObject * At(Int_t idx) const overrideDefinition TObjArray.h:164; TObjArray::Addvoid Add(TObject *obj) overrideDefinition TObjArray.h:68; TObject::IsEqualvirtual Bool_t IsEqual(const TObject *obj) constDefault equal comparison (objects are equal if they have the same address in memory).Definition TObject.cxx:570; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::GetUniqueIDvirtual UInt_t GetUniqueID() constReturn the unique object id.Definition TObject.cxx:462; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TSeqCollection::IndexOfvirtual Int_t IndexOf(const TObject *obj) constReturn index of object in collection.Definition TSeqCollection.cxx:30; TStringBasic string class.Definition TString.h:139; TString::StripTSubString Strip(EStripType s=kTrailing, char c=' ') constReturn a substring of self stripped at beginning and/or end.Definition TString.cxx:1163; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TString::Formvoid Form(const char *fmt,...)Formats a string using a printf style format descriptor.Definition TString.cxx:2356; bool; double; int; TGeant4Unit::fine_structure_conststatic constexpr double fine_structure_constDefinition TGeant4PhysicalConstants.h:90; TGeant4Unit::cm2sta",MatchSource.WIKI,doc/master/TGeoMaterial_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoMaterial_8cxx_source.html
https://root.cern/doc/master/TGeoMaterial_8cxx_source.html:67870,Availability,error,error,67870,"tTObject * At(Int_t idx) const overrideDefinition TObjArray.h:164; TObjArray::Addvoid Add(TObject *obj) overrideDefinition TObjArray.h:68; TObject::IsEqualvirtual Bool_t IsEqual(const TObject *obj) constDefault equal comparison (objects are equal if they have the same address in memory).Definition TObject.cxx:570; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::GetUniqueIDvirtual UInt_t GetUniqueID() constReturn the unique object id.Definition TObject.cxx:462; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TSeqCollection::IndexOfvirtual Int_t IndexOf(const TObject *obj) constReturn index of object in collection.Definition TSeqCollection.cxx:30; TStringBasic string class.Definition TString.h:139; TString::StripTSubString Strip(EStripType s=kTrailing, char c=' ') constReturn a substring of self stripped at beginning and/or end.Definition TString.cxx:1163; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TString::Formvoid Form(const char *fmt,...)Formats a string using a printf style format descriptor.Definition TString.cxx:2356; bool; double; int; TGeant4Unit::fine_structure_conststatic constexpr double fine_structure_constDefinition TGeant4PhysicalConstants.h:90; TGeant4Unit::cm2static constexpr double cm2Definition TGeant4SystemOfUnits.h:113; TGeant4Unit::Avogadrostatic constexpr double AvogadroDefinition TGeant",MatchSource.WIKI,doc/master/TGeoMaterial_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoMaterial_8cxx_source.html
https://root.cern/doc/master/TGeoMaterial_8cxx_source.html:10578,Deployability,release,released,10578," gm.fTemperature;; 307 fPressure = gm.fPressure;; 308 fState = gm.fState;; 309 fShader = gm.fShader;; 310 fCerenkov = gm.fCerenkov;; 311 fElement = gm.fElement;; 312 fUserExtension = gm.fUserExtension->Grab();; 313 fFWExtension = gm.fFWExtension->Grab();; 314 fProperties.SetOwner();; 315 TIter next(&fProperties);; 316 TNamed *property;; 317 while ((property = (TNamed *)next())); 318 fProperties.Add(new TNamed(*property));; 319 }; 320 return *this;; 321}; 322 ; 323////////////////////////////////////////////////////////////////////////////////; 324/// Destructor; 325 ; 326TGeoMaterial::~TGeoMaterial(); 327{; 328 if (fUserExtension) {; 329 fUserExtension->Release();; 330 fUserExtension = nullptr;; 331 }; 332 if (fFWExtension) {; 333 fFWExtension->Release();; 334 fFWExtension = nullptr;; 335 }; 336}; 337 ; 338////////////////////////////////////////////////////////////////////////////////; 339/// Connect user-defined extension to the material. The material ""grabs"" a copy, so; 340/// the original object can be released by the producer. Release the previously; 341/// connected extension if any.; 342///; 343/// NOTE: This interface is intended for user extensions and is guaranteed not; 344/// to be used by TGeo; 345 ; 346void TGeoMaterial::SetUserExtension(TGeoExtension *ext); 347{; 348 if (fUserExtension); 349 fUserExtension->Release();; 350 fUserExtension = nullptr;; 351 if (ext); 352 fUserExtension = ext->Grab();; 353}; 354 ; 355//_____________________________________________________________________________; 356const char *TGeoMaterial::GetPropertyRef(const char *property) const; 357{; 358 // Find reference for a given property; 359 TNamed *prop = (TNamed *)fProperties.FindObject(property);; 360 return (prop) ? prop->GetTitle() : nullptr;; 361}; 362 ; 363//_____________________________________________________________________________; 364TGDMLMatrix *TGeoMaterial::GetProperty(const char *property) const; 365{; 366 // Find reference for a given property; 367 TNamed *prop ",MatchSource.WIKI,doc/master/TGeoMaterial_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoMaterial_8cxx_source.html
https://root.cern/doc/master/TGeoMaterial_8cxx_source.html:14370,Deployability,release,released,14370,"____; 418bool TGeoMaterial::AddProperty(const char *property, const char *ref); 419{; 420 fProperties.SetOwner();; 421 if (GetPropertyRef(property)) {; 422 Error(""AddProperty"", ""Property %s already added to material %s"", property, GetName());; 423 return false;; 424 }; 425 fProperties.Add(new TNamed(property, ref));; 426 return true;; 427}; 428 ; 429//_____________________________________________________________________________; 430bool TGeoMaterial::AddConstProperty(const char *property, const char *ref); 431{; 432 fConstProperties.SetOwner();; 433 if (GetConstPropertyRef(property)) {; 434 Error(""AddConstProperty"", ""Constant property %s already added to material %s"", property, GetName());; 435 return false;; 436 }; 437 fConstProperties.Add(new TNamed(property, ref));; 438 return true;; 439}; 440 ; 441////////////////////////////////////////////////////////////////////////////////; 442/// Connect framework defined extension to the material. The material ""grabs"" a copy,; 443/// so the original object can be released by the producer. Release the previously; 444/// connected extension if any.; 445///; 446/// NOTE: This interface is intended for the use by TGeo and the users should; 447/// NOT connect extensions using this method; 448 ; 449void TGeoMaterial::SetFWExtension(TGeoExtension *ext); 450{; 451 if (fFWExtension); 452 fFWExtension->Release();; 453 fFWExtension = nullptr;; 454 if (ext); 455 fFWExtension = ext->Grab();; 456}; 457 ; 458////////////////////////////////////////////////////////////////////////////////; 459/// Get a copy of the user extension pointer. The user must call Release() on; 460/// the copy pointer once this pointer is not needed anymore (equivalent to; 461/// delete() after calling new()); 462 ; 463TGeoExtension *TGeoMaterial::GrabUserExtension() const; 464{; 465 if (fUserExtension); 466 return fUserExtension->Grab();; 467 return nullptr;; 468}; 469 ; 470////////////////////////////////////////////////////////////////////////////////; 471/// G",MatchSource.WIKI,doc/master/TGeoMaterial_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoMaterial_8cxx_source.html
https://root.cern/doc/master/TGeoMaterial_8cxx_source.html:69581,Energy Efficiency,power,power,69581,"string class.Definition TString.h:139; TString::StripTSubString Strip(EStripType s=kTrailing, char c=' ') constReturn a substring of self stripped at beginning and/or end.Definition TString.cxx:1163; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TString::Formvoid Form(const char *fmt,...)Formats a string using a printf style format descriptor.Definition TString.cxx:2356; bool; double; int; TGeant4Unit::fine_structure_conststatic constexpr double fine_structure_constDefinition TGeant4PhysicalConstants.h:90; TGeant4Unit::cm2static constexpr double cm2Definition TGeant4SystemOfUnits.h:113; TGeant4Unit::Avogadrostatic constexpr double AvogadroDefinition TGeant4PhysicalConstants.h:43; TGeant4Unit::cmstatic constexpr double cmDefinition TGeant4SystemOfUnits.h:112; TGeoUnit::amustatic constexpr double amuDefinition TGeoPhysicalConstants.h:77; TGeoUnit::cmstatic constexpr double cmDefinition TGeoSystemOfUnits.h:116; TGeoUnit::fine_structure_conststatic constexpr double fine_structure_constDefinition TGeoPhysicalConstants.h:90; TGeoUnit::cm2static constexpr double cm2Definition TGeoSystemOfUnits.h:117; TGeoUnit::Avogadrostatic constexpr double AvogadroDefinition TGeoPhysicalConstants.h:43; TGeoUnit::gstatic constexpr double gDefinition TGeoSystemOfUnits.h:207; TMath::ExpDouble_t Exp(Double_t x)Returns the base-e exponential function of x, which is e raised to the power x.Definition TMath.h:709; TMath::LogDouble_t Log(Double_t x)Returns the natural logarithm of x.Definition TMath.h:756; TMath::PowerLongDouble_t Power(LongDouble_t x, LongDouble_t y)Returns x raised to the power y.Definition TMath.h:721; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123. geomgeomsrcTGeoMaterial.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:14 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TGeoMaterial_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoMaterial_8cxx_source.html
https://root.cern/doc/master/TGeoMaterial_8cxx_source.html:69792,Energy Efficiency,power,power,69792,"string class.Definition TString.h:139; TString::StripTSubString Strip(EStripType s=kTrailing, char c=' ') constReturn a substring of self stripped at beginning and/or end.Definition TString.cxx:1163; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TString::Formvoid Form(const char *fmt,...)Formats a string using a printf style format descriptor.Definition TString.cxx:2356; bool; double; int; TGeant4Unit::fine_structure_conststatic constexpr double fine_structure_constDefinition TGeant4PhysicalConstants.h:90; TGeant4Unit::cm2static constexpr double cm2Definition TGeant4SystemOfUnits.h:113; TGeant4Unit::Avogadrostatic constexpr double AvogadroDefinition TGeant4PhysicalConstants.h:43; TGeant4Unit::cmstatic constexpr double cmDefinition TGeant4SystemOfUnits.h:112; TGeoUnit::amustatic constexpr double amuDefinition TGeoPhysicalConstants.h:77; TGeoUnit::cmstatic constexpr double cmDefinition TGeoSystemOfUnits.h:116; TGeoUnit::fine_structure_conststatic constexpr double fine_structure_constDefinition TGeoPhysicalConstants.h:90; TGeoUnit::cm2static constexpr double cm2Definition TGeoSystemOfUnits.h:117; TGeoUnit::Avogadrostatic constexpr double AvogadroDefinition TGeoPhysicalConstants.h:43; TGeoUnit::gstatic constexpr double gDefinition TGeoSystemOfUnits.h:207; TMath::ExpDouble_t Exp(Double_t x)Returns the base-e exponential function of x, which is e raised to the power x.Definition TMath.h:709; TMath::LogDouble_t Log(Double_t x)Returns the natural logarithm of x.Definition TMath.h:756; TMath::PowerLongDouble_t Power(LongDouble_t x, LongDouble_t y)Returns x raised to the power y.Definition TMath.h:721; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123. geomgeomsrcTGeoMaterial.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:14 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TGeoMaterial_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoMaterial_8cxx_source.html
https://root.cern/doc/master/TGeoMaterial_8cxx_source.html:10690,Integrability,interface,interface,10690,"d(new TNamed(*property));; 319 }; 320 return *this;; 321}; 322 ; 323////////////////////////////////////////////////////////////////////////////////; 324/// Destructor; 325 ; 326TGeoMaterial::~TGeoMaterial(); 327{; 328 if (fUserExtension) {; 329 fUserExtension->Release();; 330 fUserExtension = nullptr;; 331 }; 332 if (fFWExtension) {; 333 fFWExtension->Release();; 334 fFWExtension = nullptr;; 335 }; 336}; 337 ; 338////////////////////////////////////////////////////////////////////////////////; 339/// Connect user-defined extension to the material. The material ""grabs"" a copy, so; 340/// the original object can be released by the producer. Release the previously; 341/// connected extension if any.; 342///; 343/// NOTE: This interface is intended for user extensions and is guaranteed not; 344/// to be used by TGeo; 345 ; 346void TGeoMaterial::SetUserExtension(TGeoExtension *ext); 347{; 348 if (fUserExtension); 349 fUserExtension->Release();; 350 fUserExtension = nullptr;; 351 if (ext); 352 fUserExtension = ext->Grab();; 353}; 354 ; 355//_____________________________________________________________________________; 356const char *TGeoMaterial::GetPropertyRef(const char *property) const; 357{; 358 // Find reference for a given property; 359 TNamed *prop = (TNamed *)fProperties.FindObject(property);; 360 return (prop) ? prop->GetTitle() : nullptr;; 361}; 362 ; 363//_____________________________________________________________________________; 364TGDMLMatrix *TGeoMaterial::GetProperty(const char *property) const; 365{; 366 // Find reference for a given property; 367 TNamed *prop = (TNamed *)fProperties.FindObject(property);; 368 if (!prop); 369 return nullptr;; 370 return gGeoManager->GetGDMLMatrix(prop->GetTitle());; 371}; 372 ; 373//_____________________________________________________________________________; 374TGDMLMatrix *TGeoMaterial::GetProperty(Int_t i) const; 375{; 376 // Find reference for a given property; 377 TNamed *prop = (TNamed *)fProperties.At(i);; 378 i",MatchSource.WIKI,doc/master/TGeoMaterial_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoMaterial_8cxx_source.html
https://root.cern/doc/master/TGeoMaterial_8cxx_source.html:14482,Integrability,interface,interface,14482," 429//_____________________________________________________________________________; 430bool TGeoMaterial::AddConstProperty(const char *property, const char *ref); 431{; 432 fConstProperties.SetOwner();; 433 if (GetConstPropertyRef(property)) {; 434 Error(""AddConstProperty"", ""Constant property %s already added to material %s"", property, GetName());; 435 return false;; 436 }; 437 fConstProperties.Add(new TNamed(property, ref));; 438 return true;; 439}; 440 ; 441////////////////////////////////////////////////////////////////////////////////; 442/// Connect framework defined extension to the material. The material ""grabs"" a copy,; 443/// so the original object can be released by the producer. Release the previously; 444/// connected extension if any.; 445///; 446/// NOTE: This interface is intended for the use by TGeo and the users should; 447/// NOT connect extensions using this method; 448 ; 449void TGeoMaterial::SetFWExtension(TGeoExtension *ext); 450{; 451 if (fFWExtension); 452 fFWExtension->Release();; 453 fFWExtension = nullptr;; 454 if (ext); 455 fFWExtension = ext->Grab();; 456}; 457 ; 458////////////////////////////////////////////////////////////////////////////////; 459/// Get a copy of the user extension pointer. The user must call Release() on; 460/// the copy pointer once this pointer is not needed anymore (equivalent to; 461/// delete() after calling new()); 462 ; 463TGeoExtension *TGeoMaterial::GrabUserExtension() const; 464{; 465 if (fUserExtension); 466 return fUserExtension->Grab();; 467 return nullptr;; 468}; 469 ; 470////////////////////////////////////////////////////////////////////////////////; 471/// Get a copy of the framework extension pointer. The user must call Release() on; 472/// the copy pointer once this pointer is not needed anymore (equivalent to; 473/// delete() after calling new()); 474 ; 475TGeoExtension *TGeoMaterial::GrabFWExtension() const; 476{; 477 if (fFWExtension); 478 return fFWExtension->Grab();; 479 return nullptr;; 480}",MatchSource.WIKI,doc/master/TGeoMaterial_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoMaterial_8cxx_source.html
https://root.cern/doc/master/TGeoMaterial_8cxx_source.html:17014,Integrability,rout,routine,17014,"88 name.Form(""pMat%d"", GetUniqueID());; 489 return name.Data();; 490}; 491 ; 492////////////////////////////////////////////////////////////////////////////////; 493/// Set radiation/absorption lengths. If the values are negative, their absolute value; 494/// is taken, otherwise radlen is recomputed using G3 formula.; 495 ; 496void TGeoMaterial::SetRadLen(Double_t radlen, Double_t intlen); 497{; 498 fRadLen = TMath::Abs(radlen);; 499 fIntLen = TMath::Abs(intlen);; 500 // Check for vacuum; 501 if (fA < 0.9 || fZ < 0.9) {; 502 if (radlen < -1e5 || intlen < -1e-5) {; 503 Error(""SetRadLen"", ""Material %s: user values taken for vacuum: radlen=%g or intlen=%g - too small"", GetName(),; 504 fRadLen, fIntLen);; 505 return;; 506 }; 507 // Ignore positive values and take big numbers; 508 if (radlen >= 0); 509 fRadLen = 1.E30;; 510 if (intlen >= 0); 511 fIntLen = 1.E30;; 512 return;; 513 }; 514 TGeoManager::EDefaultUnits typ = TGeoManager::GetDefaultUnits();; 515 // compute radlen systematically with G3 formula for a valid material; 516 if (radlen >= 0) {; 517 // taken grom Geant3 routine GSMATE; 518 constexpr Double_t alr2av = 1.39621E-03;; 519 constexpr Double_t al183 = 5.20948;; 520 fRadLen = fA / (alr2av * fDensity * fZ * (fZ + TGeoMaterial::ScreenFactor(fZ)) *; 521 (al183 - TMath::Log(fZ) / 3 - TGeoMaterial::Coulomb(fZ)));; 522 // fRadLen is in TGeo units. Apply conversion factor in requested length-units; 523 fRadLen *= (typ == TGeoManager::kRootUnits) ? TGeoUnit::cm : TGeant4Unit::cm;; 524 }; 525 // Compute interaction length using the same formula as in GEANT4; 526 if (intlen >= 0) {; 527 constexpr Double_t lambda0 = 35. * TGeoUnit::g / TGeoUnit::cm2; // [g/cm^2]; 528 Double_t nilinv = 0.0;; 529 TGeoElement *elem = GetElement();; 530 if (!elem) {; 531 Fatal(""SetRadLen"", ""Element not found for material %s"", GetName());; 532 return;; 533 }; 534 Double_t nbAtomsPerVolume = TGeoUnit::Avogadro * fDensity / elem->A();; 535 nilinv += nbAtomsPerVolume * TMath::Power(elem->Neff()",MatchSource.WIKI,doc/master/TGeoMaterial_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoMaterial_8cxx_source.html
https://root.cern/doc/master/TGeoMaterial_8cxx_source.html:22265,Integrability,interface,interface,22265,"color related to this material.; 613 ; 614Int_t TGeoMaterial::GetDefaultColor() const; 615{; 616 Int_t id = 1 + gGeoManager->GetListOfMaterials()->IndexOf(this);; 617 return (2 + id % 6);; 618}; 619 ; 620////////////////////////////////////////////////////////////////////////////////; 621/// Get a pointer to the element this material is made of.; 622/// This second call is to avoid warnings to not call a virtual; 623/// method from the constructor; 624 ; 625TGeoElement *TGeoMaterial::GetElement() const; 626{; 627 if (fElement); 628 return fElement;; 629 TGeoElementTable *table = gGeoManager->GetElementTable();; 630 return table->GetElement(Int_t(fZ));; 631}; 632 ; 633////////////////////////////////////////////////////////////////////////////////; 634/// Get a pointer to the element this material is made of.; 635 ; 636TGeoElement *TGeoMaterial::GetElement(Int_t) const; 637{; 638 if (fElement); 639 return fElement;; 640 TGeoElementTable *table = gGeoManager->GetElementTable();; 641 return table->GetElement(Int_t(fZ));; 642}; 643 ; 644////////////////////////////////////////////////////////////////////////////////; 645/// Single interface to get element properties.; 646 ; 647void TGeoMaterial::GetElementProp(Double_t &a, Double_t &z, Double_t &w, Int_t); 648{; 649 a = fA;; 650 z = fZ;; 651 w = 1.;; 652}; 653 ; 654////////////////////////////////////////////////////////////////////////////////; 655/// Retrieve material index in the list of materials; 656 ; 657Int_t TGeoMaterial::GetIndex(); 658{; 659 if (fIndex >= 0); 660 return fIndex;; 661 TList *matlist = gGeoManager->GetListOfMaterials();; 662 fIndex = matlist->IndexOf(this);; 663 return fIndex;; 664}; 665 ; 666////////////////////////////////////////////////////////////////////////////////; 667/// Create the material representing the decay product of this material at a; 668/// given time. The precision represent the minimum cumulative branching ratio for; 669/// which decay products are still taken into account.; ",MatchSource.WIKI,doc/master/TGeoMaterial_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoMaterial_8cxx_source.html
https://root.cern/doc/master/TGeoMaterial_8cxx_source.html:57838,Integrability,interface,interface,57838,"a primitive as a C++ statement(s) on output stream ""out"".Definition TGeoMaterial.cxx:594; TGeoMaterial::ScreenFactorstatic Double_t ScreenFactor(Double_t z)static function Compute screening factor for pair production and Bremsstrahlung REFERENCE : EGS MANUA...Definition TGeoMaterial.cxx:1343; TGeoMaterial::GetConstPropertyRefconst char * GetConstPropertyRef(const char *property) constDefinition TGeoMaterial.cxx:384; TGeoMaterial::IsMixturevirtual Bool_t IsMixture() constDefinition TGeoMaterial.h:124; TGeoMaterial::fPressureDouble_t fPressureDefinition TGeoMaterial.h:47; TGeoMaterial::SetFWExtensionvoid SetFWExtension(TGeoExtension *ext)Connect framework defined extension to the material.Definition TGeoMaterial.cxx:449; TGeoMaterial::AddConstPropertybool AddConstProperty(const char *property, const char *ref)Definition TGeoMaterial.cxx:430; TGeoMaterial::fTemperatureDouble_t fTemperatureDefinition TGeoMaterial.h:46; TGeoMaterial::GetElementPropvirtual void GetElementProp(Double_t &a, Double_t &z, Double_t &w, Int_t i=0)Single interface to get element properties.Definition TGeoMaterial.cxx:647; TGeoMaterial::DecayMaterialvirtual TGeoMaterial * DecayMaterial(Double_t time, Double_t precision=0.001)Create the material representing the decay product of this material at a given time.Definition TGeoMaterial.cxx:671; TGeoMaterial::fPropertiesTList fPropertiesDefinition TGeoMaterial.h:52; TGeoMaterial::AddPropertybool AddProperty(const char *property, const char *ref)Definition TGeoMaterial.cxx:418; TGeoMaterial::fZDouble_t fZDefinition TGeoMaterial.h:42; TGeoMaterial::SetRadLenvoid SetRadLen(Double_t radlen, Double_t intlen=0.)Set radiation/absorption lengths.Definition TGeoMaterial.cxx:496; TGeoMaterial::GetElementTGeoElement * GetElement() constGet a pointer to the element this material is made of.Definition TGeoMaterial.cxx:625; TGeoMaterial::fIndexInt_t fIndexDefinition TGeoMaterial.h:40; TGeoMaterial::kMatSavePrimitive@ kMatSavePrimitiveDefinition TGeoMaterial.h:36; TG",MatchSource.WIKI,doc/master/TGeoMaterial_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoMaterial_8cxx_source.html
https://root.cern/doc/master/TGeoMaterial_8cxx_source.html:67482,Integrability,message,message,67482," constDefinition TObjArray.h:58; TObjArray::IndexOfInt_t IndexOf(const TObject *obj) const overrideDefinition TObjArray.cxx:605; TObjArray::AddAtvoid AddAt(TObject *obj, Int_t idx) overrideAdd object at position ids.Definition TObjArray.cxx:254; TObjArray::AddAtAndExpandvirtual void AddAtAndExpand(TObject *obj, Int_t idx)Add object at position idx.Definition TObjArray.cxx:235; TObjArray::AtTObject * At(Int_t idx) const overrideDefinition TObjArray.h:164; TObjArray::Addvoid Add(TObject *obj) overrideDefinition TObjArray.h:68; TObject::IsEqualvirtual Bool_t IsEqual(const TObject *obj) constDefault equal comparison (objects are equal if they have the same address in memory).Definition TObject.cxx:570; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::GetUniqueIDvirtual UInt_t GetUniqueID() constReturn the unique object id.Definition TObject.cxx:462; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TSeqCollection::IndexOfvirtual Int_t IndexOf(const TObject *obj) constReturn index of object in collection.Definition TSeqCollection.cxx:30; TStringBasic string class.Definition TString.h:139; TString::StripTSubString Strip(EStripType s=kTrailing, char c=' ') constReturn a substring of self stripped at beginning and/or end.Definition TString.cxx:1163; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TString::Formvoid Form(con",MatchSource.WIKI,doc/master/TGeoMaterial_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoMaterial_8cxx_source.html
https://root.cern/doc/master/TGeoMaterial_8cxx_source.html:67740,Integrability,message,message,67740,"dAtAndExpandvirtual void AddAtAndExpand(TObject *obj, Int_t idx)Add object at position idx.Definition TObjArray.cxx:235; TObjArray::AtTObject * At(Int_t idx) const overrideDefinition TObjArray.h:164; TObjArray::Addvoid Add(TObject *obj) overrideDefinition TObjArray.h:68; TObject::IsEqualvirtual Bool_t IsEqual(const TObject *obj) constDefault equal comparison (objects are equal if they have the same address in memory).Definition TObject.cxx:570; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::GetUniqueIDvirtual UInt_t GetUniqueID() constReturn the unique object id.Definition TObject.cxx:462; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TSeqCollection::IndexOfvirtual Int_t IndexOf(const TObject *obj) constReturn index of object in collection.Definition TSeqCollection.cxx:30; TStringBasic string class.Definition TString.h:139; TString::StripTSubString Strip(EStripType s=kTrailing, char c=' ') constReturn a substring of self stripped at beginning and/or end.Definition TString.cxx:1163; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TString::Formvoid Form(const char *fmt,...)Formats a string using a printf style format descriptor.Definition TString.cxx:2356; bool; double; int; TGeant4Unit::fine_structure_conststatic constexpr double fine_structure_constDefinition TGeant4PhysicalConstants.h:90; TGeant4Unit::cm2sta",MatchSource.WIKI,doc/master/TGeoMaterial_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoMaterial_8cxx_source.html
https://root.cern/doc/master/TGeoMaterial_8cxx_source.html:67876,Integrability,message,message,67876,"tTObject * At(Int_t idx) const overrideDefinition TObjArray.h:164; TObjArray::Addvoid Add(TObject *obj) overrideDefinition TObjArray.h:68; TObject::IsEqualvirtual Bool_t IsEqual(const TObject *obj) constDefault equal comparison (objects are equal if they have the same address in memory).Definition TObject.cxx:570; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::GetUniqueIDvirtual UInt_t GetUniqueID() constReturn the unique object id.Definition TObject.cxx:462; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TSeqCollection::IndexOfvirtual Int_t IndexOf(const TObject *obj) constReturn index of object in collection.Definition TSeqCollection.cxx:30; TStringBasic string class.Definition TString.h:139; TString::StripTSubString Strip(EStripType s=kTrailing, char c=' ') constReturn a substring of self stripped at beginning and/or end.Definition TString.cxx:1163; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TString::Formvoid Form(const char *fmt,...)Formats a string using a printf style format descriptor.Definition TString.cxx:2356; bool; double; int; TGeant4Unit::fine_structure_conststatic constexpr double fine_structure_constDefinition TGeant4PhysicalConstants.h:90; TGeant4Unit::cm2static constexpr double cm2Definition TGeant4SystemOfUnits.h:113; TGeant4Unit::Avogadrostatic constexpr double AvogadroDefinition TGeant",MatchSource.WIKI,doc/master/TGeoMaterial_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoMaterial_8cxx_source.html
https://root.cern/doc/master/TGeoMaterial_8cxx_source.html:21499,Safety,avoid,avoid,21499,"< "" absl = "" << fIntLen << "";"" << std::endl;; 605 ; 606 out << "" auto "" << name << "" = new TGeoMaterial(\"""" << GetName() << ""\"", a, z, density, radl, absl);"" << std::endl;; 607 out << "" "" << name << ""->SetIndex("" << GetIndex() << "");"" << std::endl;; 608 SetBit(TGeoMaterial::kMatSavePrimitive);; 609}; 610 ; 611////////////////////////////////////////////////////////////////////////////////; 612/// Get some default color related to this material.; 613 ; 614Int_t TGeoMaterial::GetDefaultColor() const; 615{; 616 Int_t id = 1 + gGeoManager->GetListOfMaterials()->IndexOf(this);; 617 return (2 + id % 6);; 618}; 619 ; 620////////////////////////////////////////////////////////////////////////////////; 621/// Get a pointer to the element this material is made of.; 622/// This second call is to avoid warnings to not call a virtual; 623/// method from the constructor; 624 ; 625TGeoElement *TGeoMaterial::GetElement() const; 626{; 627 if (fElement); 628 return fElement;; 629 TGeoElementTable *table = gGeoManager->GetElementTable();; 630 return table->GetElement(Int_t(fZ));; 631}; 632 ; 633////////////////////////////////////////////////////////////////////////////////; 634/// Get a pointer to the element this material is made of.; 635 ; 636TGeoElement *TGeoMaterial::GetElement(Int_t) const; 637{; 638 if (fElement); 639 return fElement;; 640 TGeoElementTable *table = gGeoManager->GetElementTable();; 641 return table->GetElement(Int_t(fZ));; 642}; 643 ; 644////////////////////////////////////////////////////////////////////////////////; 645/// Single interface to get element properties.; 646 ; 647void TGeoMaterial::GetElementProp(Double_t &a, Double_t &z, Double_t &w, Int_t); 648{; 649 a = fA;; 650 z = fZ;; 651 w = 1.;; 652}; 653 ; 654////////////////////////////////////////////////////////////////////////////////; 655/// Retrieve material index in the list of materials; 656 ; 657Int_t TGeoMaterial::GetIndex(); 658{; 659 if (fIndex >= 0); 660 return fIndex;; 661 TList *matlist = g",MatchSource.WIKI,doc/master/TGeoMaterial_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoMaterial_8cxx_source.html
https://root.cern/doc/master/TGeoMaterial_8cxx_source.html:69667,Testability,log,logarithm,69667,"string class.Definition TString.h:139; TString::StripTSubString Strip(EStripType s=kTrailing, char c=' ') constReturn a substring of self stripped at beginning and/or end.Definition TString.cxx:1163; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TString::Formvoid Form(const char *fmt,...)Formats a string using a printf style format descriptor.Definition TString.cxx:2356; bool; double; int; TGeant4Unit::fine_structure_conststatic constexpr double fine_structure_constDefinition TGeant4PhysicalConstants.h:90; TGeant4Unit::cm2static constexpr double cm2Definition TGeant4SystemOfUnits.h:113; TGeant4Unit::Avogadrostatic constexpr double AvogadroDefinition TGeant4PhysicalConstants.h:43; TGeant4Unit::cmstatic constexpr double cmDefinition TGeant4SystemOfUnits.h:112; TGeoUnit::amustatic constexpr double amuDefinition TGeoPhysicalConstants.h:77; TGeoUnit::cmstatic constexpr double cmDefinition TGeoSystemOfUnits.h:116; TGeoUnit::fine_structure_conststatic constexpr double fine_structure_constDefinition TGeoPhysicalConstants.h:90; TGeoUnit::cm2static constexpr double cm2Definition TGeoSystemOfUnits.h:117; TGeoUnit::Avogadrostatic constexpr double AvogadroDefinition TGeoPhysicalConstants.h:43; TGeoUnit::gstatic constexpr double gDefinition TGeoSystemOfUnits.h:207; TMath::ExpDouble_t Exp(Double_t x)Returns the base-e exponential function of x, which is e raised to the power x.Definition TMath.h:709; TMath::LogDouble_t Log(Double_t x)Returns the natural logarithm of x.Definition TMath.h:756; TMath::PowerLongDouble_t Power(LongDouble_t x, LongDouble_t y)Returns x raised to the power y.Definition TMath.h:721; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123. geomgeomsrcTGeoMaterial.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:14 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TGeoMaterial_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoMaterial_8cxx_source.html
https://root.cern/doc/master/TGeoMaterial_8h.html:286,Integrability,depend,dependency,286,". ROOT: geom/geom/inc/TGeoMaterial.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Variables ; TGeoMaterial.h File Reference. #include <TNamed.h>; #include <TAttFill.h>; #include <TList.h>; #include ""TGeoElement.h"". Include dependency graph for TGeoMaterial.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  TGeoMaterial;  Base class describing materials. More...;  ; class  TGeoMixture;  Mixtures of elements. More...;  . Variables; static const Double_t STP_pressure = 6.32420e+8;  ; static const Double_t STP_temperature = 273.15;  . Variable Documentation. ◆ STP_pressure. const Double_t STP_pressure = 6.32420e+8. static . Definition at line 32 of file TGeoMaterial.h. ◆ STP_temperature. const Double_t STP_temperature = 273.15. static . Definition at line 31 of file TGeoMaterial.h. geomgeomincTGeoMaterial.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:15 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TGeoMaterial_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoMaterial_8h.html
https://root.cern/doc/master/TGeoMaterial_8h_source.html:3665,Availability,error,error,3665,"ial(const char *name, TGeoElement *elem, Double_t rho);; 69 ; 70 // destructor; 71 ~TGeoMaterial() override;; 72 // methods; 73 static Double_t Coulomb(Double_t z);; 74 // radioactive mixture evolution; 75 virtual TGeoMaterial *DecayMaterial(Double_t time, Double_t precision = 0.001);; 76 virtual void FillMaterialEvolution(TObjArray *population, Double_t precision = 0.001);; 77 // getters & setters; 78 bool AddProperty(const char *property, const char *ref);; 79 bool AddConstProperty(const char *property, const char *ref);; 80 Int_t GetNproperties() const { return fProperties.GetSize(); }; 81 Int_t GetNconstProperties() const { return fConstProperties.GetSize(); }; 82 const char *GetPropertyRef(const char *property) const;; 83 const char *GetPropertyRef(Int_t i) const; 84 {; 85 return (fProperties.At(i) ? fProperties.At(i)->GetTitle() : nullptr);; 86 }; 87 Double_t GetConstProperty(const char *property, Bool_t *error = nullptr) const;; 88 Double_t GetConstProperty(Int_t i, Bool_t *error = nullptr) const;; 89 const char *GetConstPropertyRef(const char *property) const;; 90 const char *GetConstPropertyRef(Int_t i) const; 91 {; 92 return (fConstProperties.At(i) ? fConstProperties.At(i)->GetTitle() : nullptr);; 93 }; 94 TList const &GetProperties() const { return fProperties; }; 95 TList const &GetConstProperties() const { return fConstProperties; }; 96 TGDMLMatrix *GetProperty(const char *name) const;; 97 TGDMLMatrix *GetProperty(Int_t i) const;; 98 virtual Int_t GetByteCount() const { return sizeof(*this); }; 99 virtual Double_t GetA() const { return fA; }; 100 virtual Double_t GetZ() const { return fZ; }; 101 virtual Int_t GetDefaultColor() const;; 102 virtual Double_t GetDensity() const { return fDensity; }; 103 virtual Int_t GetNelements() const { return 1; }; 104 TGeoElement *GetElement() const;; 105 virtual TGeoElement *GetElement(Int_t i) const;; 106 virtual void GetElementProp(Double_t &a, Double_t &z, Double_t &w, Int_t i = 0);; 107 TGeoElement *GetBaseElement",MatchSource.WIKI,doc/master/TGeoMaterial_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoMaterial_8h_source.html
https://root.cern/doc/master/TGeoMaterial_8h_source.html:3736,Availability,error,error,3736,"ial(const char *name, TGeoElement *elem, Double_t rho);; 69 ; 70 // destructor; 71 ~TGeoMaterial() override;; 72 // methods; 73 static Double_t Coulomb(Double_t z);; 74 // radioactive mixture evolution; 75 virtual TGeoMaterial *DecayMaterial(Double_t time, Double_t precision = 0.001);; 76 virtual void FillMaterialEvolution(TObjArray *population, Double_t precision = 0.001);; 77 // getters & setters; 78 bool AddProperty(const char *property, const char *ref);; 79 bool AddConstProperty(const char *property, const char *ref);; 80 Int_t GetNproperties() const { return fProperties.GetSize(); }; 81 Int_t GetNconstProperties() const { return fConstProperties.GetSize(); }; 82 const char *GetPropertyRef(const char *property) const;; 83 const char *GetPropertyRef(Int_t i) const; 84 {; 85 return (fProperties.At(i) ? fProperties.At(i)->GetTitle() : nullptr);; 86 }; 87 Double_t GetConstProperty(const char *property, Bool_t *error = nullptr) const;; 88 Double_t GetConstProperty(Int_t i, Bool_t *error = nullptr) const;; 89 const char *GetConstPropertyRef(const char *property) const;; 90 const char *GetConstPropertyRef(Int_t i) const; 91 {; 92 return (fConstProperties.At(i) ? fConstProperties.At(i)->GetTitle() : nullptr);; 93 }; 94 TList const &GetProperties() const { return fProperties; }; 95 TList const &GetConstProperties() const { return fConstProperties; }; 96 TGDMLMatrix *GetProperty(const char *name) const;; 97 TGDMLMatrix *GetProperty(Int_t i) const;; 98 virtual Int_t GetByteCount() const { return sizeof(*this); }; 99 virtual Double_t GetA() const { return fA; }; 100 virtual Double_t GetZ() const { return fZ; }; 101 virtual Int_t GetDefaultColor() const;; 102 virtual Double_t GetDensity() const { return fDensity; }; 103 virtual Int_t GetNelements() const { return 1; }; 104 TGeoElement *GetElement() const;; 105 virtual TGeoElement *GetElement(Int_t i) const;; 106 virtual void GetElementProp(Double_t &a, Double_t &z, Double_t &w, Int_t i = 0);; 107 TGeoElement *GetBaseElement",MatchSource.WIKI,doc/master/TGeoMaterial_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoMaterial_8h_source.html
https://root.cern/doc/master/TGeoMaterial_8h_source.html:13852,Availability,error,error,13852,".cxx:249; namechar name[80]Definition TGX11.cxx:110; TGeoElement.h; STP_temperaturestatic const Double_t STP_temperatureDefinition TGeoMaterial.h:31; STP_pressurestatic const Double_t STP_pressureDefinition TGeoMaterial.h:32; TList.h; TNamed.h; TAttFillFill Area Attributes class.Definition TAttFill.h:19; TAttFill::fFillStyleStyle_t fFillStyleFill area style.Definition TAttFill.h:23; TCollection::GetSizevirtual Int_t GetSize() constReturn the capacity of the collection, i.e.Definition TCollection.h:184; TGDMLMatrixThis class is used in the process of reading and writing the GDML ""matrix"" tag.Definition TGDMLMatrix.h:33; TGeoElementTableTable of elements.Definition TGeoElement.h:398; TGeoElementBase class for chemical elements.Definition TGeoElement.h:36; TGeoExtensionABC for user objects attached to TGeoVolume or TGeoNode.Definition TGeoExtension.h:17; TGeoMaterialBase class describing materials.Definition TGeoMaterial.h:34; TGeoMaterial::GetConstPropertyDouble_t GetConstProperty(const char *property, Bool_t *error=nullptr) constDefinition TGeoMaterial.cxx:392; TGeoMaterial::GetIntLenvirtual Double_t GetIntLen() constDefinition TGeoMaterial.h:110; TGeoMaterial::SetDensityvirtual void SetDensity(Double_t density)Definition TGeoMaterial.h:137; TGeoMaterial::SetZvirtual void SetZ(Double_t z)Definition TGeoMaterial.h:132; TGeoMaterial::SetUserExtensionvoid SetUserExtension(TGeoExtension *ext)Connect user-defined extension to the material.Definition TGeoMaterial.cxx:346; TGeoMaterial::GetUserExtensionTGeoExtension * GetUserExtension() constDefinition TGeoMaterial.h:118; TGeoMaterial::GetFWExtensionTGeoExtension * GetFWExtension() constDefinition TGeoMaterial.h:119; TGeoMaterial::GetCerenkovPropertiesvirtual TObject * GetCerenkovProperties() constDefinition TGeoMaterial.h:112; TGeoMaterial::fStateEGeoMaterialState fStateDefinition TGeoMaterial.h:48; TGeoMaterial::SetCerenkovPropertiesvirtual void SetCerenkovProperties(TObject *cerenkov)Definition TGeoMaterial.h:143; TGeoMa",MatchSource.WIKI,doc/master/TGeoMaterial_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoMaterial_8h_source.html
https://root.cern/doc/master/TGeoMaterial_8h_source.html:16456,Integrability,interface,interface,16456,"1343; TGeoMaterial::GetConstPropertyRefconst char * GetConstPropertyRef(const char *property) constDefinition TGeoMaterial.cxx:384; TGeoMaterial::GetNconstPropertiesInt_t GetNconstProperties() constDefinition TGeoMaterial.h:81; TGeoMaterial::IsMixturevirtual Bool_t IsMixture() constDefinition TGeoMaterial.h:124; TGeoMaterial::fPressureDouble_t fPressureDefinition TGeoMaterial.h:47; TGeoMaterial::GetByteCountvirtual Int_t GetByteCount() constDefinition TGeoMaterial.h:98; TGeoMaterial::SetFWExtensionvoid SetFWExtension(TGeoExtension *ext)Connect framework defined extension to the material.Definition TGeoMaterial.cxx:449; TGeoMaterial::AddConstPropertybool AddConstProperty(const char *property, const char *ref)Definition TGeoMaterial.cxx:430; TGeoMaterial::fTemperatureDouble_t fTemperatureDefinition TGeoMaterial.h:46; TGeoMaterial::GetConstPropertiesTList const & GetConstProperties() constDefinition TGeoMaterial.h:95; TGeoMaterial::GetElementPropvirtual void GetElementProp(Double_t &a, Double_t &z, Double_t &w, Int_t i=0)Single interface to get element properties.Definition TGeoMaterial.cxx:647; TGeoMaterial::DecayMaterialvirtual TGeoMaterial * DecayMaterial(Double_t time, Double_t precision=0.001)Create the material representing the decay product of this material at a given time.Definition TGeoMaterial.cxx:671; TGeoMaterial::fPropertiesTList fPropertiesDefinition TGeoMaterial.h:52; TGeoMaterial::SetStatevoid SetState(EGeoMaterialState state)Definition TGeoMaterial.h:149; TGeoMaterial::GetStateEGeoMaterialState GetState() constDefinition TGeoMaterial.h:116; TGeoMaterial::AddPropertybool AddProperty(const char *property, const char *ref)Definition TGeoMaterial.cxx:418; TGeoMaterial::GetTemperatureDouble_t GetTemperature() constDefinition TGeoMaterial.h:114; TGeoMaterial::GetSpecificActivityvirtual Double_t GetSpecificActivity(Int_t) constDefinition TGeoMaterial.h:117; TGeoMaterial::GetNelementsvirtual Int_t GetNelements() constDefinition TGeoMaterial.h:103; TGeoMaterial",MatchSource.WIKI,doc/master/TGeoMaterial_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoMaterial_8h_source.html
https://root.cern/doc/master/TGeoMaterial_8h_source.html:22761,Integrability,interface,interface,22761,"xtensionTGeoExtension * fFWExtensionTransient user-defined extension to materials.Definition TGeoMaterial.h:55; TGeoMaterial::GetPropertyRefconst char * GetPropertyRef(Int_t i) constDefinition TGeoMaterial.h:83; TGeoMaterial::Printvoid Print(const Option_t *option="""") const overrideprint characteristics of this materialDefinition TGeoMaterial.cxx:585; TGeoMaterial::GetDensityvirtual Double_t GetDensity() constDefinition TGeoMaterial.h:102; TGeoMaterial::GetZvirtual Double_t GetZ() constDefinition TGeoMaterial.h:100; TGeoMaterial::~TGeoMaterial~TGeoMaterial() overrideDestructor.Definition TGeoMaterial.cxx:326; TGeoMaterial::SetTemperaturevoid SetTemperature(Double_t temperature)Definition TGeoMaterial.h:147; TGeoMixtureMixtures of elements.Definition TGeoMaterial.h:159; TGeoMixture::GetNmixtInt_t * GetNmixt() constDefinition TGeoMaterial.h:205; TGeoMixture::fElementsTObjArray * fElementsDefinition TGeoMaterial.h:168; TGeoMixture::GetElementPropvoid GetElementProp(Double_t &a, Double_t &z, Double_t &w, Int_t i=0) overrideSingle interface to get element properties.Definition TGeoMaterial.h:195; TGeoMixture::GetByteCountInt_t GetByteCount() const overrideDefinition TGeoMaterial.h:193; TGeoMixture::ComputeNuclearInterLengthvoid ComputeNuclearInterLength()Compute Nuclear Interaction Length based on Geant4 formula.Definition TGeoMaterial.cxx:1395; TGeoMixture::~TGeoMixture~TGeoMixture() overrideDestructor.Definition TGeoMaterial.cxx:810; TGeoMixture::GetZmixtDouble_t * GetZmixt() constDefinition TGeoMaterial.h:202; TGeoMixture::IsEqBool_t IsEq(const TGeoMaterial *other) const overrideReturn true if the other material has the same physical properties.Definition TGeoMaterial.cxx:1155; TGeoMixture::operator=TGeoMixture & operator=(const TGeoMixture &)=delete; TGeoMixture::AddElementvoid AddElement(Double_t a, Double_t z, Double_t weight)add an element to the mixture using fraction by weight Check if the element is already definedDefinition TGeoMaterial.cxx:869; TGeoMixture::TG",MatchSource.WIKI,doc/master/TGeoMaterial_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoMaterial_8h_source.html
https://root.cern/doc/master/TGeoMatrix_8cxx_source.html:7464,Availability,error,error,7464,");; 159 TGeoTranslation *t2 = new TGeoTranslation(4,3,10);; 160 t2->Subtract(&t1);; 161~~~; 162 ; 163#### Rotations; 164 Represent a pure rotation. Data members: Double_t fRotationMatrix[3*3].; 165 Rotations can be defined either by Euler angles, either, by GEANT3 angles :; 166 ; 167~~~ {.cpp}; 168 TGeoRotation *r1 = new TGeoRotation();; 169 r1->SetAngles(phi, theta, psi); // all angles in degrees; 170~~~; 171 ; 172 This represent the composition of : first a rotation about Z axis with; 173 angle phi, then a rotation with theta about the rotated X axis, and; 174 finally a rotation with psi about the new Z axis.; 175 ; 176~~~ {.cpp}; 177 r1->SetAngles(th1,phi1, th2,phi2, th3,phi3); 178~~~; 179 ; 180 This is a rotation defined in GEANT3 style. Theta and phi are the spherical; 181 angles of each axis of the rotated coordinate system with respect to the; 182 initial one. This construction allows definition of malformed rotations,; 183 e.g. not orthogonal. A check is performed and an error message is issued; 184 in this case.; 185 ; 186 Specific utilities : determinant, inverse.; 187 ; 188#### Scale transformations; 189 Represent a scale shrinking/enlargement. Data; 190 members :Double_t fScale[3]. Not fully implemented yet.; 191 ; 192#### Combined transformations; 193Represent a rotation followed by a translation.; 194Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; 195 ; 196~~~ {.cpp}; 197 TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; 198 TGeoTranslation trans;; 199 ...; 200 TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; 201 TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot); 202~~~; 203 ; 204 ; 205#### TGeoGenTrans; 206Combined transformations including a scale. Not implemented.; 207 ; 208#### TGeoIdentity; 209A generic singleton matrix representing a identity transformation; 210 NOTE: identified by the global variable gGeoIdentity.; 211*/; 212 ; 213#include <iostream>; 214#include ""TObjArray.h""; 215 ; 216#include ""TGeoMan",MatchSource.WIKI,doc/master/TGeoMatrix_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoMatrix_8cxx_source.html
https://root.cern/doc/master/TGeoMatrix_8cxx_source.html:46164,Availability,error,errors,46164,"x elements in the GEANT3 way; 1278 ; 1279void TGeoRotation::SetAngles(Double_t theta1, Double_t phi1, Double_t theta2, Double_t phi2, Double_t theta3,; 1280 Double_t phi3); 1281{; 1282 Double_t degrad = TMath::Pi() / 180.;; 1283 fRotationMatrix[0] = TMath::Cos(degrad * phi1) * TMath::Sin(degrad * theta1);; 1284 fRotationMatrix[3] = TMath::Sin(degrad * phi1) * TMath::Sin(degrad * theta1);; 1285 fRotationMatrix[6] = TMath::Cos(degrad * theta1);; 1286 fRotationMatrix[1] = TMath::Cos(degrad * phi2) * TMath::Sin(degrad * theta2);; 1287 fRotationMatrix[4] = TMath::Sin(degrad * phi2) * TMath::Sin(degrad * theta2);; 1288 fRotationMatrix[7] = TMath::Cos(degrad * theta2);; 1289 fRotationMatrix[2] = TMath::Cos(degrad * phi3) * TMath::Sin(degrad * theta3);; 1290 fRotationMatrix[5] = TMath::Sin(degrad * phi3) * TMath::Sin(degrad * theta3);; 1291 fRotationMatrix[8] = TMath::Cos(degrad * theta3);; 1292 // do the trick to eliminate most of the floating point errors; 1293 for (Int_t i = 0; i < 9; i++) {; 1294 if (TMath::Abs(fRotationMatrix[i]) < 1E-15); 1295 fRotationMatrix[i] = 0;; 1296 if (TMath::Abs(fRotationMatrix[i] - 1) < 1E-15); 1297 fRotationMatrix[i] = 1;; 1298 if (TMath::Abs(fRotationMatrix[i] + 1) < 1E-15); 1299 fRotationMatrix[i] = -1;; 1300 }; 1301 if (!IsValid()); 1302 Error(""SetAngles"", ""invalid rotation (G3 angles, th1=%f phi1=%f, th2=%f ph2=%f, th3=%f phi3=%f)"", theta1, phi1,; 1303 theta2, phi2, theta3, phi3);; 1304 CheckMatrix();; 1305}; 1306 ; 1307////////////////////////////////////////////////////////////////////////////////; 1308/// Retrieve rotation angles; 1309 ; 1310void TGeoRotation::GetAngles(Double_t &theta1, Double_t &phi1, Double_t &theta2, Double_t &phi2, Double_t &theta3,; 1311 Double_t &phi3) const; 1312{; 1313 Double_t raddeg = 180. / TMath::Pi();; 1314 theta1 = raddeg * TMath::ACos(fRotationMatrix[6]);; 1315 theta2 = raddeg * TMath::ACos(fRotationMatrix[7]);; 1316 theta3 = raddeg * TMath::ACos(fRotationMatrix[8]);; 1317 if (TMath::Abs(fRotationMatr",MatchSource.WIKI,doc/master/TGeoMatrix_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoMatrix_8cxx_source.html
https://root.cern/doc/master/TGeoMatrix_8cxx_source.html:81862,Availability,down,down,81862,"//////////////////////////////////////////////////; 2342/// dummy ctor; 2343 ; 2344TGeoIdentity::TGeoIdentity(); 2345{; 2346 if (!gGeoIdentity); 2347 gGeoIdentity = this;; 2348 RegisterYourself();; 2349}; 2350 ; 2351////////////////////////////////////////////////////////////////////////////////; 2352/// constructor; 2353 ; 2354TGeoIdentity::TGeoIdentity(const char *name) : TGeoMatrix(name); 2355{; 2356 if (!gGeoIdentity); 2357 gGeoIdentity = this;; 2358 RegisterYourself();; 2359}; 2360 ; 2361////////////////////////////////////////////////////////////////////////////////; 2362/// Return a temporary inverse of this.; 2363 ; 2364TGeoHMatrix TGeoIdentity::Inverse() const; 2365{; 2366 TGeoHMatrix h = *gGeoIdentity;; 2367 return h;; 2368}; 2369 ; 2370/** \class TGeoHMatrix; 2371\ingroup Geometry_classes; 2372 ; 2373Matrix class used for computing global transformations; 2374Should NOT be used for node definition. An instance of this class; 2375is generally used to pile-up local transformations starting from; 2376the top level physical node, down to the current node.; 2377*/; 2378 ; 2379ClassImp(TGeoHMatrix);; 2380 ; 2381////////////////////////////////////////////////////////////////////////////////; 2382/// dummy ctor; 2383 ; 2384TGeoHMatrix::TGeoHMatrix(); 2385{; 2386 memset(&fTranslation[0], 0, kN3);; 2387 memcpy(fRotationMatrix, kIdentityMatrix, kN9);; 2388 memcpy(fScale, kUnitScale, kN3);; 2389}; 2390 ; 2391////////////////////////////////////////////////////////////////////////////////; 2392/// constructor; 2393 ; 2394TGeoHMatrix::TGeoHMatrix(const char *name) : TGeoMatrix(name); 2395{; 2396 memset(&fTranslation[0], 0, kN3);; 2397 memcpy(fRotationMatrix, kIdentityMatrix, kN9);; 2398 memcpy(fScale, kUnitScale, kN3);; 2399}; 2400 ; 2401////////////////////////////////////////////////////////////////////////////////; 2402/// assignment; 2403 ; 2404TGeoHMatrix::TGeoHMatrix(const TGeoMatrix &matrix) : TGeoMatrix(matrix); 2405{; 2406 memset(&fTranslation[0], 0, kN3);; 2",MatchSource.WIKI,doc/master/TGeoMatrix_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoMatrix_8cxx_source.html
https://root.cern/doc/master/TGeoMatrix_8cxx_source.html:126920,Availability,error,error,126920,"mevirtual void SetName(const char *name)Set the name of the TNamed.Definition TNamed.cxx:140; TNamed::operator=TNamed & operator=(const TNamed &rhs)TNamed assignment operator.Definition TNamed.cxx:51; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjArray::GetEntriesFastInt_t GetEntriesFast() constDefinition TObjArray.h:58; TObjArray::RemoveTObject * Remove(TObject *obj) overrideRemove object from array.Definition TObjArray.cxx:719; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::GetUniqueIDvirtual UInt_t GetUniqueID() constReturn the unique object id.Definition TObject.cxx:462; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TStringBasic string class.Definition TString.h:139; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TString::Formvoid Form(const char *fmt,...)Formats a string using a printf style format descriptor.Definition TString.cxx:2356; bool; double; int; TMath::ACosDouble_t ACos(Double_t)Returns the principal value of the arc cosine of x, expressed in radians.Definition TMath.h:632; TMath::ASinDouble_t ASin(Double_t)Returns the principal value of the arc sine of x, expressed in radians.Definition TMath.h:624; TMath::ATan2Double_t ATan2(Double_t y, Double_t x)Returns the principal value of the arc tangent of y/x, expressed in radians.Definition TMath.h:646; TMath::DegToRadconstexpr Double_t DegToRad()Conversion from degree to radian: .Definition TMath.h:79;",MatchSource.WIKI,doc/master/TGeoMatrix_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoMatrix_8cxx_source.html
https://root.cern/doc/master/TGeoMatrix_8cxx_source.html:3818,Integrability,interface,interface,3818,"`, `tz` are the translation components; 72 - `sx`, `sy`, `sz` are arbitrary scale constants on each axis,; 73 ; 74 The disadvantage in using this approach is that computation for 4x4 matrices; 75is expensive. Even combining two translation would become a multiplication; 76of their corresponding matrices, which is quite an undesired effect. On the; 77other hand, it is not a good idea to store a translation as a block of 16; 78numbers. We have therefore chosen to implement each basic transformation type; 79as a class deriving from the same basic abstract class and handling its specific; 80data and point/vector transformation algorithms.; 81 ; 82\image html geom_transf.jpg; 83 ; 84### The base class TGeoMatrix defines abstract metods for:; 85 ; 86#### translation, rotation and scale getters. Every derived class stores only; 87 its specific data, e.g. a translation stores an array of 3 doubles and a; 88 rotation an array of 9. However, asking which is the rotation array of a; 89 TGeoTranslation through the base TGeoMatrix interface is a legal operation.; 90 The answer in this case is a pointer to a global constant array representing; 91 an identity rotation.; 92 ; 93~~~ {.cpp}; 94 Double_t *TGeoMatrix::GetTranslation(); 95 Double_t *TGeoMatrix::GetRotation(); 96 Double_t *TGeoMatrix::GetScale(); 97~~~; 98 ; 99#### MasterToLocal() and LocalToMaster() point and vector transformations :; 100 ; 101~~~ {.cpp}; 102 void TGeoMatrix::MasterToLocal(const Double_t *master, Double_t *local); 103 void TGeoMatrix::LocalToMaster(const Double_t *local, Double_t *master); 104 void TGeoMatrix::MasterToLocalVect(const Double_t *master, Double_t *local); 105 void TGeoMatrix::LocalToMasterVect(const Double_t *local, Double_t *master); 106~~~; 107 ; 108 These allow correct conversion also for reflections.; 109 ; 110#### Transformation type getters :; 111 ; 112~~~ {.cpp}; 113 Bool_t TGeoMatrix::IsIdentity(); 114 Bool_t TGeoMatrix::IsTranslation(); 115 Bool_t TGeoMatrix::IsRotation(); 116 Bool",MatchSource.WIKI,doc/master/TGeoMatrix_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoMatrix_8cxx_source.html
https://root.cern/doc/master/TGeoMatrix_8cxx_source.html:7470,Integrability,message,message,7470,");; 159 TGeoTranslation *t2 = new TGeoTranslation(4,3,10);; 160 t2->Subtract(&t1);; 161~~~; 162 ; 163#### Rotations; 164 Represent a pure rotation. Data members: Double_t fRotationMatrix[3*3].; 165 Rotations can be defined either by Euler angles, either, by GEANT3 angles :; 166 ; 167~~~ {.cpp}; 168 TGeoRotation *r1 = new TGeoRotation();; 169 r1->SetAngles(phi, theta, psi); // all angles in degrees; 170~~~; 171 ; 172 This represent the composition of : first a rotation about Z axis with; 173 angle phi, then a rotation with theta about the rotated X axis, and; 174 finally a rotation with psi about the new Z axis.; 175 ; 176~~~ {.cpp}; 177 r1->SetAngles(th1,phi1, th2,phi2, th3,phi3); 178~~~; 179 ; 180 This is a rotation defined in GEANT3 style. Theta and phi are the spherical; 181 angles of each axis of the rotated coordinate system with respect to the; 182 initial one. This construction allows definition of malformed rotations,; 183 e.g. not orthogonal. A check is performed and an error message is issued; 184 in this case.; 185 ; 186 Specific utilities : determinant, inverse.; 187 ; 188#### Scale transformations; 189 Represent a scale shrinking/enlargement. Data; 190 members :Double_t fScale[3]. Not fully implemented yet.; 191 ; 192#### Combined transformations; 193Represent a rotation followed by a translation.; 194Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; 195 ; 196~~~ {.cpp}; 197 TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; 198 TGeoTranslation trans;; 199 ...; 200 TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; 201 TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot); 202~~~; 203 ; 204 ; 205#### TGeoGenTrans; 206Combined transformations including a scale. Not implemented.; 207 ; 208#### TGeoIdentity; 209A generic singleton matrix representing a identity transformation; 210 NOTE: identified by the global variable gGeoIdentity.; 211*/; 212 ; 213#include <iostream>; 214#include ""TObjArray.h""; 215 ; 216#include ""TGeoMan",MatchSource.WIKI,doc/master/TGeoMatrix_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoMatrix_8cxx_source.html
https://root.cern/doc/master/TGeoMatrix_8cxx_source.html:126668,Integrability,message,message,126668,"l named ROOT classes.Definition TNamed.h:29; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TNamed::GetTitleconst char * GetTitle() const overrideReturns title of object.Definition TNamed.h:48; TNamed::SetNamevirtual void SetName(const char *name)Set the name of the TNamed.Definition TNamed.cxx:140; TNamed::operator=TNamed & operator=(const TNamed &rhs)TNamed assignment operator.Definition TNamed.cxx:51; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjArray::GetEntriesFastInt_t GetEntriesFast() constDefinition TObjArray.h:58; TObjArray::RemoveTObject * Remove(TObject *obj) overrideRemove object from array.Definition TObjArray.cxx:719; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::GetUniqueIDvirtual UInt_t GetUniqueID() constReturn the unique object id.Definition TObject.cxx:462; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TStringBasic string class.Definition TString.h:139; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TString::Formvoid Form(const char *fmt,...)Formats a string using a printf style format descriptor.Definition TString.cxx:2356; bool; double; int; TMath::ACosDouble_t ACos(Double_t)Returns the principal value of the arc cosine of x, expressed in radians.Definition TMath.h:632; TMath::ASinDouble_t ASin(Double_t)Returns the principal value of the arc sine of x, expressed in radians.Definition TMath",MatchSource.WIKI,doc/master/TGeoMatrix_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoMatrix_8cxx_source.html
https://root.cern/doc/master/TGeoMatrix_8cxx_source.html:126926,Integrability,message,message,126926,"mevirtual void SetName(const char *name)Set the name of the TNamed.Definition TNamed.cxx:140; TNamed::operator=TNamed & operator=(const TNamed &rhs)TNamed assignment operator.Definition TNamed.cxx:51; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjArray::GetEntriesFastInt_t GetEntriesFast() constDefinition TObjArray.h:58; TObjArray::RemoveTObject * Remove(TObject *obj) overrideRemove object from array.Definition TObjArray.cxx:719; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::GetUniqueIDvirtual UInt_t GetUniqueID() constReturn the unique object id.Definition TObject.cxx:462; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TStringBasic string class.Definition TString.h:139; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TString::Formvoid Form(const char *fmt,...)Formats a string using a printf style format descriptor.Definition TString.cxx:2356; bool; double; int; TMath::ACosDouble_t ACos(Double_t)Returns the principal value of the arc cosine of x, expressed in radians.Definition TMath.h:632; TMath::ASinDouble_t ASin(Double_t)Returns the principal value of the arc sine of x, expressed in radians.Definition TMath.h:624; TMath::ATan2Double_t ATan2(Double_t y, Double_t x)Returns the principal value of the arc tangent of y/x, expressed in radians.Definition TMath.h:646; TMath::DegToRadconstexpr Double_t DegToRad()Conversion from degree to radian: .Definition TMath.h:79;",MatchSource.WIKI,doc/master/TGeoMatrix_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoMatrix_8cxx_source.html
https://root.cern/doc/master/TGeoMatrix_8cxx_source.html:8357,Modifiability,variab,variable,8357,"nate system with respect to the; 182 initial one. This construction allows definition of malformed rotations,; 183 e.g. not orthogonal. A check is performed and an error message is issued; 184 in this case.; 185 ; 186 Specific utilities : determinant, inverse.; 187 ; 188#### Scale transformations; 189 Represent a scale shrinking/enlargement. Data; 190 members :Double_t fScale[3]. Not fully implemented yet.; 191 ; 192#### Combined transformations; 193Represent a rotation followed by a translation.; 194Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; 195 ; 196~~~ {.cpp}; 197 TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; 198 TGeoTranslation trans;; 199 ...; 200 TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; 201 TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot); 202~~~; 203 ; 204 ; 205#### TGeoGenTrans; 206Combined transformations including a scale. Not implemented.; 207 ; 208#### TGeoIdentity; 209A generic singleton matrix representing a identity transformation; 210 NOTE: identified by the global variable gGeoIdentity.; 211*/; 212 ; 213#include <iostream>; 214#include ""TObjArray.h""; 215 ; 216#include ""TGeoManager.h""; 217#include ""TGeoMatrix.h""; 218#include ""TMath.h""; 219 ; 220TGeoIdentity *gGeoIdentity = nullptr;; 221const Int_t kN3 = 3 * sizeof(Double_t);; 222const Int_t kN9 = 9 * sizeof(Double_t);; 223 ; 224// statics and globals; 225 ; 226ClassImp(TGeoMatrix);; 227 ; 228////////////////////////////////////////////////////////////////////////////////; 229/// dummy constructor; 230 ; 231TGeoMatrix::TGeoMatrix(); 232{; 233 ResetBit(kGeoMatrixBits);; 234}; 235 ; 236////////////////////////////////////////////////////////////////////////////////; 237/// copy constructor; 238 ; 239TGeoMatrix::TGeoMatrix(const TGeoMatrix &other) : TNamed(other); 240{; 241 ResetBit(kGeoRegistered);; 242}; 243 ; 244////////////////////////////////////////////////////////////////////////////////; 245/// Constructor; 246 ; 247TGeoMatrix::TGeoMatri",MatchSource.WIKI,doc/master/TGeoMatrix_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoMatrix_8cxx_source.html
https://root.cern/doc/master/TGeoMatrix_8cxx_source.html:893,Performance,perform,performance,893,". ROOT: geom/geom/src/TGeoMatrix.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TGeoMatrix.cxx. Go to the documentation of this file. 1// @(#)root/geom:$Id$; 2// Author: Andrei Gheata 25/10/01; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/** \class TGeoMatrix; 13\ingroup Geometry_classes; 14 ; 15Geometrical transformation package.; 16 ; 17 All geometrical transformations handled by the modeller are provided as a; 18built-in package. This was designed to minimize memory requirements and; 19optimize performance of point/vector master-to-local and local-to-master; 20computation. We need to have in mind that a transformation in TGeo has 2; 21major use-cases. The first one is for defining the placement of a volume; 22with respect to its container reference frame. This frame will be called; 23'master' and the frame of the positioned volume - 'local'. If T is a; 24transformation used for positioning volume daughters, then:; 25 ; 26~~~ {.cpp}; 27 MASTER = T * LOCAL; 28~~~; 29 ; 30 Therefore a local-to-master conversion will be performed by using T, while; 31a master-to-local by using its inverse. The second use case is the computation; 32of the global transformation of a given object in the geometry. Since the; 33geometry is built as 'volumes-inside-volumes', this global transformation; 34represent the pile-up of all local transformations in the corresponding; 35branch. The conversion from the global reference frame and the given object; 36is also called master-to-local, but it is handled by the manager class.; 37 A general homogenous transformation is defined as a 4x4 matrix embedding; 38a r",MatchSource.WIKI,doc/master/TGeoMatrix_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoMatrix_8cxx_source.html
https://root.cern/doc/master/TGeoMatrix_8cxx_source.html:1425,Performance,perform,performed,1425,"*; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/** \class TGeoMatrix; 13\ingroup Geometry_classes; 14 ; 15Geometrical transformation package.; 16 ; 17 All geometrical transformations handled by the modeller are provided as a; 18built-in package. This was designed to minimize memory requirements and; 19optimize performance of point/vector master-to-local and local-to-master; 20computation. We need to have in mind that a transformation in TGeo has 2; 21major use-cases. The first one is for defining the placement of a volume; 22with respect to its container reference frame. This frame will be called; 23'master' and the frame of the positioned volume - 'local'. If T is a; 24transformation used for positioning volume daughters, then:; 25 ; 26~~~ {.cpp}; 27 MASTER = T * LOCAL; 28~~~; 29 ; 30 Therefore a local-to-master conversion will be performed by using T, while; 31a master-to-local by using its inverse. The second use case is the computation; 32of the global transformation of a given object in the geometry. Since the; 33geometry is built as 'volumes-inside-volumes', this global transformation; 34represent the pile-up of all local transformations in the corresponding; 35branch. The conversion from the global reference frame and the given object; 36is also called master-to-local, but it is handled by the manager class.; 37 A general homogenous transformation is defined as a 4x4 matrix embedding; 38a rotation, a translation and a scale. The advantage of this description; 39is that each basic transformation can be represented as a homogenous matrix,; 40composition being performed as simple matrix multiplication.; 41 ; 42 Rotation: Inverse rotation:; 43 ; 44~~~ {.cpp}; 45 r11 r12 r13 0 r11 r21 r31 0; 46 r21 r22 r23 0 r12 r22 r32 0; 47 r31 r32 r33 0 r13 r23 r33 0; 48 0 0 0 1 0 0 0 1; 49~~~; 50 ; 51 Translation:",MatchSource.WIKI,doc/master/TGeoMatrix_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoMatrix_8cxx_source.html
https://root.cern/doc/master/TGeoMatrix_8cxx_source.html:2172,Performance,perform,performed,2172,"to its container reference frame. This frame will be called; 23'master' and the frame of the positioned volume - 'local'. If T is a; 24transformation used for positioning volume daughters, then:; 25 ; 26~~~ {.cpp}; 27 MASTER = T * LOCAL; 28~~~; 29 ; 30 Therefore a local-to-master conversion will be performed by using T, while; 31a master-to-local by using its inverse. The second use case is the computation; 32of the global transformation of a given object in the geometry. Since the; 33geometry is built as 'volumes-inside-volumes', this global transformation; 34represent the pile-up of all local transformations in the corresponding; 35branch. The conversion from the global reference frame and the given object; 36is also called master-to-local, but it is handled by the manager class.; 37 A general homogenous transformation is defined as a 4x4 matrix embedding; 38a rotation, a translation and a scale. The advantage of this description; 39is that each basic transformation can be represented as a homogenous matrix,; 40composition being performed as simple matrix multiplication.; 41 ; 42 Rotation: Inverse rotation:; 43 ; 44~~~ {.cpp}; 45 r11 r12 r13 0 r11 r21 r31 0; 46 r21 r22 r23 0 r12 r22 r32 0; 47 r31 r32 r33 0 r13 r23 r33 0; 48 0 0 0 1 0 0 0 1; 49~~~; 50 ; 51 Translation: Inverse translation:; 52 ; 53~~~ {.cpp}; 54 1 0 0 tx 1 0 0 -tx; 55 0 1 0 ty 0 1 0 -ty; 56 0 0 1 tz 0 0 1 -tz; 57 0 0 0 1 0 0 0 1; 58~~~; 59 ; 60 Scale: Inverse scale:; 61 ; 62~~~ {.cpp}; 63 sx 0 0 0 1/sx 0 0 0; 64 0 sy 0 0 0 1/sy 0 0; 65 0 0 sz 0 0 0 1/sz 0; 66 0 0 0 1 0 0 0 1; 67~~~; 68 ; 69 where:; 70 - `rij` are the 3x3 rotation matrix components,; 71 - `tx`, `ty`, `tz` are the translation components; 72 - `sx`, `sy`, `sz` are arbitrary scale constants on each axis,; 73 ; 74 The disadvantage in using this approach is that computation for 4x4 matrices; 75is expensive. Even combining two translation would become a multiplication; 76of their corresponding matrices, which is quite an undesired effect.",MatchSource.WIKI,doc/master/TGeoMatrix_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoMatrix_8cxx_source.html
https://root.cern/doc/master/TGeoMatrix_8cxx_source.html:7447,Performance,perform,performed,7447,");; 159 TGeoTranslation *t2 = new TGeoTranslation(4,3,10);; 160 t2->Subtract(&t1);; 161~~~; 162 ; 163#### Rotations; 164 Represent a pure rotation. Data members: Double_t fRotationMatrix[3*3].; 165 Rotations can be defined either by Euler angles, either, by GEANT3 angles :; 166 ; 167~~~ {.cpp}; 168 TGeoRotation *r1 = new TGeoRotation();; 169 r1->SetAngles(phi, theta, psi); // all angles in degrees; 170~~~; 171 ; 172 This represent the composition of : first a rotation about Z axis with; 173 angle phi, then a rotation with theta about the rotated X axis, and; 174 finally a rotation with psi about the new Z axis.; 175 ; 176~~~ {.cpp}; 177 r1->SetAngles(th1,phi1, th2,phi2, th3,phi3); 178~~~; 179 ; 180 This is a rotation defined in GEANT3 style. Theta and phi are the spherical; 181 angles of each axis of the rotated coordinate system with respect to the; 182 initial one. This construction allows definition of malformed rotations,; 183 e.g. not orthogonal. A check is performed and an error message is issued; 184 in this case.; 185 ; 186 Specific utilities : determinant, inverse.; 187 ; 188#### Scale transformations; 189 Represent a scale shrinking/enlargement. Data; 190 members :Double_t fScale[3]. Not fully implemented yet.; 191 ; 192#### Combined transformations; 193Represent a rotation followed by a translation.; 194Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; 195 ; 196~~~ {.cpp}; 197 TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; 198 TGeoTranslation trans;; 199 ...; 200 TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; 201 TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot); 202~~~; 203 ; 204 ; 205#### TGeoGenTrans; 206Combined transformations including a scale. Not implemented.; 207 ; 208#### TGeoIdentity; 209A generic singleton matrix representing a identity transformation; 210 NOTE: identified by the global variable gGeoIdentity.; 211*/; 212 ; 213#include <iostream>; 214#include ""TObjArray.h""; 215 ; 216#include ""TGeoMan",MatchSource.WIKI,doc/master/TGeoMatrix_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoMatrix_8cxx_source.html
https://root.cern/doc/master/TGeoMatrix_8cxx_source.html:49573,Performance,perform,performes,49573," {; 1345 theta = TMath::ACos(m[8]) * TMath::RadToDeg();; 1346 phi = TMath::ATan2(-m[8] * m[1], m[0]) * TMath::RadToDeg();; 1347 psi = 0.; // convention, phi+psi matters; 1348 return;; 1349 }; 1350 // sin(theta) != 0; 1351 phi = TMath::ATan2(m[2], -m[5]);; 1352 Double_t sphi = TMath::Sin(phi);; 1353 if (TMath::Abs(sphi) < 1.e-9); 1354 theta = -TMath::ASin(m[5] / TMath::Cos(phi)) * TMath::RadToDeg();; 1355 else; 1356 theta = TMath::ASin(m[2] / sphi) * TMath::RadToDeg();; 1357 phi *= TMath::RadToDeg();; 1358 psi = TMath::ATan2(m[6], m[7]) * TMath::RadToDeg();; 1359}; 1360 ; 1361////////////////////////////////////////////////////////////////////////////////; 1362/// computes determinant of the rotation matrix; 1363 ; 1364Double_t TGeoRotation::Determinant() const; 1365{; 1366 Double_t det = fRotationMatrix[0] * fRotationMatrix[4] * fRotationMatrix[8] +; 1367 fRotationMatrix[3] * fRotationMatrix[7] * fRotationMatrix[2] +; 1368 fRotationMatrix[6] * fRotationMatrix[1] * fRotationMatrix[5] -; 1369 fRotationMatrix[2] * fRotationMatrix[4] * fRotationMatrix[6] -; 1370 fRotationMatrix[5] * fRotationMatrix[7] * fRotationMatrix[0] -; 1371 fRotationMatrix[8] * fRotationMatrix[1] * fRotationMatrix[3];; 1372 return det;; 1373}; 1374 ; 1375////////////////////////////////////////////////////////////////////////////////; 1376/// performes an orthogonality check and finds if the matrix is a reflection; 1377/// Warning(""CheckMatrix"", ""orthogonality check not performed yet"");; 1378 ; 1379void TGeoRotation::CheckMatrix(); 1380{; 1381 if (Determinant() < 0); 1382 SetBit(kGeoReflection);; 1383 Double_t dd = fRotationMatrix[0] + fRotationMatrix[4] + fRotationMatrix[8] - 3.;; 1384 if (TMath::Abs(dd) < 1.E-12); 1385 ResetBit(kGeoRotation);; 1386 else; 1387 SetBit(kGeoRotation);; 1388}; 1389 ; 1390////////////////////////////////////////////////////////////////////////////////; 1391/// Get the inverse rotation matrix (which is simply the transpose); 1392 ; 1393void TGeoRotation::GetInverse(Doub",MatchSource.WIKI,doc/master/TGeoMatrix_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoMatrix_8cxx_source.html
https://root.cern/doc/master/TGeoMatrix_8cxx_source.html:49703,Performance,perform,performed,49703," {; 1345 theta = TMath::ACos(m[8]) * TMath::RadToDeg();; 1346 phi = TMath::ATan2(-m[8] * m[1], m[0]) * TMath::RadToDeg();; 1347 psi = 0.; // convention, phi+psi matters; 1348 return;; 1349 }; 1350 // sin(theta) != 0; 1351 phi = TMath::ATan2(m[2], -m[5]);; 1352 Double_t sphi = TMath::Sin(phi);; 1353 if (TMath::Abs(sphi) < 1.e-9); 1354 theta = -TMath::ASin(m[5] / TMath::Cos(phi)) * TMath::RadToDeg();; 1355 else; 1356 theta = TMath::ASin(m[2] / sphi) * TMath::RadToDeg();; 1357 phi *= TMath::RadToDeg();; 1358 psi = TMath::ATan2(m[6], m[7]) * TMath::RadToDeg();; 1359}; 1360 ; 1361////////////////////////////////////////////////////////////////////////////////; 1362/// computes determinant of the rotation matrix; 1363 ; 1364Double_t TGeoRotation::Determinant() const; 1365{; 1366 Double_t det = fRotationMatrix[0] * fRotationMatrix[4] * fRotationMatrix[8] +; 1367 fRotationMatrix[3] * fRotationMatrix[7] * fRotationMatrix[2] +; 1368 fRotationMatrix[6] * fRotationMatrix[1] * fRotationMatrix[5] -; 1369 fRotationMatrix[2] * fRotationMatrix[4] * fRotationMatrix[6] -; 1370 fRotationMatrix[5] * fRotationMatrix[7] * fRotationMatrix[0] -; 1371 fRotationMatrix[8] * fRotationMatrix[1] * fRotationMatrix[3];; 1372 return det;; 1373}; 1374 ; 1375////////////////////////////////////////////////////////////////////////////////; 1376/// performes an orthogonality check and finds if the matrix is a reflection; 1377/// Warning(""CheckMatrix"", ""orthogonality check not performed yet"");; 1378 ; 1379void TGeoRotation::CheckMatrix(); 1380{; 1381 if (Determinant() < 0); 1382 SetBit(kGeoReflection);; 1383 Double_t dd = fRotationMatrix[0] + fRotationMatrix[4] + fRotationMatrix[8] - 3.;; 1384 if (TMath::Abs(dd) < 1.E-12); 1385 ResetBit(kGeoRotation);; 1386 else; 1387 SetBit(kGeoRotation);; 1388}; 1389 ; 1390////////////////////////////////////////////////////////////////////////////////; 1391/// Get the inverse rotation matrix (which is simply the transpose); 1392 ; 1393void TGeoRotation::GetInverse(Doub",MatchSource.WIKI,doc/master/TGeoMatrix_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoMatrix_8cxx_source.html
https://root.cern/doc/master/TGeoMatrix_8cxx_source.html:56903,Performance,perform,perform,56903,"84 SetBit(kGeoReflection, kFALSE);; 1585}; 1586 ; 1587////////////////////////////////////////////////////////////////////////////////; 1588/// Set scale from other transformation; 1589 ; 1590void TGeoScale::SetScale(const TGeoMatrix &other); 1591{; 1592 SetBit(kGeoScale, other.IsScale());; 1593 SetBit(kGeoReflection, other.IsReflection());; 1594 memcpy(fScale, other.GetScale(), kN3);; 1595}; 1596 ; 1597////////////////////////////////////////////////////////////////////////////////; 1598/// Convert a local point to the master frame.; 1599 ; 1600void TGeoScale::LocalToMaster(const Double_t *local, Double_t *master) const; 1601{; 1602 master[0] = local[0] * fScale[0];; 1603 master[1] = local[1] * fScale[1];; 1604 master[2] = local[2] * fScale[2];; 1605}; 1606 ; 1607////////////////////////////////////////////////////////////////////////////////; 1608/// Convert the local distance along unit vector DIR to master frame. If DIR; 1609/// is not specified perform a conversion such as the returned distance is the; 1610/// the minimum for all possible directions.; 1611 ; 1612Double_t TGeoScale::LocalToMaster(Double_t dist, const Double_t *dir) const; 1613{; 1614 Double_t scale;; 1615 if (!dir) {; 1616 scale = TMath::Abs(fScale[0]);; 1617 if (TMath::Abs(fScale[1]) < scale); 1618 scale = TMath::Abs(fScale[1]);; 1619 if (TMath::Abs(fScale[2]) < scale); 1620 scale = TMath::Abs(fScale[2]);; 1621 } else {; 1622 scale = fScale[0] * fScale[0] * dir[0] * dir[0] + fScale[1] * fScale[1] * dir[1] * dir[1] +; 1623 fScale[2] * fScale[2] * dir[2] * dir[2];; 1624 scale = TMath::Sqrt(scale);; 1625 }; 1626 return scale * dist;; 1627}; 1628 ; 1629////////////////////////////////////////////////////////////////////////////////; 1630/// Make a clone of this matrix.; 1631 ; 1632TGeoMatrix *TGeoScale::MakeClone() const; 1633{; 1634 TGeoMatrix *matrix = new TGeoScale(*this);; 1635 return matrix;; 1636}; 1637 ; 1638////////////////////////////////////////////////////////////////////////////////; 163",MatchSource.WIKI,doc/master/TGeoMatrix_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoMatrix_8cxx_source.html
https://root.cern/doc/master/TGeoMatrix_8cxx_source.html:58401,Performance,perform,perform,58401,"[1] * dir[1] +; 1623 fScale[2] * fScale[2] * dir[2] * dir[2];; 1624 scale = TMath::Sqrt(scale);; 1625 }; 1626 return scale * dist;; 1627}; 1628 ; 1629////////////////////////////////////////////////////////////////////////////////; 1630/// Make a clone of this matrix.; 1631 ; 1632TGeoMatrix *TGeoScale::MakeClone() const; 1633{; 1634 TGeoMatrix *matrix = new TGeoScale(*this);; 1635 return matrix;; 1636}; 1637 ; 1638////////////////////////////////////////////////////////////////////////////////; 1639/// Convert a global point to local frame.; 1640 ; 1641void TGeoScale::MasterToLocal(const Double_t *master, Double_t *local) const; 1642{; 1643 local[0] = master[0] / fScale[0];; 1644 local[1] = master[1] / fScale[1];; 1645 local[2] = master[2] / fScale[2];; 1646}; 1647 ; 1648////////////////////////////////////////////////////////////////////////////////; 1649/// Convert the distance along unit vector DIR to local frame. If DIR; 1650/// is not specified perform a conversion such as the returned distance is the; 1651/// the minimum for all possible directions.; 1652 ; 1653Double_t TGeoScale::MasterToLocal(Double_t dist, const Double_t *dir) const; 1654{; 1655 Double_t scale;; 1656 if (!dir) {; 1657 scale = TMath::Abs(fScale[0]);; 1658 if (TMath::Abs(fScale[1]) > scale); 1659 scale = TMath::Abs(fScale[1]);; 1660 if (TMath::Abs(fScale[2]) > scale); 1661 scale = TMath::Abs(fScale[2]);; 1662 scale = 1. / scale;; 1663 } else {; 1664 scale = (dir[0] * dir[0]) / (fScale[0] * fScale[0]) + (dir[1] * dir[1]) / (fScale[1] * fScale[1]) +; 1665 (dir[2] * dir[2]) / (fScale[2] * fScale[2]);; 1666 scale = TMath::Sqrt(scale);; 1667 }; 1668 return scale * dist;; 1669}; 1670 ; 1671/** \class TGeoCombiTrans; 1672\ingroup Geometry_classes; 1673Class describing rotation + translation. Most frequently used in the description; 1674of TGeoNode 's; 1675*/; 1676 ; 1677ClassImp(TGeoCombiTrans);; 1678 ; 1679////////////////////////////////////////////////////////////////////////////////; 1680/// dumm",MatchSource.WIKI,doc/master/TGeoMatrix_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoMatrix_8cxx_source.html
https://root.cern/doc/master/TGeoMatrix_8cxx_source.html:118241,Performance,perform,performes,118241,"otation with the one specified by ROT.Definition TGeoMatrix.cxx:1411; TGeoRotation::RotateYvoid RotateY(Double_t angle) overrideRotate about Y axis of the master frame with angle expressed in degrees.Definition TGeoMatrix.cxx:1121; TGeoRotation::operator==Bool_t operator==(const TGeoRotation &other) constIs-equal operator.Definition TGeoMatrix.cxx:971; TGeoRotation::SetMatrixvoid SetMatrix(const Double_t *rot)Definition TGeoMatrix.h:230; TGeoRotation::RotateZvoid RotateZ(Double_t angle) overrideRotate about Z axis of the master frame with angle expressed in degrees.Definition TGeoMatrix.cxx:1144; TGeoRotation::LocalToMastervoid LocalToMaster(const Double_t *local, Double_t *master) const overrideconvert a point by multiplying its column vector (x, y, z, 1) to matrix inverseDefinition TGeoMatrix.cxx:1067; TGeoRotation::operator*=TGeoRotation & operator*=(const TGeoRotation &other)Composition.Definition TGeoMatrix.cxx:946; TGeoRotation::CheckMatrixvoid CheckMatrix()performes an orthogonality check and finds if the matrix is a reflection Warning(""CheckMatrix"",...Definition TGeoMatrix.cxx:1379; TGeoRotation::ReflectYvoid ReflectY(Bool_t leftside, Bool_t rotonly=kFALSE) overrideMultiply by a reflection respect to ZX.Definition TGeoMatrix.cxx:1185; TGeoRotation::GetPhiRotationDouble_t GetPhiRotation(Bool_t fixX=kFALSE) constReturns rotation angle about Z axis in degrees.Definition TGeoMatrix.cxx:1054; TGeoRotation::FastRotZvoid FastRotZ(const Double_t *sincos)Perform a rotation about Z having the sine/cosine of the rotation angle.Definition TGeoMatrix.cxx:1039; TGeoRotation::GetInversevoid GetInverse(Double_t *invmat) constGet the inverse rotation matrix (which is simply the transpose)Definition TGeoMatrix.cxx:1393; TGeoRotation::DeterminantDouble_t Determinant() constcomputes determinant of the rotation matrixDefinition TGeoMatrix.cxx:1364; TGeoRotation::GetAnglesvoid GetAngles(Double_t &theta1, Double_t &phi1, Double_t &theta2, Double_t &phi2, Double_t &theta3, Double_t",MatchSource.WIKI,doc/master/TGeoMatrix_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoMatrix_8cxx_source.html
https://root.cern/doc/master/TGeoMatrix_8cxx_source.html:34438,Testability,test,test,34438,"72{; 973 if (&other == this); 974 return kTRUE;; 975 const Double_t *rot = GetRotationMatrix();; 976 const Double_t *orot = other.GetRotationMatrix();; 977 for (auto i = 0; i < 9; i++); 978 if (TMath::Abs(rot[i] - orot[i]) > 1.E-10); 979 return kFALSE;; 980 return kTRUE;; 981}; 982 ; 983////////////////////////////////////////////////////////////////////////////////; 984/// Return a temporary inverse of this.; 985 ; 986TGeoHMatrix TGeoRotation::Inverse() const; 987{; 988 TGeoHMatrix h;; 989 h = *this;; 990 h.ResetBit(kGeoRegistered);; 991 Double_t newrot[9];; 992 newrot[0] = fRotationMatrix[0];; 993 newrot[1] = fRotationMatrix[3];; 994 newrot[2] = fRotationMatrix[6];; 995 newrot[3] = fRotationMatrix[1];; 996 newrot[4] = fRotationMatrix[4];; 997 newrot[5] = fRotationMatrix[7];; 998 newrot[6] = fRotationMatrix[2];; 999 newrot[7] = fRotationMatrix[5];; 1000 newrot[8] = fRotationMatrix[8];; 1001 h.SetRotation(newrot);; 1002 return h;; 1003}; 1004 ; 1005////////////////////////////////////////////////////////////////////////////////; 1006/// Perform orthogonality test for rotation.; 1007 ; 1008Bool_t TGeoRotation::IsValid() const; 1009{; 1010 const Double_t *r = fRotationMatrix;; 1011 Double_t cij;; 1012 for (Int_t i = 0; i < 2; i++) {; 1013 for (Int_t j = i + 1; j < 3; j++) {; 1014 // check columns; 1015 cij = TMath::Abs(r[i] * r[j] + r[i + 3] * r[j + 3] + r[i + 6] * r[j + 6]);; 1016 if (cij > 1E-4); 1017 return kFALSE;; 1018 // check rows; 1019 cij = TMath::Abs(r[3 * i] * r[3 * j] + r[3 * i + 1] * r[3 * j + 1] + r[3 * i + 2] * r[3 * j + 2]);; 1020 if (cij > 1E-4); 1021 return kFALSE;; 1022 }; 1023 }; 1024 return kTRUE;; 1025}; 1026 ; 1027////////////////////////////////////////////////////////////////////////////////; 1028/// reset data members; 1029 ; 1030void TGeoRotation::Clear(Option_t *); 1031{; 1032 memcpy(fRotationMatrix, kIdentityMatrix, kN9);; 1033 ResetBit(kGeoRotation);; 1034}; 1035 ; 1036//////////////////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TGeoMatrix_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoMatrix_8cxx_source.html
https://root.cern/doc/master/TGeoMatrix_8cxx_source.html:119398,Testability,test,test,119398,"; TGeoRotation::ReflectYvoid ReflectY(Bool_t leftside, Bool_t rotonly=kFALSE) overrideMultiply by a reflection respect to ZX.Definition TGeoMatrix.cxx:1185; TGeoRotation::GetPhiRotationDouble_t GetPhiRotation(Bool_t fixX=kFALSE) constReturns rotation angle about Z axis in degrees.Definition TGeoMatrix.cxx:1054; TGeoRotation::FastRotZvoid FastRotZ(const Double_t *sincos)Perform a rotation about Z having the sine/cosine of the rotation angle.Definition TGeoMatrix.cxx:1039; TGeoRotation::GetInversevoid GetInverse(Double_t *invmat) constGet the inverse rotation matrix (which is simply the transpose)Definition TGeoMatrix.cxx:1393; TGeoRotation::DeterminantDouble_t Determinant() constcomputes determinant of the rotation matrixDefinition TGeoMatrix.cxx:1364; TGeoRotation::GetAnglesvoid GetAngles(Double_t &theta1, Double_t &phi1, Double_t &theta2, Double_t &phi2, Double_t &theta3, Double_t &phi3) constRetrieve rotation angles.Definition TGeoMatrix.cxx:1310; TGeoRotation::IsValidBool_t IsValid() constPerform orthogonality test for rotation.Definition TGeoMatrix.cxx:1008; TGeoRotation::MasterToLocalvoid MasterToLocal(const Double_t *master, Double_t *local) const overrideconvert a point by multiplying its column vector (x, y, z, 1) to matrixDefinition TGeoMatrix.cxx:1078; TGeoRotation::MakeCloneTGeoMatrix * MakeClone() const overrideMake a clone of this matrix.Definition TGeoMatrix.cxx:1089; TGeoRotation::operator*TGeoRotation operator*(const TGeoRotation &other) constDefinition TGeoMatrix.cxx:954; TGeoRotation::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave a primitive as a C++ statement(s) on output stream ""out"".Definition TGeoMatrix.cxx:1221; TGeoRotation::ReflectXvoid ReflectX(Bool_t leftside, Bool_t rotonly=kFALSE) overrideMultiply by a reflection respect to YZ.Definition TGeoMatrix.cxx:1167; TGeoRotation::fRotationMatrixDouble_t fRotationMatrix[3 *3]Definition TGeoMatrix.h:170; TGeoRotation::SetRotationvoid SetRotation(const TGeoMatr",MatchSource.WIKI,doc/master/TGeoMatrix_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoMatrix_8cxx_source.html
https://root.cern/doc/master/TGeoMatrix_8cxx_source.html:2185,Usability,simpl,simple,2185,"to its container reference frame. This frame will be called; 23'master' and the frame of the positioned volume - 'local'. If T is a; 24transformation used for positioning volume daughters, then:; 25 ; 26~~~ {.cpp}; 27 MASTER = T * LOCAL; 28~~~; 29 ; 30 Therefore a local-to-master conversion will be performed by using T, while; 31a master-to-local by using its inverse. The second use case is the computation; 32of the global transformation of a given object in the geometry. Since the; 33geometry is built as 'volumes-inside-volumes', this global transformation; 34represent the pile-up of all local transformations in the corresponding; 35branch. The conversion from the global reference frame and the given object; 36is also called master-to-local, but it is handled by the manager class.; 37 A general homogenous transformation is defined as a 4x4 matrix embedding; 38a rotation, a translation and a scale. The advantage of this description; 39is that each basic transformation can be represented as a homogenous matrix,; 40composition being performed as simple matrix multiplication.; 41 ; 42 Rotation: Inverse rotation:; 43 ; 44~~~ {.cpp}; 45 r11 r12 r13 0 r11 r21 r31 0; 46 r21 r22 r23 0 r12 r22 r32 0; 47 r31 r32 r33 0 r13 r23 r33 0; 48 0 0 0 1 0 0 0 1; 49~~~; 50 ; 51 Translation: Inverse translation:; 52 ; 53~~~ {.cpp}; 54 1 0 0 tx 1 0 0 -tx; 55 0 1 0 ty 0 1 0 -ty; 56 0 0 1 tz 0 0 1 -tz; 57 0 0 0 1 0 0 0 1; 58~~~; 59 ; 60 Scale: Inverse scale:; 61 ; 62~~~ {.cpp}; 63 sx 0 0 0 1/sx 0 0 0; 64 0 sy 0 0 0 1/sy 0 0; 65 0 0 sz 0 0 0 1/sz 0; 66 0 0 0 1 0 0 0 1; 67~~~; 68 ; 69 where:; 70 - `rij` are the 3x3 rotation matrix components,; 71 - `tx`, `ty`, `tz` are the translation components; 72 - `sx`, `sy`, `sz` are arbitrary scale constants on each axis,; 73 ; 74 The disadvantage in using this approach is that computation for 4x4 matrices; 75is expensive. Even combining two translation would become a multiplication; 76of their corresponding matrices, which is quite an undesired effect.",MatchSource.WIKI,doc/master/TGeoMatrix_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoMatrix_8cxx_source.html
https://root.cern/doc/master/TGeoMatrix_8cxx_source.html:50173,Usability,simpl,simply,50173,"RotationMatrix[5] * fRotationMatrix[7] * fRotationMatrix[0] -; 1371 fRotationMatrix[8] * fRotationMatrix[1] * fRotationMatrix[3];; 1372 return det;; 1373}; 1374 ; 1375////////////////////////////////////////////////////////////////////////////////; 1376/// performes an orthogonality check and finds if the matrix is a reflection; 1377/// Warning(""CheckMatrix"", ""orthogonality check not performed yet"");; 1378 ; 1379void TGeoRotation::CheckMatrix(); 1380{; 1381 if (Determinant() < 0); 1382 SetBit(kGeoReflection);; 1383 Double_t dd = fRotationMatrix[0] + fRotationMatrix[4] + fRotationMatrix[8] - 3.;; 1384 if (TMath::Abs(dd) < 1.E-12); 1385 ResetBit(kGeoRotation);; 1386 else; 1387 SetBit(kGeoRotation);; 1388}; 1389 ; 1390////////////////////////////////////////////////////////////////////////////////; 1391/// Get the inverse rotation matrix (which is simply the transpose); 1392 ; 1393void TGeoRotation::GetInverse(Double_t *invmat) const; 1394{; 1395 if (!invmat) {; 1396 Error(""GetInverse"", ""no place to store the inverse matrix"");; 1397 return;; 1398 }; 1399 for (Int_t i = 0; i < 3; i++) {; 1400 for (Int_t j = 0; j < 3; j++) {; 1401 invmat[3 * i + j] = fRotationMatrix[3 * j + i];; 1402 }; 1403 }; 1404}; 1405 ; 1406////////////////////////////////////////////////////////////////////////////////; 1407/// Multiply this rotation with the one specified by ROT.; 1408/// - after=TRUE (default): THIS*ROT; 1409/// - after=FALSE : ROT*THIS; 1410 ; 1411void TGeoRotation::MultiplyBy(const TGeoRotation *rot, Bool_t after); 1412{; 1413 const Double_t *matleft, *matright;; 1414 SetBit(kGeoRotation);; 1415 Double_t newmat[9] = {0};; 1416 if (after) {; 1417 matleft = &fRotationMatrix[0];; 1418 matright = rot->GetRotationMatrix();; 1419 } else {; 1420 matleft = rot->GetRotationMatrix();; 1421 matright = &fRotationMatrix[0];; 1422 }; 1423 for (Int_t i = 0; i < 3; i++) {; 1424 for (Int_t j = 0; j < 3; j++) {; 1425 for (Int_t k = 0; k < 3; k++) {; 1426 newmat[3 * i + j] += matleft[3 * i + k] * ",MatchSource.WIKI,doc/master/TGeoMatrix_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoMatrix_8cxx_source.html
https://root.cern/doc/master/TGeoMatrix_8cxx_source.html:79168,Usability,clear,clear,79168,"GeoGenTrans(const char *name) : TGeoCombiTrans(name); 2244{; 2245 SetBit(kGeoGenTrans);; 2246 for (Int_t i = 0; i < 3; i++); 2247 fTranslation[i] = 0.0;; 2248 for (Int_t j = 0; j < 3; j++); 2249 fScale[j] = 1.0;; 2250 fRotation = nullptr;; 2251}; 2252 ; 2253////////////////////////////////////////////////////////////////////////////////; 2254/// constructor; 2255 ; 2256TGeoGenTrans::TGeoGenTrans(Double_t dx, Double_t dy, Double_t dz, Double_t sx, Double_t sy, Double_t sz,; 2257 TGeoRotation *rot); 2258 : TGeoCombiTrans(""""); 2259{; 2260 SetBit(kGeoGenTrans);; 2261 SetTranslation(dx, dy, dz);; 2262 SetScale(sx, sy, sz);; 2263 SetRotation(rot);; 2264}; 2265 ; 2266////////////////////////////////////////////////////////////////////////////////; 2267/// constructor; 2268 ; 2269TGeoGenTrans::TGeoGenTrans(const char *name, Double_t dx, Double_t dy, Double_t dz, Double_t sx, Double_t sy,; 2270 Double_t sz, TGeoRotation *rot); 2271 : TGeoCombiTrans(name); 2272{; 2273 SetBit(kGeoGenTrans);; 2274 SetTranslation(dx, dy, dz);; 2275 SetScale(sx, sy, sz);; 2276 SetRotation(rot);; 2277}; 2278 ; 2279////////////////////////////////////////////////////////////////////////////////; 2280/// destructor; 2281 ; 2282TGeoGenTrans::~TGeoGenTrans() {}; 2283 ; 2284////////////////////////////////////////////////////////////////////////////////; 2285/// clear the fields of this transformation; 2286 ; 2287void TGeoGenTrans::Clear(Option_t *); 2288{; 2289 memset(&fTranslation[0], 0, kN3);; 2290 memset(&fScale[0], 0, kN3);; 2291 if (fRotation); 2292 fRotation->Clear();; 2293}; 2294 ; 2295////////////////////////////////////////////////////////////////////////////////; 2296/// set the scale; 2297 ; 2298void TGeoGenTrans::SetScale(Double_t sx, Double_t sy, Double_t sz); 2299{; 2300 if (sx < 1.E-5 || sy < 1.E-5 || sz < 1.E-5) {; 2301 Error(""ctor"", ""Invalid scale"");; 2302 return;; 2303 }; 2304 fScale[0] = sx;; 2305 fScale[1] = sy;; 2306 fScale[2] = sz;; 2307}; 2308 ; 2309/////////////////////////////",MatchSource.WIKI,doc/master/TGeoMatrix_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoMatrix_8cxx_source.html
https://root.cern/doc/master/TGeoMatrix_8cxx_source.html:86233,Usability,clear,clear,86233,"trix();; 2485 const Double_t *orot = other.GetRotationMatrix();; 2486 for (auto i = 0; i < 9; i++); 2487 if (TMath::Abs(rot[i] - orot[i]) > 1.E-10); 2488 return kFALSE;; 2489 const Double_t *scl = GetScale();; 2490 const Double_t *oscl = other.GetScale();; 2491 for (auto i = 0; i < 3; i++); 2492 if (TMath::Abs(scl[i] - oscl[i]) > 1.E-10); 2493 return kFALSE;; 2494 return kTRUE;; 2495}; 2496 ; 2497////////////////////////////////////////////////////////////////////////////////; 2498/// Fast copy method.; 2499 ; 2500void TGeoHMatrix::CopyFrom(const TGeoMatrix *other); 2501{; 2502 SetBit(kGeoTranslation, other->IsTranslation());; 2503 SetBit(kGeoRotation, other->IsRotation());; 2504 SetBit(kGeoReflection, other->IsReflection());; 2505 memcpy(fTranslation, other->GetTranslation(), kN3);; 2506 memcpy(fRotationMatrix, other->GetRotationMatrix(), kN9);; 2507}; 2508 ; 2509////////////////////////////////////////////////////////////////////////////////; 2510/// clear the data for this matrix; 2511 ; 2512void TGeoHMatrix::Clear(Option_t *); 2513{; 2514 SetBit(kGeoReflection, kFALSE);; 2515 if (IsIdentity()); 2516 return;; 2517 ResetBit(kGeoTranslation);; 2518 ResetBit(kGeoRotation);; 2519 ResetBit(kGeoScale);; 2520 memcpy(fTranslation, kNullVector, kN3);; 2521 memcpy(fRotationMatrix, kIdentityMatrix, kN9);; 2522 memcpy(fScale, kUnitScale, kN3);; 2523}; 2524 ; 2525////////////////////////////////////////////////////////////////////////////////; 2526/// Make a clone of this matrix.; 2527 ; 2528TGeoMatrix *TGeoHMatrix::MakeClone() const; 2529{; 2530 TGeoMatrix *matrix = new TGeoHMatrix(*this);; 2531 return matrix;; 2532}; 2533 ; 2534////////////////////////////////////////////////////////////////////////////////; 2535/// Perform a rotation about Z having the sine/cosine of the rotation angle.; 2536 ; 2537void TGeoHMatrix::FastRotZ(const Double_t *sincos); 2538{; 2539 fRotationMatrix[0] = sincos[1];; 2540 fRotationMatrix[1] = -sincos[0];; 2541 fRotationMatrix[3] = sincos[0];; 2542",MatchSource.WIKI,doc/master/TGeoMatrix_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoMatrix_8cxx_source.html
https://root.cern/doc/master/TGeoMatrix_8cxx_source.html:118950,Usability,simpl,simply,118950,"onst Double_t *local, Double_t *master) const overrideconvert a point by multiplying its column vector (x, y, z, 1) to matrix inverseDefinition TGeoMatrix.cxx:1067; TGeoRotation::operator*=TGeoRotation & operator*=(const TGeoRotation &other)Composition.Definition TGeoMatrix.cxx:946; TGeoRotation::CheckMatrixvoid CheckMatrix()performes an orthogonality check and finds if the matrix is a reflection Warning(""CheckMatrix"",...Definition TGeoMatrix.cxx:1379; TGeoRotation::ReflectYvoid ReflectY(Bool_t leftside, Bool_t rotonly=kFALSE) overrideMultiply by a reflection respect to ZX.Definition TGeoMatrix.cxx:1185; TGeoRotation::GetPhiRotationDouble_t GetPhiRotation(Bool_t fixX=kFALSE) constReturns rotation angle about Z axis in degrees.Definition TGeoMatrix.cxx:1054; TGeoRotation::FastRotZvoid FastRotZ(const Double_t *sincos)Perform a rotation about Z having the sine/cosine of the rotation angle.Definition TGeoMatrix.cxx:1039; TGeoRotation::GetInversevoid GetInverse(Double_t *invmat) constGet the inverse rotation matrix (which is simply the transpose)Definition TGeoMatrix.cxx:1393; TGeoRotation::DeterminantDouble_t Determinant() constcomputes determinant of the rotation matrixDefinition TGeoMatrix.cxx:1364; TGeoRotation::GetAnglesvoid GetAngles(Double_t &theta1, Double_t &phi1, Double_t &theta2, Double_t &phi2, Double_t &theta3, Double_t &phi3) constRetrieve rotation angles.Definition TGeoMatrix.cxx:1310; TGeoRotation::IsValidBool_t IsValid() constPerform orthogonality test for rotation.Definition TGeoMatrix.cxx:1008; TGeoRotation::MasterToLocalvoid MasterToLocal(const Double_t *master, Double_t *local) const overrideconvert a point by multiplying its column vector (x, y, z, 1) to matrixDefinition TGeoMatrix.cxx:1078; TGeoRotation::MakeCloneTGeoMatrix * MakeClone() const overrideMake a clone of this matrix.Definition TGeoMatrix.cxx:1089; TGeoRotation::operator*TGeoRotation operator*(const TGeoRotation &other) constDefinition TGeoMatrix.cxx:954; TGeoRotation::SavePrimitivevoid",MatchSource.WIKI,doc/master/TGeoMatrix_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoMatrix_8cxx_source.html
https://root.cern/doc/master/TGeoMatrix_8h.html:213,Integrability,depend,dependency,213,". ROOT: geom/geom/inc/TGeoMatrix.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Variables ; TGeoMatrix.h File Reference. #include ""TNamed.h"". Include dependency graph for TGeoMatrix.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  TGeoCombiTrans;  Class describing rotation + translation. More...;  ; class  TGeoGenTrans;  Most general transformation, holding a translation, a rotation and a scale. More...;  ; class  TGeoHMatrix;  Matrix class used for computing global transformations Should NOT be used for node definition. More...;  ; class  TGeoIdentity;  An identity transformation. More...;  ; class  TGeoMatrix;  Geometrical transformation package. More...;  ; class  TGeoRotation;  Class describing rotations. More...;  ; class  TGeoScale;  Class describing scale transformations. More...;  ; class  TGeoTranslation;  Class describing translations. More...;  . Variables; R__EXTERN TGeoIdentity * gGeoIdentity;  ; const Double_t kIdentityMatrix [3 *3] = {1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0};  ; const Double_t kNullVector [3] = {0.0, 0.0, 0.0};  ; const Double_t kUnitScale [3] = {1.0, 1.0, 1.0};  . Variable Documentation. ◆ gGeoIdentity. R__EXTERN TGeoIdentity* gGeoIdentity. Definition at line 537 of file TGeoMatrix.h. ◆ kIdentityMatrix. const Double_t kIdentityMatrix[3 *3] = {1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0}. Definition at line 26 of file TGeoMatrix.h. ◆ kNullVector. const Double_t kNullVector[3] = {0.0, 0.0, 0.0}. Definition at line 24 of file TGeoMatrix.h. ◆ kUnitScale. const Double_t kUnitScale[3] = {1.0, 1.0, 1.0}. Definition at line 28 of file TGeoMatrix.h. geomgeomincTGeoMatrix.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:15 (GVA Time) using Doxygen 1.9.",MatchSource.WIKI,doc/master/TGeoMatrix_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoMatrix_8h.html
https://root.cern/doc/master/TGeoMatrix_8h_source.html:20610,Availability,down,down,20610,"2 void MasterToLocalVect(const Double_t *master, Double_t *local) const override; 433 {; 434 memcpy(local, master, 3 * sizeof(Double_t));; 435 }; 436 void MasterToLocalBomb(const Double_t *master, Double_t *local) const override; 437 {; 438 TGeoIdentity::MasterToLocal(master, local);; 439 }; 440 ; 441 const Double_t *GetTranslation() const override { return &kNullVector[0]; }; 442 const Double_t *GetRotationMatrix() const override { return &kIdentityMatrix[0]; }; 443 const Double_t *GetScale() const override { return &kUnitScale[0]; }; 444 void SavePrimitive(std::ostream &, Option_t * = """") override {}; 445 ; 446 ClassDefOverride(TGeoIdentity, 1) // identity transformation class; 447};; 448 ; 449////////////////////////////////////////////////////////////////////////////; 450// //; 451// TGeoHMatrix - Matrix class used for computing global transformations //; 452// Should NOT be used for node definition. An instance of this class //; 453// is generally used to pile-up local transformations starting from //; 454// the top level physical node, down to the current node. //; 455// //; 456////////////////////////////////////////////////////////////////////////////; 457 ; 458class TGeoHMatrix : public TGeoMatrix {; 459private:; 460 Double_t fTranslation[3]; // translation component; 461 Double_t fRotationMatrix[9]; // rotation matrix; 462 Double_t fScale[3]; // scale component; 463 ; 464public:; 465 TGeoHMatrix();; 466 TGeoHMatrix(const TGeoHMatrix &other) : TGeoHMatrix((TGeoMatrix &)other) {}; 467 TGeoHMatrix(const TGeoMatrix &matrix);; 468 TGeoHMatrix(const char *name);; 469 ~TGeoHMatrix() override;; 470 ; 471 TGeoHMatrix &operator=(const TGeoHMatrix &other) { return TGeoHMatrix::operator=((TGeoMatrix &)other); }; 472 TGeoHMatrix &operator=(const TGeoMatrix *other);; 473 TGeoHMatrix &operator=(const TGeoMatrix &other);; 474 TGeoHMatrix &operator*=(const TGeoMatrix &other);; 475 TGeoHMatrix operator*(const TGeoMatrix &other) const;; 476 Bool_t operator==(const TGeoMatrix",MatchSource.WIKI,doc/master/TGeoMatrix_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoMatrix_8h_source.html
https://root.cern/doc/master/TGeoMatrix_8h_source.html:44831,Performance,perform,performes,44831,"otation with the one specified by ROT.Definition TGeoMatrix.cxx:1411; TGeoRotation::RotateYvoid RotateY(Double_t angle) overrideRotate about Y axis of the master frame with angle expressed in degrees.Definition TGeoMatrix.cxx:1121; TGeoRotation::operator==Bool_t operator==(const TGeoRotation &other) constIs-equal operator.Definition TGeoMatrix.cxx:971; TGeoRotation::SetMatrixvoid SetMatrix(const Double_t *rot)Definition TGeoMatrix.h:230; TGeoRotation::RotateZvoid RotateZ(Double_t angle) overrideRotate about Z axis of the master frame with angle expressed in degrees.Definition TGeoMatrix.cxx:1144; TGeoRotation::LocalToMastervoid LocalToMaster(const Double_t *local, Double_t *master) const overrideconvert a point by multiplying its column vector (x, y, z, 1) to matrix inverseDefinition TGeoMatrix.cxx:1067; TGeoRotation::operator*=TGeoRotation & operator*=(const TGeoRotation &other)Composition.Definition TGeoMatrix.cxx:946; TGeoRotation::CheckMatrixvoid CheckMatrix()performes an orthogonality check and finds if the matrix is a reflection Warning(""CheckMatrix"",...Definition TGeoMatrix.cxx:1379; TGeoRotation::ReflectYvoid ReflectY(Bool_t leftside, Bool_t rotonly=kFALSE) overrideMultiply by a reflection respect to ZX.Definition TGeoMatrix.cxx:1185; TGeoRotation::GetPhiRotationDouble_t GetPhiRotation(Bool_t fixX=kFALSE) constReturns rotation angle about Z axis in degrees.Definition TGeoMatrix.cxx:1054; TGeoRotation::FastRotZvoid FastRotZ(const Double_t *sincos)Perform a rotation about Z having the sine/cosine of the rotation angle.Definition TGeoMatrix.cxx:1039; TGeoRotation::GetInversevoid GetInverse(Double_t *invmat) constGet the inverse rotation matrix (which is simply the transpose)Definition TGeoMatrix.cxx:1393; TGeoRotation::DeterminantDouble_t Determinant() constcomputes determinant of the rotation matrixDefinition TGeoMatrix.cxx:1364; TGeoRotation::GetAnglesvoid GetAngles(Double_t &theta1, Double_t &phi1, Double_t &theta2, Double_t &phi2, Double_t &theta3, Double_t",MatchSource.WIKI,doc/master/TGeoMatrix_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoMatrix_8h_source.html
https://root.cern/doc/master/TGeoMatrix_8h_source.html:45988,Testability,test,test,45988,"; TGeoRotation::ReflectYvoid ReflectY(Bool_t leftside, Bool_t rotonly=kFALSE) overrideMultiply by a reflection respect to ZX.Definition TGeoMatrix.cxx:1185; TGeoRotation::GetPhiRotationDouble_t GetPhiRotation(Bool_t fixX=kFALSE) constReturns rotation angle about Z axis in degrees.Definition TGeoMatrix.cxx:1054; TGeoRotation::FastRotZvoid FastRotZ(const Double_t *sincos)Perform a rotation about Z having the sine/cosine of the rotation angle.Definition TGeoMatrix.cxx:1039; TGeoRotation::GetInversevoid GetInverse(Double_t *invmat) constGet the inverse rotation matrix (which is simply the transpose)Definition TGeoMatrix.cxx:1393; TGeoRotation::DeterminantDouble_t Determinant() constcomputes determinant of the rotation matrixDefinition TGeoMatrix.cxx:1364; TGeoRotation::GetAnglesvoid GetAngles(Double_t &theta1, Double_t &phi1, Double_t &theta2, Double_t &phi2, Double_t &theta3, Double_t &phi3) constRetrieve rotation angles.Definition TGeoMatrix.cxx:1310; TGeoRotation::IsValidBool_t IsValid() constPerform orthogonality test for rotation.Definition TGeoMatrix.cxx:1008; TGeoRotation::MasterToLocalvoid MasterToLocal(const Double_t *master, Double_t *local) const overrideconvert a point by multiplying its column vector (x, y, z, 1) to matrixDefinition TGeoMatrix.cxx:1078; TGeoRotation::MakeCloneTGeoMatrix * MakeClone() const overrideMake a clone of this matrix.Definition TGeoMatrix.cxx:1089; TGeoRotation::operator*TGeoRotation operator*(const TGeoRotation &other) constDefinition TGeoMatrix.cxx:954; TGeoRotation::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave a primitive as a C++ statement(s) on output stream ""out"".Definition TGeoMatrix.cxx:1221; TGeoRotation::GetTranslationconst Double_t * GetTranslation() const overrideDefinition TGeoMatrix.h:238; TGeoRotation::ReflectXvoid ReflectX(Bool_t leftside, Bool_t rotonly=kFALSE) overrideMultiply by a reflection respect to YZ.Definition TGeoMatrix.cxx:1167; TGeoRotation::fRotationMatrixDouble_t f",MatchSource.WIKI,doc/master/TGeoMatrix_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoMatrix_8h_source.html
https://root.cern/doc/master/TGeoMatrix_8h_source.html:45540,Usability,simpl,simply,45540,"onst Double_t *local, Double_t *master) const overrideconvert a point by multiplying its column vector (x, y, z, 1) to matrix inverseDefinition TGeoMatrix.cxx:1067; TGeoRotation::operator*=TGeoRotation & operator*=(const TGeoRotation &other)Composition.Definition TGeoMatrix.cxx:946; TGeoRotation::CheckMatrixvoid CheckMatrix()performes an orthogonality check and finds if the matrix is a reflection Warning(""CheckMatrix"",...Definition TGeoMatrix.cxx:1379; TGeoRotation::ReflectYvoid ReflectY(Bool_t leftside, Bool_t rotonly=kFALSE) overrideMultiply by a reflection respect to ZX.Definition TGeoMatrix.cxx:1185; TGeoRotation::GetPhiRotationDouble_t GetPhiRotation(Bool_t fixX=kFALSE) constReturns rotation angle about Z axis in degrees.Definition TGeoMatrix.cxx:1054; TGeoRotation::FastRotZvoid FastRotZ(const Double_t *sincos)Perform a rotation about Z having the sine/cosine of the rotation angle.Definition TGeoMatrix.cxx:1039; TGeoRotation::GetInversevoid GetInverse(Double_t *invmat) constGet the inverse rotation matrix (which is simply the transpose)Definition TGeoMatrix.cxx:1393; TGeoRotation::DeterminantDouble_t Determinant() constcomputes determinant of the rotation matrixDefinition TGeoMatrix.cxx:1364; TGeoRotation::GetAnglesvoid GetAngles(Double_t &theta1, Double_t &phi1, Double_t &theta2, Double_t &phi2, Double_t &theta3, Double_t &phi3) constRetrieve rotation angles.Definition TGeoMatrix.cxx:1310; TGeoRotation::IsValidBool_t IsValid() constPerform orthogonality test for rotation.Definition TGeoMatrix.cxx:1008; TGeoRotation::MasterToLocalvoid MasterToLocal(const Double_t *master, Double_t *local) const overrideconvert a point by multiplying its column vector (x, y, z, 1) to matrixDefinition TGeoMatrix.cxx:1078; TGeoRotation::MakeCloneTGeoMatrix * MakeClone() const overrideMake a clone of this matrix.Definition TGeoMatrix.cxx:1089; TGeoRotation::operator*TGeoRotation operator*(const TGeoRotation &other) constDefinition TGeoMatrix.cxx:954; TGeoRotation::SavePrimitivevoid",MatchSource.WIKI,doc/master/TGeoMatrix_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoMatrix_8h_source.html
https://root.cern/doc/master/TGeoMedium_8cxx_source.html:8483,Availability,error,error,8483,"fParamsDouble_t fParams[20]Definition TGeoMedium.h:29; TGeoMedium::kMedSavePrimitive@ kMedSavePrimitiveDefinition TGeoMedium.h:25; TGeoMedium::operator=TGeoMedium & operator=(const TGeoMedium &)assignment operatorDefinition TGeoMedium.cxx:108; TGeoMedium::fIdInt_t fIdDefinition TGeoMedium.h:28; TGeoMedium::GetPointerNameconst char * GetPointerName() constProvide a pointer name containing uid.Definition TGeoMedium.cxx:128; TGeoMedium::TGeoMediumTGeoMedium()Default constructor.Definition TGeoMedium.cxx:35; TGeoMedium::~TGeoMedium~TGeoMedium() overrideDestructor.Definition TGeoMedium.cxx:123; TIterDefinition TCollection.h:235; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TNamed::fNameTString fNameDefinition TNamed.h:32; TNamed::operator=TNamed & operator=(const TNamed &rhs)TNamed assignment operator.Definition TNamed.cxx:51; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::GetUniqueIDvirtual UInt_t GetUniqueID() constReturn the unique object id.Definition TObject.cxx:462; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TStringBasic string class.Definition TString.h:139; TString::StripTSubString Strip(EStripType s=kTrailing, char c=' ') constReturn a substring of self stripped at beginning and/or end.Definition TString.cxx:1163; TString::Formvoid Form(const char *fmt,...)Formats a string using a printf style format descriptor.Definition TString.cxx:2356; double; int; unsigned int. geomgeomsrcTGeoMedium.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:14 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TGeoMedium_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoMedium_8cxx_source.html
https://root.cern/doc/master/TGeoMedium_8cxx_source.html:1269,Integrability,interface,interfaces,1269,"2// Author: Rene Brun 26/12/02; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/** \class TGeoMedium; 13\ingroup Materials_classes; 14 ; 15Media are used to store properties related to tracking and which are useful; 16only when using geometry with a particle transport MC package (via VMC). One; 17may define several tracking media for a given material. The media ID are user; 18defined values that are not used by the geometry package. In case geometry; 19is used via VMC (in GEANT) these numbers are overwritten, so one can only; 20rely on these values after gMC->FinishGeometry() is called.; 21The media parameters are inspired from GEANT3 and the values defined make sense; 22in context of GEANT (3 but also 4) or FLUKA interfaces.; 23*/; 24 ; 25#include <iostream>; 26#include ""TGeoManager.h""; 27#include ""TGeoMedium.h""; 28#include ""TList.h""; 29 ; 30ClassImp(TGeoMedium);; 31 ; 32////////////////////////////////////////////////////////////////////////////////; 33/// Default constructor; 34 ; 35TGeoMedium::TGeoMedium(); 36{; 37 fId = 0;; 38 for (Int_t i = 0; i < 20; i++); 39 fParams[i] = 0.;; 40 fMaterial = nullptr;; 41}; 42 ; 43////////////////////////////////////////////////////////////////////////////////; 44/// constructor; 45 ; 46TGeoMedium::TGeoMedium(const char *name, Int_t numed, const TGeoMaterial *mat, Double_t *params) : TNamed(name, """"); 47{; 48 fName = fName.Strip();; 49 fId = numed;; 50 for (Int_t i = 0; i < 20; i++); 51 fParams[i] = 0.;; 52 fMaterial = (TGeoMaterial *)mat;; 53 for (Int_t i = 0; i < 10; i++) {; 54 if (params); 55 fParams[i] = params[i];; 56 else; 57 fParams[i] = 0;; 58 }; 59 gGeoManager->GetListOfMedia()->Add(this)",MatchSource.WIKI,doc/master/TGeoMedium_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoMedium_8cxx_source.html
https://root.cern/doc/master/TGeoMedium_8cxx_source.html:8489,Integrability,message,message,8489,"fParamsDouble_t fParams[20]Definition TGeoMedium.h:29; TGeoMedium::kMedSavePrimitive@ kMedSavePrimitiveDefinition TGeoMedium.h:25; TGeoMedium::operator=TGeoMedium & operator=(const TGeoMedium &)assignment operatorDefinition TGeoMedium.cxx:108; TGeoMedium::fIdInt_t fIdDefinition TGeoMedium.h:28; TGeoMedium::GetPointerNameconst char * GetPointerName() constProvide a pointer name containing uid.Definition TGeoMedium.cxx:128; TGeoMedium::TGeoMediumTGeoMedium()Default constructor.Definition TGeoMedium.cxx:35; TGeoMedium::~TGeoMedium~TGeoMedium() overrideDestructor.Definition TGeoMedium.cxx:123; TIterDefinition TCollection.h:235; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TNamed::fNameTString fNameDefinition TNamed.h:32; TNamed::operator=TNamed & operator=(const TNamed &rhs)TNamed assignment operator.Definition TNamed.cxx:51; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::GetUniqueIDvirtual UInt_t GetUniqueID() constReturn the unique object id.Definition TObject.cxx:462; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TStringBasic string class.Definition TString.h:139; TString::StripTSubString Strip(EStripType s=kTrailing, char c=' ') constReturn a substring of self stripped at beginning and/or end.Definition TString.cxx:1163; TString::Formvoid Form(const char *fmt,...)Formats a string using a printf style format descriptor.Definition TString.cxx:2356; double; int; unsigned int. geomgeomsrcTGeoMedium.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:14 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TGeoMedium_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoMedium_8cxx_source.html
https://root.cern/doc/master/TGeoNavigator_8h_source.html:5172,Availability,down,downwards,5172,"lMatrix; //! current pointer to cached global matrix; 83 TGeoHMatrix *fDivMatrix; //! current local matrix of the selected division cell; 84 TString fPath; //! path to current node; 85 ; 86 static Bool_t fgUsePWSafetyCaching; //! global mode is caching enabled for parallel world safety calls; 87 ; 88public:; 89 TGeoNavigator();; 90 TGeoNavigator(TGeoManager *geom);; 91 ~TGeoNavigator() override;; 92 ; 93 void BuildCache(Bool_t dummy = kFALSE, Bool_t nodeid = kFALSE);; 94 Bool_t cd(const char *path = """");; 95 Bool_t CheckPath(const char *path) const;; 96 void CdNode(Int_t nodeid);; 97 void CdDown(Int_t index);; 98 void CdDown(TGeoNode *node);; 99 void CdUp();; 100 void CdTop();; 101 void CdNext();; 102 void GetBranchNames(Int_t *names) const;; 103 void GetBranchNumbers(Int_t *copyNumbers, Int_t *volumeNumbers) const;; 104 void GetBranchOnlys(Int_t *isonly) const;; 105 Int_t GetNmany() const { return fNmany; }; 106 //--- geometry queries; 107 TGeoNode *CrossBoundaryAndLocate(Bool_t downwards, TGeoNode *skipnode);; 108 TGeoNode *FindNextBoundary(Double_t stepmax = TGeoShape::Big(), const char *path = """", Bool_t frombdr = kFALSE);; 109 TGeoNode *FindNextDaughterBoundary(Double_t *point, Double_t *dir, Int_t &idaughter, Bool_t compmatrix = kFALSE);; 110 TGeoNode *FindNextBoundaryAndStep(Double_t stepmax = TGeoShape::Big(), Bool_t compsafe = kFALSE);; 111 TGeoNode *FindNode(Bool_t safe_start = kTRUE);; 112 TGeoNode *FindNode(Double_t x, Double_t y, Double_t z);; 113 Double_t *FindNormal(Bool_t forward = kTRUE);; 114 Double_t *FindNormalFast();; 115 TGeoNode *InitTrack(const Double_t *point, const Double_t *dir);; 116 TGeoNode *InitTrack(Double_t x, Double_t y, Double_t z, Double_t nx, Double_t ny, Double_t nz);; 117 void ResetState();; 118 void ResetAll();; 119 Double_t Safety(Bool_t inside = kFALSE);; 120 TGeoNode *SearchNode(Bool_t downwards = kFALSE, const TGeoNode *skipnode = nullptr);; 121 TGeoNode *Step(Bool_t is_geom = kTRUE, Bool_t cross = kTRUE);; 122 const Doubl",MatchSource.WIKI,doc/master/TGeoNavigator_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoNavigator_8h_source.html
https://root.cern/doc/master/TGeoNavigator_8h_source.html:6037,Availability,down,downwards,6037,"y) const;; 105 Int_t GetNmany() const { return fNmany; }; 106 //--- geometry queries; 107 TGeoNode *CrossBoundaryAndLocate(Bool_t downwards, TGeoNode *skipnode);; 108 TGeoNode *FindNextBoundary(Double_t stepmax = TGeoShape::Big(), const char *path = """", Bool_t frombdr = kFALSE);; 109 TGeoNode *FindNextDaughterBoundary(Double_t *point, Double_t *dir, Int_t &idaughter, Bool_t compmatrix = kFALSE);; 110 TGeoNode *FindNextBoundaryAndStep(Double_t stepmax = TGeoShape::Big(), Bool_t compsafe = kFALSE);; 111 TGeoNode *FindNode(Bool_t safe_start = kTRUE);; 112 TGeoNode *FindNode(Double_t x, Double_t y, Double_t z);; 113 Double_t *FindNormal(Bool_t forward = kTRUE);; 114 Double_t *FindNormalFast();; 115 TGeoNode *InitTrack(const Double_t *point, const Double_t *dir);; 116 TGeoNode *InitTrack(Double_t x, Double_t y, Double_t z, Double_t nx, Double_t ny, Double_t nz);; 117 void ResetState();; 118 void ResetAll();; 119 Double_t Safety(Bool_t inside = kFALSE);; 120 TGeoNode *SearchNode(Bool_t downwards = kFALSE, const TGeoNode *skipnode = nullptr);; 121 TGeoNode *Step(Bool_t is_geom = kTRUE, Bool_t cross = kTRUE);; 122 const Double_t *GetLastPoint() const { return fLastPoint; }; 123 Int_t GetVirtualLevel();; 124 Bool_t GotoSafeLevel();; 125 Int_t GetSafeLevel() const;; 126 Double_t GetSafeDistance() const { return fSafety; }; 127 Double_t GetLastSafety() const { return fLastSafety; }; 128 Double_t GetStep() const { return fStep; }; 129 Int_t GetThreadId() const { return fThreadId; }; 130 void InspectState() const;; 131 Bool_t IsSafeStep(Double_t proposed, Double_t &newsafety) const;; 132 Bool_t IsSameLocation(Double_t x, Double_t y, Double_t z, Bool_t change = kFALSE);; 133 Bool_t IsSameLocation() const { return fIsSameLocation; }; 134 Bool_t IsSamePoint(Double_t x, Double_t y, Double_t z) const;; 135 Bool_t IsStartSafe() const { return fStartSafe; }; 136 void SetStartSafe(Bool_t flag = kTRUE) { fStartSafe = flag; }; 137 void SetStep(Double_t step) { fStep = step; }; 138 Bool_t ",MatchSource.WIKI,doc/master/TGeoNavigator_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoNavigator_8h_source.html
https://root.cern/doc/master/TGeoNavigator_8h_source.html:10406,Availability,avail,available,10406,"ble_t z); 180 {; 181 fLastPoint[0] = x;; 182 fLastPoint[1] = y;; 183 fLastPoint[2] = z;; 184 }; 185 void SetCurrentDirection(const Double_t *dir) { memcpy(fDirection, dir, 3 * sizeof(Double_t)); }; 186 void SetCurrentDirection(Double_t nx, Double_t ny, Double_t nz); 187 {; 188 fDirection[0] = nx;; 189 fDirection[1] = ny;; 190 fDirection[2] = nz;; 191 }; 192 // void SetNormalChecked(Double_t norm) {fNormalChecked=norm;}; 193 void SetCldirChecked(Double_t *dir) { memcpy(fCldirChecked, dir, 3 * sizeof(Double_t)); }; 194 void SetLastSafetyForPoint(Double_t safe, const Double_t *point); 195 {; 196 fLastSafety = safe;; 197 memcpy(fLastPoint, point, 3 * sizeof(Double_t));; 198 }; 199 void SetLastSafetyForPoint(Double_t safe, Double_t x, Double_t y, Double_t z); 200 {; 201 fLastSafety = safe;; 202 fLastPoint[0] = x;; 203 fLastPoint[1] = y, fLastPoint[2] = z;; 204 }; 205 ; 206 // Check if we have a cached safety value from parallel world, and if this can still be used.; 207 // Return negative value if no cache available.; 208 Double_t GetPWSafetyEstimateFromCache(Double_t cpoint[3]) const; 209 {; 210 // disregard too small or invalid safeties; 211 if (fLastPWSafety < TGeoShape::Tolerance()) {; 212 return -1.;; 213 }; 214 const auto d0 = fLastPWSaftyPnt[0] - cpoint[0];; 215 const auto d1 = fLastPWSaftyPnt[1] - cpoint[1];; 216 const auto d2 = fLastPWSaftyPnt[2] - cpoint[2];; 217 const auto d_sq = d0 * d0 + d1 * d1 + d2 * d2;; 218 // if we have moved too much return -1 as ""invalid""; 219 if (d_sq >= (fLastPWSafety * fLastPWSafety)) {; 220 return -1.;; 221 }; 222 // or return a reasonable cache estimate for safety; 223 return fLastPWSafety - std::sqrt(d_sq);; 224 }; 225 ; 226 // Wrapper for getting the safety from the parallel world.; 227 // Takes care of caching mechanics and talking to the Safety function of parallel world.; 228 Double_t GetPWSafety(Double_t cpoint[3], Double_t saf_max);; 229 ; 230 // enable/disable parallel world safety caching; 231 static void SetPWSafetyCachi",MatchSource.WIKI,doc/master/TGeoNavigator_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoNavigator_8h_source.html
https://root.cern/doc/master/TGeoNavigator_8h_source.html:19482,Availability,down,downwards,19482,"finition TGeoNavigator.h:52; TGeoNavigator::DoRestoreStatevoid DoRestoreState()Restore a backed-up state without affecting the cache stack.Definition TGeoNavigator.cxx:2657; TGeoNavigator::fPointDouble_t fPoint[3]unit vector to current checked shapeDefinition TGeoNavigator.h:49; TGeoNavigator::IsStepExitingBool_t IsStepExiting() constDefinition TGeoNavigator.h:143; TGeoNavigator::fSearchOverlapsBool_t fSearchOverlapsinternal array for overlapsDefinition TGeoNavigator.h:61; TGeoNavigator::fIsExitingBool_t fIsExitingflag if current step just got into a new nodeDefinition TGeoNavigator.h:65; TGeoNavigator::fPathTString fPathcurrent local matrix of the selected division cellDefinition TGeoNavigator.h:84; TGeoNavigator::fDivMatrixTGeoHMatrix * fDivMatrixcurrent pointer to cached global matrixDefinition TGeoNavigator.h:83; TGeoNavigator::PopPathBool_t PopPath()Definition TGeoNavigator.h:247; TGeoNavigator::CrossBoundaryAndLocateTGeoNode * CrossBoundaryAndLocate(Bool_t downwards, TGeoNode *skipnode)Cross next boundary and locate within current node The current point must be on the boundary of fCurr...Definition TGeoNavigator.cxx:523; TGeoNavigator::fLastPWSafetyDouble_t fLastPWSafetylast point for which parallel world safety was ""evaluated""Definition TGeoNavigator.h:53; TGeoNavigator::GetHMatrixTGeoHMatrix * GetHMatrix()Return stored current matrix (global matrix of the next touched node).Definition TGeoNavigator.cxx:2670; TGeoNavigator::IsCheckingOverlapsBool_t IsCheckingOverlaps() constDefinition TGeoNavigator.h:138; TGeoNavigator::LocalToMastervoid LocalToMaster(const Double_t *local, Double_t *master) constDefinition TGeoNavigator.h:235; TGeoNavigator::fCacheTGeoNodeCache * fCachecurrent geometryDefinition TGeoNavigator.h:73; TGeoNavigator::fStartSafeBool_t fStartSafeflags the type of the current nodeDefinition TGeoNavigator.h:63; TGeoNavigator::CdNextvoid CdNext()Do a cd to the node found next by FindNextBoundary.Definition TGeoNavigator.cxx:405; TGeoNavigator::GetNext",MatchSource.WIKI,doc/master/TGeoNavigator_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoNavigator_8h_source.html
https://root.cern/doc/master/TGeoNavigator_8h_source.html:31177,Availability,down,downwards,31177,"e to master.Definition TGeoNavigator.cxx:2700; TGeoNavigator::SetCurrentPointvoid SetCurrentPoint(const Double_t *point)Definition TGeoNavigator.h:172; TGeoNavigator::fCurrentMatrixTGeoHMatrix * fCurrentMatrixbackup stateDefinition TGeoNavigator.h:81; TGeoNavigator::fOverlapClustersInt_t * fOverlapClusterscurrent recursive position in fOverlapClustersDefinition TGeoNavigator.h:60; TGeoNavigator::GetCldirconst Double_t * GetCldir() constDefinition TGeoNavigator.h:165; TGeoNavigator::fTopNodeTGeoNode * fTopNodecurrent nodeDefinition TGeoNavigator.h:76; TGeoNavigator::LocalToMasterVectvoid LocalToMasterVect(const Double_t *local, Double_t *master) constDefinition TGeoNavigator.h:236; TGeoNavigator::IsSafeStepBool_t IsSafeStep(Double_t proposed, Double_t &newsafety) constIn case a previous safety value was computed, check if the safety region is still safe for the curren...Definition TGeoNavigator.cxx:2609; TGeoNavigator::SearchNodeTGeoNode * SearchNode(Bool_t downwards=kFALSE, const TGeoNode *skipnode=nullptr)Returns the deepest node containing fPoint, which must be set a priori.Definition TGeoNavigator.cxx:1924; TGeoNavigator::fLastSafetyDouble_t fLastSafetysafety radius from current pointDefinition TGeoNavigator.h:45; TGeoNavigator::~TGeoNavigator~TGeoNavigator() overrideDestructor.Definition TGeoNavigator.cxx:169; TGeoNavigator::TGeoNavigatorTGeoNavigator()global mode is caching enabled for parallel world safety callsDefinition TGeoNavigator.cxx:57; TGeoNavigator::SetCurrentDirectionvoid SetCurrentDirection(const Double_t *dir)Definition TGeoNavigator.h:185; TGeoNavigator::BuildCachevoid BuildCache(Bool_t dummy=kFALSE, Bool_t nodeid=kFALSE)Builds the cache for physical nodes and global matrices.Definition TGeoNavigator.cxx:182; TGeoNavigator::fNextDaughterIndexInt_t fNextDaughterIndexnumber of overlapping nodes on current branchDefinition TGeoNavigator.h:57; TGeoNavigator::PopPathBool_t PopPath(Int_t index)Definition TGeoNavigator.h:255; TGeoNavigator::fIsNullStepBo",MatchSource.WIKI,doc/master/TGeoNavigator_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoNavigator_8h_source.html
https://root.cern/doc/master/TGeoNavigator_8h_source.html:3691,Performance,cache,cache,3691,"pClusters; 60 Int_t *fOverlapClusters; //! internal array for overlaps; 61 Bool_t fSearchOverlaps; //! flag set when an overlapping cluster is searched; 62 Bool_t fCurrentOverlapping; //! flags the type of the current node; 63 Bool_t fStartSafe; //! flag a safe start for point classification; 64 Bool_t fIsEntering; //! flag if current step just got into a new node; 65 Bool_t fIsExiting; //! flag that current track is about to leave current node; 66 Bool_t fIsStepEntering; //! flag that next geometric step will enter new volume; 67 Bool_t fIsStepExiting; //! flag that next geometric step will exit current volume; 68 Bool_t fIsOutside; //! flag that current point is outside geometry; 69 Bool_t fIsOnBoundary; //! flag that current point is on some boundary; 70 Bool_t fIsSameLocation; //! flag that a new point is in the same node as previous; 71 Bool_t fIsNullStep; //! flag that last geometric step was null; 72 TGeoManager *fGeometry; //! current geometry; 73 TGeoNodeCache *fCache; //! cache of states; 74 TGeoVolume *fCurrentVolume; //! current volume; 75 TGeoNode *fCurrentNode; //! current node; 76 TGeoNode *fTopNode; //! top physical node; 77 TGeoNode *fLastNode; //! last searched node; 78 TGeoNode *fNextNode; //! next node that will be crossed; 79 TGeoNode *fForcedNode; //! current point is supposed to be inside this node; 80 TGeoCacheState *fBackupState; //! backup state; 81 TGeoHMatrix *fCurrentMatrix; //! current stored global matrix; 82 TGeoHMatrix *fGlobalMatrix; //! current pointer to cached global matrix; 83 TGeoHMatrix *fDivMatrix; //! current local matrix of the selected division cell; 84 TString fPath; //! path to current node; 85 ; 86 static Bool_t fgUsePWSafetyCaching; //! global mode is caching enabled for parallel world safety calls; 87 ; 88public:; 89 TGeoNavigator();; 90 TGeoNavigator(TGeoManager *geom);; 91 ~TGeoNavigator() override;; 92 ; 93 void BuildCache(Bool_t dummy = kFALSE, Bool_t nodeid = kFALSE);; 94 Bool_t cd(const char *path = """");; 95 Boo",MatchSource.WIKI,doc/master/TGeoNavigator_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoNavigator_8h_source.html
https://root.cern/doc/master/TGeoNavigator_8h_source.html:4209,Performance,cache,cached,4209,"ter new volume; 67 Bool_t fIsStepExiting; //! flag that next geometric step will exit current volume; 68 Bool_t fIsOutside; //! flag that current point is outside geometry; 69 Bool_t fIsOnBoundary; //! flag that current point is on some boundary; 70 Bool_t fIsSameLocation; //! flag that a new point is in the same node as previous; 71 Bool_t fIsNullStep; //! flag that last geometric step was null; 72 TGeoManager *fGeometry; //! current geometry; 73 TGeoNodeCache *fCache; //! cache of states; 74 TGeoVolume *fCurrentVolume; //! current volume; 75 TGeoNode *fCurrentNode; //! current node; 76 TGeoNode *fTopNode; //! top physical node; 77 TGeoNode *fLastNode; //! last searched node; 78 TGeoNode *fNextNode; //! next node that will be crossed; 79 TGeoNode *fForcedNode; //! current point is supposed to be inside this node; 80 TGeoCacheState *fBackupState; //! backup state; 81 TGeoHMatrix *fCurrentMatrix; //! current stored global matrix; 82 TGeoHMatrix *fGlobalMatrix; //! current pointer to cached global matrix; 83 TGeoHMatrix *fDivMatrix; //! current local matrix of the selected division cell; 84 TString fPath; //! path to current node; 85 ; 86 static Bool_t fgUsePWSafetyCaching; //! global mode is caching enabled for parallel world safety calls; 87 ; 88public:; 89 TGeoNavigator();; 90 TGeoNavigator(TGeoManager *geom);; 91 ~TGeoNavigator() override;; 92 ; 93 void BuildCache(Bool_t dummy = kFALSE, Bool_t nodeid = kFALSE);; 94 Bool_t cd(const char *path = """");; 95 Bool_t CheckPath(const char *path) const;; 96 void CdNode(Int_t nodeid);; 97 void CdDown(Int_t index);; 98 void CdDown(TGeoNode *node);; 99 void CdUp();; 100 void CdTop();; 101 void CdNext();; 102 void GetBranchNames(Int_t *names) const;; 103 void GetBranchNumbers(Int_t *copyNumbers, Int_t *volumeNumbers) const;; 104 void GetBranchOnlys(Int_t *isonly) const;; 105 Int_t GetNmany() const { return fNmany; }; 106 //--- geometry queries; 107 TGeoNode *CrossBoundaryAndLocate(Bool_t downwards, TGeoNode *skipnode);; 108 TGeo",MatchSource.WIKI,doc/master/TGeoNavigator_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoNavigator_8h_source.html
https://root.cern/doc/master/TGeoNavigator_8h_source.html:10292,Performance,cache,cached,10292,"CurrentNodeId() const { return fCache->GetCurrentNodeId(); }; 161 const Double_t *GetCurrentPoint() const { return fPoint; }; 162 const Double_t *GetCurrentDirection() const { return fDirection; }; 163 TGeoVolume *GetCurrentVolume() const { return fCurrentNode->GetVolume(); }; 164 const Double_t *GetCldirChecked() const { return fCldirChecked; }; 165 const Double_t *GetCldir() const { return fCldir; }; 166 TGeoHMatrix *GetDivMatrix() const { return fDivMatrix; }; 167 // Double_t GetNormalChecked() const {return fNormalChecked;}; 168 const Double_t *GetNormal() const { return fNormal; }; 169 Int_t GetLevel() const { return fLevel; }; 170 const char *GetPath() const;; 171 Int_t GetStackLevel() const { return fCache->GetStackLevel(); }; 172 void SetCurrentPoint(const Double_t *point) { memcpy(fPoint, point, 3 * sizeof(Double_t)); }; 173 void SetCurrentPoint(Double_t x, Double_t y, Double_t z); 174 {; 175 fPoint[0] = x;; 176 fPoint[1] = y;; 177 fPoint[2] = z;; 178 }; 179 void SetLastPoint(Double_t x, Double_t y, Double_t z); 180 {; 181 fLastPoint[0] = x;; 182 fLastPoint[1] = y;; 183 fLastPoint[2] = z;; 184 }; 185 void SetCurrentDirection(const Double_t *dir) { memcpy(fDirection, dir, 3 * sizeof(Double_t)); }; 186 void SetCurrentDirection(Double_t nx, Double_t ny, Double_t nz); 187 {; 188 fDirection[0] = nx;; 189 fDirection[1] = ny;; 190 fDirection[2] = nz;; 191 }; 192 // void SetNormalChecked(Double_t norm) {fNormalChecked=norm;}; 193 void SetCldirChecked(Double_t *dir) { memcpy(fCldirChecked, dir, 3 * sizeof(Double_t)); }; 194 void SetLastSafetyForPoint(Double_t safe, const Double_t *point); 195 {; 196 fLastSafety = safe;; 197 memcpy(fLastPoint, point, 3 * sizeof(Double_t));; 198 }; 199 void SetLastSafetyForPoint(Double_t safe, Double_t x, Double_t y, Double_t z); 200 {; 201 fLastSafety = safe;; 202 fLastPoint[0] = x;; 203 fLastPoint[1] = y, fLastPoint[2] = z;; 204 }; 205 ; 206 // Check if we have a cached safety value from parallel world, and if this can still be used.",MatchSource.WIKI,doc/master/TGeoNavigator_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoNavigator_8h_source.html
https://root.cern/doc/master/TGeoNavigator_8h_source.html:10400,Performance,cache,cache,10400,"ble_t z); 180 {; 181 fLastPoint[0] = x;; 182 fLastPoint[1] = y;; 183 fLastPoint[2] = z;; 184 }; 185 void SetCurrentDirection(const Double_t *dir) { memcpy(fDirection, dir, 3 * sizeof(Double_t)); }; 186 void SetCurrentDirection(Double_t nx, Double_t ny, Double_t nz); 187 {; 188 fDirection[0] = nx;; 189 fDirection[1] = ny;; 190 fDirection[2] = nz;; 191 }; 192 // void SetNormalChecked(Double_t norm) {fNormalChecked=norm;}; 193 void SetCldirChecked(Double_t *dir) { memcpy(fCldirChecked, dir, 3 * sizeof(Double_t)); }; 194 void SetLastSafetyForPoint(Double_t safe, const Double_t *point); 195 {; 196 fLastSafety = safe;; 197 memcpy(fLastPoint, point, 3 * sizeof(Double_t));; 198 }; 199 void SetLastSafetyForPoint(Double_t safe, Double_t x, Double_t y, Double_t z); 200 {; 201 fLastSafety = safe;; 202 fLastPoint[0] = x;; 203 fLastPoint[1] = y, fLastPoint[2] = z;; 204 }; 205 ; 206 // Check if we have a cached safety value from parallel world, and if this can still be used.; 207 // Return negative value if no cache available.; 208 Double_t GetPWSafetyEstimateFromCache(Double_t cpoint[3]) const; 209 {; 210 // disregard too small or invalid safeties; 211 if (fLastPWSafety < TGeoShape::Tolerance()) {; 212 return -1.;; 213 }; 214 const auto d0 = fLastPWSaftyPnt[0] - cpoint[0];; 215 const auto d1 = fLastPWSaftyPnt[1] - cpoint[1];; 216 const auto d2 = fLastPWSaftyPnt[2] - cpoint[2];; 217 const auto d_sq = d0 * d0 + d1 * d1 + d2 * d2;; 218 // if we have moved too much return -1 as ""invalid""; 219 if (d_sq >= (fLastPWSafety * fLastPWSafety)) {; 220 return -1.;; 221 }; 222 // or return a reasonable cache estimate for safety; 223 return fLastPWSafety - std::sqrt(d_sq);; 224 }; 225 ; 226 // Wrapper for getting the safety from the parallel world.; 227 // Takes care of caching mechanics and talking to the Safety function of parallel world.; 228 Double_t GetPWSafety(Double_t cpoint[3], Double_t saf_max);; 229 ; 230 // enable/disable parallel world safety caching; 231 static void SetPWSafetyCachi",MatchSource.WIKI,doc/master/TGeoNavigator_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoNavigator_8h_source.html
https://root.cern/doc/master/TGeoNavigator_8h_source.html:10991,Performance,cache,cache,10991,"sizeof(Double_t));; 198 }; 199 void SetLastSafetyForPoint(Double_t safe, Double_t x, Double_t y, Double_t z); 200 {; 201 fLastSafety = safe;; 202 fLastPoint[0] = x;; 203 fLastPoint[1] = y, fLastPoint[2] = z;; 204 }; 205 ; 206 // Check if we have a cached safety value from parallel world, and if this can still be used.; 207 // Return negative value if no cache available.; 208 Double_t GetPWSafetyEstimateFromCache(Double_t cpoint[3]) const; 209 {; 210 // disregard too small or invalid safeties; 211 if (fLastPWSafety < TGeoShape::Tolerance()) {; 212 return -1.;; 213 }; 214 const auto d0 = fLastPWSaftyPnt[0] - cpoint[0];; 215 const auto d1 = fLastPWSaftyPnt[1] - cpoint[1];; 216 const auto d2 = fLastPWSaftyPnt[2] - cpoint[2];; 217 const auto d_sq = d0 * d0 + d1 * d1 + d2 * d2;; 218 // if we have moved too much return -1 as ""invalid""; 219 if (d_sq >= (fLastPWSafety * fLastPWSafety)) {; 220 return -1.;; 221 }; 222 // or return a reasonable cache estimate for safety; 223 return fLastPWSafety - std::sqrt(d_sq);; 224 }; 225 ; 226 // Wrapper for getting the safety from the parallel world.; 227 // Takes care of caching mechanics and talking to the Safety function of parallel world.; 228 Double_t GetPWSafety(Double_t cpoint[3], Double_t saf_max);; 229 ; 230 // enable/disable parallel world safety caching; 231 static void SetPWSafetyCaching(Bool_t b) { fgUsePWSafetyCaching = b; }; 232 static Bool_t IsPWSafetyCaching() { return fgUsePWSafetyCaching; }; 233 ; 234 //--- point/vector reference frame conversion; 235 void LocalToMaster(const Double_t *local, Double_t *master) const { fCache->LocalToMaster(local, master); }; 236 void LocalToMasterVect(const Double_t *local, Double_t *master) const { fCache->LocalToMasterVect(local, master); }; 237 void LocalToMasterBomb(const Double_t *local, Double_t *master) const { fCache->LocalToMasterBomb(local, master); }; 238 void MasterToLocal(const Double_t *master, Double_t *local) const { fCache->MasterToLocal(master, local); }; 239 void Maste",MatchSource.WIKI,doc/master/TGeoNavigator_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoNavigator_8h_source.html
https://root.cern/doc/master/TGeoNavigator_8h_source.html:12507,Performance,cache,cache,12507,"; 234 //--- point/vector reference frame conversion; 235 void LocalToMaster(const Double_t *local, Double_t *master) const { fCache->LocalToMaster(local, master); }; 236 void LocalToMasterVect(const Double_t *local, Double_t *master) const { fCache->LocalToMasterVect(local, master); }; 237 void LocalToMasterBomb(const Double_t *local, Double_t *master) const { fCache->LocalToMasterBomb(local, master); }; 238 void MasterToLocal(const Double_t *master, Double_t *local) const { fCache->MasterToLocal(master, local); }; 239 void MasterToLocalVect(const Double_t *master, Double_t *local) const { fCache->MasterToLocalVect(master, local); }; 240 void MasterToLocalBomb(const Double_t *master, Double_t *local) const { fCache->MasterToLocalBomb(master, local); }; 241 void MasterToTop(const Double_t *master, Double_t *top) const;; 242 void TopToMaster(const Double_t *top, Double_t *master) const;; 243 TGeoNodeCache *GetCache() const { return fCache; }; 244 // void SetCache(const TGeoNodeCache *cache) {fCache = (TGeoNodeCache*)cache;}; 245 //--- stack manipulation; 246 Int_t PushPath(Int_t startlevel = 0) { return fCache->PushState(fCurrentOverlapping, startlevel, fNmany); }; 247 Bool_t PopPath(); 248 {; 249 fCurrentOverlapping = fCache->PopState(fNmany);; 250 fCurrentNode = fCache->GetNode();; 251 fLevel = fCache->GetLevel();; 252 fGlobalMatrix = fCache->GetCurrentMatrix();; 253 return fCurrentOverlapping;; 254 }; 255 Bool_t PopPath(Int_t index); 256 {; 257 fCurrentOverlapping = fCache->PopState(fNmany, index);; 258 fCurrentNode = fCache->GetNode();; 259 fLevel = fCache->GetLevel();; 260 fGlobalMatrix = fCache->GetCurrentMatrix();; 261 return fCurrentOverlapping;; 262 }; 263 Int_t PushPoint(Int_t startlevel = 0) { return fCache->PushState(fCurrentOverlapping, startlevel, fNmany, fPoint); }; 264 Bool_t PopPoint(); 265 {; 266 fCurrentOverlapping = fCache->PopState(fNmany, fPoint);; 267 fCurrentNode = fCache->GetNode();; 268 fLevel = fCache->GetLevel();; 269 fGlobalMatrix = fCache",MatchSource.WIKI,doc/master/TGeoNavigator_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoNavigator_8h_source.html
https://root.cern/doc/master/TGeoNavigator_8h_source.html:12540,Performance,cache,cache,12540,"e frame conversion; 235 void LocalToMaster(const Double_t *local, Double_t *master) const { fCache->LocalToMaster(local, master); }; 236 void LocalToMasterVect(const Double_t *local, Double_t *master) const { fCache->LocalToMasterVect(local, master); }; 237 void LocalToMasterBomb(const Double_t *local, Double_t *master) const { fCache->LocalToMasterBomb(local, master); }; 238 void MasterToLocal(const Double_t *master, Double_t *local) const { fCache->MasterToLocal(master, local); }; 239 void MasterToLocalVect(const Double_t *master, Double_t *local) const { fCache->MasterToLocalVect(master, local); }; 240 void MasterToLocalBomb(const Double_t *master, Double_t *local) const { fCache->MasterToLocalBomb(master, local); }; 241 void MasterToTop(const Double_t *master, Double_t *top) const;; 242 void TopToMaster(const Double_t *top, Double_t *master) const;; 243 TGeoNodeCache *GetCache() const { return fCache; }; 244 // void SetCache(const TGeoNodeCache *cache) {fCache = (TGeoNodeCache*)cache;}; 245 //--- stack manipulation; 246 Int_t PushPath(Int_t startlevel = 0) { return fCache->PushState(fCurrentOverlapping, startlevel, fNmany); }; 247 Bool_t PopPath(); 248 {; 249 fCurrentOverlapping = fCache->PopState(fNmany);; 250 fCurrentNode = fCache->GetNode();; 251 fLevel = fCache->GetLevel();; 252 fGlobalMatrix = fCache->GetCurrentMatrix();; 253 return fCurrentOverlapping;; 254 }; 255 Bool_t PopPath(Int_t index); 256 {; 257 fCurrentOverlapping = fCache->PopState(fNmany, index);; 258 fCurrentNode = fCache->GetNode();; 259 fLevel = fCache->GetLevel();; 260 fGlobalMatrix = fCache->GetCurrentMatrix();; 261 return fCurrentOverlapping;; 262 }; 263 Int_t PushPoint(Int_t startlevel = 0) { return fCache->PushState(fCurrentOverlapping, startlevel, fNmany, fPoint); }; 264 Bool_t PopPoint(); 265 {; 266 fCurrentOverlapping = fCache->PopState(fNmany, fPoint);; 267 fCurrentNode = fCache->GetNode();; 268 fLevel = fCache->GetLevel();; 269 fGlobalMatrix = fCache->GetCurrentMatrix();; 270 return",MatchSource.WIKI,doc/master/TGeoNavigator_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoNavigator_8h_source.html
https://root.cern/doc/master/TGeoNavigator_8h_source.html:16439,Performance,cache,cache,16439," RtypesCore.h:94; Double_tdouble Double_tDefinition RtypesCore.h:59; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; ClassDefOverride#define ClassDefOverride(name, id)Definition Rtypes.h:346; resultOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t resultDefinition TGWin32VirtualXProxy.cxx:174; indexOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t indexDefinition TGWin32VirtualXProxy.cxx:168; TGeoCache.h; TObjArray.h; TObject.h; TCollection::SetOwnervirtual void SetOwner(Bool_t enable=kTRUE)Set whether this collection is the owner (enable==true) of its content.Definition TCollection.cxx:746; TGeoCacheStateClass storing the state of the cache at a given moment.Definition TGeoCache.h:28; TGeoHMatrixMatrix class used for computing global transformations Should NOT be used for node definition.Definition TGeoMatrix.h:458; TGeoManagerThe manager class for any TGeo geometry.Definition TGeoManager.h:44; TGeoMatrixGeometrical transformation package.Definition TGeoMatrix.h:38; TGeoNavigatorArrayDefinition TGeoNavigator.h:294; TGeoNavigatorArray::TGeoNavigatorArrayTGeoNavigatorArray(const TGeoNavigatorArray &)=delete; TGeoNavigatorArray::TGeoNavigatorArrayTGeoNavigatorArray(TGeoManager *mgr)Definition TGeoNavigator.h:304; TGeoNavigatorArray::fCurrentNavigatorTGeoNavigator * fCurrentNavigatorDefinition TGeoNavigator.h:296; TGeoNavigatorArray::AddNavigatorTGeoNavigator * AddNavigator()Add a new navigator to the array.Definition TGeoNavigator.cxx:2745; TGeoNavigatorArray::TGeoNavigatorArrayTGeoNavigatorArray()Definition TGeoNavigator.h:303; TGeoNavigatorArray::GetCurrentNavigatorTGeoNavigator * GetCurrentNavigator()",MatchSource.WIKI,doc/master/TGeoNavigator_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoNavigator_8h_source.html
https://root.cern/doc/master/TGeoNavigator_8h_source.html:18147,Performance,cache,cache,18147,"ition TGeoNavigator.h:296; TGeoNavigatorArray::AddNavigatorTGeoNavigator * AddNavigator()Add a new navigator to the array.Definition TGeoNavigator.cxx:2745; TGeoNavigatorArray::TGeoNavigatorArrayTGeoNavigatorArray()Definition TGeoNavigator.h:303; TGeoNavigatorArray::GetCurrentNavigatorTGeoNavigator * GetCurrentNavigator() constDefinition TGeoNavigator.h:308; TGeoNavigatorArray::operator=TGeoNavigatorArray & operator=(const TGeoNavigatorArray &)=delete; TGeoNavigatorArray::fGeoManagerTGeoManager * fGeoManagerDefinition TGeoNavigator.h:297; TGeoNavigatorArray::SetCurrentNavigatorTGeoNavigator * SetCurrentNavigator(Int_t inav)Definition TGeoNavigator.h:309; TGeoNavigatorArray::~TGeoNavigatorArray~TGeoNavigatorArray() overrideDefinition TGeoNavigator.h:305; TGeoNavigatorClass providing navigation API for TGeo geometries.Definition TGeoNavigator.h:32; TGeoNavigator::CdUpvoid CdUp()Go one level up in geometry.Definition TGeoNavigator.cxx:352; TGeoNavigator::DoBackupStatevoid DoBackupState()Backup the current state without affecting the cache stack.Definition TGeoNavigator.cxx:2648; TGeoNavigator::GetMotherTGeoNode * GetMother(Int_t up=1) constDefinition TGeoNavigator.h:155; TGeoNavigator::SetCurrentPointvoid SetCurrentPoint(Double_t x, Double_t y, Double_t z)Definition TGeoNavigator.h:173; TGeoNavigator::fLastPWSaftyPntDouble_t fLastPWSaftyPnt[3]last point for which safety was computedDefinition TGeoNavigator.h:52; TGeoNavigator::DoRestoreStatevoid DoRestoreState()Restore a backed-up state without affecting the cache stack.Definition TGeoNavigator.cxx:2657; TGeoNavigator::fPointDouble_t fPoint[3]unit vector to current checked shapeDefinition TGeoNavigator.h:49; TGeoNavigator::IsStepExitingBool_t IsStepExiting() constDefinition TGeoNavigator.h:143; TGeoNavigator::fSearchOverlapsBool_t fSearchOverlapsinternal array for overlapsDefinition TGeoNavigator.h:61; TGeoNavigator::fIsExitingBool_t fIsExitingflag if current step just got into a new nodeDefinition TGeoNavigator.h:65; ",MatchSource.WIKI,doc/master/TGeoNavigator_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoNavigator_8h_source.html
https://root.cern/doc/master/TGeoNavigator_8h_source.html:18632,Performance,cache,cache,18632,"gerTGeoManager * fGeoManagerDefinition TGeoNavigator.h:297; TGeoNavigatorArray::SetCurrentNavigatorTGeoNavigator * SetCurrentNavigator(Int_t inav)Definition TGeoNavigator.h:309; TGeoNavigatorArray::~TGeoNavigatorArray~TGeoNavigatorArray() overrideDefinition TGeoNavigator.h:305; TGeoNavigatorClass providing navigation API for TGeo geometries.Definition TGeoNavigator.h:32; TGeoNavigator::CdUpvoid CdUp()Go one level up in geometry.Definition TGeoNavigator.cxx:352; TGeoNavigator::DoBackupStatevoid DoBackupState()Backup the current state without affecting the cache stack.Definition TGeoNavigator.cxx:2648; TGeoNavigator::GetMotherTGeoNode * GetMother(Int_t up=1) constDefinition TGeoNavigator.h:155; TGeoNavigator::SetCurrentPointvoid SetCurrentPoint(Double_t x, Double_t y, Double_t z)Definition TGeoNavigator.h:173; TGeoNavigator::fLastPWSaftyPntDouble_t fLastPWSaftyPnt[3]last point for which safety was computedDefinition TGeoNavigator.h:52; TGeoNavigator::DoRestoreStatevoid DoRestoreState()Restore a backed-up state without affecting the cache stack.Definition TGeoNavigator.cxx:2657; TGeoNavigator::fPointDouble_t fPoint[3]unit vector to current checked shapeDefinition TGeoNavigator.h:49; TGeoNavigator::IsStepExitingBool_t IsStepExiting() constDefinition TGeoNavigator.h:143; TGeoNavigator::fSearchOverlapsBool_t fSearchOverlapsinternal array for overlapsDefinition TGeoNavigator.h:61; TGeoNavigator::fIsExitingBool_t fIsExitingflag if current step just got into a new nodeDefinition TGeoNavigator.h:65; TGeoNavigator::fPathTString fPathcurrent local matrix of the selected division cellDefinition TGeoNavigator.h:84; TGeoNavigator::fDivMatrixTGeoHMatrix * fDivMatrixcurrent pointer to cached global matrixDefinition TGeoNavigator.h:83; TGeoNavigator::PopPathBool_t PopPath()Definition TGeoNavigator.h:247; TGeoNavigator::CrossBoundaryAndLocateTGeoNode * CrossBoundaryAndLocate(Bool_t downwards, TGeoNode *skipnode)Cross next boundary and locate within current node The current point must ",MatchSource.WIKI,doc/master/TGeoNavigator_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoNavigator_8h_source.html
https://root.cern/doc/master/TGeoNavigator_8h_source.html:19283,Performance,cache,cached,19283,"GeoNavigator.h:155; TGeoNavigator::SetCurrentPointvoid SetCurrentPoint(Double_t x, Double_t y, Double_t z)Definition TGeoNavigator.h:173; TGeoNavigator::fLastPWSaftyPntDouble_t fLastPWSaftyPnt[3]last point for which safety was computedDefinition TGeoNavigator.h:52; TGeoNavigator::DoRestoreStatevoid DoRestoreState()Restore a backed-up state without affecting the cache stack.Definition TGeoNavigator.cxx:2657; TGeoNavigator::fPointDouble_t fPoint[3]unit vector to current checked shapeDefinition TGeoNavigator.h:49; TGeoNavigator::IsStepExitingBool_t IsStepExiting() constDefinition TGeoNavigator.h:143; TGeoNavigator::fSearchOverlapsBool_t fSearchOverlapsinternal array for overlapsDefinition TGeoNavigator.h:61; TGeoNavigator::fIsExitingBool_t fIsExitingflag if current step just got into a new nodeDefinition TGeoNavigator.h:65; TGeoNavigator::fPathTString fPathcurrent local matrix of the selected division cellDefinition TGeoNavigator.h:84; TGeoNavigator::fDivMatrixTGeoHMatrix * fDivMatrixcurrent pointer to cached global matrixDefinition TGeoNavigator.h:83; TGeoNavigator::PopPathBool_t PopPath()Definition TGeoNavigator.h:247; TGeoNavigator::CrossBoundaryAndLocateTGeoNode * CrossBoundaryAndLocate(Bool_t downwards, TGeoNode *skipnode)Cross next boundary and locate within current node The current point must be on the boundary of fCurr...Definition TGeoNavigator.cxx:523; TGeoNavigator::fLastPWSafetyDouble_t fLastPWSafetylast point for which parallel world safety was ""evaluated""Definition TGeoNavigator.h:53; TGeoNavigator::GetHMatrixTGeoHMatrix * GetHMatrix()Return stored current matrix (global matrix of the next touched node).Definition TGeoNavigator.cxx:2670; TGeoNavigator::IsCheckingOverlapsBool_t IsCheckingOverlaps() constDefinition TGeoNavigator.h:138; TGeoNavigator::LocalToMastervoid LocalToMaster(const Double_t *local, Double_t *master) constDefinition TGeoNavigator.h:235; TGeoNavigator::fCacheTGeoNodeCache * fCachecurrent geometryDefinition TGeoNavigator.h:73; TGeoNavigat",MatchSource.WIKI,doc/master/TGeoNavigator_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoNavigator_8h_source.html
https://root.cern/doc/master/TGeoNavigator_8h_source.html:31885,Performance,cache,cache,31885,") constDefinition TGeoNavigator.h:236; TGeoNavigator::IsSafeStepBool_t IsSafeStep(Double_t proposed, Double_t &newsafety) constIn case a previous safety value was computed, check if the safety region is still safe for the curren...Definition TGeoNavigator.cxx:2609; TGeoNavigator::SearchNodeTGeoNode * SearchNode(Bool_t downwards=kFALSE, const TGeoNode *skipnode=nullptr)Returns the deepest node containing fPoint, which must be set a priori.Definition TGeoNavigator.cxx:1924; TGeoNavigator::fLastSafetyDouble_t fLastSafetysafety radius from current pointDefinition TGeoNavigator.h:45; TGeoNavigator::~TGeoNavigator~TGeoNavigator() overrideDestructor.Definition TGeoNavigator.cxx:169; TGeoNavigator::TGeoNavigatorTGeoNavigator()global mode is caching enabled for parallel world safety callsDefinition TGeoNavigator.cxx:57; TGeoNavigator::SetCurrentDirectionvoid SetCurrentDirection(const Double_t *dir)Definition TGeoNavigator.h:185; TGeoNavigator::BuildCachevoid BuildCache(Bool_t dummy=kFALSE, Bool_t nodeid=kFALSE)Builds the cache for physical nodes and global matrices.Definition TGeoNavigator.cxx:182; TGeoNavigator::fNextDaughterIndexInt_t fNextDaughterIndexnumber of overlapping nodes on current branchDefinition TGeoNavigator.h:57; TGeoNavigator::PopPathBool_t PopPath(Int_t index)Definition TGeoNavigator.h:255; TGeoNavigator::fIsNullStepBool_t fIsNullStepflag that a new point is in the same node as previousDefinition TGeoNavigator.h:71; TGeoNavigator::SetLastSafetyForPointvoid SetLastSafetyForPoint(Double_t safe, const Double_t *point)Definition TGeoNavigator.h:194; TGeoNavigator::CdNodevoid CdNode(Int_t nodeid)Change current path to point to the node having this id.Definition TGeoNavigator.cxx:301; TGeoNavigator::IsCurrentOverlappingBool_t IsCurrentOverlapping() constDefinition TGeoNavigator.h:139; TGeoNavigator::operator=TGeoNavigator & operator=(const TGeoNavigator &)=delete; TGeoNavigator::GetNmanyInt_t GetNmany() constDefinition TGeoNavigator.h:105; TGeoNavigator::GetCache",MatchSource.WIKI,doc/master/TGeoNavigator_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoNavigator_8h_source.html
https://root.cern/doc/master/TGeoNavigator_8h_source.html:1654,Safety,safe,safety,1654,"; 23// //; 24////////////////////////////////////////////////////////////////////////////; 25 ; 26class TGeoManager;; 27class TGeoNode;; 28class TGeoVolume;; 29class TGeoMatrix;; 30class TGeoHMatrix;; 31 ; 32class TGeoNavigator : public TObject {; 33 ; 34protected:; 35 TGeoNavigator(const TGeoNavigator &) = delete;; 36 TGeoNavigator &operator=(const TGeoNavigator &) = delete;; 37 TGeoNode *FindInCluster(Int_t *cluster, Int_t nc);; 38 Int_t GetTouchedCluster(Int_t start, Double_t *point, Int_t *check_list, Int_t ncheck, Int_t *result);; 39 TGeoNode *CrossDivisionCell();; 40 void SafetyOverlaps();; 41 ; 42private:; 43 Double_t fStep; //! step to be done from current point and direction; 44 Double_t fSafety; //! safety radius from current point; 45 Double_t fLastSafety; //! last computed safety radius; 46 Double_t fNormal[3]; //! cosine of incident angle on current checked surface; 47 Double_t fCldir[3]; //! unit vector to current closest shape; 48 Double_t fCldirChecked[3]; //! unit vector to current checked shape; 49 Double_t fPoint[3]; //! current po",MatchSource.WIKI,doc/master/TGeoNavigator_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoNavigator_8h_source.html
https://root.cern/doc/master/TGeoNavigator_8h_source.html:1731,Safety,safe,safety,1731,"; 23// //; 24////////////////////////////////////////////////////////////////////////////; 25 ; 26class TGeoManager;; 27class TGeoNode;; 28class TGeoVolume;; 29class TGeoMatrix;; 30class TGeoHMatrix;; 31 ; 32class TGeoNavigator : public TObject {; 33 ; 34protected:; 35 TGeoNavigator(const TGeoNavigator &) = delete;; 36 TGeoNavigator &operator=(const TGeoNavigator &) = delete;; 37 TGeoNode *FindInCluster(Int_t *cluster, Int_t nc);; 38 Int_t GetTouchedCluster(Int_t start, Double_t *point, Int_t *check_list, Int_t ncheck, Int_t *result);; 39 TGeoNode *CrossDivisionCell();; 40 void SafetyOverlaps();; 41 ; 42private:; 43 Double_t fStep; //! step to be done from current point and direction; 44 Double_t fSafety; //! safety radius from current point; 45 Double_t fLastSafety; //! last computed safety radius; 46 Double_t fNormal[3]; //! cosine of incident angle on current checked surface; 47 Double_t fCldir[3]; //! unit vector to current closest shape; 48 Double_t fCldirChecked[3]; //! unit vector to current checked shape; 49 Double_t fPoint[3]; //! current po",MatchSource.WIKI,doc/master/TGeoNavigator_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoNavigator_8h_source.html
https://root.cern/doc/master/TGeoNavigator_8h_source.html:2108,Safety,safe,safety,2108,";; 30class TGeoHMatrix;; 31 ; 32class TGeoNavigator : public TObject {; 33 ; 34protected:; 35 TGeoNavigator(const TGeoNavigator &) = delete;; 36 TGeoNavigator &operator=(const TGeoNavigator &) = delete;; 37 TGeoNode *FindInCluster(Int_t *cluster, Int_t nc);; 38 Int_t GetTouchedCluster(Int_t start, Double_t *point, Int_t *check_list, Int_t ncheck, Int_t *result);; 39 TGeoNode *CrossDivisionCell();; 40 void SafetyOverlaps();; 41 ; 42private:; 43 Double_t fStep; //! step to be done from current point and direction; 44 Double_t fSafety; //! safety radius from current point; 45 Double_t fLastSafety; //! last computed safety radius; 46 Double_t fNormal[3]; //! cosine of incident angle on current checked surface; 47 Double_t fCldir[3]; //! unit vector to current closest shape; 48 Double_t fCldirChecked[3]; //! unit vector to current checked shape; 49 Double_t fPoint[3]; //! current point; 50 Double_t fDirection[3]; //! current direction; 51 Double_t fLastPoint[3]; //! last point for which safety was computed; 52 Double_t fLastPWSaftyPnt[3]; //! last point for which parallel world safety was ""evaluated""; 53 Double_t fLastPWSafety{-1}; //! last safety returned from parallel world (negative if invalid); 54 Int_t fThreadId; //! thread id for this navigator; 55 Int_t fLevel; //! current geometry level;; 56 Int_t fNmany; //! number of overlapping nodes on current branch; 57 Int_t fNextDaughterIndex; //! next daughter index after FindNextBoundary; 58 Int_t fOverlapSize; //! current size of fOverlapClusters; 59 Int_t fOverlapMark; //! current recursive position in fOverlapClusters; 60 Int_t *fOverlapClusters; //! internal array for overlaps; 61 Bool_t fSearchOverlaps; //! flag set when an overlapping cluster is searched; 62 Bool_t fCurrentOverlapping; //! flags the type of the current node; 63 Bool_t fStartSafe; //! flag a safe start for point classification; 64 Bool_t fIsEntering; //! flag if current step just got into a new node; 65 Bool_t fIsExiting; //! flag that current track ",MatchSource.WIKI,doc/master/TGeoNavigator_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoNavigator_8h_source.html
https://root.cern/doc/master/TGeoNavigator_8h_source.html:2201,Safety,safe,safety,2201," TGeoNavigator(const TGeoNavigator &) = delete;; 36 TGeoNavigator &operator=(const TGeoNavigator &) = delete;; 37 TGeoNode *FindInCluster(Int_t *cluster, Int_t nc);; 38 Int_t GetTouchedCluster(Int_t start, Double_t *point, Int_t *check_list, Int_t ncheck, Int_t *result);; 39 TGeoNode *CrossDivisionCell();; 40 void SafetyOverlaps();; 41 ; 42private:; 43 Double_t fStep; //! step to be done from current point and direction; 44 Double_t fSafety; //! safety radius from current point; 45 Double_t fLastSafety; //! last computed safety radius; 46 Double_t fNormal[3]; //! cosine of incident angle on current checked surface; 47 Double_t fCldir[3]; //! unit vector to current closest shape; 48 Double_t fCldirChecked[3]; //! unit vector to current checked shape; 49 Double_t fPoint[3]; //! current point; 50 Double_t fDirection[3]; //! current direction; 51 Double_t fLastPoint[3]; //! last point for which safety was computed; 52 Double_t fLastPWSaftyPnt[3]; //! last point for which parallel world safety was ""evaluated""; 53 Double_t fLastPWSafety{-1}; //! last safety returned from parallel world (negative if invalid); 54 Int_t fThreadId; //! thread id for this navigator; 55 Int_t fLevel; //! current geometry level;; 56 Int_t fNmany; //! number of overlapping nodes on current branch; 57 Int_t fNextDaughterIndex; //! next daughter index after FindNextBoundary; 58 Int_t fOverlapSize; //! current size of fOverlapClusters; 59 Int_t fOverlapMark; //! current recursive position in fOverlapClusters; 60 Int_t *fOverlapClusters; //! internal array for overlaps; 61 Bool_t fSearchOverlaps; //! flag set when an overlapping cluster is searched; 62 Bool_t fCurrentOverlapping; //! flags the type of the current node; 63 Bool_t fStartSafe; //! flag a safe start for point classification; 64 Bool_t fIsEntering; //! flag if current step just got into a new node; 65 Bool_t fIsExiting; //! flag that current track is about to leave current node; 66 Bool_t fIsStepEntering; //! flag that next geometric step ",MatchSource.WIKI,doc/master/TGeoNavigator_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoNavigator_8h_source.html
https://root.cern/doc/master/TGeoNavigator_8h_source.html:2265,Safety,safe,safety,2265,"r &operator=(const TGeoNavigator &) = delete;; 37 TGeoNode *FindInCluster(Int_t *cluster, Int_t nc);; 38 Int_t GetTouchedCluster(Int_t start, Double_t *point, Int_t *check_list, Int_t ncheck, Int_t *result);; 39 TGeoNode *CrossDivisionCell();; 40 void SafetyOverlaps();; 41 ; 42private:; 43 Double_t fStep; //! step to be done from current point and direction; 44 Double_t fSafety; //! safety radius from current point; 45 Double_t fLastSafety; //! last computed safety radius; 46 Double_t fNormal[3]; //! cosine of incident angle on current checked surface; 47 Double_t fCldir[3]; //! unit vector to current closest shape; 48 Double_t fCldirChecked[3]; //! unit vector to current checked shape; 49 Double_t fPoint[3]; //! current point; 50 Double_t fDirection[3]; //! current direction; 51 Double_t fLastPoint[3]; //! last point for which safety was computed; 52 Double_t fLastPWSaftyPnt[3]; //! last point for which parallel world safety was ""evaluated""; 53 Double_t fLastPWSafety{-1}; //! last safety returned from parallel world (negative if invalid); 54 Int_t fThreadId; //! thread id for this navigator; 55 Int_t fLevel; //! current geometry level;; 56 Int_t fNmany; //! number of overlapping nodes on current branch; 57 Int_t fNextDaughterIndex; //! next daughter index after FindNextBoundary; 58 Int_t fOverlapSize; //! current size of fOverlapClusters; 59 Int_t fOverlapMark; //! current recursive position in fOverlapClusters; 60 Int_t *fOverlapClusters; //! internal array for overlaps; 61 Bool_t fSearchOverlaps; //! flag set when an overlapping cluster is searched; 62 Bool_t fCurrentOverlapping; //! flags the type of the current node; 63 Bool_t fStartSafe; //! flag a safe start for point classification; 64 Bool_t fIsEntering; //! flag if current step just got into a new node; 65 Bool_t fIsExiting; //! flag that current track is about to leave current node; 66 Bool_t fIsStepEntering; //! flag that next geometric step will enter new volume; 67 Bool_t fIsStepExiting; //! flag that n",MatchSource.WIKI,doc/master/TGeoNavigator_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoNavigator_8h_source.html
https://root.cern/doc/master/TGeoNavigator_8h_source.html:2951,Safety,safe,safe,2951,"ked shape; 49 Double_t fPoint[3]; //! current point; 50 Double_t fDirection[3]; //! current direction; 51 Double_t fLastPoint[3]; //! last point for which safety was computed; 52 Double_t fLastPWSaftyPnt[3]; //! last point for which parallel world safety was ""evaluated""; 53 Double_t fLastPWSafety{-1}; //! last safety returned from parallel world (negative if invalid); 54 Int_t fThreadId; //! thread id for this navigator; 55 Int_t fLevel; //! current geometry level;; 56 Int_t fNmany; //! number of overlapping nodes on current branch; 57 Int_t fNextDaughterIndex; //! next daughter index after FindNextBoundary; 58 Int_t fOverlapSize; //! current size of fOverlapClusters; 59 Int_t fOverlapMark; //! current recursive position in fOverlapClusters; 60 Int_t *fOverlapClusters; //! internal array for overlaps; 61 Bool_t fSearchOverlaps; //! flag set when an overlapping cluster is searched; 62 Bool_t fCurrentOverlapping; //! flags the type of the current node; 63 Bool_t fStartSafe; //! flag a safe start for point classification; 64 Bool_t fIsEntering; //! flag if current step just got into a new node; 65 Bool_t fIsExiting; //! flag that current track is about to leave current node; 66 Bool_t fIsStepEntering; //! flag that next geometric step will enter new volume; 67 Bool_t fIsStepExiting; //! flag that next geometric step will exit current volume; 68 Bool_t fIsOutside; //! flag that current point is outside geometry; 69 Bool_t fIsOnBoundary; //! flag that current point is on some boundary; 70 Bool_t fIsSameLocation; //! flag that a new point is in the same node as previous; 71 Bool_t fIsNullStep; //! flag that last geometric step was null; 72 TGeoManager *fGeometry; //! current geometry; 73 TGeoNodeCache *fCache; //! cache of states; 74 TGeoVolume *fCurrentVolume; //! current volume; 75 TGeoNode *fCurrentNode; //! current node; 76 TGeoNode *fTopNode; //! top physical node; 77 TGeoNode *fLastNode; //! last searched node; 78 TGeoNode *fNextNode; //! next node that will be cross",MatchSource.WIKI,doc/master/TGeoNavigator_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoNavigator_8h_source.html
https://root.cern/doc/master/TGeoNavigator_8h_source.html:4457,Safety,safe,safety,4457,"0 Bool_t fIsSameLocation; //! flag that a new point is in the same node as previous; 71 Bool_t fIsNullStep; //! flag that last geometric step was null; 72 TGeoManager *fGeometry; //! current geometry; 73 TGeoNodeCache *fCache; //! cache of states; 74 TGeoVolume *fCurrentVolume; //! current volume; 75 TGeoNode *fCurrentNode; //! current node; 76 TGeoNode *fTopNode; //! top physical node; 77 TGeoNode *fLastNode; //! last searched node; 78 TGeoNode *fNextNode; //! next node that will be crossed; 79 TGeoNode *fForcedNode; //! current point is supposed to be inside this node; 80 TGeoCacheState *fBackupState; //! backup state; 81 TGeoHMatrix *fCurrentMatrix; //! current stored global matrix; 82 TGeoHMatrix *fGlobalMatrix; //! current pointer to cached global matrix; 83 TGeoHMatrix *fDivMatrix; //! current local matrix of the selected division cell; 84 TString fPath; //! path to current node; 85 ; 86 static Bool_t fgUsePWSafetyCaching; //! global mode is caching enabled for parallel world safety calls; 87 ; 88public:; 89 TGeoNavigator();; 90 TGeoNavigator(TGeoManager *geom);; 91 ~TGeoNavigator() override;; 92 ; 93 void BuildCache(Bool_t dummy = kFALSE, Bool_t nodeid = kFALSE);; 94 Bool_t cd(const char *path = """");; 95 Bool_t CheckPath(const char *path) const;; 96 void CdNode(Int_t nodeid);; 97 void CdDown(Int_t index);; 98 void CdDown(TGeoNode *node);; 99 void CdUp();; 100 void CdTop();; 101 void CdNext();; 102 void GetBranchNames(Int_t *names) const;; 103 void GetBranchNumbers(Int_t *copyNumbers, Int_t *volumeNumbers) const;; 104 void GetBranchOnlys(Int_t *isonly) const;; 105 Int_t GetNmany() const { return fNmany; }; 106 //--- geometry queries; 107 TGeoNode *CrossBoundaryAndLocate(Bool_t downwards, TGeoNode *skipnode);; 108 TGeoNode *FindNextBoundary(Double_t stepmax = TGeoShape::Big(), const char *path = """", Bool_t frombdr = kFALSE);; 109 TGeoNode *FindNextDaughterBoundary(Double_t *point, Double_t *dir, Int_t &idaughter, Bool_t compmatrix = kFALSE);; 110 TGeoNode *FindN",MatchSource.WIKI,doc/master/TGeoNavigator_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoNavigator_8h_source.html
https://root.cern/doc/master/TGeoNavigator_8h_source.html:9948,Safety,safe,safe,9948,"CurrentNodeId() const { return fCache->GetCurrentNodeId(); }; 161 const Double_t *GetCurrentPoint() const { return fPoint; }; 162 const Double_t *GetCurrentDirection() const { return fDirection; }; 163 TGeoVolume *GetCurrentVolume() const { return fCurrentNode->GetVolume(); }; 164 const Double_t *GetCldirChecked() const { return fCldirChecked; }; 165 const Double_t *GetCldir() const { return fCldir; }; 166 TGeoHMatrix *GetDivMatrix() const { return fDivMatrix; }; 167 // Double_t GetNormalChecked() const {return fNormalChecked;}; 168 const Double_t *GetNormal() const { return fNormal; }; 169 Int_t GetLevel() const { return fLevel; }; 170 const char *GetPath() const;; 171 Int_t GetStackLevel() const { return fCache->GetStackLevel(); }; 172 void SetCurrentPoint(const Double_t *point) { memcpy(fPoint, point, 3 * sizeof(Double_t)); }; 173 void SetCurrentPoint(Double_t x, Double_t y, Double_t z); 174 {; 175 fPoint[0] = x;; 176 fPoint[1] = y;; 177 fPoint[2] = z;; 178 }; 179 void SetLastPoint(Double_t x, Double_t y, Double_t z); 180 {; 181 fLastPoint[0] = x;; 182 fLastPoint[1] = y;; 183 fLastPoint[2] = z;; 184 }; 185 void SetCurrentDirection(const Double_t *dir) { memcpy(fDirection, dir, 3 * sizeof(Double_t)); }; 186 void SetCurrentDirection(Double_t nx, Double_t ny, Double_t nz); 187 {; 188 fDirection[0] = nx;; 189 fDirection[1] = ny;; 190 fDirection[2] = nz;; 191 }; 192 // void SetNormalChecked(Double_t norm) {fNormalChecked=norm;}; 193 void SetCldirChecked(Double_t *dir) { memcpy(fCldirChecked, dir, 3 * sizeof(Double_t)); }; 194 void SetLastSafetyForPoint(Double_t safe, const Double_t *point); 195 {; 196 fLastSafety = safe;; 197 memcpy(fLastPoint, point, 3 * sizeof(Double_t));; 198 }; 199 void SetLastSafetyForPoint(Double_t safe, Double_t x, Double_t y, Double_t z); 200 {; 201 fLastSafety = safe;; 202 fLastPoint[0] = x;; 203 fLastPoint[1] = y, fLastPoint[2] = z;; 204 }; 205 ; 206 // Check if we have a cached safety value from parallel world, and if this can still be used.",MatchSource.WIKI,doc/master/TGeoNavigator_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoNavigator_8h_source.html
https://root.cern/doc/master/TGeoNavigator_8h_source.html:10003,Safety,safe,safe,10003,"CurrentNodeId() const { return fCache->GetCurrentNodeId(); }; 161 const Double_t *GetCurrentPoint() const { return fPoint; }; 162 const Double_t *GetCurrentDirection() const { return fDirection; }; 163 TGeoVolume *GetCurrentVolume() const { return fCurrentNode->GetVolume(); }; 164 const Double_t *GetCldirChecked() const { return fCldirChecked; }; 165 const Double_t *GetCldir() const { return fCldir; }; 166 TGeoHMatrix *GetDivMatrix() const { return fDivMatrix; }; 167 // Double_t GetNormalChecked() const {return fNormalChecked;}; 168 const Double_t *GetNormal() const { return fNormal; }; 169 Int_t GetLevel() const { return fLevel; }; 170 const char *GetPath() const;; 171 Int_t GetStackLevel() const { return fCache->GetStackLevel(); }; 172 void SetCurrentPoint(const Double_t *point) { memcpy(fPoint, point, 3 * sizeof(Double_t)); }; 173 void SetCurrentPoint(Double_t x, Double_t y, Double_t z); 174 {; 175 fPoint[0] = x;; 176 fPoint[1] = y;; 177 fPoint[2] = z;; 178 }; 179 void SetLastPoint(Double_t x, Double_t y, Double_t z); 180 {; 181 fLastPoint[0] = x;; 182 fLastPoint[1] = y;; 183 fLastPoint[2] = z;; 184 }; 185 void SetCurrentDirection(const Double_t *dir) { memcpy(fDirection, dir, 3 * sizeof(Double_t)); }; 186 void SetCurrentDirection(Double_t nx, Double_t ny, Double_t nz); 187 {; 188 fDirection[0] = nx;; 189 fDirection[1] = ny;; 190 fDirection[2] = nz;; 191 }; 192 // void SetNormalChecked(Double_t norm) {fNormalChecked=norm;}; 193 void SetCldirChecked(Double_t *dir) { memcpy(fCldirChecked, dir, 3 * sizeof(Double_t)); }; 194 void SetLastSafetyForPoint(Double_t safe, const Double_t *point); 195 {; 196 fLastSafety = safe;; 197 memcpy(fLastPoint, point, 3 * sizeof(Double_t));; 198 }; 199 void SetLastSafetyForPoint(Double_t safe, Double_t x, Double_t y, Double_t z); 200 {; 201 fLastSafety = safe;; 202 fLastPoint[0] = x;; 203 fLastPoint[1] = y, fLastPoint[2] = z;; 204 }; 205 ; 206 // Check if we have a cached safety value from parallel world, and if this can still be used.",MatchSource.WIKI,doc/master/TGeoNavigator_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoNavigator_8h_source.html
https://root.cern/doc/master/TGeoNavigator_8h_source.html:10111,Safety,safe,safe,10111,"CurrentNodeId() const { return fCache->GetCurrentNodeId(); }; 161 const Double_t *GetCurrentPoint() const { return fPoint; }; 162 const Double_t *GetCurrentDirection() const { return fDirection; }; 163 TGeoVolume *GetCurrentVolume() const { return fCurrentNode->GetVolume(); }; 164 const Double_t *GetCldirChecked() const { return fCldirChecked; }; 165 const Double_t *GetCldir() const { return fCldir; }; 166 TGeoHMatrix *GetDivMatrix() const { return fDivMatrix; }; 167 // Double_t GetNormalChecked() const {return fNormalChecked;}; 168 const Double_t *GetNormal() const { return fNormal; }; 169 Int_t GetLevel() const { return fLevel; }; 170 const char *GetPath() const;; 171 Int_t GetStackLevel() const { return fCache->GetStackLevel(); }; 172 void SetCurrentPoint(const Double_t *point) { memcpy(fPoint, point, 3 * sizeof(Double_t)); }; 173 void SetCurrentPoint(Double_t x, Double_t y, Double_t z); 174 {; 175 fPoint[0] = x;; 176 fPoint[1] = y;; 177 fPoint[2] = z;; 178 }; 179 void SetLastPoint(Double_t x, Double_t y, Double_t z); 180 {; 181 fLastPoint[0] = x;; 182 fLastPoint[1] = y;; 183 fLastPoint[2] = z;; 184 }; 185 void SetCurrentDirection(const Double_t *dir) { memcpy(fDirection, dir, 3 * sizeof(Double_t)); }; 186 void SetCurrentDirection(Double_t nx, Double_t ny, Double_t nz); 187 {; 188 fDirection[0] = nx;; 189 fDirection[1] = ny;; 190 fDirection[2] = nz;; 191 }; 192 // void SetNormalChecked(Double_t norm) {fNormalChecked=norm;}; 193 void SetCldirChecked(Double_t *dir) { memcpy(fCldirChecked, dir, 3 * sizeof(Double_t)); }; 194 void SetLastSafetyForPoint(Double_t safe, const Double_t *point); 195 {; 196 fLastSafety = safe;; 197 memcpy(fLastPoint, point, 3 * sizeof(Double_t));; 198 }; 199 void SetLastSafetyForPoint(Double_t safe, Double_t x, Double_t y, Double_t z); 200 {; 201 fLastSafety = safe;; 202 fLastPoint[0] = x;; 203 fLastPoint[1] = y, fLastPoint[2] = z;; 204 }; 205 ; 206 // Check if we have a cached safety value from parallel world, and if this can still be used.",MatchSource.WIKI,doc/master/TGeoNavigator_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoNavigator_8h_source.html
https://root.cern/doc/master/TGeoNavigator_8h_source.html:10179,Safety,safe,safe,10179,"CurrentNodeId() const { return fCache->GetCurrentNodeId(); }; 161 const Double_t *GetCurrentPoint() const { return fPoint; }; 162 const Double_t *GetCurrentDirection() const { return fDirection; }; 163 TGeoVolume *GetCurrentVolume() const { return fCurrentNode->GetVolume(); }; 164 const Double_t *GetCldirChecked() const { return fCldirChecked; }; 165 const Double_t *GetCldir() const { return fCldir; }; 166 TGeoHMatrix *GetDivMatrix() const { return fDivMatrix; }; 167 // Double_t GetNormalChecked() const {return fNormalChecked;}; 168 const Double_t *GetNormal() const { return fNormal; }; 169 Int_t GetLevel() const { return fLevel; }; 170 const char *GetPath() const;; 171 Int_t GetStackLevel() const { return fCache->GetStackLevel(); }; 172 void SetCurrentPoint(const Double_t *point) { memcpy(fPoint, point, 3 * sizeof(Double_t)); }; 173 void SetCurrentPoint(Double_t x, Double_t y, Double_t z); 174 {; 175 fPoint[0] = x;; 176 fPoint[1] = y;; 177 fPoint[2] = z;; 178 }; 179 void SetLastPoint(Double_t x, Double_t y, Double_t z); 180 {; 181 fLastPoint[0] = x;; 182 fLastPoint[1] = y;; 183 fLastPoint[2] = z;; 184 }; 185 void SetCurrentDirection(const Double_t *dir) { memcpy(fDirection, dir, 3 * sizeof(Double_t)); }; 186 void SetCurrentDirection(Double_t nx, Double_t ny, Double_t nz); 187 {; 188 fDirection[0] = nx;; 189 fDirection[1] = ny;; 190 fDirection[2] = nz;; 191 }; 192 // void SetNormalChecked(Double_t norm) {fNormalChecked=norm;}; 193 void SetCldirChecked(Double_t *dir) { memcpy(fCldirChecked, dir, 3 * sizeof(Double_t)); }; 194 void SetLastSafetyForPoint(Double_t safe, const Double_t *point); 195 {; 196 fLastSafety = safe;; 197 memcpy(fLastPoint, point, 3 * sizeof(Double_t));; 198 }; 199 void SetLastSafetyForPoint(Double_t safe, Double_t x, Double_t y, Double_t z); 200 {; 201 fLastSafety = safe;; 202 fLastPoint[0] = x;; 203 fLastPoint[1] = y, fLastPoint[2] = z;; 204 }; 205 ; 206 // Check if we have a cached safety value from parallel world, and if this can still be used.",MatchSource.WIKI,doc/master/TGeoNavigator_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoNavigator_8h_source.html
https://root.cern/doc/master/TGeoNavigator_8h_source.html:10299,Safety,safe,safety,10299,"CurrentNodeId() const { return fCache->GetCurrentNodeId(); }; 161 const Double_t *GetCurrentPoint() const { return fPoint; }; 162 const Double_t *GetCurrentDirection() const { return fDirection; }; 163 TGeoVolume *GetCurrentVolume() const { return fCurrentNode->GetVolume(); }; 164 const Double_t *GetCldirChecked() const { return fCldirChecked; }; 165 const Double_t *GetCldir() const { return fCldir; }; 166 TGeoHMatrix *GetDivMatrix() const { return fDivMatrix; }; 167 // Double_t GetNormalChecked() const {return fNormalChecked;}; 168 const Double_t *GetNormal() const { return fNormal; }; 169 Int_t GetLevel() const { return fLevel; }; 170 const char *GetPath() const;; 171 Int_t GetStackLevel() const { return fCache->GetStackLevel(); }; 172 void SetCurrentPoint(const Double_t *point) { memcpy(fPoint, point, 3 * sizeof(Double_t)); }; 173 void SetCurrentPoint(Double_t x, Double_t y, Double_t z); 174 {; 175 fPoint[0] = x;; 176 fPoint[1] = y;; 177 fPoint[2] = z;; 178 }; 179 void SetLastPoint(Double_t x, Double_t y, Double_t z); 180 {; 181 fLastPoint[0] = x;; 182 fLastPoint[1] = y;; 183 fLastPoint[2] = z;; 184 }; 185 void SetCurrentDirection(const Double_t *dir) { memcpy(fDirection, dir, 3 * sizeof(Double_t)); }; 186 void SetCurrentDirection(Double_t nx, Double_t ny, Double_t nz); 187 {; 188 fDirection[0] = nx;; 189 fDirection[1] = ny;; 190 fDirection[2] = nz;; 191 }; 192 // void SetNormalChecked(Double_t norm) {fNormalChecked=norm;}; 193 void SetCldirChecked(Double_t *dir) { memcpy(fCldirChecked, dir, 3 * sizeof(Double_t)); }; 194 void SetLastSafetyForPoint(Double_t safe, const Double_t *point); 195 {; 196 fLastSafety = safe;; 197 memcpy(fLastPoint, point, 3 * sizeof(Double_t));; 198 }; 199 void SetLastSafetyForPoint(Double_t safe, Double_t x, Double_t y, Double_t z); 200 {; 201 fLastSafety = safe;; 202 fLastPoint[0] = x;; 203 fLastPoint[1] = y, fLastPoint[2] = z;; 204 }; 205 ; 206 // Check if we have a cached safety value from parallel world, and if this can still be used.",MatchSource.WIKI,doc/master/TGeoNavigator_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoNavigator_8h_source.html
https://root.cern/doc/master/TGeoNavigator_8h_source.html:10532,Safety,safe,safeties,10532,"on(const Double_t *dir) { memcpy(fDirection, dir, 3 * sizeof(Double_t)); }; 186 void SetCurrentDirection(Double_t nx, Double_t ny, Double_t nz); 187 {; 188 fDirection[0] = nx;; 189 fDirection[1] = ny;; 190 fDirection[2] = nz;; 191 }; 192 // void SetNormalChecked(Double_t norm) {fNormalChecked=norm;}; 193 void SetCldirChecked(Double_t *dir) { memcpy(fCldirChecked, dir, 3 * sizeof(Double_t)); }; 194 void SetLastSafetyForPoint(Double_t safe, const Double_t *point); 195 {; 196 fLastSafety = safe;; 197 memcpy(fLastPoint, point, 3 * sizeof(Double_t));; 198 }; 199 void SetLastSafetyForPoint(Double_t safe, Double_t x, Double_t y, Double_t z); 200 {; 201 fLastSafety = safe;; 202 fLastPoint[0] = x;; 203 fLastPoint[1] = y, fLastPoint[2] = z;; 204 }; 205 ; 206 // Check if we have a cached safety value from parallel world, and if this can still be used.; 207 // Return negative value if no cache available.; 208 Double_t GetPWSafetyEstimateFromCache(Double_t cpoint[3]) const; 209 {; 210 // disregard too small or invalid safeties; 211 if (fLastPWSafety < TGeoShape::Tolerance()) {; 212 return -1.;; 213 }; 214 const auto d0 = fLastPWSaftyPnt[0] - cpoint[0];; 215 const auto d1 = fLastPWSaftyPnt[1] - cpoint[1];; 216 const auto d2 = fLastPWSaftyPnt[2] - cpoint[2];; 217 const auto d_sq = d0 * d0 + d1 * d1 + d2 * d2;; 218 // if we have moved too much return -1 as ""invalid""; 219 if (d_sq >= (fLastPWSafety * fLastPWSafety)) {; 220 return -1.;; 221 }; 222 // or return a reasonable cache estimate for safety; 223 return fLastPWSafety - std::sqrt(d_sq);; 224 }; 225 ; 226 // Wrapper for getting the safety from the parallel world.; 227 // Takes care of caching mechanics and talking to the Safety function of parallel world.; 228 Double_t GetPWSafety(Double_t cpoint[3], Double_t saf_max);; 229 ; 230 // enable/disable parallel world safety caching; 231 static void SetPWSafetyCaching(Bool_t b) { fgUsePWSafetyCaching = b; }; 232 static Bool_t IsPWSafetyCaching() { return fgUsePWSafetyCaching; }; 233 ; ",MatchSource.WIKI,doc/master/TGeoNavigator_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoNavigator_8h_source.html
https://root.cern/doc/master/TGeoNavigator_8h_source.html:11010,Safety,safe,safety,11010,"sizeof(Double_t));; 198 }; 199 void SetLastSafetyForPoint(Double_t safe, Double_t x, Double_t y, Double_t z); 200 {; 201 fLastSafety = safe;; 202 fLastPoint[0] = x;; 203 fLastPoint[1] = y, fLastPoint[2] = z;; 204 }; 205 ; 206 // Check if we have a cached safety value from parallel world, and if this can still be used.; 207 // Return negative value if no cache available.; 208 Double_t GetPWSafetyEstimateFromCache(Double_t cpoint[3]) const; 209 {; 210 // disregard too small or invalid safeties; 211 if (fLastPWSafety < TGeoShape::Tolerance()) {; 212 return -1.;; 213 }; 214 const auto d0 = fLastPWSaftyPnt[0] - cpoint[0];; 215 const auto d1 = fLastPWSaftyPnt[1] - cpoint[1];; 216 const auto d2 = fLastPWSaftyPnt[2] - cpoint[2];; 217 const auto d_sq = d0 * d0 + d1 * d1 + d2 * d2;; 218 // if we have moved too much return -1 as ""invalid""; 219 if (d_sq >= (fLastPWSafety * fLastPWSafety)) {; 220 return -1.;; 221 }; 222 // or return a reasonable cache estimate for safety; 223 return fLastPWSafety - std::sqrt(d_sq);; 224 }; 225 ; 226 // Wrapper for getting the safety from the parallel world.; 227 // Takes care of caching mechanics and talking to the Safety function of parallel world.; 228 Double_t GetPWSafety(Double_t cpoint[3], Double_t saf_max);; 229 ; 230 // enable/disable parallel world safety caching; 231 static void SetPWSafetyCaching(Bool_t b) { fgUsePWSafetyCaching = b; }; 232 static Bool_t IsPWSafetyCaching() { return fgUsePWSafetyCaching; }; 233 ; 234 //--- point/vector reference frame conversion; 235 void LocalToMaster(const Double_t *local, Double_t *master) const { fCache->LocalToMaster(local, master); }; 236 void LocalToMasterVect(const Double_t *local, Double_t *master) const { fCache->LocalToMasterVect(local, master); }; 237 void LocalToMasterBomb(const Double_t *local, Double_t *master) const { fCache->LocalToMasterBomb(local, master); }; 238 void MasterToLocal(const Double_t *master, Double_t *local) const { fCache->MasterToLocal(master, local); }; 239 void Maste",MatchSource.WIKI,doc/master/TGeoNavigator_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoNavigator_8h_source.html
https://root.cern/doc/master/TGeoNavigator_8h_source.html:11107,Safety,safe,safety,11107,"sizeof(Double_t));; 198 }; 199 void SetLastSafetyForPoint(Double_t safe, Double_t x, Double_t y, Double_t z); 200 {; 201 fLastSafety = safe;; 202 fLastPoint[0] = x;; 203 fLastPoint[1] = y, fLastPoint[2] = z;; 204 }; 205 ; 206 // Check if we have a cached safety value from parallel world, and if this can still be used.; 207 // Return negative value if no cache available.; 208 Double_t GetPWSafetyEstimateFromCache(Double_t cpoint[3]) const; 209 {; 210 // disregard too small or invalid safeties; 211 if (fLastPWSafety < TGeoShape::Tolerance()) {; 212 return -1.;; 213 }; 214 const auto d0 = fLastPWSaftyPnt[0] - cpoint[0];; 215 const auto d1 = fLastPWSaftyPnt[1] - cpoint[1];; 216 const auto d2 = fLastPWSaftyPnt[2] - cpoint[2];; 217 const auto d_sq = d0 * d0 + d1 * d1 + d2 * d2;; 218 // if we have moved too much return -1 as ""invalid""; 219 if (d_sq >= (fLastPWSafety * fLastPWSafety)) {; 220 return -1.;; 221 }; 222 // or return a reasonable cache estimate for safety; 223 return fLastPWSafety - std::sqrt(d_sq);; 224 }; 225 ; 226 // Wrapper for getting the safety from the parallel world.; 227 // Takes care of caching mechanics and talking to the Safety function of parallel world.; 228 Double_t GetPWSafety(Double_t cpoint[3], Double_t saf_max);; 229 ; 230 // enable/disable parallel world safety caching; 231 static void SetPWSafetyCaching(Bool_t b) { fgUsePWSafetyCaching = b; }; 232 static Bool_t IsPWSafetyCaching() { return fgUsePWSafetyCaching; }; 233 ; 234 //--- point/vector reference frame conversion; 235 void LocalToMaster(const Double_t *local, Double_t *master) const { fCache->LocalToMaster(local, master); }; 236 void LocalToMasterVect(const Double_t *local, Double_t *master) const { fCache->LocalToMasterVect(local, master); }; 237 void LocalToMasterBomb(const Double_t *local, Double_t *master) const { fCache->LocalToMasterBomb(local, master); }; 238 void MasterToLocal(const Double_t *master, Double_t *local) const { fCache->MasterToLocal(master, local); }; 239 void Maste",MatchSource.WIKI,doc/master/TGeoNavigator_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoNavigator_8h_source.html
https://root.cern/doc/master/TGeoNavigator_8h_source.html:11342,Safety,safe,safety,11342,,MatchSource.WIKI,doc/master/TGeoNavigator_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoNavigator_8h_source.html
https://root.cern/doc/master/TGeoNavigator_8h_source.html:18484,Safety,safe,safety,18484,"GeoNavigatorArray::operator=TGeoNavigatorArray & operator=(const TGeoNavigatorArray &)=delete; TGeoNavigatorArray::fGeoManagerTGeoManager * fGeoManagerDefinition TGeoNavigator.h:297; TGeoNavigatorArray::SetCurrentNavigatorTGeoNavigator * SetCurrentNavigator(Int_t inav)Definition TGeoNavigator.h:309; TGeoNavigatorArray::~TGeoNavigatorArray~TGeoNavigatorArray() overrideDefinition TGeoNavigator.h:305; TGeoNavigatorClass providing navigation API for TGeo geometries.Definition TGeoNavigator.h:32; TGeoNavigator::CdUpvoid CdUp()Go one level up in geometry.Definition TGeoNavigator.cxx:352; TGeoNavigator::DoBackupStatevoid DoBackupState()Backup the current state without affecting the cache stack.Definition TGeoNavigator.cxx:2648; TGeoNavigator::GetMotherTGeoNode * GetMother(Int_t up=1) constDefinition TGeoNavigator.h:155; TGeoNavigator::SetCurrentPointvoid SetCurrentPoint(Double_t x, Double_t y, Double_t z)Definition TGeoNavigator.h:173; TGeoNavigator::fLastPWSaftyPntDouble_t fLastPWSaftyPnt[3]last point for which safety was computedDefinition TGeoNavigator.h:52; TGeoNavigator::DoRestoreStatevoid DoRestoreState()Restore a backed-up state without affecting the cache stack.Definition TGeoNavigator.cxx:2657; TGeoNavigator::fPointDouble_t fPoint[3]unit vector to current checked shapeDefinition TGeoNavigator.h:49; TGeoNavigator::IsStepExitingBool_t IsStepExiting() constDefinition TGeoNavigator.h:143; TGeoNavigator::fSearchOverlapsBool_t fSearchOverlapsinternal array for overlapsDefinition TGeoNavigator.h:61; TGeoNavigator::fIsExitingBool_t fIsExitingflag if current step just got into a new nodeDefinition TGeoNavigator.h:65; TGeoNavigator::fPathTString fPathcurrent local matrix of the selected division cellDefinition TGeoNavigator.h:84; TGeoNavigator::fDivMatrixTGeoHMatrix * fDivMatrixcurrent pointer to cached global matrixDefinition TGeoNavigator.h:83; TGeoNavigator::PopPathBool_t PopPath()Definition TGeoNavigator.h:247; TGeoNavigator::CrossBoundaryAndLocateTGeoNode * CrossBoundar",MatchSource.WIKI,doc/master/TGeoNavigator_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoNavigator_8h_source.html
https://root.cern/doc/master/TGeoNavigator_8h_source.html:19736,Safety,safe,safety,19736,"int[3]unit vector to current checked shapeDefinition TGeoNavigator.h:49; TGeoNavigator::IsStepExitingBool_t IsStepExiting() constDefinition TGeoNavigator.h:143; TGeoNavigator::fSearchOverlapsBool_t fSearchOverlapsinternal array for overlapsDefinition TGeoNavigator.h:61; TGeoNavigator::fIsExitingBool_t fIsExitingflag if current step just got into a new nodeDefinition TGeoNavigator.h:65; TGeoNavigator::fPathTString fPathcurrent local matrix of the selected division cellDefinition TGeoNavigator.h:84; TGeoNavigator::fDivMatrixTGeoHMatrix * fDivMatrixcurrent pointer to cached global matrixDefinition TGeoNavigator.h:83; TGeoNavigator::PopPathBool_t PopPath()Definition TGeoNavigator.h:247; TGeoNavigator::CrossBoundaryAndLocateTGeoNode * CrossBoundaryAndLocate(Bool_t downwards, TGeoNode *skipnode)Cross next boundary and locate within current node The current point must be on the boundary of fCurr...Definition TGeoNavigator.cxx:523; TGeoNavigator::fLastPWSafetyDouble_t fLastPWSafetylast point for which parallel world safety was ""evaluated""Definition TGeoNavigator.h:53; TGeoNavigator::GetHMatrixTGeoHMatrix * GetHMatrix()Return stored current matrix (global matrix of the next touched node).Definition TGeoNavigator.cxx:2670; TGeoNavigator::IsCheckingOverlapsBool_t IsCheckingOverlaps() constDefinition TGeoNavigator.h:138; TGeoNavigator::LocalToMastervoid LocalToMaster(const Double_t *local, Double_t *master) constDefinition TGeoNavigator.h:235; TGeoNavigator::fCacheTGeoNodeCache * fCachecurrent geometryDefinition TGeoNavigator.h:73; TGeoNavigator::fStartSafeBool_t fStartSafeflags the type of the current nodeDefinition TGeoNavigator.h:63; TGeoNavigator::CdNextvoid CdNext()Do a cd to the node found next by FindNextBoundary.Definition TGeoNavigator.cxx:405; TGeoNavigator::GetNextNodeTGeoNode * GetNextNode() constDefinition TGeoNavigator.h:154; TGeoNavigator::SafetyDouble_t Safety(Bool_t inside=kFALSE)Compute safe distance from the current point.Definition TGeoNavigator.cxx:1689; TG",MatchSource.WIKI,doc/master/TGeoNavigator_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoNavigator_8h_source.html
https://root.cern/doc/master/TGeoNavigator_8h_source.html:20638,Safety,safe,safe,20638,"nition TGeoNavigator.cxx:523; TGeoNavigator::fLastPWSafetyDouble_t fLastPWSafetylast point for which parallel world safety was ""evaluated""Definition TGeoNavigator.h:53; TGeoNavigator::GetHMatrixTGeoHMatrix * GetHMatrix()Return stored current matrix (global matrix of the next touched node).Definition TGeoNavigator.cxx:2670; TGeoNavigator::IsCheckingOverlapsBool_t IsCheckingOverlaps() constDefinition TGeoNavigator.h:138; TGeoNavigator::LocalToMastervoid LocalToMaster(const Double_t *local, Double_t *master) constDefinition TGeoNavigator.h:235; TGeoNavigator::fCacheTGeoNodeCache * fCachecurrent geometryDefinition TGeoNavigator.h:73; TGeoNavigator::fStartSafeBool_t fStartSafeflags the type of the current nodeDefinition TGeoNavigator.h:63; TGeoNavigator::CdNextvoid CdNext()Do a cd to the node found next by FindNextBoundary.Definition TGeoNavigator.cxx:405; TGeoNavigator::GetNextNodeTGeoNode * GetNextNode() constDefinition TGeoNavigator.h:154; TGeoNavigator::SafetyDouble_t Safety(Bool_t inside=kFALSE)Compute safe distance from the current point.Definition TGeoNavigator.cxx:1689; TGeoNavigator::GetCldirCheckedconst Double_t * GetCldirChecked() constDefinition TGeoNavigator.h:164; TGeoNavigator::GotoSafeLevelBool_t GotoSafeLevel()Go upwards the tree until a non-overlapping node.Definition TGeoNavigator.cxx:2357; TGeoNavigator::fNormalDouble_t fNormal[3]last computed safety radiusDefinition TGeoNavigator.h:46; TGeoNavigator::GetLastSafetyDouble_t GetLastSafety() constDefinition TGeoNavigator.h:127; TGeoNavigator::PopPointBool_t PopPoint(Int_t index)Definition TGeoNavigator.h:272; TGeoNavigator::cdBool_t cd(const char *path="""")Browse the tree of nodes starting from top node according to pathname.Definition TGeoNavigator.cxx:210; TGeoNavigator::fLastPointDouble_t fLastPoint[3]current directionDefinition TGeoNavigator.h:51; TGeoNavigator::GetStepDouble_t GetStep() constDefinition TGeoNavigator.h:128; TGeoNavigator::IsSameLocationBool_t IsSameLocation() constDefinition TGeoNavig",MatchSource.WIKI,doc/master/TGeoNavigator_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoNavigator_8h_source.html
https://root.cern/doc/master/TGeoNavigator_8h_source.html:21001,Safety,safe,safety,21001,"CheckingOverlaps() constDefinition TGeoNavigator.h:138; TGeoNavigator::LocalToMastervoid LocalToMaster(const Double_t *local, Double_t *master) constDefinition TGeoNavigator.h:235; TGeoNavigator::fCacheTGeoNodeCache * fCachecurrent geometryDefinition TGeoNavigator.h:73; TGeoNavigator::fStartSafeBool_t fStartSafeflags the type of the current nodeDefinition TGeoNavigator.h:63; TGeoNavigator::CdNextvoid CdNext()Do a cd to the node found next by FindNextBoundary.Definition TGeoNavigator.cxx:405; TGeoNavigator::GetNextNodeTGeoNode * GetNextNode() constDefinition TGeoNavigator.h:154; TGeoNavigator::SafetyDouble_t Safety(Bool_t inside=kFALSE)Compute safe distance from the current point.Definition TGeoNavigator.cxx:1689; TGeoNavigator::GetCldirCheckedconst Double_t * GetCldirChecked() constDefinition TGeoNavigator.h:164; TGeoNavigator::GotoSafeLevelBool_t GotoSafeLevel()Go upwards the tree until a non-overlapping node.Definition TGeoNavigator.cxx:2357; TGeoNavigator::fNormalDouble_t fNormal[3]last computed safety radiusDefinition TGeoNavigator.h:46; TGeoNavigator::GetLastSafetyDouble_t GetLastSafety() constDefinition TGeoNavigator.h:127; TGeoNavigator::PopPointBool_t PopPoint(Int_t index)Definition TGeoNavigator.h:272; TGeoNavigator::cdBool_t cd(const char *path="""")Browse the tree of nodes starting from top node according to pathname.Definition TGeoNavigator.cxx:210; TGeoNavigator::fLastPointDouble_t fLastPoint[3]current directionDefinition TGeoNavigator.h:51; TGeoNavigator::GetStepDouble_t GetStep() constDefinition TGeoNavigator.h:128; TGeoNavigator::IsSameLocationBool_t IsSameLocation() constDefinition TGeoNavigator.h:133; TGeoNavigator::fCldirDouble_t fCldir[3]cosine of incident angle on current checked surfaceDefinition TGeoNavigator.h:47; TGeoNavigator::fIsStepEnteringBool_t fIsStepEnteringflag that current track is about to leave current nodeDefinition TGeoNavigator.h:66; TGeoNavigator::SetLastPointvoid SetLastPoint(Double_t x, Double_t y, Double_t z)Definition TGeoNav",MatchSource.WIKI,doc/master/TGeoNavigator_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoNavigator_8h_source.html
https://root.cern/doc/master/TGeoNavigator_8h_source.html:23967,Safety,safe,safe,23967,"the current state.Definition TGeoNavigator.cxx:2425; TGeoNavigator::PushPointInt_t PushPoint(Int_t startlevel=0)Definition TGeoNavigator.h:263; TGeoNavigator::StepTGeoNode * Step(Bool_t is_geom=kTRUE, Bool_t cross=kTRUE)Make a rectiliniar step of length fStep from current point (fPoint) on current direction (fDirection)...Definition TGeoNavigator.cxx:2290; TGeoNavigator::FindInClusterTGeoNode * FindInCluster(Int_t *cluster, Int_t nc)Find a node inside a cluster of overlapping nodes.Definition TGeoNavigator.cxx:2159; TGeoNavigator::TGeoNavigatorTGeoNavigator(const TGeoNavigator &)=delete; TGeoNavigator::fStepDouble_t fStepDefinition TGeoNavigator.h:43; TGeoNavigator::IsNullStepBool_t IsNullStep() constDefinition TGeoNavigator.h:146; TGeoNavigator::GetCurrentVolumeTGeoVolume * GetCurrentVolume() constDefinition TGeoNavigator.h:163; TGeoNavigator::GetNextDaughterIndexInt_t GetNextDaughterIndex() constDefinition TGeoNavigator.h:153; TGeoNavigator::SafetyOverlapsvoid SafetyOverlaps()Compute safe distance from the current point within an overlapping node.Definition TGeoNavigator.cxx:1846; TGeoNavigator::GetCurrentMatrixTGeoHMatrix * GetCurrentMatrix() constDefinition TGeoNavigator.h:158; TGeoNavigator::CrossDivisionCellTGeoNode * CrossDivisionCell()Cross a division cell.Definition TGeoNavigator.cxx:461; TGeoNavigator::ResetStatevoid ResetState()Reset current state flags.Definition TGeoNavigator.cxx:1643; TGeoNavigator::IsPWSafetyCachingstatic Bool_t IsPWSafetyCaching()Definition TGeoNavigator.h:232; TGeoNavigator::GetSafeDistanceDouble_t GetSafeDistance() constDefinition TGeoNavigator.h:126; TGeoNavigator::FindNextDaughterBoundaryTGeoNode * FindNextDaughterBoundary(Double_t *point, Double_t *dir, Int_t &idaughter, Bool_t compmatrix=kFALSE)Computes as fStep the distance to next daughter of the current volume.Definition TGeoNavigator.cxx:988; TGeoNavigator::fIsSameLocationBool_t fIsSameLocationflag that current point is on some boundaryDefinition TGeoNavigator.h:70; TGeoNavi",MatchSource.WIKI,doc/master/TGeoNavigator_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoNavigator_8h_source.html
https://root.cern/doc/master/TGeoNavigator_8h_source.html:26145,Safety,safe,safety,26145,"s) constFill node copy numbers of current branch into an array.Definition TGeoNavigator.cxx:444; TGeoNavigator::CheckPathBool_t CheckPath(const char *path) constCheck if a geometry path is valid without changing the state of the navigator.Definition TGeoNavigator.cxx:256; TGeoNavigator::SetOutsidevoid SetOutside(Bool_t flag=kTRUE)Definition TGeoNavigator.h:148; TGeoNavigator::SetStartSafevoid SetStartSafe(Bool_t flag=kTRUE)Definition TGeoNavigator.h:136; TGeoNavigator::IsEnteringBool_t IsEntering() constDefinition TGeoNavigator.h:140; TGeoNavigator::GetMotherMatrixTGeoHMatrix * GetMotherMatrix(Int_t up=1) constDefinition TGeoNavigator.h:156; TGeoNavigator::fCurrentVolumeTGeoVolume * fCurrentVolumecache of statesDefinition TGeoNavigator.h:74; TGeoNavigator::fLastNodeTGeoNode * fLastNodetop physical nodeDefinition TGeoNavigator.h:77; TGeoNavigator::SetCldirCheckedvoid SetCldirChecked(Double_t *dir)Definition TGeoNavigator.h:193; TGeoNavigator::fThreadIdInt_t fThreadIdlast safety returned from parallel world (negative if invalid)Definition TGeoNavigator.h:54; TGeoNavigator::LocalToMasterBombvoid LocalToMasterBomb(const Double_t *local, Double_t *master) constDefinition TGeoNavigator.h:237; TGeoNavigator::SetPWSafetyCachingstatic void SetPWSafetyCaching(Bool_t b)Definition TGeoNavigator.h:231; TGeoNavigator::GetPWSafetyEstimateFromCacheDouble_t GetPWSafetyEstimateFromCache(Double_t cpoint[3]) constDefinition TGeoNavigator.h:208; TGeoNavigator::fDirectionDouble_t fDirection[3]current pointDefinition TGeoNavigator.h:50; TGeoNavigator::PopDummyvoid PopDummy(Int_t ipop=9999)Definition TGeoNavigator.h:280; TGeoNavigator::GetTouchedClusterInt_t GetTouchedCluster(Int_t start, Double_t *point, Int_t *check_list, Int_t ncheck, Int_t *result)Make the cluster of overlapping nodes in a voxel, containing point in reference of the mother.Definition TGeoNavigator.cxx:2245; TGeoNavigator::FindNextBoundaryTGeoNode * FindNextBoundary(Double_t stepmax=TGeoShape::Big(), const char *path="""",",MatchSource.WIKI,doc/master/TGeoNavigator_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoNavigator_8h_source.html
https://root.cern/doc/master/TGeoNavigator_8h_source.html:31003,Safety,safe,safety,31003,"; TGeoNavigator::GetNormalconst Double_t * GetNormal() constDefinition TGeoNavigator.h:168; TGeoNavigator::TopToMastervoid TopToMaster(const Double_t *top, Double_t *master) constConvert coordinates from top volume frame to master.Definition TGeoNavigator.cxx:2700; TGeoNavigator::SetCurrentPointvoid SetCurrentPoint(const Double_t *point)Definition TGeoNavigator.h:172; TGeoNavigator::fCurrentMatrixTGeoHMatrix * fCurrentMatrixbackup stateDefinition TGeoNavigator.h:81; TGeoNavigator::fOverlapClustersInt_t * fOverlapClusterscurrent recursive position in fOverlapClustersDefinition TGeoNavigator.h:60; TGeoNavigator::GetCldirconst Double_t * GetCldir() constDefinition TGeoNavigator.h:165; TGeoNavigator::fTopNodeTGeoNode * fTopNodecurrent nodeDefinition TGeoNavigator.h:76; TGeoNavigator::LocalToMasterVectvoid LocalToMasterVect(const Double_t *local, Double_t *master) constDefinition TGeoNavigator.h:236; TGeoNavigator::IsSafeStepBool_t IsSafeStep(Double_t proposed, Double_t &newsafety) constIn case a previous safety value was computed, check if the safety region is still safe for the curren...Definition TGeoNavigator.cxx:2609; TGeoNavigator::SearchNodeTGeoNode * SearchNode(Bool_t downwards=kFALSE, const TGeoNode *skipnode=nullptr)Returns the deepest node containing fPoint, which must be set a priori.Definition TGeoNavigator.cxx:1924; TGeoNavigator::fLastSafetyDouble_t fLastSafetysafety radius from current pointDefinition TGeoNavigator.h:45; TGeoNavigator::~TGeoNavigator~TGeoNavigator() overrideDestructor.Definition TGeoNavigator.cxx:169; TGeoNavigator::TGeoNavigatorTGeoNavigator()global mode is caching enabled for parallel world safety callsDefinition TGeoNavigator.cxx:57; TGeoNavigator::SetCurrentDirectionvoid SetCurrentDirection(const Double_t *dir)Definition TGeoNavigator.h:185; TGeoNavigator::BuildCachevoid BuildCache(Bool_t dummy=kFALSE, Bool_t nodeid=kFALSE)Builds the cache for physical nodes and global matrices.Definition TGeoNavigator.cxx:182; TGeoNavigator::fNextDaug",MatchSource.WIKI,doc/master/TGeoNavigator_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoNavigator_8h_source.html
https://root.cern/doc/master/TGeoNavigator_8h_source.html:31043,Safety,safe,safety,31043,"; TGeoNavigator::GetNormalconst Double_t * GetNormal() constDefinition TGeoNavigator.h:168; TGeoNavigator::TopToMastervoid TopToMaster(const Double_t *top, Double_t *master) constConvert coordinates from top volume frame to master.Definition TGeoNavigator.cxx:2700; TGeoNavigator::SetCurrentPointvoid SetCurrentPoint(const Double_t *point)Definition TGeoNavigator.h:172; TGeoNavigator::fCurrentMatrixTGeoHMatrix * fCurrentMatrixbackup stateDefinition TGeoNavigator.h:81; TGeoNavigator::fOverlapClustersInt_t * fOverlapClusterscurrent recursive position in fOverlapClustersDefinition TGeoNavigator.h:60; TGeoNavigator::GetCldirconst Double_t * GetCldir() constDefinition TGeoNavigator.h:165; TGeoNavigator::fTopNodeTGeoNode * fTopNodecurrent nodeDefinition TGeoNavigator.h:76; TGeoNavigator::LocalToMasterVectvoid LocalToMasterVect(const Double_t *local, Double_t *master) constDefinition TGeoNavigator.h:236; TGeoNavigator::IsSafeStepBool_t IsSafeStep(Double_t proposed, Double_t &newsafety) constIn case a previous safety value was computed, check if the safety region is still safe for the curren...Definition TGeoNavigator.cxx:2609; TGeoNavigator::SearchNodeTGeoNode * SearchNode(Bool_t downwards=kFALSE, const TGeoNode *skipnode=nullptr)Returns the deepest node containing fPoint, which must be set a priori.Definition TGeoNavigator.cxx:1924; TGeoNavigator::fLastSafetyDouble_t fLastSafetysafety radius from current pointDefinition TGeoNavigator.h:45; TGeoNavigator::~TGeoNavigator~TGeoNavigator() overrideDestructor.Definition TGeoNavigator.cxx:169; TGeoNavigator::TGeoNavigatorTGeoNavigator()global mode is caching enabled for parallel world safety callsDefinition TGeoNavigator.cxx:57; TGeoNavigator::SetCurrentDirectionvoid SetCurrentDirection(const Double_t *dir)Definition TGeoNavigator.h:185; TGeoNavigator::BuildCachevoid BuildCache(Bool_t dummy=kFALSE, Bool_t nodeid=kFALSE)Builds the cache for physical nodes and global matrices.Definition TGeoNavigator.cxx:182; TGeoNavigator::fNextDaug",MatchSource.WIKI,doc/master/TGeoNavigator_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoNavigator_8h_source.html
https://root.cern/doc/master/TGeoNavigator_8h_source.html:31066,Safety,safe,safe,31066,"; TGeoNavigator::GetNormalconst Double_t * GetNormal() constDefinition TGeoNavigator.h:168; TGeoNavigator::TopToMastervoid TopToMaster(const Double_t *top, Double_t *master) constConvert coordinates from top volume frame to master.Definition TGeoNavigator.cxx:2700; TGeoNavigator::SetCurrentPointvoid SetCurrentPoint(const Double_t *point)Definition TGeoNavigator.h:172; TGeoNavigator::fCurrentMatrixTGeoHMatrix * fCurrentMatrixbackup stateDefinition TGeoNavigator.h:81; TGeoNavigator::fOverlapClustersInt_t * fOverlapClusterscurrent recursive position in fOverlapClustersDefinition TGeoNavigator.h:60; TGeoNavigator::GetCldirconst Double_t * GetCldir() constDefinition TGeoNavigator.h:165; TGeoNavigator::fTopNodeTGeoNode * fTopNodecurrent nodeDefinition TGeoNavigator.h:76; TGeoNavigator::LocalToMasterVectvoid LocalToMasterVect(const Double_t *local, Double_t *master) constDefinition TGeoNavigator.h:236; TGeoNavigator::IsSafeStepBool_t IsSafeStep(Double_t proposed, Double_t &newsafety) constIn case a previous safety value was computed, check if the safety region is still safe for the curren...Definition TGeoNavigator.cxx:2609; TGeoNavigator::SearchNodeTGeoNode * SearchNode(Bool_t downwards=kFALSE, const TGeoNode *skipnode=nullptr)Returns the deepest node containing fPoint, which must be set a priori.Definition TGeoNavigator.cxx:1924; TGeoNavigator::fLastSafetyDouble_t fLastSafetysafety radius from current pointDefinition TGeoNavigator.h:45; TGeoNavigator::~TGeoNavigator~TGeoNavigator() overrideDestructor.Definition TGeoNavigator.cxx:169; TGeoNavigator::TGeoNavigatorTGeoNavigator()global mode is caching enabled for parallel world safety callsDefinition TGeoNavigator.cxx:57; TGeoNavigator::SetCurrentDirectionvoid SetCurrentDirection(const Double_t *dir)Definition TGeoNavigator.h:185; TGeoNavigator::BuildCachevoid BuildCache(Bool_t dummy=kFALSE, Bool_t nodeid=kFALSE)Builds the cache for physical nodes and global matrices.Definition TGeoNavigator.cxx:182; TGeoNavigator::fNextDaug",MatchSource.WIKI,doc/master/TGeoNavigator_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoNavigator_8h_source.html
https://root.cern/doc/master/TGeoNavigator_8h_source.html:31635,Safety,safe,safety,31635,"r::GetCldirconst Double_t * GetCldir() constDefinition TGeoNavigator.h:165; TGeoNavigator::fTopNodeTGeoNode * fTopNodecurrent nodeDefinition TGeoNavigator.h:76; TGeoNavigator::LocalToMasterVectvoid LocalToMasterVect(const Double_t *local, Double_t *master) constDefinition TGeoNavigator.h:236; TGeoNavigator::IsSafeStepBool_t IsSafeStep(Double_t proposed, Double_t &newsafety) constIn case a previous safety value was computed, check if the safety region is still safe for the curren...Definition TGeoNavigator.cxx:2609; TGeoNavigator::SearchNodeTGeoNode * SearchNode(Bool_t downwards=kFALSE, const TGeoNode *skipnode=nullptr)Returns the deepest node containing fPoint, which must be set a priori.Definition TGeoNavigator.cxx:1924; TGeoNavigator::fLastSafetyDouble_t fLastSafetysafety radius from current pointDefinition TGeoNavigator.h:45; TGeoNavigator::~TGeoNavigator~TGeoNavigator() overrideDestructor.Definition TGeoNavigator.cxx:169; TGeoNavigator::TGeoNavigatorTGeoNavigator()global mode is caching enabled for parallel world safety callsDefinition TGeoNavigator.cxx:57; TGeoNavigator::SetCurrentDirectionvoid SetCurrentDirection(const Double_t *dir)Definition TGeoNavigator.h:185; TGeoNavigator::BuildCachevoid BuildCache(Bool_t dummy=kFALSE, Bool_t nodeid=kFALSE)Builds the cache for physical nodes and global matrices.Definition TGeoNavigator.cxx:182; TGeoNavigator::fNextDaughterIndexInt_t fNextDaughterIndexnumber of overlapping nodes on current branchDefinition TGeoNavigator.h:57; TGeoNavigator::PopPathBool_t PopPath(Int_t index)Definition TGeoNavigator.h:255; TGeoNavigator::fIsNullStepBool_t fIsNullStepflag that a new point is in the same node as previousDefinition TGeoNavigator.h:71; TGeoNavigator::SetLastSafetyForPointvoid SetLastSafetyForPoint(Double_t safe, const Double_t *point)Definition TGeoNavigator.h:194; TGeoNavigator::CdNodevoid CdNode(Int_t nodeid)Change current path to point to the node having this id.Definition TGeoNavigator.cxx:301; TGeoNavigator::IsCurrentOverl",MatchSource.WIKI,doc/master/TGeoNavigator_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoNavigator_8h_source.html
https://root.cern/doc/master/TGeoNavigator_8h_source.html:32378,Safety,safe,safe,32378,"e_t fLastSafetysafety radius from current pointDefinition TGeoNavigator.h:45; TGeoNavigator::~TGeoNavigator~TGeoNavigator() overrideDestructor.Definition TGeoNavigator.cxx:169; TGeoNavigator::TGeoNavigatorTGeoNavigator()global mode is caching enabled for parallel world safety callsDefinition TGeoNavigator.cxx:57; TGeoNavigator::SetCurrentDirectionvoid SetCurrentDirection(const Double_t *dir)Definition TGeoNavigator.h:185; TGeoNavigator::BuildCachevoid BuildCache(Bool_t dummy=kFALSE, Bool_t nodeid=kFALSE)Builds the cache for physical nodes and global matrices.Definition TGeoNavigator.cxx:182; TGeoNavigator::fNextDaughterIndexInt_t fNextDaughterIndexnumber of overlapping nodes on current branchDefinition TGeoNavigator.h:57; TGeoNavigator::PopPathBool_t PopPath(Int_t index)Definition TGeoNavigator.h:255; TGeoNavigator::fIsNullStepBool_t fIsNullStepflag that a new point is in the same node as previousDefinition TGeoNavigator.h:71; TGeoNavigator::SetLastSafetyForPointvoid SetLastSafetyForPoint(Double_t safe, const Double_t *point)Definition TGeoNavigator.h:194; TGeoNavigator::CdNodevoid CdNode(Int_t nodeid)Change current path to point to the node having this id.Definition TGeoNavigator.cxx:301; TGeoNavigator::IsCurrentOverlappingBool_t IsCurrentOverlapping() constDefinition TGeoNavigator.h:139; TGeoNavigator::operator=TGeoNavigator & operator=(const TGeoNavigator &)=delete; TGeoNavigator::GetNmanyInt_t GetNmany() constDefinition TGeoNavigator.h:105; TGeoNavigator::GetCacheTGeoNodeCache * GetCache() constDefinition TGeoNavigator.h:243; TGeoNavigator::fNextNodeTGeoNode * fNextNodelast searched nodeDefinition TGeoNavigator.h:78; TGeoNavigator::fCldirCheckedDouble_t fCldirChecked[3]unit vector to current closest shapeDefinition TGeoNavigator.h:48; TGeoNavigator::SetLastSafetyForPointvoid SetLastSafetyForPoint(Double_t safe, Double_t x, Double_t y, Double_t z)Definition TGeoNavigator.h:199; TGeoNavigator::fLevelInt_t fLevelthread id for this navigatorDefinition TGeoNavigator.h",MatchSource.WIKI,doc/master/TGeoNavigator_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoNavigator_8h_source.html
https://root.cern/doc/master/TGeoNavigator_8h_source.html:33206,Safety,safe,safe,33206,"StepBool_t fIsNullStepflag that a new point is in the same node as previousDefinition TGeoNavigator.h:71; TGeoNavigator::SetLastSafetyForPointvoid SetLastSafetyForPoint(Double_t safe, const Double_t *point)Definition TGeoNavigator.h:194; TGeoNavigator::CdNodevoid CdNode(Int_t nodeid)Change current path to point to the node having this id.Definition TGeoNavigator.cxx:301; TGeoNavigator::IsCurrentOverlappingBool_t IsCurrentOverlapping() constDefinition TGeoNavigator.h:139; TGeoNavigator::operator=TGeoNavigator & operator=(const TGeoNavigator &)=delete; TGeoNavigator::GetNmanyInt_t GetNmany() constDefinition TGeoNavigator.h:105; TGeoNavigator::GetCacheTGeoNodeCache * GetCache() constDefinition TGeoNavigator.h:243; TGeoNavigator::fNextNodeTGeoNode * fNextNodelast searched nodeDefinition TGeoNavigator.h:78; TGeoNavigator::fCldirCheckedDouble_t fCldirChecked[3]unit vector to current closest shapeDefinition TGeoNavigator.h:48; TGeoNavigator::SetLastSafetyForPointvoid SetLastSafetyForPoint(Double_t safe, Double_t x, Double_t y, Double_t z)Definition TGeoNavigator.h:199; TGeoNavigator::fLevelInt_t fLevelthread id for this navigatorDefinition TGeoNavigator.h:55; TGeoNavigator::GetPWSafetyDouble_t GetPWSafety(Double_t cpoint[3], Double_t saf_max)Wrapper for getting the safety from the parallel world.Definition TGeoNavigator.cxx:1656; TGeoNavigator::ResetAllvoid ResetAll()Reset the navigator.Definition TGeoNavigator.cxx:2708; TGeoNavigator::fBackupStateTGeoCacheState * fBackupStatecurrent point is supposed to be inside this nodeDefinition TGeoNavigator.h:80; TGeoNavigator::GetLevelInt_t GetLevel() constDefinition TGeoNavigator.h:169; TGeoNavigator::IsSamePointBool_t IsSamePoint(Double_t x, Double_t y, Double_t z) constCheck if a new point with given coordinates is the same as the last located one.Definition TGeoNavigator.cxx:2634; TGeoNavigator::fCurrentOverlappingBool_t fCurrentOverlappingflag set when an overlapping cluster is searchedDefinition TGeoNavigator.h:62; TGeoNaviga",MatchSource.WIKI,doc/master/TGeoNavigator_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoNavigator_8h_source.html
https://root.cern/doc/master/TGeoNavigator_8h_source.html:33479,Safety,safe,safety,33479," TGeoNavigator::CdNodevoid CdNode(Int_t nodeid)Change current path to point to the node having this id.Definition TGeoNavigator.cxx:301; TGeoNavigator::IsCurrentOverlappingBool_t IsCurrentOverlapping() constDefinition TGeoNavigator.h:139; TGeoNavigator::operator=TGeoNavigator & operator=(const TGeoNavigator &)=delete; TGeoNavigator::GetNmanyInt_t GetNmany() constDefinition TGeoNavigator.h:105; TGeoNavigator::GetCacheTGeoNodeCache * GetCache() constDefinition TGeoNavigator.h:243; TGeoNavigator::fNextNodeTGeoNode * fNextNodelast searched nodeDefinition TGeoNavigator.h:78; TGeoNavigator::fCldirCheckedDouble_t fCldirChecked[3]unit vector to current closest shapeDefinition TGeoNavigator.h:48; TGeoNavigator::SetLastSafetyForPointvoid SetLastSafetyForPoint(Double_t safe, Double_t x, Double_t y, Double_t z)Definition TGeoNavigator.h:199; TGeoNavigator::fLevelInt_t fLevelthread id for this navigatorDefinition TGeoNavigator.h:55; TGeoNavigator::GetPWSafetyDouble_t GetPWSafety(Double_t cpoint[3], Double_t saf_max)Wrapper for getting the safety from the parallel world.Definition TGeoNavigator.cxx:1656; TGeoNavigator::ResetAllvoid ResetAll()Reset the navigator.Definition TGeoNavigator.cxx:2708; TGeoNavigator::fBackupStateTGeoCacheState * fBackupStatecurrent point is supposed to be inside this nodeDefinition TGeoNavigator.h:80; TGeoNavigator::GetLevelInt_t GetLevel() constDefinition TGeoNavigator.h:169; TGeoNavigator::IsSamePointBool_t IsSamePoint(Double_t x, Double_t y, Double_t z) constCheck if a new point with given coordinates is the same as the last located one.Definition TGeoNavigator.cxx:2634; TGeoNavigator::fCurrentOverlappingBool_t fCurrentOverlappingflag set when an overlapping cluster is searchedDefinition TGeoNavigator.h:62; TGeoNavigator::IsOnBoundaryBool_t IsOnBoundary() constDefinition TGeoNavigator.h:145; TGeoNavigator::fIsOutsideBool_t fIsOutsideflag that next geometric step will exit current volumeDefinition TGeoNavigator.h:68; TGeoNavigator::CdDownvoid CdDown(In",MatchSource.WIKI,doc/master/TGeoNavigator_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoNavigator_8h_source.html
https://root.cern/doc/master/TGeoNavigator_8h_source.html:34573,Safety,safe,safe,34573,"ResetAll()Reset the navigator.Definition TGeoNavigator.cxx:2708; TGeoNavigator::fBackupStateTGeoCacheState * fBackupStatecurrent point is supposed to be inside this nodeDefinition TGeoNavigator.h:80; TGeoNavigator::GetLevelInt_t GetLevel() constDefinition TGeoNavigator.h:169; TGeoNavigator::IsSamePointBool_t IsSamePoint(Double_t x, Double_t y, Double_t z) constCheck if a new point with given coordinates is the same as the last located one.Definition TGeoNavigator.cxx:2634; TGeoNavigator::fCurrentOverlappingBool_t fCurrentOverlappingflag set when an overlapping cluster is searchedDefinition TGeoNavigator.h:62; TGeoNavigator::IsOnBoundaryBool_t IsOnBoundary() constDefinition TGeoNavigator.h:145; TGeoNavigator::fIsOutsideBool_t fIsOutsideflag that next geometric step will exit current volumeDefinition TGeoNavigator.h:68; TGeoNavigator::CdDownvoid CdDown(Int_t index)Make a daughter of current node current.Definition TGeoNavigator.cxx:313; TGeoNavigator::fIsEnteringBool_t fIsEnteringflag a safe start for point classificationDefinition TGeoNavigator.h:64; TGeoNavigator::GetCurrentPointconst Double_t * GetCurrentPoint() constDefinition TGeoNavigator.h:161; TGeoNavigator::IsStartSafeBool_t IsStartSafe() constDefinition TGeoNavigator.h:135; TGeoNavigator::fForcedNodeTGeoNode * fForcedNodenext node that will be crossedDefinition TGeoNavigator.h:79; TGeoNavigator::GetDivMatrixTGeoHMatrix * GetDivMatrix() constDefinition TGeoNavigator.h:166; TGeoNavigator::MasterToLocalVectvoid MasterToLocalVect(const Double_t *master, Double_t *local) constDefinition TGeoNavigator.h:239; TGeoNavigator::MasterToLocalBombvoid MasterToLocalBomb(const Double_t *master, Double_t *local) constDefinition TGeoNavigator.h:240; TGeoNavigator::GetPathconst char * GetPath() constGet path to the current node in the form /node0/node1/...Definition TGeoNavigator.cxx:2682; TGeoNavigator::IsStepEnteringBool_t IsStepEntering() constDefinition TGeoNavigator.h:142; TGeoNavigator::GetSafeLevelInt_t GetSafeLevel() ",MatchSource.WIKI,doc/master/TGeoNavigator_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoNavigator_8h_source.html
https://root.cern/doc/master/TGeoNode_8h_source.html:24474,Deployability,A/B,A/B,24474,"tance of approach from point px,py to this nodeDefinition TGeoNode.cxx:251; TGeoNode::TGeoNodeTGeoNode()Default constructor.Definition TGeoNode.cxx:95; TGeoNode::fUserExtensionTGeoExtension * fUserExtensionDefinition TGeoNode.h:46; TGeoNode::GetByteCountvirtual Int_t GetByteCount() constDefinition TGeoNode.h:82; TGeoNode::fOverlapsInt_t * fOverlapsDefinition TGeoNode.h:45; TGeoNode::fNovlpInt_t fNovlpDefinition TGeoNode.h:44; TGeoNode::SetOverlappingvoid SetOverlapping(Bool_t flag=kTRUE)Definition TGeoNode.h:120; TGeoNode::GrabFWExtensionTGeoExtension * GrabFWExtension() constGet a copy of the framework extension pointer.Definition TGeoNode.cxx:545; TGeoNode::SetOverlapsvoid SetOverlaps(Int_t *ovlp, Int_t novlp)set the list of overlaps for this node (ovlp must be created with operator new)Definition TGeoNode.cxx:707; TGeoNode::PrintCandidatesvoid PrintCandidates() constprint daughters candidates for containing current pointDefinition TGeoNode.cxx:616; TGeoNode::lsvoid ls(Option_t *option="""") const overridePrint the path (A/B/C/...) to this node on stdout.Definition TGeoNode.cxx:600; TGeoNode::SetInvisiblevoid SetInvisible()Definition TGeoNode.h:123; TGeoNode::GetNdaughtersInt_t GetNdaughters() constDefinition TGeoNode.h:91; TGeoNode::GetDaughterTGeoNode * GetDaughter(Int_t ind) constDefinition TGeoNode.h:83; TGeoNode::SetCurrentPointvoid SetCurrentPoint(Double_t x, Double_t y, Double_t z)Definition TGeoNode.h:116; TGeoNode::GetOptimalVoxelsvirtual Int_t GetOptimalVoxels() constDefinition TGeoNode.h:101; TGeoNode::GetMatrixvirtual TGeoMatrix * GetMatrix() const =0; TGeoNode::IsClonedBool_t IsCloned() constDefinition TGeoNode.h:103; TGeoNode::SetVisibilityvoid SetVisibility(Bool_t vis=kTRUE) overrideSet visibility of the node (obsolete).Definition TGeoNode.cxx:718; TGeoNode::TGeoNodeTGeoNode(const TGeoNode &)=delete; TGeoNode::IsFolderBool_t IsFolder() const overrideReturns kTRUE in case object contains browsable objects (like containers or lists of other objects).Defi",MatchSource.WIKI,doc/master/TGeoNode_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoNode_8h_source.html
https://root.cern/doc/master/TGeoNode_8h_source.html:9905,Modifiability,plugin,plugins,9905,"GetIndex() const override;; 203 TGeoPatternFinder *GetFinder() const override { return fFinder; }; 204 TGeoMatrix *GetMatrix() const override; 205 {; 206 cd();; 207 return fFinder->GetMatrix();; 208 }; 209 TGeoNode *MakeCopyNode() const override;; 210 void SetFinder(TGeoPatternFinder *finder) { fFinder = finder; }; 211 ; 212 ClassDefOverride(TGeoNodeOffset, 1) // a geometry node with just an offset; 213};; 214 ; 215////////////////////////////////////////////////////////////////////////////; 216// //; 217// TGeoIteratorPlugin - Plugin for a TGeoIterator providing the method //; 218// ProcessNode each time Next is called. //; 219// //; 220////////////////////////////////////////////////////////////////////////////; 221 ; 222class TGeoIterator;; 223 ; 224class TGeoIteratorPlugin : public TObject {; 225protected:; 226 const TGeoIterator *fIterator = nullptr; // Caller iterator; 227private:; 228 // No copy; 229 TGeoIteratorPlugin(const TGeoIteratorPlugin &);; 230 TGeoIteratorPlugin &operator=(const TGeoIteratorPlugin &);; 231 ; 232public:; 233 TGeoIteratorPlugin() : TObject(), fIterator(nullptr) {}; 234 ~TGeoIteratorPlugin() override {}; 235 ; 236 virtual void ProcessNode() = 0;; 237 void SetIterator(const TGeoIterator *iter) { fIterator = iter; }; 238 ; 239 ClassDefOverride(TGeoIteratorPlugin, 0) // ABC for user plugins connecter to a geometry iterator.; 240};; 241 ; 242////////////////////////////////////////////////////////////////////////////; 243// //; 244// TGeoIterator - iterator for the node tree //; 245// //; 246////////////////////////////////////////////////////////////////////////////; 247 ; 248class TGeoIterator {; 249private:; 250 TGeoVolume *fTop = nullptr; // Top volume of the iterated branch; 251 Bool_t fMustResume = kFALSE; // Private flag to resume from current node.; 252 Bool_t fMustStop = kFALSE; // Private flag to signal that the iterator has finished.; 253 Int_t fLevel = 0; // Current level in the tree; 254 Int_t fType = 0; // Type of iteration; 2",MatchSource.WIKI,doc/master/TGeoNode_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoNode_8h_source.html
https://root.cern/doc/master/TGeoNode_8h_source.html:10815,Modifiability,plugin,plugin,10815,"e.; 252 Bool_t fMustStop = kFALSE; // Private flag to signal that the iterator has finished.; 253 Int_t fLevel = 0; // Current level in the tree; 254 Int_t fType = 0; // Type of iteration; 255 Int_t *fArray = nullptr; // Array of node indices for the current path; 256 TGeoHMatrix *fMatrix = nullptr; // Current global matrix; 257 TString fTopName; // User name for top; 258 TGeoIteratorPlugin *fPlugin = nullptr; // User iterator plugin; 259 Bool_t fPluginAutoexec = kFALSE; // Plugin automatically executed during next(); 260 ; 261 void IncreaseArray();; 262 ; 263protected:; 264 TGeoIterator(); 265 : fTop(nullptr),; 266 fMustResume(kFALSE),; 267 fMustStop(kFALSE),; 268 fLevel(0),; 269 fType(0),; 270 fArray(nullptr),; 271 fMatrix(nullptr),; 272 fTopName(),; 273 fPlugin(nullptr),; 274 fPluginAutoexec(kFALSE); 275 {; 276 }; 277 ; 278public:; 279 TGeoIterator(TGeoVolume *top);; 280 TGeoIterator(const TGeoIterator &iter);; 281 virtual ~TGeoIterator();; 282 ; 283 TGeoIterator &operator=(const TGeoIterator &iter);; 284 TGeoNode *operator()();; 285 TGeoNode *Next();; 286 void Up(); 287 {; 288 if (fLevel > 0); 289 fLevel--;; 290 }; 291 ; 292 const TGeoMatrix *GetCurrentMatrix() const;; 293 Int_t GetIndex(Int_t i) const { return ((i <= fLevel) ? fArray[i] : -1); }; 294 Int_t GetLevel() const { return fLevel; }; 295 TGeoNode *GetNode(Int_t level) const;; 296 void GetPath(TString &path) const;; 297 TGeoIteratorPlugin *GetUserPlugin() const { return fPlugin; }; 298 ; 299 TGeoVolume *GetTopVolume() const { return fTop; }; 300 Int_t GetType() const { return fType; }; 301 void Reset(TGeoVolume *top = nullptr);; 302 void SetUserPlugin(TGeoIteratorPlugin *plugin);; 303 void SetPluginAutoexec(Bool_t mode) { fPluginAutoexec = mode; }; 304 void SetType(Int_t type) { fType = type; }; 305 void SetTopName(const char *name);; 306 void Skip();; 307 ; 308 ClassDef(TGeoIterator, 0) // Iterator for geometry.; 309};; 310 ; 311#endif; b#define b(i)Definition RSha256.hxx:100; Bool_tbool Bool_tDefiniti",MatchSource.WIKI,doc/master/TGeoNode_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoNode_8h_source.html
https://root.cern/doc/master/TGeoNode_8h_source.html:12046,Modifiability,plugin,plugin,12046,"e.; 252 Bool_t fMustStop = kFALSE; // Private flag to signal that the iterator has finished.; 253 Int_t fLevel = 0; // Current level in the tree; 254 Int_t fType = 0; // Type of iteration; 255 Int_t *fArray = nullptr; // Array of node indices for the current path; 256 TGeoHMatrix *fMatrix = nullptr; // Current global matrix; 257 TString fTopName; // User name for top; 258 TGeoIteratorPlugin *fPlugin = nullptr; // User iterator plugin; 259 Bool_t fPluginAutoexec = kFALSE; // Plugin automatically executed during next(); 260 ; 261 void IncreaseArray();; 262 ; 263protected:; 264 TGeoIterator(); 265 : fTop(nullptr),; 266 fMustResume(kFALSE),; 267 fMustStop(kFALSE),; 268 fLevel(0),; 269 fType(0),; 270 fArray(nullptr),; 271 fMatrix(nullptr),; 272 fTopName(),; 273 fPlugin(nullptr),; 274 fPluginAutoexec(kFALSE); 275 {; 276 }; 277 ; 278public:; 279 TGeoIterator(TGeoVolume *top);; 280 TGeoIterator(const TGeoIterator &iter);; 281 virtual ~TGeoIterator();; 282 ; 283 TGeoIterator &operator=(const TGeoIterator &iter);; 284 TGeoNode *operator()();; 285 TGeoNode *Next();; 286 void Up(); 287 {; 288 if (fLevel > 0); 289 fLevel--;; 290 }; 291 ; 292 const TGeoMatrix *GetCurrentMatrix() const;; 293 Int_t GetIndex(Int_t i) const { return ((i <= fLevel) ? fArray[i] : -1); }; 294 Int_t GetLevel() const { return fLevel; }; 295 TGeoNode *GetNode(Int_t level) const;; 296 void GetPath(TString &path) const;; 297 TGeoIteratorPlugin *GetUserPlugin() const { return fPlugin; }; 298 ; 299 TGeoVolume *GetTopVolume() const { return fTop; }; 300 Int_t GetType() const { return fType; }; 301 void Reset(TGeoVolume *top = nullptr);; 302 void SetUserPlugin(TGeoIteratorPlugin *plugin);; 303 void SetPluginAutoexec(Bool_t mode) { fPluginAutoexec = mode; }; 304 void SetType(Int_t type) { fType = type; }; 305 void SetTopName(const char *name);; 306 void Skip();; 307 ; 308 ClassDef(TGeoIterator, 0) // Iterator for geometry.; 309};; 310 ; 311#endif; b#define b(i)Definition RSha256.hxx:100; Bool_tbool Bool_tDefiniti",MatchSource.WIKI,doc/master/TGeoNode_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoNode_8h_source.html
https://root.cern/doc/master/TGeoNode_8h_source.html:18524,Modifiability,plugin,plugin,18524,ition TGeoNode.h:303; TGeoIterator::GetLevelInt_t GetLevel() constDefinition TGeoNode.h:294; TGeoIterator::GetPathvoid GetPath(TString &path) constReturns the path for the current node.Definition TGeoNode.cxx:1193; TGeoIterator::Upvoid Up()Definition TGeoNode.h:286; TGeoIterator::IncreaseArrayvoid IncreaseArray()Increase by 30 the size of the array.Definition TGeoNode.cxx:1211; TGeoIterator::GetNodeTGeoNode * GetNode(Int_t level) constReturns current node at a given level.Definition TGeoNode.cxx:1180; TGeoIterator::operator()TGeoNode * operator()()Returns next node.Definition TGeoNode.cxx:1155; TGeoIterator::fMatrixTGeoHMatrix * fMatrixDefinition TGeoNode.h:256; TGeoIterator::GetIndexInt_t GetIndex(Int_t i) constDefinition TGeoNode.h:293; TGeoIterator::fTopTGeoVolume * fTopDefinition TGeoNode.h:250; TGeoIterator::NextTGeoNode * Next()Returns next node.Definition TGeoNode.cxx:1065; TGeoIterator::TGeoIteratorTGeoIterator()Definition TGeoNode.h:264; TGeoIterator::SetUserPluginvoid SetUserPlugin(TGeoIteratorPlugin *plugin)Set a plugin.Definition TGeoNode.cxx:1282; TGeoIterator::Skipvoid Skip()Stop iterating the current branch.Definition TGeoNode.cxx:1243; TGeoIterator::GetUserPluginTGeoIteratorPlugin * GetUserPlugin() constDefinition TGeoNode.h:297; TGeoIterator::fArrayInt_t * fArrayDefinition TGeoNode.h:255; TGeoIterator::fTopNameTString fTopNameDefinition TGeoNode.h:257; TGeoIterator::GetTopVolumeTGeoVolume * GetTopVolume() constDefinition TGeoNode.h:299; TGeoMatrixGeometrical transformation package.Definition TGeoMatrix.h:38; TGeoMediumMedia are used to store properties related to tracking and which are useful only when using geometry ...Definition TGeoMedium.h:23; TGeoNodeMatrixA node containing local transformation.Definition TGeoNode.h:154; TGeoNodeMatrix::SetMatrixvoid SetMatrix(const TGeoMatrix *matrix)Matrix setter.Definition TGeoNode.cxx:829; TGeoNodeMatrix::IsFolderBool_t IsFolder() const overrideReturns kTRUE in case object contains browsable objects (like co,MatchSource.WIKI,doc/master/TGeoNode_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoNode_8h_source.html
https://root.cern/doc/master/TGeoNode_8h_source.html:18537,Modifiability,plugin,plugin,18537,ition TGeoNode.h:303; TGeoIterator::GetLevelInt_t GetLevel() constDefinition TGeoNode.h:294; TGeoIterator::GetPathvoid GetPath(TString &path) constReturns the path for the current node.Definition TGeoNode.cxx:1193; TGeoIterator::Upvoid Up()Definition TGeoNode.h:286; TGeoIterator::IncreaseArrayvoid IncreaseArray()Increase by 30 the size of the array.Definition TGeoNode.cxx:1211; TGeoIterator::GetNodeTGeoNode * GetNode(Int_t level) constReturns current node at a given level.Definition TGeoNode.cxx:1180; TGeoIterator::operator()TGeoNode * operator()()Returns next node.Definition TGeoNode.cxx:1155; TGeoIterator::fMatrixTGeoHMatrix * fMatrixDefinition TGeoNode.h:256; TGeoIterator::GetIndexInt_t GetIndex(Int_t i) constDefinition TGeoNode.h:293; TGeoIterator::fTopTGeoVolume * fTopDefinition TGeoNode.h:250; TGeoIterator::NextTGeoNode * Next()Returns next node.Definition TGeoNode.cxx:1065; TGeoIterator::TGeoIteratorTGeoIterator()Definition TGeoNode.h:264; TGeoIterator::SetUserPluginvoid SetUserPlugin(TGeoIteratorPlugin *plugin)Set a plugin.Definition TGeoNode.cxx:1282; TGeoIterator::Skipvoid Skip()Stop iterating the current branch.Definition TGeoNode.cxx:1243; TGeoIterator::GetUserPluginTGeoIteratorPlugin * GetUserPlugin() constDefinition TGeoNode.h:297; TGeoIterator::fArrayInt_t * fArrayDefinition TGeoNode.h:255; TGeoIterator::fTopNameTString fTopNameDefinition TGeoNode.h:257; TGeoIterator::GetTopVolumeTGeoVolume * GetTopVolume() constDefinition TGeoNode.h:299; TGeoMatrixGeometrical transformation package.Definition TGeoMatrix.h:38; TGeoMediumMedia are used to store properties related to tracking and which are useful only when using geometry ...Definition TGeoMedium.h:23; TGeoNodeMatrixA node containing local transformation.Definition TGeoNode.h:154; TGeoNodeMatrix::SetMatrixvoid SetMatrix(const TGeoMatrix *matrix)Matrix setter.Definition TGeoNode.cxx:829; TGeoNodeMatrix::IsFolderBool_t IsFolder() const overrideReturns kTRUE in case object contains browsable objects (like co,MatchSource.WIKI,doc/master/TGeoNode_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoNode_8h_source.html
https://root.cern/doc/master/TGeoNode_8h_source.html:1100,Testability,log,logical,1100,". ROOT: geom/geom/inc/TGeoNode.h Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TGeoNode.h. Go to the documentation of this file. 1// @(#)root/geom:$Id$; 2// Author: Andrei Gheata 24/10/01; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#ifndef ROOT_TGeoNode; 13#define ROOT_TGeoNode; 14 ; 15#include ""TGeoAtt.h""; 16 ; 17#include ""TNamed.h""; 18 ; 19#include ""TGeoVolume.h""; 20 ; 21#include ""TGeoPatternFinder.h""; 22 ; 23// forward declarations; 24class TString;; 25class TGeoVolume;; 26class TGeoShape;; 27class TGeoMedium;; 28class TGeoMatrix;; 29class TGeoHMatrix;; 30class TGeoExtension;; 31 ; 32////////////////////////////////////////////////////////////////////////////; 33// //; 34// TGeoNode - base class for logical nodes. They represent volumes //; 35// positioned inside a mother volume //; 36// //; 37////////////////////////////////////////////////////////////////////////////; 38 ; 39class TGeoNode : public TNamed, public TGeoAtt {; 40protected:; 41 TGeoVolume *fVolume = nullptr; // volume associated with this; 42 TGeoVolume *fMother = nullptr; // mother volume; 43 Int_t fNumber = 0; // copy number; 44 Int_t fNovlp = 0; // number of overlaps; 45 Int_t *fOverlaps = nullptr; //[fNovlp] list of indices for overlapping brothers; 46 TGeoExtension *fUserExtension = nullptr; //! Transient user-defined extension to volumes; 47 TGeoExtension *fFWExtension = nullptr; //! Transient framework-defined extension to volumes; 48 ; 49 void CopyOverlaps(Int_t *ovlp, Int_t novlp);; 50 ; 51private:; 52 TGeoNode(const TGeoNode &) = delete;; 53 TGeoNode &operator=(const TGeoNode &) = delete;; 54 ; 55public:; 56 ",MatchSource.WIKI,doc/master/TGeoNode_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoNode_8h_source.html
https://root.cern/doc/master/TGeoNode_8h_source.html:10361,Usability,resume,resume,10361,"rocessNode each time Next is called. //; 219// //; 220////////////////////////////////////////////////////////////////////////////; 221 ; 222class TGeoIterator;; 223 ; 224class TGeoIteratorPlugin : public TObject {; 225protected:; 226 const TGeoIterator *fIterator = nullptr; // Caller iterator; 227private:; 228 // No copy; 229 TGeoIteratorPlugin(const TGeoIteratorPlugin &);; 230 TGeoIteratorPlugin &operator=(const TGeoIteratorPlugin &);; 231 ; 232public:; 233 TGeoIteratorPlugin() : TObject(), fIterator(nullptr) {}; 234 ~TGeoIteratorPlugin() override {}; 235 ; 236 virtual void ProcessNode() = 0;; 237 void SetIterator(const TGeoIterator *iter) { fIterator = iter; }; 238 ; 239 ClassDefOverride(TGeoIteratorPlugin, 0) // ABC for user plugins connecter to a geometry iterator.; 240};; 241 ; 242////////////////////////////////////////////////////////////////////////////; 243// //; 244// TGeoIterator - iterator for the node tree //; 245// //; 246////////////////////////////////////////////////////////////////////////////; 247 ; 248class TGeoIterator {; 249private:; 250 TGeoVolume *fTop = nullptr; // Top volume of the iterated branch; 251 Bool_t fMustResume = kFALSE; // Private flag to resume from current node.; 252 Bool_t fMustStop = kFALSE; // Private flag to signal that the iterator has finished.; 253 Int_t fLevel = 0; // Current level in the tree; 254 Int_t fType = 0; // Type of iteration; 255 Int_t *fArray = nullptr; // Array of node indices for the current path; 256 TGeoHMatrix *fMatrix = nullptr; // Current global matrix; 257 TString fTopName; // User name for top; 258 TGeoIteratorPlugin *fPlugin = nullptr; // User iterator plugin; 259 Bool_t fPluginAutoexec = kFALSE; // Plugin automatically executed during next(); 260 ; 261 void IncreaseArray();; 262 ; 263protected:; 264 TGeoIterator(); 265 : fTop(nullptr),; 266 fMustResume(kFALSE),; 267 fMustStop(kFALSE),; 268 fLevel(0),; 269 fType(0),; 270 fArray(nullptr),; 271 fMatrix(nullptr),; 272 fTopName(),; 273 fPlugin(nullptr",MatchSource.WIKI,doc/master/TGeoNode_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoNode_8h_source.html
https://root.cern/doc/master/TGeoPainter_8cxx_source.html:6442,Availability,error,errors,6442,":BombTranslation(const Double_t *tr, Double_t *bombtr); 172{; 173 memcpy(bombtr, tr, 3 * sizeof(Double_t));; 174 switch (fExplodedView) {; 175 case kGeoNoBomb: return;; 176 case kGeoBombXYZ:; 177 bombtr[0] *= fBombX;; 178 bombtr[1] *= fBombY;; 179 bombtr[2] *= fBombZ;; 180 return;; 181 case kGeoBombCyl:; 182 bombtr[0] *= fBombR;; 183 bombtr[1] *= fBombR;; 184 bombtr[2] *= fBombZ;; 185 return;; 186 case kGeoBombSph:; 187 bombtr[0] *= fBombR;; 188 bombtr[1] *= fBombR;; 189 bombtr[2] *= fBombR;; 190 return;; 191 default: return;; 192 }; 193}; 194 ; 195////////////////////////////////////////////////////////////////////////////////; 196/// Check pushes and pulls needed to cross the next boundary with respect to the; 197/// position given by FindNextBoundary. If radius is not mentioned the full bounding; 198/// box will be sampled.; 199 ; 200void TGeoPainter::CheckBoundaryErrors(Int_t ntracks, Double_t radius); 201{; 202 fChecker->CheckBoundaryErrors(ntracks, radius);; 203}; 204 ; 205////////////////////////////////////////////////////////////////////////////////; 206/// Check the boundary errors reference file created by CheckBoundaryErrors method.; 207/// The shape for which the crossing failed is drawn with the starting point in red; 208/// and the extrapolated point to boundary (+/- failing push/pull) in yellow.; 209 ; 210void TGeoPainter::CheckBoundaryReference(Int_t icheck); 211{; 212 fChecker->CheckBoundaryReference(icheck);; 213}; 214 ; 215////////////////////////////////////////////////////////////////////////////////; 216/// Geometry checking method (see: TGeoManager::CheckGeometry()); 217 ; 218void TGeoPainter::CheckGeometryFull(Bool_t checkoverlaps, Bool_t checkcrossings, Int_t ntracks, const Double_t *vertex); 219{; 220 fChecker->CheckGeometryFull(checkoverlaps, checkcrossings, ntracks, vertex);; 221}; 222 ; 223////////////////////////////////////////////////////////////////////////////////; 224/// Geometry checking method (see TGeoChecker).; 225 ; 226void T",MatchSource.WIKI,doc/master/TGeoPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPainter_8cxx_source.html
https://root.cern/doc/master/TGeoPainter_8cxx_source.html:19272,Availability,down,down,19272,"dBox[0]);; 532 fCheckedNode = daughter;; 533 if (fGeoManager->IsNodeSelectable()); 534 gPad->SetSelected(fCheckedNode);; 535 else; 536 gPad->SetSelected(vol);; 537 fCheckedBox[3] = box->GetDX();; 538 fCheckedBox[4] = box->GetDY();; 539 fCheckedBox[5] = box->GetDZ();; 540 fGeoManager->PopPath();; 541 return 0;; 542 }; 543 }; 544 // Check if we have to skip the branch; 545 if (last || !daughter->IsVisDaughters()); 546 next.Skip();; 547 }; 548 }; 549 return dist;; 550}; 551 ; 552////////////////////////////////////////////////////////////////////////////////; 553/// Set default angles for the current view.; 554 ; 555void TGeoPainter::DefaultAngles(); 556{; 557 if (gPad) {; 558 Int_t irep;; 559 TView *view = gPad->GetView();; 560 if (!view); 561 return;; 562 view->SetView(-206, 126, 75, irep);; 563 ModifiedPad();; 564 }; 565}; 566 ; 567////////////////////////////////////////////////////////////////////////////////; 568/// Set default volume colors according to tracking media; 569 ; 570void TGeoPainter::DefaultColors(); 571{; 572 TIter next(fGeoManager->GetListOfVolumes());; 573 TGeoVolume *vol;; 574 while ((vol = (TGeoVolume *)next())); 575 vol->SetLineColor(vol->GetMaterial()->GetDefaultColor());; 576 ModifiedPad();; 577}; 578 ; 579////////////////////////////////////////////////////////////////////////////////; 580/// Count number of visible nodes down to a given level.; 581 ; 582Int_t TGeoPainter::CountNodes(TGeoVolume *volume, Int_t rlevel) const; 583{; 584 TGeoVolume *vol = volume;; 585 Int_t count = 0;; 586 Bool_t vis = vol->IsVisible();; 587 // Do I need to look for the top volume ?; 588 if ((fTopVisible && vis) || !vol->GetNdaughters() || !vol->IsVisDaughters() || vol->IsVisOnly()); 589 count++;; 590 // Is this the only volume?; 591 if (volume->IsVisOnly()); 592 return count;; 593 ; 594 // Do we need to check a branch only?; 595 if (volume->IsVisBranch()) {; 596 fGeoManager->PushPath();; 597 fGeoManager->cd(fVisBranch.Data());; 598 count = fGeoManager->GetLevel(",MatchSource.WIKI,doc/master/TGeoPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPainter_8cxx_source.html
https://root.cern/doc/master/TGeoPainter_8cxx_source.html:66116,Availability,down,down,66116,"004////////////////////////////////////////////////////////////////////////////////; 2005/// Set number of points to be generated on the shape outline when checking for overlaps.; 2006 ; 2007void TGeoPainter::SetNmeshPoints(Int_t npoints); 2008{; 2009 fChecker->SetNmeshPoints(npoints);; 2010}; 2011 ; 2012////////////////////////////////////////////////////////////////////////////////; 2013/// Select a node to be checked for overlaps. All overlaps not involving it will; 2014/// be ignored.; 2015 ; 2016void TGeoPainter::SetCheckedNode(TGeoNode *node); 2017{; 2018 fChecker->SetSelectedNode(node);; 2019}; 2020 ; 2021////////////////////////////////////////////////////////////////////////////////; 2022/// Set default level down to which visualization is performed; 2023 ; 2024void TGeoPainter::SetVisLevel(Int_t level); 2025{; 2026 if (level == fVisLevel && fLastVolume == fTopVolume); 2027 return;; 2028 fVisLevel = level;; 2029 if (!fTopVolume); 2030 return;; 2031 if (fVisLock) {; 2032 ClearVisibleVolumes();; 2033 fVisLock = kFALSE;; 2034 }; 2035 if (!fLastVolume) {; 2036 // printf(""--- Drawing %6d nodes with %d visible levels\n"",fNVisNodes,fVisLevel);; 2037 return;; 2038 }; 2039 if (!gPad); 2040 return;; 2041 if (gPad->GetView()) {; 2042 // printf(""--- Drawing %6d nodes with %d visible levels\n"",fNVisNodes,fVisLevel);; 2043 ModifiedPad();; 2044 }; 2045}; 2046 ; 2047////////////////////////////////////////////////////////////////////////////////; 2048/// Set top geometry volume as visible.; 2049 ; 2050void TGeoPainter::SetTopVisible(Bool_t vis); 2051{; 2052 if (fTopVisible == vis); 2053 return;; 2054 fTopVisible = vis;; 2055 ModifiedPad();; 2056}; 2057 ; 2058////////////////////////////////////////////////////////////////////////////////; 2059/// Set drawing mode :; 2060/// - option=0 (default) all nodes drawn down to vislevel; 2061/// - option=1 leaves and nodes at vislevel drawn; 2062/// - option=2 path is drawn; 2063 ; 2064void TGeoPainter::SetVisOption(Int_t option); 2",MatchSource.WIKI,doc/master/TGeoPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPainter_8cxx_source.html
https://root.cern/doc/master/TGeoPainter_8cxx_source.html:67223,Availability,down,down,67223,"isNodes,fVisLevel);; 2043 ModifiedPad();; 2044 }; 2045}; 2046 ; 2047////////////////////////////////////////////////////////////////////////////////; 2048/// Set top geometry volume as visible.; 2049 ; 2050void TGeoPainter::SetTopVisible(Bool_t vis); 2051{; 2052 if (fTopVisible == vis); 2053 return;; 2054 fTopVisible = vis;; 2055 ModifiedPad();; 2056}; 2057 ; 2058////////////////////////////////////////////////////////////////////////////////; 2059/// Set drawing mode :; 2060/// - option=0 (default) all nodes drawn down to vislevel; 2061/// - option=1 leaves and nodes at vislevel drawn; 2062/// - option=2 path is drawn; 2063 ; 2064void TGeoPainter::SetVisOption(Int_t option); 2065{; 2066 if ((fVisOption < 0) || (fVisOption > 4)) {; 2067 Warning(""SetVisOption"", ""wrong visualization option"");; 2068 return;; 2069 }; 2070 ; 2071 if (option == kGeoVisChanged) {; 2072 if (fVisLock) {; 2073 ClearVisibleVolumes();; 2074 fVisLock = kFALSE;; 2075 }; 2076 ModifiedPad();; 2077 return;; 2078 }; 2079 ; 2080 if (fTopVolume) {; 2081 TGeoAtt *att = (TGeoAtt *)fTopVolume;; 2082 att->SetAttBit(TGeoAtt::kVisBranch, kFALSE);; 2083 att->SetAttBit(TGeoAtt::kVisContainers, kFALSE);; 2084 att->SetAttBit(TGeoAtt::kVisOnly, kFALSE);; 2085 switch (option) {; 2086 case kGeoVisDefault: att->SetAttBit(TGeoAtt::kVisContainers, kTRUE); break;; 2087 case kGeoVisLeaves: break;; 2088 case kGeoVisOnly: att->SetAttBit(TGeoAtt::kVisOnly, kTRUE); break;; 2089 }; 2090 }; 2091 ; 2092 if (fVisOption == option); 2093 return;; 2094 fVisOption = option;; 2095 if (fVisLock) {; 2096 ClearVisibleVolumes();; 2097 fVisLock = kFALSE;; 2098 }; 2099 ModifiedPad();; 2100}; 2101 ; 2102////////////////////////////////////////////////////////////////////////////////; 2103/// Returns distance between point px,py on the pad an a shape.; 2104 ; 2105Int_t TGeoPainter::ShapeDistancetoPrimitive(const TGeoShape *shape, Int_t numpoints, Int_t px, Int_t py) const; 2106{; 2107 const Int_t inaxis = 7;; 2108 const Int_t maxdist = 5;; ",MatchSource.WIKI,doc/master/TGeoPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPainter_8cxx_source.html
https://root.cern/doc/master/TGeoPainter_8cxx_source.html:83531,Availability,error,errors,83531,"kPointvoid CheckPoint(Double_t x=0, Double_t y=0, Double_t z=0, Option_t *option="""", Double_t safety=0.)Draw point (x,y,z) over the picture of the daughters of the volume containing this point.Definition TGeoChecker.cxx:1692; TGeoChecker::WeightDouble_t Weight(Double_t precision=0.01, Option_t *option=""v"")Estimate weight of top level volume with a precision SIGMA(W)/W better than PRECISION.Definition TGeoChecker.cxx:2890; TGeoChecker::OpProgressvoid OpProgress(const char *opname, Long64_t current, Long64_t size, TStopwatch *watch=nullptr, Bool_t last=kFALSE, Bool_t refresh=kFALSE, const char *msg="""")Print current operation progress.Definition TGeoChecker.cxx:151; TGeoChecker::CheckGeometryvoid CheckGeometry(Int_t nrays, Double_t startx, Double_t starty, Double_t startz) constShoot nrays with random directions from starting point (startx, starty, startz) in the reference fram...Definition TGeoChecker.cxx:809; TGeoChecker::CheckBoundaryReferencevirtual void CheckBoundaryReference(Int_t icheck=-1)Check the boundary errors reference file created by CheckBoundaryErrors method.Definition TGeoChecker.cxx:406; TGeoChecker::SetNmeshPointsvoid SetNmeshPoints(Int_t npoints=1000)Set number of points to be generated on the shape outline when checking for overlaps.Definition TGeoChecker.cxx:728; TGeoChecker::PrintOverlapsvoid PrintOverlaps() constPrint the current list of overlaps held by the manager class.Definition TGeoChecker.cxx:1678; TGeoChecker::Testvoid Test(Int_t npoints, Option_t *option)Check time of finding ""Where am I"" for n points.Definition TGeoChecker.cxx:2709; TGeoChecker::TestVoxelsBool_t TestVoxels(TGeoVolume *vol, Int_t npoints=1000000)Returns optimal voxelization type for volume vol.Definition TGeoChecker.cxx:3008; TGeoChecker::RandomRaysvoid RandomRays(Int_t nrays, Double_t startx, Double_t starty, Double_t startz, const char *target_vol=nullptr, Bool_t check_norm=kFALSE)Randomly shoot nrays from point (startx,starty,startz) and plot intersections with surface",MatchSource.WIKI,doc/master/TGeoPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPainter_8cxx_source.html
https://root.cern/doc/master/TGeoPainter_8cxx_source.html:99941,Availability,down,down,99941,"ter::UnbombTranslationvoid UnbombTranslation(const Double_t *tr, Double_t *bombtr) overrideGet the new 'unbombed' translation vector according current exploded view mode.Definition TGeoPainter.cxx:2194; TGeoPainter::fVisLockBool_t fVisLockDefinition TGeoPainter.h:52; TGeoPainter::PaintNodevoid PaintNode(TGeoNode *node, Option_t *option="""", TGeoMatrix *global=nullptr) overridePaint recursively a node and its content according to visualization options.Definition TGeoPainter.cxx:1376; TGeoPainter::DefaultAnglesvoid DefaultAngles() overrideSet default angles for the current view.Definition TGeoPainter.cxx:555; TGeoPainter::fClippingShapeTGeoShape * fClippingShapeDefinition TGeoPainter.h:65; TGeoPainter::PaintShapeBool_t PaintShape(const TGeoShape &shape, Option_t *option) constPaint the supplied shape into the current 3D viewer.Definition TGeoPainter.cxx:1550; TGeoPainter::fIsEditableBool_t fIsEditableDefinition TGeoPainter.h:70; TGeoPainter::CountNodesInt_t CountNodes(TGeoVolume *vol, Int_t level) constCount number of visible nodes down to a given level.Definition TGeoPainter.cxx:582; TGeoPainter::fCheckedBoxDouble_t fCheckedBox[6]Definition TGeoPainter.h:45; TGeoPainter::DrawShapevoid DrawShape(TGeoShape *shape, Option_t *option="""") overrideDraw a shape.Definition TGeoPainter.cxx:875; TGeoPainter::DrawOnlyvoid DrawOnly(Option_t *option="""") overrideDraw only one volume.Definition TGeoPainter.cxx:962; TGeoPainter::fOverlapTGeoOverlap * fOverlapDefinition TGeoPainter.h:60; TGeoPainter::CheckGeometryvoid CheckGeometry(Int_t nrays, Double_t startx, Double_t starty, Double_t startz) const overrideGeometry checking method (see TGeoChecker).Definition TGeoPainter.cxx:226; TGeoPainter::fBombYDouble_t fBombYDefinition TGeoPainter.h:42; TGeoPainter::fPaintingOverlapsBool_t fPaintingOverlapsDefinition TGeoPainter.h:54; TGeoPainter::CheckOverlapsvoid CheckOverlaps(const TGeoVolume *vol, Double_t ovlp=0.1, Option_t *option="""") const overrideCheck overlaps for the top volume of the g",MatchSource.WIKI,doc/master/TGeoPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPainter_8cxx_source.html
https://root.cern/doc/master/TGeoPainter_8cxx_source.html:103964,Availability,error,errors,103964,"obal=nullptr) overridePaint recursively a node and its content according to visualization options.Definition TGeoPainter.cxx:1384; TGeoPainter::fVolInfoTString fVolInfoDefinition TGeoPainter.h:58; TGeoPainter::CheckShapevoid CheckShape(TGeoShape *shape, Int_t testNo, Int_t nsamples, Option_t *option) overrideTest for shape navigation methods.Definition TGeoPainter.cxx:254; TGeoPainter::RandomPointsvoid RandomPoints(const TGeoVolume *vol, Int_t npoints, Option_t *option="""") overrideDraw random points in the bounding box of a volume.Definition TGeoPainter.cxx:1693; TGeoPainter::fTopVisibleBool_t fTopVisibleDefinition TGeoPainter.h:53; TGeoPainter::fGlobalTGeoHMatrix * fGlobalDefinition TGeoPainter.h:61; TGeoPainter::fVisLevelInt_t fVisLevelDefinition TGeoPainter.h:49; TGeoPainter::SetNsegmentsvoid SetNsegments(Int_t nseg=20) overrideSet number of segments to approximate circles.Definition TGeoPainter.cxx:1992; TGeoPainter::CheckBoundaryReferencevoid CheckBoundaryReference(Int_t icheck=-1) overrideCheck the boundary errors reference file created by CheckBoundaryErrors method.Definition TGeoPainter.cxx:210; TGeoPainter::AddTrackPointvoid AddTrackPoint(Double_t *point, Double_t *box, Bool_t reset=kFALSE) overrideAverage center of view of all painted tracklets and compute view box.Definition TGeoPainter.cxx:138; TGeoPainter::GrabFocusvoid GrabFocus(Int_t nfr=0, Double_t dlong=0, Double_t dlat=0, Double_t dpsi=0) overrideMove focus to current volume.Definition TGeoPainter.cxx:1206; TGeoPainter::DrawOverlapvoid DrawOverlap(void *ovlp, Option_t *option="""") overrideDraw an overlap.Definition TGeoPainter.cxx:913; TGeoPainter::SetVisLevelvoid SetVisLevel(Int_t level=3) overrideSet default level down to which visualization is performed.Definition TGeoPainter.cxx:2024; TGeoPainter::AddSize3Dvoid AddSize3D(Int_t numpoints, Int_t numsegs, Int_t numpolys) overrideAdd numpoints, numsegs, numpolys to the global 3D size.Definition TGeoPainter.cxx:121; TGeoPainter::fCheckedNodeTGeoNode *",MatchSource.WIKI,doc/master/TGeoPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPainter_8cxx_source.html
https://root.cern/doc/master/TGeoPainter_8cxx_source.html:104647,Availability,down,down,104647,"ition TGeoPainter.h:61; TGeoPainter::fVisLevelInt_t fVisLevelDefinition TGeoPainter.h:49; TGeoPainter::SetNsegmentsvoid SetNsegments(Int_t nseg=20) overrideSet number of segments to approximate circles.Definition TGeoPainter.cxx:1992; TGeoPainter::CheckBoundaryReferencevoid CheckBoundaryReference(Int_t icheck=-1) overrideCheck the boundary errors reference file created by CheckBoundaryErrors method.Definition TGeoPainter.cxx:210; TGeoPainter::AddTrackPointvoid AddTrackPoint(Double_t *point, Double_t *box, Bool_t reset=kFALSE) overrideAverage center of view of all painted tracklets and compute view box.Definition TGeoPainter.cxx:138; TGeoPainter::GrabFocusvoid GrabFocus(Int_t nfr=0, Double_t dlong=0, Double_t dlat=0, Double_t dpsi=0) overrideMove focus to current volume.Definition TGeoPainter.cxx:1206; TGeoPainter::DrawOverlapvoid DrawOverlap(void *ovlp, Option_t *option="""") overrideDraw an overlap.Definition TGeoPainter.cxx:913; TGeoPainter::SetVisLevelvoid SetVisLevel(Int_t level=3) overrideSet default level down to which visualization is performed.Definition TGeoPainter.cxx:2024; TGeoPainter::AddSize3Dvoid AddSize3D(Int_t numpoints, Int_t numsegs, Int_t numpolys) overrideAdd numpoints, numsegs, numpolys to the global 3D size.Definition TGeoPainter.cxx:121; TGeoPainter::fCheckedNodeTGeoNode * fCheckedNodeDefinition TGeoPainter.h:59; TGeoPainter::PaintPhysicalNodevoid PaintPhysicalNode(TGeoPhysicalNode *node, Option_t *option="""")Paints a physical node associated with a path.Definition TGeoPainter.cxx:1609; TGeoPainter::fNVisNodesInt_t fNVisNodesDefinition TGeoPainter.h:48; TGeoPainter::fExplodedViewInt_t fExplodedViewDefinition TGeoPainter.h:51; TGeoPainter::GetVolumeInfoconst char * GetVolumeInfo(const TGeoVolume *volume, Int_t px, Int_t py) const overrideGet some info about the current selected volume.Definition TGeoPainter.cxx:1151; TGeoPainter::DrawCurrentPointvoid DrawCurrentPoint(Int_t color) overrideDraw current point in the same view.Definition TGeoPainter.c",MatchSource.WIKI,doc/master/TGeoPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPainter_8cxx_source.html
https://root.cern/doc/master/TGeoPainter_8cxx_source.html:113957,Availability,error,error,113957,"ns name of object.Definition TNamed.h:47; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjArray::GetEntriesFastInt_t GetEntriesFast() constDefinition TObjArray.h:58; TObjArray::Clearvoid Clear(Option_t *option="""") overrideRemove all objects from the array.Definition TObjArray.cxx:321; TObjArray::UncheckedAtTObject * UncheckedAt(Int_t i) constDefinition TObjArray.h:84; TObjArray::Addvoid Add(TObject *obj) overrideDefinition TObjArray.h:68; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:213; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::AppendPadvirtual void AppendPad(Option_t *option="""")Append graphics object to current pad.Definition TObject.cxx:190; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TPluginHandlerDefinition TPluginManager.h:103; TPluginHandler::ExecPluginLongptr_t ExecPlugin(int nargs)Definition TPluginManager.h:231; TPointDefinition TPoint.h:31; TPoint::fYSCoord_t fYDefinition TPoint.h:36; TPoint::fXSCoord_t fXDefinition TPoint.h:35; TPolyMarker3DA 3D polymarker.Definition TPolyMarker3D.h:33; TPolyMarker3D::SetNextPointvirtual Int_t SetNextPoint(Double_t x, Double_t y, Double_t z)Set point following LastPoint to x, y, z.Definition TPolyMarker3D.cxx:523; TPolyMarker3D::Drawvoid Draw(Option_t *option="""") overrideDraws 3-D polymarker with its current attributes.Definition TPolyMarker3D.cxx:242; TStopwatchStopwatch class.Definition TStopwatch.h:28; TStopwatch::Startvoid Start(Bool_t reset=kTRUE)Start the stopwatch.Definition TStopwatch.cxx:58; TStopwatch::Stopvoid Stop()Stop the stopwatch.Definition TStopwatch.cxx:77; TStringBasic string class.Definition TString.h:139; TString::ToLowervoid ToLower()Change string to lower-case.",MatchSource.WIKI,doc/master/TGeoPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPainter_8cxx_source.html
https://root.cern/doc/master/TGeoPainter_8cxx_source.html:40151,Deployability,update,update,40151,"uble_t phimin,; 1242 Double_t phimax, Double_t rmin, Double_t rmax, Option_t *option); 1243{; 1244 return fChecker->LegoPlot(ntheta, themin, themax, nphi, phimin, phimax, rmin, rmax, option);; 1245}; 1246////////////////////////////////////////////////////////////////////////////////; 1247/// Convert a local vector according view rotation matrix; 1248 ; 1249void TGeoPainter::LocalToMasterVect(const Double_t *local, Double_t *master) const; 1250{; 1251 for (Int_t i = 0; i < 3; i++); 1252 master[i] = -local[0] * fMat[i] - local[1] * fMat[i + 3] - local[2] * fMat[i + 6];; 1253}; 1254 ; 1255////////////////////////////////////////////////////////////////////////////////; 1256/// Check if a pad and view are present and send signal ""Modified"" to pad.; 1257 ; 1258void TGeoPainter::ModifiedPad(Bool_t update) const; 1259{; 1260 if (!gPad); 1261 return;; 1262 if (update) {; 1263 gPad->Update();; 1264 return;; 1265 }; 1266 TView *view = gPad->GetView();; 1267 if (!view); 1268 return;; 1269 view->SetViewChanged();; 1270 gPad->Modified();; 1271 if (gROOT->FromPopUp()); 1272 gPad->Update();; 1273}; 1274 ; 1275////////////////////////////////////////////////////////////////////////////////; 1276/// Paint current geometry according to option.; 1277 ; 1278void TGeoPainter::Paint(Option_t *option); 1279{; 1280 if (!fGeoManager || !fTopVolume); 1281 return;; 1282 Bool_t is_padviewer = kTRUE;; 1283 if (gPad); 1284 is_padviewer = (!strcmp(gPad->GetViewer3D()->ClassName(), ""TViewer3DPad"")) ? kTRUE : kFALSE;; 1285 ; 1286 fIsRaytracing = fTopVolume->IsRaytracing();; 1287 if (fTopVolume->IsVisContainers()); 1288 fVisOption = kGeoVisDefault;; 1289 else if (fTopVolume->IsVisLeaves()); 1290 fVisOption = kGeoVisLeaves;; 1291 else if (fTopVolume->IsVisOnly()); 1292 fVisOption = kGeoVisOnly;; 1293 else if (fTopVolume->IsVisBranch()); 1294 fVisOption = kGeoVisBranch;; 1295 ; 1296 if (!fIsRaytracing || !is_padviewer) {; 1297 if (fGeoManager->IsDrawingExtra()) {; 1298 // loop the list of physical vo",MatchSource.WIKI,doc/master/TGeoPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPainter_8cxx_source.html
https://root.cern/doc/master/TGeoPainter_8cxx_source.html:40213,Deployability,update,update,40213,"uble_t phimin,; 1242 Double_t phimax, Double_t rmin, Double_t rmax, Option_t *option); 1243{; 1244 return fChecker->LegoPlot(ntheta, themin, themax, nphi, phimin, phimax, rmin, rmax, option);; 1245}; 1246////////////////////////////////////////////////////////////////////////////////; 1247/// Convert a local vector according view rotation matrix; 1248 ; 1249void TGeoPainter::LocalToMasterVect(const Double_t *local, Double_t *master) const; 1250{; 1251 for (Int_t i = 0; i < 3; i++); 1252 master[i] = -local[0] * fMat[i] - local[1] * fMat[i + 3] - local[2] * fMat[i + 6];; 1253}; 1254 ; 1255////////////////////////////////////////////////////////////////////////////////; 1256/// Check if a pad and view are present and send signal ""Modified"" to pad.; 1257 ; 1258void TGeoPainter::ModifiedPad(Bool_t update) const; 1259{; 1260 if (!gPad); 1261 return;; 1262 if (update) {; 1263 gPad->Update();; 1264 return;; 1265 }; 1266 TView *view = gPad->GetView();; 1267 if (!view); 1268 return;; 1269 view->SetViewChanged();; 1270 gPad->Modified();; 1271 if (gROOT->FromPopUp()); 1272 gPad->Update();; 1273}; 1274 ; 1275////////////////////////////////////////////////////////////////////////////////; 1276/// Paint current geometry according to option.; 1277 ; 1278void TGeoPainter::Paint(Option_t *option); 1279{; 1280 if (!fGeoManager || !fTopVolume); 1281 return;; 1282 Bool_t is_padviewer = kTRUE;; 1283 if (gPad); 1284 is_padviewer = (!strcmp(gPad->GetViewer3D()->ClassName(), ""TViewer3DPad"")) ? kTRUE : kFALSE;; 1285 ; 1286 fIsRaytracing = fTopVolume->IsRaytracing();; 1287 if (fTopVolume->IsVisContainers()); 1288 fVisOption = kGeoVisDefault;; 1289 else if (fTopVolume->IsVisLeaves()); 1290 fVisOption = kGeoVisLeaves;; 1291 else if (fTopVolume->IsVisOnly()); 1292 fVisOption = kGeoVisOnly;; 1293 else if (fTopVolume->IsVisBranch()); 1294 fVisOption = kGeoVisBranch;; 1295 ; 1296 if (!fIsRaytracing || !is_padviewer) {; 1297 if (fGeoManager->IsDrawingExtra()) {; 1298 // loop the list of physical vo",MatchSource.WIKI,doc/master/TGeoPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPainter_8cxx_source.html
https://root.cern/doc/master/TGeoPainter_8cxx_source.html:72972,Deployability,update,updatestatic,72972,"tr[2] /= fBombR;; 2213 return;; 2214 default: return;; 2215 }; 2216}; 2217 ; 2218////////////////////////////////////////////////////////////////////////////////; 2219/// Compute weight [kg] of the current volume.; 2220 ; 2221Double_t TGeoPainter::Weight(Double_t precision, Option_t *option); 2222{; 2223 return fChecker->Weight(precision, option);; 2224}; kButton1Double@ kButton1DoubleDefinition Buttons.h:24; kButton1Up@ kButton1UpDefinition Buttons.h:19; kMouseLeave@ kMouseLeaveDefinition Buttons.h:23; kButton1Down@ kButton1DownDefinition Buttons.h:17; kMouseEnter@ kMouseEnterDefinition Buttons.h:23; kWatch@ kWatchDefinition GuiTypes.h:375; kHand@ kHandDefinition GuiTypes.h:374; kPointer@ kPointerDefinition GuiTypes.h:375; b#define b(i)Definition RSha256.hxx:100; g#define g(i)Definition RSha256.hxx:105; s1#define s1(x)Definition RSha256.hxx:91; h#define h(i)Definition RSha256.hxx:106; updatestatic void update(gsl_integration_workspace *workspace, double a1, double b1, double area1, double error1, double a2, double b2, double area2, double error2)Definition RooAdaptiveGaussKronrodIntegrator1D.cxx:633; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; Int_tint Int_tDefinition RtypesCore.h:45; Float_tfloat Float_tDefinition RtypesCore.h:57; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; Double_tdouble Double_tDefinition RtypesCore.h:59; Long64_tlong long Long64_tDefinition RtypesCore.h:69; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; Option_tconst char Option_tDefinition RtypesCore.h:66; ClassImp#define ClassImp(name)Definition Rtypes.h:382; kRed@ kRedDefinition Rtypes.h:66; kBlack@ kBlackDefinition Rtypes.h:65; kGreen@ kGreenDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; TAttFill.h; TAttLine.h; TBuffer3DTypes.h; TBuffer3D.h; TCanvasImp.h; TCanvas.h; TClass.h; TColor.h; TF1.h; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; widOption_t Option_t TPoint TPoint const char GetTextMagnitude Ge",MatchSource.WIKI,doc/master/TGeoPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPainter_8cxx_source.html
https://root.cern/doc/master/TGeoPainter_8cxx_source.html:72990,Deployability,update,update,72990,"tr[2] /= fBombR;; 2213 return;; 2214 default: return;; 2215 }; 2216}; 2217 ; 2218////////////////////////////////////////////////////////////////////////////////; 2219/// Compute weight [kg] of the current volume.; 2220 ; 2221Double_t TGeoPainter::Weight(Double_t precision, Option_t *option); 2222{; 2223 return fChecker->Weight(precision, option);; 2224}; kButton1Double@ kButton1DoubleDefinition Buttons.h:24; kButton1Up@ kButton1UpDefinition Buttons.h:19; kMouseLeave@ kMouseLeaveDefinition Buttons.h:23; kButton1Down@ kButton1DownDefinition Buttons.h:17; kMouseEnter@ kMouseEnterDefinition Buttons.h:23; kWatch@ kWatchDefinition GuiTypes.h:375; kHand@ kHandDefinition GuiTypes.h:374; kPointer@ kPointerDefinition GuiTypes.h:375; b#define b(i)Definition RSha256.hxx:100; g#define g(i)Definition RSha256.hxx:105; s1#define s1(x)Definition RSha256.hxx:91; h#define h(i)Definition RSha256.hxx:106; updatestatic void update(gsl_integration_workspace *workspace, double a1, double b1, double area1, double error1, double a2, double b2, double area2, double error2)Definition RooAdaptiveGaussKronrodIntegrator1D.cxx:633; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; Int_tint Int_tDefinition RtypesCore.h:45; Float_tfloat Float_tDefinition RtypesCore.h:57; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; Double_tdouble Double_tDefinition RtypesCore.h:59; Long64_tlong long Long64_tDefinition RtypesCore.h:69; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; Option_tconst char Option_tDefinition RtypesCore.h:66; ClassImp#define ClassImp(name)Definition Rtypes.h:382; kRed@ kRedDefinition Rtypes.h:66; kBlack@ kBlackDefinition Rtypes.h:65; kGreen@ kGreenDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; TAttFill.h; TAttLine.h; TBuffer3DTypes.h; TBuffer3D.h; TCanvasImp.h; TCanvas.h; TClass.h; TColor.h; TF1.h; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; widOption_t Option_t TPoint TPoint const char GetTextMagnitude Ge",MatchSource.WIKI,doc/master/TGeoPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPainter_8cxx_source.html
https://root.cern/doc/master/TGeoPainter_8cxx_source.html:107236,Deployability,update,update,107236,"rrideDraw the time evolution of a radionuclide.Definition TGeoPainter.cxx:726; TGeoPainter::fCheckerTGeoChecker * fCheckerDefinition TGeoPainter.h:64; TGeoPainter::fIsRaytracingBool_t fIsRaytracingDefinition TGeoPainter.h:55; TGeoPainter::ExecuteShapeEventvoid ExecuteShapeEvent(TGeoShape *shape, Int_t event, Int_t px, Int_t py) overrideExecute mouse actions on a given shape.Definition TGeoPainter.cxx:1089; TGeoPainter::WeightDouble_t Weight(Double_t precision, Option_t *option=""v"") overrideCompute weight [kg] of the current volume.Definition TGeoPainter.cxx:2221; TGeoPainter::ExecuteVolumeEventvoid ExecuteVolumeEvent(TGeoVolume *volume, Int_t event, Int_t px, Int_t py) overrideExecute mouse actions on a given volume.Definition TGeoPainter.cxx:1104; TGeoPainter::TGeoPainterTGeoPainter(TGeoManager *manager)Default constructor.Definition TGeoPainter.cxx:65; TGeoPainter::fBombXDouble_t fBombXDefinition TGeoPainter.h:41; TGeoPainter::ModifiedPadvoid ModifiedPad(Bool_t update=kFALSE) const overrideCheck if a pad and view are present and send signal ""Modified"" to pad.Definition TGeoPainter.cxx:1258; TGeoPainter::SetTopVisiblevoid SetTopVisible(Bool_t vis=kTRUE) overrideSet top geometry volume as visible.Definition TGeoPainter.cxx:2050; TGeoPainter::DrawPanelvoid DrawPanel() overrideDefinition TGeoPainter.cxx:1021; TGeoPainter::fVisOptionInt_t fVisOptionDefinition TGeoPainter.h:50; TGeoPainter::TestVoxelsBool_t TestVoxels(TGeoVolume *vol) overrideCheck voxels efficiency per volume.Definition TGeoPainter.cxx:2186; TGeoPhysicalNodePhysical nodes are the actual 'touchable' objects in the geometry, representing a path of positioned ...Definition TGeoPhysicalNode.h:35; TGeoPhysicalNode::GetLevelInt_t GetLevel() constDefinition TGeoPhysicalNode.h:67; TGeoPhysicalNode::IsVisibleBool_t IsVisible() constDefinition TGeoPhysicalNode.h:78; TGeoPhysicalNode::IsVisibleFullBool_t IsVisibleFull() constDefinition TGeoPhysicalNode.h:79; TGeoPhysicalNode::GetMatrixTGeoHMatrix * GetMatrix(Int_t",MatchSource.WIKI,doc/master/TGeoPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPainter_8cxx_source.html
https://root.cern/doc/master/TGeoPainter_8cxx_source.html:10737,Energy Efficiency,green,green,10737,"///////////////////////////////////////; 290/// Get index of a base color with given light intensity (0,1); 291 ; 292Int_t TGeoPainter::GetColor(Int_t base, Float_t light) const; 293{; 294 using IntMap_t = std::map<Int_t, Int_t>;; 295 constexpr Int_t ncolors = 100;; 296 constexpr Float_t lmin = 0.25;; 297 constexpr Float_t lmax = 0.75;; 298 static IntMap_t colmap;; 299 Int_t color = base;; 300 // Search color in the map; 301 auto it = colmap.find(base);; 302 if (it != colmap.end()); 303 return (it->second + light * (ncolors - 1));; 304 // Get color pointer if stored; 305 TColor *col_base = gROOT->GetColor(base);; 306 if (!col_base) {; 307 // If color not defined, use gray palette; 308 it = colmap.find(kBlack);; 309 if (it != colmap.end()); 310 return (it->second + light * (ncolors - 1));; 311 col_base = gROOT->GetColor(kBlack);; 312 color = 1;; 313 }; 314 // Create a color palette for col_base; 315 Float_t r = 0., g = 0., b = 0., h = 0., l = 0., s = 0.;; 316 Double_t red[2], green[2], blue[2];; 317 Double_t stop[] = {0., 1.0};; 318 ; 319 if (col_base); 320 col_base->GetRGB(r, g, b);; 321 TColor::RGB2HLS(r, g, b, h, l, s);; 322 TColor::HLS2RGB(h, lmin, s, r, g, b);; 323 red[0] = r;; 324 green[0] = g;; 325 blue[0] = b;; 326 TColor::HLS2RGB(h, lmax, s, r, g, b);; 327 red[1] = r;; 328 green[1] = g;; 329 blue[1] = b;; 330 Int_t color_map_idx = TColor::CreateGradientColorTable(2, stop, red, green, blue, ncolors, 1., kFALSE);; 331 colmap[color] = color_map_idx;; 332 return (color_map_idx + light * (ncolors - 1));; 333}; 334 ; 335////////////////////////////////////////////////////////////////////////////////; 336/// Get currently drawn volume.; 337 ; 338TGeoVolume *TGeoPainter::GetDrawnVolume() const; 339{; 340 if (!gPad); 341 return nullptr;; 342 return fTopVolume;; 343}; 344 ; 345////////////////////////////////////////////////////////////////////////////////; 346/// Compute the closest distance of approach from point px,py to a volume.; 347 ; 348Int_t TGeoPainter::Distan",MatchSource.WIKI,doc/master/TGeoPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPainter_8cxx_source.html
https://root.cern/doc/master/TGeoPainter_8cxx_source.html:10952,Energy Efficiency,green,green,10952,"constexpr Int_t ncolors = 100;; 296 constexpr Float_t lmin = 0.25;; 297 constexpr Float_t lmax = 0.75;; 298 static IntMap_t colmap;; 299 Int_t color = base;; 300 // Search color in the map; 301 auto it = colmap.find(base);; 302 if (it != colmap.end()); 303 return (it->second + light * (ncolors - 1));; 304 // Get color pointer if stored; 305 TColor *col_base = gROOT->GetColor(base);; 306 if (!col_base) {; 307 // If color not defined, use gray palette; 308 it = colmap.find(kBlack);; 309 if (it != colmap.end()); 310 return (it->second + light * (ncolors - 1));; 311 col_base = gROOT->GetColor(kBlack);; 312 color = 1;; 313 }; 314 // Create a color palette for col_base; 315 Float_t r = 0., g = 0., b = 0., h = 0., l = 0., s = 0.;; 316 Double_t red[2], green[2], blue[2];; 317 Double_t stop[] = {0., 1.0};; 318 ; 319 if (col_base); 320 col_base->GetRGB(r, g, b);; 321 TColor::RGB2HLS(r, g, b, h, l, s);; 322 TColor::HLS2RGB(h, lmin, s, r, g, b);; 323 red[0] = r;; 324 green[0] = g;; 325 blue[0] = b;; 326 TColor::HLS2RGB(h, lmax, s, r, g, b);; 327 red[1] = r;; 328 green[1] = g;; 329 blue[1] = b;; 330 Int_t color_map_idx = TColor::CreateGradientColorTable(2, stop, red, green, blue, ncolors, 1., kFALSE);; 331 colmap[color] = color_map_idx;; 332 return (color_map_idx + light * (ncolors - 1));; 333}; 334 ; 335////////////////////////////////////////////////////////////////////////////////; 336/// Get currently drawn volume.; 337 ; 338TGeoVolume *TGeoPainter::GetDrawnVolume() const; 339{; 340 if (!gPad); 341 return nullptr;; 342 return fTopVolume;; 343}; 344 ; 345////////////////////////////////////////////////////////////////////////////////; 346/// Compute the closest distance of approach from point px,py to a volume.; 347 ; 348Int_t TGeoPainter::DistanceToPrimitiveVol(TGeoVolume *volume, Int_t px, Int_t py); 349{; 350 const Int_t big = 9999;; 351 const Int_t inaxis = 7;; 352 const Int_t maxdist = 5;; 353 ; 354 if (fTopVolume != volume); 355 fTopVolume = volume;; 356 TView *view = gP",MatchSource.WIKI,doc/master/TGeoPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPainter_8cxx_source.html
https://root.cern/doc/master/TGeoPainter_8cxx_source.html:11049,Energy Efficiency,green,green,11049,"constexpr Int_t ncolors = 100;; 296 constexpr Float_t lmin = 0.25;; 297 constexpr Float_t lmax = 0.75;; 298 static IntMap_t colmap;; 299 Int_t color = base;; 300 // Search color in the map; 301 auto it = colmap.find(base);; 302 if (it != colmap.end()); 303 return (it->second + light * (ncolors - 1));; 304 // Get color pointer if stored; 305 TColor *col_base = gROOT->GetColor(base);; 306 if (!col_base) {; 307 // If color not defined, use gray palette; 308 it = colmap.find(kBlack);; 309 if (it != colmap.end()); 310 return (it->second + light * (ncolors - 1));; 311 col_base = gROOT->GetColor(kBlack);; 312 color = 1;; 313 }; 314 // Create a color palette for col_base; 315 Float_t r = 0., g = 0., b = 0., h = 0., l = 0., s = 0.;; 316 Double_t red[2], green[2], blue[2];; 317 Double_t stop[] = {0., 1.0};; 318 ; 319 if (col_base); 320 col_base->GetRGB(r, g, b);; 321 TColor::RGB2HLS(r, g, b, h, l, s);; 322 TColor::HLS2RGB(h, lmin, s, r, g, b);; 323 red[0] = r;; 324 green[0] = g;; 325 blue[0] = b;; 326 TColor::HLS2RGB(h, lmax, s, r, g, b);; 327 red[1] = r;; 328 green[1] = g;; 329 blue[1] = b;; 330 Int_t color_map_idx = TColor::CreateGradientColorTable(2, stop, red, green, blue, ncolors, 1., kFALSE);; 331 colmap[color] = color_map_idx;; 332 return (color_map_idx + light * (ncolors - 1));; 333}; 334 ; 335////////////////////////////////////////////////////////////////////////////////; 336/// Get currently drawn volume.; 337 ; 338TGeoVolume *TGeoPainter::GetDrawnVolume() const; 339{; 340 if (!gPad); 341 return nullptr;; 342 return fTopVolume;; 343}; 344 ; 345////////////////////////////////////////////////////////////////////////////////; 346/// Compute the closest distance of approach from point px,py to a volume.; 347 ; 348Int_t TGeoPainter::DistanceToPrimitiveVol(TGeoVolume *volume, Int_t px, Int_t py); 349{; 350 const Int_t big = 9999;; 351 const Int_t inaxis = 7;; 352 const Int_t maxdist = 5;; 353 ; 354 if (fTopVolume != volume); 355 fTopVolume = volume;; 356 TView *view = gP",MatchSource.WIKI,doc/master/TGeoPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPainter_8cxx_source.html
https://root.cern/doc/master/TGeoPainter_8cxx_source.html:11155,Energy Efficiency,green,green,11155,"constexpr Int_t ncolors = 100;; 296 constexpr Float_t lmin = 0.25;; 297 constexpr Float_t lmax = 0.75;; 298 static IntMap_t colmap;; 299 Int_t color = base;; 300 // Search color in the map; 301 auto it = colmap.find(base);; 302 if (it != colmap.end()); 303 return (it->second + light * (ncolors - 1));; 304 // Get color pointer if stored; 305 TColor *col_base = gROOT->GetColor(base);; 306 if (!col_base) {; 307 // If color not defined, use gray palette; 308 it = colmap.find(kBlack);; 309 if (it != colmap.end()); 310 return (it->second + light * (ncolors - 1));; 311 col_base = gROOT->GetColor(kBlack);; 312 color = 1;; 313 }; 314 // Create a color palette for col_base; 315 Float_t r = 0., g = 0., b = 0., h = 0., l = 0., s = 0.;; 316 Double_t red[2], green[2], blue[2];; 317 Double_t stop[] = {0., 1.0};; 318 ; 319 if (col_base); 320 col_base->GetRGB(r, g, b);; 321 TColor::RGB2HLS(r, g, b, h, l, s);; 322 TColor::HLS2RGB(h, lmin, s, r, g, b);; 323 red[0] = r;; 324 green[0] = g;; 325 blue[0] = b;; 326 TColor::HLS2RGB(h, lmax, s, r, g, b);; 327 red[1] = r;; 328 green[1] = g;; 329 blue[1] = b;; 330 Int_t color_map_idx = TColor::CreateGradientColorTable(2, stop, red, green, blue, ncolors, 1., kFALSE);; 331 colmap[color] = color_map_idx;; 332 return (color_map_idx + light * (ncolors - 1));; 333}; 334 ; 335////////////////////////////////////////////////////////////////////////////////; 336/// Get currently drawn volume.; 337 ; 338TGeoVolume *TGeoPainter::GetDrawnVolume() const; 339{; 340 if (!gPad); 341 return nullptr;; 342 return fTopVolume;; 343}; 344 ; 345////////////////////////////////////////////////////////////////////////////////; 346/// Compute the closest distance of approach from point px,py to a volume.; 347 ; 348Int_t TGeoPainter::DistanceToPrimitiveVol(TGeoVolume *volume, Int_t px, Int_t py); 349{; 350 const Int_t big = 9999;; 351 const Int_t inaxis = 7;; 352 const Int_t maxdist = 5;; 353 ; 354 if (fTopVolume != volume); 355 fTopVolume = volume;; 356 TView *view = gP",MatchSource.WIKI,doc/master/TGeoPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPainter_8cxx_source.html
https://root.cern/doc/master/TGeoPainter_8cxx_source.html:770,Integrability,interface,interfaces,770,". ROOT: geom/geompainter/src/TGeoPainter.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TGeoPainter.cxx. Go to the documentation of this file. 1// @(#)root/geompainter:$Id: 58726ead32989b65bb2cbff2af4235fe9c6b12ae $; 2// Author: Andrei Gheata 05/03/02; 3/*************************************************************************; 4 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 5 * All rights reserved. *; 6 * *; 7 * For the licensing terms see $ROOTSYS/LICENSE. *; 8 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 9 *************************************************************************/; 10 ; 11/** \class TGeoPainter; 12\ingroup Geometry_painter; 13 ; 14Class implementing all draw interfaces for a generic 3D viewer; 15using TBuffer3D mechanism.; 16*/; 17 ; 18#include <map>; 19#include ""TROOT.h""; 20#include ""TClass.h""; 21#include ""TColor.h""; 22#include ""TPoint.h""; 23#include ""TView.h""; 24#include ""TAttLine.h""; 25#include ""TAttFill.h""; 26#include ""TVirtualPad.h""; 27#include ""TCanvas.h""; 28#include ""TCanvasImp.h""; 29#include ""TH2F.h""; 30#include ""TF1.h""; 31#include ""TGraph.h""; 32#include ""TPluginManager.h""; 33#include ""TVirtualPadEditor.h""; 34#include ""TStopwatch.h""; 35 ; 36#include ""TPolyMarker3D.h""; 37 ; 38#include ""TGeoAtt.h""; 39#include ""TGeoVolume.h""; 40#include ""TGeoNode.h""; 41#include ""TGeoElement.h""; 42#include ""TGeoManager.h""; 43#include ""TGeoTrack.h""; 44#include ""TGeoOverlap.h""; 45#include ""TGeoChecker.h""; 46#include ""TGeoPhysicalNode.h""; 47#include ""TGeoPolygon.h""; 48#include ""TGeoCompositeShape.h""; 49#include ""TGeoShapeAssembly.h""; 50#include ""TGeoPainter.h""; 51#include ""TMath.h""; 52 ; 53#include ""X3DBuffer.h""; 54 ; 55#include ""TBuffer3D.h""; 56#include ""TBuffer3DTypes.h""; 57#include ""TVirtualViewer3D.h""; 58#include ""TVirtualX.h""; 59 ; 60ClassImp(TGeoPainter);; 61 ; 62////////////////////////////////////////////////////////////////////////////////; 63/// Default constructor.; 64 ;",MatchSource.WIKI,doc/master/TGeoPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPainter_8cxx_source.html
https://root.cern/doc/master/TGeoPainter_8cxx_source.html:93399,Integrability,interface,interfaces,93399,"entDefinition TGeoNode.cxx:294; TGeoNode::GetVolumeTGeoVolume * GetVolume() constDefinition TGeoNode.h:99; TGeoNode::GetNdaughtersInt_t GetNdaughters() constDefinition TGeoNode.h:91; TGeoNode::IsVisibleBool_t IsVisible() constDefinition TGeoNode.h:109; TGeoOverlapBase class describing geometry overlaps.Definition TGeoOverlap.h:37; TGeoOverlap::GetSecondVolumeTGeoVolume * GetSecondVolume() constDefinition TGeoOverlap.h:66; TGeoOverlap::GetPolyMarkerTPolyMarker3D * GetPolyMarker() constDefinition TGeoOverlap.h:64; TGeoOverlap::GetFirstMatrixTGeoHMatrix * GetFirstMatrix() constDefinition TGeoOverlap.h:67; TGeoOverlap::IsExtrusionBool_t IsExtrusion() constDefinition TGeoOverlap.h:70; TGeoOverlap::GetOverlapDouble_t GetOverlap() constDefinition TGeoOverlap.h:69; TGeoOverlap::GetSecondMatrixTGeoHMatrix * GetSecondMatrix() constDefinition TGeoOverlap.h:68; TGeoOverlap::GetFirstVolumeTGeoVolume * GetFirstVolume() constDefinition TGeoOverlap.h:65; TGeoPainterClass implementing all draw interfaces for a generic 3D viewer using TBuffer3D mechanism.Definition TGeoPainter.h:39; TGeoPainter::AddTrackTVirtualGeoTrack * AddTrack(Int_t id, Int_t pdgcode, TObject *part) overrideCreate a primary TGeoTrack.Definition TGeoPainter.cxx:130; TGeoPainter::PaintOverlapvoid PaintOverlap(void *ovlp, Option_t *option="""") overridePaint an overlap.Definition TGeoPainter.cxx:1321; TGeoPainter::fBombZDouble_t fBombZDefinition TGeoPainter.h:43; TGeoPainter::EstimateCameraMovevoid EstimateCameraMove(Double_t tmin, Double_t tmax, Double_t *start, Double_t *end) overrideEstimate camera movement between tmin and tmax for best track display.Definition TGeoPainter.cxx:1039; TGeoPainter::fVisVolumesTObjArray * fVisVolumesDefinition TGeoPainter.h:69; TGeoPainter::fPluginTGeoIteratorPlugin * fPluginDefinition TGeoPainter.h:68; TGeoPainter::fMatDouble_t fMat[9]Definition TGeoPainter.h:46; TGeoPainter::SamplePointsTGeoNode * SamplePoints(Int_t npoints, Double_t &dist, Double_t epsil, const char *g3path) overri",MatchSource.WIKI,doc/master/TGeoPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPainter_8cxx_source.html
https://root.cern/doc/master/TGeoPainter_8cxx_source.html:113706,Integrability,message,message,113706,"nition TGraph.cxx:2397; TH2F2-D histogram with a float per channel (see TH1 documentation)Definition TH2.h:307; TIterDefinition TCollection.h:235; TIter::Resetvoid Reset()Definition TCollection.h:254; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjArray::GetEntriesFastInt_t GetEntriesFast() constDefinition TObjArray.h:58; TObjArray::Clearvoid Clear(Option_t *option="""") overrideRemove all objects from the array.Definition TObjArray.cxx:321; TObjArray::UncheckedAtTObject * UncheckedAt(Int_t i) constDefinition TObjArray.h:84; TObjArray::Addvoid Add(TObject *obj) overrideDefinition TObjArray.h:68; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:213; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::AppendPadvirtual void AppendPad(Option_t *option="""")Append graphics object to current pad.Definition TObject.cxx:190; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TPluginHandlerDefinition TPluginManager.h:103; TPluginHandler::ExecPluginLongptr_t ExecPlugin(int nargs)Definition TPluginManager.h:231; TPointDefinition TPoint.h:31; TPoint::fYSCoord_t fYDefinition TPoint.h:36; TPoint::fXSCoord_t fXDefinition TPoint.h:35; TPolyMarker3DA 3D polymarker.Definition TPolyMarker3D.h:33; TPolyMarker3D::SetNextPointvirtual Int_t SetNextPoint(Double_t x, Double_t y, Double_t z)Set point following LastPoint to x, y, z.Definition TPolyMarker3D.cxx:523; TPolyMarker3D::Drawvoid Draw(Option_t *option="""") overrideDraws 3-D polymarker with its current attributes.Definition TPolyMarker3D.cxx:242; TStopwatchStopwatch class.Definition TStopwatch.h:28; TStopwatch::Startvoid Sta",MatchSource.WIKI,doc/master/TGeoPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPainter_8cxx_source.html
https://root.cern/doc/master/TGeoPainter_8cxx_source.html:113963,Integrability,message,message,113963,"ns name of object.Definition TNamed.h:47; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjArray::GetEntriesFastInt_t GetEntriesFast() constDefinition TObjArray.h:58; TObjArray::Clearvoid Clear(Option_t *option="""") overrideRemove all objects from the array.Definition TObjArray.cxx:321; TObjArray::UncheckedAtTObject * UncheckedAt(Int_t i) constDefinition TObjArray.h:84; TObjArray::Addvoid Add(TObject *obj) overrideDefinition TObjArray.h:68; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:213; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::AppendPadvirtual void AppendPad(Option_t *option="""")Append graphics object to current pad.Definition TObject.cxx:190; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TPluginHandlerDefinition TPluginManager.h:103; TPluginHandler::ExecPluginLongptr_t ExecPlugin(int nargs)Definition TPluginManager.h:231; TPointDefinition TPoint.h:31; TPoint::fYSCoord_t fYDefinition TPoint.h:36; TPoint::fXSCoord_t fXDefinition TPoint.h:35; TPolyMarker3DA 3D polymarker.Definition TPolyMarker3D.h:33; TPolyMarker3D::SetNextPointvirtual Int_t SetNextPoint(Double_t x, Double_t y, Double_t z)Set point following LastPoint to x, y, z.Definition TPolyMarker3D.cxx:523; TPolyMarker3D::Drawvoid Draw(Option_t *option="""") overrideDraws 3-D polymarker with its current attributes.Definition TPolyMarker3D.cxx:242; TStopwatchStopwatch class.Definition TStopwatch.h:28; TStopwatch::Startvoid Start(Bool_t reset=kTRUE)Start the stopwatch.Definition TStopwatch.cxx:58; TStopwatch::Stopvoid Stop()Stop the stopwatch.Definition TStopwatch.cxx:77; TStringBasic string class.Definition TString.h:139; TString::ToLowervoid ToLower()Change string to lower-case.",MatchSource.WIKI,doc/master/TGeoPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPainter_8cxx_source.html
https://root.cern/doc/master/TGeoPainter_8cxx_source.html:86628,Modifiability,plugin,plugin,86628,".Definition TGeoCompositeShape.cxx:429; TGeoHMatrixMatrix class used for computing global transformations Should NOT be used for node definition.Definition TGeoMatrix.h:458; TGeoHMatrix::Clearvoid Clear(Option_t *option="""") overrideclear the data for this matrixDefinition TGeoMatrix.cxx:2512; TGeoIteratorPlugin::SetIteratorvoid SetIterator(const TGeoIterator *iter)Definition TGeoNode.h:237; TGeoIteratorPlugin::ProcessNodevirtual void ProcessNode()=0; TGeoIteratorA geometry iterator.Definition TGeoNode.h:248; TGeoIterator::GetCurrentMatrixconst TGeoMatrix * GetCurrentMatrix() constReturns global matrix for current node.Definition TGeoNode.cxx:1163; TGeoIterator::SetTopNamevoid SetTopName(const char *name)Set the top name for path.Definition TGeoNode.cxx:1234; TGeoIterator::GetLevelInt_t GetLevel() constDefinition TGeoNode.h:294; TGeoIterator::GetPathvoid GetPath(TString &path) constReturns the path for the current node.Definition TGeoNode.cxx:1193; TGeoIterator::SetUserPluginvoid SetUserPlugin(TGeoIteratorPlugin *plugin)Set a plugin.Definition TGeoNode.cxx:1282; TGeoIterator::Skipvoid Skip()Stop iterating the current branch.Definition TGeoNode.cxx:1243; TGeoManagerThe manager class for any TGeo geometry.Definition TGeoManager.h:44; TGeoManager::GetMotherTGeoNode * GetMother(Int_t up=1) constDefinition TGeoManager.h:493; TGeoManager::FindNormalFastDouble_t * FindNormalFast()Computes fast normal to next crossed boundary, assuming that the current point is close enough to the...Definition TGeoManager.cxx:2799; TGeoManager::DoRestoreStatevoid DoRestoreState()Restore a backed-up state without affecting the cache stack.Definition TGeoManager.cxx:1106; TGeoManager::GetCurrentDirectionconst Double_t * GetCurrentDirection() constDefinition TGeoManager.h:502; TGeoManager::CdUpvoid CdUp()Go one level up in geometry.Definition TGeoManager.cxx:1681; TGeoManager::DoBackupStatevoid DoBackupState()Backup the current state without affecting the cache stack.Definition TGeoManager.cxx:",MatchSource.WIKI,doc/master/TGeoPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPainter_8cxx_source.html
https://root.cern/doc/master/TGeoPainter_8cxx_source.html:86641,Modifiability,plugin,plugin,86641,".Definition TGeoCompositeShape.cxx:429; TGeoHMatrixMatrix class used for computing global transformations Should NOT be used for node definition.Definition TGeoMatrix.h:458; TGeoHMatrix::Clearvoid Clear(Option_t *option="""") overrideclear the data for this matrixDefinition TGeoMatrix.cxx:2512; TGeoIteratorPlugin::SetIteratorvoid SetIterator(const TGeoIterator *iter)Definition TGeoNode.h:237; TGeoIteratorPlugin::ProcessNodevirtual void ProcessNode()=0; TGeoIteratorA geometry iterator.Definition TGeoNode.h:248; TGeoIterator::GetCurrentMatrixconst TGeoMatrix * GetCurrentMatrix() constReturns global matrix for current node.Definition TGeoNode.cxx:1163; TGeoIterator::SetTopNamevoid SetTopName(const char *name)Set the top name for path.Definition TGeoNode.cxx:1234; TGeoIterator::GetLevelInt_t GetLevel() constDefinition TGeoNode.h:294; TGeoIterator::GetPathvoid GetPath(TString &path) constReturns the path for the current node.Definition TGeoNode.cxx:1193; TGeoIterator::SetUserPluginvoid SetUserPlugin(TGeoIteratorPlugin *plugin)Set a plugin.Definition TGeoNode.cxx:1282; TGeoIterator::Skipvoid Skip()Stop iterating the current branch.Definition TGeoNode.cxx:1243; TGeoManagerThe manager class for any TGeo geometry.Definition TGeoManager.h:44; TGeoManager::GetMotherTGeoNode * GetMother(Int_t up=1) constDefinition TGeoManager.h:493; TGeoManager::FindNormalFastDouble_t * FindNormalFast()Computes fast normal to next crossed boundary, assuming that the current point is close enough to the...Definition TGeoManager.cxx:2799; TGeoManager::DoRestoreStatevoid DoRestoreState()Restore a backed-up state without affecting the cache stack.Definition TGeoManager.cxx:1106; TGeoManager::GetCurrentDirectionconst Double_t * GetCurrentDirection() constDefinition TGeoManager.h:502; TGeoManager::CdUpvoid CdUp()Go one level up in geometry.Definition TGeoManager.cxx:1681; TGeoManager::DoBackupStatevoid DoBackupState()Backup the current state without affecting the cache stack.Definition TGeoManager.cxx:",MatchSource.WIKI,doc/master/TGeoPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPainter_8cxx_source.html
https://root.cern/doc/master/TGeoPainter_8cxx_source.html:115919,Modifiability,plug-in,plug-in,115919,"ion TStopwatch.h:28; TStopwatch::Startvoid Start(Bool_t reset=kTRUE)Start the stopwatch.Definition TStopwatch.cxx:58; TStopwatch::Stopvoid Stop()Stop the stopwatch.Definition TStopwatch.cxx:77; TStringBasic string class.Definition TString.h:139; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::Dataconst char * Data() constDefinition TString.h:376; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TViewSee TView3D.Definition TView.h:25; TView::SetPerspectivevirtual void SetPerspective()=0; TView::GetPsivirtual Double_t GetPsi()=0; TView::GetWindowvirtual void GetWindow(Double_t &u0, Double_t &v0, Double_t &du, Double_t &dv) const =0; TView::GetLongitudevirtual Double_t GetLongitude()=0; TView::WCtoNDCvirtual void WCtoNDC(const Float_t *pw, Float_t *pn)=0; TView::GetDviewvirtual Double_t GetDview() const =0; TView::CreateViewstatic TView * CreateView(Int_t system=1, const Double_t *rmin=nullptr, const Double_t *rmax=nullptr)Create a concrete default 3-d view via the plug-in manager.Definition TView.cxx:27; TView::SetAutoRangevirtual void SetAutoRange(Bool_t autorange=kTRUE)=0; TView::GetDprojvirtual Double_t GetDproj() const =0; TView::IsPerspectivevirtual Bool_t IsPerspective() const =0; TView::SetViewChangedvirtual void SetViewChanged(Bool_t flag=kTRUE)=0; TView::GetRangevirtual void GetRange(Float_t *min, Float_t *max)=0; TView::GetLatitudevirtual Double_t GetLatitude()=0; TView::MoveFocusvirtual void MoveFocus(Double_t *center, Double_t dx, Double_t dy, Double_t dz, Int_t nsteps=10, Double_t dlong=0, Double_t dlat=0, Double_t dpsi=0)=0; TView::SetViewvirtual void SetView(Double_t longitude, Double_t latitude, Double_t psi, Int_t &irep)=0; TVirtualGeoPainterAbstract class for geometry ",MatchSource.WIKI,doc/master/TGeoPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPainter_8cxx_source.html
https://root.cern/doc/master/TGeoPainter_8cxx_source.html:2214,Performance,load,loaded,2214,"""TGraph.h""; 32#include ""TPluginManager.h""; 33#include ""TVirtualPadEditor.h""; 34#include ""TStopwatch.h""; 35 ; 36#include ""TPolyMarker3D.h""; 37 ; 38#include ""TGeoAtt.h""; 39#include ""TGeoVolume.h""; 40#include ""TGeoNode.h""; 41#include ""TGeoElement.h""; 42#include ""TGeoManager.h""; 43#include ""TGeoTrack.h""; 44#include ""TGeoOverlap.h""; 45#include ""TGeoChecker.h""; 46#include ""TGeoPhysicalNode.h""; 47#include ""TGeoPolygon.h""; 48#include ""TGeoCompositeShape.h""; 49#include ""TGeoShapeAssembly.h""; 50#include ""TGeoPainter.h""; 51#include ""TMath.h""; 52 ; 53#include ""X3DBuffer.h""; 54 ; 55#include ""TBuffer3D.h""; 56#include ""TBuffer3DTypes.h""; 57#include ""TVirtualViewer3D.h""; 58#include ""TVirtualX.h""; 59 ; 60ClassImp(TGeoPainter);; 61 ; 62////////////////////////////////////////////////////////////////////////////////; 63/// Default constructor.; 64 ; 65TGeoPainter::TGeoPainter(TGeoManager *manager) : TVirtualGeoPainter(manager); 66{; 67 TVirtualGeoPainter::SetPainter(this);; 68 if (manager); 69 fGeoManager = manager;; 70 else {; 71 Error(""ctor"", ""No geometry loaded"");; 72 return;; 73 }; 74 fNsegments = fGeoManager->GetNsegments();; 75 fNVisNodes = 0;; 76 fBombX = 1.3;; 77 fBombY = 1.3;; 78 fBombZ = 1.3;; 79 fBombR = 1.3;; 80 fVisLevel = fGeoManager->GetVisLevel();; 81 fVisOption = fGeoManager->GetVisOption();; 82 fExplodedView = fGeoManager->GetBombMode();; 83 fVisBranch = """";; 84 fVolInfo = """";; 85 fVisLock = kFALSE;; 86 fIsRaytracing = kFALSE;; 87 fTopVisible = kFALSE;; 88 fPaintingOverlaps = kFALSE;; 89 fPlugin = nullptr;; 90 fVisVolumes = new TObjArray();; 91 fOverlap = nullptr;; 92 fGlobal = new TGeoHMatrix();; 93 fBuffer = new TBuffer3D(TBuffer3DTypes::kGeneric, 20, 3 * 20, 0, 0, 0, 0);; 94 fClippingShape = nullptr;; 95 fLastVolume = nullptr;; 96 fTopVolume = nullptr;; 97 fIsPaintingShape = kFALSE;; 98 memset(&fCheckedBox[0], 0, 6 * sizeof(Double_t));; 99 ; 100 fCheckedNode = fGeoManager->GetTopNode();; 101 fChecker = new TGeoChecker(fGeoManager);; 102 fIsEditable = kFALSE;; 103 ",MatchSource.WIKI,doc/master/TGeoPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPainter_8cxx_source.html
https://root.cern/doc/master/TGeoPainter_8cxx_source.html:22197,Performance,load,loaded,22197,"///////////////////////////////////////////////////; 634/// Count total number of visible nodes.; 635 ; 636Int_t TGeoPainter::CountVisibleNodes(); 637{; 638 Int_t maxnodes = fGeoManager->GetMaxVisNodes();; 639 Int_t vislevel = fGeoManager->GetVisLevel();; 640 // TGeoVolume *top = fGeoManager->GetTopVolume();; 641 TGeoVolume *top = fTopVolume;; 642 if (maxnodes <= 0 && top) {; 643 fNVisNodes = CountNodes(top, vislevel);; 644 SetVisLevel(vislevel);; 645 return fNVisNodes;; 646 }; 647 // if (the total number of nodes of the top volume is less than maxnodes; 648 // we can visualize everything.; 649 // recompute the best visibility level; 650 if (!top) {; 651 SetVisLevel(vislevel);; 652 return 0;; 653 }; 654 fNVisNodes = -1;; 655 Bool_t again = kFALSE;; 656 for (Int_t level = 1; level < 20; level++) {; 657 vislevel = level;; 658 Int_t nnodes = CountNodes(top, level);; 659 if (top->IsVisOnly() || top->IsVisBranch()) {; 660 vislevel = fVisLevel;; 661 fNVisNodes = nnodes;; 662 break;; 663 }; 664 if (nnodes > maxnodes) {; 665 vislevel--;; 666 break;; 667 }; 668 if (nnodes == fNVisNodes) {; 669 if (again); 670 break;; 671 again = kTRUE;; 672 }; 673 fNVisNodes = nnodes;; 674 }; 675 SetVisLevel(vislevel);; 676 return fNVisNodes;; 677}; 678 ; 679////////////////////////////////////////////////////////////////////////////////; 680/// Check if Ged library is loaded and load geometry editor classe.; 681 ; 682void TGeoPainter::CheckEdit(); 683{; 684 if (fIsEditable); 685 return;; 686 if (!TClass::GetClass(""TGedEditor"")); 687 return;; 688 TPluginHandler *h;; 689 if ((h = gROOT->GetPluginManager()->FindHandler(""TGeoManagerEditor""))) {; 690 if (h->LoadPlugin() == -1); 691 return;; 692 h->ExecPlugin(0);; 693 }; 694 fIsEditable = kTRUE;; 695}; 696 ; 697////////////////////////////////////////////////////////////////////////////////; 698/// Start the geometry editor.; 699 ; 700void TGeoPainter::EditGeometry(Option_t *option); 701{; 702 if (!gPad); 703 return;; 704 if (!fIsEditable) {; 705 ",MatchSource.WIKI,doc/master/TGeoPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPainter_8cxx_source.html
https://root.cern/doc/master/TGeoPainter_8cxx_source.html:22208,Performance,load,load,22208,"///////////////////////////////////////////////////; 634/// Count total number of visible nodes.; 635 ; 636Int_t TGeoPainter::CountVisibleNodes(); 637{; 638 Int_t maxnodes = fGeoManager->GetMaxVisNodes();; 639 Int_t vislevel = fGeoManager->GetVisLevel();; 640 // TGeoVolume *top = fGeoManager->GetTopVolume();; 641 TGeoVolume *top = fTopVolume;; 642 if (maxnodes <= 0 && top) {; 643 fNVisNodes = CountNodes(top, vislevel);; 644 SetVisLevel(vislevel);; 645 return fNVisNodes;; 646 }; 647 // if (the total number of nodes of the top volume is less than maxnodes; 648 // we can visualize everything.; 649 // recompute the best visibility level; 650 if (!top) {; 651 SetVisLevel(vislevel);; 652 return 0;; 653 }; 654 fNVisNodes = -1;; 655 Bool_t again = kFALSE;; 656 for (Int_t level = 1; level < 20; level++) {; 657 vislevel = level;; 658 Int_t nnodes = CountNodes(top, level);; 659 if (top->IsVisOnly() || top->IsVisBranch()) {; 660 vislevel = fVisLevel;; 661 fNVisNodes = nnodes;; 662 break;; 663 }; 664 if (nnodes > maxnodes) {; 665 vislevel--;; 666 break;; 667 }; 668 if (nnodes == fNVisNodes) {; 669 if (again); 670 break;; 671 again = kTRUE;; 672 }; 673 fNVisNodes = nnodes;; 674 }; 675 SetVisLevel(vislevel);; 676 return fNVisNodes;; 677}; 678 ; 679////////////////////////////////////////////////////////////////////////////////; 680/// Check if Ged library is loaded and load geometry editor classe.; 681 ; 682void TGeoPainter::CheckEdit(); 683{; 684 if (fIsEditable); 685 return;; 686 if (!TClass::GetClass(""TGedEditor"")); 687 return;; 688 TPluginHandler *h;; 689 if ((h = gROOT->GetPluginManager()->FindHandler(""TGeoManagerEditor""))) {; 690 if (h->LoadPlugin() == -1); 691 return;; 692 h->ExecPlugin(0);; 693 }; 694 fIsEditable = kTRUE;; 695}; 696 ; 697////////////////////////////////////////////////////////////////////////////////; 698/// Start the geometry editor.; 699 ; 700void TGeoPainter::EditGeometry(Option_t *option); 701{; 702 if (!gPad); 703 return;; 704 if (!fIsEditable) {; 705 ",MatchSource.WIKI,doc/master/TGeoPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPainter_8cxx_source.html
https://root.cern/doc/master/TGeoPainter_8cxx_source.html:27437,Performance,perform,perform,27437,"1 }; 812 g1->Draw(""ALP"");; 813 if (g2); 814 g2->Draw(""LP"");; 815}; 816 ; 817////////////////////////////////////////////////////////////////////////////////; 818/// Draw method.; 819 ; 820void TGeoPainter::DrawVolume(TGeoVolume *vol, Option_t *option); 821{; 822 fTopVolume = vol;; 823 fLastVolume = nullptr;; 824 fIsPaintingShape = kFALSE;; 825 // if (fVisOption==kGeoVisOnly ||; 826 // fVisOption==kGeoVisBranch) fGeoManager->SetVisOption(kGeoVisLeaves);; 827 CountVisibleNodes();; 828 TString opt = option;; 829 opt.ToLower();; 830 fPaintingOverlaps = kFALSE;; 831 fOverlap = nullptr;; 832 ; 833 if (fVisLock) {; 834 ClearVisibleVolumes();; 835 fVisLock = kFALSE;; 836 }; 837 Bool_t has_pad = (gPad == nullptr) ? kFALSE : kTRUE;; 838 // Clear pad if option ""same"" not given; 839 if (!gPad) {; 840 gROOT->MakeDefCanvas();; 841 }; 842 if (!opt.Contains(""same"")); 843 gPad->Clear();; 844 // append this volume to pad; 845 fTopVolume->AppendPad(option);; 846 ; 847 // Create a 3-D view; 848 TView *view = gPad->GetView();; 849 if (!view) {; 850 view = TView::CreateView(11, nullptr, nullptr);; 851 // Set the view to perform a first autorange (frame) draw.; 852 // TViewer3DPad will revert view to normal painting after this; 853 view->SetAutoRange(kTRUE);; 854 if (has_pad); 855 gPad->Update();; 856 }; 857 if (!opt.Contains(""same"")); 858 Paint(""range"");; 859 else; 860 Paint(opt);; 861 view->SetAutoRange(kFALSE);; 862 // If we are drawing into the pad, then the view needs to be; 863 // set to perspective; 864 // if (!view->IsPerspective()) view->SetPerspective();; 865 ; 866 fLastVolume = fTopVolume;; 867 ; 868 // Create a 3D viewer to paint us; 869 gPad->GetViewer3D(option);; 870}; 871 ; 872////////////////////////////////////////////////////////////////////////////////; 873/// Draw a shape.; 874 ; 875void TGeoPainter::DrawShape(TGeoShape *shape, Option_t *option); 876{; 877 TString opt = option;; 878 opt.ToLower();; 879 fPaintingOverlaps = kFALSE;; 880 fOverlap = nullptr;; 881 fIsPainti",MatchSource.WIKI,doc/master/TGeoPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPainter_8cxx_source.html
https://root.cern/doc/master/TGeoPainter_8cxx_source.html:28780,Performance,perform,perform,28780,"range"");; 859 else; 860 Paint(opt);; 861 view->SetAutoRange(kFALSE);; 862 // If we are drawing into the pad, then the view needs to be; 863 // set to perspective; 864 // if (!view->IsPerspective()) view->SetPerspective();; 865 ; 866 fLastVolume = fTopVolume;; 867 ; 868 // Create a 3D viewer to paint us; 869 gPad->GetViewer3D(option);; 870}; 871 ; 872////////////////////////////////////////////////////////////////////////////////; 873/// Draw a shape.; 874 ; 875void TGeoPainter::DrawShape(TGeoShape *shape, Option_t *option); 876{; 877 TString opt = option;; 878 opt.ToLower();; 879 fPaintingOverlaps = kFALSE;; 880 fOverlap = nullptr;; 881 fIsPaintingShape = kTRUE;; 882 ; 883 Bool_t has_pad = (gPad == nullptr) ? kFALSE : kTRUE;; 884 // Clear pad if option ""same"" not given; 885 if (!gPad) {; 886 gROOT->MakeDefCanvas();; 887 }; 888 if (!opt.Contains(""same"")); 889 gPad->Clear();; 890 // append this shape to pad; 891 shape->AppendPad(option);; 892 ; 893 // Create a 3-D view; 894 TView *view = gPad->GetView();; 895 if (!view) {; 896 view = TView::CreateView(11, nullptr, nullptr);; 897 // Set the view to perform a first autorange (frame) draw.; 898 // TViewer3DPad will revert view to normal painting after this; 899 view->SetAutoRange(kTRUE);; 900 if (has_pad); 901 gPad->Update();; 902 }; 903 PaintShape(shape, ""range"");; 904 view->SetAutoRange(kFALSE);; 905 view->SetPerspective();; 906 // Create a 3D viewer to paint us; 907 gPad->GetViewer3D(option);; 908}; 909 ; 910////////////////////////////////////////////////////////////////////////////////; 911/// Draw an overlap.; 912 ; 913void TGeoPainter::DrawOverlap(void *ovlp, Option_t *option); 914{; 915 TString opt = option;; 916 fIsPaintingShape = kFALSE;; 917 TGeoOverlap *overlap = (TGeoOverlap *)ovlp;; 918 if (!overlap); 919 return;; 920 ; 921 fPaintingOverlaps = kTRUE;; 922 fOverlap = overlap;; 923 opt.ToLower();; 924 if (fVisLock) {; 925 ClearVisibleVolumes();; 926 fVisLock = kFALSE;; 927 }; 928 Bool_t has_pad = (gPad == nul",MatchSource.WIKI,doc/master/TGeoPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPainter_8cxx_source.html
https://root.cern/doc/master/TGeoPainter_8cxx_source.html:30143,Performance,perform,perform,30143,"ge"");; 904 view->SetAutoRange(kFALSE);; 905 view->SetPerspective();; 906 // Create a 3D viewer to paint us; 907 gPad->GetViewer3D(option);; 908}; 909 ; 910////////////////////////////////////////////////////////////////////////////////; 911/// Draw an overlap.; 912 ; 913void TGeoPainter::DrawOverlap(void *ovlp, Option_t *option); 914{; 915 TString opt = option;; 916 fIsPaintingShape = kFALSE;; 917 TGeoOverlap *overlap = (TGeoOverlap *)ovlp;; 918 if (!overlap); 919 return;; 920 ; 921 fPaintingOverlaps = kTRUE;; 922 fOverlap = overlap;; 923 opt.ToLower();; 924 if (fVisLock) {; 925 ClearVisibleVolumes();; 926 fVisLock = kFALSE;; 927 }; 928 Bool_t has_pad = (gPad == nullptr) ? kFALSE : kTRUE;; 929 // Clear pad if option ""same"" not given; 930 if (!gPad) {; 931 gROOT->MakeDefCanvas();; 932 }; 933 if (!opt.Contains(""same"")); 934 gPad->Clear();; 935 // append this volume to pad; 936 overlap->AppendPad(option);; 937 ; 938 // Create a 3-D view; 939 // Create a 3D viewer to paint us; 940 gPad->GetViewer3D(option);; 941 TView *view = gPad->GetView();; 942 if (!view) {; 943 view = TView::CreateView(11, nullptr, nullptr);; 944 // Set the view to perform a first autorange (frame) draw.; 945 // TViewer3DPad will revert view to normal painting after this; 946 view->SetAutoRange(kTRUE);; 947 PaintOverlap(ovlp, ""range"");; 948 overlap->GetPolyMarker()->Draw(""SAME"");; 949 if (has_pad); 950 gPad->Update();; 951 }; 952 ; 953 // If we are drawing into the pad, then the view needs to be; 954 // set to perspective; 955 // if (!view->IsPerspective()) view->SetPerspective();; 956 fVisLock = kTRUE;; 957}; 958 ; 959////////////////////////////////////////////////////////////////////////////////; 960/// Draw only one volume.; 961 ; 962void TGeoPainter::DrawOnly(Option_t *option); 963{; 964 TString opt = option;; 965 opt.ToLower();; 966 if (fVisLock) {; 967 ClearVisibleVolumes();; 968 fVisLock = kFALSE;; 969 }; 970 fPaintingOverlaps = kFALSE;; 971 fIsPaintingShape = kFALSE;; 972 Bool_t has_pad = (",MatchSource.WIKI,doc/master/TGeoPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPainter_8cxx_source.html
https://root.cern/doc/master/TGeoPainter_8cxx_source.html:31463,Performance,perform,perform,31463," overlap->GetPolyMarker()->Draw(""SAME"");; 949 if (has_pad); 950 gPad->Update();; 951 }; 952 ; 953 // If we are drawing into the pad, then the view needs to be; 954 // set to perspective; 955 // if (!view->IsPerspective()) view->SetPerspective();; 956 fVisLock = kTRUE;; 957}; 958 ; 959////////////////////////////////////////////////////////////////////////////////; 960/// Draw only one volume.; 961 ; 962void TGeoPainter::DrawOnly(Option_t *option); 963{; 964 TString opt = option;; 965 opt.ToLower();; 966 if (fVisLock) {; 967 ClearVisibleVolumes();; 968 fVisLock = kFALSE;; 969 }; 970 fPaintingOverlaps = kFALSE;; 971 fIsPaintingShape = kFALSE;; 972 Bool_t has_pad = (gPad == nullptr) ? kFALSE : kTRUE;; 973 // Clear pad if option ""same"" not given; 974 if (!gPad) {; 975 gROOT->MakeDefCanvas();; 976 }; 977 if (!opt.Contains(""same"")); 978 gPad->Clear();; 979 // append this volume to pad; 980 fTopVolume = fGeoManager->GetCurrentVolume();; 981 fTopVolume->AppendPad(option);; 982 ; 983 // Create a 3-D view; 984 TView *view = gPad->GetView();; 985 if (!view) {; 986 view = TView::CreateView(11, nullptr, nullptr);; 987 // Set the view to perform a first autorange (frame) draw.; 988 // TViewer3DPad will revert view to normal painting after this; 989 view->SetAutoRange(kTRUE);; 990 fVisOption = kGeoVisOnly;; 991 if (has_pad); 992 gPad->Update();; 993 }; 994 ; 995 // If we are drawing into the pad, then the view needs to be; 996 // set to perspective; 997 // if (!view->IsPerspective()) view->SetPerspective();; 998 fVisLock = kTRUE;; 999}; 1000 ; 1001////////////////////////////////////////////////////////////////////////////////; 1002/// Draw current point in the same view.; 1003 ; 1004void TGeoPainter::DrawCurrentPoint(Int_t color); 1005{; 1006 if (!gPad); 1007 return;; 1008 if (!gPad->GetView()); 1009 return;; 1010 TPolyMarker3D *pm = new TPolyMarker3D();; 1011 pm->SetMarkerColor(color);; 1012 const Double_t *point = fGeoManager->GetCurrentPoint();; 1013 pm->SetNextPoint(point[0], ",MatchSource.WIKI,doc/master/TGeoPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPainter_8cxx_source.html
https://root.cern/doc/master/TGeoPainter_8cxx_source.html:50136,Performance,perform,perform,50136,");; 1528 vol->SetLineStyle(line_style);; 1529 vol->SetTransparency(transparency);; 1530 }; 1531 if (!fVisLock && !daughter->IsOnScreen()) {; 1532 fVisVolumes->Add(vol);; 1533 vol->SetAttBit(TGeoAtt::kVisOnScreen);; 1534 }; 1535 }; 1536 // Check if we have to skip the branch; 1537 if (!drawDaughters || last || !daughter->IsVisDaughters()); 1538 next.Skip();; 1539 }; 1540 }; 1541 if (fPlugin); 1542 fPlugin->SetIterator(nullptr);; 1543 fGeoManager->SetMatrixReflection(kFALSE);; 1544 fVisLock = kTRUE;; 1545}; 1546 ; 1547////////////////////////////////////////////////////////////////////////////////; 1548/// Paint the supplied shape into the current 3D viewer; 1549 ; 1550Bool_t TGeoPainter::PaintShape(const TGeoShape &shape, Option_t *option) const; 1551{; 1552 Bool_t addDaughters = kTRUE;; 1553 ; 1554 TVirtualViewer3D *viewer = gPad->GetViewer3D();; 1555 ; 1556 if (!viewer || shape.IsA() == TGeoShapeAssembly::Class()) {; 1557 return addDaughters;; 1558 }; 1559 ; 1560 // For non-composite shapes we are the main paint method & perform the negotiation; 1561 // with the viewer here; 1562 if (!shape.IsComposite()) {; 1563 // Does viewer prefer local frame positions?; 1564 Bool_t localFrame = viewer->PreferLocalFrame();; 1565 // Perform first fetch of buffer from the shape and try adding it; 1566 // to the viewer; 1567 const TBuffer3D &buffer =; 1568 shape.GetBuffer3D(TBuffer3D::kCore | TBuffer3D::kBoundingBox | TBuffer3D::kShapeSpecific, localFrame);; 1569 Int_t reqSections = viewer->AddObject(buffer, &addDaughters);; 1570 ; 1571 // If the viewer requires additional sections fetch from the shape (if possible); 1572 // and add again; 1573 if (reqSections != TBuffer3D::kNone) {; 1574 shape.GetBuffer3D(reqSections, localFrame);; 1575 viewer->AddObject(buffer, &addDaughters);; 1576 }; 1577 }; 1578 // Composite shapes have their own internal hierarchy of shapes, each; 1579 // of which generate a filled TBuffer3D. Therefore we can't pass up a; 1580 // single buffer to here. So as ",MatchSource.WIKI,doc/master/TGeoPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPainter_8cxx_source.html
https://root.cern/doc/master/TGeoPainter_8cxx_source.html:51146,Performance,perform,performs,51146," negotiation; 1561 // with the viewer here; 1562 if (!shape.IsComposite()) {; 1563 // Does viewer prefer local frame positions?; 1564 Bool_t localFrame = viewer->PreferLocalFrame();; 1565 // Perform first fetch of buffer from the shape and try adding it; 1566 // to the viewer; 1567 const TBuffer3D &buffer =; 1568 shape.GetBuffer3D(TBuffer3D::kCore | TBuffer3D::kBoundingBox | TBuffer3D::kShapeSpecific, localFrame);; 1569 Int_t reqSections = viewer->AddObject(buffer, &addDaughters);; 1570 ; 1571 // If the viewer requires additional sections fetch from the shape (if possible); 1572 // and add again; 1573 if (reqSections != TBuffer3D::kNone) {; 1574 shape.GetBuffer3D(reqSections, localFrame);; 1575 viewer->AddObject(buffer, &addDaughters);; 1576 }; 1577 }; 1578 // Composite shapes have their own internal hierarchy of shapes, each; 1579 // of which generate a filled TBuffer3D. Therefore we can't pass up a; 1580 // single buffer to here. So as a special case the TGeoCompositeShape; 1581 // performs it's own painting & negotiation with the viewer.; 1582 else {; 1583 const TGeoCompositeShape *composite = static_cast<const TGeoCompositeShape *>(&shape);; 1584 ; 1585 // We need the addDaughters flag returned from the viewer from paint; 1586 // so can't use the normal TObject::Paint(); 1587 // TGeoHMatrix *matrix = (TGeoHMatrix*)TGeoShape::GetTransform();; 1588 // if (viewer->PreferLocalFrame()) matrix->Clear();; 1589 addDaughters = composite->PaintComposite(option);; 1590 }; 1591 ; 1592 return addDaughters;; 1593}; 1594 ; 1595////////////////////////////////////////////////////////////////////////////////; 1596/// Paint an overlap.; 1597 ; 1598void TGeoPainter::PaintShape(TGeoShape *shape, Option_t *option); 1599{; 1600 TGeoShape::SetTransform(fGlobal);; 1601 fGlobal->Clear();; 1602 fGeoManager->SetPaintVolume(nullptr);; 1603 PaintShape(*shape, option);; 1604}; 1605 ; 1606////////////////////////////////////////////////////////////////////////////////; 1607/// Paints a physica",MatchSource.WIKI,doc/master/TGeoPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPainter_8cxx_source.html
https://root.cern/doc/master/TGeoPainter_8cxx_source.html:66147,Performance,perform,performed,66147,"004////////////////////////////////////////////////////////////////////////////////; 2005/// Set number of points to be generated on the shape outline when checking for overlaps.; 2006 ; 2007void TGeoPainter::SetNmeshPoints(Int_t npoints); 2008{; 2009 fChecker->SetNmeshPoints(npoints);; 2010}; 2011 ; 2012////////////////////////////////////////////////////////////////////////////////; 2013/// Select a node to be checked for overlaps. All overlaps not involving it will; 2014/// be ignored.; 2015 ; 2016void TGeoPainter::SetCheckedNode(TGeoNode *node); 2017{; 2018 fChecker->SetSelectedNode(node);; 2019}; 2020 ; 2021////////////////////////////////////////////////////////////////////////////////; 2022/// Set default level down to which visualization is performed; 2023 ; 2024void TGeoPainter::SetVisLevel(Int_t level); 2025{; 2026 if (level == fVisLevel && fLastVolume == fTopVolume); 2027 return;; 2028 fVisLevel = level;; 2029 if (!fTopVolume); 2030 return;; 2031 if (fVisLock) {; 2032 ClearVisibleVolumes();; 2033 fVisLock = kFALSE;; 2034 }; 2035 if (!fLastVolume) {; 2036 // printf(""--- Drawing %6d nodes with %d visible levels\n"",fNVisNodes,fVisLevel);; 2037 return;; 2038 }; 2039 if (!gPad); 2040 return;; 2041 if (gPad->GetView()) {; 2042 // printf(""--- Drawing %6d nodes with %d visible levels\n"",fNVisNodes,fVisLevel);; 2043 ModifiedPad();; 2044 }; 2045}; 2046 ; 2047////////////////////////////////////////////////////////////////////////////////; 2048/// Set top geometry volume as visible.; 2049 ; 2050void TGeoPainter::SetTopVisible(Bool_t vis); 2051{; 2052 if (fTopVisible == vis); 2053 return;; 2054 fTopVisible = vis;; 2055 ModifiedPad();; 2056}; 2057 ; 2058////////////////////////////////////////////////////////////////////////////////; 2059/// Set drawing mode :; 2060/// - option=0 (default) all nodes drawn down to vislevel; 2061/// - option=1 leaves and nodes at vislevel drawn; 2062/// - option=2 path is drawn; 2063 ; 2064void TGeoPainter::SetVisOption(Int_t option); 2",MatchSource.WIKI,doc/master/TGeoPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPainter_8cxx_source.html
https://root.cern/doc/master/TGeoPainter_8cxx_source.html:78012,Performance,load,load,78012," TAttMarker::SetMarkerStylevirtual void SetMarkerStyle(Style_t mstyle=1)Set the marker style.Definition TAttMarker.h:40; TAttMarker::SetMarkerSizevirtual void SetMarkerSize(Size_t msize=1)Set the marker size.Definition TAttMarker.h:45; TBuffer3DTypes::kGeneric@ kGenericDefinition TBuffer3DTypes.h:24; TBuffer3DGeneric 3D primitive description class.Definition TBuffer3D.h:18; TBuffer3D::kBoundingBox@ kBoundingBoxDefinition TBuffer3D.h:51; TBuffer3D::kNone@ kNoneDefinition TBuffer3D.h:49; TBuffer3D::kShapeSpecific@ kShapeSpecificDefinition TBuffer3D.h:52; TBuffer3D::kCore@ kCoreDefinition TBuffer3D.h:50; TBuffer3D::SetRawSizesBool_t SetRawSizes(UInt_t reqPnts, UInt_t reqPntsCapacity, UInt_t reqSegs, UInt_t reqSegsCapacity, UInt_t reqPols, UInt_t reqPolsCapacity)Set kRaw tessellation section of buffer with supplied sizes.Definition TBuffer3D.cxx:360; TBuffer3D::fPntsDouble_t * fPntsDefinition TBuffer3D.h:113; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TColorThe color creation and management class.Definition TColor.h:21; TColor::HLS2RGBstatic void HLS2RGB(Float_t h, Float_t l, Float_t s, Float_t &r, Float_t &g, Float_t &b)Static method to compute RGB from HLS.Definition TColor.cxx:1576; TColor::GetRGBvirtual void GetRGB(Float_t &r, Float_t &g, Float_t &b) constDefinition TColor.h:54; TColor::GetColorstatic Int_t GetColor(const char *hexcolor)Static method returning color number for color specified by hex color string of form: ""#rrggbb"",...Definition TColor.cxx:1920; TColor::InitializeColorsstatic void InitializeColors()Initialize colors used by the TCanvas based graphics (via TColor objects).Definition TColor.cxx:1167; TColor::CreateGradientColorTablestatic Int_t CreateGradientColorTable(UInt_t Number, Double_t *Stops, Double_t *Red, Double_t *Green, Double_t *Blue, UInt_t NColors, Float_t alpha=1., Bool_t setPalette=kT",MatchSource.WIKI,doc/master/TGeoPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPainter_8cxx_source.html
https://root.cern/doc/master/TGeoPainter_8cxx_source.html:87228,Performance,cache,cache,87228," constReturns global matrix for current node.Definition TGeoNode.cxx:1163; TGeoIterator::SetTopNamevoid SetTopName(const char *name)Set the top name for path.Definition TGeoNode.cxx:1234; TGeoIterator::GetLevelInt_t GetLevel() constDefinition TGeoNode.h:294; TGeoIterator::GetPathvoid GetPath(TString &path) constReturns the path for the current node.Definition TGeoNode.cxx:1193; TGeoIterator::SetUserPluginvoid SetUserPlugin(TGeoIteratorPlugin *plugin)Set a plugin.Definition TGeoNode.cxx:1282; TGeoIterator::Skipvoid Skip()Stop iterating the current branch.Definition TGeoNode.cxx:1243; TGeoManagerThe manager class for any TGeo geometry.Definition TGeoManager.h:44; TGeoManager::GetMotherTGeoNode * GetMother(Int_t up=1) constDefinition TGeoManager.h:493; TGeoManager::FindNormalFastDouble_t * FindNormalFast()Computes fast normal to next crossed boundary, assuming that the current point is close enough to the...Definition TGeoManager.cxx:2799; TGeoManager::DoRestoreStatevoid DoRestoreState()Restore a backed-up state without affecting the cache stack.Definition TGeoManager.cxx:1106; TGeoManager::GetCurrentDirectionconst Double_t * GetCurrentDirection() constDefinition TGeoManager.h:502; TGeoManager::CdUpvoid CdUp()Go one level up in geometry.Definition TGeoManager.cxx:1681; TGeoManager::DoBackupStatevoid DoBackupState()Backup the current state without affecting the cache stack.Definition TGeoManager.cxx:1098; TGeoManager::GetListOfVolumesTObjArray * GetListOfVolumes() constDefinition TGeoManager.h:473; TGeoManager::SetMatrixReflectionvoid SetMatrixReflection(Bool_t flag=kTRUE)Definition TGeoManager.h:399; TGeoManager::cdvirtual Bool_t cd(const char *path="""")Browse the tree of nodes starting from fTopNode according to pathname.Definition TGeoManager.cxx:1707; TGeoManager::LocalToMastervoid LocalToMaster(const Double_t *local, Double_t *master) constDefinition TGeoManager.h:526; TGeoManager::GetRTmodeInt_t GetRTmode() constDefinition TGeoManager.h:440; TGeoManager::IsClosedBo",MatchSource.WIKI,doc/master/TGeoPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPainter_8cxx_source.html
https://root.cern/doc/master/TGeoPainter_8cxx_source.html:87561,Performance,cache,cache,87561,"the current node.Definition TGeoNode.cxx:1193; TGeoIterator::SetUserPluginvoid SetUserPlugin(TGeoIteratorPlugin *plugin)Set a plugin.Definition TGeoNode.cxx:1282; TGeoIterator::Skipvoid Skip()Stop iterating the current branch.Definition TGeoNode.cxx:1243; TGeoManagerThe manager class for any TGeo geometry.Definition TGeoManager.h:44; TGeoManager::GetMotherTGeoNode * GetMother(Int_t up=1) constDefinition TGeoManager.h:493; TGeoManager::FindNormalFastDouble_t * FindNormalFast()Computes fast normal to next crossed boundary, assuming that the current point is close enough to the...Definition TGeoManager.cxx:2799; TGeoManager::DoRestoreStatevoid DoRestoreState()Restore a backed-up state without affecting the cache stack.Definition TGeoManager.cxx:1106; TGeoManager::GetCurrentDirectionconst Double_t * GetCurrentDirection() constDefinition TGeoManager.h:502; TGeoManager::CdUpvoid CdUp()Go one level up in geometry.Definition TGeoManager.cxx:1681; TGeoManager::DoBackupStatevoid DoBackupState()Backup the current state without affecting the cache stack.Definition TGeoManager.cxx:1098; TGeoManager::GetListOfVolumesTObjArray * GetListOfVolumes() constDefinition TGeoManager.h:473; TGeoManager::SetMatrixReflectionvoid SetMatrixReflection(Bool_t flag=kTRUE)Definition TGeoManager.h:399; TGeoManager::cdvirtual Bool_t cd(const char *path="""")Browse the tree of nodes starting from fTopNode according to pathname.Definition TGeoManager.cxx:1707; TGeoManager::LocalToMastervoid LocalToMaster(const Double_t *local, Double_t *master) constDefinition TGeoManager.h:526; TGeoManager::GetRTmodeInt_t GetRTmode() constDefinition TGeoManager.h:440; TGeoManager::IsClosedBool_t IsClosed() constDefinition TGeoManager.h:297; TGeoManager::GetCurrentNodeTGeoNode * GetCurrentNode() constDefinition TGeoManager.h:499; TGeoManager::SetCurrentDirectionvoid SetCurrentDirection(Double_t *dir)Definition TGeoManager.h:518; TGeoManager::StepTGeoNode * Step(Bool_t is_geom=kTRUE, Bool_t cross=kTRUE)Make a rectilinear ",MatchSource.WIKI,doc/master/TGeoPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPainter_8cxx_source.html
https://root.cern/doc/master/TGeoPainter_8cxx_source.html:101384,Performance,load,loaded,101384,"on TGeoPainter.h:60; TGeoPainter::CheckGeometryvoid CheckGeometry(Int_t nrays, Double_t startx, Double_t starty, Double_t startz) const overrideGeometry checking method (see TGeoChecker).Definition TGeoPainter.cxx:226; TGeoPainter::fBombYDouble_t fBombYDefinition TGeoPainter.h:42; TGeoPainter::fPaintingOverlapsBool_t fPaintingOverlapsDefinition TGeoPainter.h:54; TGeoPainter::CheckOverlapsvoid CheckOverlaps(const TGeoVolume *vol, Double_t ovlp=0.1, Option_t *option="""") const overrideCheck overlaps for the top volume of the geometry, within a limit OVLP.Definition TGeoPainter.cxx:234; TGeoPainter::SetBombFactorsvoid SetBombFactors(Double_t bombx=1.3, Double_t bomby=1.3, Double_t bombz=1.3, Double_t bombr=1.3) overrideSet cartesian and radial bomb factors for translations.Definition TGeoPainter.cxx:1949; TGeoPainter::DefaultColorsvoid DefaultColors() overrideSet default volume colors according to tracking media.Definition TGeoPainter.cxx:570; TGeoPainter::CheckEditvoid CheckEdit()Check if Ged library is loaded and load geometry editor classe.Definition TGeoPainter.cxx:682; TGeoPainter::CheckBoundaryErrorsvoid CheckBoundaryErrors(Int_t ntracks=1000000, Double_t radius=-1.) overrideCheck pushes and pulls needed to cross the next boundary with respect to the position given by FindNe...Definition TGeoPainter.cxx:200; TGeoPainter::ClearVisibleVolumesvoid ClearVisibleVolumes()Clear the list of visible volumes reset the kVisOnScreen bit for volumes previously in the list.Definition TGeoPainter.cxx:263; TGeoPainter::GetColorInt_t GetColor(Int_t base, Float_t light) const overrideGet index of a base color with given light intensity (0,1)Definition TGeoPainter.cxx:292; TGeoPainter::LocalToMasterVectvoid LocalToMasterVect(const Double_t *local, Double_t *master) constConvert a local vector according view rotation matrix.Definition TGeoPainter.cxx:1249; TGeoPainter::DrawVolumevoid DrawVolume(TGeoVolume *vol, Option_t *option="""") overrideDraw method.Definition TGeoPainter.cxx:820; ",MatchSource.WIKI,doc/master/TGeoPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPainter_8cxx_source.html
https://root.cern/doc/master/TGeoPainter_8cxx_source.html:101395,Performance,load,load,101395,"on TGeoPainter.h:60; TGeoPainter::CheckGeometryvoid CheckGeometry(Int_t nrays, Double_t startx, Double_t starty, Double_t startz) const overrideGeometry checking method (see TGeoChecker).Definition TGeoPainter.cxx:226; TGeoPainter::fBombYDouble_t fBombYDefinition TGeoPainter.h:42; TGeoPainter::fPaintingOverlapsBool_t fPaintingOverlapsDefinition TGeoPainter.h:54; TGeoPainter::CheckOverlapsvoid CheckOverlaps(const TGeoVolume *vol, Double_t ovlp=0.1, Option_t *option="""") const overrideCheck overlaps for the top volume of the geometry, within a limit OVLP.Definition TGeoPainter.cxx:234; TGeoPainter::SetBombFactorsvoid SetBombFactors(Double_t bombx=1.3, Double_t bomby=1.3, Double_t bombz=1.3, Double_t bombr=1.3) overrideSet cartesian and radial bomb factors for translations.Definition TGeoPainter.cxx:1949; TGeoPainter::DefaultColorsvoid DefaultColors() overrideSet default volume colors according to tracking media.Definition TGeoPainter.cxx:570; TGeoPainter::CheckEditvoid CheckEdit()Check if Ged library is loaded and load geometry editor classe.Definition TGeoPainter.cxx:682; TGeoPainter::CheckBoundaryErrorsvoid CheckBoundaryErrors(Int_t ntracks=1000000, Double_t radius=-1.) overrideCheck pushes and pulls needed to cross the next boundary with respect to the position given by FindNe...Definition TGeoPainter.cxx:200; TGeoPainter::ClearVisibleVolumesvoid ClearVisibleVolumes()Clear the list of visible volumes reset the kVisOnScreen bit for volumes previously in the list.Definition TGeoPainter.cxx:263; TGeoPainter::GetColorInt_t GetColor(Int_t base, Float_t light) const overrideGet index of a base color with given light intensity (0,1)Definition TGeoPainter.cxx:292; TGeoPainter::LocalToMasterVectvoid LocalToMasterVect(const Double_t *local, Double_t *master) constConvert a local vector according view rotation matrix.Definition TGeoPainter.cxx:1249; TGeoPainter::DrawVolumevoid DrawVolume(TGeoVolume *vol, Option_t *option="""") overrideDraw method.Definition TGeoPainter.cxx:820; ",MatchSource.WIKI,doc/master/TGeoPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPainter_8cxx_source.html
https://root.cern/doc/master/TGeoPainter_8cxx_source.html:104678,Performance,perform,performed,104678,"ition TGeoPainter.h:61; TGeoPainter::fVisLevelInt_t fVisLevelDefinition TGeoPainter.h:49; TGeoPainter::SetNsegmentsvoid SetNsegments(Int_t nseg=20) overrideSet number of segments to approximate circles.Definition TGeoPainter.cxx:1992; TGeoPainter::CheckBoundaryReferencevoid CheckBoundaryReference(Int_t icheck=-1) overrideCheck the boundary errors reference file created by CheckBoundaryErrors method.Definition TGeoPainter.cxx:210; TGeoPainter::AddTrackPointvoid AddTrackPoint(Double_t *point, Double_t *box, Bool_t reset=kFALSE) overrideAverage center of view of all painted tracklets and compute view box.Definition TGeoPainter.cxx:138; TGeoPainter::GrabFocusvoid GrabFocus(Int_t nfr=0, Double_t dlong=0, Double_t dlat=0, Double_t dpsi=0) overrideMove focus to current volume.Definition TGeoPainter.cxx:1206; TGeoPainter::DrawOverlapvoid DrawOverlap(void *ovlp, Option_t *option="""") overrideDraw an overlap.Definition TGeoPainter.cxx:913; TGeoPainter::SetVisLevelvoid SetVisLevel(Int_t level=3) overrideSet default level down to which visualization is performed.Definition TGeoPainter.cxx:2024; TGeoPainter::AddSize3Dvoid AddSize3D(Int_t numpoints, Int_t numsegs, Int_t numpolys) overrideAdd numpoints, numsegs, numpolys to the global 3D size.Definition TGeoPainter.cxx:121; TGeoPainter::fCheckedNodeTGeoNode * fCheckedNodeDefinition TGeoPainter.h:59; TGeoPainter::PaintPhysicalNodevoid PaintPhysicalNode(TGeoPhysicalNode *node, Option_t *option="""")Paints a physical node associated with a path.Definition TGeoPainter.cxx:1609; TGeoPainter::fNVisNodesInt_t fNVisNodesDefinition TGeoPainter.h:48; TGeoPainter::fExplodedViewInt_t fExplodedViewDefinition TGeoPainter.h:51; TGeoPainter::GetVolumeInfoconst char * GetVolumeInfo(const TGeoVolume *volume, Int_t px, Int_t py) const overrideGet some info about the current selected volume.Definition TGeoPainter.cxx:1151; TGeoPainter::DrawCurrentPointvoid DrawCurrentPoint(Int_t color) overrideDraw current point in the same view.Definition TGeoPainter.c",MatchSource.WIKI,doc/master/TGeoPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPainter_8cxx_source.html
https://root.cern/doc/master/TGeoPainter_8cxx_source.html:8083,Safety,safe,safety,8083,"rlaps, checkcrossings, ntracks, vertex);; 221}; 222 ; 223////////////////////////////////////////////////////////////////////////////////; 224/// Geometry checking method (see TGeoChecker).; 225 ; 226void TGeoPainter::CheckGeometry(Int_t nrays, Double_t startx, Double_t starty, Double_t startz) const; 227{; 228 fChecker->CheckGeometry(nrays, startx, starty, startz);; 229}; 230 ; 231////////////////////////////////////////////////////////////////////////////////; 232/// Check overlaps for the top volume of the geometry, within a limit OVLP.; 233 ; 234void TGeoPainter::CheckOverlaps(const TGeoVolume *vol, Double_t ovlp, Option_t *option) const; 235{; 236 fChecker->CheckOverlaps(vol, ovlp, option);; 237}; 238 ; 239////////////////////////////////////////////////////////////////////////////////; 240/// Check current point in the geometry.; 241 ; 242void TGeoPainter::CheckPoint(Double_t x, Double_t y, Double_t z, Option_t *option, Double_t safety); 243{; 244 fChecker->CheckPoint(x, y, z, option, safety);; 245}; 246 ; 247////////////////////////////////////////////////////////////////////////////////; 248/// Test for shape navigation methods. Summary for test numbers:; 249/// - 1: DistFromInside/Outside. Sample points inside the shape. Generate; 250/// directions randomly in cos(theta). Compute DistFromInside and move the; 251/// point with bigger distance. Compute DistFromOutside back from new point.; 252/// Plot d-(d1+d2); 253 ; 254void TGeoPainter::CheckShape(TGeoShape *shape, Int_t testNo, Int_t nsamples, Option_t *option); 255{; 256 fChecker->CheckShape(shape, testNo, nsamples, option);; 257}; 258 ; 259////////////////////////////////////////////////////////////////////////////////; 260/// Clear the list of visible volumes; 261/// reset the kVisOnScreen bit for volumes previously in the list; 262 ; 263void TGeoPainter::ClearVisibleVolumes(); 264{; 265 if (!fVisVolumes); 266 return;; 267 TIter next(fVisVolumes);; 268 TGeoVolume *vol;; 269 while ((vol = (TGeoVolume *)n",MatchSource.WIKI,doc/master/TGeoPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPainter_8cxx_source.html
https://root.cern/doc/master/TGeoPainter_8cxx_source.html:8140,Safety,safe,safety,8140,"rlaps, checkcrossings, ntracks, vertex);; 221}; 222 ; 223////////////////////////////////////////////////////////////////////////////////; 224/// Geometry checking method (see TGeoChecker).; 225 ; 226void TGeoPainter::CheckGeometry(Int_t nrays, Double_t startx, Double_t starty, Double_t startz) const; 227{; 228 fChecker->CheckGeometry(nrays, startx, starty, startz);; 229}; 230 ; 231////////////////////////////////////////////////////////////////////////////////; 232/// Check overlaps for the top volume of the geometry, within a limit OVLP.; 233 ; 234void TGeoPainter::CheckOverlaps(const TGeoVolume *vol, Double_t ovlp, Option_t *option) const; 235{; 236 fChecker->CheckOverlaps(vol, ovlp, option);; 237}; 238 ; 239////////////////////////////////////////////////////////////////////////////////; 240/// Check current point in the geometry.; 241 ; 242void TGeoPainter::CheckPoint(Double_t x, Double_t y, Double_t z, Option_t *option, Double_t safety); 243{; 244 fChecker->CheckPoint(x, y, z, option, safety);; 245}; 246 ; 247////////////////////////////////////////////////////////////////////////////////; 248/// Test for shape navigation methods. Summary for test numbers:; 249/// - 1: DistFromInside/Outside. Sample points inside the shape. Generate; 250/// directions randomly in cos(theta). Compute DistFromInside and move the; 251/// point with bigger distance. Compute DistFromOutside back from new point.; 252/// Plot d-(d1+d2); 253 ; 254void TGeoPainter::CheckShape(TGeoShape *shape, Int_t testNo, Int_t nsamples, Option_t *option); 255{; 256 fChecker->CheckShape(shape, testNo, nsamples, option);; 257}; 258 ; 259////////////////////////////////////////////////////////////////////////////////; 260/// Clear the list of visible volumes; 261/// reset the kVisOnScreen bit for volumes previously in the list; 262 ; 263void TGeoPainter::ClearVisibleVolumes(); 264{; 265 if (!fVisVolumes); 266 return;; 267 TIter next(fVisVolumes);; 268 TGeoVolume *vol;; 269 while ((vol = (TGeoVolume *)n",MatchSource.WIKI,doc/master/TGeoPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPainter_8cxx_source.html
https://root.cern/doc/master/TGeoPainter_8cxx_source.html:82597,Safety,safe,safety,82597,"nt_t nsamples, Option_t *option)Test for shape navigation methods.Definition TGeoChecker.cxx:1752; TGeoChecker::CheckOverlapsvoid CheckOverlaps(const TGeoVolume *vol, Double_t ovlp=0.1, Option_t *option="""")Check illegal overlaps for volume VOL within a limit OVLP.Definition TGeoChecker.cxx:1427; TGeoChecker::TestOverlapsvoid TestOverlaps(const char *path)Geometry overlap checker based on sampling.Definition TGeoChecker.cxx:2761; TGeoChecker::SetSelectedNodevoid SetSelectedNode(TGeoNode *node)Definition TGeoChecker.h:93; TGeoChecker::CheckGeometryFullvoid CheckGeometryFull(Bool_t checkoverlaps=kTRUE, Bool_t checkcrossings=kTRUE, Int_t nrays=10000, const Double_t *vertex=nullptr)Geometry checking.Definition TGeoChecker.cxx:503; TGeoChecker::SamplePointsTGeoNode * SamplePoints(Int_t npoints, Double_t &dist, Double_t epsil, const char *g3path)shoot npoints randomly in a box of 1E-5 around current point.Definition TGeoChecker.cxx:2492; TGeoChecker::CheckPointvoid CheckPoint(Double_t x=0, Double_t y=0, Double_t z=0, Option_t *option="""", Double_t safety=0.)Draw point (x,y,z) over the picture of the daughters of the volume containing this point.Definition TGeoChecker.cxx:1692; TGeoChecker::WeightDouble_t Weight(Double_t precision=0.01, Option_t *option=""v"")Estimate weight of top level volume with a precision SIGMA(W)/W better than PRECISION.Definition TGeoChecker.cxx:2890; TGeoChecker::OpProgressvoid OpProgress(const char *opname, Long64_t current, Long64_t size, TStopwatch *watch=nullptr, Bool_t last=kFALSE, Bool_t refresh=kFALSE, const char *msg="""")Print current operation progress.Definition TGeoChecker.cxx:151; TGeoChecker::CheckGeometryvoid CheckGeometry(Int_t nrays, Double_t startx, Double_t starty, Double_t startz) constShoot nrays with random directions from starting point (startx, starty, startz) in the reference fram...Definition TGeoChecker.cxx:809; TGeoChecker::CheckBoundaryReferencevirtual void CheckBoundaryReference(Int_t icheck=-1)Check the boundary errors ref",MatchSource.WIKI,doc/master/TGeoPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPainter_8cxx_source.html
https://root.cern/doc/master/TGeoPainter_8cxx_source.html:98590,Safety,safe,safety,98590,"w method.Definition TGeoPainter.cxx:718; TGeoPainter::CountVisibleNodesInt_t CountVisibleNodes() overrideCount total number of visible nodes.Definition TGeoPainter.cxx:636; TGeoPainter::DefineColorsvoid DefineColors() constDefine 100 colors with increasing light intensities for each basic color (1-7) Register these colors ...Definition TGeoPainter.cxx:279; TGeoPainter::SetExplodedViewvoid SetExplodedView(Int_t iopt=0) overrideSet type of exploding view.Definition TGeoPainter.cxx:1962; TGeoPainter::ExecuteManagerEventvoid ExecuteManagerEvent(TGeoManager *geom, Int_t event, Int_t px, Int_t py) overrideExecute mouse actions on a given volume.Definition TGeoPainter.cxx:1074; TGeoPainter::fLastVolumeTGeoVolume * fLastVolumeDefinition TGeoPainter.h:67; TGeoPainter::SetNmeshPointsvoid SetNmeshPoints(Int_t npoints) overrideSet number of points to be generated on the shape outline when checking for overlaps.Definition TGeoPainter.cxx:2007; TGeoPainter::CheckPointvoid CheckPoint(Double_t x=0, Double_t y=0, Double_t z=0, Option_t *option="""", Double_t safety=0.) overrideCheck current point in the geometry.Definition TGeoPainter.cxx:242; TGeoPainter::DistanceToPrimitiveVolInt_t DistanceToPrimitiveVol(TGeoVolume *vol, Int_t px, Int_t py) overrideCompute the closest distance of approach from point px,py to a volume.Definition TGeoPainter.cxx:348; TGeoPainter::UnbombTranslationvoid UnbombTranslation(const Double_t *tr, Double_t *bombtr) overrideGet the new 'unbombed' translation vector according current exploded view mode.Definition TGeoPainter.cxx:2194; TGeoPainter::fVisLockBool_t fVisLockDefinition TGeoPainter.h:52; TGeoPainter::PaintNodevoid PaintNode(TGeoNode *node, Option_t *option="""", TGeoMatrix *global=nullptr) overridePaint recursively a node and its content according to visualization options.Definition TGeoPainter.cxx:1376; TGeoPainter::DefaultAnglesvoid DefaultAngles() overrideSet default angles for the current view.Definition TGeoPainter.cxx:555; TGeoPainter::fClippingSh",MatchSource.WIKI,doc/master/TGeoPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPainter_8cxx_source.html
https://root.cern/doc/master/TGeoPainter_8cxx_source.html:109754,Safety,avoid,avoid,109754,"by vertices.Definition TGeoPolygon.h:19; TGeoPolygon::IsConvexBool_t IsConvex() constDefinition TGeoPolygon.h:59; TGeoPolygon::GetNconvexInt_t GetNconvex() constDefinition TGeoPolygon.h:53; TGeoPolygon::GetVerticesvoid GetVertices(Double_t *x, Double_t *y) constFill list of vertices into provided arrays.Definition TGeoPolygon.cxx:243; TGeoPolygon::GetNvertInt_t GetNvert() constDefinition TGeoPolygon.h:52; TGeoPolygon::GetConvexVerticesvoid GetConvexVertices(Double_t *x, Double_t *y) constFill list of vertices of the convex outscribed polygon into provided arrays.Definition TGeoPolygon.cxx:252; TGeoShapeAssembly::Classstatic TClass * Class(); TGeoShapeBase abstract class for all shapes.Definition TGeoShape.h:25; TGeoShape::DistancetoPrimitiveInt_t DistancetoPrimitive(Int_t px, Int_t py) override=0Computes distance from point (px,py) to the object.; TGeoShape::ComputeNormalvirtual void ComputeNormal(const Double_t *point, const Double_t *dir, Double_t *norm)=0; TGeoShape::GetBuffer3Dvirtual const TBuffer3D & GetBuffer3D(Int_t reqSections, Bool_t localFrame) constStub implementation to avoid forcing implementation at this stage.Definition TGeoShape.cxx:735; TGeoShape::Bigstatic Double_t Big()Definition TGeoShape.h:87; TGeoShape::DistFromInsidevirtual Double_t DistFromInside(const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const =0; TGeoShape::SetTransformstatic void SetTransform(TGeoMatrix *matrix)Set current transformation matrix that applies to shape.Definition TGeoShape.cxx:582; TGeoShape::IsCompositevirtual Bool_t IsComposite() constDefinition TGeoShape.h:130; TGeoShape::DistFromOutsidevirtual Double_t DistFromOutside(const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const =0; TGeoShape::GetTransformstatic TGeoMatrix * GetTransform()Returns current transformation matrix that applies to shape.Definition TGeoShape.cxx:574; TGeoShape::Contain",MatchSource.WIKI,doc/master/TGeoPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPainter_8cxx_source.html
https://root.cern/doc/master/TGeoPainter_8cxx_source.html:110046,Safety,safe,safe,110046,"nition TGeoPolygon.h:52; TGeoPolygon::GetConvexVerticesvoid GetConvexVertices(Double_t *x, Double_t *y) constFill list of vertices of the convex outscribed polygon into provided arrays.Definition TGeoPolygon.cxx:252; TGeoShapeAssembly::Classstatic TClass * Class(); TGeoShapeBase abstract class for all shapes.Definition TGeoShape.h:25; TGeoShape::DistancetoPrimitiveInt_t DistancetoPrimitive(Int_t px, Int_t py) override=0Computes distance from point (px,py) to the object.; TGeoShape::ComputeNormalvirtual void ComputeNormal(const Double_t *point, const Double_t *dir, Double_t *norm)=0; TGeoShape::GetBuffer3Dvirtual const TBuffer3D & GetBuffer3D(Int_t reqSections, Bool_t localFrame) constStub implementation to avoid forcing implementation at this stage.Definition TGeoShape.cxx:735; TGeoShape::Bigstatic Double_t Big()Definition TGeoShape.h:87; TGeoShape::DistFromInsidevirtual Double_t DistFromInside(const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const =0; TGeoShape::SetTransformstatic void SetTransform(TGeoMatrix *matrix)Set current transformation matrix that applies to shape.Definition TGeoShape.cxx:582; TGeoShape::IsCompositevirtual Bool_t IsComposite() constDefinition TGeoShape.h:130; TGeoShape::DistFromOutsidevirtual Double_t DistFromOutside(const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const =0; TGeoShape::GetTransformstatic TGeoMatrix * GetTransform()Returns current transformation matrix that applies to shape.Definition TGeoShape.cxx:574; TGeoShape::Containsvirtual Bool_t Contains(const Double_t *point) const =0; TGeoShape::SetPointsvirtual void SetPoints(Double_t *points) const =0; TGeoShape::IsATClass * IsA() const overrideDefinition TGeoShape.h:171; TGeoTrackDefinition TGeoTrack.h:26; TGeoVolumeTGeoVolume, TGeoVolumeMulti, TGeoVolumeAssembly are the volume classes.Definition TGeoVolume.h:43; TGeoVolume::IsVisContainersBool_t IsVi",MatchSource.WIKI,doc/master/TGeoPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPainter_8cxx_source.html
https://root.cern/doc/master/TGeoPainter_8cxx_source.html:110466,Safety,safe,safe,110466,"erride=0Computes distance from point (px,py) to the object.; TGeoShape::ComputeNormalvirtual void ComputeNormal(const Double_t *point, const Double_t *dir, Double_t *norm)=0; TGeoShape::GetBuffer3Dvirtual const TBuffer3D & GetBuffer3D(Int_t reqSections, Bool_t localFrame) constStub implementation to avoid forcing implementation at this stage.Definition TGeoShape.cxx:735; TGeoShape::Bigstatic Double_t Big()Definition TGeoShape.h:87; TGeoShape::DistFromInsidevirtual Double_t DistFromInside(const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const =0; TGeoShape::SetTransformstatic void SetTransform(TGeoMatrix *matrix)Set current transformation matrix that applies to shape.Definition TGeoShape.cxx:582; TGeoShape::IsCompositevirtual Bool_t IsComposite() constDefinition TGeoShape.h:130; TGeoShape::DistFromOutsidevirtual Double_t DistFromOutside(const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const =0; TGeoShape::GetTransformstatic TGeoMatrix * GetTransform()Returns current transformation matrix that applies to shape.Definition TGeoShape.cxx:574; TGeoShape::Containsvirtual Bool_t Contains(const Double_t *point) const =0; TGeoShape::SetPointsvirtual void SetPoints(Double_t *points) const =0; TGeoShape::IsATClass * IsA() const overrideDefinition TGeoShape.h:171; TGeoTrackDefinition TGeoTrack.h:26; TGeoVolumeTGeoVolume, TGeoVolumeMulti, TGeoVolumeAssembly are the volume classes.Definition TGeoVolume.h:43; TGeoVolume::IsVisContainersBool_t IsVisContainers() constDefinition TGeoVolume.h:157; TGeoVolume::SetLineWidthvoid SetLineWidth(Width_t lwidth) overrideSet the line width.Definition TGeoVolume.cxx:2185; TGeoVolume::GetMaterialTGeoMaterial * GetMaterial() constDefinition TGeoVolume.h:174; TGeoVolume::GetNdaughtersInt_t GetNdaughters() constDefinition TGeoVolume.h:362; TGeoVolume::SetTransparencyvoid SetTransparency(Char_t transparency=0)Definition TGe",MatchSource.WIKI,doc/master/TGeoPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPainter_8cxx_source.html
https://root.cern/doc/master/TGeoPainter_8cxx_source.html:8301,Testability,test,test,8301,"er).; 225 ; 226void TGeoPainter::CheckGeometry(Int_t nrays, Double_t startx, Double_t starty, Double_t startz) const; 227{; 228 fChecker->CheckGeometry(nrays, startx, starty, startz);; 229}; 230 ; 231////////////////////////////////////////////////////////////////////////////////; 232/// Check overlaps for the top volume of the geometry, within a limit OVLP.; 233 ; 234void TGeoPainter::CheckOverlaps(const TGeoVolume *vol, Double_t ovlp, Option_t *option) const; 235{; 236 fChecker->CheckOverlaps(vol, ovlp, option);; 237}; 238 ; 239////////////////////////////////////////////////////////////////////////////////; 240/// Check current point in the geometry.; 241 ; 242void TGeoPainter::CheckPoint(Double_t x, Double_t y, Double_t z, Option_t *option, Double_t safety); 243{; 244 fChecker->CheckPoint(x, y, z, option, safety);; 245}; 246 ; 247////////////////////////////////////////////////////////////////////////////////; 248/// Test for shape navigation methods. Summary for test numbers:; 249/// - 1: DistFromInside/Outside. Sample points inside the shape. Generate; 250/// directions randomly in cos(theta). Compute DistFromInside and move the; 251/// point with bigger distance. Compute DistFromOutside back from new point.; 252/// Plot d-(d1+d2); 253 ; 254void TGeoPainter::CheckShape(TGeoShape *shape, Int_t testNo, Int_t nsamples, Option_t *option); 255{; 256 fChecker->CheckShape(shape, testNo, nsamples, option);; 257}; 258 ; 259////////////////////////////////////////////////////////////////////////////////; 260/// Clear the list of visible volumes; 261/// reset the kVisOnScreen bit for volumes previously in the list; 262 ; 263void TGeoPainter::ClearVisibleVolumes(); 264{; 265 if (!fVisVolumes); 266 return;; 267 TIter next(fVisVolumes);; 268 TGeoVolume *vol;; 269 while ((vol = (TGeoVolume *)next())) {; 270 vol->ResetAttBit(TGeoAtt::kVisOnScreen);; 271 }; 272 fVisVolumes->Clear();; 273}; 274 ; 275////////////////////////////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TGeoPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPainter_8cxx_source.html
https://root.cern/doc/master/TGeoPainter_8cxx_source.html:8639,Testability,test,testNo,8639,"heckPoint(Double_t x, Double_t y, Double_t z, Option_t *option, Double_t safety); 243{; 244 fChecker->CheckPoint(x, y, z, option, safety);; 245}; 246 ; 247////////////////////////////////////////////////////////////////////////////////; 248/// Test for shape navigation methods. Summary for test numbers:; 249/// - 1: DistFromInside/Outside. Sample points inside the shape. Generate; 250/// directions randomly in cos(theta). Compute DistFromInside and move the; 251/// point with bigger distance. Compute DistFromOutside back from new point.; 252/// Plot d-(d1+d2); 253 ; 254void TGeoPainter::CheckShape(TGeoShape *shape, Int_t testNo, Int_t nsamples, Option_t *option); 255{; 256 fChecker->CheckShape(shape, testNo, nsamples, option);; 257}; 258 ; 259////////////////////////////////////////////////////////////////////////////////; 260/// Clear the list of visible volumes; 261/// reset the kVisOnScreen bit for volumes previously in the list; 262 ; 263void TGeoPainter::ClearVisibleVolumes(); 264{; 265 if (!fVisVolumes); 266 return;; 267 TIter next(fVisVolumes);; 268 TGeoVolume *vol;; 269 while ((vol = (TGeoVolume *)next())) {; 270 vol->ResetAttBit(TGeoAtt::kVisOnScreen);; 271 }; 272 fVisVolumes->Clear();; 273}; 274 ; 275////////////////////////////////////////////////////////////////////////////////; 276/// Define 100 colors with increasing light intensities for each basic color (1-7); 277/// Register these colors at indexes starting with 1000.; 278 ; 279void TGeoPainter::DefineColors() const; 280{; 281 static Int_t color = 0;; 282 if (!color) {; 283 TColor::InitializeColors();; 284 for (auto icol = 1; icol < 10; ++icol); 285 color = GetColor(icol, 0.5);; 286 }; 287}; 288 ; 289////////////////////////////////////////////////////////////////////////////////; 290/// Get index of a base color with given light intensity (0,1); 291 ; 292Int_t TGeoPainter::GetColor(Int_t base, Float_t light) const; 293{; 294 using IntMap_t = std::map<Int_t, Int_t>;; 295 constexpr Int_t ncolors = 10",MatchSource.WIKI,doc/master/TGeoPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPainter_8cxx_source.html
https://root.cern/doc/master/TGeoPainter_8cxx_source.html:8720,Testability,test,testNo,8720,"heckPoint(Double_t x, Double_t y, Double_t z, Option_t *option, Double_t safety); 243{; 244 fChecker->CheckPoint(x, y, z, option, safety);; 245}; 246 ; 247////////////////////////////////////////////////////////////////////////////////; 248/// Test for shape navigation methods. Summary for test numbers:; 249/// - 1: DistFromInside/Outside. Sample points inside the shape. Generate; 250/// directions randomly in cos(theta). Compute DistFromInside and move the; 251/// point with bigger distance. Compute DistFromOutside back from new point.; 252/// Plot d-(d1+d2); 253 ; 254void TGeoPainter::CheckShape(TGeoShape *shape, Int_t testNo, Int_t nsamples, Option_t *option); 255{; 256 fChecker->CheckShape(shape, testNo, nsamples, option);; 257}; 258 ; 259////////////////////////////////////////////////////////////////////////////////; 260/// Clear the list of visible volumes; 261/// reset the kVisOnScreen bit for volumes previously in the list; 262 ; 263void TGeoPainter::ClearVisibleVolumes(); 264{; 265 if (!fVisVolumes); 266 return;; 267 TIter next(fVisVolumes);; 268 TGeoVolume *vol;; 269 while ((vol = (TGeoVolume *)next())) {; 270 vol->ResetAttBit(TGeoAtt::kVisOnScreen);; 271 }; 272 fVisVolumes->Clear();; 273}; 274 ; 275////////////////////////////////////////////////////////////////////////////////; 276/// Define 100 colors with increasing light intensities for each basic color (1-7); 277/// Register these colors at indexes starting with 1000.; 278 ; 279void TGeoPainter::DefineColors() const; 280{; 281 static Int_t color = 0;; 282 if (!color) {; 283 TColor::InitializeColors();; 284 for (auto icol = 1; icol < 10; ++icol); 285 color = GetColor(icol, 0.5);; 286 }; 287}; 288 ; 289////////////////////////////////////////////////////////////////////////////////; 290/// Get index of a base color with given light intensity (0,1); 291 ; 292Int_t TGeoPainter::GetColor(Int_t base, Float_t light) const; 293{; 294 using IntMap_t = std::map<Int_t, Int_t>;; 295 constexpr Int_t ncolors = 10",MatchSource.WIKI,doc/master/TGeoPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPainter_8cxx_source.html
https://root.cern/doc/master/TGeoPainter_8cxx_source.html:81532,Testability,test,testNo,81532,"ion TGeoAtt.h:63; TGeoAtt::SetVisRaytracevoid SetVisRaytrace(Bool_t flag=kTRUE)Definition TGeoAtt.h:66; TGeoAtt::IsVisDaughtersBool_t IsVisDaughters() constDefinition TGeoAtt.h:84; TGeoAtt::SetAttBitvoid SetAttBit(UInt_t f)Definition TGeoAtt.h:61; TGeoBBoxDefinition TGeoBBox.h:17; TGeoBatemanSolDefinition TGeoElement.h:286; TGeoBatemanSol::ConcentrationDouble_t Concentration(Double_t time) constFind concentration of the element at a given time.Definition TGeoElement.cxx:1601; TGeoBatemanSol::GetNcoeffInt_t GetNcoeff() constDefinition TGeoElement.h:338; TGeoBatemanSol::GetCoeffvoid GetCoeff(Int_t i, Double_t &cn, Double_t &lambda) constDefinition TGeoElement.h:326; TGeoBatemanSol::GetRangevoid GetRange(Double_t &tmin, Double_t &tmax) constDefinition TGeoElement.h:331; TGeoBatemanSol::GetElementTGeoElementRN * GetElement() constDefinition TGeoElement.h:336; TGeoCheckerGeometry checking package.Definition TGeoChecker.h:37; TGeoChecker::CheckShapevoid CheckShape(TGeoShape *shape, Int_t testNo, Int_t nsamples, Option_t *option)Test for shape navigation methods.Definition TGeoChecker.cxx:1752; TGeoChecker::CheckOverlapsvoid CheckOverlaps(const TGeoVolume *vol, Double_t ovlp=0.1, Option_t *option="""")Check illegal overlaps for volume VOL within a limit OVLP.Definition TGeoChecker.cxx:1427; TGeoChecker::TestOverlapsvoid TestOverlaps(const char *path)Geometry overlap checker based on sampling.Definition TGeoChecker.cxx:2761; TGeoChecker::SetSelectedNodevoid SetSelectedNode(TGeoNode *node)Definition TGeoChecker.h:93; TGeoChecker::CheckGeometryFullvoid CheckGeometryFull(Bool_t checkoverlaps=kTRUE, Bool_t checkcrossings=kTRUE, Int_t nrays=10000, const Double_t *vertex=nullptr)Geometry checking.Definition TGeoChecker.cxx:503; TGeoChecker::SamplePointsTGeoNode * SamplePoints(Int_t npoints, Double_t &dist, Double_t epsil, const char *g3path)shoot npoints randomly in a box of 1E-5 around current point.Definition TGeoChecker.cxx:2492; TGeoChecker::CheckPointvoid CheckPoint(Double_t x",MatchSource.WIKI,doc/master/TGeoPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPainter_8cxx_source.html
https://root.cern/doc/master/TGeoPainter_8cxx_source.html:103195,Testability,test,testNo,103195,"rix.Definition TGeoPainter.cxx:1249; TGeoPainter::DrawVolumevoid DrawVolume(TGeoVolume *vol, Option_t *option="""") overrideDraw method.Definition TGeoPainter.cxx:820; TGeoPainter::GetDrawnVolumeTGeoVolume * GetDrawnVolume() const overrideGet currently drawn volume.Definition TGeoPainter.cxx:338; TGeoPainter::DrawPolygonvoid DrawPolygon(const TGeoPolygon *poly) overrideDraw a polygon in 3D.Definition TGeoPainter.cxx:770; TGeoPainter::fNsegmentsInt_t fNsegmentsDefinition TGeoPainter.h:47; TGeoPainter::Testvoid Test(Int_t npoints, Option_t *option) overrideCheck time of finding ""Where am I"" for n points.Definition TGeoPainter.cxx:2170; TGeoPainter::PaintVolumevoid PaintVolume(TGeoVolume *vol, Option_t *option="""", TGeoMatrix *global=nullptr) overridePaint recursively a node and its content according to visualization options.Definition TGeoPainter.cxx:1384; TGeoPainter::fVolInfoTString fVolInfoDefinition TGeoPainter.h:58; TGeoPainter::CheckShapevoid CheckShape(TGeoShape *shape, Int_t testNo, Int_t nsamples, Option_t *option) overrideTest for shape navigation methods.Definition TGeoPainter.cxx:254; TGeoPainter::RandomPointsvoid RandomPoints(const TGeoVolume *vol, Int_t npoints, Option_t *option="""") overrideDraw random points in the bounding box of a volume.Definition TGeoPainter.cxx:1693; TGeoPainter::fTopVisibleBool_t fTopVisibleDefinition TGeoPainter.h:53; TGeoPainter::fGlobalTGeoHMatrix * fGlobalDefinition TGeoPainter.h:61; TGeoPainter::fVisLevelInt_t fVisLevelDefinition TGeoPainter.h:49; TGeoPainter::SetNsegmentsvoid SetNsegments(Int_t nseg=20) overrideSet number of segments to approximate circles.Definition TGeoPainter.cxx:1992; TGeoPainter::CheckBoundaryReferencevoid CheckBoundaryReference(Int_t icheck=-1) overrideCheck the boundary errors reference file created by CheckBoundaryErrors method.Definition TGeoPainter.cxx:210; TGeoPainter::AddTrackPointvoid AddTrackPoint(Double_t *point, Double_t *box, Bool_t reset=kFALSE) overrideAverage center of view of all painted tra",MatchSource.WIKI,doc/master/TGeoPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPainter_8cxx_source.html
https://root.cern/doc/master/TGeoPainter_8cxx_source.html:54736,Usability,progress bar,progress bar,54736,"e->GetMatrix();; 1626 fGeoManager->SetMatrixReflection(matrix->IsReflection());; 1627 fGeoManager->SetPaintVolume(vcrt);; 1628 if (!node->IsVolAttributes() && !strstr(option, ""range"")) {; 1629 col = vcrt->GetLineColor();; 1630 wid = vcrt->GetLineWidth();; 1631 sty = vcrt->GetLineStyle();; 1632 vcrt->SetLineColor(node->GetLineColor());; 1633 vcrt->SetLineWidth(node->GetLineWidth());; 1634 vcrt->SetLineStyle(node->GetLineStyle());; 1635 ((TAttLine *)vcrt)->Modify();; 1636 PaintShape(*shape, option);; 1637 vcrt->SetLineColor(col);; 1638 vcrt->SetLineWidth(wid);; 1639 vcrt->SetLineStyle(sty);; 1640 } else {; 1641 PaintShape(*shape, option);; 1642 }; 1643 } else {; 1644 // Paint full branch, except top node; 1645 for (i = 1; i <= level; i++) {; 1646 vcrt = node->GetVolume(i);; 1647 if (!strstr(option, ""range"")); 1648 ((TAttLine *)vcrt)->Modify();; 1649 shape = vcrt->GetShape();; 1650 *matrix = node->GetMatrix(i);; 1651 fGeoManager->SetMatrixReflection(matrix->IsReflection());; 1652 fGeoManager->SetPaintVolume(vcrt);; 1653 if (!node->IsVolAttributes() && !strstr(option, ""range"")) {; 1654 col = vcrt->GetLineColor();; 1655 wid = vcrt->GetLineWidth();; 1656 sty = vcrt->GetLineStyle();; 1657 vcrt->SetLineColor(node->GetLineColor());; 1658 vcrt->SetLineWidth(node->GetLineWidth());; 1659 vcrt->SetLineStyle(node->GetLineStyle());; 1660 ((TAttLine *)vcrt)->Modify();; 1661 PaintShape(*shape, option);; 1662 vcrt->SetLineColor(col);; 1663 vcrt->SetLineWidth(wid);; 1664 vcrt->SetLineStyle(sty);; 1665 } else {; 1666 PaintShape(*shape, option);; 1667 }; 1668 }; 1669 }; 1670 fGeoManager->SetMatrixReflection(kFALSE);; 1671}; 1672 ; 1673////////////////////////////////////////////////////////////////////////////////; 1674/// Print overlaps (see TGeoChecker::PrintOverlaps()); 1675 ; 1676void TGeoPainter::PrintOverlaps() const; 1677{; 1678 fChecker->PrintOverlaps();; 1679}; 1680 ; 1681////////////////////////////////////////////////////////////////////////////////; 1682/// Text progress bar.",MatchSource.WIKI,doc/master/TGeoPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPainter_8cxx_source.html
https://root.cern/doc/master/TGeoPainter_8cxx_source.html:105975,Usability,progress bar,progress bar,105975," TGeoPainter.cxx:121; TGeoPainter::fCheckedNodeTGeoNode * fCheckedNodeDefinition TGeoPainter.h:59; TGeoPainter::PaintPhysicalNodevoid PaintPhysicalNode(TGeoPhysicalNode *node, Option_t *option="""")Paints a physical node associated with a path.Definition TGeoPainter.cxx:1609; TGeoPainter::fNVisNodesInt_t fNVisNodesDefinition TGeoPainter.h:48; TGeoPainter::fExplodedViewInt_t fExplodedViewDefinition TGeoPainter.h:51; TGeoPainter::GetVolumeInfoconst char * GetVolumeInfo(const TGeoVolume *volume, Int_t px, Int_t py) const overrideGet some info about the current selected volume.Definition TGeoPainter.cxx:1151; TGeoPainter::DrawCurrentPointvoid DrawCurrentPoint(Int_t color) overrideDraw current point in the same view.Definition TGeoPainter.cxx:1004; TGeoPainter::DrawPathvoid DrawPath(const char *path, Option_t *option="""") overrideDraw all volumes for a given path.Definition TGeoPainter.cxx:1026; TGeoPainter::OpProgressvoid OpProgress(const char *opname, Long64_t current, Long64_t size, TStopwatch *watch=nullptr, Bool_t last=kFALSE, Bool_t refresh=kFALSE, const char *msg="""") overrideText progress bar.Definition TGeoPainter.cxx:1684; TGeoPainter::SetCheckedNodevoid SetCheckedNode(TGeoNode *node) overrideSelect a node to be checked for overlaps.Definition TGeoPainter.cxx:2016; TGeoPainter::DrawBatemanSolvoid DrawBatemanSol(TGeoBatemanSol *sol, Option_t *option="""") overrideDraw the time evolution of a radionuclide.Definition TGeoPainter.cxx:726; TGeoPainter::fCheckerTGeoChecker * fCheckerDefinition TGeoPainter.h:64; TGeoPainter::fIsRaytracingBool_t fIsRaytracingDefinition TGeoPainter.h:55; TGeoPainter::ExecuteShapeEventvoid ExecuteShapeEvent(TGeoShape *shape, Int_t event, Int_t px, Int_t py) overrideExecute mouse actions on a given shape.Definition TGeoPainter.cxx:1089; TGeoPainter::WeightDouble_t Weight(Double_t precision, Option_t *option=""v"") overrideCompute weight [kg] of the current volume.Definition TGeoPainter.cxx:2221; TGeoPainter::ExecuteVolumeEventvoid ExecuteVolumeEv",MatchSource.WIKI,doc/master/TGeoPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPainter_8cxx_source.html
https://root.cern/doc/master/TGeoPainter_8h_source.html:18754,Availability,down,down,18754,"ter::UnbombTranslationvoid UnbombTranslation(const Double_t *tr, Double_t *bombtr) overrideGet the new 'unbombed' translation vector according current exploded view mode.Definition TGeoPainter.cxx:2194; TGeoPainter::fVisLockBool_t fVisLockDefinition TGeoPainter.h:52; TGeoPainter::PaintNodevoid PaintNode(TGeoNode *node, Option_t *option="""", TGeoMatrix *global=nullptr) overridePaint recursively a node and its content according to visualization options.Definition TGeoPainter.cxx:1376; TGeoPainter::DefaultAnglesvoid DefaultAngles() overrideSet default angles for the current view.Definition TGeoPainter.cxx:555; TGeoPainter::fClippingShapeTGeoShape * fClippingShapeDefinition TGeoPainter.h:65; TGeoPainter::PaintShapeBool_t PaintShape(const TGeoShape &shape, Option_t *option) constPaint the supplied shape into the current 3D viewer.Definition TGeoPainter.cxx:1550; TGeoPainter::fIsEditableBool_t fIsEditableDefinition TGeoPainter.h:70; TGeoPainter::CountNodesInt_t CountNodes(TGeoVolume *vol, Int_t level) constCount number of visible nodes down to a given level.Definition TGeoPainter.cxx:582; TGeoPainter::fCheckedBoxDouble_t fCheckedBox[6]Definition TGeoPainter.h:45; TGeoPainter::DrawShapevoid DrawShape(TGeoShape *shape, Option_t *option="""") overrideDraw a shape.Definition TGeoPainter.cxx:875; TGeoPainter::DrawOnlyvoid DrawOnly(Option_t *option="""") overrideDraw only one volume.Definition TGeoPainter.cxx:962; TGeoPainter::fOverlapTGeoOverlap * fOverlapDefinition TGeoPainter.h:60; TGeoPainter::CheckGeometryvoid CheckGeometry(Int_t nrays, Double_t startx, Double_t starty, Double_t startz) const overrideGeometry checking method (see TGeoChecker).Definition TGeoPainter.cxx:226; TGeoPainter::fBombYDouble_t fBombYDefinition TGeoPainter.h:42; TGeoPainter::fPaintingOverlapsBool_t fPaintingOverlapsDefinition TGeoPainter.h:54; TGeoPainter::CheckOverlapsvoid CheckOverlaps(const TGeoVolume *vol, Double_t ovlp=0.1, Option_t *option="""") const overrideCheck overlaps for the top volume of the g",MatchSource.WIKI,doc/master/TGeoPainter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPainter_8h_source.html
https://root.cern/doc/master/TGeoPainter_8h_source.html:23315,Availability,error,errors,23315,"lugin) overrideDefinition TGeoPainter.h:165; TGeoPainter::RandomPointsvoid RandomPoints(const TGeoVolume *vol, Int_t npoints, Option_t *option="""") overrideDraw random points in the bounding box of a volume.Definition TGeoPainter.cxx:1693; TGeoPainter::fTopVisibleBool_t fTopVisibleDefinition TGeoPainter.h:53; TGeoPainter::GetTopVolumeTGeoVolume * GetTopVolume() const overrideDefinition TGeoPainter.h:129; TGeoPainter::fGlobalTGeoHMatrix * fGlobalDefinition TGeoPainter.h:61; TGeoPainter::GetBombFactorsvoid GetBombFactors(Double_t &bombx, Double_t &bomby, Double_t &bombz, Double_t &bombr) const overrideDefinition TGeoPainter.h:116; TGeoPainter::fVisLevelInt_t fVisLevelDefinition TGeoPainter.h:49; TGeoPainter::Lockvoid Lock(Bool_t flag=kTRUE)Definition TGeoPainter.h:142; TGeoPainter::SetNsegmentsvoid SetNsegments(Int_t nseg=20) overrideSet number of segments to approximate circles.Definition TGeoPainter.cxx:1992; TGeoPainter::CheckBoundaryReferencevoid CheckBoundaryReference(Int_t icheck=-1) overrideCheck the boundary errors reference file created by CheckBoundaryErrors method.Definition TGeoPainter.cxx:210; TGeoPainter::AddTrackPointvoid AddTrackPoint(Double_t *point, Double_t *box, Bool_t reset=kFALSE) overrideAverage center of view of all painted tracklets and compute view box.Definition TGeoPainter.cxx:138; TGeoPainter::GrabFocusvoid GrabFocus(Int_t nfr=0, Double_t dlong=0, Double_t dlat=0, Double_t dpsi=0) overrideMove focus to current volume.Definition TGeoPainter.cxx:1206; TGeoPainter::DrawOverlapvoid DrawOverlap(void *ovlp, Option_t *option="""") overrideDraw an overlap.Definition TGeoPainter.cxx:913; TGeoPainter::SetVisLevelvoid SetVisLevel(Int_t level=3) overrideSet default level down to which visualization is performed.Definition TGeoPainter.cxx:2024; TGeoPainter::AddSize3Dvoid AddSize3D(Int_t numpoints, Int_t numsegs, Int_t numpolys) overrideAdd numpoints, numsegs, numpolys to the global 3D size.Definition TGeoPainter.cxx:121; TGeoPainter::fCheckedNodeTGeoNode *",MatchSource.WIKI,doc/master/TGeoPainter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPainter_8h_source.html
https://root.cern/doc/master/TGeoPainter_8h_source.html:23998,Availability,down,down,23998,"oPainter.h:49; TGeoPainter::Lockvoid Lock(Bool_t flag=kTRUE)Definition TGeoPainter.h:142; TGeoPainter::SetNsegmentsvoid SetNsegments(Int_t nseg=20) overrideSet number of segments to approximate circles.Definition TGeoPainter.cxx:1992; TGeoPainter::CheckBoundaryReferencevoid CheckBoundaryReference(Int_t icheck=-1) overrideCheck the boundary errors reference file created by CheckBoundaryErrors method.Definition TGeoPainter.cxx:210; TGeoPainter::AddTrackPointvoid AddTrackPoint(Double_t *point, Double_t *box, Bool_t reset=kFALSE) overrideAverage center of view of all painted tracklets and compute view box.Definition TGeoPainter.cxx:138; TGeoPainter::GrabFocusvoid GrabFocus(Int_t nfr=0, Double_t dlong=0, Double_t dlat=0, Double_t dpsi=0) overrideMove focus to current volume.Definition TGeoPainter.cxx:1206; TGeoPainter::DrawOverlapvoid DrawOverlap(void *ovlp, Option_t *option="""") overrideDraw an overlap.Definition TGeoPainter.cxx:913; TGeoPainter::SetVisLevelvoid SetVisLevel(Int_t level=3) overrideSet default level down to which visualization is performed.Definition TGeoPainter.cxx:2024; TGeoPainter::AddSize3Dvoid AddSize3D(Int_t numpoints, Int_t numsegs, Int_t numpolys) overrideAdd numpoints, numsegs, numpolys to the global 3D size.Definition TGeoPainter.cxx:121; TGeoPainter::fCheckedNodeTGeoNode * fCheckedNodeDefinition TGeoPainter.h:59; TGeoPainter::PaintPhysicalNodevoid PaintPhysicalNode(TGeoPhysicalNode *node, Option_t *option="""")Paints a physical node associated with a path.Definition TGeoPainter.cxx:1609; TGeoPainter::fNVisNodesInt_t fNVisNodesDefinition TGeoPainter.h:48; TGeoPainter::fExplodedViewInt_t fExplodedViewDefinition TGeoPainter.h:51; TGeoPainter::GetVolumeInfoconst char * GetVolumeInfo(const TGeoVolume *volume, Int_t px, Int_t py) const overrideGet some info about the current selected volume.Definition TGeoPainter.cxx:1151; TGeoPainter::SetClippingShapevoid SetClippingShape(TGeoShape *shape) overrideDefinition TGeoPainter.h:160; TGeoPainter::DrawCurrentP",MatchSource.WIKI,doc/master/TGeoPainter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPainter_8h_source.html
https://root.cern/doc/master/TGeoPainter_8h_source.html:7261,Deployability,update,update,7261,"tracing() const override { return fIsRaytracing; }; 138 Bool_t IsPaintingShape() const override { return fIsPaintingShape; }; 139 TH2F *LegoPlot(Int_t ntheta = 60, Double_t themin = 0., Double_t themax = 180., Int_t nphi = 90,; 140 Double_t phimin = 0., Double_t phimax = 360., Double_t rmin = 0., Double_t rmax = 9999999,; 141 Option_t *option = """") override;; 142 void Lock(Bool_t flag = kTRUE) { fVisLock = flag; }; 143 void ModifiedPad(Bool_t update = kFALSE) const override;; 144 void OpProgress(const char *opname, Long64_t current, Long64_t size, TStopwatch *watch = nullptr,; 145 Bool_t last = kFALSE, Bool_t refresh = kFALSE, const char *msg = """") override;; 146 void Paint(Option_t *option = """") override;; 147 void PaintNode(TGeoNode *node, Option_t *option = """", TGeoMatrix *global = nullptr) override;; 148 Bool_t PaintShape(const TGeoShape &shape, Option_t *option) const;; 149 void PaintShape(TGeoShape *shape, Option_t *option = """") override;; 150 void PaintOverlap(void *ovlp, Option_t *option = """") override;; 151 void PaintVolume(TGeoVolume *vol, Option_t *option = """", TGeoMatrix *global = nullptr) override;; 152 void PrintOverlaps() const override;; 153 void PaintPhysicalNode(TGeoPhysicalNode *node, Option_t *option = """");; 154 void RandomPoints(const TGeoVolume *vol, Int_t npoints, Option_t *option = """") override;; 155 void RandomRays(Int_t nrays, Double_t startx, Double_t starty, Double_t startz, const char *target_vol = nullptr,; 156 Bool_t check_norm = kFALSE) override;; 157 void Raytrace(Option_t *option = """") override;; 158 TGeoNode *SamplePoints(Int_t npoints, Double_t &dist, Double_t epsil, const char *g3path) override;; 159 void SetBombFactors(Double_t bombx = 1.3, Double_t bomby = 1.3, Double_t bombz = 1.3, Double_t bombr = 1.3) override;; 160 void SetClippingShape(TGeoShape *shape) override { fClippingShape = shape; }; 161 void SetExplodedView(Int_t iopt = 0) override;; 162 void SetNsegments(Int_t nseg = 20) override;; 163 void SetNmeshPoints(Int_t np",MatchSource.WIKI,doc/master/TGeoPainter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPainter_8h_source.html
https://root.cern/doc/master/TGeoPainter_8h_source.html:9897,Deployability,update,updatestatic,9897,"option = """") override;; 158 TGeoNode *SamplePoints(Int_t npoints, Double_t &dist, Double_t epsil, const char *g3path) override;; 159 void SetBombFactors(Double_t bombx = 1.3, Double_t bomby = 1.3, Double_t bombz = 1.3, Double_t bombr = 1.3) override;; 160 void SetClippingShape(TGeoShape *shape) override { fClippingShape = shape; }; 161 void SetExplodedView(Int_t iopt = 0) override;; 162 void SetNsegments(Int_t nseg = 20) override;; 163 void SetNmeshPoints(Int_t npoints) override;; 164 void SetGeoManager(TGeoManager *geom) override { fGeoManager = geom; }; 165 void SetIteratorPlugin(TGeoIteratorPlugin *plugin) override; 166 {; 167 fPlugin = plugin;; 168 ModifiedPad();; 169 }; 170 void SetCheckedNode(TGeoNode *node) override;; 171 void SetRaytracing(Bool_t flag = kTRUE) override { fIsRaytracing = flag; }; 172 void SetTopVisible(Bool_t vis = kTRUE) override;; 173 void SetTopVolume(TGeoVolume *vol) override { fTopVolume = vol; }; 174 void SetVisLevel(Int_t level = 3) override;; 175 void SetVisOption(Int_t option = 0) override;; 176 Int_t ShapeDistancetoPrimitive(const TGeoShape *shape, Int_t numpoints, Int_t px, Int_t py) const override;; 177 void Test(Int_t npoints, Option_t *option) override;; 178 void TestOverlaps(const char *path) override;; 179 Bool_t TestVoxels(TGeoVolume *vol) override;; 180 void UnbombTranslation(const Double_t *tr, Double_t *bombtr) override;; 181 Double_t Weight(Double_t precision, Option_t *option = ""v"") override;; 182 ; 183 ClassDefOverride(TGeoPainter, 0) // geometry painter; 184};; 185 ; 186#endif; updatestatic void update(gsl_integration_workspace *workspace, double a1, double b1, double area1, double error1, double a2, double b2, double area2, double error2)Definition RooAdaptiveGaussKronrodIntegrator1D.cxx:633; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; Float_tfloat Float_tDefinition RtypesCore.h:57; kFALSEconstexpr Bo",MatchSource.WIKI,doc/master/TGeoPainter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPainter_8h_source.html
https://root.cern/doc/master/TGeoPainter_8h_source.html:9915,Deployability,update,update,9915,"option = """") override;; 158 TGeoNode *SamplePoints(Int_t npoints, Double_t &dist, Double_t epsil, const char *g3path) override;; 159 void SetBombFactors(Double_t bombx = 1.3, Double_t bomby = 1.3, Double_t bombz = 1.3, Double_t bombr = 1.3) override;; 160 void SetClippingShape(TGeoShape *shape) override { fClippingShape = shape; }; 161 void SetExplodedView(Int_t iopt = 0) override;; 162 void SetNsegments(Int_t nseg = 20) override;; 163 void SetNmeshPoints(Int_t npoints) override;; 164 void SetGeoManager(TGeoManager *geom) override { fGeoManager = geom; }; 165 void SetIteratorPlugin(TGeoIteratorPlugin *plugin) override; 166 {; 167 fPlugin = plugin;; 168 ModifiedPad();; 169 }; 170 void SetCheckedNode(TGeoNode *node) override;; 171 void SetRaytracing(Bool_t flag = kTRUE) override { fIsRaytracing = flag; }; 172 void SetTopVisible(Bool_t vis = kTRUE) override;; 173 void SetTopVolume(TGeoVolume *vol) override { fTopVolume = vol; }; 174 void SetVisLevel(Int_t level = 3) override;; 175 void SetVisOption(Int_t option = 0) override;; 176 Int_t ShapeDistancetoPrimitive(const TGeoShape *shape, Int_t numpoints, Int_t px, Int_t py) const override;; 177 void Test(Int_t npoints, Option_t *option) override;; 178 void TestOverlaps(const char *path) override;; 179 Bool_t TestVoxels(TGeoVolume *vol) override;; 180 void UnbombTranslation(const Double_t *tr, Double_t *bombtr) override;; 181 Double_t Weight(Double_t precision, Option_t *option = ""v"") override;; 182 ; 183 ClassDefOverride(TGeoPainter, 0) // geometry painter; 184};; 185 ; 186#endif; updatestatic void update(gsl_integration_workspace *workspace, double a1, double b1, double area1, double error1, double a2, double b2, double area2, double error2)Definition RooAdaptiveGaussKronrodIntegrator1D.cxx:633; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; Float_tfloat Float_tDefinition RtypesCore.h:57; kFALSEconstexpr Bo",MatchSource.WIKI,doc/master/TGeoPainter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPainter_8h_source.html
https://root.cern/doc/master/TGeoPainter_8h_source.html:26762,Deployability,update,update,26762,"r.cxx:726; TGeoPainter::fCheckerTGeoChecker * fCheckerDefinition TGeoPainter.h:64; TGeoPainter::IsRaytracingBool_t IsRaytracing() const overrideDefinition TGeoPainter.h:137; TGeoPainter::fIsRaytracingBool_t fIsRaytracingDefinition TGeoPainter.h:55; TGeoPainter::ExecuteShapeEventvoid ExecuteShapeEvent(TGeoShape *shape, Int_t event, Int_t px, Int_t py) overrideExecute mouse actions on a given shape.Definition TGeoPainter.cxx:1089; TGeoPainter::GetViewBoxDouble_t * GetViewBox() overrideDefinition TGeoPainter.h:134; TGeoPainter::WeightDouble_t Weight(Double_t precision, Option_t *option=""v"") overrideCompute weight [kg] of the current volume.Definition TGeoPainter.cxx:2221; TGeoPainter::ExecuteVolumeEventvoid ExecuteVolumeEvent(TGeoVolume *volume, Int_t event, Int_t px, Int_t py) overrideExecute mouse actions on a given volume.Definition TGeoPainter.cxx:1104; TGeoPainter::fBombXDouble_t fBombXDefinition TGeoPainter.h:41; TGeoPainter::ModifiedPadvoid ModifiedPad(Bool_t update=kFALSE) const overrideCheck if a pad and view are present and send signal ""Modified"" to pad.Definition TGeoPainter.cxx:1258; TGeoPainter::SetTopVisiblevoid SetTopVisible(Bool_t vis=kTRUE) overrideSet top geometry volume as visible.Definition TGeoPainter.cxx:2050; TGeoPainter::DrawPanelvoid DrawPanel() overrideDefinition TGeoPainter.cxx:1021; TGeoPainter::GetVisOptionInt_t GetVisOption() const overrideDefinition TGeoPainter.h:131; TGeoPainter::fVisOptionInt_t fVisOptionDefinition TGeoPainter.h:50; TGeoPainter::TestVoxelsBool_t TestVoxels(TGeoVolume *vol) overrideCheck voxels efficiency per volume.Definition TGeoPainter.cxx:2186; TGeoPhysicalNodePhysical nodes are the actual 'touchable' objects in the geometry, representing a path of positioned ...Definition TGeoPhysicalNode.h:35; TGeoPolygonAn arbitrary polygon defined by vertices.Definition TGeoPolygon.h:19; TGeoShapeBase abstract class for all shapes.Definition TGeoShape.h:25; TGeoVolumeTGeoVolume, TGeoVolumeMulti, TGeoVolumeAssembly are the volume c",MatchSource.WIKI,doc/master/TGeoPainter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPainter_8h_source.html
https://root.cern/doc/master/TGeoPainter_8h_source.html:11556,Integrability,interface,interfaces,11556,"Option_tDefinition RtypesCore.h:66; ClassDefOverride#define ClassDefOverride(name, id)Definition Rtypes.h:346; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; TGeoManager.h; TVirtualGeoPainter.h; TBuffer3DGeneric 3D primitive description class.Definition TBuffer3D.h:18; TGeoBatemanSolDefinition TGeoElement.h:286; TGeoCheckerGeometry checking package.Definition TGeoChecker.h:37; TGeoHMatrixMatrix class used for computing global transformations Should NOT be used for node definition.Definition TGeoMatrix.h:458; TGeoIteratorPluginDefinition TGeoNode.h:224; TGeoManagerThe manager class for any TGeo geometry.Definition TGeoManager.h:44; TGeoMatrixGeometrical transformation package.Definition TGeoMatrix.h:38; TGeoNodeA node represent a volume positioned inside another.They store links to both volumes and to the TGeoM...Definition TGeoNode.h:39; TGeoOverlapBase class describing geometry overlaps.Definition TGeoOverlap.h:37; TGeoPainterClass implementing all draw interfaces for a generic 3D viewer using TBuffer3D mechanism.Definition TGeoPainter.h:39; TGeoPainter::AddTrackTVirtualGeoTrack * AddTrack(Int_t id, Int_t pdgcode, TObject *part) overrideCreate a primary TGeoTrack.Definition TGeoPainter.cxx:130; TGeoPainter::PaintOverlapvoid PaintOverlap(void *ovlp, Option_t *option="""") overridePaint an overlap.Definition TGeoPainter.cxx:1321; TGeoPainter::fBombZDouble_t fBombZDefinition TGeoPainter.h:43; TGeoPainter::EstimateCameraMovevoid EstimateCameraMove(Double_t tmin, Double_t tmax, Double_t *start, Double_t *end) overrideEstimate camera movement between tmin and tmax for best track display.Definition TGeoPainter.cxx:1039; TGeoPainter::fVisVolumesTObjArray * fVisVolumesDefinition TGeoPainter.h:69; TGeoPainter::fPluginTGeoIteratorPlugin * fPluginDefinition TGeoPainter.h:68; TGeoPainter::fMatDouble_t fMat[9]Definition TGeoPainter.h:46; TGeoPainter::SamplePointsTGeoNode * SamplePoints(Int_t npoints, Double_t &dist, Double_t epsil, const char *g3path) overri",MatchSource.WIKI,doc/master/TGeoPainter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPainter_8h_source.html
https://root.cern/doc/master/TGeoPainter_8h_source.html:2773,Modifiability,plugin,plugin,2773," fCheckedBox[6]; // bounding box of checked node; 46 Double_t fMat[9]; // view rotation matrix; 47 Int_t fNsegments; // number of segments approximating circles; 48 Int_t fNVisNodes; // number of visible nodes; 49 Int_t fVisLevel; // depth for drawing; 50 Int_t fVisOption; // global visualization option; 51 Int_t fExplodedView; // type of exploding current view; 52 Bool_t fVisLock; // lock for adding visible volumes; 53 Bool_t fTopVisible; // set top volume visible; 54 Bool_t fPaintingOverlaps; // lock overlaps painting; 55 Bool_t fIsRaytracing; // raytracing flag; 56 Bool_t fIsPaintingShape; // flag for shape painting; 57 TString fVisBranch; // drawn branch; 58 TString fVolInfo; // volume info; 59 TGeoNode *fCheckedNode; // checked node; 60 TGeoOverlap *fOverlap; // current overlap; 61 TGeoHMatrix *fGlobal; // current global matrix; 62 TBuffer3D *fBuffer; // buffer used for painting; 63 TGeoManager *fGeoManager; // geometry to which applies; 64 TGeoChecker *fChecker; // geometry checker; 65 TGeoShape *fClippingShape; // clipping shape; 66 TGeoVolume *fTopVolume; // top drawn volume; 67 TGeoVolume *fLastVolume; // last drawn volume; 68 TGeoIteratorPlugin *fPlugin; // User iterator plugin for changing pain volume properties; 69 TObjArray *fVisVolumes; // list of visible volumes; 70 Bool_t fIsEditable; // flag that geometry is editable; 71 ; 72 void DefineColors() const;; 73 void LocalToMasterVect(const Double_t *local, Double_t *master) const;; 74 ; 75protected:; 76 void ClearVisibleVolumes();; 77 ; 78public:; 79 TGeoPainter(TGeoManager *manager);; 80 ~TGeoPainter() override;; 81 ; 82 void AddSize3D(Int_t numpoints, Int_t numsegs, Int_t numpolys) override;; 83 TVirtualGeoTrack *AddTrack(Int_t id, Int_t pdgcode, TObject *part) override;; 84 void AddTrackPoint(Double_t *point, Double_t *box, Bool_t reset = kFALSE) override;; 85 void BombTranslation(const Double_t *tr, Double_t *bombtr) override;; 86 void CheckBoundaryErrors(Int_t ntracks = 1000000, Double_t radius = -1.",MatchSource.WIKI,doc/master/TGeoPainter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPainter_8h_source.html
https://root.cern/doc/master/TGeoPainter_8h_source.html:8955,Modifiability,plugin,plugin,8955,"option = """") override;; 158 TGeoNode *SamplePoints(Int_t npoints, Double_t &dist, Double_t epsil, const char *g3path) override;; 159 void SetBombFactors(Double_t bombx = 1.3, Double_t bomby = 1.3, Double_t bombz = 1.3, Double_t bombr = 1.3) override;; 160 void SetClippingShape(TGeoShape *shape) override { fClippingShape = shape; }; 161 void SetExplodedView(Int_t iopt = 0) override;; 162 void SetNsegments(Int_t nseg = 20) override;; 163 void SetNmeshPoints(Int_t npoints) override;; 164 void SetGeoManager(TGeoManager *geom) override { fGeoManager = geom; }; 165 void SetIteratorPlugin(TGeoIteratorPlugin *plugin) override; 166 {; 167 fPlugin = plugin;; 168 ModifiedPad();; 169 }; 170 void SetCheckedNode(TGeoNode *node) override;; 171 void SetRaytracing(Bool_t flag = kTRUE) override { fIsRaytracing = flag; }; 172 void SetTopVisible(Bool_t vis = kTRUE) override;; 173 void SetTopVolume(TGeoVolume *vol) override { fTopVolume = vol; }; 174 void SetVisLevel(Int_t level = 3) override;; 175 void SetVisOption(Int_t option = 0) override;; 176 Int_t ShapeDistancetoPrimitive(const TGeoShape *shape, Int_t numpoints, Int_t px, Int_t py) const override;; 177 void Test(Int_t npoints, Option_t *option) override;; 178 void TestOverlaps(const char *path) override;; 179 Bool_t TestVoxels(TGeoVolume *vol) override;; 180 void UnbombTranslation(const Double_t *tr, Double_t *bombtr) override;; 181 Double_t Weight(Double_t precision, Option_t *option = ""v"") override;; 182 ; 183 ClassDefOverride(TGeoPainter, 0) // geometry painter; 184};; 185 ; 186#endif; updatestatic void update(gsl_integration_workspace *workspace, double a1, double b1, double area1, double error1, double a2, double b2, double area2, double error2)Definition RooAdaptiveGaussKronrodIntegrator1D.cxx:633; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; Float_tfloat Float_tDefinition RtypesCore.h:57; kFALSEconstexpr Bo",MatchSource.WIKI,doc/master/TGeoPainter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPainter_8h_source.html
https://root.cern/doc/master/TGeoPainter_8h_source.html:8994,Modifiability,plugin,plugin,8994,"option = """") override;; 158 TGeoNode *SamplePoints(Int_t npoints, Double_t &dist, Double_t epsil, const char *g3path) override;; 159 void SetBombFactors(Double_t bombx = 1.3, Double_t bomby = 1.3, Double_t bombz = 1.3, Double_t bombr = 1.3) override;; 160 void SetClippingShape(TGeoShape *shape) override { fClippingShape = shape; }; 161 void SetExplodedView(Int_t iopt = 0) override;; 162 void SetNsegments(Int_t nseg = 20) override;; 163 void SetNmeshPoints(Int_t npoints) override;; 164 void SetGeoManager(TGeoManager *geom) override { fGeoManager = geom; }; 165 void SetIteratorPlugin(TGeoIteratorPlugin *plugin) override; 166 {; 167 fPlugin = plugin;; 168 ModifiedPad();; 169 }; 170 void SetCheckedNode(TGeoNode *node) override;; 171 void SetRaytracing(Bool_t flag = kTRUE) override { fIsRaytracing = flag; }; 172 void SetTopVisible(Bool_t vis = kTRUE) override;; 173 void SetTopVolume(TGeoVolume *vol) override { fTopVolume = vol; }; 174 void SetVisLevel(Int_t level = 3) override;; 175 void SetVisOption(Int_t option = 0) override;; 176 Int_t ShapeDistancetoPrimitive(const TGeoShape *shape, Int_t numpoints, Int_t px, Int_t py) const override;; 177 void Test(Int_t npoints, Option_t *option) override;; 178 void TestOverlaps(const char *path) override;; 179 Bool_t TestVoxels(TGeoVolume *vol) override;; 180 void UnbombTranslation(const Double_t *tr, Double_t *bombtr) override;; 181 Double_t Weight(Double_t precision, Option_t *option = ""v"") override;; 182 ; 183 ClassDefOverride(TGeoPainter, 0) // geometry painter; 184};; 185 ; 186#endif; updatestatic void update(gsl_integration_workspace *workspace, double a1, double b1, double area1, double error1, double a2, double b2, double area2, double error2)Definition RooAdaptiveGaussKronrodIntegrator1D.cxx:633; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; Float_tfloat Float_tDefinition RtypesCore.h:57; kFALSEconstexpr Bo",MatchSource.WIKI,doc/master/TGeoPainter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPainter_8h_source.html
https://root.cern/doc/master/TGeoPainter_8h_source.html:22285,Modifiability,plugin,plugin,22285,":820; TGeoPainter::GetDrawnVolumeTGeoVolume * GetDrawnVolume() const overrideGet currently drawn volume.Definition TGeoPainter.cxx:338; TGeoPainter::DrawPolygonvoid DrawPolygon(const TGeoPolygon *poly) overrideDraw a polygon in 3D.Definition TGeoPainter.cxx:770; TGeoPainter::fNsegmentsInt_t fNsegmentsDefinition TGeoPainter.h:47; TGeoPainter::Testvoid Test(Int_t npoints, Option_t *option) overrideCheck time of finding ""Where am I"" for n points.Definition TGeoPainter.cxx:2170; TGeoPainter::PaintVolumevoid PaintVolume(TGeoVolume *vol, Option_t *option="""", TGeoMatrix *global=nullptr) overridePaint recursively a node and its content according to visualization options.Definition TGeoPainter.cxx:1384; TGeoPainter::fVolInfoTString fVolInfoDefinition TGeoPainter.h:58; TGeoPainter::CheckShapevoid CheckShape(TGeoShape *shape, Int_t testNo, Int_t nsamples, Option_t *option) overrideTest for shape navigation methods.Definition TGeoPainter.cxx:254; TGeoPainter::SetIteratorPluginvoid SetIteratorPlugin(TGeoIteratorPlugin *plugin) overrideDefinition TGeoPainter.h:165; TGeoPainter::RandomPointsvoid RandomPoints(const TGeoVolume *vol, Int_t npoints, Option_t *option="""") overrideDraw random points in the bounding box of a volume.Definition TGeoPainter.cxx:1693; TGeoPainter::fTopVisibleBool_t fTopVisibleDefinition TGeoPainter.h:53; TGeoPainter::GetTopVolumeTGeoVolume * GetTopVolume() const overrideDefinition TGeoPainter.h:129; TGeoPainter::fGlobalTGeoHMatrix * fGlobalDefinition TGeoPainter.h:61; TGeoPainter::GetBombFactorsvoid GetBombFactors(Double_t &bombx, Double_t &bomby, Double_t &bombz, Double_t &bombr) const overrideDefinition TGeoPainter.h:116; TGeoPainter::fVisLevelInt_t fVisLevelDefinition TGeoPainter.h:49; TGeoPainter::Lockvoid Lock(Bool_t flag=kTRUE)Definition TGeoPainter.h:142; TGeoPainter::SetNsegmentsvoid SetNsegments(Int_t nseg=20) overrideSet number of segments to approximate circles.Definition TGeoPainter.cxx:1992; TGeoPainter::CheckBoundaryReferencevoid CheckBoundaryRef",MatchSource.WIKI,doc/master/TGeoPainter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPainter_8h_source.html
https://root.cern/doc/master/TGeoPainter_8h_source.html:20197,Performance,load,loaded,20197,"on TGeoPainter.h:60; TGeoPainter::CheckGeometryvoid CheckGeometry(Int_t nrays, Double_t startx, Double_t starty, Double_t startz) const overrideGeometry checking method (see TGeoChecker).Definition TGeoPainter.cxx:226; TGeoPainter::fBombYDouble_t fBombYDefinition TGeoPainter.h:42; TGeoPainter::fPaintingOverlapsBool_t fPaintingOverlapsDefinition TGeoPainter.h:54; TGeoPainter::CheckOverlapsvoid CheckOverlaps(const TGeoVolume *vol, Double_t ovlp=0.1, Option_t *option="""") const overrideCheck overlaps for the top volume of the geometry, within a limit OVLP.Definition TGeoPainter.cxx:234; TGeoPainter::SetBombFactorsvoid SetBombFactors(Double_t bombx=1.3, Double_t bomby=1.3, Double_t bombz=1.3, Double_t bombr=1.3) overrideSet cartesian and radial bomb factors for translations.Definition TGeoPainter.cxx:1949; TGeoPainter::DefaultColorsvoid DefaultColors() overrideSet default volume colors according to tracking media.Definition TGeoPainter.cxx:570; TGeoPainter::CheckEditvoid CheckEdit()Check if Ged library is loaded and load geometry editor classe.Definition TGeoPainter.cxx:682; TGeoPainter::GetVisLevelInt_t GetVisLevel() const overrideDefinition TGeoPainter.h:130; TGeoPainter::CheckBoundaryErrorsvoid CheckBoundaryErrors(Int_t ntracks=1000000, Double_t radius=-1.) overrideCheck pushes and pulls needed to cross the next boundary with respect to the position given by FindNe...Definition TGeoPainter.cxx:200; TGeoPainter::ClearVisibleVolumesvoid ClearVisibleVolumes()Clear the list of visible volumes reset the kVisOnScreen bit for volumes previously in the list.Definition TGeoPainter.cxx:263; TGeoPainter::GetColorInt_t GetColor(Int_t base, Float_t light) const overrideGet index of a base color with given light intensity (0,1)Definition TGeoPainter.cxx:292; TGeoPainter::LocalToMasterVectvoid LocalToMasterVect(const Double_t *local, Double_t *master) constConvert a local vector according view rotation matrix.Definition TGeoPainter.cxx:1249; TGeoPainter::DrawVolumevoid DrawVolume(TG",MatchSource.WIKI,doc/master/TGeoPainter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPainter_8h_source.html
https://root.cern/doc/master/TGeoPainter_8h_source.html:20208,Performance,load,load,20208,"on TGeoPainter.h:60; TGeoPainter::CheckGeometryvoid CheckGeometry(Int_t nrays, Double_t startx, Double_t starty, Double_t startz) const overrideGeometry checking method (see TGeoChecker).Definition TGeoPainter.cxx:226; TGeoPainter::fBombYDouble_t fBombYDefinition TGeoPainter.h:42; TGeoPainter::fPaintingOverlapsBool_t fPaintingOverlapsDefinition TGeoPainter.h:54; TGeoPainter::CheckOverlapsvoid CheckOverlaps(const TGeoVolume *vol, Double_t ovlp=0.1, Option_t *option="""") const overrideCheck overlaps for the top volume of the geometry, within a limit OVLP.Definition TGeoPainter.cxx:234; TGeoPainter::SetBombFactorsvoid SetBombFactors(Double_t bombx=1.3, Double_t bomby=1.3, Double_t bombz=1.3, Double_t bombr=1.3) overrideSet cartesian and radial bomb factors for translations.Definition TGeoPainter.cxx:1949; TGeoPainter::DefaultColorsvoid DefaultColors() overrideSet default volume colors according to tracking media.Definition TGeoPainter.cxx:570; TGeoPainter::CheckEditvoid CheckEdit()Check if Ged library is loaded and load geometry editor classe.Definition TGeoPainter.cxx:682; TGeoPainter::GetVisLevelInt_t GetVisLevel() const overrideDefinition TGeoPainter.h:130; TGeoPainter::CheckBoundaryErrorsvoid CheckBoundaryErrors(Int_t ntracks=1000000, Double_t radius=-1.) overrideCheck pushes and pulls needed to cross the next boundary with respect to the position given by FindNe...Definition TGeoPainter.cxx:200; TGeoPainter::ClearVisibleVolumesvoid ClearVisibleVolumes()Clear the list of visible volumes reset the kVisOnScreen bit for volumes previously in the list.Definition TGeoPainter.cxx:263; TGeoPainter::GetColorInt_t GetColor(Int_t base, Float_t light) const overrideGet index of a base color with given light intensity (0,1)Definition TGeoPainter.cxx:292; TGeoPainter::LocalToMasterVectvoid LocalToMasterVect(const Double_t *local, Double_t *master) constConvert a local vector according view rotation matrix.Definition TGeoPainter.cxx:1249; TGeoPainter::DrawVolumevoid DrawVolume(TG",MatchSource.WIKI,doc/master/TGeoPainter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPainter_8h_source.html
https://root.cern/doc/master/TGeoPainter_8h_source.html:24029,Performance,perform,performed,24029,"oPainter.h:49; TGeoPainter::Lockvoid Lock(Bool_t flag=kTRUE)Definition TGeoPainter.h:142; TGeoPainter::SetNsegmentsvoid SetNsegments(Int_t nseg=20) overrideSet number of segments to approximate circles.Definition TGeoPainter.cxx:1992; TGeoPainter::CheckBoundaryReferencevoid CheckBoundaryReference(Int_t icheck=-1) overrideCheck the boundary errors reference file created by CheckBoundaryErrors method.Definition TGeoPainter.cxx:210; TGeoPainter::AddTrackPointvoid AddTrackPoint(Double_t *point, Double_t *box, Bool_t reset=kFALSE) overrideAverage center of view of all painted tracklets and compute view box.Definition TGeoPainter.cxx:138; TGeoPainter::GrabFocusvoid GrabFocus(Int_t nfr=0, Double_t dlong=0, Double_t dlat=0, Double_t dpsi=0) overrideMove focus to current volume.Definition TGeoPainter.cxx:1206; TGeoPainter::DrawOverlapvoid DrawOverlap(void *ovlp, Option_t *option="""") overrideDraw an overlap.Definition TGeoPainter.cxx:913; TGeoPainter::SetVisLevelvoid SetVisLevel(Int_t level=3) overrideSet default level down to which visualization is performed.Definition TGeoPainter.cxx:2024; TGeoPainter::AddSize3Dvoid AddSize3D(Int_t numpoints, Int_t numsegs, Int_t numpolys) overrideAdd numpoints, numsegs, numpolys to the global 3D size.Definition TGeoPainter.cxx:121; TGeoPainter::fCheckedNodeTGeoNode * fCheckedNodeDefinition TGeoPainter.h:59; TGeoPainter::PaintPhysicalNodevoid PaintPhysicalNode(TGeoPhysicalNode *node, Option_t *option="""")Paints a physical node associated with a path.Definition TGeoPainter.cxx:1609; TGeoPainter::fNVisNodesInt_t fNVisNodesDefinition TGeoPainter.h:48; TGeoPainter::fExplodedViewInt_t fExplodedViewDefinition TGeoPainter.h:51; TGeoPainter::GetVolumeInfoconst char * GetVolumeInfo(const TGeoVolume *volume, Int_t px, Int_t py) const overrideGet some info about the current selected volume.Definition TGeoPainter.cxx:1151; TGeoPainter::SetClippingShapevoid SetClippingShape(TGeoShape *shape) overrideDefinition TGeoPainter.h:160; TGeoPainter::DrawCurrentP",MatchSource.WIKI,doc/master/TGeoPainter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPainter_8h_source.html
https://root.cern/doc/master/TGeoPainter_8h_source.html:4029,Safety,safe,safety,4029,"operties; 69 TObjArray *fVisVolumes; // list of visible volumes; 70 Bool_t fIsEditable; // flag that geometry is editable; 71 ; 72 void DefineColors() const;; 73 void LocalToMasterVect(const Double_t *local, Double_t *master) const;; 74 ; 75protected:; 76 void ClearVisibleVolumes();; 77 ; 78public:; 79 TGeoPainter(TGeoManager *manager);; 80 ~TGeoPainter() override;; 81 ; 82 void AddSize3D(Int_t numpoints, Int_t numsegs, Int_t numpolys) override;; 83 TVirtualGeoTrack *AddTrack(Int_t id, Int_t pdgcode, TObject *part) override;; 84 void AddTrackPoint(Double_t *point, Double_t *box, Bool_t reset = kFALSE) override;; 85 void BombTranslation(const Double_t *tr, Double_t *bombtr) override;; 86 void CheckBoundaryErrors(Int_t ntracks = 1000000, Double_t radius = -1.) override;; 87 void CheckBoundaryReference(Int_t icheck = -1) override;; 88 void CheckGeometryFull(Bool_t checkoverlaps = kTRUE, Bool_t checkcrossings = kTRUE, Int_t nrays = 10000,; 89 const Double_t *vertex = nullptr) override;; 90 void CheckGeometry(Int_t nrays, Double_t startx, Double_t starty, Double_t startz) const override;; 91 void CheckEdit();; 92 void CheckPoint(Double_t x = 0, Double_t y = 0, Double_t z = 0, Option_t *option = """", Double_t safety = 0.) override;; 93 void CheckShape(TGeoShape *shape, Int_t testNo, Int_t nsamples, Option_t *option) override;; 94 void CheckOverlaps(const TGeoVolume *vol, Double_t ovlp = 0.1, Option_t *option = """") const override;; 95 Int_t CountNodes(TGeoVolume *vol, Int_t level) const;; 96 Int_t CountVisibleNodes() override;; 97 void DefaultAngles() override;; 98 void DefaultColors() override;; 99 Int_t DistanceToPrimitiveVol(TGeoVolume *vol, Int_t px, Int_t py) override;; 100 void Draw(Option_t *option = """") override;; 101 void DrawBatemanSol(TGeoBatemanSol *sol, Option_t *option = """") override;; 102 void DrawOverlap(void *ovlp, Option_t *option = """") override;; 103 void DrawCurrentPoint(Int_t color) override;; 104 void DrawOnly(Option_t *option = """") override;; 105 void",MatchSource.WIKI,doc/master/TGeoPainter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPainter_8h_source.html
https://root.cern/doc/master/TGeoPainter_8h_source.html:17403,Safety,safe,safety,17403,"id DefineColors() constDefine 100 colors with increasing light intensities for each basic color (1-7) Register these colors ...Definition TGeoPainter.cxx:279; TGeoPainter::SetExplodedViewvoid SetExplodedView(Int_t iopt=0) overrideSet type of exploding view.Definition TGeoPainter.cxx:1962; TGeoPainter::ExecuteManagerEventvoid ExecuteManagerEvent(TGeoManager *geom, Int_t event, Int_t px, Int_t py) overrideExecute mouse actions on a given volume.Definition TGeoPainter.cxx:1074; TGeoPainter::SetTopVolumevoid SetTopVolume(TGeoVolume *vol) overrideDefinition TGeoPainter.h:173; TGeoPainter::SetRaytracingvoid SetRaytracing(Bool_t flag=kTRUE) overrideDefinition TGeoPainter.h:171; TGeoPainter::fLastVolumeTGeoVolume * fLastVolumeDefinition TGeoPainter.h:67; TGeoPainter::SetNmeshPointsvoid SetNmeshPoints(Int_t npoints) overrideSet number of points to be generated on the shape outline when checking for overlaps.Definition TGeoPainter.cxx:2007; TGeoPainter::CheckPointvoid CheckPoint(Double_t x=0, Double_t y=0, Double_t z=0, Option_t *option="""", Double_t safety=0.) overrideCheck current point in the geometry.Definition TGeoPainter.cxx:242; TGeoPainter::DistanceToPrimitiveVolInt_t DistanceToPrimitiveVol(TGeoVolume *vol, Int_t px, Int_t py) overrideCompute the closest distance of approach from point px,py to a volume.Definition TGeoPainter.cxx:348; TGeoPainter::UnbombTranslationvoid UnbombTranslation(const Double_t *tr, Double_t *bombtr) overrideGet the new 'unbombed' translation vector according current exploded view mode.Definition TGeoPainter.cxx:2194; TGeoPainter::fVisLockBool_t fVisLockDefinition TGeoPainter.h:52; TGeoPainter::PaintNodevoid PaintNode(TGeoNode *node, Option_t *option="""", TGeoMatrix *global=nullptr) overridePaint recursively a node and its content according to visualization options.Definition TGeoPainter.cxx:1376; TGeoPainter::DefaultAnglesvoid DefaultAngles() overrideSet default angles for the current view.Definition TGeoPainter.cxx:555; TGeoPainter::fClippingSh",MatchSource.WIKI,doc/master/TGeoPainter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPainter_8h_source.html
https://root.cern/doc/master/TGeoPainter_8h_source.html:4096,Testability,test,testNo,4096,"oManager *manager);; 80 ~TGeoPainter() override;; 81 ; 82 void AddSize3D(Int_t numpoints, Int_t numsegs, Int_t numpolys) override;; 83 TVirtualGeoTrack *AddTrack(Int_t id, Int_t pdgcode, TObject *part) override;; 84 void AddTrackPoint(Double_t *point, Double_t *box, Bool_t reset = kFALSE) override;; 85 void BombTranslation(const Double_t *tr, Double_t *bombtr) override;; 86 void CheckBoundaryErrors(Int_t ntracks = 1000000, Double_t radius = -1.) override;; 87 void CheckBoundaryReference(Int_t icheck = -1) override;; 88 void CheckGeometryFull(Bool_t checkoverlaps = kTRUE, Bool_t checkcrossings = kTRUE, Int_t nrays = 10000,; 89 const Double_t *vertex = nullptr) override;; 90 void CheckGeometry(Int_t nrays, Double_t startx, Double_t starty, Double_t startz) const override;; 91 void CheckEdit();; 92 void CheckPoint(Double_t x = 0, Double_t y = 0, Double_t z = 0, Option_t *option = """", Double_t safety = 0.) override;; 93 void CheckShape(TGeoShape *shape, Int_t testNo, Int_t nsamples, Option_t *option) override;; 94 void CheckOverlaps(const TGeoVolume *vol, Double_t ovlp = 0.1, Option_t *option = """") const override;; 95 Int_t CountNodes(TGeoVolume *vol, Int_t level) const;; 96 Int_t CountVisibleNodes() override;; 97 void DefaultAngles() override;; 98 void DefaultColors() override;; 99 Int_t DistanceToPrimitiveVol(TGeoVolume *vol, Int_t px, Int_t py) override;; 100 void Draw(Option_t *option = """") override;; 101 void DrawBatemanSol(TGeoBatemanSol *sol, Option_t *option = """") override;; 102 void DrawOverlap(void *ovlp, Option_t *option = """") override;; 103 void DrawCurrentPoint(Int_t color) override;; 104 void DrawOnly(Option_t *option = """") override;; 105 void DrawPanel() override;; 106 void DrawPath(const char *path, Option_t *option = """") override;; 107 void DrawPolygon(const TGeoPolygon *poly) override;; 108 void DrawShape(TGeoShape *shape, Option_t *option = """") override;; 109 void DrawVolume(TGeoVolume *vol, Option_t *option = """") override;; 110 void EditGeometry(Opti",MatchSource.WIKI,doc/master/TGeoPainter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPainter_8h_source.html
https://root.cern/doc/master/TGeoPainter_8h_source.html:22096,Testability,test,testNo,22096,"rix.Definition TGeoPainter.cxx:1249; TGeoPainter::DrawVolumevoid DrawVolume(TGeoVolume *vol, Option_t *option="""") overrideDraw method.Definition TGeoPainter.cxx:820; TGeoPainter::GetDrawnVolumeTGeoVolume * GetDrawnVolume() const overrideGet currently drawn volume.Definition TGeoPainter.cxx:338; TGeoPainter::DrawPolygonvoid DrawPolygon(const TGeoPolygon *poly) overrideDraw a polygon in 3D.Definition TGeoPainter.cxx:770; TGeoPainter::fNsegmentsInt_t fNsegmentsDefinition TGeoPainter.h:47; TGeoPainter::Testvoid Test(Int_t npoints, Option_t *option) overrideCheck time of finding ""Where am I"" for n points.Definition TGeoPainter.cxx:2170; TGeoPainter::PaintVolumevoid PaintVolume(TGeoVolume *vol, Option_t *option="""", TGeoMatrix *global=nullptr) overridePaint recursively a node and its content according to visualization options.Definition TGeoPainter.cxx:1384; TGeoPainter::fVolInfoTString fVolInfoDefinition TGeoPainter.h:58; TGeoPainter::CheckShapevoid CheckShape(TGeoShape *shape, Int_t testNo, Int_t nsamples, Option_t *option) overrideTest for shape navigation methods.Definition TGeoPainter.cxx:254; TGeoPainter::SetIteratorPluginvoid SetIteratorPlugin(TGeoIteratorPlugin *plugin) overrideDefinition TGeoPainter.h:165; TGeoPainter::RandomPointsvoid RandomPoints(const TGeoVolume *vol, Int_t npoints, Option_t *option="""") overrideDraw random points in the bounding box of a volume.Definition TGeoPainter.cxx:1693; TGeoPainter::fTopVisibleBool_t fTopVisibleDefinition TGeoPainter.h:53; TGeoPainter::GetTopVolumeTGeoVolume * GetTopVolume() const overrideDefinition TGeoPainter.h:129; TGeoPainter::fGlobalTGeoHMatrix * fGlobalDefinition TGeoPainter.h:61; TGeoPainter::GetBombFactorsvoid GetBombFactors(Double_t &bombx, Double_t &bomby, Double_t &bombz, Double_t &bombr) const overrideDefinition TGeoPainter.h:116; TGeoPainter::fVisLevelInt_t fVisLevelDefinition TGeoPainter.h:49; TGeoPainter::Lockvoid Lock(Bool_t flag=kTRUE)Definition TGeoPainter.h:142; TGeoPainter::SetNsegmentsvoid SetNsegment",MatchSource.WIKI,doc/master/TGeoPainter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPainter_8h_source.html
https://root.cern/doc/master/TGeoPainter_8h_source.html:25433,Usability,progress bar,progress bar,25433,"ter::PaintPhysicalNodevoid PaintPhysicalNode(TGeoPhysicalNode *node, Option_t *option="""")Paints a physical node associated with a path.Definition TGeoPainter.cxx:1609; TGeoPainter::fNVisNodesInt_t fNVisNodesDefinition TGeoPainter.h:48; TGeoPainter::fExplodedViewInt_t fExplodedViewDefinition TGeoPainter.h:51; TGeoPainter::GetVolumeInfoconst char * GetVolumeInfo(const TGeoVolume *volume, Int_t px, Int_t py) const overrideGet some info about the current selected volume.Definition TGeoPainter.cxx:1151; TGeoPainter::SetClippingShapevoid SetClippingShape(TGeoShape *shape) overrideDefinition TGeoPainter.h:160; TGeoPainter::DrawCurrentPointvoid DrawCurrentPoint(Int_t color) overrideDraw current point in the same view.Definition TGeoPainter.cxx:1004; TGeoPainter::DrawPathvoid DrawPath(const char *path, Option_t *option="""") overrideDraw all volumes for a given path.Definition TGeoPainter.cxx:1026; TGeoPainter::OpProgressvoid OpProgress(const char *opname, Long64_t current, Long64_t size, TStopwatch *watch=nullptr, Bool_t last=kFALSE, Bool_t refresh=kFALSE, const char *msg="""") overrideText progress bar.Definition TGeoPainter.cxx:1684; TGeoPainter::SetCheckedNodevoid SetCheckedNode(TGeoNode *node) overrideSelect a node to be checked for overlaps.Definition TGeoPainter.cxx:2016; TGeoPainter::DrawBatemanSolvoid DrawBatemanSol(TGeoBatemanSol *sol, Option_t *option="""") overrideDraw the time evolution of a radionuclide.Definition TGeoPainter.cxx:726; TGeoPainter::fCheckerTGeoChecker * fCheckerDefinition TGeoPainter.h:64; TGeoPainter::IsRaytracingBool_t IsRaytracing() const overrideDefinition TGeoPainter.h:137; TGeoPainter::fIsRaytracingBool_t fIsRaytracingDefinition TGeoPainter.h:55; TGeoPainter::ExecuteShapeEventvoid ExecuteShapeEvent(TGeoShape *shape, Int_t event, Int_t px, Int_t py) overrideExecute mouse actions on a given shape.Definition TGeoPainter.cxx:1089; TGeoPainter::GetViewBoxDouble_t * GetViewBox() overrideDefinition TGeoPainter.h:134; TGeoPainter::WeightDouble_t Weight(",MatchSource.WIKI,doc/master/TGeoPainter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPainter_8h_source.html
https://root.cern/doc/master/TGeoPhysicalNode_8cxx_source.html:16544,Availability,avail,available,16544,"//////////////////////////; 472/// Refresh this physical node. Called for all registered physical nodes; 473/// after an Align() call.; 474 ; 475void TGeoPhysicalNode::Refresh(); 476{; 477 SetPath(fName.Data());; 478}; 479 ; 480////////////////////////////////////////////////////////////////////////////////; 481/// Set node branch according to current state; 482 ; 483void TGeoPhysicalNode::SetBranchAsState(); 484{; 485 TGeoNodeCache *cache = gGeoManager->GetCache();; 486 if (!cache) {; 487 Error(""SetBranchAsState"", ""no state available"");; 488 return;; 489 }; 490 if (!cache->IsDummy()) {; 491 Error(""SetBranchAsState"", ""not implemented for full cache"");; 492 return;; 493 }; 494 if (!fNodes); 495 fNodes = new TObjArray(30);; 496 if (!fMatrices); 497 fMatrices = new TObjArray(30);; 498 TGeoHMatrix **matrices = (TGeoHMatrix **)cache->GetMatrices();; 499 TGeoNode **branch = (TGeoNode **)cache->GetBranch();; 500 ; 501 Bool_t refresh = (fLevel > 0) ? kTRUE : kFALSE;; 502 if (refresh) {; 503 TGeoHMatrix *current;; 504 for (Int_t i = 0; i <= fLevel; i++) {; 505 fNodes->AddAtAndExpand(branch[i], i);; 506 current = (TGeoHMatrix *)fMatrices->UncheckedAt(i);; 507 *current = *matrices[i];; 508 }; 509 return;; 510 }; 511 fLevel = gGeoManager->GetLevel();; 512 for (Int_t i = 0; i <= fLevel; i++) {; 513 fNodes->AddAtAndExpand(branch[i], i);; 514 fMatrices->AddAtAndExpand(new TGeoHMatrix(*matrices[i]), i);; 515 }; 516 TGeoNode *node = (TGeoNode *)fNodes->UncheckedAt(fLevel);; 517 if (!fMatrixOrig); 518 fMatrixOrig = new TGeoHMatrix();; 519 *fMatrixOrig = node->GetMatrix();; 520}; 521 ; 522////////////////////////////////////////////////////////////////////////////////; 523/// Allows PN entries (or users) to preset the local original matrix for the; 524/// last node pointed by the path.; 525 ; 526void TGeoPhysicalNode::SetMatrixOrig(const TGeoMatrix *local); 527{; 528 if (!fMatrixOrig); 529 fMatrixOrig = new TGeoHMatrix();; 530 if (!local) {; 531 fMatrixOrig->Clear();; 532 return;; 533",MatchSource.WIKI,doc/master/TGeoPhysicalNode_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPhysicalNode_8cxx_source.html
https://root.cern/doc/master/TGeoPhysicalNode_8cxx_source.html:18773,Availability,avail,available,18773,"///////////////////////////////////////////////////; 538/// Specify the path for this node.; 539 ; 540Bool_t TGeoPhysicalNode::SetPath(const char *path); 541{; 542 if (!gGeoManager->cd(path)) {; 543 Error(""SetPath"", ""wrong path -> maybe RestoreMasterVolume"");; 544 return kFALSE;; 545 }; 546 SetBranchAsState();; 547 return kTRUE;; 548}; 549 ; 550////////////////////////////////////////////////////////////////////////////////; 551/// Checks if a given navigator state matches this physical node; 552 ; 553Bool_t TGeoPhysicalNode::IsMatchingState(TGeoNavigator *nav) const; 554{; 555 TGeoNodeCache *cache = nav->GetCache();; 556 if (!cache) {; 557 Fatal(""SetBranchAsState"", ""no state available"");; 558 return kFALSE;; 559 }; 560 // the first condition is that the levels of navigator and this physical node must match; 561 if (cache->GetLevel() != fLevel) {; 562 return kFALSE;; 563 }; 564 // now we compare the nodes at each level; 565 // starting backwards since that enhances the probability of an early return; 566 TGeoNode **branch = (TGeoNode **)cache->GetBranch();; 567 for (Int_t i = fLevel; i >= 1; --i); 568 if (fNodes->At(i) != branch[i]); 569 return kFALSE;; 570 return kTRUE;; 571}; 572 ; 573ClassImp(TGeoPNEntry);; 574 ; 575////////////////////////////////////////////////////////////////////////////////; 576/// Default constructor; 577 ; 578TGeoPNEntry::TGeoPNEntry(); 579{; 580 fNode = nullptr;; 581 fMatrix = nullptr;; 582 fGlobalOrig = nullptr;; 583}; 584 ; 585////////////////////////////////////////////////////////////////////////////////; 586/// Default constructor; 587 ; 588TGeoPNEntry::TGeoPNEntry(const char *name, const char *path) : TNamed(name, path); 589{; 590 if (!gGeoManager || !gGeoManager->IsClosed() || !gGeoManager->CheckPath(path)) {; 591 TString errmsg(""Cannot define a physical node link without a closed geometry and a valid path !"");; 592 Error(""ctor"", ""%s"", errmsg.Data());; 593 throw errmsg;; 594 return;; 595 }; 596 gGeoManager->PushPath();; 597 gGeoMana",MatchSource.WIKI,doc/master/TGeoPhysicalNode_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPhysicalNode_8cxx_source.html
https://root.cern/doc/master/TGeoPhysicalNode_8cxx_source.html:34733,Availability,error,error,34733,"ass for all named ROOT classes.Definition TNamed.h:29; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TNamed::fNameTString fNameDefinition TNamed.h:32; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjArray::AddAtvoid AddAt(TObject *obj, Int_t idx) overrideAdd object at position ids.Definition TObjArray.cxx:254; TObjArray::AddAtAndExpandvirtual void AddAtAndExpand(TObject *obj, Int_t idx)Add object at position idx.Definition TObjArray.cxx:235; TObjArray::Deletevoid Delete(Option_t *option="""") overrideRemove all objects from the array AND delete all heap based objects.Definition TObjArray.cxx:356; TObjArray::AtTObject * At(Int_t idx) const overrideDefinition TObjArray.h:164; TObjArray::UncheckedAtTObject * UncheckedAt(Int_t i) constDefinition TObjArray.h:84; TObjArray::RemoveAtTObject * RemoveAt(Int_t idx) overrideRemove object at index idx.Definition TObjArray.cxx:694; TObjArray::Addvoid Add(TObject *obj) overrideDefinition TObjArray.h:68; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; TVirtualGeoPainterAbstract class for geometry painters.Definition TVirtualGeoPainter.h:32; bool; double; int. geomgeomsrcTGeoPhysicalNode.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:14 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TGeoPhysicalNode_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPhysicalNode_8cxx_source.html
https://root.cern/doc/master/TGeoPhysicalNode_8cxx_source.html:34869,Availability,error,error,34869,"ass for all named ROOT classes.Definition TNamed.h:29; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TNamed::fNameTString fNameDefinition TNamed.h:32; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjArray::AddAtvoid AddAt(TObject *obj, Int_t idx) overrideAdd object at position ids.Definition TObjArray.cxx:254; TObjArray::AddAtAndExpandvirtual void AddAtAndExpand(TObject *obj, Int_t idx)Add object at position idx.Definition TObjArray.cxx:235; TObjArray::Deletevoid Delete(Option_t *option="""") overrideRemove all objects from the array AND delete all heap based objects.Definition TObjArray.cxx:356; TObjArray::AtTObject * At(Int_t idx) const overrideDefinition TObjArray.h:164; TObjArray::UncheckedAtTObject * UncheckedAt(Int_t i) constDefinition TObjArray.h:84; TObjArray::RemoveAtTObject * RemoveAt(Int_t idx) overrideRemove object at index idx.Definition TObjArray.cxx:694; TObjArray::Addvoid Add(TObject *obj) overrideDefinition TObjArray.h:68; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; TVirtualGeoPainterAbstract class for geometry painters.Definition TVirtualGeoPainter.h:32; bool; double; int. geomgeomsrcTGeoPhysicalNode.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:14 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TGeoPhysicalNode_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPhysicalNode_8cxx_source.html
https://root.cern/doc/master/TGeoPhysicalNode_8cxx_source.html:10164,Deployability,update,update,10164,"->RemoveAt(i);; 260 vm->GetNodes()->AddAt(newnode, i);; 261 shared = kTRUE;; 262 }; 263 if (!shared); 264 Error(""Align"", ""The matrix replaced for %s is not actually shared"", GetName());; 265 } else {; 266 // The aligned node may have a composite shape containing a shared matrix; 267 if (vd->GetShape()->IsComposite()) {; 268 cs = (TGeoCompositeShape *)vd->GetShape();; 269 if (cs->GetBoolNode()->GetRightMatrix()->IsShared()) {; 270 if (!nnode->GetMatrix()->IsIdentity()) {; 271 Error(""Align"", ""The composite shape having a shared matrix on the subtracted branch must be ""; 272 ""positioned using identity matrix."");; 273 return kFALSE;; 274 }; 275 // We have to put the alignment matrix on top of the left branch; 276 // of the composite shape. The node is already decoupled from logical tree.; 277 TGeoCompositeShape *ncs = new TGeoCompositeShape(cs->GetName(), cs->GetBoolNode()->MakeClone());; 278 TGeoMatrix *oldmat = ncs->GetBoolNode()->GetLeftMatrix();; 279 TGeoHMatrix *newmat1 = new TGeoHMatrix(*newmat);; 280 newmat1->Multiply(oldmat);; 281 ncs->GetBoolNode()->ReplaceMatrix(oldmat, newmat1);; 282 vd->SetShape(ncs);; 283 // The right-side matrix pointer is preserved, so no need to update nodes.; 284 aligned = nullptr; // to prevent updating its matrix; 285 }; 286 }; 287 }; 288 // Register matrix and make it the active one; 289 if (!newmat->IsRegistered()); 290 newmat->RegisterYourself();; 291 if (aligned) {; 292 aligned->SetMatrix(newmat);; 293 // Update the global matrix for the aligned node; 294 TGeoHMatrix *global = GetMatrix();; 295 TGeoHMatrix *up = GetMatrix(fLevel - 1);; 296 *global = up;; 297 global->Multiply(newmat);; 298 }; 299 }; 300 // Change the shape for the aligned node; 301 if (newshape); 302 vd->SetShape(newshape);; 303 ; 304 // Re-compute bounding box of mother(s) if needed; 305 for (i = fLevel - 1; i > 0; i--) {; 306 Bool_t dassm = vd->IsAssembly(); // is daughter assembly ?; 307 vd = GetVolume(i);; 308 if (!vd); 309 break;; 310 Bool_t cassm = vd->IsAsse",MatchSource.WIKI,doc/master/TGeoPhysicalNode_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPhysicalNode_8cxx_source.html
https://root.cern/doc/master/TGeoPhysicalNode_8cxx_source.html:34609,Integrability,message,message,34609,"ass for all named ROOT classes.Definition TNamed.h:29; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TNamed::fNameTString fNameDefinition TNamed.h:32; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjArray::AddAtvoid AddAt(TObject *obj, Int_t idx) overrideAdd object at position ids.Definition TObjArray.cxx:254; TObjArray::AddAtAndExpandvirtual void AddAtAndExpand(TObject *obj, Int_t idx)Add object at position idx.Definition TObjArray.cxx:235; TObjArray::Deletevoid Delete(Option_t *option="""") overrideRemove all objects from the array AND delete all heap based objects.Definition TObjArray.cxx:356; TObjArray::AtTObject * At(Int_t idx) const overrideDefinition TObjArray.h:164; TObjArray::UncheckedAtTObject * UncheckedAt(Int_t i) constDefinition TObjArray.h:84; TObjArray::RemoveAtTObject * RemoveAt(Int_t idx) overrideRemove object at index idx.Definition TObjArray.cxx:694; TObjArray::Addvoid Add(TObject *obj) overrideDefinition TObjArray.h:68; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; TVirtualGeoPainterAbstract class for geometry painters.Definition TVirtualGeoPainter.h:32; bool; double; int. geomgeomsrcTGeoPhysicalNode.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:14 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TGeoPhysicalNode_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPhysicalNode_8cxx_source.html
https://root.cern/doc/master/TGeoPhysicalNode_8cxx_source.html:34739,Integrability,message,message,34739,"ass for all named ROOT classes.Definition TNamed.h:29; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TNamed::fNameTString fNameDefinition TNamed.h:32; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjArray::AddAtvoid AddAt(TObject *obj, Int_t idx) overrideAdd object at position ids.Definition TObjArray.cxx:254; TObjArray::AddAtAndExpandvirtual void AddAtAndExpand(TObject *obj, Int_t idx)Add object at position idx.Definition TObjArray.cxx:235; TObjArray::Deletevoid Delete(Option_t *option="""") overrideRemove all objects from the array AND delete all heap based objects.Definition TObjArray.cxx:356; TObjArray::AtTObject * At(Int_t idx) const overrideDefinition TObjArray.h:164; TObjArray::UncheckedAtTObject * UncheckedAt(Int_t i) constDefinition TObjArray.h:84; TObjArray::RemoveAtTObject * RemoveAt(Int_t idx) overrideRemove object at index idx.Definition TObjArray.cxx:694; TObjArray::Addvoid Add(TObject *obj) overrideDefinition TObjArray.h:68; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; TVirtualGeoPainterAbstract class for geometry painters.Definition TVirtualGeoPainter.h:32; bool; double; int. geomgeomsrcTGeoPhysicalNode.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:14 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TGeoPhysicalNode_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPhysicalNode_8cxx_source.html
https://root.cern/doc/master/TGeoPhysicalNode_8cxx_source.html:34875,Integrability,message,message,34875,"ass for all named ROOT classes.Definition TNamed.h:29; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TNamed::fNameTString fNameDefinition TNamed.h:32; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjArray::AddAtvoid AddAt(TObject *obj, Int_t idx) overrideAdd object at position ids.Definition TObjArray.cxx:254; TObjArray::AddAtAndExpandvirtual void AddAtAndExpand(TObject *obj, Int_t idx)Add object at position idx.Definition TObjArray.cxx:235; TObjArray::Deletevoid Delete(Option_t *option="""") overrideRemove all objects from the array AND delete all heap based objects.Definition TObjArray.cxx:356; TObjArray::AtTObject * At(Int_t idx) const overrideDefinition TObjArray.h:164; TObjArray::UncheckedAtTObject * UncheckedAt(Int_t i) constDefinition TObjArray.h:84; TObjArray::RemoveAtTObject * RemoveAt(Int_t idx) overrideRemove object at index idx.Definition TObjArray.cxx:694; TObjArray::Addvoid Add(TObject *obj) overrideDefinition TObjArray.h:68; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; TVirtualGeoPainterAbstract class for geometry painters.Definition TVirtualGeoPainter.h:32; bool; double; int. geomgeomsrcTGeoPhysicalNode.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:14 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TGeoPhysicalNode_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPhysicalNode_8cxx_source.html
https://root.cern/doc/master/TGeoPhysicalNode_8cxx_source.html:35003,Integrability,message,message,35003,"ass for all named ROOT classes.Definition TNamed.h:29; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TNamed::fNameTString fNameDefinition TNamed.h:32; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjArray::AddAtvoid AddAt(TObject *obj, Int_t idx) overrideAdd object at position ids.Definition TObjArray.cxx:254; TObjArray::AddAtAndExpandvirtual void AddAtAndExpand(TObject *obj, Int_t idx)Add object at position idx.Definition TObjArray.cxx:235; TObjArray::Deletevoid Delete(Option_t *option="""") overrideRemove all objects from the array AND delete all heap based objects.Definition TObjArray.cxx:356; TObjArray::AtTObject * At(Int_t idx) const overrideDefinition TObjArray.h:164; TObjArray::UncheckedAtTObject * UncheckedAt(Int_t i) constDefinition TObjArray.h:84; TObjArray::RemoveAtTObject * RemoveAt(Int_t idx) overrideRemove object at index idx.Definition TObjArray.cxx:694; TObjArray::Addvoid Add(TObject *obj) overrideDefinition TObjArray.h:68; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; TVirtualGeoPainterAbstract class for geometry painters.Definition TVirtualGeoPainter.h:32; bool; double; int. geomgeomsrcTGeoPhysicalNode.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:14 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TGeoPhysicalNode_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPhysicalNode_8cxx_source.html
https://root.cern/doc/master/TGeoPhysicalNode_8cxx_source.html:19059,Modifiability,enhance,enhances,19059,"///////////////////////////////////////////////////; 538/// Specify the path for this node.; 539 ; 540Bool_t TGeoPhysicalNode::SetPath(const char *path); 541{; 542 if (!gGeoManager->cd(path)) {; 543 Error(""SetPath"", ""wrong path -> maybe RestoreMasterVolume"");; 544 return kFALSE;; 545 }; 546 SetBranchAsState();; 547 return kTRUE;; 548}; 549 ; 550////////////////////////////////////////////////////////////////////////////////; 551/// Checks if a given navigator state matches this physical node; 552 ; 553Bool_t TGeoPhysicalNode::IsMatchingState(TGeoNavigator *nav) const; 554{; 555 TGeoNodeCache *cache = nav->GetCache();; 556 if (!cache) {; 557 Fatal(""SetBranchAsState"", ""no state available"");; 558 return kFALSE;; 559 }; 560 // the first condition is that the levels of navigator and this physical node must match; 561 if (cache->GetLevel() != fLevel) {; 562 return kFALSE;; 563 }; 564 // now we compare the nodes at each level; 565 // starting backwards since that enhances the probability of an early return; 566 TGeoNode **branch = (TGeoNode **)cache->GetBranch();; 567 for (Int_t i = fLevel; i >= 1; --i); 568 if (fNodes->At(i) != branch[i]); 569 return kFALSE;; 570 return kTRUE;; 571}; 572 ; 573ClassImp(TGeoPNEntry);; 574 ; 575////////////////////////////////////////////////////////////////////////////////; 576/// Default constructor; 577 ; 578TGeoPNEntry::TGeoPNEntry(); 579{; 580 fNode = nullptr;; 581 fMatrix = nullptr;; 582 fGlobalOrig = nullptr;; 583}; 584 ; 585////////////////////////////////////////////////////////////////////////////////; 586/// Default constructor; 587 ; 588TGeoPNEntry::TGeoPNEntry(const char *name, const char *path) : TNamed(name, path); 589{; 590 if (!gGeoManager || !gGeoManager->IsClosed() || !gGeoManager->CheckPath(path)) {; 591 TString errmsg(""Cannot define a physical node link without a closed geometry and a valid path !"");; 592 Error(""ctor"", ""%s"", errmsg.Data());; 593 throw errmsg;; 594 return;; 595 }; 596 gGeoManager->PushPath();; 597 gGeoMana",MatchSource.WIKI,doc/master/TGeoPhysicalNode_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPhysicalNode_8cxx_source.html
https://root.cern/doc/master/TGeoPhysicalNode_8cxx_source.html:4260,Performance,perform,perform,4260,"t char *path) : TNamed(path, """"); 93{; 94 if (!path[0]) {; 95 Error(""ctor"", ""path not valid"");; 96 return;; 97 }; 98 fLevel = 0;; 99 fMatrices = new TObjArray(30);; 100 fNodes = new TObjArray(30);; 101 fMatrixOrig = nullptr;; 102 SetPath(path);; 103 SetVisibility(kTRUE);; 104 SetVisibleFull(kFALSE);; 105 SetIsVolAtt(kTRUE);; 106 SetAligned(kFALSE);; 107}; 108 ; 109////////////////////////////////////////////////////////////////////////////////; 110/// Destructor; 111 ; 112TGeoPhysicalNode::~TGeoPhysicalNode(); 113{; 114 if (fMatrices) {; 115 fMatrices->Delete();; 116 delete fMatrices;; 117 }; 118 if (fNodes); 119 delete fNodes;; 120 if (fMatrixOrig); 121 delete fMatrixOrig;; 122}; 123 ; 124////////////////////////////////////////////////////////////////////////////////; 125/// Align a physical node with a new relative matrix/shape.; 126/// Example: /TOP_1/A_1/B_1/C_1; 127/// node->Align(transl_1, box) will perform:; 128/// - change RELATIVE translation of C_1 node (with respect to its; 129/// container volume B) to transl_1; 130/// - change the shape of the C volume; 131/// *NOTE* The operations will affect ONLY the LAST node in the branch. All; 132/// volumes/nodes in the branch represented by this physical node are; 133/// CLONED so the operation does not affect other possible replicas.; 134 ; 135Bool_t TGeoPhysicalNode::Align(TGeoMatrix *newmat, TGeoShape *newshape, Bool_t check, Double_t ovlp); 136{; 137 if (!newmat && !newshape); 138 return kFALSE;; 139 if (TGeoManager::IsLocked()) {; 140 Error(""Align"", ""Not performed. Geometry in LOCKED mode !"");; 141 return kFALSE;; 142 }; 143 if (newmat == gGeoIdentity) {; 144 Error(""Align"", ""Cannot align using gGeoIdentity. Use some default matrix constructor to represent identities."");; 145 return kFALSE;; 146 }; 147 TGeoNode *node = GetNode();; 148 if (node->IsOffset()) {; 149 Error(""Align"", ""Cannot align division nodes: %s\n"", node->GetName());; 150 return kFALSE;; 151 }; 152 // Refresh the node since other Align calls ma",MatchSource.WIKI,doc/master/TGeoPhysicalNode_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPhysicalNode_8cxx_source.html
https://root.cern/doc/master/TGeoPhysicalNode_8cxx_source.html:4879,Performance,perform,performed,4879,"//////////////////; 110/// Destructor; 111 ; 112TGeoPhysicalNode::~TGeoPhysicalNode(); 113{; 114 if (fMatrices) {; 115 fMatrices->Delete();; 116 delete fMatrices;; 117 }; 118 if (fNodes); 119 delete fNodes;; 120 if (fMatrixOrig); 121 delete fMatrixOrig;; 122}; 123 ; 124////////////////////////////////////////////////////////////////////////////////; 125/// Align a physical node with a new relative matrix/shape.; 126/// Example: /TOP_1/A_1/B_1/C_1; 127/// node->Align(transl_1, box) will perform:; 128/// - change RELATIVE translation of C_1 node (with respect to its; 129/// container volume B) to transl_1; 130/// - change the shape of the C volume; 131/// *NOTE* The operations will affect ONLY the LAST node in the branch. All; 132/// volumes/nodes in the branch represented by this physical node are; 133/// CLONED so the operation does not affect other possible replicas.; 134 ; 135Bool_t TGeoPhysicalNode::Align(TGeoMatrix *newmat, TGeoShape *newshape, Bool_t check, Double_t ovlp); 136{; 137 if (!newmat && !newshape); 138 return kFALSE;; 139 if (TGeoManager::IsLocked()) {; 140 Error(""Align"", ""Not performed. Geometry in LOCKED mode !"");; 141 return kFALSE;; 142 }; 143 if (newmat == gGeoIdentity) {; 144 Error(""Align"", ""Cannot align using gGeoIdentity. Use some default matrix constructor to represent identities."");; 145 return kFALSE;; 146 }; 147 TGeoNode *node = GetNode();; 148 if (node->IsOffset()) {; 149 Error(""Align"", ""Cannot align division nodes: %s\n"", node->GetName());; 150 return kFALSE;; 151 }; 152 // Refresh the node since other Align calls may have altered the stored nodes; 153 Refresh();; 154 TGeoNode *nnode = nullptr;; 155 TGeoVolume *vm = GetVolume(0);; 156 TGeoVolume *vd = nullptr;; 157 Int_t i;; 158 if (!IsAligned()) {; 159 Int_t *id = new Int_t[fLevel];; 160 for (i = 0; i < fLevel; i++) {; 161 // Store daughter indexes; 162 vd = GetVolume(i);; 163 node = GetNode(i + 1);; 164 id[i] = vd->GetIndex(node);; 165 if (id[i] < 0) {; 166 Error(""Align"", ""%s cannot a",MatchSource.WIKI,doc/master/TGeoPhysicalNode_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPhysicalNode_8cxx_source.html
https://root.cern/doc/master/TGeoPhysicalNode_8cxx_source.html:11719,Performance,perform,performed,11719,";; 303 ; 304 // Re-compute bounding box of mother(s) if needed; 305 for (i = fLevel - 1; i > 0; i--) {; 306 Bool_t dassm = vd->IsAssembly(); // is daughter assembly ?; 307 vd = GetVolume(i);; 308 if (!vd); 309 break;; 310 Bool_t cassm = vd->IsAssembly(); // is current assembly ?; 311 if (cassm); 312 ((TGeoShapeAssembly *)vd->GetShape())->NeedsBBoxRecompute();; 313 if ((cassm || dassm) && vd->GetVoxels()); 314 vd->GetVoxels()->SetNeedRebuild();; 315 if (!cassm); 316 break;; 317 }; 318 ; 319 // Now we have to re-voxelize the mother volume; 320 TGeoVoxelFinder *voxels = vm->GetVoxels();; 321 if (voxels); 322 voxels->SetNeedRebuild();; 323 // Eventually check for overlaps; 324 if (check) {; 325 if (voxels) {; 326 voxels->Voxelize();; 327 vm->FindOverlaps();; 328 }; 329 // Set aligned node to be checked; 330 i = fLevel;; 331 node = GetNode(i);; 332 if (!node); 333 return kTRUE;; 334 if (node->IsOverlapping()) {; 335 Info(""Align"",; 336 ""The check for overlaps for node: \n%s\n cannot be performed since the node is declared possibly ""; 337 ""overlapping"",; 338 GetName());; 339 } else {; 340 gGeoManager->SetCheckedNode(node);; 341 // Check overlaps for the first non-assembly parent node; 342 while ((node = GetNode(--i))) {; 343 if (!node->GetVolume()->IsAssembly()); 344 break;; 345 }; 346 if (node && node->IsOverlapping()) {; 347 Info(""Align"",; 348 ""The check for overlaps for assembly node: \n%s\n cannot be performed since the parent %s is declared ""; 349 ""possibly overlapping"",; 350 GetName(), node->GetName());; 351 node = nullptr;; 352 }; 353 if (node); 354 node->CheckOverlaps(ovlp);; 355 gGeoManager->SetCheckedNode(nullptr);; 356 }; 357 }; 358 // Clean current matrices from cache; 359 gGeoManager->CdTop();; 360 SetAligned(kTRUE);; 361 return kTRUE;; 362}; 363 ; 364////////////////////////////////////////////////////////////////////////////////; 365 ; 366void TGeoPhysicalNode::cd() const; 367{; 368 if (GetNode(0) != gGeoManager->GetTopNode()); 369 return;; 370 gGeoManager->",MatchSource.WIKI,doc/master/TGeoPhysicalNode_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPhysicalNode_8cxx_source.html
https://root.cern/doc/master/TGeoPhysicalNode_8cxx_source.html:12145,Performance,perform,performed,12145," 304 // Re-compute bounding box of mother(s) if needed; 305 for (i = fLevel - 1; i > 0; i--) {; 306 Bool_t dassm = vd->IsAssembly(); // is daughter assembly ?; 307 vd = GetVolume(i);; 308 if (!vd); 309 break;; 310 Bool_t cassm = vd->IsAssembly(); // is current assembly ?; 311 if (cassm); 312 ((TGeoShapeAssembly *)vd->GetShape())->NeedsBBoxRecompute();; 313 if ((cassm || dassm) && vd->GetVoxels()); 314 vd->GetVoxels()->SetNeedRebuild();; 315 if (!cassm); 316 break;; 317 }; 318 ; 319 // Now we have to re-voxelize the mother volume; 320 TGeoVoxelFinder *voxels = vm->GetVoxels();; 321 if (voxels); 322 voxels->SetNeedRebuild();; 323 // Eventually check for overlaps; 324 if (check) {; 325 if (voxels) {; 326 voxels->Voxelize();; 327 vm->FindOverlaps();; 328 }; 329 // Set aligned node to be checked; 330 i = fLevel;; 331 node = GetNode(i);; 332 if (!node); 333 return kTRUE;; 334 if (node->IsOverlapping()) {; 335 Info(""Align"",; 336 ""The check for overlaps for node: \n%s\n cannot be performed since the node is declared possibly ""; 337 ""overlapping"",; 338 GetName());; 339 } else {; 340 gGeoManager->SetCheckedNode(node);; 341 // Check overlaps for the first non-assembly parent node; 342 while ((node = GetNode(--i))) {; 343 if (!node->GetVolume()->IsAssembly()); 344 break;; 345 }; 346 if (node && node->IsOverlapping()) {; 347 Info(""Align"",; 348 ""The check for overlaps for assembly node: \n%s\n cannot be performed since the parent %s is declared ""; 349 ""possibly overlapping"",; 350 GetName(), node->GetName());; 351 node = nullptr;; 352 }; 353 if (node); 354 node->CheckOverlaps(ovlp);; 355 gGeoManager->SetCheckedNode(nullptr);; 356 }; 357 }; 358 // Clean current matrices from cache; 359 gGeoManager->CdTop();; 360 SetAligned(kTRUE);; 361 return kTRUE;; 362}; 363 ; 364////////////////////////////////////////////////////////////////////////////////; 365 ; 366void TGeoPhysicalNode::cd() const; 367{; 368 if (GetNode(0) != gGeoManager->GetTopNode()); 369 return;; 370 gGeoManager->cd(fName.",MatchSource.WIKI,doc/master/TGeoPhysicalNode_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPhysicalNode_8cxx_source.html
https://root.cern/doc/master/TGeoPhysicalNode_8cxx_source.html:12420,Performance,cache,cache,12420," 304 // Re-compute bounding box of mother(s) if needed; 305 for (i = fLevel - 1; i > 0; i--) {; 306 Bool_t dassm = vd->IsAssembly(); // is daughter assembly ?; 307 vd = GetVolume(i);; 308 if (!vd); 309 break;; 310 Bool_t cassm = vd->IsAssembly(); // is current assembly ?; 311 if (cassm); 312 ((TGeoShapeAssembly *)vd->GetShape())->NeedsBBoxRecompute();; 313 if ((cassm || dassm) && vd->GetVoxels()); 314 vd->GetVoxels()->SetNeedRebuild();; 315 if (!cassm); 316 break;; 317 }; 318 ; 319 // Now we have to re-voxelize the mother volume; 320 TGeoVoxelFinder *voxels = vm->GetVoxels();; 321 if (voxels); 322 voxels->SetNeedRebuild();; 323 // Eventually check for overlaps; 324 if (check) {; 325 if (voxels) {; 326 voxels->Voxelize();; 327 vm->FindOverlaps();; 328 }; 329 // Set aligned node to be checked; 330 i = fLevel;; 331 node = GetNode(i);; 332 if (!node); 333 return kTRUE;; 334 if (node->IsOverlapping()) {; 335 Info(""Align"",; 336 ""The check for overlaps for node: \n%s\n cannot be performed since the node is declared possibly ""; 337 ""overlapping"",; 338 GetName());; 339 } else {; 340 gGeoManager->SetCheckedNode(node);; 341 // Check overlaps for the first non-assembly parent node; 342 while ((node = GetNode(--i))) {; 343 if (!node->GetVolume()->IsAssembly()); 344 break;; 345 }; 346 if (node && node->IsOverlapping()) {; 347 Info(""Align"",; 348 ""The check for overlaps for assembly node: \n%s\n cannot be performed since the parent %s is declared ""; 349 ""possibly overlapping"",; 350 GetName(), node->GetName());; 351 node = nullptr;; 352 }; 353 if (node); 354 node->CheckOverlaps(ovlp);; 355 gGeoManager->SetCheckedNode(nullptr);; 356 }; 357 }; 358 // Clean current matrices from cache; 359 gGeoManager->CdTop();; 360 SetAligned(kTRUE);; 361 return kTRUE;; 362}; 363 ; 364////////////////////////////////////////////////////////////////////////////////; 365 ; 366void TGeoPhysicalNode::cd() const; 367{; 368 if (GetNode(0) != gGeoManager->GetTopNode()); 369 return;; 370 gGeoManager->cd(fName.",MatchSource.WIKI,doc/master/TGeoPhysicalNode_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPhysicalNode_8cxx_source.html
https://root.cern/doc/master/TGeoPhysicalNode_8cxx_source.html:16451,Performance,cache,cache,16451,"//////////////////////////; 472/// Refresh this physical node. Called for all registered physical nodes; 473/// after an Align() call.; 474 ; 475void TGeoPhysicalNode::Refresh(); 476{; 477 SetPath(fName.Data());; 478}; 479 ; 480////////////////////////////////////////////////////////////////////////////////; 481/// Set node branch according to current state; 482 ; 483void TGeoPhysicalNode::SetBranchAsState(); 484{; 485 TGeoNodeCache *cache = gGeoManager->GetCache();; 486 if (!cache) {; 487 Error(""SetBranchAsState"", ""no state available"");; 488 return;; 489 }; 490 if (!cache->IsDummy()) {; 491 Error(""SetBranchAsState"", ""not implemented for full cache"");; 492 return;; 493 }; 494 if (!fNodes); 495 fNodes = new TObjArray(30);; 496 if (!fMatrices); 497 fMatrices = new TObjArray(30);; 498 TGeoHMatrix **matrices = (TGeoHMatrix **)cache->GetMatrices();; 499 TGeoNode **branch = (TGeoNode **)cache->GetBranch();; 500 ; 501 Bool_t refresh = (fLevel > 0) ? kTRUE : kFALSE;; 502 if (refresh) {; 503 TGeoHMatrix *current;; 504 for (Int_t i = 0; i <= fLevel; i++) {; 505 fNodes->AddAtAndExpand(branch[i], i);; 506 current = (TGeoHMatrix *)fMatrices->UncheckedAt(i);; 507 *current = *matrices[i];; 508 }; 509 return;; 510 }; 511 fLevel = gGeoManager->GetLevel();; 512 for (Int_t i = 0; i <= fLevel; i++) {; 513 fNodes->AddAtAndExpand(branch[i], i);; 514 fMatrices->AddAtAndExpand(new TGeoHMatrix(*matrices[i]), i);; 515 }; 516 TGeoNode *node = (TGeoNode *)fNodes->UncheckedAt(fLevel);; 517 if (!fMatrixOrig); 518 fMatrixOrig = new TGeoHMatrix();; 519 *fMatrixOrig = node->GetMatrix();; 520}; 521 ; 522////////////////////////////////////////////////////////////////////////////////; 523/// Allows PN entries (or users) to preset the local original matrix for the; 524/// last node pointed by the path.; 525 ; 526void TGeoPhysicalNode::SetMatrixOrig(const TGeoMatrix *local); 527{; 528 if (!fMatrixOrig); 529 fMatrixOrig = new TGeoHMatrix();; 530 if (!local) {; 531 fMatrixOrig->Clear();; 532 return;; 533",MatchSource.WIKI,doc/master/TGeoPhysicalNode_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPhysicalNode_8cxx_source.html
https://root.cern/doc/master/TGeoPhysicalNode_8cxx_source.html:16494,Performance,cache,cache,16494,"//////////////////////////; 472/// Refresh this physical node. Called for all registered physical nodes; 473/// after an Align() call.; 474 ; 475void TGeoPhysicalNode::Refresh(); 476{; 477 SetPath(fName.Data());; 478}; 479 ; 480////////////////////////////////////////////////////////////////////////////////; 481/// Set node branch according to current state; 482 ; 483void TGeoPhysicalNode::SetBranchAsState(); 484{; 485 TGeoNodeCache *cache = gGeoManager->GetCache();; 486 if (!cache) {; 487 Error(""SetBranchAsState"", ""no state available"");; 488 return;; 489 }; 490 if (!cache->IsDummy()) {; 491 Error(""SetBranchAsState"", ""not implemented for full cache"");; 492 return;; 493 }; 494 if (!fNodes); 495 fNodes = new TObjArray(30);; 496 if (!fMatrices); 497 fMatrices = new TObjArray(30);; 498 TGeoHMatrix **matrices = (TGeoHMatrix **)cache->GetMatrices();; 499 TGeoNode **branch = (TGeoNode **)cache->GetBranch();; 500 ; 501 Bool_t refresh = (fLevel > 0) ? kTRUE : kFALSE;; 502 if (refresh) {; 503 TGeoHMatrix *current;; 504 for (Int_t i = 0; i <= fLevel; i++) {; 505 fNodes->AddAtAndExpand(branch[i], i);; 506 current = (TGeoHMatrix *)fMatrices->UncheckedAt(i);; 507 *current = *matrices[i];; 508 }; 509 return;; 510 }; 511 fLevel = gGeoManager->GetLevel();; 512 for (Int_t i = 0; i <= fLevel; i++) {; 513 fNodes->AddAtAndExpand(branch[i], i);; 514 fMatrices->AddAtAndExpand(new TGeoHMatrix(*matrices[i]), i);; 515 }; 516 TGeoNode *node = (TGeoNode *)fNodes->UncheckedAt(fLevel);; 517 if (!fMatrixOrig); 518 fMatrixOrig = new TGeoHMatrix();; 519 *fMatrixOrig = node->GetMatrix();; 520}; 521 ; 522////////////////////////////////////////////////////////////////////////////////; 523/// Allows PN entries (or users) to preset the local original matrix for the; 524/// last node pointed by the path.; 525 ; 526void TGeoPhysicalNode::SetMatrixOrig(const TGeoMatrix *local); 527{; 528 if (!fMatrixOrig); 529 fMatrixOrig = new TGeoHMatrix();; 530 if (!local) {; 531 fMatrixOrig->Clear();; 532 return;; 533",MatchSource.WIKI,doc/master/TGeoPhysicalNode_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPhysicalNode_8cxx_source.html
https://root.cern/doc/master/TGeoPhysicalNode_8cxx_source.html:16587,Performance,cache,cache,16587,"//////////////////////////; 472/// Refresh this physical node. Called for all registered physical nodes; 473/// after an Align() call.; 474 ; 475void TGeoPhysicalNode::Refresh(); 476{; 477 SetPath(fName.Data());; 478}; 479 ; 480////////////////////////////////////////////////////////////////////////////////; 481/// Set node branch according to current state; 482 ; 483void TGeoPhysicalNode::SetBranchAsState(); 484{; 485 TGeoNodeCache *cache = gGeoManager->GetCache();; 486 if (!cache) {; 487 Error(""SetBranchAsState"", ""no state available"");; 488 return;; 489 }; 490 if (!cache->IsDummy()) {; 491 Error(""SetBranchAsState"", ""not implemented for full cache"");; 492 return;; 493 }; 494 if (!fNodes); 495 fNodes = new TObjArray(30);; 496 if (!fMatrices); 497 fMatrices = new TObjArray(30);; 498 TGeoHMatrix **matrices = (TGeoHMatrix **)cache->GetMatrices();; 499 TGeoNode **branch = (TGeoNode **)cache->GetBranch();; 500 ; 501 Bool_t refresh = (fLevel > 0) ? kTRUE : kFALSE;; 502 if (refresh) {; 503 TGeoHMatrix *current;; 504 for (Int_t i = 0; i <= fLevel; i++) {; 505 fNodes->AddAtAndExpand(branch[i], i);; 506 current = (TGeoHMatrix *)fMatrices->UncheckedAt(i);; 507 *current = *matrices[i];; 508 }; 509 return;; 510 }; 511 fLevel = gGeoManager->GetLevel();; 512 for (Int_t i = 0; i <= fLevel; i++) {; 513 fNodes->AddAtAndExpand(branch[i], i);; 514 fMatrices->AddAtAndExpand(new TGeoHMatrix(*matrices[i]), i);; 515 }; 516 TGeoNode *node = (TGeoNode *)fNodes->UncheckedAt(fLevel);; 517 if (!fMatrixOrig); 518 fMatrixOrig = new TGeoHMatrix();; 519 *fMatrixOrig = node->GetMatrix();; 520}; 521 ; 522////////////////////////////////////////////////////////////////////////////////; 523/// Allows PN entries (or users) to preset the local original matrix for the; 524/// last node pointed by the path.; 525 ; 526void TGeoPhysicalNode::SetMatrixOrig(const TGeoMatrix *local); 527{; 528 if (!fMatrixOrig); 529 fMatrixOrig = new TGeoHMatrix();; 530 if (!local) {; 531 fMatrixOrig->Clear();; 532 return;; 533",MatchSource.WIKI,doc/master/TGeoPhysicalNode_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPhysicalNode_8cxx_source.html
https://root.cern/doc/master/TGeoPhysicalNode_8cxx_source.html:16664,Performance,cache,cache,16664,"//////////////////////////; 472/// Refresh this physical node. Called for all registered physical nodes; 473/// after an Align() call.; 474 ; 475void TGeoPhysicalNode::Refresh(); 476{; 477 SetPath(fName.Data());; 478}; 479 ; 480////////////////////////////////////////////////////////////////////////////////; 481/// Set node branch according to current state; 482 ; 483void TGeoPhysicalNode::SetBranchAsState(); 484{; 485 TGeoNodeCache *cache = gGeoManager->GetCache();; 486 if (!cache) {; 487 Error(""SetBranchAsState"", ""no state available"");; 488 return;; 489 }; 490 if (!cache->IsDummy()) {; 491 Error(""SetBranchAsState"", ""not implemented for full cache"");; 492 return;; 493 }; 494 if (!fNodes); 495 fNodes = new TObjArray(30);; 496 if (!fMatrices); 497 fMatrices = new TObjArray(30);; 498 TGeoHMatrix **matrices = (TGeoHMatrix **)cache->GetMatrices();; 499 TGeoNode **branch = (TGeoNode **)cache->GetBranch();; 500 ; 501 Bool_t refresh = (fLevel > 0) ? kTRUE : kFALSE;; 502 if (refresh) {; 503 TGeoHMatrix *current;; 504 for (Int_t i = 0; i <= fLevel; i++) {; 505 fNodes->AddAtAndExpand(branch[i], i);; 506 current = (TGeoHMatrix *)fMatrices->UncheckedAt(i);; 507 *current = *matrices[i];; 508 }; 509 return;; 510 }; 511 fLevel = gGeoManager->GetLevel();; 512 for (Int_t i = 0; i <= fLevel; i++) {; 513 fNodes->AddAtAndExpand(branch[i], i);; 514 fMatrices->AddAtAndExpand(new TGeoHMatrix(*matrices[i]), i);; 515 }; 516 TGeoNode *node = (TGeoNode *)fNodes->UncheckedAt(fLevel);; 517 if (!fMatrixOrig); 518 fMatrixOrig = new TGeoHMatrix();; 519 *fMatrixOrig = node->GetMatrix();; 520}; 521 ; 522////////////////////////////////////////////////////////////////////////////////; 523/// Allows PN entries (or users) to preset the local original matrix for the; 524/// last node pointed by the path.; 525 ; 526void TGeoPhysicalNode::SetMatrixOrig(const TGeoMatrix *local); 527{; 528 if (!fMatrixOrig); 529 fMatrixOrig = new TGeoHMatrix();; 530 if (!local) {; 531 fMatrixOrig->Clear();; 532 return;; 533",MatchSource.WIKI,doc/master/TGeoPhysicalNode_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPhysicalNode_8cxx_source.html
https://root.cern/doc/master/TGeoPhysicalNode_8cxx_source.html:16847,Performance,cache,cache,16847,"//////////////////////////; 472/// Refresh this physical node. Called for all registered physical nodes; 473/// after an Align() call.; 474 ; 475void TGeoPhysicalNode::Refresh(); 476{; 477 SetPath(fName.Data());; 478}; 479 ; 480////////////////////////////////////////////////////////////////////////////////; 481/// Set node branch according to current state; 482 ; 483void TGeoPhysicalNode::SetBranchAsState(); 484{; 485 TGeoNodeCache *cache = gGeoManager->GetCache();; 486 if (!cache) {; 487 Error(""SetBranchAsState"", ""no state available"");; 488 return;; 489 }; 490 if (!cache->IsDummy()) {; 491 Error(""SetBranchAsState"", ""not implemented for full cache"");; 492 return;; 493 }; 494 if (!fNodes); 495 fNodes = new TObjArray(30);; 496 if (!fMatrices); 497 fMatrices = new TObjArray(30);; 498 TGeoHMatrix **matrices = (TGeoHMatrix **)cache->GetMatrices();; 499 TGeoNode **branch = (TGeoNode **)cache->GetBranch();; 500 ; 501 Bool_t refresh = (fLevel > 0) ? kTRUE : kFALSE;; 502 if (refresh) {; 503 TGeoHMatrix *current;; 504 for (Int_t i = 0; i <= fLevel; i++) {; 505 fNodes->AddAtAndExpand(branch[i], i);; 506 current = (TGeoHMatrix *)fMatrices->UncheckedAt(i);; 507 *current = *matrices[i];; 508 }; 509 return;; 510 }; 511 fLevel = gGeoManager->GetLevel();; 512 for (Int_t i = 0; i <= fLevel; i++) {; 513 fNodes->AddAtAndExpand(branch[i], i);; 514 fMatrices->AddAtAndExpand(new TGeoHMatrix(*matrices[i]), i);; 515 }; 516 TGeoNode *node = (TGeoNode *)fNodes->UncheckedAt(fLevel);; 517 if (!fMatrixOrig); 518 fMatrixOrig = new TGeoHMatrix();; 519 *fMatrixOrig = node->GetMatrix();; 520}; 521 ; 522////////////////////////////////////////////////////////////////////////////////; 523/// Allows PN entries (or users) to preset the local original matrix for the; 524/// last node pointed by the path.; 525 ; 526void TGeoPhysicalNode::SetMatrixOrig(const TGeoMatrix *local); 527{; 528 if (!fMatrixOrig); 529 fMatrixOrig = new TGeoHMatrix();; 530 if (!local) {; 531 fMatrixOrig->Clear();; 532 return;; 533",MatchSource.WIKI,doc/master/TGeoPhysicalNode_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPhysicalNode_8cxx_source.html
https://root.cern/doc/master/TGeoPhysicalNode_8cxx_source.html:16907,Performance,cache,cache,16907,"//////////////////////////; 472/// Refresh this physical node. Called for all registered physical nodes; 473/// after an Align() call.; 474 ; 475void TGeoPhysicalNode::Refresh(); 476{; 477 SetPath(fName.Data());; 478}; 479 ; 480////////////////////////////////////////////////////////////////////////////////; 481/// Set node branch according to current state; 482 ; 483void TGeoPhysicalNode::SetBranchAsState(); 484{; 485 TGeoNodeCache *cache = gGeoManager->GetCache();; 486 if (!cache) {; 487 Error(""SetBranchAsState"", ""no state available"");; 488 return;; 489 }; 490 if (!cache->IsDummy()) {; 491 Error(""SetBranchAsState"", ""not implemented for full cache"");; 492 return;; 493 }; 494 if (!fNodes); 495 fNodes = new TObjArray(30);; 496 if (!fMatrices); 497 fMatrices = new TObjArray(30);; 498 TGeoHMatrix **matrices = (TGeoHMatrix **)cache->GetMatrices();; 499 TGeoNode **branch = (TGeoNode **)cache->GetBranch();; 500 ; 501 Bool_t refresh = (fLevel > 0) ? kTRUE : kFALSE;; 502 if (refresh) {; 503 TGeoHMatrix *current;; 504 for (Int_t i = 0; i <= fLevel; i++) {; 505 fNodes->AddAtAndExpand(branch[i], i);; 506 current = (TGeoHMatrix *)fMatrices->UncheckedAt(i);; 507 *current = *matrices[i];; 508 }; 509 return;; 510 }; 511 fLevel = gGeoManager->GetLevel();; 512 for (Int_t i = 0; i <= fLevel; i++) {; 513 fNodes->AddAtAndExpand(branch[i], i);; 514 fMatrices->AddAtAndExpand(new TGeoHMatrix(*matrices[i]), i);; 515 }; 516 TGeoNode *node = (TGeoNode *)fNodes->UncheckedAt(fLevel);; 517 if (!fMatrixOrig); 518 fMatrixOrig = new TGeoHMatrix();; 519 *fMatrixOrig = node->GetMatrix();; 520}; 521 ; 522////////////////////////////////////////////////////////////////////////////////; 523/// Allows PN entries (or users) to preset the local original matrix for the; 524/// last node pointed by the path.; 525 ; 526void TGeoPhysicalNode::SetMatrixOrig(const TGeoMatrix *local); 527{; 528 if (!fMatrixOrig); 529 fMatrixOrig = new TGeoHMatrix();; 530 if (!local) {; 531 fMatrixOrig->Clear();; 532 return;; 533",MatchSource.WIKI,doc/master/TGeoPhysicalNode_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPhysicalNode_8cxx_source.html
https://root.cern/doc/master/TGeoPhysicalNode_8cxx_source.html:18688,Performance,cache,cache,18688,"///////////////////////////////////////////////////; 538/// Specify the path for this node.; 539 ; 540Bool_t TGeoPhysicalNode::SetPath(const char *path); 541{; 542 if (!gGeoManager->cd(path)) {; 543 Error(""SetPath"", ""wrong path -> maybe RestoreMasterVolume"");; 544 return kFALSE;; 545 }; 546 SetBranchAsState();; 547 return kTRUE;; 548}; 549 ; 550////////////////////////////////////////////////////////////////////////////////; 551/// Checks if a given navigator state matches this physical node; 552 ; 553Bool_t TGeoPhysicalNode::IsMatchingState(TGeoNavigator *nav) const; 554{; 555 TGeoNodeCache *cache = nav->GetCache();; 556 if (!cache) {; 557 Fatal(""SetBranchAsState"", ""no state available"");; 558 return kFALSE;; 559 }; 560 // the first condition is that the levels of navigator and this physical node must match; 561 if (cache->GetLevel() != fLevel) {; 562 return kFALSE;; 563 }; 564 // now we compare the nodes at each level; 565 // starting backwards since that enhances the probability of an early return; 566 TGeoNode **branch = (TGeoNode **)cache->GetBranch();; 567 for (Int_t i = fLevel; i >= 1; --i); 568 if (fNodes->At(i) != branch[i]); 569 return kFALSE;; 570 return kTRUE;; 571}; 572 ; 573ClassImp(TGeoPNEntry);; 574 ; 575////////////////////////////////////////////////////////////////////////////////; 576/// Default constructor; 577 ; 578TGeoPNEntry::TGeoPNEntry(); 579{; 580 fNode = nullptr;; 581 fMatrix = nullptr;; 582 fGlobalOrig = nullptr;; 583}; 584 ; 585////////////////////////////////////////////////////////////////////////////////; 586/// Default constructor; 587 ; 588TGeoPNEntry::TGeoPNEntry(const char *name, const char *path) : TNamed(name, path); 589{; 590 if (!gGeoManager || !gGeoManager->IsClosed() || !gGeoManager->CheckPath(path)) {; 591 TString errmsg(""Cannot define a physical node link without a closed geometry and a valid path !"");; 592 Error(""ctor"", ""%s"", errmsg.Data());; 593 throw errmsg;; 594 return;; 595 }; 596 gGeoManager->PushPath();; 597 gGeoMana",MatchSource.WIKI,doc/master/TGeoPhysicalNode_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPhysicalNode_8cxx_source.html
https://root.cern/doc/master/TGeoPhysicalNode_8cxx_source.html:18723,Performance,cache,cache,18723,"///////////////////////////////////////////////////; 538/// Specify the path for this node.; 539 ; 540Bool_t TGeoPhysicalNode::SetPath(const char *path); 541{; 542 if (!gGeoManager->cd(path)) {; 543 Error(""SetPath"", ""wrong path -> maybe RestoreMasterVolume"");; 544 return kFALSE;; 545 }; 546 SetBranchAsState();; 547 return kTRUE;; 548}; 549 ; 550////////////////////////////////////////////////////////////////////////////////; 551/// Checks if a given navigator state matches this physical node; 552 ; 553Bool_t TGeoPhysicalNode::IsMatchingState(TGeoNavigator *nav) const; 554{; 555 TGeoNodeCache *cache = nav->GetCache();; 556 if (!cache) {; 557 Fatal(""SetBranchAsState"", ""no state available"");; 558 return kFALSE;; 559 }; 560 // the first condition is that the levels of navigator and this physical node must match; 561 if (cache->GetLevel() != fLevel) {; 562 return kFALSE;; 563 }; 564 // now we compare the nodes at each level; 565 // starting backwards since that enhances the probability of an early return; 566 TGeoNode **branch = (TGeoNode **)cache->GetBranch();; 567 for (Int_t i = fLevel; i >= 1; --i); 568 if (fNodes->At(i) != branch[i]); 569 return kFALSE;; 570 return kTRUE;; 571}; 572 ; 573ClassImp(TGeoPNEntry);; 574 ; 575////////////////////////////////////////////////////////////////////////////////; 576/// Default constructor; 577 ; 578TGeoPNEntry::TGeoPNEntry(); 579{; 580 fNode = nullptr;; 581 fMatrix = nullptr;; 582 fGlobalOrig = nullptr;; 583}; 584 ; 585////////////////////////////////////////////////////////////////////////////////; 586/// Default constructor; 587 ; 588TGeoPNEntry::TGeoPNEntry(const char *name, const char *path) : TNamed(name, path); 589{; 590 if (!gGeoManager || !gGeoManager->IsClosed() || !gGeoManager->CheckPath(path)) {; 591 TString errmsg(""Cannot define a physical node link without a closed geometry and a valid path !"");; 592 Error(""ctor"", ""%s"", errmsg.Data());; 593 throw errmsg;; 594 return;; 595 }; 596 gGeoManager->PushPath();; 597 gGeoMana",MatchSource.WIKI,doc/master/TGeoPhysicalNode_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPhysicalNode_8cxx_source.html
https://root.cern/doc/master/TGeoPhysicalNode_8cxx_source.html:18916,Performance,cache,cache,18916,"///////////////////////////////////////////////////; 538/// Specify the path for this node.; 539 ; 540Bool_t TGeoPhysicalNode::SetPath(const char *path); 541{; 542 if (!gGeoManager->cd(path)) {; 543 Error(""SetPath"", ""wrong path -> maybe RestoreMasterVolume"");; 544 return kFALSE;; 545 }; 546 SetBranchAsState();; 547 return kTRUE;; 548}; 549 ; 550////////////////////////////////////////////////////////////////////////////////; 551/// Checks if a given navigator state matches this physical node; 552 ; 553Bool_t TGeoPhysicalNode::IsMatchingState(TGeoNavigator *nav) const; 554{; 555 TGeoNodeCache *cache = nav->GetCache();; 556 if (!cache) {; 557 Fatal(""SetBranchAsState"", ""no state available"");; 558 return kFALSE;; 559 }; 560 // the first condition is that the levels of navigator and this physical node must match; 561 if (cache->GetLevel() != fLevel) {; 562 return kFALSE;; 563 }; 564 // now we compare the nodes at each level; 565 // starting backwards since that enhances the probability of an early return; 566 TGeoNode **branch = (TGeoNode **)cache->GetBranch();; 567 for (Int_t i = fLevel; i >= 1; --i); 568 if (fNodes->At(i) != branch[i]); 569 return kFALSE;; 570 return kTRUE;; 571}; 572 ; 573ClassImp(TGeoPNEntry);; 574 ; 575////////////////////////////////////////////////////////////////////////////////; 576/// Default constructor; 577 ; 578TGeoPNEntry::TGeoPNEntry(); 579{; 580 fNode = nullptr;; 581 fMatrix = nullptr;; 582 fGlobalOrig = nullptr;; 583}; 584 ; 585////////////////////////////////////////////////////////////////////////////////; 586/// Default constructor; 587 ; 588TGeoPNEntry::TGeoPNEntry(const char *name, const char *path) : TNamed(name, path); 589{; 590 if (!gGeoManager || !gGeoManager->IsClosed() || !gGeoManager->CheckPath(path)) {; 591 TString errmsg(""Cannot define a physical node link without a closed geometry and a valid path !"");; 592 Error(""ctor"", ""%s"", errmsg.Data());; 593 throw errmsg;; 594 return;; 595 }; 596 gGeoManager->PushPath();; 597 gGeoMana",MatchSource.WIKI,doc/master/TGeoPhysicalNode_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPhysicalNode_8cxx_source.html
https://root.cern/doc/master/TGeoPhysicalNode_8cxx_source.html:19141,Performance,cache,cache,19141,"///////////////////////////////////////////////////; 538/// Specify the path for this node.; 539 ; 540Bool_t TGeoPhysicalNode::SetPath(const char *path); 541{; 542 if (!gGeoManager->cd(path)) {; 543 Error(""SetPath"", ""wrong path -> maybe RestoreMasterVolume"");; 544 return kFALSE;; 545 }; 546 SetBranchAsState();; 547 return kTRUE;; 548}; 549 ; 550////////////////////////////////////////////////////////////////////////////////; 551/// Checks if a given navigator state matches this physical node; 552 ; 553Bool_t TGeoPhysicalNode::IsMatchingState(TGeoNavigator *nav) const; 554{; 555 TGeoNodeCache *cache = nav->GetCache();; 556 if (!cache) {; 557 Fatal(""SetBranchAsState"", ""no state available"");; 558 return kFALSE;; 559 }; 560 // the first condition is that the levels of navigator and this physical node must match; 561 if (cache->GetLevel() != fLevel) {; 562 return kFALSE;; 563 }; 564 // now we compare the nodes at each level; 565 // starting backwards since that enhances the probability of an early return; 566 TGeoNode **branch = (TGeoNode **)cache->GetBranch();; 567 for (Int_t i = fLevel; i >= 1; --i); 568 if (fNodes->At(i) != branch[i]); 569 return kFALSE;; 570 return kTRUE;; 571}; 572 ; 573ClassImp(TGeoPNEntry);; 574 ; 575////////////////////////////////////////////////////////////////////////////////; 576/// Default constructor; 577 ; 578TGeoPNEntry::TGeoPNEntry(); 579{; 580 fNode = nullptr;; 581 fMatrix = nullptr;; 582 fGlobalOrig = nullptr;; 583}; 584 ; 585////////////////////////////////////////////////////////////////////////////////; 586/// Default constructor; 587 ; 588TGeoPNEntry::TGeoPNEntry(const char *name, const char *path) : TNamed(name, path); 589{; 590 if (!gGeoManager || !gGeoManager->IsClosed() || !gGeoManager->CheckPath(path)) {; 591 TString errmsg(""Cannot define a physical node link without a closed geometry and a valid path !"");; 592 Error(""ctor"", ""%s"", errmsg.Data());; 593 throw errmsg;; 594 return;; 595 }; 596 gGeoManager->PushPath();; 597 gGeoMana",MatchSource.WIKI,doc/master/TGeoPhysicalNode_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPhysicalNode_8cxx_source.html
https://root.cern/doc/master/TGeoPhysicalNode_8cxx_source.html:32565,Performance,optimiz,optimization,32565,"; TGeoShape::GetNameconst char * GetName() const overrideGet the shape name.Definition TGeoShape.cxx:250; TGeoVolumeTGeoVolume, TGeoVolumeMulti, TGeoVolumeAssembly are the volume classes.Definition TGeoVolume.h:43; TGeoVolume::kVolumeImportNodes@ kVolumeImportNodesDefinition TGeoVolume.h:76; TGeoVolume::CloneVolumevirtual TGeoVolume * CloneVolume() constClone this volume.Definition TGeoVolume.cxx:1831; TGeoVolume::GetNdaughtersInt_t GetNdaughters() constDefinition TGeoVolume.h:362; TGeoVolume::GetNodesTObjArray * GetNodes()Definition TGeoVolume.h:169; TGeoVolume::FindOverlapsvoid FindOverlaps() constloop all nodes marked as overlaps and find overlapping brothersDefinition TGeoVolume.cxx:2227; TGeoVolume::GetNodeTGeoNode * GetNode(const char *name) constget the pointer to a daughter nodeDefinition TGeoVolume.cxx:2193; TGeoVolume::GetIndexInt_t GetIndex(const TGeoNode *node) constget index number for a given daughterDefinition TGeoVolume.cxx:1743; TGeoVolume::GetVoxelsTGeoVoxelFinder * GetVoxels() constGetter for optimization structure.Definition TGeoVolume.cxx:1802; TGeoVolume::SetShapevoid SetShape(const TGeoShape *shape)set the shape associated with this volumeDefinition TGeoVolume.cxx:2067; TGeoVolume::GetShapeTGeoShape * GetShape() constDefinition TGeoVolume.h:190; TGeoVolume::IsAssemblyvirtual Bool_t IsAssembly() constReturns true if the volume is an assembly or a scaled assembly.Definition TGeoVolume.cxx:1822; TGeoVoxelFinderFinder class handling voxels.Definition TGeoVoxelFinder.h:20; TGeoVoxelFinder::SetNeedRebuildvoid SetNeedRebuild(Bool_t flag=kTRUE)Definition TGeoVoxelFinder.h:107; TGeoVoxelFinder::Voxelizevirtual void Voxelize(Option_t *option="""")Voxelize attached volume according to option If the volume is an assembly, make sure the bbox is comp...Definition TGeoVoxelFinder.cxx:2419; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Defini",MatchSource.WIKI,doc/master/TGeoPhysicalNode_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPhysicalNode_8cxx_source.html
https://root.cern/doc/master/TGeoPhysicalNode_8cxx_source.html:1046,Safety,detect,detector,1046," Matches. TGeoPhysicalNode.cxx. Go to the documentation of this file. 1// @(#)root/geom:$Id$; 2// Author: Andrei Gheata 17/02/04; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/** \class TGeoPhysicalNode; 13\ingroup Geometry_classes; 14 ; 15Physical nodes are the actual 'touchable' objects in the geometry, representing; 16a path of positioned volumes starting with the top node:; 17 path=/TOP/A_1/B_4/C_3 , where A, B, C represent names of volumes.; 18 ; 19The number of physical nodes is given by the total number of possible of; 20branches in the geometry hierarchy. In case of detector geometries and; 21specially for calorimeters this number can be of the order 1e6-1e9, therefore; 22it is impossible to create all physical nodes as objects in memory. In TGeo,; 23physical nodes are represented by the class TGeoPhysicalNode and can be created; 24on demand for alignment purposes:; 25 ; 26~~~ {.cpp}; 27 TGeoPhysicalNode *pn = new TGeoPhysicalNode(""path_to_object""); 28~~~; 29 ; 30Once created, a physical node can be misaligned, meaning that its position; 31or even shape can be changed:; 32 ; 33~~~ {.cpp}; 34 pn->Align(TGeoMatrix* newmat, TGeoShape* newshape, Bool_t check=kFALSE); 35~~~; 36*/; 37 ; 38/** \class TGeoPNEntry; 39\ingroup Geometry_classes; 40 ; 41The knowledge of the path to the objects that need to be misaligned is; 42essential since there is no other way of identifying them. One can however; 43create 'symbolic links' to any complex path to make it more representable; 44for the object it designates:; 45 ; 46~~~ {.cpp}; 47 TGeoPNEntry *pne = new TGeoPNEntry(""TPC_SECTOR_2"", ""path_to_tpc_sect2"");; 48 pne->SetPhysicalNode(pn); 49~~~; 5",MatchSource.WIKI,doc/master/TGeoPhysicalNode_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPhysicalNode_8cxx_source.html
https://root.cern/doc/master/TGeoPhysicalNode_8cxx_source.html:9752,Testability,log,logical,9752,";; 252 return kFALSE;; 253 }; 254 newnode->SetVolume(newvol);; 255 newnode->SetMotherVolume(vm);; 256 if (vm->TestBit(TGeoVolume::kVolumeImportNodes)) {; 257 gGeoManager->GetListOfGShapes()->Add(newnode);; 258 }; 259 vm->GetNodes()->RemoveAt(i);; 260 vm->GetNodes()->AddAt(newnode, i);; 261 shared = kTRUE;; 262 }; 263 if (!shared); 264 Error(""Align"", ""The matrix replaced for %s is not actually shared"", GetName());; 265 } else {; 266 // The aligned node may have a composite shape containing a shared matrix; 267 if (vd->GetShape()->IsComposite()) {; 268 cs = (TGeoCompositeShape *)vd->GetShape();; 269 if (cs->GetBoolNode()->GetRightMatrix()->IsShared()) {; 270 if (!nnode->GetMatrix()->IsIdentity()) {; 271 Error(""Align"", ""The composite shape having a shared matrix on the subtracted branch must be ""; 272 ""positioned using identity matrix."");; 273 return kFALSE;; 274 }; 275 // We have to put the alignment matrix on top of the left branch; 276 // of the composite shape. The node is already decoupled from logical tree.; 277 TGeoCompositeShape *ncs = new TGeoCompositeShape(cs->GetName(), cs->GetBoolNode()->MakeClone());; 278 TGeoMatrix *oldmat = ncs->GetBoolNode()->GetLeftMatrix();; 279 TGeoHMatrix *newmat1 = new TGeoHMatrix(*newmat);; 280 newmat1->Multiply(oldmat);; 281 ncs->GetBoolNode()->ReplaceMatrix(oldmat, newmat1);; 282 vd->SetShape(ncs);; 283 // The right-side matrix pointer is preserved, so no need to update nodes.; 284 aligned = nullptr; // to prevent updating its matrix; 285 }; 286 }; 287 }; 288 // Register matrix and make it the active one; 289 if (!newmat->IsRegistered()); 290 newmat->RegisterYourself();; 291 if (aligned) {; 292 aligned->SetMatrix(newmat);; 293 // Update the global matrix for the aligned node; 294 TGeoHMatrix *global = GetMatrix();; 295 TGeoHMatrix *up = GetMatrix(fLevel - 1);; 296 *global = up;; 297 global->Multiply(newmat);; 298 }; 299 }; 300 // Change the shape for the aligned node; 301 if (newshape); 302 vd->SetShape(newshape);; 303 ; 304 // R",MatchSource.WIKI,doc/master/TGeoPhysicalNode_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPhysicalNode_8cxx_source.html
https://root.cern/doc/master/TGeoShape_8h_source.html:1059,Availability,error,error,1059,"fine ROOT_TGeoShape; 14 ; 15#include ""TNamed.h""; 16 ; 17// forward declarations; 18class TGeoBoolCombinator;; 19class TGeoBBox;; 20class TGeoMatrix;; 21class TGeoHMatrix;; 22class TGeoVolume;; 23class TBuffer3D;; 24 ; 25class TGeoShape : public TNamed {; 26private:; 27 static TGeoMatrix *fgTransform; // current transformation matrix that applies to shape; 28 static Double_t fgEpsMch; // Machine round-off error; 29public:; 30 enum EShapeType {; 31 kBitMask32 = 0xffffffff,; 32 kGeoNoShape = 0,; 33 kGeoBad = BIT(0),; 34 kGeoRSeg = BIT(1),; 35 kGeoPhiSeg = BIT(2),; 36 kGeoThetaSeg = BIT(3),; 37 kGeoVisX = BIT(4),; 38 kGeoVisY = BIT(5),; 39 kGeoVisZ = BIT(6),; 40 kGeoRunTimeShape = BIT(7),; 41 kGeoInvalidShape = BIT(8),; 42 kGeoTorus = BIT(9),; 43 kGeoBox = BIT(10),; 44 kGeoPara = BIT(11),; 45 kGeoSph = BIT(12),; 46 kGeoTube = BIT(13),; 47 kGeoTubeSeg = BIT(14),; 48 kGeoCone = BIT(15),; 49 kGeoConeSeg = BIT(16),; 50 kGeoPcon = BIT(17),; 51 kGeoPgon = BIT(18),; 52 kGeoArb8 = BIT(19),; 53 kGeoEltu = BIT(20),; 54 kGeoTrap = BIT(21),; 55 kGeoCtub = BIT(22),; 56 kGeoTrd1 = BIT(23),; 57 kGeoTrd2 = BIT(24),; 58 kGeoComb = BIT(25),; 59 kGeoClosedShape = BIT(26),; 60 kGeoXtru = BIT(27),; 61 kGeoParaboloid = BIT(28),; 62 kGeoHalfSpace = BIT(29),; 63 kGeoHype = BIT(30),; 64 kGeoSavePrimitive = BIT(20); 65 };; 66 virtual void ClearThreadData() const {}; 67 virtual void CreateThreadData(Int_t) {}; 68 ; 69protected:; 70 // data members; 71 Int_t fShapeId; // shape id; 72 UInt_t fShapeBits; // shape bits; 73 // methods; 74 virtual void FillBuffer3D(TBuffer3D &buffer, Int_t reqSections, Bool_t localFrame) const;; 75 Int_t GetBasicColor() const;; 76 void SetOnBoundary(Bool_t /*flag=kTRUE*/) {}; 77 void TransformPoints(Double_t *points, UInt_t NbPoints) const;; 78 ; 79public:; 80 // constructors; 81 TGeoShape();; 82 TGeoShape(const char *name);; 83 // destructor; 84 ~TGeoShape() override;; 85 // methods; 86 ; 87 static Double_t Big() { return 1.E30; }; 88 static TGeoMatrix *GetTransform();",MatchSource.WIKI,doc/master/TGeoShape_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoShape_8h_source.html
https://root.cern/doc/master/TGeoShape_8h_source.html:14807,Availability,toler,tolerance,14807,"etAxisNamevirtual const char * GetAxisName(Int_t iaxis) const =0; TGeoShape::GetPointsOnSegmentsvirtual Bool_t GetPointsOnSegments(Int_t npoints, Double_t *array) const =0; TGeoShape::SetTransformstatic void SetTransform(TGeoMatrix *matrix)Set current transformation matrix that applies to shape.Definition TGeoShape.cxx:582; TGeoShape::DistFromInside_vvirtual void DistFromInside_v(const Double_t *, const Double_t *, Double_t *, Int_t, Double_t *) constDefinition TGeoShape.h:105; TGeoShape::Dividevirtual TGeoVolume * Divide(TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step)=0; TGeoShape::IsCompositevirtual Bool_t IsComposite() constDefinition TGeoShape.h:130; TGeoShape::InvertShapeBitvoid InvertShapeBit(UInt_t f)Definition TGeoShape.h:169; TGeoShape::ComputeNormal_vvirtual void ComputeNormal_v(const Double_t *, const Double_t *, Double_t *, Int_t)Definition TGeoShape.h:98; TGeoShape::IsSameWithinTolerancestatic Bool_t IsSameWithinTolerance(Double_t a, Double_t b)Check if two numbers differ with less than a tolerance.Definition TGeoShape.cxx:338; TGeoShape::Safetyvirtual Double_t Safety(const Double_t *point, Bool_t in=kTRUE) const =0; TGeoShape::IsRunTimeShapeBool_t IsRunTimeShape() constDefinition TGeoShape.h:142; TGeoShape::Contains_vvirtual void Contains_v(const Double_t *, Bool_t *, Int_t) constDefinition TGeoShape.h:100; TGeoShape::ClearThreadDatavirtual void ClearThreadData() constDefinition TGeoShape.h:66; TGeoShape::GetPointerNameconst char * GetPointerName() constProvide a pointer name containing uid.Definition TGeoShape.cxx:746; TGeoShape::FillBuffer3Dvirtual void FillBuffer3D(TBuffer3D &buffer, Int_t reqSections, Bool_t localFrame) constFill the supplied buffer, with sections in desired frame See TBuffer3D.h for explanation of sections,...Definition TGeoShape.cxx:632; TGeoShape::IsCylTypevirtual Bool_t IsCylType() const =0; TGeoShape::CheckShapevoid CheckShape(Int_t testNo, Int_t nsamples=10000, Option_t *option",MatchSource.WIKI,doc/master/TGeoShape_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoShape_8h_source.html
https://root.cern/doc/master/TGeoShape_8h_source.html:15898,Availability,error,errorDefinition,15898,"tyvirtual Double_t Safety(const Double_t *point, Bool_t in=kTRUE) const =0; TGeoShape::IsRunTimeShapeBool_t IsRunTimeShape() constDefinition TGeoShape.h:142; TGeoShape::Contains_vvirtual void Contains_v(const Double_t *, Bool_t *, Int_t) constDefinition TGeoShape.h:100; TGeoShape::ClearThreadDatavirtual void ClearThreadData() constDefinition TGeoShape.h:66; TGeoShape::GetPointerNameconst char * GetPointerName() constProvide a pointer name containing uid.Definition TGeoShape.cxx:746; TGeoShape::FillBuffer3Dvirtual void FillBuffer3D(TBuffer3D &buffer, Int_t reqSections, Bool_t localFrame) constFill the supplied buffer, with sections in desired frame See TBuffer3D.h for explanation of sections,...Definition TGeoShape.cxx:632; TGeoShape::IsCylTypevirtual Bool_t IsCylType() const =0; TGeoShape::CheckShapevoid CheckShape(Int_t testNo, Int_t nsamples=10000, Option_t *option="""")Test for shape navigation methods.Definition TGeoShape.cxx:211; TGeoShape::EpsMchstatic Double_t EpsMch()static function returning the machine round-off errorDefinition TGeoShape.cxx:242; TGeoShape::IsInPhiRangestatic Bool_t IsInPhiRange(const Double_t *point, Double_t phi1, Double_t phi2)Static method to check if a point is in the phi range (phi1, phi2) [degrees].Definition TGeoShape.cxx:290; TGeoShape::ComputeEpsMchstatic Double_t ComputeEpsMch()Compute machine round-off double precision error as the smallest number that if added to 1....Definition TGeoShape.cxx:225; TGeoShape::Paintvoid Paint(Option_t *option="""") overridePaint this shape.Definition TGeoShape.cxx:784; TGeoShape::~TGeoShape~TGeoShape() overrideDestructor.Definition TGeoShape.cxx:197; TGeoShape::fgTransformstatic TGeoMatrix * fgTransformDefinition TGeoShape.h:27; TGeoShape::GetBoundingCylindervirtual void GetBoundingCylinder(Double_t *param) const =0; TGeoShape::InspectShapevirtual void InspectShape() const =0; TGeoShape::IsValidBoxvirtual Bool_t IsValidBox() const =0; TGeoShape::IsReflectedvirtual Bool_t IsReflected() constDefinitio",MatchSource.WIKI,doc/master/TGeoShape_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoShape_8h_source.html
https://root.cern/doc/master/TGeoShape_8h_source.html:16240,Availability,error,error,16240,"Shape.h:66; TGeoShape::GetPointerNameconst char * GetPointerName() constProvide a pointer name containing uid.Definition TGeoShape.cxx:746; TGeoShape::FillBuffer3Dvirtual void FillBuffer3D(TBuffer3D &buffer, Int_t reqSections, Bool_t localFrame) constFill the supplied buffer, with sections in desired frame See TBuffer3D.h for explanation of sections,...Definition TGeoShape.cxx:632; TGeoShape::IsCylTypevirtual Bool_t IsCylType() const =0; TGeoShape::CheckShapevoid CheckShape(Int_t testNo, Int_t nsamples=10000, Option_t *option="""")Test for shape navigation methods.Definition TGeoShape.cxx:211; TGeoShape::EpsMchstatic Double_t EpsMch()static function returning the machine round-off errorDefinition TGeoShape.cxx:242; TGeoShape::IsInPhiRangestatic Bool_t IsInPhiRange(const Double_t *point, Double_t phi1, Double_t phi2)Static method to check if a point is in the phi range (phi1, phi2) [degrees].Definition TGeoShape.cxx:290; TGeoShape::ComputeEpsMchstatic Double_t ComputeEpsMch()Compute machine round-off double precision error as the smallest number that if added to 1....Definition TGeoShape.cxx:225; TGeoShape::Paintvoid Paint(Option_t *option="""") overridePaint this shape.Definition TGeoShape.cxx:784; TGeoShape::~TGeoShape~TGeoShape() overrideDestructor.Definition TGeoShape.cxx:197; TGeoShape::fgTransformstatic TGeoMatrix * fgTransformDefinition TGeoShape.h:27; TGeoShape::GetBoundingCylindervirtual void GetBoundingCylinder(Double_t *param) const =0; TGeoShape::InspectShapevirtual void InspectShape() const =0; TGeoShape::IsValidBoxvirtual Bool_t IsValidBox() const =0; TGeoShape::IsReflectedvirtual Bool_t IsReflected() constDefinition TGeoShape.h:140; TGeoShape::ShapeDistancetoPrimitiveInt_t ShapeDistancetoPrimitive(Int_t numpoints, Int_t px, Int_t py) constReturns distance to shape primitive mesh.Definition TGeoShape.cxx:261; TGeoShape::GetFittingBoxvirtual Int_t GetFittingBox(const TGeoBBox *parambox, TGeoMatrix *mat, Double_t &dx, Double_t &dy, Double_t &dz) const =0; TGeo",MatchSource.WIKI,doc/master/TGeoShape_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoShape_8h_source.html
https://root.cern/doc/master/TGeoShape_8h_source.html:3641,Safety,safe,safe,3641,,MatchSource.WIKI,doc/master/TGeoShape_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoShape_8h_source.html
https://root.cern/doc/master/TGeoShape_8h_source.html:3926,Safety,safe,safe,3926,"stNo, Int_t nsamples = 10000, Option_t *option = """");; 96 virtual void ComputeBBox() = 0;; 97 virtual void ComputeNormal(const Double_t *point, const Double_t *dir, Double_t *norm) = 0;; 98 virtual void ComputeNormal_v(const Double_t *, const Double_t *, Double_t *, Int_t) {}; 99 virtual Bool_t Contains(const Double_t *point) const = 0;; 100 virtual void Contains_v(const Double_t *, Bool_t *, Int_t) const {}; 101 virtual Bool_t CouldBeCrossed(const Double_t *point, const Double_t *dir) const = 0;; 102 Int_t DistancetoPrimitive(Int_t px, Int_t py) override = 0;; 103 virtual Double_t DistFromInside(const Double_t *point, const Double_t *dir, Int_t iact = 1,; 104 Double_t step = TGeoShape::Big(), Double_t *safe = nullptr) const = 0;; 105 virtual void DistFromInside_v(const Double_t *, const Double_t *, Double_t *, Int_t, Double_t *) const {}; 106 virtual Double_t DistFromOutside(const Double_t *point, const Double_t *dir, Int_t iact = 1,; 107 Double_t step = TGeoShape::Big(), Double_t *safe = nullptr) const = 0;; 108 virtual void DistFromOutside_v(const Double_t *, const Double_t *, Double_t *, Int_t, Double_t *) const {}; 109 static Double_t DistToPhiMin(const Double_t *point, const Double_t *dir, Double_t s1, Double_t c1, Double_t s2,; 110 Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE);; 111 virtual TGeoVolume *; 112 Divide(TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) = 0;; 113 void Draw(Option_t *option = """") override; // *MENU*; 114 void ExecuteEvent(Int_t event, Int_t px, Int_t py) override;; 115 virtual const char *GetAxisName(Int_t iaxis) const = 0;; 116 virtual Double_t GetAxisRange(Int_t iaxis, Double_t &xlo, Double_t &xhi) const = 0;; 117 virtual void GetBoundingCylinder(Double_t *param) const = 0;; 118 virtual const TBuffer3D &GetBuffer3D(Int_t reqSections, Bool_t localFrame) const;; 119 virtual Int_t GetByteCount() const = 0;; 120 virtual Bool_t GetPointsOnSegments(Int_t npoints, Double_t *array)",MatchSource.WIKI,doc/master/TGeoShape_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoShape_8h_source.html
https://root.cern/doc/master/TGeoShape_8h_source.html:10965,Safety,avoid,avoid,10965,"t TPoint const char y1Definition TGWin32VirtualXProxy.cxx:70; namechar name[80]Definition TGX11.cxx:110; TNamed.h; TBuffer3DGeneric 3D primitive description class.Definition TBuffer3D.h:18; TGeoBBoxDefinition TGeoBBox.h:17; TGeoHMatrixMatrix class used for computing global transformations Should NOT be used for node definition.Definition TGeoMatrix.h:458; TGeoMatrixGeometrical transformation package.Definition TGeoMatrix.h:38; TGeoShapeBase abstract class for all shapes.Definition TGeoShape.h:25; TGeoShape::DistancetoPrimitiveInt_t DistancetoPrimitive(Int_t px, Int_t py) override=0Computes distance from point (px,py) to the object.; TGeoShape::SetOnBoundaryvoid SetOnBoundary(Bool_t)Definition TGeoShape.h:76; TGeoShape::ComputeNormalvirtual void ComputeNormal(const Double_t *point, const Double_t *dir, Double_t *norm)=0; TGeoShape::TestShapeBitsInt_t TestShapeBits(UInt_t f) constDefinition TGeoShape.h:168; TGeoShape::GetBuffer3Dvirtual const TBuffer3D & GetBuffer3D(Int_t reqSections, Bool_t localFrame) constStub implementation to avoid forcing implementation at this stage.Definition TGeoShape.cxx:735; TGeoShape::SetIdvoid SetId(Int_t id)Definition TGeoShape.h:155; TGeoShape::fShapeBitsUInt_t fShapeBitsDefinition TGeoShape.h:72; TGeoShape::Bigstatic Double_t Big()Definition TGeoShape.h:87; TGeoShape::GetAxisRangevirtual Double_t GetAxisRange(Int_t iaxis, Double_t &xlo, Double_t &xhi) const =0; TGeoShape::GetBasicColorInt_t GetBasicColor() constGet the basic color (0-7).Definition TGeoShape.cxx:718; TGeoShape::DistFromInsidevirtual Double_t DistFromInside(const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const =0; TGeoShape::IsSegCrossingstatic Bool_t IsSegCrossing(Double_t x1, Double_t y1, Double_t x2, Double_t y2, Double_t x3, Double_t y3, Double_t x4, Double_t y4)Check if segments (A,B) and (C,D) are crossing, where: A(x1,y1), B(x2,y2), C(x3,y3),...Definition TGeoShape.cxx:349; TGeoShape::CreateThreadDa",MatchSource.WIKI,doc/master/TGeoShape_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoShape_8h_source.html
https://root.cern/doc/master/TGeoShape_8h_source.html:11599,Safety,safe,safe,11599,":ComputeNormalvirtual void ComputeNormal(const Double_t *point, const Double_t *dir, Double_t *norm)=0; TGeoShape::TestShapeBitsInt_t TestShapeBits(UInt_t f) constDefinition TGeoShape.h:168; TGeoShape::GetBuffer3Dvirtual const TBuffer3D & GetBuffer3D(Int_t reqSections, Bool_t localFrame) constStub implementation to avoid forcing implementation at this stage.Definition TGeoShape.cxx:735; TGeoShape::SetIdvoid SetId(Int_t id)Definition TGeoShape.h:155; TGeoShape::fShapeBitsUInt_t fShapeBitsDefinition TGeoShape.h:72; TGeoShape::Bigstatic Double_t Big()Definition TGeoShape.h:87; TGeoShape::GetAxisRangevirtual Double_t GetAxisRange(Int_t iaxis, Double_t &xlo, Double_t &xhi) const =0; TGeoShape::GetBasicColorInt_t GetBasicColor() constGet the basic color (0-7).Definition TGeoShape.cxx:718; TGeoShape::DistFromInsidevirtual Double_t DistFromInside(const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const =0; TGeoShape::IsSegCrossingstatic Bool_t IsSegCrossing(Double_t x1, Double_t y1, Double_t x2, Double_t y2, Double_t x3, Double_t y3, Double_t x4, Double_t y4)Check if segments (A,B) and (C,D) are crossing, where: A(x1,y1), B(x2,y2), C(x3,y3),...Definition TGeoShape.cxx:349; TGeoShape::CreateThreadDatavirtual void CreateThreadData(Int_t)Definition TGeoShape.h:67; TGeoShape::TransformPointsvoid TransformPoints(Double_t *points, UInt_t NbPoints) constTranform a set of points (LocalToMaster)Definition TGeoShape.cxx:590; TGeoShape::SetShapeBitvoid SetShapeBit(UInt_t f, Bool_t set)Equivalent of TObject::SetBit.Definition TGeoShape.cxx:562; TGeoShape::IsValidBool_t IsValid() constDefinition TGeoShape.h:143; TGeoShape::ResetShapeBitvoid ResetShapeBit(UInt_t f)Definition TGeoShape.h:166; TGeoShape::GetNmeshVerticesvirtual Int_t GetNmeshVertices() constDefinition TGeoShape.h:127; TGeoShape::GetMeshNumbersvirtual void GetMeshNumbers(Int_t &, Int_t &, Int_t &) constDefinition TGeoShape.h:125; TGeoShape::DistToPhiMinstatic Do",MatchSource.WIKI,doc/master/TGeoShape_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoShape_8h_source.html
https://root.cern/doc/master/TGeoShape_8h_source.html:13442,Safety,safe,safety,13442,"nt_t f)Definition TGeoShape.h:166; TGeoShape::GetNmeshVerticesvirtual Int_t GetNmeshVertices() constDefinition TGeoShape.h:127; TGeoShape::GetMeshNumbersvirtual void GetMeshNumbers(Int_t &, Int_t &, Int_t &) constDefinition TGeoShape.h:125; TGeoShape::DistToPhiMinstatic Double_t DistToPhiMin(const Double_t *point, const Double_t *dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in=kTRUE)compute distance from point (inside phi) to both phi planes. Return minimum.Definition TGeoShape.cxx:426; TGeoShape::SetSegsAndPolsvirtual void SetSegsAndPols(TBuffer3D &buff) const =0; TGeoShape::SetShapeBitvoid SetShapeBit(UInt_t f)Definition TGeoShape.h:165; TGeoShape::DistFromOutside_vvirtual void DistFromOutside_v(const Double_t *, const Double_t *, Double_t *, Int_t, Double_t *) constDefinition TGeoShape.h:108; TGeoShape::TGeoShapeTGeoShape()Default constructor.Definition TGeoShape.cxx:167; TGeoShape::SafetyPhistatic Double_t SafetyPhi(const Double_t *point, Bool_t in, Double_t phi1, Double_t phi2)Static method to compute safety w.r.t a phi corner defined by cosines/sines of the angles phi1,...Definition TGeoShape.cxx:494; TGeoShape::SetDimensionsvirtual void SetDimensions(Double_t *param)=0; TGeoShape::Sizeof3Dvirtual void Sizeof3D() const =0; TGeoShape::fShapeIdInt_t fShapeIdDefinition TGeoShape.h:71; TGeoShape::GetAxisNamevirtual const char * GetAxisName(Int_t iaxis) const =0; TGeoShape::GetPointsOnSegmentsvirtual Bool_t GetPointsOnSegments(Int_t npoints, Double_t *array) const =0; TGeoShape::SetTransformstatic void SetTransform(TGeoMatrix *matrix)Set current transformation matrix that applies to shape.Definition TGeoShape.cxx:582; TGeoShape::DistFromInside_vvirtual void DistFromInside_v(const Double_t *, const Double_t *, Double_t *, Int_t, Double_t *) constDefinition TGeoShape.h:105; TGeoShape::Dividevirtual TGeoVolume * Divide(TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step)=0; TGeoSh",MatchSource.WIKI,doc/master/TGeoShape_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoShape_8h_source.html
https://root.cern/doc/master/TGeoShape_8h_source.html:18176,Safety,safe,safe,18176,"uble_t &dy, Double_t &dz) const =0; TGeoShape::fgEpsMchstatic Double_t fgEpsMchDefinition TGeoShape.h:28; TGeoShape::NormalPhistatic void NormalPhi(const Double_t *point, const Double_t *dir, Double_t *norm, Double_t c1, Double_t s1, Double_t c2, Double_t s2)Static method to compute normal to phi planes.Definition TGeoShape.cxx:464; TGeoShape::SafetySegstatic Double_t SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer)Compute distance from point of coordinates (r,z) to segment (r1,z1):(r2,z2)Definition TGeoShape.cxx:528; TGeoShape::IsCrossingSemiplanestatic Bool_t IsCrossingSemiplane(const Double_t *point, const Double_t *dir, Double_t cphi, Double_t sphi, Double_t &snext, Double_t &rxy)Compute distance from POINT to semiplane defined by PHI angle along DIR.Definition TGeoShape.cxx:306; TGeoShape::DistFromOutsidevirtual Double_t DistFromOutside(const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const =0; TGeoShape::GetByteCountvirtual Int_t GetByteCount() const =0; TGeoShape::IsVecGeomvirtual Bool_t IsVecGeom() constDefinition TGeoShape.h:141; TGeoShape::GetNameconst char * GetName() const overrideGet the shape name.Definition TGeoShape.cxx:250; TGeoShape::ComputeBBoxvirtual void ComputeBBox()=0; TGeoShape::AfterStreamervirtual void AfterStreamer()Definition TGeoShape.h:93; TGeoShape::CouldBeCrossedvirtual Bool_t CouldBeCrossed(const Double_t *point, const Double_t *dir) const =0; TGeoShape::Safety_vvirtual void Safety_v(const Double_t *, const Bool_t *, Double_t *, Int_t) constDefinition TGeoShape.h:151; TGeoShape::GetTransformstatic TGeoMatrix * GetTransform()Returns current transformation matrix that applies to shape.Definition TGeoShape.cxx:574; TGeoShape::Capacityvirtual Double_t Capacity() const =0; TGeoShape::SetRuntimevoid SetRuntime(Bool_t flag=kTRUE)Definition TGeoShape.h:159; TGeoShape::Containsvirtual Bool_t Contains(const Double_t *point) const ",MatchSource.WIKI,doc/master/TGeoShape_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoShape_8h_source.html
https://root.cern/doc/master/TGeoShape_8h_source.html:2926,Testability,test,testNo,2926,,MatchSource.WIKI,doc/master/TGeoShape_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoShape_8h_source.html
https://root.cern/doc/master/TGeoShape_8h_source.html:15695,Testability,test,testNo,15695,"IsSameWithinTolerancestatic Bool_t IsSameWithinTolerance(Double_t a, Double_t b)Check if two numbers differ with less than a tolerance.Definition TGeoShape.cxx:338; TGeoShape::Safetyvirtual Double_t Safety(const Double_t *point, Bool_t in=kTRUE) const =0; TGeoShape::IsRunTimeShapeBool_t IsRunTimeShape() constDefinition TGeoShape.h:142; TGeoShape::Contains_vvirtual void Contains_v(const Double_t *, Bool_t *, Int_t) constDefinition TGeoShape.h:100; TGeoShape::ClearThreadDatavirtual void ClearThreadData() constDefinition TGeoShape.h:66; TGeoShape::GetPointerNameconst char * GetPointerName() constProvide a pointer name containing uid.Definition TGeoShape.cxx:746; TGeoShape::FillBuffer3Dvirtual void FillBuffer3D(TBuffer3D &buffer, Int_t reqSections, Bool_t localFrame) constFill the supplied buffer, with sections in desired frame See TBuffer3D.h for explanation of sections,...Definition TGeoShape.cxx:632; TGeoShape::IsCylTypevirtual Bool_t IsCylType() const =0; TGeoShape::CheckShapevoid CheckShape(Int_t testNo, Int_t nsamples=10000, Option_t *option="""")Test for shape navigation methods.Definition TGeoShape.cxx:211; TGeoShape::EpsMchstatic Double_t EpsMch()static function returning the machine round-off errorDefinition TGeoShape.cxx:242; TGeoShape::IsInPhiRangestatic Bool_t IsInPhiRange(const Double_t *point, Double_t phi1, Double_t phi2)Static method to check if a point is in the phi range (phi1, phi2) [degrees].Definition TGeoShape.cxx:290; TGeoShape::ComputeEpsMchstatic Double_t ComputeEpsMch()Compute machine round-off double precision error as the smallest number that if added to 1....Definition TGeoShape.cxx:225; TGeoShape::Paintvoid Paint(Option_t *option="""") overridePaint this shape.Definition TGeoShape.cxx:784; TGeoShape::~TGeoShape~TGeoShape() overrideDestructor.Definition TGeoShape.cxx:197; TGeoShape::fgTransformstatic TGeoMatrix * fgTransformDefinition TGeoShape.h:27; TGeoShape::GetBoundingCylindervirtual void GetBoundingCylinder(Double_t *param) const =0; TGeoSh",MatchSource.WIKI,doc/master/TGeoShape_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoShape_8h_source.html
https://root.cern/doc/master/TGeoTube_8h_source.html:2177,Safety,safe,safe,2177," TGeoTube(Double_t *params);; 34 // destructor; 35 ~TGeoTube() override;; 36 // methods; 37 ; 38 Double_t Capacity() const override;; 39 static Double_t Capacity(Double_t rmin, Double_t rmax, Double_t dz);; 40 void ComputeBBox() override;; 41 void ComputeNormal(const Double_t *point, const Double_t *dir, Double_t *norm) override;; 42 void ComputeNormal_v(const Double_t *points, const Double_t *dirs, Double_t *norms, Int_t vecsize) override;; 43 static void ComputeNormalS(const Double_t *point, const Double_t *dir, Double_t *norm, Double_t rmin, Double_t rmax,; 44 Double_t dz);; 45 Bool_t Contains(const Double_t *point) const override;; 46 void Contains_v(const Double_t *points, Bool_t *inside, Int_t vecsize) const override;; 47 static Double_t; 48 DistFromInsideS(const Double_t *point, const Double_t *dir, Double_t rmin, Double_t rmax, Double_t dz);; 49 Double_t DistFromInside(const Double_t *point, const Double_t *dir, Int_t iact = 1, Double_t step = TGeoShape::Big(),; 50 Double_t *safe = nullptr) const override;; 51 void DistFromInside_v(const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize,; 52 Double_t *step) const override;; 53 static Double_t; 54 DistFromOutsideS(const Double_t *point, const Double_t *dir, Double_t rmin, Double_t rmax, Double_t dz);; 55 Double_t DistFromOutside(const Double_t *point, const Double_t *dir, Int_t iact = 1,; 56 Double_t step = TGeoShape::Big(), Double_t *safe = nullptr) const override;; 57 void DistFromOutside_v(const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize,; 58 Double_t *step) const override;; 59 static void DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t &b, Double_t &delta);; 60 Int_t DistancetoPrimitive(Int_t px, Int_t py) override;; 61 TGeoVolume *; 62 Divide(TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override;; 63 const char *GetAxisName(Int_t iaxis) const override;; 64 Double_t GetAxisR",MatchSource.WIKI,doc/master/TGeoTube_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoTube_8h_source.html
https://root.cern/doc/master/TGeoTube_8h_source.html:2615,Safety,safe,safe,2615,"rride;; 43 static void ComputeNormalS(const Double_t *point, const Double_t *dir, Double_t *norm, Double_t rmin, Double_t rmax,; 44 Double_t dz);; 45 Bool_t Contains(const Double_t *point) const override;; 46 void Contains_v(const Double_t *points, Bool_t *inside, Int_t vecsize) const override;; 47 static Double_t; 48 DistFromInsideS(const Double_t *point, const Double_t *dir, Double_t rmin, Double_t rmax, Double_t dz);; 49 Double_t DistFromInside(const Double_t *point, const Double_t *dir, Int_t iact = 1, Double_t step = TGeoShape::Big(),; 50 Double_t *safe = nullptr) const override;; 51 void DistFromInside_v(const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize,; 52 Double_t *step) const override;; 53 static Double_t; 54 DistFromOutsideS(const Double_t *point, const Double_t *dir, Double_t rmin, Double_t rmax, Double_t dz);; 55 Double_t DistFromOutside(const Double_t *point, const Double_t *dir, Int_t iact = 1,; 56 Double_t step = TGeoShape::Big(), Double_t *safe = nullptr) const override;; 57 void DistFromOutside_v(const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize,; 58 Double_t *step) const override;; 59 static void DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t &b, Double_t &delta);; 60 Int_t DistancetoPrimitive(Int_t px, Int_t py) override;; 61 TGeoVolume *; 62 Divide(TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override;; 63 const char *GetAxisName(Int_t iaxis) const override;; 64 Double_t GetAxisRange(Int_t iaxis, Double_t &xlo, Double_t &xhi) const override;; 65 void GetBoundingCylinder(Double_t *param) const override;; 66 const TBuffer3D &GetBuffer3D(Int_t reqSections, Bool_t localFrame) const override;; 67 Int_t GetByteCount() const override { return 48; }; 68 Bool_t GetPointsOnSegments(Int_t npoints, Double_t *array) const override;; 69 TGeoShape *GetMakeRuntimeShape(TGeoShape *mother, TGeoMatrix *mat) const override;; 70 ",MatchSource.WIKI,doc/master/TGeoTube_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoTube_8h_source.html
https://root.cern/doc/master/TGeoTube_8h_source.html:4264,Safety,safe,safe,4264,"; 65 void GetBoundingCylinder(Double_t *param) const override;; 66 const TBuffer3D &GetBuffer3D(Int_t reqSections, Bool_t localFrame) const override;; 67 Int_t GetByteCount() const override { return 48; }; 68 Bool_t GetPointsOnSegments(Int_t npoints, Double_t *array) const override;; 69 TGeoShape *GetMakeRuntimeShape(TGeoShape *mother, TGeoMatrix *mat) const override;; 70 void GetMeshNumbers(Int_t &nvert, Int_t &nsegs, Int_t &npols) const override;; 71 Int_t GetNmeshVertices() const override;; 72 virtual Double_t GetRmin() const { return fRmin; }; 73 virtual Double_t GetRmax() const { return fRmax; }; 74 virtual Double_t GetDz() const { return fDz; }; 75 Bool_t HasRmin() const { return (fRmin > 0) ? kTRUE : kFALSE; }; 76 void InspectShape() const override;; 77 Bool_t IsCylType() const override { return kTRUE; }; 78 TBuffer3D *MakeBuffer3D() const override;; 79 Double_t Safety(const Double_t *point, Bool_t in = kTRUE) const override;; 80 void Safety_v(const Double_t *points, const Bool_t *inside, Double_t *safe, Int_t vecsize) const override;; 81 static Double_t; 82 SafetyS(const Double_t *point, Bool_t in, Double_t rmin, Double_t rmax, Double_t dz, Int_t skipz = 0);; 83 void SavePrimitive(std::ostream &out, Option_t *option = """") override;; 84 void SetTubeDimensions(Double_t rmin, Double_t rmax, Double_t dz);; 85 void SetDimensions(Double_t *param) override;; 86 void SetPoints(Double_t *points) const override;; 87 void SetPoints(Float_t *points) const override;; 88 void SetSegsAndPols(TBuffer3D &buff) const override;; 89 void Sizeof3D() const override;; 90 ; 91 ClassDefOverride(TGeoTube, 1) // cylindrical tube class; 92};; 93 ; 94class TGeoTubeSeg : public TGeoTube {; 95protected:; 96 // data members; 97 Double_t fPhi1; // first phi limit; 98 Double_t fPhi2; // second phi limit; 99 // Transient trigonometric data; 100 Double_t fS1; // sin(phi1); 101 Double_t fC1; // cos(phi1); 102 Double_t fS2; // sin(phi2); 103 Double_t fC2; // cos(phi2); 104 Double_t fSm; // sin(0.",MatchSource.WIKI,doc/master/TGeoTube_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoTube_8h_source.html
https://root.cern/doc/master/TGeoTube_8h_source.html:6938,Safety,safe,safe,6938,"eBBox() override;; 123 void ComputeNormal(const Double_t *point, const Double_t *dir, Double_t *norm) override;; 124 void ComputeNormal_v(const Double_t *points, const Double_t *dirs, Double_t *norms, Int_t vecsize) override;; 125 static void ComputeNormalS(const Double_t *point, const Double_t *dir, Double_t *norm, Double_t rmin, Double_t rmax,; 126 Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2);; 127 Bool_t Contains(const Double_t *point) const override;; 128 void Contains_v(const Double_t *points, Bool_t *inside, Int_t vecsize) const override;; 129 Int_t DistancetoPrimitive(Int_t px, Int_t py) override;; 130 static Double_t DistFromInsideS(const Double_t *point, const Double_t *dir, Double_t rmin, Double_t rmax,; 131 Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm,; 132 Double_t sm, Double_t cdfi);; 133 Double_t DistFromInside(const Double_t *point, const Double_t *dir, Int_t iact = 1, Double_t step = TGeoShape::Big(),; 134 Double_t *safe = nullptr) const override;; 135 void DistFromInside_v(const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize,; 136 Double_t *step) const override;; 137 static Double_t DistFromOutsideS(const Double_t *point, const Double_t *dir, Double_t rmin, Double_t rmax,; 138 Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm,; 139 Double_t sm, Double_t cdfi);; 140 Double_t DistFromOutside(const Double_t *point, const Double_t *dir, Int_t iact = 1,; 141 Double_t step = TGeoShape::Big(), Double_t *safe = nullptr) const override;; 142 void DistFromOutside_v(const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize,; 143 Double_t *step) const override;; 144 TGeoVolume *; 145 Divide(TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override;; 146 Double_t GetAxisRange(Int_t iaxis, Double_t &xlo, Double_t &xhi) const override;; 147 void GetBoundingCylinder(Double_t *param) const override;;",MatchSource.WIKI,doc/master/TGeoTube_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoTube_8h_source.html
https://root.cern/doc/master/TGeoTube_8h_source.html:7480,Safety,safe,safe,7480,"t_t vecsize) const override;; 129 Int_t DistancetoPrimitive(Int_t px, Int_t py) override;; 130 static Double_t DistFromInsideS(const Double_t *point, const Double_t *dir, Double_t rmin, Double_t rmax,; 131 Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm,; 132 Double_t sm, Double_t cdfi);; 133 Double_t DistFromInside(const Double_t *point, const Double_t *dir, Int_t iact = 1, Double_t step = TGeoShape::Big(),; 134 Double_t *safe = nullptr) const override;; 135 void DistFromInside_v(const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize,; 136 Double_t *step) const override;; 137 static Double_t DistFromOutsideS(const Double_t *point, const Double_t *dir, Double_t rmin, Double_t rmax,; 138 Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm,; 139 Double_t sm, Double_t cdfi);; 140 Double_t DistFromOutside(const Double_t *point, const Double_t *dir, Int_t iact = 1,; 141 Double_t step = TGeoShape::Big(), Double_t *safe = nullptr) const override;; 142 void DistFromOutside_v(const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize,; 143 Double_t *step) const override;; 144 TGeoVolume *; 145 Divide(TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override;; 146 Double_t GetAxisRange(Int_t iaxis, Double_t &xlo, Double_t &xhi) const override;; 147 void GetBoundingCylinder(Double_t *param) const override;; 148 const TBuffer3D &GetBuffer3D(Int_t reqSections, Bool_t localFrame) const override;; 149 Int_t GetByteCount() const override { return 56; }; 150 Bool_t GetPointsOnSegments(Int_t npoints, Double_t *array) const override;; 151 TGeoShape *GetMakeRuntimeShape(TGeoShape *mother, TGeoMatrix *mat) const override;; 152 Int_t GetNmeshVertices() const override;; 153 void GetMeshNumbers(Int_t &nvert, Int_t &nsegs, Int_t &npols) const override;; 154 Double_t GetPhi1() const { return fPhi1; }; 155 Double_t GetPhi2() const { return fPhi2; }; 156 ",MatchSource.WIKI,doc/master/TGeoTube_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoTube_8h_source.html
https://root.cern/doc/master/TGeoTube_8h_source.html:8720,Safety,safe,safe,8720,"me, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override;; 146 Double_t GetAxisRange(Int_t iaxis, Double_t &xlo, Double_t &xhi) const override;; 147 void GetBoundingCylinder(Double_t *param) const override;; 148 const TBuffer3D &GetBuffer3D(Int_t reqSections, Bool_t localFrame) const override;; 149 Int_t GetByteCount() const override { return 56; }; 150 Bool_t GetPointsOnSegments(Int_t npoints, Double_t *array) const override;; 151 TGeoShape *GetMakeRuntimeShape(TGeoShape *mother, TGeoMatrix *mat) const override;; 152 Int_t GetNmeshVertices() const override;; 153 void GetMeshNumbers(Int_t &nvert, Int_t &nsegs, Int_t &npols) const override;; 154 Double_t GetPhi1() const { return fPhi1; }; 155 Double_t GetPhi2() const { return fPhi2; }; 156 void InspectShape() const override;; 157 TBuffer3D *MakeBuffer3D() const override;; 158 Double_t Safety(const Double_t *point, Bool_t in = kTRUE) const override;; 159 void Safety_v(const Double_t *points, const Bool_t *inside, Double_t *safe, Int_t vecsize) const override;; 160 static Double_t SafetyS(const Double_t *point, Bool_t in, Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1,; 161 Double_t phi2, Int_t skipz = 0);; 162 void SavePrimitive(std::ostream &out, Option_t *option = """") override;; 163 void SetTubsDimensions(Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2);; 164 void SetDimensions(Double_t *param) override;; 165 void SetPoints(Double_t *points) const override;; 166 void SetPoints(Float_t *points) const override;; 167 void SetSegsAndPols(TBuffer3D &buff) const override;; 168 void Sizeof3D() const override;; 169 ; 170 ClassDefOverride(TGeoTubeSeg, 2) // cylindrical tube segment class; 171};; 172 ; 173class TGeoCtub : public TGeoTubeSeg {; 174protected:; 175 // data members; 176 Double_t fNlow[3]; // normal to lower cut plane; 177 Double_t fNhigh[3]; // normal to higher cut plane; 178 ; 179public:; 180 // constructors; 181 TGeoCtub();; 182 TGeoCtub(Double_t rmin, Double_t rmax,",MatchSource.WIKI,doc/master/TGeoTube_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoTube_8h_source.html
https://root.cern/doc/master/TGeoTube_8h_source.html:10708,Safety,safe,safe,10708,"ouble_t rmax, Double_t dz, Double_t phi1, Double_t phi2, Double_t lx, Double_t ly,; 183 Double_t lz, Double_t tx, Double_t ty, Double_t tz);; 184 TGeoCtub(const char *name, Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2, Double_t lx,; 185 Double_t ly, Double_t lz, Double_t tx, Double_t ty, Double_t tz);; 186 TGeoCtub(Double_t *params);; 187 // destructor; 188 ~TGeoCtub() override;; 189 // methods; 190 Double_t Capacity() const override;; 191 void ComputeBBox() override;; 192 void ComputeNormal(const Double_t *point, const Double_t *dir, Double_t *norm) override;; 193 void ComputeNormal_v(const Double_t *points, const Double_t *dirs, Double_t *norms, Int_t vecsize) override;; 194 Bool_t Contains(const Double_t *point) const override;; 195 void Contains_v(const Double_t *points, Bool_t *inside, Int_t vecsize) const override;; 196 Double_t DistFromInside(const Double_t *point, const Double_t *dir, Int_t iact = 1, Double_t step = TGeoShape::Big(),; 197 Double_t *safe = nullptr) const override;; 198 void DistFromInside_v(const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize,; 199 Double_t *step) const override;; 200 Double_t DistFromOutside(const Double_t *point, const Double_t *dir, Int_t iact = 1,; 201 Double_t step = TGeoShape::Big(), Double_t *safe = nullptr) const override;; 202 void DistFromOutside_v(const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize,; 203 Double_t *step) const override;; 204 TGeoVolume *; 205 Divide(TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override;; 206 Double_t GetAxisRange(Int_t iaxis, Double_t &xlo, Double_t &xhi) const override;; 207 const TBuffer3D &GetBuffer3D(Int_t reqSections, Bool_t localFrame) const override;; 208 Int_t GetByteCount() const override { return 98; }; 209 Bool_t GetPointsOnSegments(Int_t npoints, Double_t *array) const override;; 210 TGeoShape *GetMakeRuntimeShape(TGeoShape *mother, TGeoMatrix *m",MatchSource.WIKI,doc/master/TGeoTube_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoTube_8h_source.html
https://root.cern/doc/master/TGeoTube_8h_source.html:11021,Safety,safe,safe,11021,"y, Double_t tz);; 186 TGeoCtub(Double_t *params);; 187 // destructor; 188 ~TGeoCtub() override;; 189 // methods; 190 Double_t Capacity() const override;; 191 void ComputeBBox() override;; 192 void ComputeNormal(const Double_t *point, const Double_t *dir, Double_t *norm) override;; 193 void ComputeNormal_v(const Double_t *points, const Double_t *dirs, Double_t *norms, Int_t vecsize) override;; 194 Bool_t Contains(const Double_t *point) const override;; 195 void Contains_v(const Double_t *points, Bool_t *inside, Int_t vecsize) const override;; 196 Double_t DistFromInside(const Double_t *point, const Double_t *dir, Int_t iact = 1, Double_t step = TGeoShape::Big(),; 197 Double_t *safe = nullptr) const override;; 198 void DistFromInside_v(const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize,; 199 Double_t *step) const override;; 200 Double_t DistFromOutside(const Double_t *point, const Double_t *dir, Int_t iact = 1,; 201 Double_t step = TGeoShape::Big(), Double_t *safe = nullptr) const override;; 202 void DistFromOutside_v(const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize,; 203 Double_t *step) const override;; 204 TGeoVolume *; 205 Divide(TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override;; 206 Double_t GetAxisRange(Int_t iaxis, Double_t &xlo, Double_t &xhi) const override;; 207 const TBuffer3D &GetBuffer3D(Int_t reqSections, Bool_t localFrame) const override;; 208 Int_t GetByteCount() const override { return 98; }; 209 Bool_t GetPointsOnSegments(Int_t npoints, Double_t *array) const override;; 210 TGeoShape *GetMakeRuntimeShape(TGeoShape *mother, TGeoMatrix *mat) const override;; 211 void GetMeshNumbers(Int_t &nvert, Int_t &nsegs, Int_t &npols) const override;; 212 Int_t GetNmeshVertices() const override;; 213 const Double_t *GetNlow() const { return &fNlow[0]; }; 214 const Double_t *GetNhigh() const { return &fNhigh[0]; }; 215 Double_t GetZcoord(Double_t xc, Double_",MatchSource.WIKI,doc/master/TGeoTube_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoTube_8h_source.html
https://root.cern/doc/master/TGeoTube_8h_source.html:12245,Safety,safe,safe,12245,"ists, Int_t vecsize,; 199 Double_t *step) const override;; 200 Double_t DistFromOutside(const Double_t *point, const Double_t *dir, Int_t iact = 1,; 201 Double_t step = TGeoShape::Big(), Double_t *safe = nullptr) const override;; 202 void DistFromOutside_v(const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize,; 203 Double_t *step) const override;; 204 TGeoVolume *; 205 Divide(TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override;; 206 Double_t GetAxisRange(Int_t iaxis, Double_t &xlo, Double_t &xhi) const override;; 207 const TBuffer3D &GetBuffer3D(Int_t reqSections, Bool_t localFrame) const override;; 208 Int_t GetByteCount() const override { return 98; }; 209 Bool_t GetPointsOnSegments(Int_t npoints, Double_t *array) const override;; 210 TGeoShape *GetMakeRuntimeShape(TGeoShape *mother, TGeoMatrix *mat) const override;; 211 void GetMeshNumbers(Int_t &nvert, Int_t &nsegs, Int_t &npols) const override;; 212 Int_t GetNmeshVertices() const override;; 213 const Double_t *GetNlow() const { return &fNlow[0]; }; 214 const Double_t *GetNhigh() const { return &fNhigh[0]; }; 215 Double_t GetZcoord(Double_t xc, Double_t yc, Double_t zc) const;; 216 void InspectShape() const override;; 217 Double_t Safety(const Double_t *point, Bool_t in = kTRUE) const override;; 218 void Safety_v(const Double_t *points, const Bool_t *inside, Double_t *safe, Int_t vecsize) const override;; 219 void SavePrimitive(std::ostream &out, Option_t *option = """") override;; 220 void SetCtubDimensions(Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2, Double_t lx,; 221 Double_t ly, Double_t lz, Double_t tx, Double_t ty, Double_t tz);; 222 void SetDimensions(Double_t *param) override;; 223 void SetPoints(Double_t *points) const override;; 224 void SetPoints(Float_t *points) const override;; 225 ; 226 ClassDefOverride(TGeoCtub, 1) // cut tube segment class; 227};; 228 ; 229#endif; b#define b(i)Definition RSha256.",MatchSource.WIKI,doc/master/TGeoTube_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoTube_8h_source.html
https://root.cern/doc/master/TGeoTube_8h_source.html:13830,Safety,safe,safe,13830,"ion_tDefinition RtypesCore.h:66; ClassDefOverride#define ClassDefOverride(name, id)Definition Rtypes.h:346; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; pointsOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t pointsDefinition TGWin32VirtualXProxy.cxx:148; namechar name[80]Definition TGX11.cxx:110; TGeoBBox.h; TBuffer3DGeneric 3D primitive description class.Definition TBuffer3D.h:18; TGeoBBoxDefinition TGeoBBox.h:17; TGeoCtubDefinition TGeoTube.h:173; TGeoCtub::GetByteCountInt_t GetByteCount() const overrideDefinition TGeoTube.h:208; TGeoCtub::Safety_vvoid Safety_v(const Double_t *points, const Bool_t *inside, Double_t *safe, Int_t vecsize) const override; TGeoCtub::ComputeNormal_vvoid ComputeNormal_v(const Double_t *points, const Double_t *dirs, Double_t *norms, Int_t vecsize) override; TGeoCtub::GetPointsOnSegmentsBool_t GetPointsOnSegments(Int_t npoints, Double_t *array) const override; TGeoCtub::Contains_vvoid Contains_v(const Double_t *points, Bool_t *inside, Int_t vecsize) const override; TGeoCtub::GetBuffer3Dconst TBuffer3D & GetBuffer3D(Int_t reqSections, Bool_t localFrame) const overrideStub implementation to avoid forcing implementation at this stage.; TGeoCtub::ComputeNormalvoid ComputeNormal(const Double_t *point, const Double_t *dir, Double_t *norm) override; TGeoCtub::GetMakeRuntimeShapeTGeoShape * GetMakeRuntimeShape(TGeoShape *mother, TGeoMatrix *mat) const override; TGeoCtub::GetNlowconst Double_t * GetNlow() constDefinition TGeoTube.h:213; TGeoCtub::TGeoCtubTGeoCtub(Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2, Double_t lx, Double_t ly, Double_t lz, Double_t tx, Double_t ty, Double_t tz); TGeoCtub::SetDimensionsvoid SetDimensions(Double_t *param) override; TGeoCtub::TGeoCtubTGeoCtub(); TGeoCtub::SetPointsvoid SetPoints(Float_t *points) const override; TGeoCtub::CapacityDouble_t Ca",MatchSource.WIKI,doc/master/TGeoTube_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoTube_8h_source.html
https://root.cern/doc/master/TGeoTube_8h_source.html:14338,Safety,avoid,avoid,14338,"ion_tDefinition RtypesCore.h:66; ClassDefOverride#define ClassDefOverride(name, id)Definition Rtypes.h:346; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; pointsOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t pointsDefinition TGWin32VirtualXProxy.cxx:148; namechar name[80]Definition TGX11.cxx:110; TGeoBBox.h; TBuffer3DGeneric 3D primitive description class.Definition TBuffer3D.h:18; TGeoBBoxDefinition TGeoBBox.h:17; TGeoCtubDefinition TGeoTube.h:173; TGeoCtub::GetByteCountInt_t GetByteCount() const overrideDefinition TGeoTube.h:208; TGeoCtub::Safety_vvoid Safety_v(const Double_t *points, const Bool_t *inside, Double_t *safe, Int_t vecsize) const override; TGeoCtub::ComputeNormal_vvoid ComputeNormal_v(const Double_t *points, const Double_t *dirs, Double_t *norms, Int_t vecsize) override; TGeoCtub::GetPointsOnSegmentsBool_t GetPointsOnSegments(Int_t npoints, Double_t *array) const override; TGeoCtub::Contains_vvoid Contains_v(const Double_t *points, Bool_t *inside, Int_t vecsize) const override; TGeoCtub::GetBuffer3Dconst TBuffer3D & GetBuffer3D(Int_t reqSections, Bool_t localFrame) const overrideStub implementation to avoid forcing implementation at this stage.; TGeoCtub::ComputeNormalvoid ComputeNormal(const Double_t *point, const Double_t *dir, Double_t *norm) override; TGeoCtub::GetMakeRuntimeShapeTGeoShape * GetMakeRuntimeShape(TGeoShape *mother, TGeoMatrix *mat) const override; TGeoCtub::GetNlowconst Double_t * GetNlow() constDefinition TGeoTube.h:213; TGeoCtub::TGeoCtubTGeoCtub(Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2, Double_t lx, Double_t ly, Double_t lz, Double_t tx, Double_t ty, Double_t tz); TGeoCtub::SetDimensionsvoid SetDimensions(Double_t *param) override; TGeoCtub::TGeoCtubTGeoCtub(); TGeoCtub::SetPointsvoid SetPoints(Float_t *points) const override; TGeoCtub::CapacityDouble_t Ca",MatchSource.WIKI,doc/master/TGeoTube_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoTube_8h_source.html
https://root.cern/doc/master/TGeoTube_8h_source.html:15233,Safety,safe,safe,15233,,MatchSource.WIKI,doc/master/TGeoTube_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoTube_8h_source.html
https://root.cern/doc/master/TGeoTube_8h_source.html:15769,Safety,safe,safe,15769,"uble_t phi2, Double_t lx, Double_t ly, Double_t lz, Double_t tx, Double_t ty, Double_t tz); TGeoCtub::SetDimensionsvoid SetDimensions(Double_t *param) override; TGeoCtub::TGeoCtubTGeoCtub(); TGeoCtub::SetPointsvoid SetPoints(Float_t *points) const override; TGeoCtub::CapacityDouble_t Capacity() const override; TGeoCtub::DistFromOutsideDouble_t DistFromOutside(const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override; TGeoCtub::ContainsBool_t Contains(const Double_t *point) const override; TGeoCtub::SafetyDouble_t Safety(const Double_t *point, Bool_t in=kTRUE) const override; TGeoCtub::TGeoCtubTGeoCtub(const char *name, Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2, Double_t lx, Double_t ly, Double_t lz, Double_t tx, Double_t ty, Double_t tz); TGeoCtub::DistFromInsideDouble_t DistFromInside(const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override; TGeoCtub::TGeoCtubTGeoCtub(Double_t *params); TGeoCtub::DivideTGeoVolume * Divide(TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override; TGeoCtub::GetZcoordDouble_t GetZcoord(Double_t xc, Double_t yc, Double_t zc) const; TGeoCtub::InspectShapevoid InspectShape() const override; TGeoCtub::GetMeshNumbersvoid GetMeshNumbers(Int_t &nvert, Int_t &nsegs, Int_t &npols) const override; TGeoCtub::~TGeoCtub~TGeoCtub() override; TGeoCtub::DistFromInside_vvoid DistFromInside_v(const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override; TGeoCtub::GetAxisRangeDouble_t GetAxisRange(Int_t iaxis, Double_t &xlo, Double_t &xhi) const override; TGeoCtub::DistFromOutside_vvoid DistFromOutside_v(const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override; TGeoCtub::GetNmeshVerticesInt_t GetNmeshVertices() const override; TGeoCtub::S",MatchSource.WIKI,doc/master/TGeoTube_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoTube_8h_source.html
https://root.cern/doc/master/TGeoTube_8h_source.html:17829,Safety,safe,safe,17829,"GeoCtub::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave a primitive as a C++ statement(s) on output stream ""out"".; TGeoCtub::GetNhighconst Double_t * GetNhigh() constDefinition TGeoTube.h:214; TGeoCtub::ComputeBBoxvoid ComputeBBox() override; TGeoMatrixGeometrical transformation package.Definition TGeoMatrix.h:38; TGeoShapeBase abstract class for all shapes.Definition TGeoShape.h:25; TGeoShape::Bigstatic Double_t Big()Definition TGeoShape.h:87; TGeoTubeSegDefinition TGeoTube.h:94; TGeoTubeSeg::DistFromOutsideDouble_t DistFromOutside(const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override; TGeoTubeSeg::ComputeNormal_vvoid ComputeNormal_v(const Double_t *points, const Double_t *dirs, Double_t *norms, Int_t vecsize) override; TGeoTubeSeg::SetPointsvoid SetPoints(Double_t *points) const override; TGeoTubeSeg::CapacityDouble_t Capacity() const override; TGeoTubeSeg::TGeoTubeSegTGeoTubeSeg(); TGeoTubeSeg::~TGeoTubeSeg~TGeoTubeSeg() override; TGeoTubeSeg::DistFromInsideSstatic Double_t DistFromInsideS(const Double_t *point, const Double_t *dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); TGeoTubeSeg::Safety_vvoid Safety_v(const Double_t *points, const Bool_t *inside, Double_t *safe, Int_t vecsize) const override; TGeoTubeSeg::fPhi1Double_t fPhi1Definition TGeoTube.h:97; TGeoTubeSeg::MakeBuffer3DTBuffer3D * MakeBuffer3D() const override; TGeoTubeSeg::Sizeof3Dvoid Sizeof3D() const override; TGeoTubeSeg::GetPointsOnSegmentsBool_t GetPointsOnSegments(Int_t npoints, Double_t *array) const override; TGeoTubeSeg::GetMakeRuntimeShapeTGeoShape * GetMakeRuntimeShape(TGeoShape *mother, TGeoMatrix *mat) const override; TGeoTubeSeg::fPhi2Double_t fPhi2Definition TGeoTube.h:98; TGeoTubeSeg::ComputeNormalvoid ComputeNormal(const Double_t *point, const Double_t *dir, Double_t *norm) overr",MatchSource.WIKI,doc/master/TGeoTube_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoTube_8h_source.html
https://root.cern/doc/master/TGeoTube_8h_source.html:18545,Safety,safe,safe,18545,"GeoCtub::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave a primitive as a C++ statement(s) on output stream ""out"".; TGeoCtub::GetNhighconst Double_t * GetNhigh() constDefinition TGeoTube.h:214; TGeoCtub::ComputeBBoxvoid ComputeBBox() override; TGeoMatrixGeometrical transformation package.Definition TGeoMatrix.h:38; TGeoShapeBase abstract class for all shapes.Definition TGeoShape.h:25; TGeoShape::Bigstatic Double_t Big()Definition TGeoShape.h:87; TGeoTubeSegDefinition TGeoTube.h:94; TGeoTubeSeg::DistFromOutsideDouble_t DistFromOutside(const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override; TGeoTubeSeg::ComputeNormal_vvoid ComputeNormal_v(const Double_t *points, const Double_t *dirs, Double_t *norms, Int_t vecsize) override; TGeoTubeSeg::SetPointsvoid SetPoints(Double_t *points) const override; TGeoTubeSeg::CapacityDouble_t Capacity() const override; TGeoTubeSeg::TGeoTubeSegTGeoTubeSeg(); TGeoTubeSeg::~TGeoTubeSeg~TGeoTubeSeg() override; TGeoTubeSeg::DistFromInsideSstatic Double_t DistFromInsideS(const Double_t *point, const Double_t *dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); TGeoTubeSeg::Safety_vvoid Safety_v(const Double_t *points, const Bool_t *inside, Double_t *safe, Int_t vecsize) const override; TGeoTubeSeg::fPhi1Double_t fPhi1Definition TGeoTube.h:97; TGeoTubeSeg::MakeBuffer3DTBuffer3D * MakeBuffer3D() const override; TGeoTubeSeg::Sizeof3Dvoid Sizeof3D() const override; TGeoTubeSeg::GetPointsOnSegmentsBool_t GetPointsOnSegments(Int_t npoints, Double_t *array) const override; TGeoTubeSeg::GetMakeRuntimeShapeTGeoShape * GetMakeRuntimeShape(TGeoShape *mother, TGeoMatrix *mat) const override; TGeoTubeSeg::fPhi2Double_t fPhi2Definition TGeoTube.h:98; TGeoTubeSeg::ComputeNormalvoid ComputeNormal(const Double_t *point, const Double_t *dir, Double_t *norm) overr",MatchSource.WIKI,doc/master/TGeoTube_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoTube_8h_source.html
https://root.cern/doc/master/TGeoTube_8h_source.html:20642,Safety,safe,safe,20642,"t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); TGeoTubeSeg::fC2Double_t fC2Definition TGeoTube.h:103; TGeoTubeSeg::ContainsBool_t Contains(const Double_t *point) const override; TGeoTubeSeg::ComputeBBoxvoid ComputeBBox() override; TGeoTubeSeg::DistFromOutside_vvoid DistFromOutside_v(const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override; TGeoTubeSeg::TGeoTubeSegTGeoTubeSeg(Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2); TGeoTubeSeg::fCdfiDouble_t fCdfiDefinition TGeoTube.h:106; TGeoTubeSeg::fCmDouble_t fCmDefinition TGeoTube.h:105; TGeoTubeSeg::DistFromInsideDouble_t DistFromInside(const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override; TGeoTubeSeg::TGeoTubeSegTGeoTubeSeg(const char *name, Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2); TGeoTubeSeg::SetPointsvoid SetPoints(Float_t *points) const override; TGeoTubeSeg::GetBoundingCylindervoid GetBoundingCylinder(Double_t *param) const override; TGeoTubeSeg::DistancetoPrimitiveInt_t DistancetoPrimitive(Int_t px, Int_t py) overrideComputes distance from point (px,py) to the object.; TGeoTubeSeg::InitTrigonometryvoid InitTrigonometry(); TGeoTubeSeg::DivideTGeoVolume * Divide(TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override; TGeoTubeSeg::GetByteCountInt_t GetByteCount() const overrideDefinition TGeoTube.h:149; TGeoTubeSeg::SafetyDouble_t Safety(const Double_t *point, Bool_t in=kTRUE) const override; TGeoTubeSeg::SetTubsDimensionsvoid SetTubsDimensions(Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2); TGeoTubeSeg::GetPhi2Double_t GetPhi2() constDefinition TGeoTube.h:155; TGeoTubeSeg::fC1Double_t fC1Definition TGeoTube.h:101; TGeoTubeSeg::GetNmeshVerticesInt_t GetNmeshVertices() const o",MatchSource.WIKI,doc/master/TGeoTube_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoTube_8h_source.html
https://root.cern/doc/master/TGeoTube_8h_source.html:22039,Safety,avoid,avoid,22039,"Int_t DistancetoPrimitive(Int_t px, Int_t py) overrideComputes distance from point (px,py) to the object.; TGeoTubeSeg::InitTrigonometryvoid InitTrigonometry(); TGeoTubeSeg::DivideTGeoVolume * Divide(TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override; TGeoTubeSeg::GetByteCountInt_t GetByteCount() const overrideDefinition TGeoTube.h:149; TGeoTubeSeg::SafetyDouble_t Safety(const Double_t *point, Bool_t in=kTRUE) const override; TGeoTubeSeg::SetTubsDimensionsvoid SetTubsDimensions(Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2); TGeoTubeSeg::GetPhi2Double_t GetPhi2() constDefinition TGeoTube.h:155; TGeoTubeSeg::fC1Double_t fC1Definition TGeoTube.h:101; TGeoTubeSeg::GetNmeshVerticesInt_t GetNmeshVertices() const override; TGeoTubeSeg::fS1Double_t fS1Definition TGeoTube.h:100; TGeoTubeSeg::fS2Double_t fS2Definition TGeoTube.h:102; TGeoTubeSeg::GetBuffer3Dconst TBuffer3D & GetBuffer3D(Int_t reqSections, Bool_t localFrame) const overrideStub implementation to avoid forcing implementation at this stage.; TGeoTubeSeg::GetAxisRangeDouble_t GetAxisRange(Int_t iaxis, Double_t &xlo, Double_t &xhi) const override; TGeoTubeSeg::GetMeshNumbersvoid GetMeshNumbers(Int_t &nvert, Int_t &nsegs, Int_t &npols) const override; TGeoTubeSeg::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave a primitive as a C++ statement(s) on output stream ""out"".; TGeoTubeSeg::DistFromInside_vvoid DistFromInside_v(const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override; TGeoTubeSeg::SafetySstatic Double_t SafetyS(const Double_t *point, Bool_t in, Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2, Int_t skipz=0); TGeoTubeSeg::TGeoTubeSegTGeoTubeSeg(Double_t *params); TGeoTubeSeg::fSmDouble_t fSmDefinition TGeoTube.h:104; TGeoTubeSeg::Contains_vvoid Contains_v(const Double_t *points, Bool_t *inside, Int_t vecsize) const ove",MatchSource.WIKI,doc/master/TGeoTube_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoTube_8h_source.html
https://root.cern/doc/master/TGeoTube_8h_source.html:23683,Safety,safe,safe,23683,"x, Double_t dz, Double_t phi1, Double_t phi2, Int_t skipz=0); TGeoTubeSeg::TGeoTubeSegTGeoTubeSeg(Double_t *params); TGeoTubeSeg::fSmDouble_t fSmDefinition TGeoTube.h:104; TGeoTubeSeg::Contains_vvoid Contains_v(const Double_t *points, Bool_t *inside, Int_t vecsize) const override; TGeoTubeSeg::SetSegsAndPolsvoid SetSegsAndPols(TBuffer3D &buff) const override; TGeoTubeSeg::GetPhi1Double_t GetPhi1() constDefinition TGeoTube.h:154; TGeoTubeDefinition TGeoTube.h:17; TGeoTube::GetNmeshVerticesInt_t GetNmeshVertices() const override; TGeoTube::DistToTubestatic void DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t &b, Double_t &delta); TGeoTube::GetBoundingCylindervoid GetBoundingCylinder(Double_t *param) const override; TGeoTube::GetRminvirtual Double_t GetRmin() constDefinition TGeoTube.h:72; TGeoTube::TGeoTubeTGeoTube(Double_t *params); TGeoTube::Safety_vvoid Safety_v(const Double_t *points, const Bool_t *inside, Double_t *safe, Int_t vecsize) const override; TGeoTube::GetMeshNumbersvoid GetMeshNumbers(Int_t &nvert, Int_t &nsegs, Int_t &npols) const override; TGeoTube::IsCylTypeBool_t IsCylType() const overrideDefinition TGeoTube.h:77; TGeoTube::GetByteCountInt_t GetByteCount() const overrideDefinition TGeoTube.h:67; TGeoTube::GetAxisRangeDouble_t GetAxisRange(Int_t iaxis, Double_t &xlo, Double_t &xhi) const override; TGeoTube::SetTubeDimensionsvoid SetTubeDimensions(Double_t rmin, Double_t rmax, Double_t dz); TGeoTube::MakeBuffer3DTBuffer3D * MakeBuffer3D() const override; TGeoTube::DistancetoPrimitiveInt_t DistancetoPrimitive(Int_t px, Int_t py) overrideComputes distance from point (px,py) to the object.; TGeoTube::DistFromInsideSstatic Double_t DistFromInsideS(const Double_t *point, const Double_t *dir, Double_t rmin, Double_t rmax, Double_t dz); TGeoTube::GetDzvirtual Double_t GetDz() constDefinition TGeoTube.h:74; TGeoTube::SetPointsvoid SetPoints(Float_t *points) const override; TGeoTube::DistFromOutsideDouble_t DistFromOutside(const",MatchSource.WIKI,doc/master/TGeoTube_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoTube_8h_source.html
https://root.cern/doc/master/TGeoTube_8h_source.html:24814,Safety,safe,safe,24814,"rsvoid GetMeshNumbers(Int_t &nvert, Int_t &nsegs, Int_t &npols) const override; TGeoTube::IsCylTypeBool_t IsCylType() const overrideDefinition TGeoTube.h:77; TGeoTube::GetByteCountInt_t GetByteCount() const overrideDefinition TGeoTube.h:67; TGeoTube::GetAxisRangeDouble_t GetAxisRange(Int_t iaxis, Double_t &xlo, Double_t &xhi) const override; TGeoTube::SetTubeDimensionsvoid SetTubeDimensions(Double_t rmin, Double_t rmax, Double_t dz); TGeoTube::MakeBuffer3DTBuffer3D * MakeBuffer3D() const override; TGeoTube::DistancetoPrimitiveInt_t DistancetoPrimitive(Int_t px, Int_t py) overrideComputes distance from point (px,py) to the object.; TGeoTube::DistFromInsideSstatic Double_t DistFromInsideS(const Double_t *point, const Double_t *dir, Double_t rmin, Double_t rmax, Double_t dz); TGeoTube::GetDzvirtual Double_t GetDz() constDefinition TGeoTube.h:74; TGeoTube::SetPointsvoid SetPoints(Float_t *points) const override; TGeoTube::DistFromOutsideDouble_t DistFromOutside(const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override; TGeoTube::fRminDouble_t fRminDefinition TGeoTube.h:20; TGeoTube::ComputeNormal_vvoid ComputeNormal_v(const Double_t *points, const Double_t *dirs, Double_t *norms, Int_t vecsize) override; TGeoTube::TGeoTubeTGeoTube(const char *name, Double_t rmin, Double_t rmax, Double_t dz); TGeoTube::fDzDouble_t fDzDefinition TGeoTube.h:22; TGeoTube::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave a primitive as a C++ statement(s) on output stream ""out"".; TGeoTube::ComputeBBoxvoid ComputeBBox() override; TGeoTube::DistFromOutsideSstatic Double_t DistFromOutsideS(const Double_t *point, const Double_t *dir, Double_t rmin, Double_t rmax, Double_t dz); TGeoTube::DistFromInside_vvoid DistFromInside_v(const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override; TGeoTube::operator=TGeoTube & operator=(const TGeoTube &)=de",MatchSource.WIKI,doc/master/TGeoTube_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoTube_8h_source.html
https://root.cern/doc/master/TGeoTube_8h_source.html:27199,Safety,safe,safe,27199,"const Double_t *dir, Double_t *norm, Double_t rmin, Double_t rmax, Double_t dz); TGeoTube::InspectShapevoid InspectShape() const override; TGeoTube::ContainsBool_t Contains(const Double_t *point) const override; TGeoTube::fRmaxDouble_t fRmaxDefinition TGeoTube.h:21; TGeoTube::DistFromOutside_vvoid DistFromOutside_v(const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override; TGeoTube::SetSegsAndPolsvoid SetSegsAndPols(TBuffer3D &buff) const override; TGeoTube::GetPointsOnSegmentsBool_t GetPointsOnSegments(Int_t npoints, Double_t *array) const override; TGeoTube::SetPointsvoid SetPoints(Double_t *points) const override; TGeoTube::ComputeNormalvoid ComputeNormal(const Double_t *point, const Double_t *dir, Double_t *norm) override; TGeoTube::DivideTGeoVolume * Divide(TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override; TGeoTube::SetDimensionsvoid SetDimensions(Double_t *param) override; TGeoTube::Capacitystatic Double_t Capacity(Double_t rmin, Double_t rmax, Double_t dz); TGeoTube::CapacityDouble_t Capacity() const override; TGeoTube::SafetyDouble_t Safety(const Double_t *point, Bool_t in=kTRUE) const override; TGeoTube::DistFromInsideDouble_t DistFromInside(const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override; TGeoTube::Sizeof3Dvoid Sizeof3D() const override; TGeoTube::GetMakeRuntimeShapeTGeoShape * GetMakeRuntimeShape(TGeoShape *mother, TGeoMatrix *mat) const override; TGeoTube::GetBuffer3Dconst TBuffer3D & GetBuffer3D(Int_t reqSections, Bool_t localFrame) const overrideStub implementation to avoid forcing implementation at this stage.; TGeoTube::TGeoTubeTGeoTube(Double_t rmin, Double_t rmax, Double_t dz); TGeoTube::HasRminBool_t HasRmin() constDefinition TGeoTube.h:75; TGeoTube::GetAxisNameconst char * GetAxisName(Int_t iaxis) const override; TGeoTube::GetRmaxvirtual Double_t GetRmax() cons",MatchSource.WIKI,doc/master/TGeoTube_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoTube_8h_source.html
https://root.cern/doc/master/TGeoTube_8h_source.html:27518,Safety,avoid,avoid,27518,"const Double_t *dir, Double_t *norm, Double_t rmin, Double_t rmax, Double_t dz); TGeoTube::InspectShapevoid InspectShape() const override; TGeoTube::ContainsBool_t Contains(const Double_t *point) const override; TGeoTube::fRmaxDouble_t fRmaxDefinition TGeoTube.h:21; TGeoTube::DistFromOutside_vvoid DistFromOutside_v(const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize, Double_t *step) const override; TGeoTube::SetSegsAndPolsvoid SetSegsAndPols(TBuffer3D &buff) const override; TGeoTube::GetPointsOnSegmentsBool_t GetPointsOnSegments(Int_t npoints, Double_t *array) const override; TGeoTube::SetPointsvoid SetPoints(Double_t *points) const override; TGeoTube::ComputeNormalvoid ComputeNormal(const Double_t *point, const Double_t *dir, Double_t *norm) override; TGeoTube::DivideTGeoVolume * Divide(TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override; TGeoTube::SetDimensionsvoid SetDimensions(Double_t *param) override; TGeoTube::Capacitystatic Double_t Capacity(Double_t rmin, Double_t rmax, Double_t dz); TGeoTube::CapacityDouble_t Capacity() const override; TGeoTube::SafetyDouble_t Safety(const Double_t *point, Bool_t in=kTRUE) const override; TGeoTube::DistFromInsideDouble_t DistFromInside(const Double_t *point, const Double_t *dir, Int_t iact=1, Double_t step=TGeoShape::Big(), Double_t *safe=nullptr) const override; TGeoTube::Sizeof3Dvoid Sizeof3D() const override; TGeoTube::GetMakeRuntimeShapeTGeoShape * GetMakeRuntimeShape(TGeoShape *mother, TGeoMatrix *mat) const override; TGeoTube::GetBuffer3Dconst TBuffer3D & GetBuffer3D(Int_t reqSections, Bool_t localFrame) const overrideStub implementation to avoid forcing implementation at this stage.; TGeoTube::TGeoTubeTGeoTube(Double_t rmin, Double_t rmax, Double_t dz); TGeoTube::HasRminBool_t HasRmin() constDefinition TGeoTube.h:75; TGeoTube::GetAxisNameconst char * GetAxisName(Int_t iaxis) const override; TGeoTube::GetRmaxvirtual Double_t GetRmax() cons",MatchSource.WIKI,doc/master/TGeoTube_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoTube_8h_source.html
https://root.cern/doc/master/TGeoVolume_8cxx_source.html:16415,Availability,error,error,16415," para - 1,2,3 means X,Y,Z; for; 305tube, tubs, cone, cons - 1 means Rxy, 2 means phi and 3 means Z; for pcon and; 306pgon - 2 means phi and 3 means Z; for spheres 1 means R and 2 means phi.; 307 In fact, the division operation has the same effect as positioning volumes; 308in a given order inside the divided container - the advantage being that the; 309navigation in such a structure is much faster. When a volume is divided, a; 310volume family corresponding to the slices is created. In case all slices can; 311be represented by a single shape, only one volume is added to the family and; 312positioned N times inside the divided volume, otherwise, each slice will be; 313represented by a distinct volume in the family.; 314 Divisions can be also performed in a given range of one axis. For that, one; 315have to specify also the starting coordinate value and the step:; 316 ; 317~~~ {.cpp}; 318 TGeoVolume *slicex = box->Divide(""SLICEX"", 1, N, start, step);; 319~~~; 320 ; 321A check is always done on the resulting division range : if not fitting into; 322the container limits, an error message is posted. If we will browse the divided; 323volume we will notice that it will contain N nodes starting with index 1 upto; 324N. The first one has the lower X limit at START position, while the last one; 325will have the upper X limit at START+N*STEP. The resulting slices cannot; 326be positioned inside an other volume (they are by default positioned inside the; 327divided one) but can be further divided and may contain other volumes:; 328 ; 329~~~ {.cpp}; 330 TGeoVolume *slicey = slicex->Divide(""SLICEY"", 2, N1);; 331 slicey->AddNode(other_vol, index, some_matrix);; 332~~~; 333 ; 334 When doing that, we have to remember that SLICEY represents a family, therefore; 335all members of the family will be divided on Y and the other volume will be; 336added as node inside all.; 337 In the example above all the resulting slices had the same shape as the; 338divided volume (box). This is not alw",MatchSource.WIKI,doc/master/TGeoVolume_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoVolume_8cxx_source.html
https://root.cern/doc/master/TGeoVolume_8cxx_source.html:30756,Availability,down,down,30756,"e->GetName());; 700 // old_vol->InspectShape();; 701 // make a copy of the node; 702 new_node = node->MakeCopyNode();; 703 if (!new_node) {; 704 Fatal(""CheckShapes"", ""Cannot make copy node for %s"", node->GetName());; 705 return;; 706 }; 707 TGeoShape *new_shape = shape->GetMakeRuntimeShape(fShape, node->GetMatrix());; 708 if (!new_shape) {; 709 Error(""CheckShapes"", ""cannot resolve runtime shape for volume %s/%s\n"", GetName(), old_vol->GetName());; 710 continue;; 711 }; 712 TGeoVolume *new_volume = old_vol->MakeCopyVolume(new_shape);; 713 // printf("" new volume %s shape params :\n"", new_volume->GetName());; 714 // new_volume->InspectShape();; 715 new_node->SetVolume(new_volume);; 716 // decouple the old node and put the new one instead; 717 fNodes->AddAt(new_node, i);; 718 // new_volume->CheckShapes();; 719 }; 720 }; 721}; 722 ; 723////////////////////////////////////////////////////////////////////////////////; 724/// Count total number of subnodes starting from this volume, nlevels down; 725/// - option = 0 (default) - count only once per volume; 726/// - option = 1 - count every time; 727/// - option = 2 - count volumes on visible branches; 728/// - option = 3 - return maximum level counted already with option = 0; 729 ; 730Int_t TGeoVolume::CountNodes(Int_t nlevels, Int_t option); 731{; 732 static Int_t maxlevel = 0;; 733 static Int_t nlev = 0;; 734 ; 735 if (option < 0 || option > 3); 736 option = 0;; 737 Int_t visopt = 0;; 738 Int_t nd = GetNdaughters();; 739 Bool_t last = (!nlevels || !nd) ? kTRUE : kFALSE;; 740 switch (option) {; 741 case 0:; 742 if (fNtotal); 743 return fNtotal;; 744 case 1: fNtotal = 1; break;; 745 case 2:; 746 visopt = fGeoManager->GetVisOption();; 747 if (!IsVisDaughters()); 748 last = kTRUE;; 749 switch (visopt) {; 750 case TVirtualGeoPainter::kGeoVisDefault: fNtotal = (IsVisible()) ? 1 : 0; break;; 751 case TVirtualGeoPainter::kGeoVisLeaves: fNtotal = (IsVisible() && last) ? 1 : 0;; 752 }; 753 if (!IsVisibleDaughters()); 754 return fNtot",MatchSource.WIKI,doc/master/TGeoVolume_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoVolume_8cxx_source.html
https://root.cern/doc/master/TGeoVolume_8cxx_source.html:131920,Availability,toler,tolerance,131920,"Shapestatic TGeoShape * MakeScaledShape(const char *name, TGeoShape *shape, TGeoScale *scale)Create a scaled shape starting from a non-scaled one.Definition TGeoScaledShape.cxx:277; TGeoShapeAssemblyThe shape encapsulating an assembly (union) of volumes.Definition TGeoShapeAssembly.h:19; TGeoShapeBase abstract class for all shapes.Definition TGeoShape.h:25; TGeoShape::GetAxisRangevirtual Double_t GetAxisRange(Int_t iaxis, Double_t &xlo, Double_t &xhi) const =0; TGeoShape::CreateThreadDatavirtual void CreateThreadData(Int_t)Definition TGeoShape.h:67; TGeoShape::IsValidBool_t IsValid() constDefinition TGeoShape.h:143; TGeoShape::GetAxisNamevirtual const char * GetAxisName(Int_t iaxis) const =0; TGeoShape::Dividevirtual TGeoVolume * Divide(TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step)=0; TGeoShape::IsCompositevirtual Bool_t IsComposite() constDefinition TGeoShape.h:130; TGeoShape::IsSameWithinTolerancestatic Bool_t IsSameWithinTolerance(Double_t a, Double_t b)Check if two numbers differ with less than a tolerance.Definition TGeoShape.cxx:338; TGeoShape::IsRunTimeShapeBool_t IsRunTimeShape() constDefinition TGeoShape.h:142; TGeoShape::ClearThreadDatavirtual void ClearThreadData() constDefinition TGeoShape.h:66; TGeoShape::GetPointerNameconst char * GetPointerName() constProvide a pointer name containing uid.Definition TGeoShape.cxx:746; TGeoShape::CheckShapevoid CheckShape(Int_t testNo, Int_t nsamples=10000, Option_t *option="""")Test for shape navigation methods.Definition TGeoShape.cxx:211; TGeoShape::IsValidBoxvirtual Bool_t IsValidBox() const =0; TGeoShape::GetByteCountvirtual Int_t GetByteCount() const =0; TGeoShape::GetNameconst char * GetName() const overrideGet the shape name.Definition TGeoShape.cxx:250; TGeoShape::ComputeBBoxvirtual void ComputeBBox()=0; TGeoShape::Capacityvirtual Double_t Capacity() const =0; TGeoShape::kGeoSavePrimitive@ kGeoSavePrimitiveDefinition TGeoShape.h:64; TGeoShape::kGeoBad@ kGeoBadDef",MatchSource.WIKI,doc/master/TGeoVolume_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoVolume_8cxx_source.html
https://root.cern/doc/master/TGeoVolume_8cxx_source.html:145286,Availability,down,down,145286,"Double_t rmax=9999999, Option_t *option="""")Generate a lego plot fot the top volume, according to option.Definition TGeoVolume.cxx:1332; TGeoVolume::Drawvoid Draw(Option_t *option="""") overridedraw top volume according to optionDefinition TGeoVolume.cxx:1206; TGeoVolume::fVoxelsTGeoVoxelFinder * fVoxelsDefinition TGeoVolume.h:50; TGeoVolume::GetMaterialTGeoMaterial * GetMaterial() constDefinition TGeoVolume.h:174; TGeoVolume::IsVolumeMultivirtual Bool_t IsVolumeMulti() constDefinition TGeoVolume.h:110; TGeoVolume::GrabUserExtensionTGeoExtension * GrabUserExtension() constGet a copy of the user extension pointer.Definition TGeoVolume.cxx:1513; TGeoVolume::kVolumeClone@ kVolumeCloneDefinition TGeoVolume.h:80; TGeoVolume::kVolumeSelected@ kVolumeSelectedDefinition TGeoVolume.h:73; TGeoVolume::kVolumeMulti@ kVolumeMultiDefinition TGeoVolume.h:77; TGeoVolume::kVolumeImportNodes@ kVolumeImportNodesDefinition TGeoVolume.h:76; TGeoVolume::CountNodesInt_t CountNodes(Int_t nlevels=1000, Int_t option=0)Count total number of subnodes starting from this volume, nlevels down.Definition TGeoVolume.cxx:730; TGeoVolume::GrabFocusvoid GrabFocus()Move perspective view focus to this volume.Definition TGeoVolume.cxx:1812; TGeoVolume::UnmarkSavedvoid UnmarkSaved()Reset SavePrimitive bits.Definition TGeoVolume.cxx:1699; TGeoVolume::ExecuteEventvoid ExecuteEvent(Int_t event, Int_t px, Int_t py) overrideExecute mouse actions on this volume.Definition TGeoVolume.cxx:1710; TGeoVolume::CloneVolumevirtual TGeoVolume * CloneVolume() constClone this volume.Definition TGeoVolume.cxx:1831; TGeoVolume::SetFindervoid SetFinder(TGeoPatternFinder *finder)Definition TGeoVolume.h:244; TGeoVolume::GetNdaughtersInt_t GetNdaughters() constDefinition TGeoVolume.h:362; TGeoVolume::IsValidBool_t IsValid() constDefinition TGeoVolume.h:154; TGeoVolume::Grabvoid Grab()Definition TGeoVolume.h:136; TGeoVolume::CheckGeometryvoid CheckGeometry(Int_t nrays=1, Double_t startx=0, Double_t starty=0, Double_t startz=0) const",MatchSource.WIKI,doc/master/TGeoVolume_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoVolume_8cxx_source.html
https://root.cern/doc/master/TGeoVolume_8cxx_source.html:160496,Availability,error,error,160496,"ject.h:199; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:213; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::SavePrimitivevirtual void SavePrimitive(std::ostream &out, Option_t *option="""")Save a primitive as a C++ statement(s) on output stream ""out"".Definition TObject.cxx:757; TObject::Writevirtual Int_t Write(const char *name=nullptr, Int_t option=0, Int_t bufsize=0)Write this object to the current directory.Definition TObject.cxx:886; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::SetUniqueIDvirtual void SetUniqueID(UInt_t uid)Set the unique object id.Definition TObject.cxx:797; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TSeqCollectionSequenceable collection abstract base class.Definition TSeqCollection.h:28; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::StripTSubString Strip(EStripType s=kTrailing, char c=' ') constReturn a substring of self stripped at beginning and/or end.Definition TString.cxx:1163; TString::Dataconst char * Data() constDefinition TString.h:376; TStr",MatchSource.WIKI,doc/master/TGeoVolume_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoVolume_8cxx_source.html
https://root.cern/doc/master/TGeoVolume_8cxx_source.html:160632,Availability,error,error,160632,"ect.cxx:213; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::SavePrimitivevirtual void SavePrimitive(std::ostream &out, Option_t *option="""")Save a primitive as a C++ statement(s) on output stream ""out"".Definition TObject.cxx:757; TObject::Writevirtual Int_t Write(const char *name=nullptr, Int_t option=0, Int_t bufsize=0)Write this object to the current directory.Definition TObject.cxx:886; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::SetUniqueIDvirtual void SetUniqueID(UInt_t uid)Set the unique object id.Definition TObject.cxx:797; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TSeqCollectionSequenceable collection abstract base class.Definition TSeqCollection.h:28; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::StripTSubString Strip(EStripType s=kTrailing, char c=' ') constReturn a substring of self stripped at beginning and/or end.Definition TString.cxx:1163; TString::Dataconst char * Data() constDefinition TString.h:376; TString::CapacitySsiz_t Capacity() constDefinition TString.h:364; TString::IsNullBool_t IsNull() constDefinition TString.h:414; TString::",MatchSource.WIKI,doc/master/TGeoVolume_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoVolume_8cxx_source.html
https://root.cern/doc/master/TGeoVolume_8cxx_source.html:56683,Deployability,release,released,56683,"void TGeoVolume::SaveAs(const char *filename, Option_t *option) const; 1448{; 1449 if (!filename); 1450 return;; 1451 std::ofstream out;; 1452 out.open(filename, std::ios::out);; 1453 if (out.bad()) {; 1454 Error(""SavePrimitive"", ""Bad file name: %s"", filename);; 1455 return;; 1456 }; 1457 if (fGeoManager->GetTopVolume() != this); 1458 fGeoManager->SetTopVolume((TGeoVolume *)this);; 1459 ; 1460 TString fname(filename);; 1461 Int_t ind = fname.Index(""."");; 1462 if (ind > 0); 1463 fname.Remove(ind);; 1464 out << ""void "" << fname << ""() {"" << std::endl;; 1465 out << "" gSystem->Load(\""libGeom\"");"" << std::endl;; 1466 const UInt_t prec = TGeoManager::GetExportPrecision();; 1467 out << std::setprecision(prec);; 1468 ((TGeoVolume *)this)->SavePrimitive(out, option);; 1469 out << ""}"" << std::endl;; 1470}; 1471 ; 1472////////////////////////////////////////////////////////////////////////////////; 1473/// Connect user-defined extension to the volume. The volume ""grabs"" a copy, so; 1474/// the original object can be released by the producer. Release the previously; 1475/// connected extension if any.; 1476///; 1477/// NOTE: This interface is intended for user extensions and is guaranteed not; 1478/// to be used by TGeo; 1479 ; 1480void TGeoVolume::SetUserExtension(TGeoExtension *ext); 1481{; 1482 TGeoExtension* tmp = fUserExtension;; 1483 fUserExtension = nullptr;; 1484 if (ext); 1485 fUserExtension = ext->Grab();; 1486 if (tmp); 1487 tmp->Release();; 1488}; 1489 ; 1490////////////////////////////////////////////////////////////////////////////////; 1491/// Connect framework defined extension to the volume. The volume ""grabs"" a copy,; 1492/// so the original object can be released by the producer. Release the previously; 1493/// connected extension if any.; 1494///; 1495/// NOTE: This interface is intended for the use by TGeo and the users should; 1496/// NOT connect extensions using this method; 1497 ; 1498void TGeoVolume::SetFWExtension(TGeoExtension *ext); 1499{; 1500 TGeoE",MatchSource.WIKI,doc/master/TGeoVolume_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoVolume_8cxx_source.html
https://root.cern/doc/master/TGeoVolume_8cxx_source.html:57352,Deployability,release,released,57352,"on();; 1467 out << std::setprecision(prec);; 1468 ((TGeoVolume *)this)->SavePrimitive(out, option);; 1469 out << ""}"" << std::endl;; 1470}; 1471 ; 1472////////////////////////////////////////////////////////////////////////////////; 1473/// Connect user-defined extension to the volume. The volume ""grabs"" a copy, so; 1474/// the original object can be released by the producer. Release the previously; 1475/// connected extension if any.; 1476///; 1477/// NOTE: This interface is intended for user extensions and is guaranteed not; 1478/// to be used by TGeo; 1479 ; 1480void TGeoVolume::SetUserExtension(TGeoExtension *ext); 1481{; 1482 TGeoExtension* tmp = fUserExtension;; 1483 fUserExtension = nullptr;; 1484 if (ext); 1485 fUserExtension = ext->Grab();; 1486 if (tmp); 1487 tmp->Release();; 1488}; 1489 ; 1490////////////////////////////////////////////////////////////////////////////////; 1491/// Connect framework defined extension to the volume. The volume ""grabs"" a copy,; 1492/// so the original object can be released by the producer. Release the previously; 1493/// connected extension if any.; 1494///; 1495/// NOTE: This interface is intended for the use by TGeo and the users should; 1496/// NOT connect extensions using this method; 1497 ; 1498void TGeoVolume::SetFWExtension(TGeoExtension *ext); 1499{; 1500 TGeoExtension* tmp = fFWExtension;; 1501 fFWExtension = nullptr;; 1502 if (ext); 1503 fFWExtension = ext->Grab();; 1504 if (tmp); 1505 tmp->Release();; 1506}; 1507 ; 1508////////////////////////////////////////////////////////////////////////////////; 1509/// Get a copy of the user extension pointer. The user must call Release() on; 1510/// the copy pointer once this pointer is not needed anymore (equivalent to; 1511/// delete() after calling new()); 1512 ; 1513TGeoExtension *TGeoVolume::GrabUserExtension() const; 1514{; 1515 if (fUserExtension); 1516 return fUserExtension->Grab();; 1517 return nullptr;; 1518}; 1519 ; 1520////////////////////////////////////////////",MatchSource.WIKI,doc/master/TGeoVolume_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoVolume_8cxx_source.html
https://root.cern/doc/master/TGeoVolume_8cxx_source.html:162701,Deployability,update,update,162701,"tring::Formvoid Form(const char *fmt,...)Formats a string using a printf style format descriptor.Definition TString.cxx:2356; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TString::IndexSsiz_t Index(const char *pat, Ssiz_t i=0, ECaseCompare cmp=kExact) constDefinition TString.h:651; TVirtualGeoPainterAbstract class for geometry painters.Definition TVirtualGeoPainter.h:32; TVirtualGeoPainter::SetTopVolumevirtual void SetTopVolume(TGeoVolume *vol)=0; TVirtualGeoPainter::kGeoVisOnly@ kGeoVisOnlyDefinition TVirtualGeoPainter.h:42; TVirtualGeoPainter::kGeoVisDefault@ kGeoVisDefaultDefinition TVirtualGeoPainter.h:40; TVirtualGeoPainter::kGeoVisLeaves@ kGeoVisLeavesDefinition TVirtualGeoPainter.h:41; TVirtualGeoPainter::ModifiedPadvirtual void ModifiedPad(Bool_t update=kFALSE) const =0; TVirtualGeoPainter::GetTopVolumevirtual TGeoVolume * GetTopVolume() const =0; TVirtualGeoPainter::DrawVolumevirtual void DrawVolume(TGeoVolume *vol, Option_t *option="""")=0; TVirtualGeoPainter::GrabFocusvirtual void GrabFocus(Int_t nfr=0, Double_t dlong=0, Double_t dlat=0, Double_t dpsi=0)=0; TVirtualGeoPainter::CheckOverlapsvirtual void CheckOverlaps(const TGeoVolume *vol, Double_t ovlp=0.1, Option_t *option="""") const =0; TVirtualGeoPainter::DistanceToPrimitiveVolvirtual Int_t DistanceToPrimitiveVol(TGeoVolume *vol, Int_t px, Int_t py)=0; TVirtualGeoPainter::Paintvoid Paint(Option_t *option="""") override=0This method must be overridden if a class wants to paint itself.; TVirtualGeoPainter::TestVoxelsvirtual Bool_t TestVoxels(TGeoVolume *vol)=0; TVirtualGeoPainter::GetDrawnVolumevirtual TGeoVolume * GetDrawnVolume() const =0; TVirtualGeoPainter::GetVolumeInfovirtual const char * GetVolumeInfo(const TGeoVolume *volume, Int_t px, Int_t py) const =0; TVirtualGeoPainter::ExecuteVolumeEventvirtual void ExecuteVolumeEvent(TGeoVolume *volume, Int_t event, Int_t px, Int_t py)=0; TVirtualGeoPainter::CheckGeometryvirtual void CheckGeometry(Int",MatchSource.WIKI,doc/master/TGeoVolume_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoVolume_8cxx_source.html
https://root.cern/doc/master/TGeoVolume_8cxx_source.html:10781,Energy Efficiency,efficient,efficient,10781,", 2, new TGeoTranslation(0.2,0,0));; 185~~~; 186 ; 187 The 2 nodes that we have created inside chamber will both point to a wire_co; 188object, but will be completely distinct : WIRE_CO_1 and WIRE_CO_2. We will; 189want now to place symmetrically 1000 chambers on a pad, following a pattern; 190of 20 rows and 50 columns. One way to do this will be to replicate our chamber; 191by positioning it 1000 times in different positions of the pad. Unfortunately,; 192this is far from being the optimal way of doing what we want.; 193Imagine that we would like to find out which of the 1000 chambers is containing; 194a (x,y,z) point defined in the pad reference. You will never have to do that,; 195since the modeller will take care of it for you, but let's guess what it has; 196to do. The most simple algorithm will just loop over all daughters, convert; 197the point from mother to local reference and check if the current chamber; 198contains the point or not. This might be efficient for pads with few chambers,; 199but definitely not for 1000. Fortunately the modeler is smarter than that and; 200create for each volume some optimization structures called voxels (see Voxelization); 201to minimize the penalty having too many daughters, but if you have 100 pads like; 202this in your geometry you will anyway loose a lot in your tracking performance.; 203 ; 204 The way out when volumes can be arranged according to simple patterns is the; 205usage of divisions. We will describe them in detail later on. Let's think now; 206at a different situation : instead of 1000 chambers of the same type, we may; 207have several types of chambers. Let's say all chambers are cylindrical and have; 208a wire inside, but their dimensions are different. However, we would like all; 209to be represented by a single volume family, since they have the same properties.; 210*/; 211 ; 212/** \class TGeoVolumeMulti; 213\ingroup Geometry_classes; 214 ; 215Volume families; 216 ; 217A volume family is represented by the",MatchSource.WIKI,doc/master/TGeoVolume_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoVolume_8cxx_source.html
https://root.cern/doc/master/TGeoVolume_8cxx_source.html:48404,Energy Efficiency,efficient,efficient,48404,"sContainers()); 1214 SetVisLeaves();; 1215 if (option && option[0] > 0) {; 1216 painter->DrawVolume(this, option);; 1217 } else {; 1218 painter->DrawVolume(this, gEnv->GetValue(""Viewer3D.DefaultDrawOption"", """"));; 1219 }; 1220}; 1221 ; 1222////////////////////////////////////////////////////////////////////////////////; 1223/// draw only this volume; 1224 ; 1225void TGeoVolume::DrawOnly(Option_t *option); 1226{; 1227 if (IsAssembly()) {; 1228 Info(""DrawOnly"", ""Volume assemblies do not support this option."");; 1229 return;; 1230 }; 1231 if (gGeoManager != fGeoManager); 1232 gGeoManager = fGeoManager;; 1233 SetVisOnly();; 1234 TGeoAtt::SetVisRaytrace(kFALSE);; 1235 TVirtualGeoPainter *painter = fGeoManager->GetGeomPainter();; 1236 if (option && option[0] > 0) {; 1237 painter->DrawVolume(this, option);; 1238 } else {; 1239 painter->DrawVolume(this, gEnv->GetValue(""Viewer3D.DefaultDrawOption"", """"));; 1240 }; 1241}; 1242 ; 1243////////////////////////////////////////////////////////////////////////////////; 1244/// Perform an extensive sampling to find which type of voxelization is; 1245/// most efficient.; 1246 ; 1247Bool_t TGeoVolume::OptimizeVoxels(); 1248{; 1249 printf(""Optimizing volume %s ...\n"", GetName());; 1250 TVirtualGeoPainter *painter = fGeoManager->GetGeomPainter();; 1251 return painter->TestVoxels(this);; 1252}; 1253 ; 1254////////////////////////////////////////////////////////////////////////////////; 1255/// Print volume info; 1256 ; 1257void TGeoVolume::Print(Option_t *) const; 1258{; 1259 printf(""== Volume: %s type %s positioned %d times\n"", GetName(), ClassName(), fRefCount);; 1260 InspectShape();; 1261 InspectMaterial();; 1262}; 1263 ; 1264////////////////////////////////////////////////////////////////////////////////; 1265/// paint volume; 1266 ; 1267void TGeoVolume::Paint(Option_t *option); 1268{; 1269 TVirtualGeoPainter *painter = fGeoManager->GetGeomPainter();; 1270 painter->SetTopVolume(this);; 1271 // painter->Paint(option);; 1272 if (option &",MatchSource.WIKI,doc/master/TGeoVolume_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoVolume_8cxx_source.html
https://root.cern/doc/master/TGeoVolume_8cxx_source.html:143452,Energy Efficiency,efficient,efficient,143452,"build a volume with same name, shape and mediumDefinition TGeoVolume.cxx:1928; TGeoVolume::ReplayCreationvoid ReplayCreation(const TGeoVolume *other)Recreate the content of the other volume without pointer copying.Definition TGeoVolume.cxx:1292; TGeoVolume::WeightDouble_t Weight(Double_t precision=0.01, Option_t *option=""va"")Estimate the weight of a volume (in kg) with SIGMA(M)/M better than PRECISION.Definition TGeoVolume.cxx:2501; TGeoVolume::fNumberInt_t fNumberoption - if anyDefinition TGeoVolume.h:55; TGeoVolume::CreateThreadDatavirtual void CreateThreadData(Int_t nthreads)Definition TGeoVolume.cxx:435; TGeoVolume::GetByteCountvirtual Int_t GetByteCount() constget the total size in bytes for this volumeDefinition TGeoVolume.cxx:2204; TGeoVolume::AddNodevirtual TGeoNode * AddNode(TGeoVolume *vol, Int_t copy_no, TGeoMatrix *mat=nullptr, Option_t *option="""")Add a TGeoNode to the list of nodes.Definition TGeoVolume.cxx:975; TGeoVolume::OptimizeVoxelsBool_t OptimizeVoxels()Perform an extensive sampling to find which type of voxelization is most efficient.Definition TGeoVolume.cxx:1247; TGeoVolume::Browsevoid Browse(TBrowser *b) overrideHow to browse a volume.Definition TGeoVolume.cxx:535; TGeoVolume::SetCurrentPointvoid SetCurrentPoint(Double_t x, Double_t y, Double_t z)Set the current tracking point.Definition TGeoVolume.cxx:2059; TGeoVolume::Paintvoid Paint(Option_t *option="""") overridepaint volumeDefinition TGeoVolume.cxx:1267; TGeoVolume::SetVisOnlyvoid SetVisOnly(Bool_t flag=kTRUE) overrideSet visibility for leaves.Definition TGeoVolume.cxx:2393; TGeoVolume::fGeoManagerTGeoManager * fGeoManagerDefinition TGeoVolume.h:51; TGeoVolume::LegoPlotTH2F * LegoPlot(Int_t ntheta=20, Double_t themin=0., Double_t themax=180., Int_t nphi=60, Double_t phimin=0., Double_t phimax=360., Double_t rmin=0., Double_t rmax=9999999, Option_t *option="""")Generate a lego plot fot the top volume, according to option.Definition TGeoVolume.cxx:1332; TGeoVolume::Drawvoid Draw(Option_t *optio",MatchSource.WIKI,doc/master/TGeoVolume_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoVolume_8cxx_source.html
https://root.cern/doc/master/TGeoVolume_8cxx_source.html:156955,Energy Efficiency,efficient,efficient,156955,"re the bbox is comp...Definition TGeoVoxelFinder.cxx:2419; TGeoVoxelFinder::FindOverlapsvirtual void FindOverlaps(Int_t inode) constcreate the list of nodes for which the bboxes overlap with inode's bboxDefinition TGeoVoxelFinder.cxx:329; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; TH2F2-D histogram with a float per channel (see TH1 documentation)Definition TH2.h:307; TIterDefinition TCollection.h:235; TKeyBook space in a file, create I/O buffers, to fill them, (un)compress them.Definition TKey.h:28; TKey::GetClassNamevirtual const char * GetClassName() constDefinition TKey.h:75; TKey::ReadObjvirtual TObject * ReadObj()To read a TObject* from the file.Definition TKey.cxx:759; TList::FindObjectTObject * FindObject(const char *name) const overrideFind an object in this list using its name.Definition TList.cxx:576; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TMapTMap implements an associative array of (key,value) pairs using a THashTable for efficient retrieval ...Definition TMap.h:40; TMap::Addvoid Add(TObject *obj) overrideThis function may not be used (but we need to provide it since it is a pure virtual in TCollection).Definition TMap.cxx:54; TMap::GetValueTObject * GetValue(const char *keyname) constReturns a pointer to the value associated with keyname as name of the key.Definition TMap.cxx:236; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TNamed::SetTitlevirtual void SetTitle(const char *title="""")Set the title of the TNamed.Definition TNamed.cxx:164; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TNamed::GetTitleconst char * GetTitle() const overrideReturns title of object.Definition TNamed.h:48; TNamed::fTitleTString fTitleDefinition TNamed.h:33; TNamed::fNameTString fNameDefinition TNamed.h:32; TNamed::SetNamevirtual void SetName(const char *name)Set the name of the TNamed.Definitio",MatchSource.WIKI,doc/master/TGeoVolume_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoVolume_8cxx_source.html
https://root.cern/doc/master/TGeoVolume_8cxx_source.html:16421,Integrability,message,message,16421," para - 1,2,3 means X,Y,Z; for; 305tube, tubs, cone, cons - 1 means Rxy, 2 means phi and 3 means Z; for pcon and; 306pgon - 2 means phi and 3 means Z; for spheres 1 means R and 2 means phi.; 307 In fact, the division operation has the same effect as positioning volumes; 308in a given order inside the divided container - the advantage being that the; 309navigation in such a structure is much faster. When a volume is divided, a; 310volume family corresponding to the slices is created. In case all slices can; 311be represented by a single shape, only one volume is added to the family and; 312positioned N times inside the divided volume, otherwise, each slice will be; 313represented by a distinct volume in the family.; 314 Divisions can be also performed in a given range of one axis. For that, one; 315have to specify also the starting coordinate value and the step:; 316 ; 317~~~ {.cpp}; 318 TGeoVolume *slicex = box->Divide(""SLICEX"", 1, N, start, step);; 319~~~; 320 ; 321A check is always done on the resulting division range : if not fitting into; 322the container limits, an error message is posted. If we will browse the divided; 323volume we will notice that it will contain N nodes starting with index 1 upto; 324N. The first one has the lower X limit at START position, while the last one; 325will have the upper X limit at START+N*STEP. The resulting slices cannot; 326be positioned inside an other volume (they are by default positioned inside the; 327divided one) but can be further divided and may contain other volumes:; 328 ; 329~~~ {.cpp}; 330 TGeoVolume *slicey = slicex->Divide(""SLICEY"", 2, N1);; 331 slicey->AddNode(other_vol, index, some_matrix);; 332~~~; 333 ; 334 When doing that, we have to remember that SLICEY represents a family, therefore; 335all members of the family will be divided on Y and the other volume will be; 336added as node inside all.; 337 In the example above all the resulting slices had the same shape as the; 338divided volume (box). This is not alw",MatchSource.WIKI,doc/master/TGeoVolume_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoVolume_8cxx_source.html
https://root.cern/doc/master/TGeoVolume_8cxx_source.html:56798,Integrability,interface,interface,56798,"TGeoVolume *)this);; 1459 ; 1460 TString fname(filename);; 1461 Int_t ind = fname.Index(""."");; 1462 if (ind > 0); 1463 fname.Remove(ind);; 1464 out << ""void "" << fname << ""() {"" << std::endl;; 1465 out << "" gSystem->Load(\""libGeom\"");"" << std::endl;; 1466 const UInt_t prec = TGeoManager::GetExportPrecision();; 1467 out << std::setprecision(prec);; 1468 ((TGeoVolume *)this)->SavePrimitive(out, option);; 1469 out << ""}"" << std::endl;; 1470}; 1471 ; 1472////////////////////////////////////////////////////////////////////////////////; 1473/// Connect user-defined extension to the volume. The volume ""grabs"" a copy, so; 1474/// the original object can be released by the producer. Release the previously; 1475/// connected extension if any.; 1476///; 1477/// NOTE: This interface is intended for user extensions and is guaranteed not; 1478/// to be used by TGeo; 1479 ; 1480void TGeoVolume::SetUserExtension(TGeoExtension *ext); 1481{; 1482 TGeoExtension* tmp = fUserExtension;; 1483 fUserExtension = nullptr;; 1484 if (ext); 1485 fUserExtension = ext->Grab();; 1486 if (tmp); 1487 tmp->Release();; 1488}; 1489 ; 1490////////////////////////////////////////////////////////////////////////////////; 1491/// Connect framework defined extension to the volume. The volume ""grabs"" a copy,; 1492/// so the original object can be released by the producer. Release the previously; 1493/// connected extension if any.; 1494///; 1495/// NOTE: This interface is intended for the use by TGeo and the users should; 1496/// NOT connect extensions using this method; 1497 ; 1498void TGeoVolume::SetFWExtension(TGeoExtension *ext); 1499{; 1500 TGeoExtension* tmp = fFWExtension;; 1501 fFWExtension = nullptr;; 1502 if (ext); 1503 fFWExtension = ext->Grab();; 1504 if (tmp); 1505 tmp->Release();; 1506}; 1507 ; 1508////////////////////////////////////////////////////////////////////////////////; 1509/// Get a copy of the user extension pointer. The user must call Release() on; 1510/// the copy pointer once this ",MatchSource.WIKI,doc/master/TGeoVolume_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoVolume_8cxx_source.html
https://root.cern/doc/master/TGeoVolume_8cxx_source.html:57467,Integrability,interface,interface,57467,"e producer. Release the previously; 1475/// connected extension if any.; 1476///; 1477/// NOTE: This interface is intended for user extensions and is guaranteed not; 1478/// to be used by TGeo; 1479 ; 1480void TGeoVolume::SetUserExtension(TGeoExtension *ext); 1481{; 1482 TGeoExtension* tmp = fUserExtension;; 1483 fUserExtension = nullptr;; 1484 if (ext); 1485 fUserExtension = ext->Grab();; 1486 if (tmp); 1487 tmp->Release();; 1488}; 1489 ; 1490////////////////////////////////////////////////////////////////////////////////; 1491/// Connect framework defined extension to the volume. The volume ""grabs"" a copy,; 1492/// so the original object can be released by the producer. Release the previously; 1493/// connected extension if any.; 1494///; 1495/// NOTE: This interface is intended for the use by TGeo and the users should; 1496/// NOT connect extensions using this method; 1497 ; 1498void TGeoVolume::SetFWExtension(TGeoExtension *ext); 1499{; 1500 TGeoExtension* tmp = fFWExtension;; 1501 fFWExtension = nullptr;; 1502 if (ext); 1503 fFWExtension = ext->Grab();; 1504 if (tmp); 1505 tmp->Release();; 1506}; 1507 ; 1508////////////////////////////////////////////////////////////////////////////////; 1509/// Get a copy of the user extension pointer. The user must call Release() on; 1510/// the copy pointer once this pointer is not needed anymore (equivalent to; 1511/// delete() after calling new()); 1512 ; 1513TGeoExtension *TGeoVolume::GrabUserExtension() const; 1514{; 1515 if (fUserExtension); 1516 return fUserExtension->Grab();; 1517 return nullptr;; 1518}; 1519 ; 1520////////////////////////////////////////////////////////////////////////////////; 1521/// Get a copy of the framework extension pointer. The user must call Release() on; 1522/// the copy pointer once this pointer is not needed anymore (equivalent to; 1523/// delete() after calling new()); 1524 ; 1525TGeoExtension *TGeoVolume::GrabFWExtension() const; 1526{; 1527 if (fFWExtension); 1528 return fFWExtension->G",MatchSource.WIKI,doc/master/TGeoVolume_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoVolume_8cxx_source.html
https://root.cern/doc/master/TGeoVolume_8cxx_source.html:60270,Integrability,rout,rout,60270,"s); 1546 mustDraw = kTRUE;; 1547 if (!option[0]) {; 1548 fGeoManager->SetAllIndex();; 1549 out << "" new TGeoManager(\"""" << fGeoManager->GetName() << ""\"", \"""" << fGeoManager->GetTitle() << ""\"");""; 1550 << std::endl; 1551 << std::endl;; 1552 // if (mustDraw) out << "" Bool_t mustDraw = kTRUE;"" << std::endl;; 1553 // else out << "" Bool_t mustDraw = kFALSE;"" << std::endl;; 1554 out << "" Double_t dx, dy, dz;"" << std::endl;; 1555 out << "" Double_t dx1, dx2, dy1, dy2;"" << std::endl;; 1556 out << "" Double_t vert[20], par[20];"" << std::endl;; 1557 out << "" Double_t theta, phi, h1, bl1, tl1, alpha1, h2, bl2, tl2, alpha2;"" << std::endl;; 1558 out << "" Double_t twist;"" << std::endl;; 1559 out << "" Double_t origin[3];"" << std::endl;; 1560 out << "" Double_t rmin, rmax, rmin1, rmax1, rmin2, rmax2;"" << std::endl;; 1561 out << "" Double_t r, rlo, rhi;"" << std::endl;; 1562 out << "" Double_t a, b;"" << std::endl;; 1563 out << "" Double_t point[3], norm[3];"" << std::endl;; 1564 out << "" Double_t rin, stin, rout, stout;"" << std::endl;; 1565 out << "" Double_t thx, phx, thy, phy, thz, phz;"" << std::endl;; 1566 out << "" Double_t alpha, theta1, theta2, phi1, phi2, dphi;"" << std::endl;; 1567 out << "" Double_t tr[3], rot[9];"" << std::endl;; 1568 out << "" Double_t z, density, radl, absl, w;"" << std::endl;; 1569 out << "" Double_t lx, ly, lz, tx, ty, tz;"" << std::endl;; 1570 out << "" Double_t xvert[50], yvert[50];"" << std::endl;; 1571 out << "" Double_t zsect, x0, y0, scale0;"" << std::endl;; 1572 out << "" Int_t nel, numed, nz, nedges, nvert;"" << std::endl;; 1573 out << "" TGeoBoolNode *pBoolNode = nullptr;"" << std::endl << std::endl;; 1574 // first save materials/media; 1575 out << "" // MATERIALS, MIXTURES AND TRACKING MEDIA"" << std::endl;; 1576 SavePrimitive(out, ""m"");; 1577 // then, save matrices; 1578 out << std::endl << "" // TRANSFORMATION MATRICES"" << std::endl;; 1579 SavePrimitive(out, ""x"");; 1580 // save this volume and shape; 1581 SavePrimitive(out, ""s"");; 1582 out << std::endl << "" // SET TOP ",MatchSource.WIKI,doc/master/TGeoVolume_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoVolume_8cxx_source.html
https://root.cern/doc/master/TGeoVolume_8cxx_source.html:110192,Integrability,depend,depending,110192,"024 if (fVoxels) {; 3025 voxels = new TGeoVoxelFinder(vol);; 3026 vol->SetVoxelFinder(voxels);; 3027 }; 3028 // copy option, uid; 3029 vol->SetOption(fOption);; 3030 vol->SetNumber(fNumber);; 3031 vol->SetNtotal(fNtotal);; 3032 vol->SetTitle(GetTitle());; 3033 // copy extensions; 3034 vol->SetUserExtension(fUserExtension);; 3035 vol->SetFWExtension(fFWExtension);; 3036 return vol;; 3037}; 3038 ; 3039////////////////////////////////////////////////////////////////////////////////; 3040/// Division makes no sense for assemblies.; 3041 ; 3042TGeoVolume *TGeoVolumeAssembly::Divide(const char *, Int_t, Int_t, Double_t, Double_t, Int_t, Option_t *); 3043{; 3044 Error(""Divide"", ""Assemblies cannot be divided"");; 3045 return nullptr;; 3046}; 3047 ; 3048////////////////////////////////////////////////////////////////////////////////; 3049/// Assign to the assembly a collection of identical volumes positioned according; 3050/// a predefined pattern. The option can be spaced out or touching depending on the empty; 3051/// space between volumes.; 3052 ; 3053TGeoVolume *TGeoVolumeAssembly::Divide(TGeoVolume *cell, TGeoPatternFinder *pattern, Option_t *option); 3054{; 3055 if (fNodes) {; 3056 Error(""Divide"", ""Cannot divide assembly %s since it has nodes"", GetName());; 3057 return nullptr;; 3058 }; 3059 if (fFinder) {; 3060 Error(""Divide"", ""Assembly %s already divided"", GetName());; 3061 return nullptr;; 3062 }; 3063 Int_t ncells = pattern->GetNdiv();; 3064 if (!ncells || pattern->GetStep() <= 0) {; 3065 Error(""Divide"", ""Pattern finder for dividing assembly %s not initialized. Use SetRange() method."", GetName());; 3066 return nullptr;; 3067 }; 3068 fFinder = pattern;; 3069 TString opt(option);; 3070 opt.ToLower();; 3071 if (opt.Contains(""spacedout"")); 3072 fFinder->SetSpacedOut(kTRUE);; 3073 else; 3074 fFinder->SetSpacedOut(kFALSE);; 3075 // Position volumes; 3076 for (Int_t i = 0; i < ncells; i++) {; 3077 fFinder->cd(i);; 3078 TGeoNodeOffset *node = new TGeoNodeOffset(cell, i, 0.)",MatchSource.WIKI,doc/master/TGeoVolume_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoVolume_8cxx_source.html
https://root.cern/doc/master/TGeoVolume_8cxx_source.html:159742,Integrability,message,message,159742,"move all objects from the array AND delete all heap based objects.Definition TObjArray.cxx:356; TObjArray::AtTObject * At(Int_t idx) const overrideDefinition TObjArray.h:164; TObjArray::RemoveTObject * Remove(TObject *obj) overrideRemove object from array.Definition TObjArray.cxx:719; TObjArray::RemoveAtTObject * RemoveAt(Int_t idx) overrideRemove object at index idx.Definition TObjArray.cxx:694; TObjArray::FindObjectTObject * FindObject(const char *name) const overrideFind an object in this collection using its name.Definition TObjArray.cxx:415; TObjArray::Addvoid Add(TObject *obj) overrideDefinition TObjArray.h:68; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:213; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::SavePrimitivevirtual void SavePrimitive(std::ostream &out, Option_t *option="""")Save a primitive as a C++ statement(s) on output stream ""out"".Definition TObject.cxx:757; TObject::Writevirtual Int_t Write(const char *name=nullptr, Int_t option=0, Int_t bufsize=0)Write this object to the current directory.Definition TObject.cxx:886; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::SetUniqueIDvirtual void SetUniqueID(UInt_t uid)Set t",MatchSource.WIKI,doc/master/TGeoVolume_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoVolume_8cxx_source.html
https://root.cern/doc/master/TGeoVolume_8cxx_source.html:160502,Integrability,message,message,160502,"ject.h:199; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:213; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::SavePrimitivevirtual void SavePrimitive(std::ostream &out, Option_t *option="""")Save a primitive as a C++ statement(s) on output stream ""out"".Definition TObject.cxx:757; TObject::Writevirtual Int_t Write(const char *name=nullptr, Int_t option=0, Int_t bufsize=0)Write this object to the current directory.Definition TObject.cxx:886; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::SetUniqueIDvirtual void SetUniqueID(UInt_t uid)Set the unique object id.Definition TObject.cxx:797; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TSeqCollectionSequenceable collection abstract base class.Definition TSeqCollection.h:28; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::StripTSubString Strip(EStripType s=kTrailing, char c=' ') constReturn a substring of self stripped at beginning and/or end.Definition TString.cxx:1163; TString::Dataconst char * Data() constDefinition TString.h:376; TStr",MatchSource.WIKI,doc/master/TGeoVolume_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoVolume_8cxx_source.html
https://root.cern/doc/master/TGeoVolume_8cxx_source.html:160638,Integrability,message,message,160638,"ect.cxx:213; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::SavePrimitivevirtual void SavePrimitive(std::ostream &out, Option_t *option="""")Save a primitive as a C++ statement(s) on output stream ""out"".Definition TObject.cxx:757; TObject::Writevirtual Int_t Write(const char *name=nullptr, Int_t option=0, Int_t bufsize=0)Write this object to the current directory.Definition TObject.cxx:886; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::SetUniqueIDvirtual void SetUniqueID(UInt_t uid)Set the unique object id.Definition TObject.cxx:797; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TSeqCollectionSequenceable collection abstract base class.Definition TSeqCollection.h:28; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::StripTSubString Strip(EStripType s=kTrailing, char c=' ') constReturn a substring of self stripped at beginning and/or end.Definition TString.cxx:1163; TString::Dataconst char * Data() constDefinition TString.h:376; TString::CapacitySsiz_t Capacity() constDefinition TString.h:364; TString::IsNullBool_t IsNull() constDefinition TString.h:414; TString::",MatchSource.WIKI,doc/master/TGeoVolume_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoVolume_8cxx_source.html
https://root.cern/doc/master/TGeoVolume_8cxx_source.html:160941,Integrability,message,message,160941,"on TObject.cxx:757; TObject::Writevirtual Int_t Write(const char *name=nullptr, Int_t option=0, Int_t bufsize=0)Write this object to the current directory.Definition TObject.cxx:886; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::SetUniqueIDvirtual void SetUniqueID(UInt_t uid)Set the unique object id.Definition TObject.cxx:797; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TSeqCollectionSequenceable collection abstract base class.Definition TSeqCollection.h:28; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::StripTSubString Strip(EStripType s=kTrailing, char c=' ') constReturn a substring of self stripped at beginning and/or end.Definition TString.cxx:1163; TString::Dataconst char * Data() constDefinition TString.h:376; TString::CapacitySsiz_t Capacity() constDefinition TString.h:364; TString::IsNullBool_t IsNull() constDefinition TString.h:414; TString::RemoveTString & Remove(Ssiz_t pos)Definition TString.h:685; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TString::Formvoid Form(const char *fmt,...)Formats a string usi",MatchSource.WIKI,doc/master/TGeoVolume_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoVolume_8cxx_source.html
https://root.cern/doc/master/TGeoVolume_8cxx_source.html:2380,Modifiability,inherit,inherits,2380,"nique volume object, but may also represent more general a family (class); 25of volume objects having the same shape type and medium, but possibly; 26different shape parameters. It is the user's task to provide different names; 27for different volume families in order to avoid ambiguities at tracking time.; 28A generic family rather than a single volume is created only in two cases :; 29when a generic shape is provided to the volume constructor or when a division; 30operation is applied. Each volume in the geometry stores an unique; 31ID corresponding to its family. In order to ease-up their creation, the manager; 32class is providing an API that allows making a shape and a volume in a single step.; 33 ; 34 Volumes are objects that can be visualized, therefore having visibility,; 35colour, line and fill attributes that can be defined or modified any time after; 36the volume creation. It is advisable however to define these properties just; 37after the first creation of a volume namespace, since in case of volume families; 38any new member created by the modeler inherits these properties.; 39 ; 40 In order to provide navigation features, volumes have to be able to find; 41the proper container of any point defined in the local reference frame. This; 42can be the volume itself, one of its positioned daughter volumes or none if; 43the point is actually outside. On the other hand, volumes have to provide also; 44other navigation methods such as finding the distances to its shape boundaries; 45or which daughter will be crossed first. The implementation of these features; 46is done at shape level, but the local mother-daughters management is handled; 47by volumes that builds additional optimisation structures upon geometry closure.; 48In order to have navigation features properly working one has to follow the; 49general rules for building a valid geometry (see TGeoManager class).; 50 ; 51 Now let's make a simple volume representing a copper wire. We suppose that; 52a mediu",MatchSource.WIKI,doc/master/TGeoVolume_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoVolume_8cxx_source.html
https://root.cern/doc/master/TGeoVolume_8cxx_source.html:160348,Modifiability,inherit,inherits,160348,"d(TObject *obj) overrideDefinition TObjArray.h:68; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:213; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::SavePrimitivevirtual void SavePrimitive(std::ostream &out, Option_t *option="""")Save a primitive as a C++ statement(s) on output stream ""out"".Definition TObject.cxx:757; TObject::Writevirtual Int_t Write(const char *name=nullptr, Int_t option=0, Int_t bufsize=0)Write this object to the current directory.Definition TObject.cxx:886; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::SetUniqueIDvirtual void SetUniqueID(UInt_t uid)Set the unique object id.Definition TObject.cxx:797; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TSeqCollectionSequenceable collection abstract base class.Definition TSeqCollection.h:28; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::StripTSubString Strip(EStripType",MatchSource.WIKI,doc/master/TGeoVolume_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoVolume_8cxx_source.html
https://root.cern/doc/master/TGeoVolume_8cxx_source.html:10933,Performance,optimiz,optimization,10933,"_CO_2. We will; 189want now to place symmetrically 1000 chambers on a pad, following a pattern; 190of 20 rows and 50 columns. One way to do this will be to replicate our chamber; 191by positioning it 1000 times in different positions of the pad. Unfortunately,; 192this is far from being the optimal way of doing what we want.; 193Imagine that we would like to find out which of the 1000 chambers is containing; 194a (x,y,z) point defined in the pad reference. You will never have to do that,; 195since the modeller will take care of it for you, but let's guess what it has; 196to do. The most simple algorithm will just loop over all daughters, convert; 197the point from mother to local reference and check if the current chamber; 198contains the point or not. This might be efficient for pads with few chambers,; 199but definitely not for 1000. Fortunately the modeler is smarter than that and; 200create for each volume some optimization structures called voxels (see Voxelization); 201to minimize the penalty having too many daughters, but if you have 100 pads like; 202this in your geometry you will anyway loose a lot in your tracking performance.; 203 ; 204 The way out when volumes can be arranged according to simple patterns is the; 205usage of divisions. We will describe them in detail later on. Let's think now; 206at a different situation : instead of 1000 chambers of the same type, we may; 207have several types of chambers. Let's say all chambers are cylindrical and have; 208a wire inside, but their dimensions are different. However, we would like all; 209to be represented by a single volume family, since they have the same properties.; 210*/; 211 ; 212/** \class TGeoVolumeMulti; 213\ingroup Geometry_classes; 214 ; 215Volume families; 216 ; 217A volume family is represented by the class TGeoVolumeMulti. It represents; 218a class of volumes having the same shape type and each member will be; 219identified by the same name and volume ID. Any operation applied to a; 220TGeoVo",MatchSource.WIKI,doc/master/TGeoVolume_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoVolume_8cxx_source.html
https://root.cern/doc/master/TGeoVolume_8cxx_source.html:11146,Performance,perform,performance,11146,"_CO_2. We will; 189want now to place symmetrically 1000 chambers on a pad, following a pattern; 190of 20 rows and 50 columns. One way to do this will be to replicate our chamber; 191by positioning it 1000 times in different positions of the pad. Unfortunately,; 192this is far from being the optimal way of doing what we want.; 193Imagine that we would like to find out which of the 1000 chambers is containing; 194a (x,y,z) point defined in the pad reference. You will never have to do that,; 195since the modeller will take care of it for you, but let's guess what it has; 196to do. The most simple algorithm will just loop over all daughters, convert; 197the point from mother to local reference and check if the current chamber; 198contains the point or not. This might be efficient for pads with few chambers,; 199but definitely not for 1000. Fortunately the modeler is smarter than that and; 200create for each volume some optimization structures called voxels (see Voxelization); 201to minimize the penalty having too many daughters, but if you have 100 pads like; 202this in your geometry you will anyway loose a lot in your tracking performance.; 203 ; 204 The way out when volumes can be arranged according to simple patterns is the; 205usage of divisions. We will describe them in detail later on. Let's think now; 206at a different situation : instead of 1000 chambers of the same type, we may; 207have several types of chambers. Let's say all chambers are cylindrical and have; 208a wire inside, but their dimensions are different. However, we would like all; 209to be represented by a single volume family, since they have the same properties.; 210*/; 211 ; 212/** \class TGeoVolumeMulti; 213\ingroup Geometry_classes; 214 ; 215Volume families; 216 ; 217A volume family is represented by the class TGeoVolumeMulti. It represents; 218a class of volumes having the same shape type and each member will be; 219identified by the same name and volume ID. Any operation applied to a; 220TGeoVo",MatchSource.WIKI,doc/master/TGeoVolume_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoVolume_8cxx_source.html
https://root.cern/doc/master/TGeoVolume_8cxx_source.html:16079,Performance,perform,performed,16079,"EX"", 1, N);; 300~~~; 301 ; 302where SLICE is the name of the new family representing all slices and 1 is the; 303slicing axis. The meaning of the axis index is the following: for all volumes; 304having shapes like box, trd1, trd2, trap, gtra or para - 1,2,3 means X,Y,Z; for; 305tube, tubs, cone, cons - 1 means Rxy, 2 means phi and 3 means Z; for pcon and; 306pgon - 2 means phi and 3 means Z; for spheres 1 means R and 2 means phi.; 307 In fact, the division operation has the same effect as positioning volumes; 308in a given order inside the divided container - the advantage being that the; 309navigation in such a structure is much faster. When a volume is divided, a; 310volume family corresponding to the slices is created. In case all slices can; 311be represented by a single shape, only one volume is added to the family and; 312positioned N times inside the divided volume, otherwise, each slice will be; 313represented by a distinct volume in the family.; 314 Divisions can be also performed in a given range of one axis. For that, one; 315have to specify also the starting coordinate value and the step:; 316 ; 317~~~ {.cpp}; 318 TGeoVolume *slicex = box->Divide(""SLICEX"", 1, N, start, step);; 319~~~; 320 ; 321A check is always done on the resulting division range : if not fitting into; 322the container limits, an error message is posted. If we will browse the divided; 323volume we will notice that it will contain N nodes starting with index 1 upto; 324N. The first one has the lower X limit at START position, while the last one; 325will have the upper X limit at START+N*STEP. The resulting slices cannot; 326be positioned inside an other volume (they are by default positioned inside the; 327divided one) but can be further divided and may contain other volumes:; 328 ; 329~~~ {.cpp}; 330 TGeoVolume *slicey = slicex->Divide(""SLICEY"", 2, N1);; 331 slicey->AddNode(other_vol, index, some_matrix);; 332~~~; 333 ; 334 When doing that, we have to remember that SLICEY represents a fa",MatchSource.WIKI,doc/master/TGeoVolume_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoVolume_8cxx_source.html
https://root.cern/doc/master/TGeoVolume_8cxx_source.html:19258,Performance,optimiz,optimized,19258,"4 ; 355 The GEANT3 option MANY is supported by TGeoVolumeOverlap class. An overlapping; 356volume is in fact a virtual container that does not represent a physical object.; 357It contains a list of nodes that are not its daughters but that must be checked; 358always before the container itself. This list must be defined by users and it; 359is checked and resolved in a priority order. Note that the feature is non-standard; 360to geometrical modelers and it was introduced just to support conversions of; 361GEANT3 geometries, therefore its extensive usage should be avoided.; 362*/; 363 ; 364/** \class TGeoVolumeAssembly; 365\ingroup Geometry_classes; 366 ; 367Volume assemblies; 368 ; 369Assemblies a volumes that have neither a shape or a material/medium. Assemblies; 370behave exactly like normal volumes grouping several daughters together, but; 371the daughters can never extrude the assembly since this has no shape. However,; 372a bounding box and a voxelization structure are built for assemblies as for; 373normal volumes, so that navigation is still optimized. Assemblies are useful; 374for grouping hierarchically volumes which are otherwise defined in a flat; 375manner, but also to avoid clashes between container shapes.; 376To define an assembly one should just input a name, then start adding other; 377volumes (or volume assemblies) as content.; 378*/; 379 ; 380#include <fstream>; 381#include <iomanip>; 382 ; 383#include ""TString.h""; 384#include ""TBuffer.h""; 385#include ""TBrowser.h""; 386#include ""TStyle.h""; 387#include ""TH2F.h""; 388#include ""TROOT.h""; 389#include ""TEnv.h""; 390#include ""TMap.h""; 391#include ""TFile.h""; 392#include ""TKey.h""; 393 ; 394#include ""TGeoManager.h""; 395#include ""TGeoNode.h""; 396#include ""TGeoMatrix.h""; 397#include ""TVirtualGeoPainter.h""; 398#include ""TGeoVolume.h""; 399#include ""TGeoShapeAssembly.h""; 400#include ""TGeoScaledShape.h""; 401#include ""TGeoCompositeShape.h""; 402#include ""TGeoVoxelFinder.h""; 403#include ""TGeoExtension.h""; 404 ; 405Clas",MatchSource.WIKI,doc/master/TGeoVolume_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoVolume_8cxx_source.html
https://root.cern/doc/master/TGeoVolume_8cxx_source.html:54931,Performance,perform,perform,54931,"////////////; 1390/// Draw random points in the bounding box of this volume.; 1391 ; 1392void TGeoVolume::RandomPoints(Int_t npoints, Option_t *option); 1393{; 1394 if (gGeoManager != fGeoManager); 1395 gGeoManager = fGeoManager;; 1396 TGeoVolume *old_vol = fGeoManager->GetTopVolume();; 1397 if (old_vol != this); 1398 fGeoManager->SetTopVolume(this);; 1399 else; 1400 old_vol = nullptr;; 1401 fGeoManager->RandomPoints(this, npoints, option);; 1402 if (old_vol); 1403 fGeoManager->SetTopVolume(old_vol);; 1404}; 1405 ; 1406////////////////////////////////////////////////////////////////////////////////; 1407/// Random raytracing method.; 1408 ; 1409void TGeoVolume::RandomRays(Int_t nrays, Double_t startx, Double_t starty, Double_t startz, const char *target_vol,; 1410 Bool_t check_norm); 1411{; 1412 if (gGeoManager != fGeoManager); 1413 gGeoManager = fGeoManager;; 1414 TGeoVolume *old_vol = fGeoManager->GetTopVolume();; 1415 if (old_vol != this); 1416 fGeoManager->SetTopVolume(this);; 1417 else; 1418 old_vol = nullptr;; 1419 fGeoManager->RandomRays(nrays, startx, starty, startz, target_vol, check_norm);; 1420 if (old_vol); 1421 fGeoManager->SetTopVolume(old_vol);; 1422}; 1423 ; 1424////////////////////////////////////////////////////////////////////////////////; 1425/// Draw this volume with current settings and perform raytracing in the pad.; 1426 ; 1427void TGeoVolume::Raytrace(Bool_t flag); 1428{; 1429 TGeoAtt::SetVisRaytrace(kFALSE);; 1430 if (gGeoManager != fGeoManager); 1431 gGeoManager = fGeoManager;; 1432 TVirtualGeoPainter *painter = fGeoManager->GetGeomPainter();; 1433 Bool_t drawn = (painter->GetDrawnVolume() == this) ? kTRUE : kFALSE;; 1434 if (!drawn) {; 1435 painter->DrawVolume(this, """");; 1436 TGeoAtt::SetVisRaytrace(flag);; 1437 painter->ModifiedPad();; 1438 return;; 1439 }; 1440 TGeoAtt::SetVisRaytrace(flag);; 1441 painter->ModifiedPad();; 1442}; 1443 ; 1444////////////////////////////////////////////////////////////////////////////////; 1445/// Save ge",MatchSource.WIKI,doc/master/TGeoVolume_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoVolume_8cxx_source.html
https://root.cern/doc/master/TGeoVolume_8cxx_source.html:68743,Performance,optimiz,optimization,68743,"llptr;; 1766 return (char *)painter->GetVolumeInfo(vol, px, py);; 1767}; 1768 ; 1769////////////////////////////////////////////////////////////////////////////////; 1770/// Returns true if cylindrical voxelization is optimal.; 1771 ; 1772Bool_t TGeoVolume::GetOptimalVoxels() const; 1773{; 1774 Int_t nd = GetNdaughters();; 1775 if (!nd); 1776 return kFALSE;; 1777 Int_t id;; 1778 Int_t ncyl = 0;; 1779 TGeoNode *node;; 1780 for (id = 0; id < nd; id++) {; 1781 node = (TGeoNode *)fNodes->At(id);; 1782 ncyl += node->GetOptimalVoxels();; 1783 }; 1784 if (ncyl > (nd / 2)); 1785 return kTRUE;; 1786 return kFALSE;; 1787}; 1788 ; 1789////////////////////////////////////////////////////////////////////////////////; 1790/// Provide a pointer name containing uid.; 1791 ; 1792const char *TGeoVolume::GetPointerName() const; 1793{; 1794 static TString name;; 1795 name.Form(""p%s_%zx"", GetName(), (size_t)this);; 1796 return name.Data();; 1797}; 1798 ; 1799////////////////////////////////////////////////////////////////////////////////; 1800/// Getter for optimization structure.; 1801 ; 1802TGeoVoxelFinder *TGeoVolume::GetVoxels() const; 1803{; 1804 if (fVoxels && !fVoxels->IsInvalid()); 1805 return fVoxels;; 1806 return nullptr;; 1807}; 1808 ; 1809////////////////////////////////////////////////////////////////////////////////; 1810/// Move perspective view focus to this volume; 1811 ; 1812void TGeoVolume::GrabFocus(); 1813{; 1814 TVirtualGeoPainter *painter = fGeoManager->GetPainter();; 1815 if (painter); 1816 painter->GrabFocus();; 1817}; 1818 ; 1819////////////////////////////////////////////////////////////////////////////////; 1820/// Returns true if the volume is an assembly or a scaled assembly.; 1821 ; 1822Bool_t TGeoVolume::IsAssembly() const; 1823{; 1824 return fShape->IsAssembly();; 1825}; 1826 ; 1827////////////////////////////////////////////////////////////////////////////////; 1828/// Clone this volume.; 1829/// build a volume with same name, shape and medium; 1830 ; 18",MatchSource.WIKI,doc/master/TGeoVolume_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoVolume_8cxx_source.html
https://root.cern/doc/master/TGeoVolume_8cxx_source.html:140830,Performance,perform,perform,140830,"ion TGeoVolume.cxx:2409; TGeoVolume::IsAllInvisibleBool_t IsAllInvisible() constReturn TRUE if volume and all daughters are invisible.Definition TGeoVolume.cxx:781; TGeoVolume::fNtotalInt_t fNtotalDefinition TGeoVolume.h:56; TGeoVolume::MakeCopyNodesvoid MakeCopyNodes(const TGeoVolume *other)make a new list of nodes and copy all nodes of other volume insideDefinition TGeoVolume.cxx:1908; TGeoVolume::SetUserExtensionvoid SetUserExtension(TGeoExtension *ext)Connect user-defined extension to the volume.Definition TGeoVolume.cxx:1480; TGeoVolume::GrabFWExtensionTGeoExtension * GrabFWExtension() constGet a copy of the framework extension pointer.Definition TGeoVolume.cxx:1525; TGeoVolume::SetNumbervoid SetNumber(Int_t number)Definition TGeoVolume.h:245; TGeoVolume::ClearNodesvoid ClearNodes()Definition TGeoVolume.h:95; TGeoVolume::SetLineWidthvoid SetLineWidth(Width_t lwidth) overrideSet the line width.Definition TGeoVolume.cxx:2185; TGeoVolume::Raytracevoid Raytrace(Bool_t flag=kTRUE)Draw this volume with current settings and perform raytracing in the pad.Definition TGeoVolume.cxx:1427; TGeoVolume::RandomRaysvoid RandomRays(Int_t nrays=10000, Double_t startx=0, Double_t starty=0, Double_t startz=0, const char *target_vol=nullptr, Bool_t check_norm=kFALSE)Random raytracing method.Definition TGeoVolume.cxx:1409; TGeoVolume::TGeoVolumeTGeoVolume()dummy constructorDefinition TGeoVolume.cxx:453; TGeoVolume::GetMediumTGeoMedium * GetMedium() constDefinition TGeoVolume.h:175; TGeoVolume::GetObjectInfochar * GetObjectInfo(Int_t px, Int_t py) const overrideGet volume info for the browser.Definition TGeoVolume.cxx:1760; TGeoVolume::Printvoid Print(Option_t *option="""") const overridePrint volume info.Definition TGeoVolume.cxx:1257; TGeoVolume::CloneNodesAndConnectvoid CloneNodesAndConnect(TGeoVolume *newmother) constClone the array of nodes.Definition TGeoVolume.cxx:1880; TGeoVolume::SortNodesvoid SortNodes()sort nodes by decreasing volume of the bounding box.Definition TGeoVolume.",MatchSource.WIKI,doc/master/TGeoVolume_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoVolume_8cxx_source.html
https://root.cern/doc/master/TGeoVolume_8cxx_source.html:149566,Performance,optimiz,optimization,149566,"but possibly a new shape,...Definition TGeoVolume.cxx:2269; TGeoVolume::InvisibleAllvoid InvisibleAll(Bool_t flag=kTRUE)Make volume and each of it daughters (in)visible.Definition TGeoVolume.cxx:795; TGeoVolume::IsVisibleDaughtersBool_t IsVisibleDaughters() constDefinition TGeoVolume.h:156; TGeoVolume::fOptionTString fOptionjust a hook for nowDefinition TGeoVolume.h:54; TGeoVolume::GetIndexInt_t GetIndex(const TGeoNode *node) constget index number for a given daughterDefinition TGeoVolume.cxx:1743; TGeoVolume::SetNodesvoid SetNodes(TObjArray *nodes)Definition TGeoVolume.h:223; TGeoVolume::GetFinderTGeoPatternFinder * GetFinder() constDefinition TGeoVolume.h:177; TGeoVolume::PrintVoxelsvoid PrintVoxels() constPrint the voxels for this volume.Definition TGeoVolume.cxx:1282; TGeoVolume::fUserExtensionTGeoExtension * fUserExtensionDefinition TGeoVolume.h:59; TGeoVolume::SetMediumvirtual void SetMedium(TGeoMedium *medium)Definition TGeoVolume.h:242; TGeoVolume::GetVoxelsTGeoVoxelFinder * GetVoxels() constGetter for optimization structure.Definition TGeoVolume.cxx:1802; TGeoVolume::SetAttVisibilityvoid SetAttVisibility(Bool_t vis)Definition TGeoVolume.h:233; TGeoVolume::~TGeoVolume~TGeoVolume() overrideDestructor.Definition TGeoVolume.cxx:510; TGeoVolume::SetShapevoid SetShape(const TGeoShape *shape)set the shape associated with this volumeDefinition TGeoVolume.cxx:2067; TGeoVolume::DummyMediumstatic TGeoMedium * DummyMedium()Definition TGeoVolume.cxx:445; TGeoVolume::fFieldTObject * fFieldpointer to TGeoManager owning this volumeDefinition TGeoVolume.h:53; TGeoVolume::SetLineColorvoid SetLineColor(Color_t lcolor) overrideSet the line color.Definition TGeoVolume.cxx:2169; TGeoVolume::GetNumberInt_t GetNumber() constDefinition TGeoVolume.h:184; TGeoVolume::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave a primitive as a C++ statement(s) on output stream ""out"".Definition TGeoVolume.cxx:1535; TGeoVolume::CleanAllvoid CleanAll()Clean data o",MatchSource.WIKI,doc/master/TGeoVolume_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoVolume_8cxx_source.html
https://root.cern/doc/master/TGeoVolume_8cxx_source.html:1574,Safety,avoid,avoid,1574,"or the list of contributors see $ROOTSYS/README/CREDITS. *; 11 *************************************************************************/; 12 ; 13/** \class TGeoVolume; 14\ingroup Shapes_classes; 15 ; 16TGeoVolume, TGeoVolumeMulti, TGeoVolumeAssembly are the volume classes; 17 ; 18 Volumes are the basic objects used in building the geometrical hierarchy.; 19They represent unpositioned objects but store all information about the; 20placement of the other volumes they may contain. Therefore a volume can; 21be replicated several times in the geometry. In order to create a volume, one; 22has to put together a shape and a medium which are already defined. Volumes; 23have to be named by users at creation time. Every different name may represent a; 24an unique volume object, but may also represent more general a family (class); 25of volume objects having the same shape type and medium, but possibly; 26different shape parameters. It is the user's task to provide different names; 27for different volume families in order to avoid ambiguities at tracking time.; 28A generic family rather than a single volume is created only in two cases :; 29when a generic shape is provided to the volume constructor or when a division; 30operation is applied. Each volume in the geometry stores an unique; 31ID corresponding to its family. In order to ease-up their creation, the manager; 32class is providing an API that allows making a shape and a volume in a single step.; 33 ; 34 Volumes are objects that can be visualized, therefore having visibility,; 35colour, line and fill attributes that can be defined or modified any time after; 36the volume creation. It is advisable however to define these properties just; 37after the first creation of a volume namespace, since in case of volume families; 38any new member created by the modeler inherits these properties.; 39 ; 40 In order to provide navigation features, volumes have to be able to find; 41the proper container of any point defined in the loc",MatchSource.WIKI,doc/master/TGeoVolume_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoVolume_8cxx_source.html
https://root.cern/doc/master/TGeoVolume_8cxx_source.html:9544,Safety,detect,detector,9544,"s ONLY and the others; 161MANY as in GEANT3, where this concept was introduced:; 162 1. The part of a MANY node B extruding its container A will never be ""seen""; 163during navigation, as if B was in fact the result of the intersection of A and B.; 164 2. If we have two nodes A (ONLY) and B (MANY) inside the same container, all; 165points in the overlapping region of A and B will be designated as belonging to A.; 166 3. If A an B in the above case were both MANY, points in the overlapping; 167part will be designated to the one defined first. Both nodes must have the; 168same medium.; 169 4. The slices of a divided MANY will be as well MANY.; 170 ; 171One needs to know that navigation inside geometry parts MANY nodes is much; 172slower. Any overlapping part can be defined based on composite shapes - this; 173is always recommended.; 174 ; 175### Replicating volumes; 176 ; 177 What can we do if our chamber contains two identical wires instead of one ?; 178What if then we would need 1000 chambers in our detector ? Should we create; 1792000 wires and 1000 chamber volumes ? No, we will just need to replicate the; 180ones that we have already created.; 181 ; 182~~~ {.cpp}; 183 chamber->AddNode(wire_co, 1, new TGeoTranslation(-0.2,0,0));; 184 chamber->AddNode(wire_co, 2, new TGeoTranslation(0.2,0,0));; 185~~~; 186 ; 187 The 2 nodes that we have created inside chamber will both point to a wire_co; 188object, but will be completely distinct : WIRE_CO_1 and WIRE_CO_2. We will; 189want now to place symmetrically 1000 chambers on a pad, following a pattern; 190of 20 rows and 50 columns. One way to do this will be to replicate our chamber; 191by positioning it 1000 times in different positions of the pad. Unfortunately,; 192this is far from being the optimal way of doing what we want.; 193Imagine that we would like to find out which of the 1000 chambers is containing; 194a (x,y,z) point defined in the pad reference. You will never have to do that,; 195since the modeller will take c",MatchSource.WIKI,doc/master/TGeoVolume_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoVolume_8cxx_source.html
https://root.cern/doc/master/TGeoVolume_8cxx_source.html:18763,Safety,avoid,avoided,18763,"ly (e.g. slicey). This should be done as if the coordinate system; 344of the generic slice was the same as the one of the divided volume. The generic; 345slice in case of PHI division is centered with respect to X axis. If the; 346family contains slices of different sizes, any volume positioned inside should; 347fit into the smallest one.; 348 Examples for specific divisions according to shape types can be found inside; 349shape classes.; 350 ; 351~~~ {.cpp}; 352 TGeoVolume::Divide(N, Xmin, Xmax, ""X"");; 353~~~; 354 ; 355 The GEANT3 option MANY is supported by TGeoVolumeOverlap class. An overlapping; 356volume is in fact a virtual container that does not represent a physical object.; 357It contains a list of nodes that are not its daughters but that must be checked; 358always before the container itself. This list must be defined by users and it; 359is checked and resolved in a priority order. Note that the feature is non-standard; 360to geometrical modelers and it was introduced just to support conversions of; 361GEANT3 geometries, therefore its extensive usage should be avoided.; 362*/; 363 ; 364/** \class TGeoVolumeAssembly; 365\ingroup Geometry_classes; 366 ; 367Volume assemblies; 368 ; 369Assemblies a volumes that have neither a shape or a material/medium. Assemblies; 370behave exactly like normal volumes grouping several daughters together, but; 371the daughters can never extrude the assembly since this has no shape. However,; 372a bounding box and a voxelization structure are built for assemblies as for; 373normal volumes, so that navigation is still optimized. Assemblies are useful; 374for grouping hierarchically volumes which are otherwise defined in a flat; 375manner, but also to avoid clashes between container shapes.; 376To define an assembly one should just input a name, then start adding other; 377volumes (or volume assemblies) as content.; 378*/; 379 ; 380#include <fstream>; 381#include <iomanip>; 382 ; 383#include ""TString.h""; 384#include ""TBuffer.h""; ",MatchSource.WIKI,doc/master/TGeoVolume_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoVolume_8cxx_source.html
https://root.cern/doc/master/TGeoVolume_8cxx_source.html:19393,Safety,avoid,avoid,19393,"hysical object.; 357It contains a list of nodes that are not its daughters but that must be checked; 358always before the container itself. This list must be defined by users and it; 359is checked and resolved in a priority order. Note that the feature is non-standard; 360to geometrical modelers and it was introduced just to support conversions of; 361GEANT3 geometries, therefore its extensive usage should be avoided.; 362*/; 363 ; 364/** \class TGeoVolumeAssembly; 365\ingroup Geometry_classes; 366 ; 367Volume assemblies; 368 ; 369Assemblies a volumes that have neither a shape or a material/medium. Assemblies; 370behave exactly like normal volumes grouping several daughters together, but; 371the daughters can never extrude the assembly since this has no shape. However,; 372a bounding box and a voxelization structure are built for assemblies as for; 373normal volumes, so that navigation is still optimized. Assemblies are useful; 374for grouping hierarchically volumes which are otherwise defined in a flat; 375manner, but also to avoid clashes between container shapes.; 376To define an assembly one should just input a name, then start adding other; 377volumes (or volume assemblies) as content.; 378*/; 379 ; 380#include <fstream>; 381#include <iomanip>; 382 ; 383#include ""TString.h""; 384#include ""TBuffer.h""; 385#include ""TBrowser.h""; 386#include ""TStyle.h""; 387#include ""TH2F.h""; 388#include ""TROOT.h""; 389#include ""TEnv.h""; 390#include ""TMap.h""; 391#include ""TFile.h""; 392#include ""TKey.h""; 393 ; 394#include ""TGeoManager.h""; 395#include ""TGeoNode.h""; 396#include ""TGeoMatrix.h""; 397#include ""TVirtualGeoPainter.h""; 398#include ""TGeoVolume.h""; 399#include ""TGeoShapeAssembly.h""; 400#include ""TGeoScaledShape.h""; 401#include ""TGeoCompositeShape.h""; 402#include ""TGeoVoxelFinder.h""; 403#include ""TGeoExtension.h""; 404 ; 405ClassImp(TGeoVolume);; 406 ; 407TGeoMedium *TGeoVolume::fgDummyMedium = nullptr;; 408 ; 409/////////////////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TGeoVolume_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoVolume_8cxx_source.html
https://root.cern/doc/master/TGeoVolume_8cxx_source.html:28245,Testability,test,testNo,28245,"=\n"", GetName());; 626 }; 627 painter->CheckOverlaps(this, ovlp, option);; 628 // if (sampling) return;; 629 if (!fGeoManager->IsCheckingOverlaps()) {; 630 fGeoManager->SortOverlaps();; 631 TObjArray *overlaps = fGeoManager->GetListOfOverlaps();; 632 Int_t novlps = overlaps->GetEntriesFast();; 633 TNamed *obj;; 634 TString name;; 635 for (Int_t i = 0; i < novlps; i++) {; 636 obj = (TNamed *)overlaps->At(i);; 637 if (novlps < 1000); 638 name = TString::Format(""ov%03d"", i);; 639 else; 640 name = TString::Format(""ov%06d"", i);; 641 obj->SetName(name);; 642 }; 643 if (novlps); 644 Info(""CheckOverlaps"", ""Number of illegal overlaps/extrusions for volume %s: %d\n"", GetName(), novlps);; 645 }; 646}; 647 ; 648////////////////////////////////////////////////////////////////////////////////; 649/// Tests for checking the shape navigation algorithms. See TGeoShape::CheckShape(); 650 ; 651void TGeoVolume::CheckShape(Int_t testNo, Int_t nsamples, Option_t *option); 652{; 653 fShape->CheckShape(testNo, nsamples, option);; 654}; 655 ; 656////////////////////////////////////////////////////////////////////////////////; 657/// Clean data of the volume.; 658 ; 659void TGeoVolume::CleanAll(); 660{; 661 ClearNodes();; 662 ClearShape();; 663}; 664 ; 665////////////////////////////////////////////////////////////////////////////////; 666/// Clear the shape of this volume from the list held by the current manager.; 667 ; 668void TGeoVolume::ClearShape(); 669{; 670 fGeoManager->ClearShape(fShape);; 671}; 672 ; 673////////////////////////////////////////////////////////////////////////////////; 674/// check for negative parameters in shapes.; 675 ; 676void TGeoVolume::CheckShapes(); 677{; 678 if (fShape->IsRunTimeShape()) {; 679 Error(""CheckShapes"", ""volume %s has run-time shape"", GetName());; 680 InspectShape();; 681 return;; 682 }; 683 if (!fNodes); 684 return;; 685 Int_t nd = fNodes->GetEntriesFast();; 686 TGeoNode *node = nullptr;; 687 TGeoNode *new_node;; 688 const TGeoShape *shape = nul",MatchSource.WIKI,doc/master/TGeoVolume_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoVolume_8cxx_source.html
https://root.cern/doc/master/TGeoVolume_8cxx_source.html:28317,Testability,test,testNo,28317,"=\n"", GetName());; 626 }; 627 painter->CheckOverlaps(this, ovlp, option);; 628 // if (sampling) return;; 629 if (!fGeoManager->IsCheckingOverlaps()) {; 630 fGeoManager->SortOverlaps();; 631 TObjArray *overlaps = fGeoManager->GetListOfOverlaps();; 632 Int_t novlps = overlaps->GetEntriesFast();; 633 TNamed *obj;; 634 TString name;; 635 for (Int_t i = 0; i < novlps; i++) {; 636 obj = (TNamed *)overlaps->At(i);; 637 if (novlps < 1000); 638 name = TString::Format(""ov%03d"", i);; 639 else; 640 name = TString::Format(""ov%06d"", i);; 641 obj->SetName(name);; 642 }; 643 if (novlps); 644 Info(""CheckOverlaps"", ""Number of illegal overlaps/extrusions for volume %s: %d\n"", GetName(), novlps);; 645 }; 646}; 647 ; 648////////////////////////////////////////////////////////////////////////////////; 649/// Tests for checking the shape navigation algorithms. See TGeoShape::CheckShape(); 650 ; 651void TGeoVolume::CheckShape(Int_t testNo, Int_t nsamples, Option_t *option); 652{; 653 fShape->CheckShape(testNo, nsamples, option);; 654}; 655 ; 656////////////////////////////////////////////////////////////////////////////////; 657/// Clean data of the volume.; 658 ; 659void TGeoVolume::CleanAll(); 660{; 661 ClearNodes();; 662 ClearShape();; 663}; 664 ; 665////////////////////////////////////////////////////////////////////////////////; 666/// Clear the shape of this volume from the list held by the current manager.; 667 ; 668void TGeoVolume::ClearShape(); 669{; 670 fGeoManager->ClearShape(fShape);; 671}; 672 ; 673////////////////////////////////////////////////////////////////////////////////; 674/// check for negative parameters in shapes.; 675 ; 676void TGeoVolume::CheckShapes(); 677{; 678 if (fShape->IsRunTimeShape()) {; 679 Error(""CheckShapes"", ""volume %s has run-time shape"", GetName());; 680 InspectShape();; 681 return;; 682 }; 683 if (!fNodes); 684 return;; 685 Int_t nd = fNodes->GetEntriesFast();; 686 TGeoNode *node = nullptr;; 687 TGeoNode *new_node;; 688 const TGeoShape *shape = nul",MatchSource.WIKI,doc/master/TGeoVolume_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoVolume_8cxx_source.html
https://root.cern/doc/master/TGeoVolume_8cxx_source.html:132302,Testability,test,testNo,132302," TGeoShape::CreateThreadDatavirtual void CreateThreadData(Int_t)Definition TGeoShape.h:67; TGeoShape::IsValidBool_t IsValid() constDefinition TGeoShape.h:143; TGeoShape::GetAxisNamevirtual const char * GetAxisName(Int_t iaxis) const =0; TGeoShape::Dividevirtual TGeoVolume * Divide(TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step)=0; TGeoShape::IsCompositevirtual Bool_t IsComposite() constDefinition TGeoShape.h:130; TGeoShape::IsSameWithinTolerancestatic Bool_t IsSameWithinTolerance(Double_t a, Double_t b)Check if two numbers differ with less than a tolerance.Definition TGeoShape.cxx:338; TGeoShape::IsRunTimeShapeBool_t IsRunTimeShape() constDefinition TGeoShape.h:142; TGeoShape::ClearThreadDatavirtual void ClearThreadData() constDefinition TGeoShape.h:66; TGeoShape::GetPointerNameconst char * GetPointerName() constProvide a pointer name containing uid.Definition TGeoShape.cxx:746; TGeoShape::CheckShapevoid CheckShape(Int_t testNo, Int_t nsamples=10000, Option_t *option="""")Test for shape navigation methods.Definition TGeoShape.cxx:211; TGeoShape::IsValidBoxvirtual Bool_t IsValidBox() const =0; TGeoShape::GetByteCountvirtual Int_t GetByteCount() const =0; TGeoShape::GetNameconst char * GetName() const overrideGet the shape name.Definition TGeoShape.cxx:250; TGeoShape::ComputeBBoxvirtual void ComputeBBox()=0; TGeoShape::Capacityvirtual Double_t Capacity() const =0; TGeoShape::kGeoSavePrimitive@ kGeoSavePrimitiveDefinition TGeoShape.h:64; TGeoShape::kGeoBad@ kGeoBadDefinition TGeoShape.h:33; TGeoShape::GetMakeRuntimeShapevirtual TGeoShape * GetMakeRuntimeShape(TGeoShape *mother, TGeoMatrix *mat) const =0; TGeoShape::IsAssemblyvirtual Bool_t IsAssembly() constDefinition TGeoShape.h:129; TGeoShape::TestShapeBitBool_t TestShapeBit(UInt_t f) constDefinition TGeoShape.h:167; TGeoVolumeAssemblyVolume assemblies.Definition TGeoVolume.h:316; TGeoVolumeAssembly::MakeAssemblyFromVolumestatic TGeoVolumeAssembly * MakeAssemblyFromVolum",MatchSource.WIKI,doc/master/TGeoVolume_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoVolume_8cxx_source.html
https://root.cern/doc/master/TGeoVolume_8cxx_source.html:155225,Testability,test,testNo,155225,"verrideSet visibility for leaves.Definition TGeoVolume.cxx:2379; TGeoVolume::InspectShapevoid InspectShape() constDefinition TGeoVolume.h:195; TGeoVolume::IsFolderBool_t IsFolder() const overrideReturn TRUE if volume contains nodes.Definition TGeoVolume.cxx:823; TGeoVolume::FindNodeTGeoNode * FindNode(const char *name) constsearch a daughter inside the list of nodesDefinition TGeoVolume.cxx:1721; TGeoVolume::CheckOverlapsvoid CheckOverlaps(Double_t ovlp=0.1, Option_t *option="""") constOverlap checking tool.Definition TGeoVolume.cxx:611; TGeoVolume::SetOverlappingCandidatevoid SetOverlappingCandidate(Bool_t flag)Definition TGeoVolume.h:228; TGeoVolume::IsOverlappingCandidateBool_t IsOverlappingCandidate() constDefinition TGeoVolume.h:148; TGeoVolume::fRefCountInt_t fRefCountDefinition TGeoVolume.h:57; TGeoVolume::Streamervoid Streamer(TBuffer &) overrideStream an object of class TGeoVolume.Definition TGeoVolume.cxx:2136; TGeoVolume::CheckShapevoid CheckShape(Int_t testNo, Int_t nsamples=10000, Option_t *option="""")Tests for checking the shape navigation algorithms. See TGeoShape::CheckShape()Definition TGeoVolume.cxx:651; TGeoVoxelFinderFinder class handling voxels.Definition TGeoVoxelFinder.h:20; TGeoVoxelFinder::IsInvalidBool_t IsInvalid() constDefinition TGeoVoxelFinder.h:100; TGeoVoxelFinder::Printvoid Print(Option_t *option="""") const overridePrint the voxels.Definition TGeoVoxelFinder.cxx:2271; TGeoVoxelFinder::SetNeedRebuildvoid SetNeedRebuild(Bool_t flag=kTRUE)Definition TGeoVoxelFinder.h:107; TGeoVoxelFinder::Voxelizevirtual void Voxelize(Option_t *option="""")Voxelize attached volume according to option If the volume is an assembly, make sure the bbox is comp...Definition TGeoVoxelFinder.cxx:2419; TGeoVoxelFinder::FindOverlapsvirtual void FindOverlaps(Int_t inode) constcreate the list of nodes for which the bboxes overlap with inode's bboxDefinition TGeoVoxelFinder.cxx:329; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definitio",MatchSource.WIKI,doc/master/TGeoVolume_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoVolume_8cxx_source.html
https://root.cern/doc/master/TGeoVolume_8cxx_source.html:3234,Usability,simpl,simple,3234,"operties just; 37after the first creation of a volume namespace, since in case of volume families; 38any new member created by the modeler inherits these properties.; 39 ; 40 In order to provide navigation features, volumes have to be able to find; 41the proper container of any point defined in the local reference frame. This; 42can be the volume itself, one of its positioned daughter volumes or none if; 43the point is actually outside. On the other hand, volumes have to provide also; 44other navigation methods such as finding the distances to its shape boundaries; 45or which daughter will be crossed first. The implementation of these features; 46is done at shape level, but the local mother-daughters management is handled; 47by volumes that builds additional optimisation structures upon geometry closure.; 48In order to have navigation features properly working one has to follow the; 49general rules for building a valid geometry (see TGeoManager class).; 50 ; 51 Now let's make a simple volume representing a copper wire. We suppose that; 52a medium is already created (see TGeoMedium class on how to create media).; 53We will create a TUBE shape for our wire, having Rmin=0cm, Rmax=0.01cm; 54and a half-length dZ=1cm :; 55 ; 56~~~ {.cpp}; 57 TGeoTube *tube = new TGeoTube(""wire_tube"", 0, 0.01, 1);; 58~~~; 59 ; 60One may omit the name for the shape if no retrieving by name is further needed; 61during geometry building. The same shape can be shared by different volumes; 62having different names and materials. Now let's make the volume for our wire.; 63The prototype for volumes constructor looks like :; 64 ; 65 TGeoVolume::TGeoVolume(const char *name, TGeoShape *shape, TGeoMedium *med); 66 ; 67Since TGeoTube derives from the base shape class, we can provide it to the volume; 68constructor :; 69 ; 70~~~ {.cpp}; 71 TGeoVolume *wire_co = new TGeoVolume(""WIRE_CO"", tube, ptrCOPPER);; 72~~~; 73 ; 74Do not bother to delete neither the media, shapes or volumes that you have; 75create",MatchSource.WIKI,doc/master/TGeoVolume_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoVolume_8cxx_source.html
https://root.cern/doc/master/TGeoVolume_8cxx_source.html:5035,Usability,learn,learned,5035," the volume; 68constructor :; 69 ; 70~~~ {.cpp}; 71 TGeoVolume *wire_co = new TGeoVolume(""WIRE_CO"", tube, ptrCOPPER);; 72~~~; 73 ; 74Do not bother to delete neither the media, shapes or volumes that you have; 75created since all will be automatically cleaned on exit by the manager class.; 76If we would have taken a look inside TGeoManager::MakeTube() method, we would; 77have been able to create our wire with a single line :; 78 ; 79~~~ {.cpp}; 80 TGeoVolume *wire_co = gGeoManager->MakeTube(""WIRE_CO"", ptrCOPPER, 0, 0.01, 1);; 81~~~; 82 ; 83The same applies for all primitive shapes, for which there can be found; 84corresponding MakeSHAPE() methods. Their usage is much more convenient unless; 85a shape has to be shared between more volumes. Let's make now an aluminium wire; 86having the same shape, supposing that we have created the copper wire with the; 87line above :; 88 ; 89~~~ {.cpp}; 90 TGeoVolume *wire_al = new TGeoVolume(""WIRE_AL"", wire_co->GetShape(), ptrAL);; 91~~~; 92 ; 93Now that we have learned how to create elementary volumes, let's see how we; 94can create a geometrical hierarchy.; 95 ; 96 ; 97### Positioning volumes; 98 ; 99 When creating a volume one does not specify if this will contain or not other; 100volumes. Adding daughters to a volume implies creating those and adding them; 101one by one to the list of daughters. Since the volume has to know the position; 102of all its daughters, we will have to supply at the same time a geometrical; 103transformation with respect to its local reference frame for each of them.; 104The objects referencing a volume and a transformation are called NODES and; 105their creation is fully handled by the modeler. They represent the link; 106elements in the hierarchy of volumes. Nodes are unique and distinct geometrical; 107objects ONLY from their container point of view. Since volumes can be replicated; 108in the geometry, the same node may be found on different branches.; 109 ; 110\image html geom_t_example.png width=600",MatchSource.WIKI,doc/master/TGeoVolume_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoVolume_8cxx_source.html
https://root.cern/doc/master/TGeoVolume_8cxx_source.html:6756,Usability,simpl,simplicity,6756," represent the link; 106elements in the hierarchy of volumes. Nodes are unique and distinct geometrical; 107objects ONLY from their container point of view. Since volumes can be replicated; 108in the geometry, the same node may be found on different branches.; 109 ; 110\image html geom_t_example.png width=600px; 111 ; 112 An important observation is that volume objects are owned by the TGeoManager; 113class. This stores a list of all volumes in the geometry, that is cleaned; 114upon destruction.; 115 ; 116 Let's consider positioning now our wire in the middle of a gas chamber. We; 117need first to define the gas chamber :; 118 ; 119~~~ {.cpp}; 120 TGeoVolume *chamber = gGeoManager->MakeTube(""CHAMBER"", ptrGAS, 0, 1, 1);; 121~~~; 122 ; 123Now we can put the wire inside :; 124 ; 125~~~ {.cpp}; 126 chamber->AddNode(wire_co, 1);; 127~~~; 128 ; 129If we inspect now the chamber volume in a browser, we will notice that it has; 130one daughter. Of course the gas has some container also, but let's keep it like; 131that for the sake of simplicity. The full prototype of AddNode() is :; 132 ; 133~~~ {.cpp}; 134 TGeoVolume::AddNode(TGeoVolume *daughter, Int_t usernumber,; 135 TGeoMatrix *matrix=gGeoIdentity); 136~~~; 137 ; 138Since we did not supplied the third argument, the wire will be positioned with; 139an identity transformation inside the chamber. One will notice that the inner; 140radii of the wire and chamber are both zero - therefore, aren't the two volumes; 141overlapping ? The answer is no, the modeler is even relaying on the fact that; 142any daughter is fully contained by its mother. On the other hand, neither of; 143the nodes positioned inside a volume should overlap with each other. We will; 144see that there are allowed some exceptions to those rules.; 145 ; 146### Overlapping volumes; 147 ; 148 Positioning volumes that does not overlap their neighbours nor extrude; 149their container is sometimes quite strong constraint. Some parts of the geometry; 150might overla",MatchSource.WIKI,doc/master/TGeoVolume_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoVolume_8cxx_source.html
https://root.cern/doc/master/TGeoVolume_8cxx_source.html:10598,Usability,simpl,simple,10598,"ready created.; 181 ; 182~~~ {.cpp}; 183 chamber->AddNode(wire_co, 1, new TGeoTranslation(-0.2,0,0));; 184 chamber->AddNode(wire_co, 2, new TGeoTranslation(0.2,0,0));; 185~~~; 186 ; 187 The 2 nodes that we have created inside chamber will both point to a wire_co; 188object, but will be completely distinct : WIRE_CO_1 and WIRE_CO_2. We will; 189want now to place symmetrically 1000 chambers on a pad, following a pattern; 190of 20 rows and 50 columns. One way to do this will be to replicate our chamber; 191by positioning it 1000 times in different positions of the pad. Unfortunately,; 192this is far from being the optimal way of doing what we want.; 193Imagine that we would like to find out which of the 1000 chambers is containing; 194a (x,y,z) point defined in the pad reference. You will never have to do that,; 195since the modeller will take care of it for you, but let's guess what it has; 196to do. The most simple algorithm will just loop over all daughters, convert; 197the point from mother to local reference and check if the current chamber; 198contains the point or not. This might be efficient for pads with few chambers,; 199but definitely not for 1000. Fortunately the modeler is smarter than that and; 200create for each volume some optimization structures called voxels (see Voxelization); 201to minimize the penalty having too many daughters, but if you have 100 pads like; 202this in your geometry you will anyway loose a lot in your tracking performance.; 203 ; 204 The way out when volumes can be arranged according to simple patterns is the; 205usage of divisions. We will describe them in detail later on. Let's think now; 206at a different situation : instead of 1000 chambers of the same type, we may; 207have several types of chambers. Let's say all chambers are cylindrical and have; 208a wire inside, but their dimensions are different. However, we would like all; 209to be represented by a single volume family, since they have the same properties.; 210*/; 211 ; 2",MatchSource.WIKI,doc/master/TGeoVolume_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoVolume_8cxx_source.html
https://root.cern/doc/master/TGeoVolume_8cxx_source.html:11224,Usability,simpl,simple,11224," in different positions of the pad. Unfortunately,; 192this is far from being the optimal way of doing what we want.; 193Imagine that we would like to find out which of the 1000 chambers is containing; 194a (x,y,z) point defined in the pad reference. You will never have to do that,; 195since the modeller will take care of it for you, but let's guess what it has; 196to do. The most simple algorithm will just loop over all daughters, convert; 197the point from mother to local reference and check if the current chamber; 198contains the point or not. This might be efficient for pads with few chambers,; 199but definitely not for 1000. Fortunately the modeler is smarter than that and; 200create for each volume some optimization structures called voxels (see Voxelization); 201to minimize the penalty having too many daughters, but if you have 100 pads like; 202this in your geometry you will anyway loose a lot in your tracking performance.; 203 ; 204 The way out when volumes can be arranged according to simple patterns is the; 205usage of divisions. We will describe them in detail later on. Let's think now; 206at a different situation : instead of 1000 chambers of the same type, we may; 207have several types of chambers. Let's say all chambers are cylindrical and have; 208a wire inside, but their dimensions are different. However, we would like all; 209to be represented by a single volume family, since they have the same properties.; 210*/; 211 ; 212/** \class TGeoVolumeMulti; 213\ingroup Geometry_classes; 214 ; 215Volume families; 216 ; 217A volume family is represented by the class TGeoVolumeMulti. It represents; 218a class of volumes having the same shape type and each member will be; 219identified by the same name and volume ID. Any operation applied to a; 220TGeoVolume equally affects all volumes in that family. The creation of a; 221family is generally not a user task, but can be forced in particular cases:; 222 ; 223~~~ {.cpp}; 224 TGeoManager::Volume(const char *vnam",MatchSource.WIKI,doc/master/TGeoVolume_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoVolume_8cxx_source.html
https://root.cern/doc/master/TGeoVolume_8cxx_source.html:14711,Usability,simpl,simple,14711,"r to match one ore more container; 273limits. Suppose we want to position the same box inside 2 different volumes; 274and we want the Z size to match the one of each container:; 275 ; 276~~~ {.cpp}; 277 TGeoVolume *container1 = gGeoManager->MakeBox(""C1"", imed, 10,10,30);; 278 TGeoVolume *container2 = gGeoManager->MakeBox(""C2"", imed, 10,10,20);; 279 TGeoVolume *pvol = gGeoManager->MakeBox(""PVOL"", jmed, 3,3,-1);; 280 container1->AddNode(pvol, 1);; 281 container2->AddNode(pvol, 1);; 282~~~; 283 ; 284 Note that the third parameter of PVOL is negative, which does not make sense; 285as half-length on Z. This is interpreted as: when positioned, create a box; 286replacing all invalid parameters with the corresponding dimensions of the; 287container. This is also internally handled by the TGeoVolumeMulti class, which; 288does not need to be instantiated by users.; 289 ; 290### Dividing volumes; 291 ; 292 Volumes can be divided according a pattern. The most simple division can; 293be done along one axis, that can be: X, Y, Z, Phi, Rxy or Rxyz. Let's take; 294the most simple case: we would like to divide a box in N equal slices along X; 295coordinate, representing a new volume family. Supposing we already have created; 296the initial box, this can be done like:; 297 ; 298~~~ {.cpp}; 299 TGeoVolume *slicex = box->Divide(""SLICEX"", 1, N);; 300~~~; 301 ; 302where SLICE is the name of the new family representing all slices and 1 is the; 303slicing axis. The meaning of the axis index is the following: for all volumes; 304having shapes like box, trd1, trd2, trap, gtra or para - 1,2,3 means X,Y,Z; for; 305tube, tubs, cone, cons - 1 means Rxy, 2 means phi and 3 means Z; for pcon and; 306pgon - 2 means phi and 3 means Z; for spheres 1 means R and 2 means phi.; 307 In fact, the division operation has the same effect as positioning volumes; 308in a given order inside the divided container - the advantage being that the; 309navigation in such a structure is much faster. When a volume is div",MatchSource.WIKI,doc/master/TGeoVolume_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoVolume_8cxx_source.html
https://root.cern/doc/master/TGeoVolume_8cxx_source.html:14823,Usability,simpl,simple,14823,"d we want the Z size to match the one of each container:; 275 ; 276~~~ {.cpp}; 277 TGeoVolume *container1 = gGeoManager->MakeBox(""C1"", imed, 10,10,30);; 278 TGeoVolume *container2 = gGeoManager->MakeBox(""C2"", imed, 10,10,20);; 279 TGeoVolume *pvol = gGeoManager->MakeBox(""PVOL"", jmed, 3,3,-1);; 280 container1->AddNode(pvol, 1);; 281 container2->AddNode(pvol, 1);; 282~~~; 283 ; 284 Note that the third parameter of PVOL is negative, which does not make sense; 285as half-length on Z. This is interpreted as: when positioned, create a box; 286replacing all invalid parameters with the corresponding dimensions of the; 287container. This is also internally handled by the TGeoVolumeMulti class, which; 288does not need to be instantiated by users.; 289 ; 290### Dividing volumes; 291 ; 292 Volumes can be divided according a pattern. The most simple division can; 293be done along one axis, that can be: X, Y, Z, Phi, Rxy or Rxyz. Let's take; 294the most simple case: we would like to divide a box in N equal slices along X; 295coordinate, representing a new volume family. Supposing we already have created; 296the initial box, this can be done like:; 297 ; 298~~~ {.cpp}; 299 TGeoVolume *slicex = box->Divide(""SLICEX"", 1, N);; 300~~~; 301 ; 302where SLICE is the name of the new family representing all slices and 1 is the; 303slicing axis. The meaning of the axis index is the following: for all volumes; 304having shapes like box, trd1, trd2, trap, gtra or para - 1,2,3 means X,Y,Z; for; 305tube, tubs, cone, cons - 1 means Rxy, 2 means phi and 3 means Z; for pcon and; 306pgon - 2 means phi and 3 means Z; for spheres 1 means R and 2 means phi.; 307 In fact, the division operation has the same effect as positioning volumes; 308in a given order inside the divided container - the advantage being that the; 309navigation in such a structure is much faster. When a volume is divided, a; 310volume family corresponding to the slices is created. In case all slices can; 311be represented by a single ",MatchSource.WIKI,doc/master/TGeoVolume_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoVolume_8cxx_source.html
https://root.cern/doc/master/TGeoVolume_8cxx_source.html:86270,Usability,clear,clear,86270,"odeorig->MakeCopyNode();; 2298 if (!newnode) {; 2299 Fatal(""ReplaceNode"", ""Cannot make copy node for %s"", nodeorig->GetName());; 2300 return nullptr;; 2301 }; 2302 // Change the volume for the new node; 2303 newnode->SetVolume(vol);; 2304 // Replace the matrix; 2305 if (newpos && !nodeorig->IsOffset()) {; 2306 TGeoNodeMatrix *nodemat = (TGeoNodeMatrix *)newnode;; 2307 nodemat->SetMatrix(newpos);; 2308 }; 2309 // Replace nodeorig with new one; 2310 fNodes->RemoveAt(ind);; 2311 fNodes->AddAt(newnode, ind);; 2312 if (fVoxels); 2313 fVoxels->SetNeedRebuild();; 2314 if (IsAssembly()); 2315 fShape->ComputeBBox();; 2316 return newnode;; 2317}; 2318 ; 2319////////////////////////////////////////////////////////////////////////////////; 2320/// Select this volume as matching an arbitrary criteria. The volume is added to; 2321/// a static list and the flag TGeoVolume::kVolumeSelected is set. All flags need; 2322/// to be reset at the end by calling the method with CLEAR=true. This will also clear; 2323/// the list.; 2324 ; 2325void TGeoVolume::SelectVolume(Bool_t clear); 2326{; 2327 static TObjArray array(256);; 2328 static Int_t len = 0;; 2329 Int_t i;; 2330 TObject *vol;; 2331 if (clear) {; 2332 for (i = 0; i < len; i++) {; 2333 vol = array.At(i);; 2334 vol->ResetBit(TGeoVolume::kVolumeSelected);; 2335 }; 2336 array.Clear();; 2337 len = 0;; 2338 return;; 2339 }; 2340 SetBit(TGeoVolume::kVolumeSelected);; 2341 array.AddAtAndExpand(this, len++);; 2342}; 2343 ; 2344////////////////////////////////////////////////////////////////////////////////; 2345/// set visibility of this volume; 2346 ; 2347void TGeoVolume::SetVisibility(Bool_t vis); 2348{; 2349 TGeoAtt::SetVisibility(vis);; 2350 if (fGeoManager->IsClosed()); 2351 SetVisTouched(kTRUE);; 2352 fGeoManager->SetVisOption(4);; 2353 TSeqCollection *brlist = gROOT->GetListOfBrowsers();; 2354 TIter next(brlist);; 2355 TBrowser *browser = nullptr;; 2356 while ((browser = (TBrowser *)next())) {; 2357 browser->CheckObjectItem(this, v",MatchSource.WIKI,doc/master/TGeoVolume_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoVolume_8cxx_source.html
https://root.cern/doc/master/TGeoVolume_8cxx_source.html:86344,Usability,clear,clear,86344,"turn nullptr;; 2301 }; 2302 // Change the volume for the new node; 2303 newnode->SetVolume(vol);; 2304 // Replace the matrix; 2305 if (newpos && !nodeorig->IsOffset()) {; 2306 TGeoNodeMatrix *nodemat = (TGeoNodeMatrix *)newnode;; 2307 nodemat->SetMatrix(newpos);; 2308 }; 2309 // Replace nodeorig with new one; 2310 fNodes->RemoveAt(ind);; 2311 fNodes->AddAt(newnode, ind);; 2312 if (fVoxels); 2313 fVoxels->SetNeedRebuild();; 2314 if (IsAssembly()); 2315 fShape->ComputeBBox();; 2316 return newnode;; 2317}; 2318 ; 2319////////////////////////////////////////////////////////////////////////////////; 2320/// Select this volume as matching an arbitrary criteria. The volume is added to; 2321/// a static list and the flag TGeoVolume::kVolumeSelected is set. All flags need; 2322/// to be reset at the end by calling the method with CLEAR=true. This will also clear; 2323/// the list.; 2324 ; 2325void TGeoVolume::SelectVolume(Bool_t clear); 2326{; 2327 static TObjArray array(256);; 2328 static Int_t len = 0;; 2329 Int_t i;; 2330 TObject *vol;; 2331 if (clear) {; 2332 for (i = 0; i < len; i++) {; 2333 vol = array.At(i);; 2334 vol->ResetBit(TGeoVolume::kVolumeSelected);; 2335 }; 2336 array.Clear();; 2337 len = 0;; 2338 return;; 2339 }; 2340 SetBit(TGeoVolume::kVolumeSelected);; 2341 array.AddAtAndExpand(this, len++);; 2342}; 2343 ; 2344////////////////////////////////////////////////////////////////////////////////; 2345/// set visibility of this volume; 2346 ; 2347void TGeoVolume::SetVisibility(Bool_t vis); 2348{; 2349 TGeoAtt::SetVisibility(vis);; 2350 if (fGeoManager->IsClosed()); 2351 SetVisTouched(kTRUE);; 2352 fGeoManager->SetVisOption(4);; 2353 TSeqCollection *brlist = gROOT->GetListOfBrowsers();; 2354 TIter next(brlist);; 2355 TBrowser *browser = nullptr;; 2356 while ((browser = (TBrowser *)next())) {; 2357 browser->CheckObjectItem(this, vis);; 2358 browser->Refresh();; 2359 }; 2360}; 2361 ; 2362///////////////////////////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TGeoVolume_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoVolume_8cxx_source.html
https://root.cern/doc/master/TGeoVolume_8cxx_source.html:86466,Usability,clear,clear,86466,"turn nullptr;; 2301 }; 2302 // Change the volume for the new node; 2303 newnode->SetVolume(vol);; 2304 // Replace the matrix; 2305 if (newpos && !nodeorig->IsOffset()) {; 2306 TGeoNodeMatrix *nodemat = (TGeoNodeMatrix *)newnode;; 2307 nodemat->SetMatrix(newpos);; 2308 }; 2309 // Replace nodeorig with new one; 2310 fNodes->RemoveAt(ind);; 2311 fNodes->AddAt(newnode, ind);; 2312 if (fVoxels); 2313 fVoxels->SetNeedRebuild();; 2314 if (IsAssembly()); 2315 fShape->ComputeBBox();; 2316 return newnode;; 2317}; 2318 ; 2319////////////////////////////////////////////////////////////////////////////////; 2320/// Select this volume as matching an arbitrary criteria. The volume is added to; 2321/// a static list and the flag TGeoVolume::kVolumeSelected is set. All flags need; 2322/// to be reset at the end by calling the method with CLEAR=true. This will also clear; 2323/// the list.; 2324 ; 2325void TGeoVolume::SelectVolume(Bool_t clear); 2326{; 2327 static TObjArray array(256);; 2328 static Int_t len = 0;; 2329 Int_t i;; 2330 TObject *vol;; 2331 if (clear) {; 2332 for (i = 0; i < len; i++) {; 2333 vol = array.At(i);; 2334 vol->ResetBit(TGeoVolume::kVolumeSelected);; 2335 }; 2336 array.Clear();; 2337 len = 0;; 2338 return;; 2339 }; 2340 SetBit(TGeoVolume::kVolumeSelected);; 2341 array.AddAtAndExpand(this, len++);; 2342}; 2343 ; 2344////////////////////////////////////////////////////////////////////////////////; 2345/// set visibility of this volume; 2346 ; 2347void TGeoVolume::SetVisibility(Bool_t vis); 2348{; 2349 TGeoAtt::SetVisibility(vis);; 2350 if (fGeoManager->IsClosed()); 2351 SetVisTouched(kTRUE);; 2352 fGeoManager->SetVisOption(4);; 2353 TSeqCollection *brlist = gROOT->GetListOfBrowsers();; 2354 TIter next(brlist);; 2355 TBrowser *browser = nullptr;; 2356 while ((browser = (TBrowser *)next())) {; 2357 browser->CheckObjectItem(this, vis);; 2358 browser->Refresh();; 2359 }; 2360}; 2361 ; 2362///////////////////////////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TGeoVolume_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoVolume_8cxx_source.html
https://root.cern/doc/master/TGeoVolume_8cxx_source.html:104681,Usability,clear,clear,104681,///////////////////////////////////////////////////////////////////////////; 2870/// Destructor.; 2871 ; 2872TGeoVolumeAssembly::ThreadData_t::~ThreadData_t() {}; 2873 ; 2874////////////////////////////////////////////////////////////////////////////////; 2875 ; 2876TGeoVolumeAssembly::ThreadData_t &TGeoVolumeAssembly::GetThreadData() const; 2877{; 2878 Int_t tid = TGeoManager::ThreadId();; 2879 return *fThreadData[tid];; 2880}; 2881 ; 2882////////////////////////////////////////////////////////////////////////////////; 2883 ; 2884void TGeoVolumeAssembly::ClearThreadData() const; 2885{; 2886 std::lock_guard<std::mutex> guard(fMutex);; 2887 TGeoVolume::ClearThreadData();; 2888 std::vector<ThreadData_t *>::iterator i = fThreadData.begin();; 2889 while (i != fThreadData.end()) {; 2890 delete *i;; 2891 ++i;; 2892 }; 2893 fThreadData.clear();; 2894 fThreadSize = 0;; 2895}; 2896 ; 2897////////////////////////////////////////////////////////////////////////////////; 2898 ; 2899void TGeoVolumeAssembly::CreateThreadData(Int_t nthreads); 2900{; 2901 std::lock_guard<std::mutex> guard(fMutex);; 2902 // Create assembly thread data here; 2903 fThreadData.resize(nthreads);; 2904 fThreadSize = nthreads;; 2905 for (Int_t tid = 0; tid < nthreads; tid++) {; 2906 if (fThreadData[tid] == nullptr) {; 2907 fThreadData[tid] = new ThreadData_t;; 2908 }; 2909 }; 2910 TGeoVolume::CreateThreadData(nthreads);; 2911}; 2912 ; 2913////////////////////////////////////////////////////////////////////////////////; 2914 ; 2915Int_t TGeoVolumeAssembly::GetCurrentNodeIndex() const; 2916{; 2917 return fThreadData[TGeoManager::ThreadId()]->fCurrent;; 2918}; 2919 ; 2920////////////////////////////////////////////////////////////////////////////////; 2921 ; 2922Int_t TGeoVolumeAssembly::GetNextNodeIndex() const; 2923{; 2924 return fThreadData[TGeoManager::ThreadId()]->fNext;; 2925}; 2926 ; 2927////////////////////////////////////////////////////////////////////////////////; 2928 ; 2929void TGeoVolumeAssembl,MatchSource.WIKI,doc/master/TGeoVolume_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoVolume_8cxx_source.html
https://root.cern/doc/master/TGeoVolume_8cxx_source.html:146400,Usability,clear,clear,146400,"finition TGeoVolume.cxx:1812; TGeoVolume::UnmarkSavedvoid UnmarkSaved()Reset SavePrimitive bits.Definition TGeoVolume.cxx:1699; TGeoVolume::ExecuteEventvoid ExecuteEvent(Int_t event, Int_t px, Int_t py) overrideExecute mouse actions on this volume.Definition TGeoVolume.cxx:1710; TGeoVolume::CloneVolumevirtual TGeoVolume * CloneVolume() constClone this volume.Definition TGeoVolume.cxx:1831; TGeoVolume::SetFindervoid SetFinder(TGeoPatternFinder *finder)Definition TGeoVolume.h:244; TGeoVolume::GetNdaughtersInt_t GetNdaughters() constDefinition TGeoVolume.h:362; TGeoVolume::IsValidBool_t IsValid() constDefinition TGeoVolume.h:154; TGeoVolume::Grabvoid Grab()Definition TGeoVolume.h:136; TGeoVolume::CheckGeometryvoid CheckGeometry(Int_t nrays=1, Double_t startx=0, Double_t starty=0, Double_t startz=0) constShoot nrays with random directions from starting point (startx, starty, startz) in the reference fram...Definition TGeoVolume.cxx:588; TGeoVolume::SelectVolumevoid SelectVolume(Bool_t clear=kFALSE)Select this volume as matching an arbitrary criteria.Definition TGeoVolume.cxx:2325; TGeoVolume::GetPointerNameconst char * GetPointerName() constProvide a pointer name containing uid.Definition TGeoVolume.cxx:1792; TGeoVolume::Classstatic TClass * Class(); TGeoVolume::GetNodesTObjArray * GetNodes()Definition TGeoVolume.h:169; TGeoVolume::ClearShapevoid ClearShape()Clear the shape of this volume from the list held by the current manager.Definition TGeoVolume.cxx:668; TGeoVolume::SetFWExtensionvoid SetFWExtension(TGeoExtension *ext)Connect framework defined extension to the volume.Definition TGeoVolume.cxx:1498; TGeoVolume::VisibleDaughtersvoid VisibleDaughters(Bool_t vis=kTRUE)set visibility for daughtersDefinition TGeoVolume.cxx:2453; TGeoVolume::FindOverlapsvoid FindOverlaps() constloop all nodes marked as overlaps and find overlapping brothersDefinition TGeoVolume.cxx:2227; TGeoVolume::AddNodeOverlapvirtual void AddNodeOverlap(TGeoVolume *vol, Int_t copy_no, TGeoMatrix *mat",MatchSource.WIKI,doc/master/TGeoVolume_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoVolume_8cxx_source.html
https://root.cern/doc/master/TGeoVolume_8h_source.html:37774,Availability,down,down,37774,"tensionTGeoExtension * GrabUserExtension() constGet a copy of the user extension pointer.Definition TGeoVolume.cxx:1513; TGeoVolume::EGeoVolumeTypesEGeoVolumeTypesDefinition TGeoVolume.h:71; TGeoVolume::kVolumeClone@ kVolumeCloneDefinition TGeoVolume.h:80; TGeoVolume::kVolumeOverlap@ kVolumeOverlapDefinition TGeoVolume.h:75; TGeoVolume::kVolumeReplicated@ kVolumeReplicatedDefinition TGeoVolume.h:72; TGeoVolume::kVoxelsCyl@ kVoxelsCylDefinition TGeoVolume.h:79; TGeoVolume::kVolumeDiv@ kVolumeDivDefinition TGeoVolume.h:74; TGeoVolume::kVolumeOC@ kVolumeOCDefinition TGeoVolume.h:82; TGeoVolume::kVolumeSelected@ kVolumeSelectedDefinition TGeoVolume.h:73; TGeoVolume::kVolumeMulti@ kVolumeMultiDefinition TGeoVolume.h:77; TGeoVolume::kVolumeImportNodes@ kVolumeImportNodesDefinition TGeoVolume.h:76; TGeoVolume::kVolumeAdded@ kVolumeAddedDefinition TGeoVolume.h:81; TGeoVolume::kVoxelsXYZ@ kVoxelsXYZDefinition TGeoVolume.h:78; TGeoVolume::CountNodesInt_t CountNodes(Int_t nlevels=1000, Int_t option=0)Count total number of subnodes starting from this volume, nlevels down.Definition TGeoVolume.cxx:730; TGeoVolume::GrabFocusvoid GrabFocus()Move perspective view focus to this volume.Definition TGeoVolume.cxx:1812; TGeoVolume::UnmarkSavedvoid UnmarkSaved()Reset SavePrimitive bits.Definition TGeoVolume.cxx:1699; TGeoVolume::ExecuteEventvoid ExecuteEvent(Int_t event, Int_t px, Int_t py) overrideExecute mouse actions on this volume.Definition TGeoVolume.cxx:1710; TGeoVolume::CloneVolumevirtual TGeoVolume * CloneVolume() constClone this volume.Definition TGeoVolume.cxx:1831; TGeoVolume::SetFindervoid SetFinder(TGeoPatternFinder *finder)Definition TGeoVolume.h:244; TGeoVolume::GetNdaughtersInt_t GetNdaughters() constDefinition TGeoVolume.h:362; TGeoVolume::IsValidBool_t IsValid() constDefinition TGeoVolume.h:154; TGeoVolume::Grabvoid Grab()Definition TGeoVolume.h:136; TGeoVolume::CheckGeometryvoid CheckGeometry(Int_t nrays=1, Double_t startx=0, Double_t starty=0, Double_t startz=0) const",MatchSource.WIKI,doc/master/TGeoVolume_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoVolume_8h_source.html
https://root.cern/doc/master/TGeoVolume_8h_source.html:35265,Energy Efficiency,efficient,efficient,35265,"playCreationvoid ReplayCreation(const TGeoVolume *other)Recreate the content of the other volume without pointer copying.Definition TGeoVolume.cxx:1292; TGeoVolume::WeightDouble_t Weight(Double_t precision=0.01, Option_t *option=""va"")Estimate the weight of a volume (in kg) with SIGMA(M)/M better than PRECISION.Definition TGeoVolume.cxx:2501; TGeoVolume::fNumberInt_t fNumberoption - if anyDefinition TGeoVolume.h:55; TGeoVolume::CreateThreadDatavirtual void CreateThreadData(Int_t nthreads)Definition TGeoVolume.cxx:435; TGeoVolume::GetByteCountvirtual Int_t GetByteCount() constget the total size in bytes for this volumeDefinition TGeoVolume.cxx:2204; TGeoVolume::ContainsBool_t Contains(const Double_t *point) constDefinition TGeoVolume.h:104; TGeoVolume::AddNodevirtual TGeoNode * AddNode(TGeoVolume *vol, Int_t copy_no, TGeoMatrix *mat=nullptr, Option_t *option="""")Add a TGeoNode to the list of nodes.Definition TGeoVolume.cxx:975; TGeoVolume::OptimizeVoxelsBool_t OptimizeVoxels()Perform an extensive sampling to find which type of voxelization is most efficient.Definition TGeoVolume.cxx:1247; TGeoVolume::Browsevoid Browse(TBrowser *b) overrideHow to browse a volume.Definition TGeoVolume.cxx:535; TGeoVolume::SetCylVoxelsvoid SetCylVoxels(Bool_t flag=kTRUE)Definition TGeoVolume.h:218; TGeoVolume::SetCurrentPointvoid SetCurrentPoint(Double_t x, Double_t y, Double_t z)Set the current tracking point.Definition TGeoVolume.cxx:2059; TGeoVolume::Paintvoid Paint(Option_t *option="""") overridepaint volumeDefinition TGeoVolume.cxx:1267; TGeoVolume::SetVisOnlyvoid SetVisOnly(Bool_t flag=kTRUE) overrideSet visibility for leaves.Definition TGeoVolume.cxx:2393; TGeoVolume::fGeoManagerTGeoManager * fGeoManagerDefinition TGeoVolume.h:51; TGeoVolume::LegoPlotTH2F * LegoPlot(Int_t ntheta=20, Double_t themin=0., Double_t themax=180., Int_t nphi=60, Double_t phimin=0., Double_t phimax=360., Double_t rmin=0., Double_t rmax=9999999, Option_t *option="""")Generate a lego plot fot the top volume, acco",MatchSource.WIKI,doc/master/TGeoVolume_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoVolume_8h_source.html
https://root.cern/doc/master/TGeoVolume_8h_source.html:15791,Performance,concurren,concurrent,15791,,MatchSource.WIKI,doc/master/TGeoVolume_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoVolume_8h_source.html
https://root.cern/doc/master/TGeoVolume_8h_source.html:24072,Performance,concurren,concurrent,24072,"ideGet the shape name.Definition TGeoShape.cxx:250; TGeoShape::Containsvirtual Bool_t Contains(const Double_t *point) const =0; TGeoVolumeAssemblyVolume assemblies.Definition TGeoVolume.h:316; TGeoVolumeAssembly::MakeAssemblyFromVolumestatic TGeoVolumeAssembly * MakeAssemblyFromVolume(TGeoVolume *vol)Make a clone of volume VOL but which is an assembly.Definition TGeoVolume.cxx:3088; TGeoVolumeAssembly::operator=TGeoVolumeAssembly & operator=(const TGeoVolumeAssembly &)=delete; TGeoVolumeAssembly::~TGeoVolumeAssembly~TGeoVolumeAssembly() overrideDestructor. The assembly is owner of its ""shape"".Definition TGeoVolume.cxx:2968; TGeoVolumeAssembly::GetNextNodeIndexInt_t GetNextNodeIndex() const overrideDefinition TGeoVolume.cxx:2922; TGeoVolumeAssembly::IsVisibleBool_t IsVisible() const overrideDefinition TGeoVolume.h:354; TGeoVolumeAssembly::CreateThreadDatavoid CreateThreadData(Int_t nthreads) overrideDefinition TGeoVolume.cxx:2899; TGeoVolumeAssembly::TGeoVolumeAssemblyTGeoVolumeAssembly(const TGeoVolumeAssembly &)=deleteMutex for concurrent operations.; TGeoVolumeAssembly::AddNodeTGeoNode * AddNode(TGeoVolume *vol, Int_t copy_no, TGeoMatrix *mat=nullptr, Option_t *option="""") overrideAdd a component to the assembly.Definition TGeoVolume.cxx:2978; TGeoVolumeAssembly::ClearThreadDatavoid ClearThreadData() const overrideDefinition TGeoVolume.cxx:2884; TGeoVolumeAssembly::CloneVolumeTGeoVolume * CloneVolume() const overrideClone this volume.Definition TGeoVolume.cxx:3001; TGeoVolumeAssembly::AddNodeOverlapvoid AddNodeOverlap(TGeoVolume *vol, Int_t copy_no, TGeoMatrix *mat, Option_t *option) overrideAdd an overlapping node - not allowed for assemblies.Definition TGeoVolume.cxx:2989; TGeoVolumeAssembly::fThreadDatastd::vector< ThreadData_t * > fThreadDataDefinition TGeoVolume.h:331; TGeoVolumeAssembly::fMutexstd::mutex fMutexThread vector size.Definition TGeoVolume.h:333; TGeoVolumeAssembly::DrawOnlyvoid DrawOnly(Option_t *) overridedraw only this volumeDefinition TGeoVolume",MatchSource.WIKI,doc/master/TGeoVolume_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoVolume_8h_source.html
https://root.cern/doc/master/TGeoVolume_8h_source.html:32001,Performance,perform,perform,32001,"ension * GetUserExtension() constDefinition TGeoVolume.h:132; TGeoVolume::IsAllInvisibleBool_t IsAllInvisible() constReturn TRUE if volume and all daughters are invisible.Definition TGeoVolume.cxx:781; TGeoVolume::IsXYZVoxelsBool_t IsXYZVoxels() constDefinition TGeoVolume.h:152; TGeoVolume::fNtotalInt_t fNtotalDefinition TGeoVolume.h:56; TGeoVolume::MakeCopyNodesvoid MakeCopyNodes(const TGeoVolume *other)make a new list of nodes and copy all nodes of other volume insideDefinition TGeoVolume.cxx:1908; TGeoVolume::SetUserExtensionvoid SetUserExtension(TGeoExtension *ext)Connect user-defined extension to the volume.Definition TGeoVolume.cxx:1480; TGeoVolume::GrabFWExtensionTGeoExtension * GrabFWExtension() constGet a copy of the framework extension pointer.Definition TGeoVolume.cxx:1525; TGeoVolume::SetNumbervoid SetNumber(Int_t number)Definition TGeoVolume.h:245; TGeoVolume::ClearNodesvoid ClearNodes()Definition TGeoVolume.h:95; TGeoVolume::Raytracevoid Raytrace(Bool_t flag=kTRUE)Draw this volume with current settings and perform raytracing in the pad.Definition TGeoVolume.cxx:1427; TGeoVolume::RandomRaysvoid RandomRays(Int_t nrays=10000, Double_t startx=0, Double_t starty=0, Double_t startz=0, const char *target_vol=nullptr, Bool_t check_norm=kFALSE)Random raytracing method.Definition TGeoVolume.cxx:1409; TGeoVolume::TGeoVolumeTGeoVolume()dummy constructorDefinition TGeoVolume.cxx:453; TGeoVolume::GetMediumTGeoMedium * GetMedium() constDefinition TGeoVolume.h:175; TGeoVolume::GetObjectInfochar * GetObjectInfo(Int_t px, Int_t py) const overrideGet volume info for the browser.Definition TGeoVolume.cxx:1760; TGeoVolume::Printvoid Print(Option_t *option="""") const overridePrint volume info.Definition TGeoVolume.cxx:1257; TGeoVolume::CloneNodesAndConnectvoid CloneNodesAndConnect(TGeoVolume *newmother) constClone the array of nodes.Definition TGeoVolume.cxx:1880; TGeoVolume::GetRefCountInt_t GetRefCount() constDefinition TGeoVolume.h:131; TGeoVolume::IsActiveDaughtersBool_t ",MatchSource.WIKI,doc/master/TGeoVolume_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoVolume_8h_source.html
https://root.cern/doc/master/TGeoVolume_8h_source.html:42173,Performance,optimiz,optimization,42173,"but possibly a new shape,...Definition TGeoVolume.cxx:2269; TGeoVolume::InvisibleAllvoid InvisibleAll(Bool_t flag=kTRUE)Make volume and each of it daughters (in)visible.Definition TGeoVolume.cxx:795; TGeoVolume::IsVisibleDaughtersBool_t IsVisibleDaughters() constDefinition TGeoVolume.h:156; TGeoVolume::fOptionTString fOptionjust a hook for nowDefinition TGeoVolume.h:54; TGeoVolume::GetIndexInt_t GetIndex(const TGeoNode *node) constget index number for a given daughterDefinition TGeoVolume.cxx:1743; TGeoVolume::SetNodesvoid SetNodes(TObjArray *nodes)Definition TGeoVolume.h:223; TGeoVolume::GetFinderTGeoPatternFinder * GetFinder() constDefinition TGeoVolume.h:177; TGeoVolume::PrintVoxelsvoid PrintVoxels() constPrint the voxels for this volume.Definition TGeoVolume.cxx:1282; TGeoVolume::fUserExtensionTGeoExtension * fUserExtensionDefinition TGeoVolume.h:59; TGeoVolume::SetMediumvirtual void SetMedium(TGeoMedium *medium)Definition TGeoVolume.h:242; TGeoVolume::GetVoxelsTGeoVoxelFinder * GetVoxels() constGetter for optimization structure.Definition TGeoVolume.cxx:1802; TGeoVolume::SetAttVisibilityvoid SetAttVisibility(Bool_t vis)Definition TGeoVolume.h:233; TGeoVolume::~TGeoVolume~TGeoVolume() overrideDestructor.Definition TGeoVolume.cxx:510; TGeoVolume::SetShapevoid SetShape(const TGeoShape *shape)set the shape associated with this volumeDefinition TGeoVolume.cxx:2067; TGeoVolume::DummyMediumstatic TGeoMedium * DummyMedium()Definition TGeoVolume.cxx:445; TGeoVolume::fFieldTObject * fFieldpointer to TGeoManager owning this volumeDefinition TGeoVolume.h:53; TGeoVolume::GetNumberInt_t GetNumber() constDefinition TGeoVolume.h:184; TGeoVolume::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave a primitive as a C++ statement(s) on output stream ""out"".Definition TGeoVolume.cxx:1535; TGeoVolume::CleanAllvoid CleanAll()Clean data of the volume.Definition TGeoVolume.cxx:659; TGeoVolume::SetActiveDaughtersvoid SetActiveDaughters(Bool_t flag=kTRUE)D",MatchSource.WIKI,doc/master/TGeoVolume_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoVolume_8h_source.html
https://root.cern/doc/master/TGeoVolume_8h_source.html:3820,Testability,test,testNo,3820,"ClearNodes() { fNodes = nullptr; }; 96 void ClearShape();; 97 void CleanAll();; 98 virtual TGeoVolume *CloneVolume() const;; 99 void CloneNodesAndConnect(TGeoVolume *newmother) const;; 100 void CheckGeometry(Int_t nrays = 1, Double_t startx = 0, Double_t starty = 0, Double_t startz = 0) const;; 101 void CheckOverlaps(Double_t ovlp = 0.1, Option_t *option = """") const; // *MENU*; 102 void CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t *option = """"); // *MENU*; 103 Int_t CountNodes(Int_t nlevels = 1000, Int_t option = 0);; 104 Bool_t Contains(const Double_t *point) const { return fShape->Contains(point); }; 105 static void CreateDummyMedium();; 106 static TGeoMedium *DummyMedium();; 107 virtual Bool_t IsAssembly() const;; 108 Bool_t IsFolder() const override;; 109 Bool_t IsRunTime() const { return fShape->IsRunTimeShape(); }; 110 virtual Bool_t IsVolumeMulti() const { return kFALSE; }; 111 virtual TGeoNode *; 112 AddNode(TGeoVolume *vol, Int_t copy_no, TGeoMatrix *mat = nullptr, Option_t *option = """"); // most general case; 113 void AddNodeOffset(TGeoVolume *vol, Int_t copy_no, Double_t offset = 0, Option_t *option = """");; 114 virtual void AddNodeOverlap(TGeoVolume *vol, Int_t copy_no, TGeoMatrix *mat = nullptr, Option_t *option = """");; 115 ; 116 virtual TGeoVolume *Divide(const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step,; 117 Int_t numed = 0, Option_t *option = """");; 118 Int_t DistancetoPrimitive(Int_t px, Int_t py) override;; 119 void Draw(Option_t *option = """") override; // *MENU*; 120 virtual void DrawOnly(Option_t *option = """"); // *MENU*; 121 TH2F *LegoPlot(Int_t ntheta = 20, Double_t themin = 0., Double_t themax = 180., Int_t nphi = 60,; 122 Double_t phimin = 0., Double_t phimax = 360., Double_t rmin = 0., Double_t rmax = 9999999,; 123 Option_t *option = """"); // *MENU*; 124 void Paint(Option_t *option = """") override;; 125 void Print(Option_t *option = """") const override; // *MENU*; 126 void PrintNodes() const;; 127 void Print",MatchSource.WIKI,doc/master/TGeoVolume_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoVolume_8h_source.html
https://root.cern/doc/master/TGeoVolume_8h_source.html:48719,Testability,test,testNo,48719,"_t flag=kTRUE) overrideSet visibility for leaves.Definition TGeoVolume.cxx:2379; TGeoVolume::InspectShapevoid InspectShape() constDefinition TGeoVolume.h:195; TGeoVolume::IsFolderBool_t IsFolder() const overrideReturn TRUE if volume contains nodes.Definition TGeoVolume.cxx:823; TGeoVolume::FindNodeTGeoNode * FindNode(const char *name) constsearch a daughter inside the list of nodesDefinition TGeoVolume.cxx:1721; TGeoVolume::CheckOverlapsvoid CheckOverlaps(Double_t ovlp=0.1, Option_t *option="""") constOverlap checking tool.Definition TGeoVolume.cxx:611; TGeoVolume::SetOverlappingCandidatevoid SetOverlappingCandidate(Bool_t flag)Definition TGeoVolume.h:228; TGeoVolume::IsOverlappingCandidateBool_t IsOverlappingCandidate() constDefinition TGeoVolume.h:148; TGeoVolume::fRefCountInt_t fRefCountDefinition TGeoVolume.h:57; TGeoVolume::ResetTransparencyvoid ResetTransparency(Char_t transparency=-1)Definition TGeoVolume.h:383; TGeoVolume::CheckShapevoid CheckShape(Int_t testNo, Int_t nsamples=10000, Option_t *option="""")Tests for checking the shape navigation algorithms. See TGeoShape::CheckShape()Definition TGeoVolume.cxx:651; TGeoVoxelFinderFinder class handling voxels.Definition TGeoVoxelFinder.h:20; TH2F2-D histogram with a float per channel (see TH1 documentation)Definition TH2.h:307; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjArray::GetEntriesFastInt_t GetEntriesFast() constDefinition TObjArray.h:58; TObjArray::AtTObject * At(Int_t idx) const overrideDefinition TObjArray.h:164; TObjArray::UncheckedAtTObject * UncheckedAt(Int_t i) constDefinition TObjArray.h:84; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TStringBasic string class.Defin",MatchSource.WIKI,doc/master/TGeoVolume_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoVolume_8h_source.html
https://root.cern/doc/master/TGeoVolume_8h_source.html:10151,Usability,clear,clear,10151,"; 197 void MakeCopyNodes(const TGeoVolume *other);; 198 TGeoVolume *MakeReflectedVolume(const char *newname = """") const;; 199 Bool_t OptimizeVoxels(); // *MENU*; 200 void RandomPoints(Int_t npoints = 1000000, Option_t *option = """"); // *MENU*; 201 void RandomRays(Int_t nrays = 10000, Double_t startx = 0, Double_t starty = 0, Double_t startz = 0,; 202 const char *target_vol = nullptr, Bool_t check_norm = kFALSE); // *MENU*; 203 void Raytrace(Bool_t flag = kTRUE); // *TOGGLE* *GETTER=IsRaytracing; 204 void RegisterYourself(Option_t *option = """");; 205 void RemoveNode(TGeoNode *node);; 206 TGeoNode *ReplaceNode(TGeoNode *nodeorig, TGeoShape *newshape = nullptr, TGeoMatrix *newpos = nullptr,; 207 TGeoMedium *newmed = nullptr);; 208 void ResetTransparency(Char_t transparency = -1); // *MENU*; 209 void SaveAs(const char *filename = """", Option_t *option = """") const override; // *MENU*; 210 void SavePrimitive(std::ostream &out, Option_t *option = """") override;; 211 void SelectVolume(Bool_t clear = kFALSE);; 212 void SetActivity(Bool_t flag = kTRUE) { TGeoAtt::SetActivity(flag); }; 213 void SetActiveDaughters(Bool_t flag = kTRUE) { TGeoAtt::SetActiveDaughters(flag); }; 214 void SetAsTopVolume(); // *TOGGLE* *GETTER=IsTopVolume; 215 void SetAdded() { TObject::SetBit(kVolumeAdded); }; 216 void SetReplicated() { TObject::SetBit(kVolumeReplicated); }; 217 void SetCurrentPoint(Double_t x, Double_t y, Double_t z);; 218 void SetCylVoxels(Bool_t flag = kTRUE); 219 {; 220 TObject::SetBit(kVoxelsCyl, flag);; 221 TObject::SetBit(kVoxelsXYZ, !flag);; 222 }; 223 void SetNodes(TObjArray *nodes); 224 {; 225 fNodes = nodes;; 226 TObject::SetBit(kVolumeImportNodes);; 227 }; 228 void SetOverlappingCandidate(Bool_t flag) { TObject::SetBit(kVolumeOC, flag); }; 229 void SetShape(const TGeoShape *shape);; 230 void SetTransparency(Char_t transparency = 0); // *MENU*; 231 void SetField(TObject *field) { fField = field; }; 232 void SetOption(const char *option);; 233 void SetAttVisibility(Bool_t vis",MatchSource.WIKI,doc/master/TGeoVolume_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoVolume_8h_source.html
https://root.cern/doc/master/TGeoVolume_8h_source.html:38888,Usability,clear,clear,38888,"finition TGeoVolume.cxx:1812; TGeoVolume::UnmarkSavedvoid UnmarkSaved()Reset SavePrimitive bits.Definition TGeoVolume.cxx:1699; TGeoVolume::ExecuteEventvoid ExecuteEvent(Int_t event, Int_t px, Int_t py) overrideExecute mouse actions on this volume.Definition TGeoVolume.cxx:1710; TGeoVolume::CloneVolumevirtual TGeoVolume * CloneVolume() constClone this volume.Definition TGeoVolume.cxx:1831; TGeoVolume::SetFindervoid SetFinder(TGeoPatternFinder *finder)Definition TGeoVolume.h:244; TGeoVolume::GetNdaughtersInt_t GetNdaughters() constDefinition TGeoVolume.h:362; TGeoVolume::IsValidBool_t IsValid() constDefinition TGeoVolume.h:154; TGeoVolume::Grabvoid Grab()Definition TGeoVolume.h:136; TGeoVolume::CheckGeometryvoid CheckGeometry(Int_t nrays=1, Double_t startx=0, Double_t starty=0, Double_t startz=0) constShoot nrays with random directions from starting point (startx, starty, startz) in the reference fram...Definition TGeoVolume.cxx:588; TGeoVolume::SelectVolumevoid SelectVolume(Bool_t clear=kFALSE)Select this volume as matching an arbitrary criteria.Definition TGeoVolume.cxx:2325; TGeoVolume::GetPointerNameconst char * GetPointerName() constProvide a pointer name containing uid.Definition TGeoVolume.cxx:1792; TGeoVolume::GetNodesTObjArray * GetNodes()Definition TGeoVolume.h:169; TGeoVolume::SetTransparencyvoid SetTransparency(Char_t transparency=0)Definition TGeoVolume.h:376; TGeoVolume::ClearShapevoid ClearShape()Clear the shape of this volume from the list held by the current manager.Definition TGeoVolume.cxx:668; TGeoVolume::SetFWExtensionvoid SetFWExtension(TGeoExtension *ext)Connect framework defined extension to the volume.Definition TGeoVolume.cxx:1498; TGeoVolume::VisibleDaughtersvoid VisibleDaughters(Bool_t vis=kTRUE)set visibility for daughtersDefinition TGeoVolume.cxx:2453; TGeoVolume::Releasevoid Release()Definition TGeoVolume.h:137; TGeoVolume::FindOverlapsvoid FindOverlaps() constloop all nodes marked as overlaps and find overlapping brothersDefinition TGe",MatchSource.WIKI,doc/master/TGeoVolume_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoVolume_8h_source.html
https://root.cern/doc/master/TGFrame_8h.html:345,Integrability,depend,dependency,345,". ROOT: gui/gui/inc/TGFrame.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Enumerations ; TGFrame.h File Reference. #include ""TGWindow.h""; #include ""TQObject.h""; #include ""TGDimension.h""; #include ""TGGC.h""; #include ""TGFont.h""; #include ""TGLayout.h""; #include ""TGString.h"". Include dependency graph for TGFrame.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  TGCompositeFrame;  The base class for composite widgets (menu bars, list boxes, etc.). More...;  ; class  TGFrame;  A subclasses of TGWindow, and is used as base class for some simple widgets (buttons, labels, etc.). More...;  ; class  TGGroupFrame;  A composite frame with a border and a title. More...;  ; class  TGHeaderFrame;  Horizontal Frame used to contain header buttons and splitters in a list view. More...;  ; class  TGHorizontalFrame;  A composite frame that layout their children in horizontal way. More...;  ; class  TGMainFrame;  Defines top level windows that interact with the system Window Manager. More...;  ; class  TGMainFrame::TGMapKey;  ; class  TGTransientFrame;  Defines transient windows that typically are used for dialogs windows. More...;  ; class  TGVerticalFrame;  A composite frame that layout their children in vertical way. More...;  . Enumerations; enum  EDNDFlags { kIsDNDSource = (1ULL << ( 0 )); , kIsDNDTarget = (1ULL << ( 1 )); };  ; enum  EFrameCleanup { kNoCleanup = 0; , kLocalCleanup = 1; , kDeepCleanup = -1; };  ; enum  EFrameState { kIsVisible = (1ULL << ( 0 )); , kIsMapped = kIsVisible; , kIsArranged = (1ULL << ( 1 )); };  ; enum  EMWMHints { ;   kMWMFuncAll = (1ULL << ( 0 )); , kMWMFuncResize = (1ULL << ( 1 )); , kMWMFuncMove = (1ULL << ( 2 )); , kMWMFuncMinimize = (1ULL << ( 3 )); , ;   kMWMFuncMaximize = (1UL",MatchSource.WIKI,doc/master/TGFrame_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGFrame_8h.html
https://root.cern/doc/master/TGFrame_8h.html:813,Usability,simpl,simple,813,". ROOT: gui/gui/inc/TGFrame.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Enumerations ; TGFrame.h File Reference. #include ""TGWindow.h""; #include ""TQObject.h""; #include ""TGDimension.h""; #include ""TGGC.h""; #include ""TGFont.h""; #include ""TGLayout.h""; #include ""TGString.h"". Include dependency graph for TGFrame.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  TGCompositeFrame;  The base class for composite widgets (menu bars, list boxes, etc.). More...;  ; class  TGFrame;  A subclasses of TGWindow, and is used as base class for some simple widgets (buttons, labels, etc.). More...;  ; class  TGGroupFrame;  A composite frame with a border and a title. More...;  ; class  TGHeaderFrame;  Horizontal Frame used to contain header buttons and splitters in a list view. More...;  ; class  TGHorizontalFrame;  A composite frame that layout their children in horizontal way. More...;  ; class  TGMainFrame;  Defines top level windows that interact with the system Window Manager. More...;  ; class  TGMainFrame::TGMapKey;  ; class  TGTransientFrame;  Defines transient windows that typically are used for dialogs windows. More...;  ; class  TGVerticalFrame;  A composite frame that layout their children in vertical way. More...;  . Enumerations; enum  EDNDFlags { kIsDNDSource = (1ULL << ( 0 )); , kIsDNDTarget = (1ULL << ( 1 )); };  ; enum  EFrameCleanup { kNoCleanup = 0; , kLocalCleanup = 1; , kDeepCleanup = -1; };  ; enum  EFrameState { kIsVisible = (1ULL << ( 0 )); , kIsMapped = kIsVisible; , kIsArranged = (1ULL << ( 1 )); };  ; enum  EMWMHints { ;   kMWMFuncAll = (1ULL << ( 0 )); , kMWMFuncResize = (1ULL << ( 1 )); , kMWMFuncMove = (1ULL << ( 2 )); , kMWMFuncMinimize = (1ULL << ( 3 )); , ;   kMWMFuncMaximize = (1UL",MatchSource.WIKI,doc/master/TGFrame_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGFrame_8h.html
https://root.cern/doc/master/TGHtmlTable_8cxx.html:307,Integrability,depend,dependency,307,". ROOT: gui/guihtml/src/TGHtmlTable.cxx File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Macros ; TGHtmlTable.cxx File Reference. #include <cstdlib>; #include <cstring>; #include <cctype>; #include <cmath>; #include ""TGHtml.h""; #include ""snprintf.h"". Include dependency graph for TGHtmlTable.cxx:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Macros; #define ColMin(A, B)   colMin[(A)-1][(B)-1];  ; #define ColReq(A, B)   colMin[(B)-1][(A)-1];  ; #define DFLT_BORDER   0;  ; #define DFLT_CELLPADDING   2;  ; #define DFLT_CELLSPACING_3D   5;  ; #define DFLT_CELLSPACING_FLAT   0;  ; #define DFLT_HSPACE   0;  ; #define DFLT_VSPACE   0;  ; #define MAX(A, B)   ((A) < (B) ? (B) : (A));  ; #define N   (HTML_MAX_COLUMNS+1);  ; #define SETMAX(A, B)   if ((A) < (B)) { (A) = (B); };  ; #define VAlign_Baseline   4;  ; #define VAlign_Bottom   2;  ; #define VAlign_Center   3;  ; #define VAlign_Top   1;  ; #define VAlign_Unknown   0;  . Macro Definition Documentation. ◆ ColMin. #define ColMin; (;  ; A, .  ; B . );    colMin[(A)-1][(B)-1]. ◆ ColReq. #define ColReq; (;  ; A, .  ; B . );    colMin[(B)-1][(A)-1]. ◆ DFLT_BORDER. #define DFLT_BORDER   0. Definition at line 38 of file TGHtmlTable.cxx. ◆ DFLT_CELLPADDING. #define DFLT_CELLPADDING   2. Definition at line 41 of file TGHtmlTable.cxx. ◆ DFLT_CELLSPACING_3D. #define DFLT_CELLSPACING_3D   5. Definition at line 39 of file TGHtmlTable.cxx. ◆ DFLT_CELLSPACING_FLAT. #define DFLT_CELLSPACING_FLAT   0. Definition at line 40 of file TGHtmlTable.cxx. ◆ DFLT_HSPACE. #define DFLT_HSPACE   0. Definition at line 42 of file TGHtmlTable.cxx. ◆ DFLT_VSPACE. #define DFLT_VSPACE   0. Definition at line 43 of file TGHtmlTable.cxx. ◆ MAX. #define MAX; (;  ; A, .  ; B . );    ((A) < (B) ? (B) : (A)). Definition at line 47 of file TGHtmlTable.cxx. ◆ N. #define N   (HTML_MAX_COLUMNS+1). ◆ SETMAX. #define SETMAX; (;  ; A, .  ; B . );    if ((A) < (B)) { (A) = (B); }. Def",MatchSource.WIKI,doc/master/TGHtmlTable_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGHtmlTable_8cxx.html
https://root.cern/doc/master/TGLUtil_8h.html:1655,Availability,error,error,1655,"Opera instead. Classes; class  TGLUtil::TColorLocker;  ; class  TGLUtil::TDrawQualityModifier;  ; class  TGLUtil::TDrawQualityScaler;  ; class  TGL2DArray< T >;  ; class  TGLCapabilityEnabler;  ; class  TGLCapabilitySwitch;  ; class  TGLColor;  Class encapsulating color information in preferred GL format - an array of four unsigned bytes. More...;  ; class  TGLColorSet;  Class encapsulating a set of colors used throughout standard rendering. More...;  ; class  TGLDisableGuard;  ; class  TGLEnableGuard;  ; class  TGLFloatHolder;  ; class  TGLLevelPalette;  ; class  TGLLine3;  3D space, fixed length, line class, with direction / length 'vector', passing through point 'vertex'. More...;  ; class  TGLMatrix;  16 component (4x4) transform matrix - column MAJOR as per GL. More...;  ; class  TGLPlane;  3D plane class - of format Ax + By + Cz + D = 0 More...;  ; class  TGLRect;  Viewport (pixel base) 2D rectangle class. More...;  ; class  TGLSelectionBuffer;  ; class  TGLUtil;  Wrapper class for various misc static functions - error checking, draw helpers etc. More...;  ; class  TGLVector3;  3 component (x/y/z) vector class. More...;  ; class  TGLVertex3;  3 component (x/y/z) vertex class. More...;  ; class  Rgl::TGuardBase;  ; class  Rgl::TOneArgGuard< Func, Arg >;  ; class  Rgl::TTwoArgsGuard< Func, Arg1, Arg2 >;  . Namespaces; namespace  Rgl;  . Typedefs; typedef std::pair< Int_t, Int_t > Rgl::BinRange_t;  ; typedef std::pair< Double_t, Double_t > Rgl::Range_t;  ; typedef std::vector< TGLPlane >::const_iterator TGLPlaneSet_ci;  ; typedef std::vector< TGLPlane >::iterator TGLPlaneSet_i;  ; typedef std::vector< TGLPlane > TGLPlaneSet_t;  . Enumerations; enum  EGLCoordType { kGLCartesian; , kGLPolar; , kGLCylindrical; , kGLSpherical; };  ; enum  EGLPlotType { ;   kGLLegoPlot; , kGLSurfacePlot; , kGLBoxPlot; , kGLTF3Plot; , ;   kGLStackPlot; , kGLParametricPlot; , kGLIsoPlot; , kGL5D; , ;   kGLTH3Composition; , kGLVoxel; , kGLDefaultPlot. };  ; enum  Rgl::EOverlap { Rgl::kIns",MatchSource.WIKI,doc/master/TGLUtil_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGLUtil_8h.html
https://root.cern/doc/master/TGLUtil_8h.html:360,Integrability,depend,dependency,360,". ROOT: graf3d/gl/inc/TGLUtil.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Namespaces |; Typedefs |; Enumerations |; Functions |; Variables ; TGLUtil.h File Reference. #include ""Rtypes.h""; #include ""TError.h""; #include <vector>; #include <cmath>; #include <cassert>; #include <utility>. Include dependency graph for TGLUtil.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  TGLUtil::TColorLocker;  ; class  TGLUtil::TDrawQualityModifier;  ; class  TGLUtil::TDrawQualityScaler;  ; class  TGL2DArray< T >;  ; class  TGLCapabilityEnabler;  ; class  TGLCapabilitySwitch;  ; class  TGLColor;  Class encapsulating color information in preferred GL format - an array of four unsigned bytes. More...;  ; class  TGLColorSet;  Class encapsulating a set of colors used throughout standard rendering. More...;  ; class  TGLDisableGuard;  ; class  TGLEnableGuard;  ; class  TGLFloatHolder;  ; class  TGLLevelPalette;  ; class  TGLLine3;  3D space, fixed length, line class, with direction / length 'vector', passing through point 'vertex'. More...;  ; class  TGLMatrix;  16 component (4x4) transform matrix - column MAJOR as per GL. More...;  ; class  TGLPlane;  3D plane class - of format Ax + By + Cz + D = 0 More...;  ; class  TGLRect;  Viewport (pixel base) 2D rectangle class. More...;  ; class  TGLSelectionBuffer;  ; class  TGLUtil;  Wrapper class for various misc static functions - error checking, draw helpers etc. More...;  ; class  TGLVector3;  3 component (x/y/z) vector class. More...;  ; class  TGLVertex3;  3 component (x/y/z) vertex class. More...;  ; class  Rgl::TGuardBase;  ; class  Rgl::TOneArgGuard< Func, Arg >;  ; class  Rgl::TTwoArgsGuard< Func, Arg1, Arg2 >;  . Namespaces; namespace  Rgl;  . Typedefs; typedef ",MatchSource.WIKI,doc/master/TGLUtil_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGLUtil_8h.html
https://root.cern/doc/master/TGLUtil_8h.html:6922,Modifiability,extend,extend,6922,"uble_t zMin, Double_t zMax, Bool_t color=kTRUE);  ; void Rgl::DrawTrapezoid (const Double_t ver[][3]);  ; void Rgl::DrawTrapezoidTextured (const Double_t ver[][2], Double_t zMin, Double_t zMax, Double_t texMin, Double_t texMax);  In polar coordinates, box became trapezoid. ;  ; void Rgl::DrawTrapezoidTextured (const Double_t ver[][3], Double_t texMin, Double_t texMax);  ; void Rgl::DrawTrapezoidTextured2 (const Double_t ver[][2], Double_t zMin, Double_t zMax, Double_t texMin, Double_t texMax);  In polar coordinates, box became trapezoid. ;  ; void Rgl::GetColor (Float_t v, Float_t vmin, Float_t vmax, Int_t type, Float_t *rgba);  This function creates color for parametric surface's vertex, using its 'u' value. ;  ; std::pair< Bool_t, TGLLine3 > Intersection (const TGLPlane &p1, const TGLPlane &p2);  Find 3D line interestion of this plane with 'other'. ;  ; std::pair< Bool_t, TGLVertex3 > Intersection (const TGLPlane &p1, const TGLPlane &p2, const TGLPlane &p3);  ; std::pair< Bool_t, TGLVertex3 > Intersection (const TGLPlane &plane, const TGLLine3 &line, Bool_t extend);  Find intersection of 3D space 'line' with this plane. ;  ; template<class Func , class Arg > ; TOneArgGuard< Func, Arg > Rgl::make_guard (Func f, Arg a);  ; template<class Func , class Arg1 , class Arg2 > ; TTwoArgsGuard< Func, Arg1, Arg2 > Rgl::make_guard (Func f, Arg1 a1, Arg2 a2);  ; void Rgl::ObjectIDToColor (Int_t objectID, Bool_t highColor);  Object id encoded as rgb triplet. ;  ; TGLMatrix operator* (const TGLMatrix &lhs, const TGLMatrix &rhs);  ; Double_t operator* (const TGLVector3 &a, const TGLVector3 &b);  ; const TGLVector3 operator* (const TGLVector3 &vec, Double_t val);  ; TGLVertex3 operator* (Double_t f, const TGLVertex3 &v);  ; TGLVector3 operator+ (const TGLVector3 &vector1, const TGLVector3 &vector2);  ; TGLVertex3 operator+ (const TGLVertex3 &vertex1, const TGLVector3 &vertex2);  ; TGLVector3 operator- (const TGLVector3 &vector1, const TGLVector3 &vector2);  ; TGLVector3 operator- (",MatchSource.WIKI,doc/master/TGLUtil_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGLUtil_8h.html
https://root.cern/doc/master/TGLUtil_8h.html:10347,Modifiability,extend,extend,10347,"ocumentation. ◆ Cross(). TGLVector3 Cross ; (; const TGLVector3 & ; v1, . const TGLVector3 & ; v2 . ). inline . Definition at line 323 of file TGLUtil.h. ◆ Dot(). Double_t Dot ; (; const TGLVector3 & ; v1, . const TGLVector3 & ; v2 . ). inline . Definition at line 317 of file TGLUtil.h. ◆ Intersection() [1/3]. std::pair< Bool_t, TGLLine3 > Intersection ; (; const TGLPlane & ; p1, . const TGLPlane & ; p2 . ). Find 3D line interestion of this plane with 'other'. ; Returns a std::pair; first (Bool_t) second (TGLLine3) kTRUE - planes intersect intersection line between planes kFALSE - no intersect (parallel) undefined ; Definition at line 516 of file TGLUtil.cxx. ◆ Intersection() [2/3]. std::pair< Bool_t, TGLVertex3 > Intersection ; (; const TGLPlane & ; p1, . const TGLPlane & ; p2, . const TGLPlane & ; p3 . ). Definition at line 531 of file TGLUtil.cxx. ◆ Intersection() [3/3]. std::pair< Bool_t, TGLVertex3 > Intersection ; (; const TGLPlane & ; plane, . const TGLLine3 & ; line, . Bool_t ; extend . ). Find intersection of 3D space 'line' with this plane. ; If 'extend' is kTRUE then line extents can be extended (infinite length) to find intersection. If 'extend' is kFALSE the fixed extents of line is respected.; The return a std::pair. first (Bool_t) second (TGLVertex3); kTRUE - line/plane intersect intersection vertex on plane; kFALSE - no line/plane intersect undefined. If intersection is not found (first == kFALSE) & 'extend' was kTRUE (infinite line) this implies line and plane are parallel. If 'extend' was kFALSE, then either line parallel or insufficient length. ; Definition at line 559 of file TGLUtil.cxx. ◆ operator*() [1/4]. TGLMatrix operator* ; (; const TGLMatrix & ; lhs, . const TGLMatrix & ; rhs . ). inline . Definition at line 705 of file TGLUtil.h. ◆ operator*() [2/4]. Double_t operator* ; (; const TGLVector3 & ; a, . const TGLVector3 & ; b . ). inline . Definition at line 372 of file TGLUtil.h. ◆ operator*() [3/4]. const TGLVector3 operator* ; (; const TG",MatchSource.WIKI,doc/master/TGLUtil_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGLUtil_8h.html
https://root.cern/doc/master/TGLUtil_8h.html:10419,Modifiability,extend,extend,10419,"finition at line 323 of file TGLUtil.h. ◆ Dot(). Double_t Dot ; (; const TGLVector3 & ; v1, . const TGLVector3 & ; v2 . ). inline . Definition at line 317 of file TGLUtil.h. ◆ Intersection() [1/3]. std::pair< Bool_t, TGLLine3 > Intersection ; (; const TGLPlane & ; p1, . const TGLPlane & ; p2 . ). Find 3D line interestion of this plane with 'other'. ; Returns a std::pair; first (Bool_t) second (TGLLine3) kTRUE - planes intersect intersection line between planes kFALSE - no intersect (parallel) undefined ; Definition at line 516 of file TGLUtil.cxx. ◆ Intersection() [2/3]. std::pair< Bool_t, TGLVertex3 > Intersection ; (; const TGLPlane & ; p1, . const TGLPlane & ; p2, . const TGLPlane & ; p3 . ). Definition at line 531 of file TGLUtil.cxx. ◆ Intersection() [3/3]. std::pair< Bool_t, TGLVertex3 > Intersection ; (; const TGLPlane & ; plane, . const TGLLine3 & ; line, . Bool_t ; extend . ). Find intersection of 3D space 'line' with this plane. ; If 'extend' is kTRUE then line extents can be extended (infinite length) to find intersection. If 'extend' is kFALSE the fixed extents of line is respected.; The return a std::pair. first (Bool_t) second (TGLVertex3); kTRUE - line/plane intersect intersection vertex on plane; kFALSE - no line/plane intersect undefined. If intersection is not found (first == kFALSE) & 'extend' was kTRUE (infinite line) this implies line and plane are parallel. If 'extend' was kFALSE, then either line parallel or insufficient length. ; Definition at line 559 of file TGLUtil.cxx. ◆ operator*() [1/4]. TGLMatrix operator* ; (; const TGLMatrix & ; lhs, . const TGLMatrix & ; rhs . ). inline . Definition at line 705 of file TGLUtil.h. ◆ operator*() [2/4]. Double_t operator* ; (; const TGLVector3 & ; a, . const TGLVector3 & ; b . ). inline . Definition at line 372 of file TGLUtil.h. ◆ operator*() [3/4]. const TGLVector3 operator* ; (; const TGLVector3 & ; vec, . Double_t ; val . ). inline . Definition at line 337 of file TGLUtil.h. ◆ operator*() [4/4]. TGL",MatchSource.WIKI,doc/master/TGLUtil_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGLUtil_8h.html
https://root.cern/doc/master/TGLUtil_8h.html:10461,Modifiability,extend,extended,10461,"finition at line 323 of file TGLUtil.h. ◆ Dot(). Double_t Dot ; (; const TGLVector3 & ; v1, . const TGLVector3 & ; v2 . ). inline . Definition at line 317 of file TGLUtil.h. ◆ Intersection() [1/3]. std::pair< Bool_t, TGLLine3 > Intersection ; (; const TGLPlane & ; p1, . const TGLPlane & ; p2 . ). Find 3D line interestion of this plane with 'other'. ; Returns a std::pair; first (Bool_t) second (TGLLine3) kTRUE - planes intersect intersection line between planes kFALSE - no intersect (parallel) undefined ; Definition at line 516 of file TGLUtil.cxx. ◆ Intersection() [2/3]. std::pair< Bool_t, TGLVertex3 > Intersection ; (; const TGLPlane & ; p1, . const TGLPlane & ; p2, . const TGLPlane & ; p3 . ). Definition at line 531 of file TGLUtil.cxx. ◆ Intersection() [3/3]. std::pair< Bool_t, TGLVertex3 > Intersection ; (; const TGLPlane & ; plane, . const TGLLine3 & ; line, . Bool_t ; extend . ). Find intersection of 3D space 'line' with this plane. ; If 'extend' is kTRUE then line extents can be extended (infinite length) to find intersection. If 'extend' is kFALSE the fixed extents of line is respected.; The return a std::pair. first (Bool_t) second (TGLVertex3); kTRUE - line/plane intersect intersection vertex on plane; kFALSE - no line/plane intersect undefined. If intersection is not found (first == kFALSE) & 'extend' was kTRUE (infinite line) this implies line and plane are parallel. If 'extend' was kFALSE, then either line parallel or insufficient length. ; Definition at line 559 of file TGLUtil.cxx. ◆ operator*() [1/4]. TGLMatrix operator* ; (; const TGLMatrix & ; lhs, . const TGLMatrix & ; rhs . ). inline . Definition at line 705 of file TGLUtil.h. ◆ operator*() [2/4]. Double_t operator* ; (; const TGLVector3 & ; a, . const TGLVector3 & ; b . ). inline . Definition at line 372 of file TGLUtil.h. ◆ operator*() [3/4]. const TGLVector3 operator* ; (; const TGLVector3 & ; vec, . Double_t ; val . ). inline . Definition at line 337 of file TGLUtil.h. ◆ operator*() [4/4]. TGL",MatchSource.WIKI,doc/master/TGLUtil_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGLUtil_8h.html
https://root.cern/doc/master/TGLUtil_8h.html:10514,Modifiability,extend,extend,10514,"or3 & ; v1, . const TGLVector3 & ; v2 . ). inline . Definition at line 317 of file TGLUtil.h. ◆ Intersection() [1/3]. std::pair< Bool_t, TGLLine3 > Intersection ; (; const TGLPlane & ; p1, . const TGLPlane & ; p2 . ). Find 3D line interestion of this plane with 'other'. ; Returns a std::pair; first (Bool_t) second (TGLLine3) kTRUE - planes intersect intersection line between planes kFALSE - no intersect (parallel) undefined ; Definition at line 516 of file TGLUtil.cxx. ◆ Intersection() [2/3]. std::pair< Bool_t, TGLVertex3 > Intersection ; (; const TGLPlane & ; p1, . const TGLPlane & ; p2, . const TGLPlane & ; p3 . ). Definition at line 531 of file TGLUtil.cxx. ◆ Intersection() [3/3]. std::pair< Bool_t, TGLVertex3 > Intersection ; (; const TGLPlane & ; plane, . const TGLLine3 & ; line, . Bool_t ; extend . ). Find intersection of 3D space 'line' with this plane. ; If 'extend' is kTRUE then line extents can be extended (infinite length) to find intersection. If 'extend' is kFALSE the fixed extents of line is respected.; The return a std::pair. first (Bool_t) second (TGLVertex3); kTRUE - line/plane intersect intersection vertex on plane; kFALSE - no line/plane intersect undefined. If intersection is not found (first == kFALSE) & 'extend' was kTRUE (infinite line) this implies line and plane are parallel. If 'extend' was kFALSE, then either line parallel or insufficient length. ; Definition at line 559 of file TGLUtil.cxx. ◆ operator*() [1/4]. TGLMatrix operator* ; (; const TGLMatrix & ; lhs, . const TGLMatrix & ; rhs . ). inline . Definition at line 705 of file TGLUtil.h. ◆ operator*() [2/4]. Double_t operator* ; (; const TGLVector3 & ; a, . const TGLVector3 & ; b . ). inline . Definition at line 372 of file TGLUtil.h. ◆ operator*() [3/4]. const TGLVector3 operator* ; (; const TGLVector3 & ; vec, . Double_t ; val . ). inline . Definition at line 337 of file TGLUtil.h. ◆ operator*() [4/4]. TGLVertex3 operator* ; (; Double_t ; f, . const TGLVertex3 & ; v . ). inline . Def",MatchSource.WIKI,doc/master/TGLUtil_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGLUtil_8h.html
https://root.cern/doc/master/TGLUtil_8h.html:10786,Modifiability,extend,extend,10786,"ith 'other'. ; Returns a std::pair; first (Bool_t) second (TGLLine3) kTRUE - planes intersect intersection line between planes kFALSE - no intersect (parallel) undefined ; Definition at line 516 of file TGLUtil.cxx. ◆ Intersection() [2/3]. std::pair< Bool_t, TGLVertex3 > Intersection ; (; const TGLPlane & ; p1, . const TGLPlane & ; p2, . const TGLPlane & ; p3 . ). Definition at line 531 of file TGLUtil.cxx. ◆ Intersection() [3/3]. std::pair< Bool_t, TGLVertex3 > Intersection ; (; const TGLPlane & ; plane, . const TGLLine3 & ; line, . Bool_t ; extend . ). Find intersection of 3D space 'line' with this plane. ; If 'extend' is kTRUE then line extents can be extended (infinite length) to find intersection. If 'extend' is kFALSE the fixed extents of line is respected.; The return a std::pair. first (Bool_t) second (TGLVertex3); kTRUE - line/plane intersect intersection vertex on plane; kFALSE - no line/plane intersect undefined. If intersection is not found (first == kFALSE) & 'extend' was kTRUE (infinite line) this implies line and plane are parallel. If 'extend' was kFALSE, then either line parallel or insufficient length. ; Definition at line 559 of file TGLUtil.cxx. ◆ operator*() [1/4]. TGLMatrix operator* ; (; const TGLMatrix & ; lhs, . const TGLMatrix & ; rhs . ). inline . Definition at line 705 of file TGLUtil.h. ◆ operator*() [2/4]. Double_t operator* ; (; const TGLVector3 & ; a, . const TGLVector3 & ; b . ). inline . Definition at line 372 of file TGLUtil.h. ◆ operator*() [3/4]. const TGLVector3 operator* ; (; const TGLVector3 & ; vec, . Double_t ; val . ). inline . Definition at line 337 of file TGLUtil.h. ◆ operator*() [4/4]. TGLVertex3 operator* ; (; Double_t ; f, . const TGLVertex3 & ; v . ). inline . Definition at line 135 of file TGLUtil.h. ◆ operator+() [1/2]. TGLVector3 operator+ ; (; const TGLVector3 & ; vector1, . const TGLVector3 & ; vector2 . ). inline . Definition at line 358 of file TGLUtil.h. ◆ operator+() [2/2]. TGLVertex3 operator+ ; (; const TG",MatchSource.WIKI,doc/master/TGLUtil_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGLUtil_8h.html
https://root.cern/doc/master/TGLUtil_8h.html:10866,Modifiability,extend,extend,10866,"ection line between planes kFALSE - no intersect (parallel) undefined ; Definition at line 516 of file TGLUtil.cxx. ◆ Intersection() [2/3]. std::pair< Bool_t, TGLVertex3 > Intersection ; (; const TGLPlane & ; p1, . const TGLPlane & ; p2, . const TGLPlane & ; p3 . ). Definition at line 531 of file TGLUtil.cxx. ◆ Intersection() [3/3]. std::pair< Bool_t, TGLVertex3 > Intersection ; (; const TGLPlane & ; plane, . const TGLLine3 & ; line, . Bool_t ; extend . ). Find intersection of 3D space 'line' with this plane. ; If 'extend' is kTRUE then line extents can be extended (infinite length) to find intersection. If 'extend' is kFALSE the fixed extents of line is respected.; The return a std::pair. first (Bool_t) second (TGLVertex3); kTRUE - line/plane intersect intersection vertex on plane; kFALSE - no line/plane intersect undefined. If intersection is not found (first == kFALSE) & 'extend' was kTRUE (infinite line) this implies line and plane are parallel. If 'extend' was kFALSE, then either line parallel or insufficient length. ; Definition at line 559 of file TGLUtil.cxx. ◆ operator*() [1/4]. TGLMatrix operator* ; (; const TGLMatrix & ; lhs, . const TGLMatrix & ; rhs . ). inline . Definition at line 705 of file TGLUtil.h. ◆ operator*() [2/4]. Double_t operator* ; (; const TGLVector3 & ; a, . const TGLVector3 & ; b . ). inline . Definition at line 372 of file TGLUtil.h. ◆ operator*() [3/4]. const TGLVector3 operator* ; (; const TGLVector3 & ; vec, . Double_t ; val . ). inline . Definition at line 337 of file TGLUtil.h. ◆ operator*() [4/4]. TGLVertex3 operator* ; (; Double_t ; f, . const TGLVertex3 & ; v . ). inline . Definition at line 135 of file TGLUtil.h. ◆ operator+() [1/2]. TGLVector3 operator+ ; (; const TGLVector3 & ; vector1, . const TGLVector3 & ; vector2 . ). inline . Definition at line 358 of file TGLUtil.h. ◆ operator+() [2/2]. TGLVertex3 operator+ ; (; const TGLVertex3 & ; vertex1, . const TGLVector3 & ; vertex2 . ). inline . Definition at line 344 of file TG",MatchSource.WIKI,doc/master/TGLUtil_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGLUtil_8h.html
https://root.cern/doc/master/TGLUtil_8h.html:5157,Safety,avoid,avoid,5157,"st TGLVector3 &norm2, const TGLVector3 &norm3);  Draw textured triangle. ;  ; void Rgl::DrawFaceTextured (const TGLVertex3 &v1, const TGLVertex3 &v2, const TGLVertex3 &v3, Double_t t1, Double_t t2, Double_t t3, Double_t z, const TGLVector3 &normal);  Draw textured triangle on a plane. ;  ; void Rgl::DrawQuadFilled (const Double_t *v0, const Double_t *v1, const Double_t *v2, const Double_t *v3, const Double_t *normal);  Draw quad face. ;  ; void Rgl::DrawQuadFilled (const TGLVertex3 &v0, const TGLVertex3 &v1, const TGLVertex3 &v2, const TGLVertex3 &v3, const TGLVector3 &normal);  Draw quad face. ;  ; void Rgl::DrawQuadOutline (const TGLVertex3 &v1, const TGLVertex3 &v2, const TGLVertex3 &v3, const TGLVertex3 &v4);  Draw quad outline. ;  ; void Rgl::DrawQuadStripWithRadialGradientFill (unsigned nPoints, const Double_t *inner, const Double_t *innerRGBA, const Double_t *outer, const Double_t *outerRGBA);  TODO: is it possible to use GLdouble to avoid problems with Double_t/GLdouble if they are not the same type? ;  ; void Rgl::DrawSmoothFace (const TGLVertex3 &v1, const TGLVertex3 &v2, const TGLVertex3 &v3, const TGLVector3 &norm1, const TGLVector3 &norm2, const TGLVector3 &norm3);  Draws triangle face, each vertex has its own averaged normal. ;  ; void Rgl::DrawSphere (TGLQuadric *quadric, Double_t xMin, Double_t xMax, Double_t yMin, Double_t yMax, Double_t zMin, Double_t zMax);  Cylinder for lego3. ;  ; void Rgl::DrawTransparentBox (Double_t xMin, Double_t xMax, Double_t yMin, Double_t yMax, Double_t zMin, Double_t zMax, Int_t fp);  Draws lego's bar as a 3d box. ;  ; void Rgl::DrawTrapezoid (const Double_t ver[][2], Double_t zMin, Double_t zMax, Bool_t color=kTRUE);  ; void Rgl::DrawTrapezoid (const Double_t ver[][3]);  ; void Rgl::DrawTrapezoidTextured (const Double_t ver[][2], Double_t zMin, Double_t zMax, Double_t texMin, Double_t texMax);  In polar coordinates, box became trapezoid. ;  ; void Rgl::DrawTrapezoidTextured (const Double_t ver[][3], Double_t texMin, Dou",MatchSource.WIKI,doc/master/TGLUtil_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGLUtil_8h.html
https://root.cern/doc/master/TGraph2DErrors_8cxx_source.html:949,Availability,error,errors,949,". ROOT: hist/hist/src/TGraph2DErrors.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TGraph2DErrors.cxx. Go to the documentation of this file. 1// @(#)root/hist:$Id: TGraph2DErrors.cxx,v 1.00; 2// Author: Olivier Couet; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#include <iostream>; 13#include ""TBuffer.h""; 14#include ""TGraph2DErrors.h""; 15#include ""TH2.h""; 16#include ""TVirtualPad.h""; 17#include ""TVirtualFitter.h""; 18#include ""THLimitsFinder.h""; 19 ; 20ClassImp(TGraph2DErrors);; 21 ; 22/** \class TGraph2DErrors; 23 \ingroup Graphs; 24Graph 2D class with errors.; 25 ; 26A TGraph2DErrors is a TGraph2D with errors. It behaves like a TGraph2D and has; 27the same drawing options.; 28 ; 29The **""ERR""** drawing option allows to display the error bars. The; 30following example shows how to use it:; 31 ; 32Begin_Macro(source); 33{; 34 auto c = new TCanvas(""c"",""TGraph2DErrors example"",0,0,600,600);; 35 Double_t P = 6.;; 36 Int_t np = 200;; 37 ; 38 Double_t *rx=0, *ry=0, *rz=0;; 39 Double_t *ex=0, *ey=0, *ez=0;; 40 ; 41 rx = new Double_t[np];; 42 ry = new Double_t[np];; 43 rz = new Double_t[np];; 44 ex = new Double_t[np];; 45 ey = new Double_t[np];; 46 ez = new Double_t[np];; 47 ; 48 auto r = new TRandom();; 49 ; 50 for (Int_t N=0; N<np;N++) {; 51 rx[N] = 2*P*(r->Rndm(N))-P;; 52 ry[N] = 2*P*(r->Rndm(N))-P;; 53 rz[N] = rx[N]*rx[N]-ry[N]*ry[N];; 54 rx[N] = 10.+rx[N];; 55 ry[N] = 10.+ry[N];; 56 rz[N] = 40.+rz[N];; 57 ex[N] = r->Rndm(N);; 58 ey[N] = r->Rndm(N);; 59 ez[N] = 10*r->Rndm(N);; 60 }; 61 ; 62 auto g = new TGraph2DErrors(np, rx, ry, rz, ex, ey, ez);; 63 g->SetTitle(""TGraph2D with error bars:",MatchSource.WIKI,doc/master/TGraph2DErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2DErrors_8cxx_source.html
https://root.cern/doc/master/TGraph2DErrors_8cxx_source.html:1001,Availability,error,errors,1001,". ROOT: hist/hist/src/TGraph2DErrors.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TGraph2DErrors.cxx. Go to the documentation of this file. 1// @(#)root/hist:$Id: TGraph2DErrors.cxx,v 1.00; 2// Author: Olivier Couet; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#include <iostream>; 13#include ""TBuffer.h""; 14#include ""TGraph2DErrors.h""; 15#include ""TH2.h""; 16#include ""TVirtualPad.h""; 17#include ""TVirtualFitter.h""; 18#include ""THLimitsFinder.h""; 19 ; 20ClassImp(TGraph2DErrors);; 21 ; 22/** \class TGraph2DErrors; 23 \ingroup Graphs; 24Graph 2D class with errors.; 25 ; 26A TGraph2DErrors is a TGraph2D with errors. It behaves like a TGraph2D and has; 27the same drawing options.; 28 ; 29The **""ERR""** drawing option allows to display the error bars. The; 30following example shows how to use it:; 31 ; 32Begin_Macro(source); 33{; 34 auto c = new TCanvas(""c"",""TGraph2DErrors example"",0,0,600,600);; 35 Double_t P = 6.;; 36 Int_t np = 200;; 37 ; 38 Double_t *rx=0, *ry=0, *rz=0;; 39 Double_t *ex=0, *ey=0, *ez=0;; 40 ; 41 rx = new Double_t[np];; 42 ry = new Double_t[np];; 43 rz = new Double_t[np];; 44 ex = new Double_t[np];; 45 ey = new Double_t[np];; 46 ez = new Double_t[np];; 47 ; 48 auto r = new TRandom();; 49 ; 50 for (Int_t N=0; N<np;N++) {; 51 rx[N] = 2*P*(r->Rndm(N))-P;; 52 ry[N] = 2*P*(r->Rndm(N))-P;; 53 rz[N] = rx[N]*rx[N]-ry[N]*ry[N];; 54 rx[N] = 10.+rx[N];; 55 ry[N] = 10.+ry[N];; 56 rz[N] = 40.+rz[N];; 57 ex[N] = r->Rndm(N);; 58 ey[N] = r->Rndm(N);; 59 ez[N] = 10*r->Rndm(N);; 60 }; 61 ; 62 auto g = new TGraph2DErrors(np, rx, ry, rz, ex, ey, ez);; 63 g->SetTitle(""TGraph2D with error bars:",MatchSource.WIKI,doc/master/TGraph2DErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2DErrors_8cxx_source.html
https://root.cern/doc/master/TGraph2DErrors_8cxx_source.html:1132,Availability,error,error,1132,"; Searching...; No Matches. TGraph2DErrors.cxx. Go to the documentation of this file. 1// @(#)root/hist:$Id: TGraph2DErrors.cxx,v 1.00; 2// Author: Olivier Couet; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#include <iostream>; 13#include ""TBuffer.h""; 14#include ""TGraph2DErrors.h""; 15#include ""TH2.h""; 16#include ""TVirtualPad.h""; 17#include ""TVirtualFitter.h""; 18#include ""THLimitsFinder.h""; 19 ; 20ClassImp(TGraph2DErrors);; 21 ; 22/** \class TGraph2DErrors; 23 \ingroup Graphs; 24Graph 2D class with errors.; 25 ; 26A TGraph2DErrors is a TGraph2D with errors. It behaves like a TGraph2D and has; 27the same drawing options.; 28 ; 29The **""ERR""** drawing option allows to display the error bars. The; 30following example shows how to use it:; 31 ; 32Begin_Macro(source); 33{; 34 auto c = new TCanvas(""c"",""TGraph2DErrors example"",0,0,600,600);; 35 Double_t P = 6.;; 36 Int_t np = 200;; 37 ; 38 Double_t *rx=0, *ry=0, *rz=0;; 39 Double_t *ex=0, *ey=0, *ez=0;; 40 ; 41 rx = new Double_t[np];; 42 ry = new Double_t[np];; 43 rz = new Double_t[np];; 44 ex = new Double_t[np];; 45 ey = new Double_t[np];; 46 ez = new Double_t[np];; 47 ; 48 auto r = new TRandom();; 49 ; 50 for (Int_t N=0; N<np;N++) {; 51 rx[N] = 2*P*(r->Rndm(N))-P;; 52 ry[N] = 2*P*(r->Rndm(N))-P;; 53 rz[N] = rx[N]*rx[N]-ry[N]*ry[N];; 54 rx[N] = 10.+rx[N];; 55 ry[N] = 10.+ry[N];; 56 rz[N] = 40.+rz[N];; 57 ex[N] = r->Rndm(N);; 58 ey[N] = r->Rndm(N);; 59 ez[N] = 10*r->Rndm(N);; 60 }; 61 ; 62 auto g = new TGraph2DErrors(np, rx, ry, rz, ex, ey, ez);; 63 g->SetTitle(""TGraph2D with error bars: option \""ERR\"""");; 64 g->SetFillColor(29);; 65 g->SetMarkerSize(0.8);; 66 g->SetMarkerStyle(20);; 67 g->Se",MatchSource.WIKI,doc/master/TGraph2DErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2DErrors_8cxx_source.html
https://root.cern/doc/master/TGraph2DErrors_8cxx_source.html:1990,Availability,error,error,1990,"D class with errors.; 25 ; 26A TGraph2DErrors is a TGraph2D with errors. It behaves like a TGraph2D and has; 27the same drawing options.; 28 ; 29The **""ERR""** drawing option allows to display the error bars. The; 30following example shows how to use it:; 31 ; 32Begin_Macro(source); 33{; 34 auto c = new TCanvas(""c"",""TGraph2DErrors example"",0,0,600,600);; 35 Double_t P = 6.;; 36 Int_t np = 200;; 37 ; 38 Double_t *rx=0, *ry=0, *rz=0;; 39 Double_t *ex=0, *ey=0, *ez=0;; 40 ; 41 rx = new Double_t[np];; 42 ry = new Double_t[np];; 43 rz = new Double_t[np];; 44 ex = new Double_t[np];; 45 ey = new Double_t[np];; 46 ez = new Double_t[np];; 47 ; 48 auto r = new TRandom();; 49 ; 50 for (Int_t N=0; N<np;N++) {; 51 rx[N] = 2*P*(r->Rndm(N))-P;; 52 ry[N] = 2*P*(r->Rndm(N))-P;; 53 rz[N] = rx[N]*rx[N]-ry[N]*ry[N];; 54 rx[N] = 10.+rx[N];; 55 ry[N] = 10.+ry[N];; 56 rz[N] = 40.+rz[N];; 57 ex[N] = r->Rndm(N);; 58 ey[N] = r->Rndm(N);; 59 ez[N] = 10*r->Rndm(N);; 60 }; 61 ; 62 auto g = new TGraph2DErrors(np, rx, ry, rz, ex, ey, ez);; 63 g->SetTitle(""TGraph2D with error bars: option \""ERR\"""");; 64 g->SetFillColor(29);; 65 g->SetMarkerSize(0.8);; 66 g->SetMarkerStyle(20);; 67 g->SetMarkerColor(kRed);; 68 g->SetLineColor(kBlue-3);; 69 g->SetLineWidth(2);; 70 gPad->SetLogy(1);; 71 g->Draw(""err p0"");; 72}; 73End_Macro; 74*/; 75 ; 76 ; 77////////////////////////////////////////////////////////////////////////////////; 78/// TGraph2DErrors default constructor; 79 ; 80TGraph2DErrors::TGraph2DErrors() {}; 81 ; 82 ; 83////////////////////////////////////////////////////////////////////////////////; 84/// TGraph2DErrors normal constructor; 85/// the arrays are preset to zero; 86 ; 87TGraph2DErrors::TGraph2DErrors(Int_t n); 88 : TGraph2D(n); 89{; 90 if (n <= 0) {; 91 Error(""TGraph2DErrors"", ""Invalid number of points (%d)"", n);; 92 return;; 93 }; 94 ; 95 fEX = new Double_t[n];; 96 fEY = new Double_t[n];; 97 fEZ = new Double_t[n];; 98 ; 99 for (Int_t i=0;i<n;i++) {; 100 fEX[i] = 0;; 101 fEY[i] = 0;; 102 f",MatchSource.WIKI,doc/master/TGraph2DErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2DErrors_8cxx_source.html
https://root.cern/doc/master/TGraph2DErrors_8cxx_source.html:5233,Availability,error,error,5233,"9 delete [] fEX;; 140 delete [] fEY;; 141 delete [] fEZ;; 142}; 143 ; 144////////////////////////////////////////////////////////////////////////////////; 145/// Copy constructor.; 146/// Copy everything except list of functions; 147 ; 148TGraph2DErrors::TGraph2DErrors(const TGraph2DErrors &g); 149: TGraph2D(g), fEX(nullptr), fEY(nullptr), fEZ(nullptr); 150{; 151 if (fSize > 0) {; 152 fEX = new Double_t[fSize];; 153 fEY = new Double_t[fSize];; 154 fEZ = new Double_t[fSize];; 155 for (Int_t n = 0; n < fSize; n++) {; 156 fEX[n] = g.fEX[n];; 157 fEY[n] = g.fEY[n];; 158 fEZ[n] = g.fEZ[n];; 159 }; 160 }; 161}; 162 ; 163////////////////////////////////////////////////////////////////////////////////; 164/// Assignment operator; 165/// Copy everything except list of functions; 166 ; 167TGraph2DErrors &TGraph2DErrors::operator=(const TGraph2DErrors &g); 168{; 169 if (this == &g) return *this;; 170 ; 171 // call operator= on TGraph2D; 172 this->TGraph2D::operator=(static_cast<const TGraph2D&>(g) );; 173 ; 174 // delete before existing contained objects; 175 if (fEX) delete [] fEX;; 176 if (fEY) delete [] fEY;; 177 if (fEZ) delete [] fEZ;; 178 ; 179 fEX = (fSize > 0) ? new Double_t[fSize] : nullptr;; 180 fEY = (fSize > 0) ? new Double_t[fSize] : nullptr;; 181 fEZ = (fSize > 0) ? new Double_t[fSize] : nullptr;; 182 ; 183 ; 184 // copy error arrays; 185 for (Int_t n = 0; n < fSize; n++) {; 186 fEX[n] = g.fEX[n];; 187 fEY[n] = g.fEY[n];; 188 fEZ[n] = g.fEZ[n];; 189 }; 190 return *this;; 191}; 192 ; 193////////////////////////////////////////////////////////////////////////////////; 194/// Add a point with errorbars to the graph.; 195 ; 196void TGraph2DErrors::AddPointError(Double_t x, Double_t y, Double_t z, Double_t ex, Double_t ey, Double_t ez); 197{; 198 AddPoint(x, y, z); // this will increase fNpoints by one; 199 SetPointError(fNpoints - 1, ex, ey, ez);; 200}; 201 ; 202////////////////////////////////////////////////////////////////////////////////; 203/// This function is ",MatchSource.WIKI,doc/master/TGraph2DErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2DErrors_8cxx_source.html
https://root.cern/doc/master/TGraph2DErrors_8cxx_source.html:5507,Availability,error,errorbars,5507,"n] = g.fEY[n];; 158 fEZ[n] = g.fEZ[n];; 159 }; 160 }; 161}; 162 ; 163////////////////////////////////////////////////////////////////////////////////; 164/// Assignment operator; 165/// Copy everything except list of functions; 166 ; 167TGraph2DErrors &TGraph2DErrors::operator=(const TGraph2DErrors &g); 168{; 169 if (this == &g) return *this;; 170 ; 171 // call operator= on TGraph2D; 172 this->TGraph2D::operator=(static_cast<const TGraph2D&>(g) );; 173 ; 174 // delete before existing contained objects; 175 if (fEX) delete [] fEX;; 176 if (fEY) delete [] fEY;; 177 if (fEZ) delete [] fEZ;; 178 ; 179 fEX = (fSize > 0) ? new Double_t[fSize] : nullptr;; 180 fEY = (fSize > 0) ? new Double_t[fSize] : nullptr;; 181 fEZ = (fSize > 0) ? new Double_t[fSize] : nullptr;; 182 ; 183 ; 184 // copy error arrays; 185 for (Int_t n = 0; n < fSize; n++) {; 186 fEX[n] = g.fEX[n];; 187 fEY[n] = g.fEY[n];; 188 fEZ[n] = g.fEZ[n];; 189 }; 190 return *this;; 191}; 192 ; 193////////////////////////////////////////////////////////////////////////////////; 194/// Add a point with errorbars to the graph.; 195 ; 196void TGraph2DErrors::AddPointError(Double_t x, Double_t y, Double_t z, Double_t ex, Double_t ey, Double_t ez); 197{; 198 AddPoint(x, y, z); // this will increase fNpoints by one; 199 SetPointError(fNpoints - 1, ex, ey, ez);; 200}; 201 ; 202////////////////////////////////////////////////////////////////////////////////; 203/// This function is called by Graph2DFitChisquare.; 204/// It returns the error along X at point i.; 205 ; 206Double_t TGraph2DErrors::GetErrorX(Int_t i) const; 207{; 208 if (i < 0 || i >= fNpoints) return -1;; 209 if (fEX) return fEX[i];; 210 return -1;; 211}; 212 ; 213 ; 214////////////////////////////////////////////////////////////////////////////////; 215/// This function is called by Graph2DFitChisquare.; 216/// It returns the error along Y at point i.; 217 ; 218Double_t TGraph2DErrors::GetErrorY(Int_t i) const; 219{; 220 if (i < 0 || i >= fNpoints) return -1;; ",MatchSource.WIKI,doc/master/TGraph2DErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2DErrors_8cxx_source.html
https://root.cern/doc/master/TGraph2DErrors_8cxx_source.html:5941,Availability,error,error,5941,"jects; 175 if (fEX) delete [] fEX;; 176 if (fEY) delete [] fEY;; 177 if (fEZ) delete [] fEZ;; 178 ; 179 fEX = (fSize > 0) ? new Double_t[fSize] : nullptr;; 180 fEY = (fSize > 0) ? new Double_t[fSize] : nullptr;; 181 fEZ = (fSize > 0) ? new Double_t[fSize] : nullptr;; 182 ; 183 ; 184 // copy error arrays; 185 for (Int_t n = 0; n < fSize; n++) {; 186 fEX[n] = g.fEX[n];; 187 fEY[n] = g.fEY[n];; 188 fEZ[n] = g.fEZ[n];; 189 }; 190 return *this;; 191}; 192 ; 193////////////////////////////////////////////////////////////////////////////////; 194/// Add a point with errorbars to the graph.; 195 ; 196void TGraph2DErrors::AddPointError(Double_t x, Double_t y, Double_t z, Double_t ex, Double_t ey, Double_t ez); 197{; 198 AddPoint(x, y, z); // this will increase fNpoints by one; 199 SetPointError(fNpoints - 1, ex, ey, ez);; 200}; 201 ; 202////////////////////////////////////////////////////////////////////////////////; 203/// This function is called by Graph2DFitChisquare.; 204/// It returns the error along X at point i.; 205 ; 206Double_t TGraph2DErrors::GetErrorX(Int_t i) const; 207{; 208 if (i < 0 || i >= fNpoints) return -1;; 209 if (fEX) return fEX[i];; 210 return -1;; 211}; 212 ; 213 ; 214////////////////////////////////////////////////////////////////////////////////; 215/// This function is called by Graph2DFitChisquare.; 216/// It returns the error along Y at point i.; 217 ; 218Double_t TGraph2DErrors::GetErrorY(Int_t i) const; 219{; 220 if (i < 0 || i >= fNpoints) return -1;; 221 if (fEY) return fEY[i];; 222 return -1;; 223}; 224 ; 225 ; 226////////////////////////////////////////////////////////////////////////////////; 227/// This function is called by Graph2DFitChisquare.; 228/// It returns the error along Z at point i.; 229 ; 230Double_t TGraph2DErrors::GetErrorZ(Int_t i) const; 231{; 232 if (i < 0 || i >= fNpoints) return -1;; 233 if (fEZ) return fEZ[i];; 234 return -1;; 235}; 236 ; 237 ; 238////////////////////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TGraph2DErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2DErrors_8cxx_source.html
https://root.cern/doc/master/TGraph2DErrors_8cxx_source.html:6304,Availability,error,error,6304,"EX[n];; 187 fEY[n] = g.fEY[n];; 188 fEZ[n] = g.fEZ[n];; 189 }; 190 return *this;; 191}; 192 ; 193////////////////////////////////////////////////////////////////////////////////; 194/// Add a point with errorbars to the graph.; 195 ; 196void TGraph2DErrors::AddPointError(Double_t x, Double_t y, Double_t z, Double_t ex, Double_t ey, Double_t ez); 197{; 198 AddPoint(x, y, z); // this will increase fNpoints by one; 199 SetPointError(fNpoints - 1, ex, ey, ez);; 200}; 201 ; 202////////////////////////////////////////////////////////////////////////////////; 203/// This function is called by Graph2DFitChisquare.; 204/// It returns the error along X at point i.; 205 ; 206Double_t TGraph2DErrors::GetErrorX(Int_t i) const; 207{; 208 if (i < 0 || i >= fNpoints) return -1;; 209 if (fEX) return fEX[i];; 210 return -1;; 211}; 212 ; 213 ; 214////////////////////////////////////////////////////////////////////////////////; 215/// This function is called by Graph2DFitChisquare.; 216/// It returns the error along Y at point i.; 217 ; 218Double_t TGraph2DErrors::GetErrorY(Int_t i) const; 219{; 220 if (i < 0 || i >= fNpoints) return -1;; 221 if (fEY) return fEY[i];; 222 return -1;; 223}; 224 ; 225 ; 226////////////////////////////////////////////////////////////////////////////////; 227/// This function is called by Graph2DFitChisquare.; 228/// It returns the error along Z at point i.; 229 ; 230Double_t TGraph2DErrors::GetErrorZ(Int_t i) const; 231{; 232 if (i < 0 || i >= fNpoints) return -1;; 233 if (fEZ) return fEZ[i];; 234 return -1;; 235}; 236 ; 237 ; 238////////////////////////////////////////////////////////////////////////////////; 239/// Returns the X maximum with errors.; 240 ; 241Double_t TGraph2DErrors::GetXmaxE() const; 242{; 243 Double_t v = fX[0]+fEX[0];; 244 for (Int_t i=1; i<fNpoints; i++) if (fX[i]+fEX[i]>v) v=fX[i]+fEX[i];; 245 return v;; 246}; 247 ; 248 ; 249////////////////////////////////////////////////////////////////////////////////; 250/// Returns the X minimum",MatchSource.WIKI,doc/master/TGraph2DErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2DErrors_8cxx_source.html
https://root.cern/doc/master/TGraph2DErrors_8cxx_source.html:6667,Availability,error,error,6667,"int(x, y, z); // this will increase fNpoints by one; 199 SetPointError(fNpoints - 1, ex, ey, ez);; 200}; 201 ; 202////////////////////////////////////////////////////////////////////////////////; 203/// This function is called by Graph2DFitChisquare.; 204/// It returns the error along X at point i.; 205 ; 206Double_t TGraph2DErrors::GetErrorX(Int_t i) const; 207{; 208 if (i < 0 || i >= fNpoints) return -1;; 209 if (fEX) return fEX[i];; 210 return -1;; 211}; 212 ; 213 ; 214////////////////////////////////////////////////////////////////////////////////; 215/// This function is called by Graph2DFitChisquare.; 216/// It returns the error along Y at point i.; 217 ; 218Double_t TGraph2DErrors::GetErrorY(Int_t i) const; 219{; 220 if (i < 0 || i >= fNpoints) return -1;; 221 if (fEY) return fEY[i];; 222 return -1;; 223}; 224 ; 225 ; 226////////////////////////////////////////////////////////////////////////////////; 227/// This function is called by Graph2DFitChisquare.; 228/// It returns the error along Z at point i.; 229 ; 230Double_t TGraph2DErrors::GetErrorZ(Int_t i) const; 231{; 232 if (i < 0 || i >= fNpoints) return -1;; 233 if (fEZ) return fEZ[i];; 234 return -1;; 235}; 236 ; 237 ; 238////////////////////////////////////////////////////////////////////////////////; 239/// Returns the X maximum with errors.; 240 ; 241Double_t TGraph2DErrors::GetXmaxE() const; 242{; 243 Double_t v = fX[0]+fEX[0];; 244 for (Int_t i=1; i<fNpoints; i++) if (fX[i]+fEX[i]>v) v=fX[i]+fEX[i];; 245 return v;; 246}; 247 ; 248 ; 249////////////////////////////////////////////////////////////////////////////////; 250/// Returns the X minimum with errors.; 251 ; 252Double_t TGraph2DErrors::GetXminE() const; 253{; 254 Double_t v = fX[0]-fEX[0];; 255 for (Int_t i=1; i<fNpoints; i++) if (fX[i]-fEX[i]<v) v=fX[i]-fEX[i];; 256 return v;; 257}; 258 ; 259 ; 260////////////////////////////////////////////////////////////////////////////////; 261/// Returns the Y maximum with errors.; 262 ; 263Double_t TGrap",MatchSource.WIKI,doc/master/TGraph2DErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2DErrors_8cxx_source.html
https://root.cern/doc/master/TGraph2DErrors_8cxx_source.html:6986,Availability,error,errors,6986,///////////////////; 203/// This function is called by Graph2DFitChisquare.; 204/// It returns the error along X at point i.; 205 ; 206Double_t TGraph2DErrors::GetErrorX(Int_t i) const; 207{; 208 if (i < 0 || i >= fNpoints) return -1;; 209 if (fEX) return fEX[i];; 210 return -1;; 211}; 212 ; 213 ; 214////////////////////////////////////////////////////////////////////////////////; 215/// This function is called by Graph2DFitChisquare.; 216/// It returns the error along Y at point i.; 217 ; 218Double_t TGraph2DErrors::GetErrorY(Int_t i) const; 219{; 220 if (i < 0 || i >= fNpoints) return -1;; 221 if (fEY) return fEY[i];; 222 return -1;; 223}; 224 ; 225 ; 226////////////////////////////////////////////////////////////////////////////////; 227/// This function is called by Graph2DFitChisquare.; 228/// It returns the error along Z at point i.; 229 ; 230Double_t TGraph2DErrors::GetErrorZ(Int_t i) const; 231{; 232 if (i < 0 || i >= fNpoints) return -1;; 233 if (fEZ) return fEZ[i];; 234 return -1;; 235}; 236 ; 237 ; 238////////////////////////////////////////////////////////////////////////////////; 239/// Returns the X maximum with errors.; 240 ; 241Double_t TGraph2DErrors::GetXmaxE() const; 242{; 243 Double_t v = fX[0]+fEX[0];; 244 for (Int_t i=1; i<fNpoints; i++) if (fX[i]+fEX[i]>v) v=fX[i]+fEX[i];; 245 return v;; 246}; 247 ; 248 ; 249////////////////////////////////////////////////////////////////////////////////; 250/// Returns the X minimum with errors.; 251 ; 252Double_t TGraph2DErrors::GetXminE() const; 253{; 254 Double_t v = fX[0]-fEX[0];; 255 for (Int_t i=1; i<fNpoints; i++) if (fX[i]-fEX[i]<v) v=fX[i]-fEX[i];; 256 return v;; 257}; 258 ; 259 ; 260////////////////////////////////////////////////////////////////////////////////; 261/// Returns the Y maximum with errors.; 262 ; 263Double_t TGraph2DErrors::GetYmaxE() const; 264{; 265 Double_t v = fY[0]+fEY[0];; 266 for (Int_t i=1; i<fNpoints; i++) if (fY[i]+fEY[i]>v) v=fY[i]+fEY[i];; 267 return v;; 268}; 269 ; 270 ; 2,MatchSource.WIKI,doc/master/TGraph2DErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2DErrors_8cxx_source.html
https://root.cern/doc/master/TGraph2DErrors_8cxx_source.html:7311,Availability,error,errors,7311,/////////////////////////////////////////////////////////////////////; 215/// This function is called by Graph2DFitChisquare.; 216/// It returns the error along Y at point i.; 217 ; 218Double_t TGraph2DErrors::GetErrorY(Int_t i) const; 219{; 220 if (i < 0 || i >= fNpoints) return -1;; 221 if (fEY) return fEY[i];; 222 return -1;; 223}; 224 ; 225 ; 226////////////////////////////////////////////////////////////////////////////////; 227/// This function is called by Graph2DFitChisquare.; 228/// It returns the error along Z at point i.; 229 ; 230Double_t TGraph2DErrors::GetErrorZ(Int_t i) const; 231{; 232 if (i < 0 || i >= fNpoints) return -1;; 233 if (fEZ) return fEZ[i];; 234 return -1;; 235}; 236 ; 237 ; 238////////////////////////////////////////////////////////////////////////////////; 239/// Returns the X maximum with errors.; 240 ; 241Double_t TGraph2DErrors::GetXmaxE() const; 242{; 243 Double_t v = fX[0]+fEX[0];; 244 for (Int_t i=1; i<fNpoints; i++) if (fX[i]+fEX[i]>v) v=fX[i]+fEX[i];; 245 return v;; 246}; 247 ; 248 ; 249////////////////////////////////////////////////////////////////////////////////; 250/// Returns the X minimum with errors.; 251 ; 252Double_t TGraph2DErrors::GetXminE() const; 253{; 254 Double_t v = fX[0]-fEX[0];; 255 for (Int_t i=1; i<fNpoints; i++) if (fX[i]-fEX[i]<v) v=fX[i]-fEX[i];; 256 return v;; 257}; 258 ; 259 ; 260////////////////////////////////////////////////////////////////////////////////; 261/// Returns the Y maximum with errors.; 262 ; 263Double_t TGraph2DErrors::GetYmaxE() const; 264{; 265 Double_t v = fY[0]+fEY[0];; 266 for (Int_t i=1; i<fNpoints; i++) if (fY[i]+fEY[i]>v) v=fY[i]+fEY[i];; 267 return v;; 268}; 269 ; 270 ; 271////////////////////////////////////////////////////////////////////////////////; 272/// Returns the Y minimum with errors.; 273 ; 274Double_t TGraph2DErrors::GetYminE() const; 275{; 276 Double_t v = fY[0]-fEY[0];; 277 for (Int_t i=1; i<fNpoints; i++) if (fY[i]-fEY[i]<v) v=fY[i]-fEY[i];; 278 return v;; 279}; 2,MatchSource.WIKI,doc/master/TGraph2DErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2DErrors_8cxx_source.html
https://root.cern/doc/master/TGraph2DErrors_8cxx_source.html:7636,Availability,error,errors,7636, -1;; 223}; 224 ; 225 ; 226////////////////////////////////////////////////////////////////////////////////; 227/// This function is called by Graph2DFitChisquare.; 228/// It returns the error along Z at point i.; 229 ; 230Double_t TGraph2DErrors::GetErrorZ(Int_t i) const; 231{; 232 if (i < 0 || i >= fNpoints) return -1;; 233 if (fEZ) return fEZ[i];; 234 return -1;; 235}; 236 ; 237 ; 238////////////////////////////////////////////////////////////////////////////////; 239/// Returns the X maximum with errors.; 240 ; 241Double_t TGraph2DErrors::GetXmaxE() const; 242{; 243 Double_t v = fX[0]+fEX[0];; 244 for (Int_t i=1; i<fNpoints; i++) if (fX[i]+fEX[i]>v) v=fX[i]+fEX[i];; 245 return v;; 246}; 247 ; 248 ; 249////////////////////////////////////////////////////////////////////////////////; 250/// Returns the X minimum with errors.; 251 ; 252Double_t TGraph2DErrors::GetXminE() const; 253{; 254 Double_t v = fX[0]-fEX[0];; 255 for (Int_t i=1; i<fNpoints; i++) if (fX[i]-fEX[i]<v) v=fX[i]-fEX[i];; 256 return v;; 257}; 258 ; 259 ; 260////////////////////////////////////////////////////////////////////////////////; 261/// Returns the Y maximum with errors.; 262 ; 263Double_t TGraph2DErrors::GetYmaxE() const; 264{; 265 Double_t v = fY[0]+fEY[0];; 266 for (Int_t i=1; i<fNpoints; i++) if (fY[i]+fEY[i]>v) v=fY[i]+fEY[i];; 267 return v;; 268}; 269 ; 270 ; 271////////////////////////////////////////////////////////////////////////////////; 272/// Returns the Y minimum with errors.; 273 ; 274Double_t TGraph2DErrors::GetYminE() const; 275{; 276 Double_t v = fY[0]-fEY[0];; 277 for (Int_t i=1; i<fNpoints; i++) if (fY[i]-fEY[i]<v) v=fY[i]-fEY[i];; 278 return v;; 279}; 280 ; 281 ; 282////////////////////////////////////////////////////////////////////////////////; 283/// Returns the Z maximum with errors.; 284 ; 285Double_t TGraph2DErrors::GetZmaxE() const; 286{; 287 Double_t v = fZ[0]+fEZ[0];; 288 for (Int_t i=1; i<fNpoints; i++) if (fZ[i]+fEZ[i]>v) v=fZ[i]+fEZ[i];; 289 return v;; 290}; 2,MatchSource.WIKI,doc/master/TGraph2DErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2DErrors_8cxx_source.html
https://root.cern/doc/master/TGraph2DErrors_8cxx_source.html:7961,Availability,error,errors,7961,33 if (fEZ) return fEZ[i];; 234 return -1;; 235}; 236 ; 237 ; 238////////////////////////////////////////////////////////////////////////////////; 239/// Returns the X maximum with errors.; 240 ; 241Double_t TGraph2DErrors::GetXmaxE() const; 242{; 243 Double_t v = fX[0]+fEX[0];; 244 for (Int_t i=1; i<fNpoints; i++) if (fX[i]+fEX[i]>v) v=fX[i]+fEX[i];; 245 return v;; 246}; 247 ; 248 ; 249////////////////////////////////////////////////////////////////////////////////; 250/// Returns the X minimum with errors.; 251 ; 252Double_t TGraph2DErrors::GetXminE() const; 253{; 254 Double_t v = fX[0]-fEX[0];; 255 for (Int_t i=1; i<fNpoints; i++) if (fX[i]-fEX[i]<v) v=fX[i]-fEX[i];; 256 return v;; 257}; 258 ; 259 ; 260////////////////////////////////////////////////////////////////////////////////; 261/// Returns the Y maximum with errors.; 262 ; 263Double_t TGraph2DErrors::GetYmaxE() const; 264{; 265 Double_t v = fY[0]+fEY[0];; 266 for (Int_t i=1; i<fNpoints; i++) if (fY[i]+fEY[i]>v) v=fY[i]+fEY[i];; 267 return v;; 268}; 269 ; 270 ; 271////////////////////////////////////////////////////////////////////////////////; 272/// Returns the Y minimum with errors.; 273 ; 274Double_t TGraph2DErrors::GetYminE() const; 275{; 276 Double_t v = fY[0]-fEY[0];; 277 for (Int_t i=1; i<fNpoints; i++) if (fY[i]-fEY[i]<v) v=fY[i]-fEY[i];; 278 return v;; 279}; 280 ; 281 ; 282////////////////////////////////////////////////////////////////////////////////; 283/// Returns the Z maximum with errors.; 284 ; 285Double_t TGraph2DErrors::GetZmaxE() const; 286{; 287 Double_t v = fZ[0]+fEZ[0];; 288 for (Int_t i=1; i<fNpoints; i++) if (fZ[i]+fEZ[i]>v) v=fZ[i]+fEZ[i];; 289 return v;; 290}; 291 ; 292 ; 293////////////////////////////////////////////////////////////////////////////////; 294/// Returns the Z minimum with errors.; 295 ; 296Double_t TGraph2DErrors::GetZminE() const; 297{; 298 Double_t v = fZ[0]-fEZ[0];; 299 for (Int_t i=1; i<fNpoints; i++) if (fZ[i]-fEZ[i]<v) v=fZ[i]-fEZ[i];; 300 return v;; 301}; 3,MatchSource.WIKI,doc/master/TGraph2DErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2DErrors_8cxx_source.html
https://root.cern/doc/master/TGraph2DErrors_8cxx_source.html:8286,Availability,error,errors,8286,"]+fEX[i]>v) v=fX[i]+fEX[i];; 245 return v;; 246}; 247 ; 248 ; 249////////////////////////////////////////////////////////////////////////////////; 250/// Returns the X minimum with errors.; 251 ; 252Double_t TGraph2DErrors::GetXminE() const; 253{; 254 Double_t v = fX[0]-fEX[0];; 255 for (Int_t i=1; i<fNpoints; i++) if (fX[i]-fEX[i]<v) v=fX[i]-fEX[i];; 256 return v;; 257}; 258 ; 259 ; 260////////////////////////////////////////////////////////////////////////////////; 261/// Returns the Y maximum with errors.; 262 ; 263Double_t TGraph2DErrors::GetYmaxE() const; 264{; 265 Double_t v = fY[0]+fEY[0];; 266 for (Int_t i=1; i<fNpoints; i++) if (fY[i]+fEY[i]>v) v=fY[i]+fEY[i];; 267 return v;; 268}; 269 ; 270 ; 271////////////////////////////////////////////////////////////////////////////////; 272/// Returns the Y minimum with errors.; 273 ; 274Double_t TGraph2DErrors::GetYminE() const; 275{; 276 Double_t v = fY[0]-fEY[0];; 277 for (Int_t i=1; i<fNpoints; i++) if (fY[i]-fEY[i]<v) v=fY[i]-fEY[i];; 278 return v;; 279}; 280 ; 281 ; 282////////////////////////////////////////////////////////////////////////////////; 283/// Returns the Z maximum with errors.; 284 ; 285Double_t TGraph2DErrors::GetZmaxE() const; 286{; 287 Double_t v = fZ[0]+fEZ[0];; 288 for (Int_t i=1; i<fNpoints; i++) if (fZ[i]+fEZ[i]>v) v=fZ[i]+fEZ[i];; 289 return v;; 290}; 291 ; 292 ; 293////////////////////////////////////////////////////////////////////////////////; 294/// Returns the Z minimum with errors.; 295 ; 296Double_t TGraph2DErrors::GetZminE() const; 297{; 298 Double_t v = fZ[0]-fEZ[0];; 299 for (Int_t i=1; i<fNpoints; i++) if (fZ[i]-fEZ[i]<v) v=fZ[i]-fEZ[i];; 300 return v;; 301}; 302 ; 303 ; 304////////////////////////////////////////////////////////////////////////////////; 305/// Print 2D graph and errors values.; 306 ; 307void TGraph2DErrors::Print(Option_t *) const; 308{; 309 for (Int_t i = 0; i < fNpoints; i++) {; 310 printf(""x[%d]=%g, y[%d]=%g, z[%d]=%g, ex[%d]=%g, ey[%d]=%g, ez[%d]=%g\n"", i, f",MatchSource.WIKI,doc/master/TGraph2DErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2DErrors_8cxx_source.html
https://root.cern/doc/master/TGraph2DErrors_8cxx_source.html:8611,Availability,error,errors,8611,"]-fEX[i]<v) v=fX[i]-fEX[i];; 256 return v;; 257}; 258 ; 259 ; 260////////////////////////////////////////////////////////////////////////////////; 261/// Returns the Y maximum with errors.; 262 ; 263Double_t TGraph2DErrors::GetYmaxE() const; 264{; 265 Double_t v = fY[0]+fEY[0];; 266 for (Int_t i=1; i<fNpoints; i++) if (fY[i]+fEY[i]>v) v=fY[i]+fEY[i];; 267 return v;; 268}; 269 ; 270 ; 271////////////////////////////////////////////////////////////////////////////////; 272/// Returns the Y minimum with errors.; 273 ; 274Double_t TGraph2DErrors::GetYminE() const; 275{; 276 Double_t v = fY[0]-fEY[0];; 277 for (Int_t i=1; i<fNpoints; i++) if (fY[i]-fEY[i]<v) v=fY[i]-fEY[i];; 278 return v;; 279}; 280 ; 281 ; 282////////////////////////////////////////////////////////////////////////////////; 283/// Returns the Z maximum with errors.; 284 ; 285Double_t TGraph2DErrors::GetZmaxE() const; 286{; 287 Double_t v = fZ[0]+fEZ[0];; 288 for (Int_t i=1; i<fNpoints; i++) if (fZ[i]+fEZ[i]>v) v=fZ[i]+fEZ[i];; 289 return v;; 290}; 291 ; 292 ; 293////////////////////////////////////////////////////////////////////////////////; 294/// Returns the Z minimum with errors.; 295 ; 296Double_t TGraph2DErrors::GetZminE() const; 297{; 298 Double_t v = fZ[0]-fEZ[0];; 299 for (Int_t i=1; i<fNpoints; i++) if (fZ[i]-fEZ[i]<v) v=fZ[i]-fEZ[i];; 300 return v;; 301}; 302 ; 303 ; 304////////////////////////////////////////////////////////////////////////////////; 305/// Print 2D graph and errors values.; 306 ; 307void TGraph2DErrors::Print(Option_t *) const; 308{; 309 for (Int_t i = 0; i < fNpoints; i++) {; 310 printf(""x[%d]=%g, y[%d]=%g, z[%d]=%g, ex[%d]=%g, ey[%d]=%g, ez[%d]=%g\n"", i, fX[i], i, fY[i], i, fZ[i], i, fEX[i], i, fEY[i], i, fEZ[i]);; 311 }; 312}; 313 ; 314////////////////////////////////////////////////////////////////////////////////; 315/// Multiply the values and errors of a TGraph2DErrors by a constant c1.; 316///; 317/// If option contains ""x"" the x values and errors are scaled; 318/// If",MatchSource.WIKI,doc/master/TGraph2DErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2DErrors_8cxx_source.html
https://root.cern/doc/master/TGraph2DErrors_8cxx_source.html:8928,Availability,error,errors,8928,"]+fEY[i]>v) v=fY[i]+fEY[i];; 267 return v;; 268}; 269 ; 270 ; 271////////////////////////////////////////////////////////////////////////////////; 272/// Returns the Y minimum with errors.; 273 ; 274Double_t TGraph2DErrors::GetYminE() const; 275{; 276 Double_t v = fY[0]-fEY[0];; 277 for (Int_t i=1; i<fNpoints; i++) if (fY[i]-fEY[i]<v) v=fY[i]-fEY[i];; 278 return v;; 279}; 280 ; 281 ; 282////////////////////////////////////////////////////////////////////////////////; 283/// Returns the Z maximum with errors.; 284 ; 285Double_t TGraph2DErrors::GetZmaxE() const; 286{; 287 Double_t v = fZ[0]+fEZ[0];; 288 for (Int_t i=1; i<fNpoints; i++) if (fZ[i]+fEZ[i]>v) v=fZ[i]+fEZ[i];; 289 return v;; 290}; 291 ; 292 ; 293////////////////////////////////////////////////////////////////////////////////; 294/// Returns the Z minimum with errors.; 295 ; 296Double_t TGraph2DErrors::GetZminE() const; 297{; 298 Double_t v = fZ[0]-fEZ[0];; 299 for (Int_t i=1; i<fNpoints; i++) if (fZ[i]-fEZ[i]<v) v=fZ[i]-fEZ[i];; 300 return v;; 301}; 302 ; 303 ; 304////////////////////////////////////////////////////////////////////////////////; 305/// Print 2D graph and errors values.; 306 ; 307void TGraph2DErrors::Print(Option_t *) const; 308{; 309 for (Int_t i = 0; i < fNpoints; i++) {; 310 printf(""x[%d]=%g, y[%d]=%g, z[%d]=%g, ex[%d]=%g, ey[%d]=%g, ez[%d]=%g\n"", i, fX[i], i, fY[i], i, fZ[i], i, fEX[i], i, fEY[i], i, fEZ[i]);; 311 }; 312}; 313 ; 314////////////////////////////////////////////////////////////////////////////////; 315/// Multiply the values and errors of a TGraph2DErrors by a constant c1.; 316///; 317/// If option contains ""x"" the x values and errors are scaled; 318/// If option contains ""y"" the y values and errors are scaled; 319/// If option contains ""z"" the z values and errors are scaled; 320/// If option contains ""xyz"" all three x, y and z values and errors are scaled; 321 ; 322void TGraph2DErrors::Scale(Double_t c1, Option_t *option); 323{; 324 TGraph2D::Scale(c1, option);; 325 TStrin",MatchSource.WIKI,doc/master/TGraph2DErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2DErrors_8cxx_source.html
https://root.cern/doc/master/TGraph2DErrors_8cxx_source.html:9327,Availability,error,errors,9327,"80 ; 281 ; 282////////////////////////////////////////////////////////////////////////////////; 283/// Returns the Z maximum with errors.; 284 ; 285Double_t TGraph2DErrors::GetZmaxE() const; 286{; 287 Double_t v = fZ[0]+fEZ[0];; 288 for (Int_t i=1; i<fNpoints; i++) if (fZ[i]+fEZ[i]>v) v=fZ[i]+fEZ[i];; 289 return v;; 290}; 291 ; 292 ; 293////////////////////////////////////////////////////////////////////////////////; 294/// Returns the Z minimum with errors.; 295 ; 296Double_t TGraph2DErrors::GetZminE() const; 297{; 298 Double_t v = fZ[0]-fEZ[0];; 299 for (Int_t i=1; i<fNpoints; i++) if (fZ[i]-fEZ[i]<v) v=fZ[i]-fEZ[i];; 300 return v;; 301}; 302 ; 303 ; 304////////////////////////////////////////////////////////////////////////////////; 305/// Print 2D graph and errors values.; 306 ; 307void TGraph2DErrors::Print(Option_t *) const; 308{; 309 for (Int_t i = 0; i < fNpoints; i++) {; 310 printf(""x[%d]=%g, y[%d]=%g, z[%d]=%g, ex[%d]=%g, ey[%d]=%g, ez[%d]=%g\n"", i, fX[i], i, fY[i], i, fZ[i], i, fEX[i], i, fEY[i], i, fEZ[i]);; 311 }; 312}; 313 ; 314////////////////////////////////////////////////////////////////////////////////; 315/// Multiply the values and errors of a TGraph2DErrors by a constant c1.; 316///; 317/// If option contains ""x"" the x values and errors are scaled; 318/// If option contains ""y"" the y values and errors are scaled; 319/// If option contains ""z"" the z values and errors are scaled; 320/// If option contains ""xyz"" all three x, y and z values and errors are scaled; 321 ; 322void TGraph2DErrors::Scale(Double_t c1, Option_t *option); 323{; 324 TGraph2D::Scale(c1, option);; 325 TString opt = option; opt.ToLower();; 326 if (opt.Contains(""x"") && GetEX()) {; 327 for (Int_t i=0; i<GetN(); i++); 328 GetEX()[i] *= c1;; 329 }; 330 if (opt.Contains(""y"") && GetEY()) {; 331 for (Int_t i=0; i<GetN(); i++); 332 GetEY()[i] *= c1;; 333 }; 334 if (opt.Contains(""z"") && GetEZ()) {; 335 for (Int_t i=0; i<GetN(); i++); 336 GetEZ()[i] *= c1;; 337 }; 338}; 339 ; 340/////////",MatchSource.WIKI,doc/master/TGraph2DErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2DErrors_8cxx_source.html
https://root.cern/doc/master/TGraph2DErrors_8cxx_source.html:9428,Availability,error,errors,9428,"eturns the Z minimum with errors.; 295 ; 296Double_t TGraph2DErrors::GetZminE() const; 297{; 298 Double_t v = fZ[0]-fEZ[0];; 299 for (Int_t i=1; i<fNpoints; i++) if (fZ[i]-fEZ[i]<v) v=fZ[i]-fEZ[i];; 300 return v;; 301}; 302 ; 303 ; 304////////////////////////////////////////////////////////////////////////////////; 305/// Print 2D graph and errors values.; 306 ; 307void TGraph2DErrors::Print(Option_t *) const; 308{; 309 for (Int_t i = 0; i < fNpoints; i++) {; 310 printf(""x[%d]=%g, y[%d]=%g, z[%d]=%g, ex[%d]=%g, ey[%d]=%g, ez[%d]=%g\n"", i, fX[i], i, fY[i], i, fZ[i], i, fEX[i], i, fEY[i], i, fEZ[i]);; 311 }; 312}; 313 ; 314////////////////////////////////////////////////////////////////////////////////; 315/// Multiply the values and errors of a TGraph2DErrors by a constant c1.; 316///; 317/// If option contains ""x"" the x values and errors are scaled; 318/// If option contains ""y"" the y values and errors are scaled; 319/// If option contains ""z"" the z values and errors are scaled; 320/// If option contains ""xyz"" all three x, y and z values and errors are scaled; 321 ; 322void TGraph2DErrors::Scale(Double_t c1, Option_t *option); 323{; 324 TGraph2D::Scale(c1, option);; 325 TString opt = option; opt.ToLower();; 326 if (opt.Contains(""x"") && GetEX()) {; 327 for (Int_t i=0; i<GetN(); i++); 328 GetEX()[i] *= c1;; 329 }; 330 if (opt.Contains(""y"") && GetEY()) {; 331 for (Int_t i=0; i<GetN(); i++); 332 GetEY()[i] *= c1;; 333 }; 334 if (opt.Contains(""z"") && GetEZ()) {; 335 for (Int_t i=0; i<GetN(); i++); 336 GetEZ()[i] *= c1;; 337 }; 338}; 339 ; 340////////////////////////////////////////////////////////////////////////////////; 341/// Set number of points in the 2D graph.; 342/// Existing coordinates are preserved.; 343/// New coordinates above fNpoints are preset to 0.; 344 ; 345void TGraph2DErrors::Set(Int_t n); 346{; 347 if (n < 0) n = 0;; 348 if (n == fNpoints) return;; 349 if (n > fNpoints) SetPointError(n,0,0,0);; 350 fNpoints = n;; 351}; 352 ; 353////////////////////////",MatchSource.WIKI,doc/master/TGraph2DErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2DErrors_8cxx_source.html
https://root.cern/doc/master/TGraph2DErrors_8cxx_source.html:9494,Availability,error,errors,9494,"eturns the Z minimum with errors.; 295 ; 296Double_t TGraph2DErrors::GetZminE() const; 297{; 298 Double_t v = fZ[0]-fEZ[0];; 299 for (Int_t i=1; i<fNpoints; i++) if (fZ[i]-fEZ[i]<v) v=fZ[i]-fEZ[i];; 300 return v;; 301}; 302 ; 303 ; 304////////////////////////////////////////////////////////////////////////////////; 305/// Print 2D graph and errors values.; 306 ; 307void TGraph2DErrors::Print(Option_t *) const; 308{; 309 for (Int_t i = 0; i < fNpoints; i++) {; 310 printf(""x[%d]=%g, y[%d]=%g, z[%d]=%g, ex[%d]=%g, ey[%d]=%g, ez[%d]=%g\n"", i, fX[i], i, fY[i], i, fZ[i], i, fEX[i], i, fEY[i], i, fEZ[i]);; 311 }; 312}; 313 ; 314////////////////////////////////////////////////////////////////////////////////; 315/// Multiply the values and errors of a TGraph2DErrors by a constant c1.; 316///; 317/// If option contains ""x"" the x values and errors are scaled; 318/// If option contains ""y"" the y values and errors are scaled; 319/// If option contains ""z"" the z values and errors are scaled; 320/// If option contains ""xyz"" all three x, y and z values and errors are scaled; 321 ; 322void TGraph2DErrors::Scale(Double_t c1, Option_t *option); 323{; 324 TGraph2D::Scale(c1, option);; 325 TString opt = option; opt.ToLower();; 326 if (opt.Contains(""x"") && GetEX()) {; 327 for (Int_t i=0; i<GetN(); i++); 328 GetEX()[i] *= c1;; 329 }; 330 if (opt.Contains(""y"") && GetEY()) {; 331 for (Int_t i=0; i<GetN(); i++); 332 GetEY()[i] *= c1;; 333 }; 334 if (opt.Contains(""z"") && GetEZ()) {; 335 for (Int_t i=0; i<GetN(); i++); 336 GetEZ()[i] *= c1;; 337 }; 338}; 339 ; 340////////////////////////////////////////////////////////////////////////////////; 341/// Set number of points in the 2D graph.; 342/// Existing coordinates are preserved.; 343/// New coordinates above fNpoints are preset to 0.; 344 ; 345void TGraph2DErrors::Set(Int_t n); 346{; 347 if (n < 0) n = 0;; 348 if (n == fNpoints) return;; 349 if (n > fNpoints) SetPointError(n,0,0,0);; 350 fNpoints = n;; 351}; 352 ; 353////////////////////////",MatchSource.WIKI,doc/master/TGraph2DErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2DErrors_8cxx_source.html
https://root.cern/doc/master/TGraph2DErrors_8cxx_source.html:9560,Availability,error,errors,9560,"eturns the Z minimum with errors.; 295 ; 296Double_t TGraph2DErrors::GetZminE() const; 297{; 298 Double_t v = fZ[0]-fEZ[0];; 299 for (Int_t i=1; i<fNpoints; i++) if (fZ[i]-fEZ[i]<v) v=fZ[i]-fEZ[i];; 300 return v;; 301}; 302 ; 303 ; 304////////////////////////////////////////////////////////////////////////////////; 305/// Print 2D graph and errors values.; 306 ; 307void TGraph2DErrors::Print(Option_t *) const; 308{; 309 for (Int_t i = 0; i < fNpoints; i++) {; 310 printf(""x[%d]=%g, y[%d]=%g, z[%d]=%g, ex[%d]=%g, ey[%d]=%g, ez[%d]=%g\n"", i, fX[i], i, fY[i], i, fZ[i], i, fEX[i], i, fEY[i], i, fEZ[i]);; 311 }; 312}; 313 ; 314////////////////////////////////////////////////////////////////////////////////; 315/// Multiply the values and errors of a TGraph2DErrors by a constant c1.; 316///; 317/// If option contains ""x"" the x values and errors are scaled; 318/// If option contains ""y"" the y values and errors are scaled; 319/// If option contains ""z"" the z values and errors are scaled; 320/// If option contains ""xyz"" all three x, y and z values and errors are scaled; 321 ; 322void TGraph2DErrors::Scale(Double_t c1, Option_t *option); 323{; 324 TGraph2D::Scale(c1, option);; 325 TString opt = option; opt.ToLower();; 326 if (opt.Contains(""x"") && GetEX()) {; 327 for (Int_t i=0; i<GetN(); i++); 328 GetEX()[i] *= c1;; 329 }; 330 if (opt.Contains(""y"") && GetEY()) {; 331 for (Int_t i=0; i<GetN(); i++); 332 GetEY()[i] *= c1;; 333 }; 334 if (opt.Contains(""z"") && GetEZ()) {; 335 for (Int_t i=0; i<GetN(); i++); 336 GetEZ()[i] *= c1;; 337 }; 338}; 339 ; 340////////////////////////////////////////////////////////////////////////////////; 341/// Set number of points in the 2D graph.; 342/// Existing coordinates are preserved.; 343/// New coordinates above fNpoints are preset to 0.; 344 ; 345void TGraph2DErrors::Set(Int_t n); 346{; 347 if (n < 0) n = 0;; 348 if (n == fNpoints) return;; 349 if (n > fNpoints) SetPointError(n,0,0,0);; 350 fNpoints = n;; 351}; 352 ; 353////////////////////////",MatchSource.WIKI,doc/master/TGraph2DErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2DErrors_8cxx_source.html
https://root.cern/doc/master/TGraph2DErrors_8cxx_source.html:9643,Availability,error,errors,9643,"eturns the Z minimum with errors.; 295 ; 296Double_t TGraph2DErrors::GetZminE() const; 297{; 298 Double_t v = fZ[0]-fEZ[0];; 299 for (Int_t i=1; i<fNpoints; i++) if (fZ[i]-fEZ[i]<v) v=fZ[i]-fEZ[i];; 300 return v;; 301}; 302 ; 303 ; 304////////////////////////////////////////////////////////////////////////////////; 305/// Print 2D graph and errors values.; 306 ; 307void TGraph2DErrors::Print(Option_t *) const; 308{; 309 for (Int_t i = 0; i < fNpoints; i++) {; 310 printf(""x[%d]=%g, y[%d]=%g, z[%d]=%g, ex[%d]=%g, ey[%d]=%g, ez[%d]=%g\n"", i, fX[i], i, fY[i], i, fZ[i], i, fEX[i], i, fEY[i], i, fEZ[i]);; 311 }; 312}; 313 ; 314////////////////////////////////////////////////////////////////////////////////; 315/// Multiply the values and errors of a TGraph2DErrors by a constant c1.; 316///; 317/// If option contains ""x"" the x values and errors are scaled; 318/// If option contains ""y"" the y values and errors are scaled; 319/// If option contains ""z"" the z values and errors are scaled; 320/// If option contains ""xyz"" all three x, y and z values and errors are scaled; 321 ; 322void TGraph2DErrors::Scale(Double_t c1, Option_t *option); 323{; 324 TGraph2D::Scale(c1, option);; 325 TString opt = option; opt.ToLower();; 326 if (opt.Contains(""x"") && GetEX()) {; 327 for (Int_t i=0; i<GetN(); i++); 328 GetEX()[i] *= c1;; 329 }; 330 if (opt.Contains(""y"") && GetEY()) {; 331 for (Int_t i=0; i<GetN(); i++); 332 GetEY()[i] *= c1;; 333 }; 334 if (opt.Contains(""z"") && GetEZ()) {; 335 for (Int_t i=0; i<GetN(); i++); 336 GetEZ()[i] *= c1;; 337 }; 338}; 339 ; 340////////////////////////////////////////////////////////////////////////////////; 341/// Set number of points in the 2D graph.; 342/// Existing coordinates are preserved.; 343/// New coordinates above fNpoints are preset to 0.; 344 ; 345void TGraph2DErrors::Set(Int_t n); 346{; 347 if (n < 0) n = 0;; 348 if (n == fNpoints) return;; 349 if (n > fNpoints) SetPointError(n,0,0,0);; 350 fNpoints = n;; 351}; 352 ; 353////////////////////////",MatchSource.WIKI,doc/master/TGraph2DErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2DErrors_8cxx_source.html
https://root.cern/doc/master/TGraph2DErrors_8cxx_source.html:14427,Availability,error,errors,14427,"454 fEY[i] = ey;; 455 fEZ[i] = ez;; 456}; 457 ; 458 ; 459////////////////////////////////////////////////////////////////////////////////; 460/// Stream an object of class TGraph2DErrors.; 461 ; 462void TGraph2DErrors::Streamer(TBuffer &b); 463{; 464 if (b.IsReading()) {; 465 UInt_t R__s, R__c;; 466 Version_t R__v = b.ReadVersion(&R__s, &R__c);; 467 b.ReadClassBuffer(TGraph2DErrors::Class(), this, R__v, R__s, R__c);; 468 } else {; 469 b.WriteClassBuffer(TGraph2DErrors::Class(),this);; 470 }; 471}; b#define b(i)Definition RSha256.hxx:100; g#define g(i)Definition RSha256.hxx:105; Version_tshort Version_tDefinition RtypesCore.h:65; Option_tconst char Option_tDefinition RtypesCore.h:66; ClassImp#define ClassImp(name)Definition Rtypes.h:382; TBuffer.h; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; TGraph2DErrors.h; TH2.h; THLimitsFinder.h; TVirtualFitter.h; TVirtualPad.h; TBufferBuffer base class used for serializing objects.Definition TBuffer.h:43; TGraph2DErrorsGraph 2D class with errors.Definition TGraph2DErrors.h:26; TGraph2DErrors::Streamervoid Streamer(TBuffer &) overrideStream an object of class TGraph2DErrors.Definition TGraph2DErrors.cxx:462; TGraph2DErrors::GetErrorZDouble_t GetErrorZ(Int_t bin) const overrideThis function is called by Graph2DFitChisquare.Definition TGraph2DErrors.cxx:230; TGraph2DErrors::~TGraph2DErrors~TGraph2DErrors() overrideTGraph2DErrors destructor.Definition TGraph2DErrors.cxx:137; TGraph2DErrors::GetYminEDouble_t GetYminE() const overrideReturns the Y minimum with errors.Definition TGraph2DErrors.cxx:274; TGraph2DErrors::GetXminEDouble_t GetXminE() const overrideReturns the X minimum with errors.Definition TGraph2DErrors.cxx:252; TGraph2DErrors::GetEZDouble_t * GetEZ() const overrideDefinition TGraph2DErrors.h:47; TGraph2DErrors::fEYDouble_t * fEY[fNpoints] array of Y errorsDefinition TGraph2DErrors.h:30; TGraph2DErrors::GetEYDouble_t * GetEY() const overrideDefinition TGraph2DErrors.h:46; TGraph2DErrors::SetPoint",MatchSource.WIKI,doc/master/TGraph2DErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2DErrors_8cxx_source.html
https://root.cern/doc/master/TGraph2DErrors_8cxx_source.html:14953,Availability,error,errors,14953,"1}; b#define b(i)Definition RSha256.hxx:100; g#define g(i)Definition RSha256.hxx:105; Version_tshort Version_tDefinition RtypesCore.h:65; Option_tconst char Option_tDefinition RtypesCore.h:66; ClassImp#define ClassImp(name)Definition Rtypes.h:382; TBuffer.h; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; TGraph2DErrors.h; TH2.h; THLimitsFinder.h; TVirtualFitter.h; TVirtualPad.h; TBufferBuffer base class used for serializing objects.Definition TBuffer.h:43; TGraph2DErrorsGraph 2D class with errors.Definition TGraph2DErrors.h:26; TGraph2DErrors::Streamervoid Streamer(TBuffer &) overrideStream an object of class TGraph2DErrors.Definition TGraph2DErrors.cxx:462; TGraph2DErrors::GetErrorZDouble_t GetErrorZ(Int_t bin) const overrideThis function is called by Graph2DFitChisquare.Definition TGraph2DErrors.cxx:230; TGraph2DErrors::~TGraph2DErrors~TGraph2DErrors() overrideTGraph2DErrors destructor.Definition TGraph2DErrors.cxx:137; TGraph2DErrors::GetYminEDouble_t GetYminE() const overrideReturns the Y minimum with errors.Definition TGraph2DErrors.cxx:274; TGraph2DErrors::GetXminEDouble_t GetXminE() const overrideReturns the X minimum with errors.Definition TGraph2DErrors.cxx:252; TGraph2DErrors::GetEZDouble_t * GetEZ() const overrideDefinition TGraph2DErrors.h:47; TGraph2DErrors::fEYDouble_t * fEY[fNpoints] array of Y errorsDefinition TGraph2DErrors.h:30; TGraph2DErrors::GetEYDouble_t * GetEY() const overrideDefinition TGraph2DErrors.h:46; TGraph2DErrors::SetPointvoid SetPoint(Int_t i, Double_t x, Double_t y, Double_t z) overrideSet x, y and z values for point number i.Definition TGraph2DErrors.cxx:404; TGraph2DErrors::Scalevoid Scale(Double_t c1=1., Option_t *option=""z"") overrideMultiply the values and errors of a TGraph2DErrors by a constant c1.Definition TGraph2DErrors.cxx:322; TGraph2DErrors::fEZDouble_t * fEZ[fNpoints] array of Z errorsDefinition TGraph2DErrors.h:31; TGraph2DErrors::GetEXDouble_t * GetEX() const overrideDefinition TGraph2DErrors.h:",MatchSource.WIKI,doc/master/TGraph2DErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2DErrors_8cxx_source.html
https://root.cern/doc/master/TGraph2DErrors_8cxx_source.html:15080,Availability,error,errors,15080,"Core.h:65; Option_tconst char Option_tDefinition RtypesCore.h:66; ClassImp#define ClassImp(name)Definition Rtypes.h:382; TBuffer.h; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; TGraph2DErrors.h; TH2.h; THLimitsFinder.h; TVirtualFitter.h; TVirtualPad.h; TBufferBuffer base class used for serializing objects.Definition TBuffer.h:43; TGraph2DErrorsGraph 2D class with errors.Definition TGraph2DErrors.h:26; TGraph2DErrors::Streamervoid Streamer(TBuffer &) overrideStream an object of class TGraph2DErrors.Definition TGraph2DErrors.cxx:462; TGraph2DErrors::GetErrorZDouble_t GetErrorZ(Int_t bin) const overrideThis function is called by Graph2DFitChisquare.Definition TGraph2DErrors.cxx:230; TGraph2DErrors::~TGraph2DErrors~TGraph2DErrors() overrideTGraph2DErrors destructor.Definition TGraph2DErrors.cxx:137; TGraph2DErrors::GetYminEDouble_t GetYminE() const overrideReturns the Y minimum with errors.Definition TGraph2DErrors.cxx:274; TGraph2DErrors::GetXminEDouble_t GetXminE() const overrideReturns the X minimum with errors.Definition TGraph2DErrors.cxx:252; TGraph2DErrors::GetEZDouble_t * GetEZ() const overrideDefinition TGraph2DErrors.h:47; TGraph2DErrors::fEYDouble_t * fEY[fNpoints] array of Y errorsDefinition TGraph2DErrors.h:30; TGraph2DErrors::GetEYDouble_t * GetEY() const overrideDefinition TGraph2DErrors.h:46; TGraph2DErrors::SetPointvoid SetPoint(Int_t i, Double_t x, Double_t y, Double_t z) overrideSet x, y and z values for point number i.Definition TGraph2DErrors.cxx:404; TGraph2DErrors::Scalevoid Scale(Double_t c1=1., Option_t *option=""z"") overrideMultiply the values and errors of a TGraph2DErrors by a constant c1.Definition TGraph2DErrors.cxx:322; TGraph2DErrors::fEZDouble_t * fEZ[fNpoints] array of Z errorsDefinition TGraph2DErrors.h:31; TGraph2DErrors::GetEXDouble_t * GetEX() const overrideDefinition TGraph2DErrors.h:45; TGraph2DErrors::SetPointErrorvirtual void SetPointError(Int_t i, Double_t ex, Double_t ey, Double_t ez)Set ex, ey and ez va",MatchSource.WIKI,doc/master/TGraph2DErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2DErrors_8cxx_source.html
https://root.cern/doc/master/TGraph2DErrors_8cxx_source.html:15263,Availability,error,errorsDefinition,15263,"rors.h; TH2.h; THLimitsFinder.h; TVirtualFitter.h; TVirtualPad.h; TBufferBuffer base class used for serializing objects.Definition TBuffer.h:43; TGraph2DErrorsGraph 2D class with errors.Definition TGraph2DErrors.h:26; TGraph2DErrors::Streamervoid Streamer(TBuffer &) overrideStream an object of class TGraph2DErrors.Definition TGraph2DErrors.cxx:462; TGraph2DErrors::GetErrorZDouble_t GetErrorZ(Int_t bin) const overrideThis function is called by Graph2DFitChisquare.Definition TGraph2DErrors.cxx:230; TGraph2DErrors::~TGraph2DErrors~TGraph2DErrors() overrideTGraph2DErrors destructor.Definition TGraph2DErrors.cxx:137; TGraph2DErrors::GetYminEDouble_t GetYminE() const overrideReturns the Y minimum with errors.Definition TGraph2DErrors.cxx:274; TGraph2DErrors::GetXminEDouble_t GetXminE() const overrideReturns the X minimum with errors.Definition TGraph2DErrors.cxx:252; TGraph2DErrors::GetEZDouble_t * GetEZ() const overrideDefinition TGraph2DErrors.h:47; TGraph2DErrors::fEYDouble_t * fEY[fNpoints] array of Y errorsDefinition TGraph2DErrors.h:30; TGraph2DErrors::GetEYDouble_t * GetEY() const overrideDefinition TGraph2DErrors.h:46; TGraph2DErrors::SetPointvoid SetPoint(Int_t i, Double_t x, Double_t y, Double_t z) overrideSet x, y and z values for point number i.Definition TGraph2DErrors.cxx:404; TGraph2DErrors::Scalevoid Scale(Double_t c1=1., Option_t *option=""z"") overrideMultiply the values and errors of a TGraph2DErrors by a constant c1.Definition TGraph2DErrors.cxx:322; TGraph2DErrors::fEZDouble_t * fEZ[fNpoints] array of Z errorsDefinition TGraph2DErrors.h:31; TGraph2DErrors::GetEXDouble_t * GetEX() const overrideDefinition TGraph2DErrors.h:45; TGraph2DErrors::SetPointErrorvirtual void SetPointError(Int_t i, Double_t ex, Double_t ey, Double_t ez)Set ex, ey and ez values for point number i.Definition TGraph2DErrors.cxx:446; TGraph2DErrors::GetErrorXDouble_t GetErrorX(Int_t bin) const overrideThis function is called by Graph2DFitChisquare.Definition TGraph2DErrors.cxx:206; TG",MatchSource.WIKI,doc/master/TGraph2DErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2DErrors_8cxx_source.html
https://root.cern/doc/master/TGraph2DErrors_8cxx_source.html:15656,Availability,error,errors,15656,"in) const overrideThis function is called by Graph2DFitChisquare.Definition TGraph2DErrors.cxx:230; TGraph2DErrors::~TGraph2DErrors~TGraph2DErrors() overrideTGraph2DErrors destructor.Definition TGraph2DErrors.cxx:137; TGraph2DErrors::GetYminEDouble_t GetYminE() const overrideReturns the Y minimum with errors.Definition TGraph2DErrors.cxx:274; TGraph2DErrors::GetXminEDouble_t GetXminE() const overrideReturns the X minimum with errors.Definition TGraph2DErrors.cxx:252; TGraph2DErrors::GetEZDouble_t * GetEZ() const overrideDefinition TGraph2DErrors.h:47; TGraph2DErrors::fEYDouble_t * fEY[fNpoints] array of Y errorsDefinition TGraph2DErrors.h:30; TGraph2DErrors::GetEYDouble_t * GetEY() const overrideDefinition TGraph2DErrors.h:46; TGraph2DErrors::SetPointvoid SetPoint(Int_t i, Double_t x, Double_t y, Double_t z) overrideSet x, y and z values for point number i.Definition TGraph2DErrors.cxx:404; TGraph2DErrors::Scalevoid Scale(Double_t c1=1., Option_t *option=""z"") overrideMultiply the values and errors of a TGraph2DErrors by a constant c1.Definition TGraph2DErrors.cxx:322; TGraph2DErrors::fEZDouble_t * fEZ[fNpoints] array of Z errorsDefinition TGraph2DErrors.h:31; TGraph2DErrors::GetEXDouble_t * GetEX() const overrideDefinition TGraph2DErrors.h:45; TGraph2DErrors::SetPointErrorvirtual void SetPointError(Int_t i, Double_t ex, Double_t ey, Double_t ez)Set ex, ey and ez values for point number i.Definition TGraph2DErrors.cxx:446; TGraph2DErrors::GetErrorXDouble_t GetErrorX(Int_t bin) const overrideThis function is called by Graph2DFitChisquare.Definition TGraph2DErrors.cxx:206; TGraph2DErrors::AddPointErrorvirtual void AddPointError(Double_t x, Double_t y, Double_t z, Double_t ex=0., Double_t ey=0., Double_t ez=0.)Add a point with errorbars to the graph.Definition TGraph2DErrors.cxx:196; TGraph2DErrors::Printvoid Print(Option_t *chopt="""") const overridePrint 2D graph and errors values.Definition TGraph2DErrors.cxx:307; TGraph2DErrors::GetZminEDouble_t GetZminE() const overr",MatchSource.WIKI,doc/master/TGraph2DErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2DErrors_8cxx_source.html
https://root.cern/doc/master/TGraph2DErrors_8cxx_source.html:15790,Availability,error,errorsDefinition,15790,"DErrors~TGraph2DErrors() overrideTGraph2DErrors destructor.Definition TGraph2DErrors.cxx:137; TGraph2DErrors::GetYminEDouble_t GetYminE() const overrideReturns the Y minimum with errors.Definition TGraph2DErrors.cxx:274; TGraph2DErrors::GetXminEDouble_t GetXminE() const overrideReturns the X minimum with errors.Definition TGraph2DErrors.cxx:252; TGraph2DErrors::GetEZDouble_t * GetEZ() const overrideDefinition TGraph2DErrors.h:47; TGraph2DErrors::fEYDouble_t * fEY[fNpoints] array of Y errorsDefinition TGraph2DErrors.h:30; TGraph2DErrors::GetEYDouble_t * GetEY() const overrideDefinition TGraph2DErrors.h:46; TGraph2DErrors::SetPointvoid SetPoint(Int_t i, Double_t x, Double_t y, Double_t z) overrideSet x, y and z values for point number i.Definition TGraph2DErrors.cxx:404; TGraph2DErrors::Scalevoid Scale(Double_t c1=1., Option_t *option=""z"") overrideMultiply the values and errors of a TGraph2DErrors by a constant c1.Definition TGraph2DErrors.cxx:322; TGraph2DErrors::fEZDouble_t * fEZ[fNpoints] array of Z errorsDefinition TGraph2DErrors.h:31; TGraph2DErrors::GetEXDouble_t * GetEX() const overrideDefinition TGraph2DErrors.h:45; TGraph2DErrors::SetPointErrorvirtual void SetPointError(Int_t i, Double_t ex, Double_t ey, Double_t ez)Set ex, ey and ez values for point number i.Definition TGraph2DErrors.cxx:446; TGraph2DErrors::GetErrorXDouble_t GetErrorX(Int_t bin) const overrideThis function is called by Graph2DFitChisquare.Definition TGraph2DErrors.cxx:206; TGraph2DErrors::AddPointErrorvirtual void AddPointError(Double_t x, Double_t y, Double_t z, Double_t ex=0., Double_t ey=0., Double_t ez=0.)Add a point with errorbars to the graph.Definition TGraph2DErrors.cxx:196; TGraph2DErrors::Printvoid Print(Option_t *chopt="""") const overridePrint 2D graph and errors values.Definition TGraph2DErrors.cxx:307; TGraph2DErrors::GetZminEDouble_t GetZminE() const overrideReturns the Z minimum with errors.Definition TGraph2DErrors.cxx:296; TGraph2DErrors::operator=TGraph2DErrors & operator=(",MatchSource.WIKI,doc/master/TGraph2DErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2DErrors_8cxx_source.html
https://root.cern/doc/master/TGraph2DErrors_8cxx_source.html:16403,Availability,error,errorbars,16403,"tPointvoid SetPoint(Int_t i, Double_t x, Double_t y, Double_t z) overrideSet x, y and z values for point number i.Definition TGraph2DErrors.cxx:404; TGraph2DErrors::Scalevoid Scale(Double_t c1=1., Option_t *option=""z"") overrideMultiply the values and errors of a TGraph2DErrors by a constant c1.Definition TGraph2DErrors.cxx:322; TGraph2DErrors::fEZDouble_t * fEZ[fNpoints] array of Z errorsDefinition TGraph2DErrors.h:31; TGraph2DErrors::GetEXDouble_t * GetEX() const overrideDefinition TGraph2DErrors.h:45; TGraph2DErrors::SetPointErrorvirtual void SetPointError(Int_t i, Double_t ex, Double_t ey, Double_t ez)Set ex, ey and ez values for point number i.Definition TGraph2DErrors.cxx:446; TGraph2DErrors::GetErrorXDouble_t GetErrorX(Int_t bin) const overrideThis function is called by Graph2DFitChisquare.Definition TGraph2DErrors.cxx:206; TGraph2DErrors::AddPointErrorvirtual void AddPointError(Double_t x, Double_t y, Double_t z, Double_t ex=0., Double_t ey=0., Double_t ez=0.)Add a point with errorbars to the graph.Definition TGraph2DErrors.cxx:196; TGraph2DErrors::Printvoid Print(Option_t *chopt="""") const overridePrint 2D graph and errors values.Definition TGraph2DErrors.cxx:307; TGraph2DErrors::GetZminEDouble_t GetZminE() const overrideReturns the Z minimum with errors.Definition TGraph2DErrors.cxx:296; TGraph2DErrors::operator=TGraph2DErrors & operator=(const TGraph2DErrors &)Assignment operator Copy everything except list of functions.Definition TGraph2DErrors.cxx:167; TGraph2DErrors::GetErrorYDouble_t GetErrorY(Int_t bin) const overrideThis function is called by Graph2DFitChisquare.Definition TGraph2DErrors.cxx:218; TGraph2DErrors::fEXDouble_t * fEX[fNpoints] array of X errorsDefinition TGraph2DErrors.h:29; TGraph2DErrors::TGraph2DErrorsTGraph2DErrors()TGraph2DErrors default constructor.Definition TGraph2DErrors.cxx:80; TGraph2DErrors::GetYmaxEDouble_t GetYmaxE() const overrideReturns the Y maximum with errors.Definition TGraph2DErrors.cxx:263; TGraph2DErrors::GetXmaxEDou",MatchSource.WIKI,doc/master/TGraph2DErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2DErrors_8cxx_source.html
https://root.cern/doc/master/TGraph2DErrors_8cxx_source.html:16546,Availability,error,errors,16546,"int number i.Definition TGraph2DErrors.cxx:404; TGraph2DErrors::Scalevoid Scale(Double_t c1=1., Option_t *option=""z"") overrideMultiply the values and errors of a TGraph2DErrors by a constant c1.Definition TGraph2DErrors.cxx:322; TGraph2DErrors::fEZDouble_t * fEZ[fNpoints] array of Z errorsDefinition TGraph2DErrors.h:31; TGraph2DErrors::GetEXDouble_t * GetEX() const overrideDefinition TGraph2DErrors.h:45; TGraph2DErrors::SetPointErrorvirtual void SetPointError(Int_t i, Double_t ex, Double_t ey, Double_t ez)Set ex, ey and ez values for point number i.Definition TGraph2DErrors.cxx:446; TGraph2DErrors::GetErrorXDouble_t GetErrorX(Int_t bin) const overrideThis function is called by Graph2DFitChisquare.Definition TGraph2DErrors.cxx:206; TGraph2DErrors::AddPointErrorvirtual void AddPointError(Double_t x, Double_t y, Double_t z, Double_t ex=0., Double_t ey=0., Double_t ez=0.)Add a point with errorbars to the graph.Definition TGraph2DErrors.cxx:196; TGraph2DErrors::Printvoid Print(Option_t *chopt="""") const overridePrint 2D graph and errors values.Definition TGraph2DErrors.cxx:307; TGraph2DErrors::GetZminEDouble_t GetZminE() const overrideReturns the Z minimum with errors.Definition TGraph2DErrors.cxx:296; TGraph2DErrors::operator=TGraph2DErrors & operator=(const TGraph2DErrors &)Assignment operator Copy everything except list of functions.Definition TGraph2DErrors.cxx:167; TGraph2DErrors::GetErrorYDouble_t GetErrorY(Int_t bin) const overrideThis function is called by Graph2DFitChisquare.Definition TGraph2DErrors.cxx:218; TGraph2DErrors::fEXDouble_t * fEX[fNpoints] array of X errorsDefinition TGraph2DErrors.h:29; TGraph2DErrors::TGraph2DErrorsTGraph2DErrors()TGraph2DErrors default constructor.Definition TGraph2DErrors.cxx:80; TGraph2DErrors::GetYmaxEDouble_t GetYmaxE() const overrideReturns the Y maximum with errors.Definition TGraph2DErrors.cxx:263; TGraph2DErrors::GetXmaxEDouble_t GetXmaxE() const overrideReturns the X maximum with errors.Definition TGraph2DErrors.cxx:241; ",MatchSource.WIKI,doc/master/TGraph2DErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2DErrors_8cxx_source.html
https://root.cern/doc/master/TGraph2DErrors_8cxx_source.html:16680,Availability,error,errors,16680,"iply the values and errors of a TGraph2DErrors by a constant c1.Definition TGraph2DErrors.cxx:322; TGraph2DErrors::fEZDouble_t * fEZ[fNpoints] array of Z errorsDefinition TGraph2DErrors.h:31; TGraph2DErrors::GetEXDouble_t * GetEX() const overrideDefinition TGraph2DErrors.h:45; TGraph2DErrors::SetPointErrorvirtual void SetPointError(Int_t i, Double_t ex, Double_t ey, Double_t ez)Set ex, ey and ez values for point number i.Definition TGraph2DErrors.cxx:446; TGraph2DErrors::GetErrorXDouble_t GetErrorX(Int_t bin) const overrideThis function is called by Graph2DFitChisquare.Definition TGraph2DErrors.cxx:206; TGraph2DErrors::AddPointErrorvirtual void AddPointError(Double_t x, Double_t y, Double_t z, Double_t ex=0., Double_t ey=0., Double_t ez=0.)Add a point with errorbars to the graph.Definition TGraph2DErrors.cxx:196; TGraph2DErrors::Printvoid Print(Option_t *chopt="""") const overridePrint 2D graph and errors values.Definition TGraph2DErrors.cxx:307; TGraph2DErrors::GetZminEDouble_t GetZminE() const overrideReturns the Z minimum with errors.Definition TGraph2DErrors.cxx:296; TGraph2DErrors::operator=TGraph2DErrors & operator=(const TGraph2DErrors &)Assignment operator Copy everything except list of functions.Definition TGraph2DErrors.cxx:167; TGraph2DErrors::GetErrorYDouble_t GetErrorY(Int_t bin) const overrideThis function is called by Graph2DFitChisquare.Definition TGraph2DErrors.cxx:218; TGraph2DErrors::fEXDouble_t * fEX[fNpoints] array of X errorsDefinition TGraph2DErrors.h:29; TGraph2DErrors::TGraph2DErrorsTGraph2DErrors()TGraph2DErrors default constructor.Definition TGraph2DErrors.cxx:80; TGraph2DErrors::GetYmaxEDouble_t GetYmaxE() const overrideReturns the Y maximum with errors.Definition TGraph2DErrors.cxx:263; TGraph2DErrors::GetXmaxEDouble_t GetXmaxE() const overrideReturns the X maximum with errors.Definition TGraph2DErrors.cxx:241; TGraph2DErrors::GetZmaxEDouble_t GetZmaxE() const overrideReturns the Z maximum with errors.Definition TGraph2DErrors.cxx:285; TGra",MatchSource.WIKI,doc/master/TGraph2DErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2DErrors_8cxx_source.html
https://root.cern/doc/master/TGraph2DErrors_8cxx_source.html:17099,Availability,error,errorsDefinition,17099,"ors.cxx:446; TGraph2DErrors::GetErrorXDouble_t GetErrorX(Int_t bin) const overrideThis function is called by Graph2DFitChisquare.Definition TGraph2DErrors.cxx:206; TGraph2DErrors::AddPointErrorvirtual void AddPointError(Double_t x, Double_t y, Double_t z, Double_t ex=0., Double_t ey=0., Double_t ez=0.)Add a point with errorbars to the graph.Definition TGraph2DErrors.cxx:196; TGraph2DErrors::Printvoid Print(Option_t *chopt="""") const overridePrint 2D graph and errors values.Definition TGraph2DErrors.cxx:307; TGraph2DErrors::GetZminEDouble_t GetZminE() const overrideReturns the Z minimum with errors.Definition TGraph2DErrors.cxx:296; TGraph2DErrors::operator=TGraph2DErrors & operator=(const TGraph2DErrors &)Assignment operator Copy everything except list of functions.Definition TGraph2DErrors.cxx:167; TGraph2DErrors::GetErrorYDouble_t GetErrorY(Int_t bin) const overrideThis function is called by Graph2DFitChisquare.Definition TGraph2DErrors.cxx:218; TGraph2DErrors::fEXDouble_t * fEX[fNpoints] array of X errorsDefinition TGraph2DErrors.h:29; TGraph2DErrors::TGraph2DErrorsTGraph2DErrors()TGraph2DErrors default constructor.Definition TGraph2DErrors.cxx:80; TGraph2DErrors::GetYmaxEDouble_t GetYmaxE() const overrideReturns the Y maximum with errors.Definition TGraph2DErrors.cxx:263; TGraph2DErrors::GetXmaxEDouble_t GetXmaxE() const overrideReturns the X maximum with errors.Definition TGraph2DErrors.cxx:241; TGraph2DErrors::GetZmaxEDouble_t GetZmaxE() const overrideReturns the Z maximum with errors.Definition TGraph2DErrors.cxx:285; TGraph2DErrors::Setvoid Set(Int_t n) overrideSet number of points in the 2D graph.Definition TGraph2DErrors.cxx:345; TGraph2DErrors::Classstatic TClass * Class(); TGraph2DErrors::RemovePointInt_t RemovePoint(Int_t ipoint)Deletes point number ipoint.Definition TGraph2DErrors.cxx:356; TGraph2DGraphics object made of three arrays X, Y and Z with the same number of points each.Definition TGraph2D.h:41; TGraph2D::fNpointsInt_t fNpointsNumber of points",MatchSource.WIKI,doc/master/TGraph2DErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2DErrors_8cxx_source.html
https://root.cern/doc/master/TGraph2DErrors_8cxx_source.html:17337,Availability,error,errors,17337,"intError(Double_t x, Double_t y, Double_t z, Double_t ex=0., Double_t ey=0., Double_t ez=0.)Add a point with errorbars to the graph.Definition TGraph2DErrors.cxx:196; TGraph2DErrors::Printvoid Print(Option_t *chopt="""") const overridePrint 2D graph and errors values.Definition TGraph2DErrors.cxx:307; TGraph2DErrors::GetZminEDouble_t GetZminE() const overrideReturns the Z minimum with errors.Definition TGraph2DErrors.cxx:296; TGraph2DErrors::operator=TGraph2DErrors & operator=(const TGraph2DErrors &)Assignment operator Copy everything except list of functions.Definition TGraph2DErrors.cxx:167; TGraph2DErrors::GetErrorYDouble_t GetErrorY(Int_t bin) const overrideThis function is called by Graph2DFitChisquare.Definition TGraph2DErrors.cxx:218; TGraph2DErrors::fEXDouble_t * fEX[fNpoints] array of X errorsDefinition TGraph2DErrors.h:29; TGraph2DErrors::TGraph2DErrorsTGraph2DErrors()TGraph2DErrors default constructor.Definition TGraph2DErrors.cxx:80; TGraph2DErrors::GetYmaxEDouble_t GetYmaxE() const overrideReturns the Y maximum with errors.Definition TGraph2DErrors.cxx:263; TGraph2DErrors::GetXmaxEDouble_t GetXmaxE() const overrideReturns the X maximum with errors.Definition TGraph2DErrors.cxx:241; TGraph2DErrors::GetZmaxEDouble_t GetZmaxE() const overrideReturns the Z maximum with errors.Definition TGraph2DErrors.cxx:285; TGraph2DErrors::Setvoid Set(Int_t n) overrideSet number of points in the 2D graph.Definition TGraph2DErrors.cxx:345; TGraph2DErrors::Classstatic TClass * Class(); TGraph2DErrors::RemovePointInt_t RemovePoint(Int_t ipoint)Deletes point number ipoint.Definition TGraph2DErrors.cxx:356; TGraph2DGraphics object made of three arrays X, Y and Z with the same number of points each.Definition TGraph2D.h:41; TGraph2D::fNpointsInt_t fNpointsNumber of points in the data set.Definition TGraph2D.h:45; TGraph2D::fZDouble_t * fZ[fNpoints]Definition TGraph2D.h:52; TGraph2D::fHistogramTH2D * fHistogram!2D histogram of z values linearly interpolated on the trianglesDefini",MatchSource.WIKI,doc/master/TGraph2DErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2DErrors_8cxx_source.html
https://root.cern/doc/master/TGraph2DErrors_8cxx_source.html:17464,Availability,error,errors,17464,"graph.Definition TGraph2DErrors.cxx:196; TGraph2DErrors::Printvoid Print(Option_t *chopt="""") const overridePrint 2D graph and errors values.Definition TGraph2DErrors.cxx:307; TGraph2DErrors::GetZminEDouble_t GetZminE() const overrideReturns the Z minimum with errors.Definition TGraph2DErrors.cxx:296; TGraph2DErrors::operator=TGraph2DErrors & operator=(const TGraph2DErrors &)Assignment operator Copy everything except list of functions.Definition TGraph2DErrors.cxx:167; TGraph2DErrors::GetErrorYDouble_t GetErrorY(Int_t bin) const overrideThis function is called by Graph2DFitChisquare.Definition TGraph2DErrors.cxx:218; TGraph2DErrors::fEXDouble_t * fEX[fNpoints] array of X errorsDefinition TGraph2DErrors.h:29; TGraph2DErrors::TGraph2DErrorsTGraph2DErrors()TGraph2DErrors default constructor.Definition TGraph2DErrors.cxx:80; TGraph2DErrors::GetYmaxEDouble_t GetYmaxE() const overrideReturns the Y maximum with errors.Definition TGraph2DErrors.cxx:263; TGraph2DErrors::GetXmaxEDouble_t GetXmaxE() const overrideReturns the X maximum with errors.Definition TGraph2DErrors.cxx:241; TGraph2DErrors::GetZmaxEDouble_t GetZmaxE() const overrideReturns the Z maximum with errors.Definition TGraph2DErrors.cxx:285; TGraph2DErrors::Setvoid Set(Int_t n) overrideSet number of points in the 2D graph.Definition TGraph2DErrors.cxx:345; TGraph2DErrors::Classstatic TClass * Class(); TGraph2DErrors::RemovePointInt_t RemovePoint(Int_t ipoint)Deletes point number ipoint.Definition TGraph2DErrors.cxx:356; TGraph2DGraphics object made of three arrays X, Y and Z with the same number of points each.Definition TGraph2D.h:41; TGraph2D::fNpointsInt_t fNpointsNumber of points in the data set.Definition TGraph2D.h:45; TGraph2D::fZDouble_t * fZ[fNpoints]Definition TGraph2D.h:52; TGraph2D::fHistogramTH2D * fHistogram!2D histogram of z values linearly interpolated on the trianglesDefinition TGraph2D.h:58; TGraph2D::fDelaunayTObject * fDelaunay! Pointer to Delaunay interpolator objectDefinition TGraph2D.h:59; TG",MatchSource.WIKI,doc/master/TGraph2DErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2DErrors_8cxx_source.html
https://root.cern/doc/master/TGraph2DErrors_8cxx_source.html:17591,Availability,error,errors,17591,"rrors values.Definition TGraph2DErrors.cxx:307; TGraph2DErrors::GetZminEDouble_t GetZminE() const overrideReturns the Z minimum with errors.Definition TGraph2DErrors.cxx:296; TGraph2DErrors::operator=TGraph2DErrors & operator=(const TGraph2DErrors &)Assignment operator Copy everything except list of functions.Definition TGraph2DErrors.cxx:167; TGraph2DErrors::GetErrorYDouble_t GetErrorY(Int_t bin) const overrideThis function is called by Graph2DFitChisquare.Definition TGraph2DErrors.cxx:218; TGraph2DErrors::fEXDouble_t * fEX[fNpoints] array of X errorsDefinition TGraph2DErrors.h:29; TGraph2DErrors::TGraph2DErrorsTGraph2DErrors()TGraph2DErrors default constructor.Definition TGraph2DErrors.cxx:80; TGraph2DErrors::GetYmaxEDouble_t GetYmaxE() const overrideReturns the Y maximum with errors.Definition TGraph2DErrors.cxx:263; TGraph2DErrors::GetXmaxEDouble_t GetXmaxE() const overrideReturns the X maximum with errors.Definition TGraph2DErrors.cxx:241; TGraph2DErrors::GetZmaxEDouble_t GetZmaxE() const overrideReturns the Z maximum with errors.Definition TGraph2DErrors.cxx:285; TGraph2DErrors::Setvoid Set(Int_t n) overrideSet number of points in the 2D graph.Definition TGraph2DErrors.cxx:345; TGraph2DErrors::Classstatic TClass * Class(); TGraph2DErrors::RemovePointInt_t RemovePoint(Int_t ipoint)Deletes point number ipoint.Definition TGraph2DErrors.cxx:356; TGraph2DGraphics object made of three arrays X, Y and Z with the same number of points each.Definition TGraph2D.h:41; TGraph2D::fNpointsInt_t fNpointsNumber of points in the data set.Definition TGraph2D.h:45; TGraph2D::fZDouble_t * fZ[fNpoints]Definition TGraph2D.h:52; TGraph2D::fHistogramTH2D * fHistogram!2D histogram of z values linearly interpolated on the trianglesDefinition TGraph2D.h:58; TGraph2D::fDelaunayTObject * fDelaunay! Pointer to Delaunay interpolator objectDefinition TGraph2D.h:59; TGraph2D::GetNInt_t GetN() constDefinition TGraph2D.h:122; TGraph2D::operator=TGraph2D & operator=(const TGraph2D &)Graph2D opera",MatchSource.WIKI,doc/master/TGraph2DErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2DErrors_8cxx_source.html
https://root.cern/doc/master/TGraph2DErrors_8cxx_source.html:19182,Availability,error,error,19182,"s.cxx:356; TGraph2DGraphics object made of three arrays X, Y and Z with the same number of points each.Definition TGraph2D.h:41; TGraph2D::fNpointsInt_t fNpointsNumber of points in the data set.Definition TGraph2D.h:45; TGraph2D::fZDouble_t * fZ[fNpoints]Definition TGraph2D.h:52; TGraph2D::fHistogramTH2D * fHistogram!2D histogram of z values linearly interpolated on the trianglesDefinition TGraph2D.h:58; TGraph2D::fDelaunayTObject * fDelaunay! Pointer to Delaunay interpolator objectDefinition TGraph2D.h:59; TGraph2D::GetNInt_t GetN() constDefinition TGraph2D.h:122; TGraph2D::operator=TGraph2D & operator=(const TGraph2D &)Graph2D operator ""="".Definition TGraph2D.cxx:557; TGraph2D::fXDouble_t * fX[fNpoints]Definition TGraph2D.h:50; TGraph2D::fYDouble_t * fY[fNpoints] Data set to be plottedDefinition TGraph2D.h:51; TGraph2D::Scalevirtual void Scale(Double_t c1=1., Option_t *option=""z"")Multiply the values of a TGraph2D by a constant c1.Definition TGraph2D.cxx:1506; TGraph2D::AddPointvirtual void AddPoint(Double_t x, Double_t y, Double_t z)Append a new point to the graph.Definition TGraph2D.h:93; TGraph2D::fSizeInt_t fSize!Real size of fX, fY and fZDefinition TGraph2D.h:49; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TStringBasic string class.Definition TString.h:139; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; double; int; unsigned int; yDouble_t y[n]Definition legend1.C:17; c1return c1Definition legend1.C:41; xDouble_t x[n]Definition legend1.C:17; eyDouble_t ey[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; exDouble_t ex[n]Definition legend1.C:17; v@ vDefinition rootcling_impl.cxx:3699. histhistsrcTGraph2DErrors.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:33 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TGraph2DErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2DErrors_8cxx_source.html
https://root.cern/doc/master/TGraph2DErrors_8cxx_source.html:12044,Energy Efficiency,allocate,allocate,12044,"w Double_t[fNpoints];; 367 Double_t *newEZ = new Double_t[fNpoints];; 368 ; 369 Int_t j = -1;; 370 for (Int_t i = 0; i < fNpoints + 1; i++) {; 371 if (i == ipoint) continue;; 372 j++;; 373 newX[j] = fX[i];; 374 newY[j] = fY[i];; 375 newZ[j] = fZ[i];; 376 newEX[j] = fEX[i];; 377 newEY[j] = fEY[i];; 378 newEZ[j] = fEZ[i];; 379 }; 380 delete [] fX;; 381 delete [] fY;; 382 delete [] fZ;; 383 delete [] fEX;; 384 delete [] fEY;; 385 delete [] fEZ;; 386 fX = newX;; 387 fY = newY;; 388 fZ = newZ;; 389 fEX = newEX;; 390 fEY = newEY;; 391 fEZ = newEZ;; 392 fSize = fNpoints;; 393 if (fHistogram) {; 394 delete fHistogram;; 395 fHistogram = nullptr;; 396 fDelaunay = nullptr;; 397 }; 398 return ipoint;; 399}; 400 ; 401////////////////////////////////////////////////////////////////////////////////; 402/// Set x, y and z values for point number i; 403 ; 404void TGraph2DErrors::SetPoint(Int_t i, Double_t x, Double_t y, Double_t z); 405{; 406 if (i < 0) return;; 407 if (i >= fNpoints) {; 408 // re-allocate the object; 409 Double_t *savex = new Double_t[i+1];; 410 Double_t *savey = new Double_t[i+1];; 411 Double_t *savez = new Double_t[i+1];; 412 Double_t *saveex = new Double_t[i+1];; 413 Double_t *saveey = new Double_t[i+1];; 414 Double_t *saveez = new Double_t[i+1];; 415 if (fNpoints > 0) {; 416 memcpy(savex, fX, fNpoints*sizeof(Double_t));; 417 memcpy(savey, fY, fNpoints*sizeof(Double_t));; 418 memcpy(savez, fZ, fNpoints*sizeof(Double_t));; 419 memcpy(saveex,fEX,fNpoints*sizeof(Double_t));; 420 memcpy(saveey,fEY,fNpoints*sizeof(Double_t));; 421 memcpy(saveez,fEZ,fNpoints*sizeof(Double_t));; 422 }; 423 if (fX) delete [] fX;; 424 if (fY) delete [] fY;; 425 if (fZ) delete [] fZ;; 426 if (fEX) delete [] fEX;; 427 if (fEY) delete [] fEY;; 428 if (fEZ) delete [] fEZ;; 429 fX = savex;; 430 fY = savey;; 431 fZ = savez;; 432 fEX = saveex;; 433 fEY = saveey;; 434 fEZ = saveez;; 435 fNpoints = i+1;; 436 }; 437 fX[i] = x;; 438 fY[i] = y;; 439 fZ[i] = z;; 440}; 441 ; 442 ; 443//////////////////",MatchSource.WIKI,doc/master/TGraph2DErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2DErrors_8cxx_source.html
https://root.cern/doc/master/TGraph2DErrors_8cxx_source.html:13324,Energy Efficiency,allocate,allocate,13324," 392 fSize = fNpoints;; 393 if (fHistogram) {; 394 delete fHistogram;; 395 fHistogram = nullptr;; 396 fDelaunay = nullptr;; 397 }; 398 return ipoint;; 399}; 400 ; 401////////////////////////////////////////////////////////////////////////////////; 402/// Set x, y and z values for point number i; 403 ; 404void TGraph2DErrors::SetPoint(Int_t i, Double_t x, Double_t y, Double_t z); 405{; 406 if (i < 0) return;; 407 if (i >= fNpoints) {; 408 // re-allocate the object; 409 Double_t *savex = new Double_t[i+1];; 410 Double_t *savey = new Double_t[i+1];; 411 Double_t *savez = new Double_t[i+1];; 412 Double_t *saveex = new Double_t[i+1];; 413 Double_t *saveey = new Double_t[i+1];; 414 Double_t *saveez = new Double_t[i+1];; 415 if (fNpoints > 0) {; 416 memcpy(savex, fX, fNpoints*sizeof(Double_t));; 417 memcpy(savey, fY, fNpoints*sizeof(Double_t));; 418 memcpy(savez, fZ, fNpoints*sizeof(Double_t));; 419 memcpy(saveex,fEX,fNpoints*sizeof(Double_t));; 420 memcpy(saveey,fEY,fNpoints*sizeof(Double_t));; 421 memcpy(saveez,fEZ,fNpoints*sizeof(Double_t));; 422 }; 423 if (fX) delete [] fX;; 424 if (fY) delete [] fY;; 425 if (fZ) delete [] fZ;; 426 if (fEX) delete [] fEX;; 427 if (fEY) delete [] fEY;; 428 if (fEZ) delete [] fEZ;; 429 fX = savex;; 430 fY = savey;; 431 fZ = savez;; 432 fEX = saveex;; 433 fEY = saveey;; 434 fEZ = saveez;; 435 fNpoints = i+1;; 436 }; 437 fX[i] = x;; 438 fY[i] = y;; 439 fZ[i] = z;; 440}; 441 ; 442 ; 443////////////////////////////////////////////////////////////////////////////////; 444/// Set ex, ey and ez values for point number i; 445 ; 446void TGraph2DErrors::SetPointError(Int_t i, Double_t ex, Double_t ey, Double_t ez); 447{; 448 if (i < 0) return;; 449 if (i >= fNpoints) {; 450 // re-allocate the object; 451 TGraph2DErrors::SetPoint(i,0,0,0);; 452 }; 453 fEX[i] = ex;; 454 fEY[i] = ey;; 455 fEZ[i] = ez;; 456}; 457 ; 458 ; 459////////////////////////////////////////////////////////////////////////////////; 460/// Stream an object of class TGraph2DErrors.",MatchSource.WIKI,doc/master/TGraph2DErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2DErrors_8cxx_source.html
https://root.cern/doc/master/TGraph2DErrors_8cxx_source.html:19188,Integrability,message,message,19188,"s.cxx:356; TGraph2DGraphics object made of three arrays X, Y and Z with the same number of points each.Definition TGraph2D.h:41; TGraph2D::fNpointsInt_t fNpointsNumber of points in the data set.Definition TGraph2D.h:45; TGraph2D::fZDouble_t * fZ[fNpoints]Definition TGraph2D.h:52; TGraph2D::fHistogramTH2D * fHistogram!2D histogram of z values linearly interpolated on the trianglesDefinition TGraph2D.h:58; TGraph2D::fDelaunayTObject * fDelaunay! Pointer to Delaunay interpolator objectDefinition TGraph2D.h:59; TGraph2D::GetNInt_t GetN() constDefinition TGraph2D.h:122; TGraph2D::operator=TGraph2D & operator=(const TGraph2D &)Graph2D operator ""="".Definition TGraph2D.cxx:557; TGraph2D::fXDouble_t * fX[fNpoints]Definition TGraph2D.h:50; TGraph2D::fYDouble_t * fY[fNpoints] Data set to be plottedDefinition TGraph2D.h:51; TGraph2D::Scalevirtual void Scale(Double_t c1=1., Option_t *option=""z"")Multiply the values of a TGraph2D by a constant c1.Definition TGraph2D.cxx:1506; TGraph2D::AddPointvirtual void AddPoint(Double_t x, Double_t y, Double_t z)Append a new point to the graph.Definition TGraph2D.h:93; TGraph2D::fSizeInt_t fSize!Real size of fX, fY and fZDefinition TGraph2D.h:49; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TStringBasic string class.Definition TString.h:139; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; double; int; unsigned int; yDouble_t y[n]Definition legend1.C:17; c1return c1Definition legend1.C:41; xDouble_t x[n]Definition legend1.C:17; eyDouble_t ey[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; exDouble_t ex[n]Definition legend1.C:17; v@ vDefinition rootcling_impl.cxx:3699. histhistsrcTGraph2DErrors.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:33 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TGraph2DErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2DErrors_8cxx_source.html
https://root.cern/doc/master/TGraph2DErrors_8h.html:545,Availability,error,errors,545,". ROOT: hist/hist/inc/TGraph2DErrors.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; TGraph2DErrors.h File Reference. #include ""TGraph2D.h"". Include dependency graph for TGraph2DErrors.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  TGraph2DErrors;  Graph 2D class with errors. More...;  . histhistincTGraph2DErrors.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:20 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TGraph2DErrors_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2DErrors_8h.html
https://root.cern/doc/master/TGraph2DErrors_8h.html:210,Integrability,depend,dependency,210,". ROOT: hist/hist/inc/TGraph2DErrors.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; TGraph2DErrors.h File Reference. #include ""TGraph2D.h"". Include dependency graph for TGraph2DErrors.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  TGraph2DErrors;  Graph 2D class with errors. More...;  . histhistincTGraph2DErrors.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:20 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TGraph2DErrors_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2DErrors_8h.html
https://root.cern/doc/master/TGraph2DErrors_8h_source.html:869,Availability,error,error,869,". ROOT: hist/hist/inc/TGraph2DErrors.h Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TGraph2DErrors.h. Go to the documentation of this file. 1// @(#)root/hist:$Id: TGraph2DErrors.h,v 1.00; 2// Author: Olivier Couet 26/11/2003; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#ifndef ROOT_TGraph2DErrors; 13#define ROOT_TGraph2DErrors; 14 ; 15 ; 16//////////////////////////////////////////////////////////////////////////; 17// //; 18// TGraph2DErrors //; 19// //; 20// a 2D Graph with error bars //; 21// //; 22//////////////////////////////////////////////////////////////////////////; 23 ; 24#include ""TGraph2D.h""; 25 ; 26class TGraph2DErrors : public TGraph2D {; 27 ; 28protected:; 29 Double_t *fEX{nullptr}; ///<[fNpoints] array of X errors; 30 Double_t *fEY{nullptr}; ///<[fNpoints] array of Y errors; 31 Double_t *fEZ{nullptr}; ///<[fNpoints] array of Z errors; 32 ; 33public:; 34 TGraph2DErrors();; 35 TGraph2DErrors(Int_t n);; 36 TGraph2DErrors(Int_t n, Double_t *x, Double_t *y, Double_t *z,; 37 Double_t *ex = nullptr, Double_t *ey = nullptr, Double_t *ez = nullptr, Option_t *option = """");; 38 TGraph2DErrors(const TGraph2DErrors&);; 39 TGraph2DErrors& operator=(const TGraph2DErrors&);; 40 ~TGraph2DErrors() override;; 41 virtual void AddPointError(Double_t x, Double_t y, Double_t z, Double_t ex = 0., Double_t ey = 0., Double_t ez = 0.);; 42 Double_t GetErrorX(Int_t bin) const override;; 43 Double_t GetErrorY(Int_t bin) const override;; 44 Double_t GetErrorZ(Int_t bin) const override;; 45 Double_t *GetEX() const override {return fEX;}; 46 Double_t *GetEY() const override {return fEY;}; 47 Double_t ",MatchSource.WIKI,doc/master/TGraph2DErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2DErrors_8h_source.html
https://root.cern/doc/master/TGraph2DErrors_8h_source.html:1122,Availability,error,errors,1122,"*******; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#ifndef ROOT_TGraph2DErrors; 13#define ROOT_TGraph2DErrors; 14 ; 15 ; 16//////////////////////////////////////////////////////////////////////////; 17// //; 18// TGraph2DErrors //; 19// //; 20// a 2D Graph with error bars //; 21// //; 22//////////////////////////////////////////////////////////////////////////; 23 ; 24#include ""TGraph2D.h""; 25 ; 26class TGraph2DErrors : public TGraph2D {; 27 ; 28protected:; 29 Double_t *fEX{nullptr}; ///<[fNpoints] array of X errors; 30 Double_t *fEY{nullptr}; ///<[fNpoints] array of Y errors; 31 Double_t *fEZ{nullptr}; ///<[fNpoints] array of Z errors; 32 ; 33public:; 34 TGraph2DErrors();; 35 TGraph2DErrors(Int_t n);; 36 TGraph2DErrors(Int_t n, Double_t *x, Double_t *y, Double_t *z,; 37 Double_t *ex = nullptr, Double_t *ey = nullptr, Double_t *ez = nullptr, Option_t *option = """");; 38 TGraph2DErrors(const TGraph2DErrors&);; 39 TGraph2DErrors& operator=(const TGraph2DErrors&);; 40 ~TGraph2DErrors() override;; 41 virtual void AddPointError(Double_t x, Double_t y, Double_t z, Double_t ex = 0., Double_t ey = 0., Double_t ez = 0.);; 42 Double_t GetErrorX(Int_t bin) const override;; 43 Double_t GetErrorY(Int_t bin) const override;; 44 Double_t GetErrorZ(Int_t bin) const override;; 45 Double_t *GetEX() const override {return fEX;}; 46 Double_t *GetEY() const override {return fEY;}; 47 Double_t *GetEZ() const override {return fEZ;}; 48 Double_t GetXmaxE() const override;; 49 Double_t GetXminE() const override;; 50 Double_t GetYmaxE() const override;; 51 Double_t GetYminE() const override;; 52 Double_t GetZmaxE() const override;; 53 Double_t GetZminE() const override;; 54 void Print(Option_t *chopt="""") const override;; 55 Int_t RemoveP",MatchSource.WIKI,doc/master/TGraph2DErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2DErrors_8h_source.html
https://root.cern/doc/master/TGraph2DErrors_8h_source.html:1183,Availability,error,errors,1183,"*******; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#ifndef ROOT_TGraph2DErrors; 13#define ROOT_TGraph2DErrors; 14 ; 15 ; 16//////////////////////////////////////////////////////////////////////////; 17// //; 18// TGraph2DErrors //; 19// //; 20// a 2D Graph with error bars //; 21// //; 22//////////////////////////////////////////////////////////////////////////; 23 ; 24#include ""TGraph2D.h""; 25 ; 26class TGraph2DErrors : public TGraph2D {; 27 ; 28protected:; 29 Double_t *fEX{nullptr}; ///<[fNpoints] array of X errors; 30 Double_t *fEY{nullptr}; ///<[fNpoints] array of Y errors; 31 Double_t *fEZ{nullptr}; ///<[fNpoints] array of Z errors; 32 ; 33public:; 34 TGraph2DErrors();; 35 TGraph2DErrors(Int_t n);; 36 TGraph2DErrors(Int_t n, Double_t *x, Double_t *y, Double_t *z,; 37 Double_t *ex = nullptr, Double_t *ey = nullptr, Double_t *ez = nullptr, Option_t *option = """");; 38 TGraph2DErrors(const TGraph2DErrors&);; 39 TGraph2DErrors& operator=(const TGraph2DErrors&);; 40 ~TGraph2DErrors() override;; 41 virtual void AddPointError(Double_t x, Double_t y, Double_t z, Double_t ex = 0., Double_t ey = 0., Double_t ez = 0.);; 42 Double_t GetErrorX(Int_t bin) const override;; 43 Double_t GetErrorY(Int_t bin) const override;; 44 Double_t GetErrorZ(Int_t bin) const override;; 45 Double_t *GetEX() const override {return fEX;}; 46 Double_t *GetEY() const override {return fEY;}; 47 Double_t *GetEZ() const override {return fEZ;}; 48 Double_t GetXmaxE() const override;; 49 Double_t GetXminE() const override;; 50 Double_t GetYmaxE() const override;; 51 Double_t GetYminE() const override;; 52 Double_t GetZmaxE() const override;; 53 Double_t GetZminE() const override;; 54 void Print(Option_t *chopt="""") const override;; 55 Int_t RemoveP",MatchSource.WIKI,doc/master/TGraph2DErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2DErrors_8h_source.html
https://root.cern/doc/master/TGraph2DErrors_8h_source.html:1244,Availability,error,errors,1244,"*******; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#ifndef ROOT_TGraph2DErrors; 13#define ROOT_TGraph2DErrors; 14 ; 15 ; 16//////////////////////////////////////////////////////////////////////////; 17// //; 18// TGraph2DErrors //; 19// //; 20// a 2D Graph with error bars //; 21// //; 22//////////////////////////////////////////////////////////////////////////; 23 ; 24#include ""TGraph2D.h""; 25 ; 26class TGraph2DErrors : public TGraph2D {; 27 ; 28protected:; 29 Double_t *fEX{nullptr}; ///<[fNpoints] array of X errors; 30 Double_t *fEY{nullptr}; ///<[fNpoints] array of Y errors; 31 Double_t *fEZ{nullptr}; ///<[fNpoints] array of Z errors; 32 ; 33public:; 34 TGraph2DErrors();; 35 TGraph2DErrors(Int_t n);; 36 TGraph2DErrors(Int_t n, Double_t *x, Double_t *y, Double_t *z,; 37 Double_t *ex = nullptr, Double_t *ey = nullptr, Double_t *ez = nullptr, Option_t *option = """");; 38 TGraph2DErrors(const TGraph2DErrors&);; 39 TGraph2DErrors& operator=(const TGraph2DErrors&);; 40 ~TGraph2DErrors() override;; 41 virtual void AddPointError(Double_t x, Double_t y, Double_t z, Double_t ex = 0., Double_t ey = 0., Double_t ez = 0.);; 42 Double_t GetErrorX(Int_t bin) const override;; 43 Double_t GetErrorY(Int_t bin) const override;; 44 Double_t GetErrorZ(Int_t bin) const override;; 45 Double_t *GetEX() const override {return fEX;}; 46 Double_t *GetEY() const override {return fEY;}; 47 Double_t *GetEZ() const override {return fEZ;}; 48 Double_t GetXmaxE() const override;; 49 Double_t GetXminE() const override;; 50 Double_t GetYmaxE() const override;; 51 Double_t GetYminE() const override;; 52 Double_t GetZmaxE() const override;; 53 Double_t GetZminE() const override;; 54 void Print(Option_t *chopt="""") const override;; 55 Int_t RemoveP",MatchSource.WIKI,doc/master/TGraph2DErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2DErrors_8h_source.html
https://root.cern/doc/master/TGraph2DErrors_8h_source.html:2697,Availability,error,error,2697,"ph2DErrors() override;; 41 virtual void AddPointError(Double_t x, Double_t y, Double_t z, Double_t ex = 0., Double_t ey = 0., Double_t ez = 0.);; 42 Double_t GetErrorX(Int_t bin) const override;; 43 Double_t GetErrorY(Int_t bin) const override;; 44 Double_t GetErrorZ(Int_t bin) const override;; 45 Double_t *GetEX() const override {return fEX;}; 46 Double_t *GetEY() const override {return fEY;}; 47 Double_t *GetEZ() const override {return fEZ;}; 48 Double_t GetXmaxE() const override;; 49 Double_t GetXminE() const override;; 50 Double_t GetYmaxE() const override;; 51 Double_t GetYminE() const override;; 52 Double_t GetZmaxE() const override;; 53 Double_t GetZminE() const override;; 54 void Print(Option_t *chopt="""") const override;; 55 Int_t RemovePoint(Int_t ipoint); // *MENU*; 56 void Scale(Double_t c1=1., Option_t *option=""z"") override; // *MENU*; 57 void Set(Int_t n) override;; 58 void SetPoint(Int_t i, Double_t x, Double_t y, Double_t z) override;; 59 virtual void SetPointError(Int_t i, Double_t ex, Double_t ey, Double_t ez);; 60 ; 61 ClassDefOverride(TGraph2DErrors,1) //A 2D graph with error bars; 62};; 63 ; 64#endif; 65 ; 66 ; Int_tint Int_tDefinition RtypesCore.h:45; Double_tdouble Double_tDefinition RtypesCore.h:59; Option_tconst char Option_tDefinition RtypesCore.h:66; ClassDefOverride#define ClassDefOverride(name, id)Definition Rtypes.h:346; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; TGraph2D.h; TGraph2DErrorsGraph 2D class with errors.Definition TGraph2DErrors.h:26; TGraph2DErrors::GetErrorZDouble_t GetErrorZ(Int_t bin) const overrideThis function is called by Graph2DFitChisquare.Definition TGraph2DErrors.cxx:230; TGraph2DErrors::~TGraph2DErrors~TGraph2DErrors() overrideTGraph2DErrors destructor.Definition TGraph2DErrors.cxx:137; TGraph2DErrors::GetYminEDouble_t GetYminE() const overrideReturns the Y minimum with errors.Definition TGraph2DErrors.cxx:274; TGraph2DErrors::GetXminEDouble_t GetXminE() const overrideReturns the X minim",MatchSource.WIKI,doc/master/TGraph2DErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2DErrors_8h_source.html
https://root.cern/doc/master/TGraph2DErrors_8h_source.html:3079,Availability,error,errors,3079,"onst override;; 49 Double_t GetXminE() const override;; 50 Double_t GetYmaxE() const override;; 51 Double_t GetYminE() const override;; 52 Double_t GetZmaxE() const override;; 53 Double_t GetZminE() const override;; 54 void Print(Option_t *chopt="""") const override;; 55 Int_t RemovePoint(Int_t ipoint); // *MENU*; 56 void Scale(Double_t c1=1., Option_t *option=""z"") override; // *MENU*; 57 void Set(Int_t n) override;; 58 void SetPoint(Int_t i, Double_t x, Double_t y, Double_t z) override;; 59 virtual void SetPointError(Int_t i, Double_t ex, Double_t ey, Double_t ez);; 60 ; 61 ClassDefOverride(TGraph2DErrors,1) //A 2D graph with error bars; 62};; 63 ; 64#endif; 65 ; 66 ; Int_tint Int_tDefinition RtypesCore.h:45; Double_tdouble Double_tDefinition RtypesCore.h:59; Option_tconst char Option_tDefinition RtypesCore.h:66; ClassDefOverride#define ClassDefOverride(name, id)Definition Rtypes.h:346; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; TGraph2D.h; TGraph2DErrorsGraph 2D class with errors.Definition TGraph2DErrors.h:26; TGraph2DErrors::GetErrorZDouble_t GetErrorZ(Int_t bin) const overrideThis function is called by Graph2DFitChisquare.Definition TGraph2DErrors.cxx:230; TGraph2DErrors::~TGraph2DErrors~TGraph2DErrors() overrideTGraph2DErrors destructor.Definition TGraph2DErrors.cxx:137; TGraph2DErrors::GetYminEDouble_t GetYminE() const overrideReturns the Y minimum with errors.Definition TGraph2DErrors.cxx:274; TGraph2DErrors::GetXminEDouble_t GetXminE() const overrideReturns the X minimum with errors.Definition TGraph2DErrors.cxx:252; TGraph2DErrors::GetEZDouble_t * GetEZ() const overrideDefinition TGraph2DErrors.h:47; TGraph2DErrors::fEYDouble_t * fEY[fNpoints] array of Y errorsDefinition TGraph2DErrors.h:30; TGraph2DErrors::GetEYDouble_t * GetEY() const overrideDefinition TGraph2DErrors.h:46; TGraph2DErrors::SetPointvoid SetPoint(Int_t i, Double_t x, Double_t y, Double_t z) overrideSet x, y and z values for point number i.Definition TGraph2DErrors.",MatchSource.WIKI,doc/master/TGraph2DErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2DErrors_8h_source.html
https://root.cern/doc/master/TGraph2DErrors_8h_source.html:3472,Availability,error,errors,3472,") override; // *MENU*; 57 void Set(Int_t n) override;; 58 void SetPoint(Int_t i, Double_t x, Double_t y, Double_t z) override;; 59 virtual void SetPointError(Int_t i, Double_t ex, Double_t ey, Double_t ez);; 60 ; 61 ClassDefOverride(TGraph2DErrors,1) //A 2D graph with error bars; 62};; 63 ; 64#endif; 65 ; 66 ; Int_tint Int_tDefinition RtypesCore.h:45; Double_tdouble Double_tDefinition RtypesCore.h:59; Option_tconst char Option_tDefinition RtypesCore.h:66; ClassDefOverride#define ClassDefOverride(name, id)Definition Rtypes.h:346; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; TGraph2D.h; TGraph2DErrorsGraph 2D class with errors.Definition TGraph2DErrors.h:26; TGraph2DErrors::GetErrorZDouble_t GetErrorZ(Int_t bin) const overrideThis function is called by Graph2DFitChisquare.Definition TGraph2DErrors.cxx:230; TGraph2DErrors::~TGraph2DErrors~TGraph2DErrors() overrideTGraph2DErrors destructor.Definition TGraph2DErrors.cxx:137; TGraph2DErrors::GetYminEDouble_t GetYminE() const overrideReturns the Y minimum with errors.Definition TGraph2DErrors.cxx:274; TGraph2DErrors::GetXminEDouble_t GetXminE() const overrideReturns the X minimum with errors.Definition TGraph2DErrors.cxx:252; TGraph2DErrors::GetEZDouble_t * GetEZ() const overrideDefinition TGraph2DErrors.h:47; TGraph2DErrors::fEYDouble_t * fEY[fNpoints] array of Y errorsDefinition TGraph2DErrors.h:30; TGraph2DErrors::GetEYDouble_t * GetEY() const overrideDefinition TGraph2DErrors.h:46; TGraph2DErrors::SetPointvoid SetPoint(Int_t i, Double_t x, Double_t y, Double_t z) overrideSet x, y and z values for point number i.Definition TGraph2DErrors.cxx:404; TGraph2DErrors::Scalevoid Scale(Double_t c1=1., Option_t *option=""z"") overrideMultiply the values and errors of a TGraph2DErrors by a constant c1.Definition TGraph2DErrors.cxx:322; TGraph2DErrors::fEZDouble_t * fEZ[fNpoints] array of Z errorsDefinition TGraph2DErrors.h:31; TGraph2DErrors::GetEXDouble_t * GetEX() const overrideDefinition TGraph2DErrors.h:",MatchSource.WIKI,doc/master/TGraph2DErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2DErrors_8h_source.html
https://root.cern/doc/master/TGraph2DErrors_8h_source.html:3599,Availability,error,errors,3599," 59 virtual void SetPointError(Int_t i, Double_t ex, Double_t ey, Double_t ez);; 60 ; 61 ClassDefOverride(TGraph2DErrors,1) //A 2D graph with error bars; 62};; 63 ; 64#endif; 65 ; 66 ; Int_tint Int_tDefinition RtypesCore.h:45; Double_tdouble Double_tDefinition RtypesCore.h:59; Option_tconst char Option_tDefinition RtypesCore.h:66; ClassDefOverride#define ClassDefOverride(name, id)Definition Rtypes.h:346; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; TGraph2D.h; TGraph2DErrorsGraph 2D class with errors.Definition TGraph2DErrors.h:26; TGraph2DErrors::GetErrorZDouble_t GetErrorZ(Int_t bin) const overrideThis function is called by Graph2DFitChisquare.Definition TGraph2DErrors.cxx:230; TGraph2DErrors::~TGraph2DErrors~TGraph2DErrors() overrideTGraph2DErrors destructor.Definition TGraph2DErrors.cxx:137; TGraph2DErrors::GetYminEDouble_t GetYminE() const overrideReturns the Y minimum with errors.Definition TGraph2DErrors.cxx:274; TGraph2DErrors::GetXminEDouble_t GetXminE() const overrideReturns the X minimum with errors.Definition TGraph2DErrors.cxx:252; TGraph2DErrors::GetEZDouble_t * GetEZ() const overrideDefinition TGraph2DErrors.h:47; TGraph2DErrors::fEYDouble_t * fEY[fNpoints] array of Y errorsDefinition TGraph2DErrors.h:30; TGraph2DErrors::GetEYDouble_t * GetEY() const overrideDefinition TGraph2DErrors.h:46; TGraph2DErrors::SetPointvoid SetPoint(Int_t i, Double_t x, Double_t y, Double_t z) overrideSet x, y and z values for point number i.Definition TGraph2DErrors.cxx:404; TGraph2DErrors::Scalevoid Scale(Double_t c1=1., Option_t *option=""z"") overrideMultiply the values and errors of a TGraph2DErrors by a constant c1.Definition TGraph2DErrors.cxx:322; TGraph2DErrors::fEZDouble_t * fEZ[fNpoints] array of Z errorsDefinition TGraph2DErrors.h:31; TGraph2DErrors::GetEXDouble_t * GetEX() const overrideDefinition TGraph2DErrors.h:45; TGraph2DErrors::SetPointErrorvirtual void SetPointError(Int_t i, Double_t ex, Double_t ey, Double_t ez)Set ex, ey and ez va",MatchSource.WIKI,doc/master/TGraph2DErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2DErrors_8h_source.html
https://root.cern/doc/master/TGraph2DErrors_8h_source.html:3782,Availability,error,errorsDefinition,3782,"ypesCore.h:45; Double_tdouble Double_tDefinition RtypesCore.h:59; Option_tconst char Option_tDefinition RtypesCore.h:66; ClassDefOverride#define ClassDefOverride(name, id)Definition Rtypes.h:346; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; TGraph2D.h; TGraph2DErrorsGraph 2D class with errors.Definition TGraph2DErrors.h:26; TGraph2DErrors::GetErrorZDouble_t GetErrorZ(Int_t bin) const overrideThis function is called by Graph2DFitChisquare.Definition TGraph2DErrors.cxx:230; TGraph2DErrors::~TGraph2DErrors~TGraph2DErrors() overrideTGraph2DErrors destructor.Definition TGraph2DErrors.cxx:137; TGraph2DErrors::GetYminEDouble_t GetYminE() const overrideReturns the Y minimum with errors.Definition TGraph2DErrors.cxx:274; TGraph2DErrors::GetXminEDouble_t GetXminE() const overrideReturns the X minimum with errors.Definition TGraph2DErrors.cxx:252; TGraph2DErrors::GetEZDouble_t * GetEZ() const overrideDefinition TGraph2DErrors.h:47; TGraph2DErrors::fEYDouble_t * fEY[fNpoints] array of Y errorsDefinition TGraph2DErrors.h:30; TGraph2DErrors::GetEYDouble_t * GetEY() const overrideDefinition TGraph2DErrors.h:46; TGraph2DErrors::SetPointvoid SetPoint(Int_t i, Double_t x, Double_t y, Double_t z) overrideSet x, y and z values for point number i.Definition TGraph2DErrors.cxx:404; TGraph2DErrors::Scalevoid Scale(Double_t c1=1., Option_t *option=""z"") overrideMultiply the values and errors of a TGraph2DErrors by a constant c1.Definition TGraph2DErrors.cxx:322; TGraph2DErrors::fEZDouble_t * fEZ[fNpoints] array of Z errorsDefinition TGraph2DErrors.h:31; TGraph2DErrors::GetEXDouble_t * GetEX() const overrideDefinition TGraph2DErrors.h:45; TGraph2DErrors::SetPointErrorvirtual void SetPointError(Int_t i, Double_t ex, Double_t ey, Double_t ez)Set ex, ey and ez values for point number i.Definition TGraph2DErrors.cxx:446; TGraph2DErrors::GetErrorXDouble_t GetErrorX(Int_t bin) const overrideThis function is called by Graph2DFitChisquare.Definition TGraph2DErrors.cxx:206; TG",MatchSource.WIKI,doc/master/TGraph2DErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2DErrors_8h_source.html
https://root.cern/doc/master/TGraph2DErrors_8h_source.html:4175,Availability,error,errors,4175,"in) const overrideThis function is called by Graph2DFitChisquare.Definition TGraph2DErrors.cxx:230; TGraph2DErrors::~TGraph2DErrors~TGraph2DErrors() overrideTGraph2DErrors destructor.Definition TGraph2DErrors.cxx:137; TGraph2DErrors::GetYminEDouble_t GetYminE() const overrideReturns the Y minimum with errors.Definition TGraph2DErrors.cxx:274; TGraph2DErrors::GetXminEDouble_t GetXminE() const overrideReturns the X minimum with errors.Definition TGraph2DErrors.cxx:252; TGraph2DErrors::GetEZDouble_t * GetEZ() const overrideDefinition TGraph2DErrors.h:47; TGraph2DErrors::fEYDouble_t * fEY[fNpoints] array of Y errorsDefinition TGraph2DErrors.h:30; TGraph2DErrors::GetEYDouble_t * GetEY() const overrideDefinition TGraph2DErrors.h:46; TGraph2DErrors::SetPointvoid SetPoint(Int_t i, Double_t x, Double_t y, Double_t z) overrideSet x, y and z values for point number i.Definition TGraph2DErrors.cxx:404; TGraph2DErrors::Scalevoid Scale(Double_t c1=1., Option_t *option=""z"") overrideMultiply the values and errors of a TGraph2DErrors by a constant c1.Definition TGraph2DErrors.cxx:322; TGraph2DErrors::fEZDouble_t * fEZ[fNpoints] array of Z errorsDefinition TGraph2DErrors.h:31; TGraph2DErrors::GetEXDouble_t * GetEX() const overrideDefinition TGraph2DErrors.h:45; TGraph2DErrors::SetPointErrorvirtual void SetPointError(Int_t i, Double_t ex, Double_t ey, Double_t ez)Set ex, ey and ez values for point number i.Definition TGraph2DErrors.cxx:446; TGraph2DErrors::GetErrorXDouble_t GetErrorX(Int_t bin) const overrideThis function is called by Graph2DFitChisquare.Definition TGraph2DErrors.cxx:206; TGraph2DErrors::AddPointErrorvirtual void AddPointError(Double_t x, Double_t y, Double_t z, Double_t ex=0., Double_t ey=0., Double_t ez=0.)Add a point with errorbars to the graph.Definition TGraph2DErrors.cxx:196; TGraph2DErrors::Printvoid Print(Option_t *chopt="""") const overridePrint 2D graph and errors values.Definition TGraph2DErrors.cxx:307; TGraph2DErrors::GetZminEDouble_t GetZminE() const overr",MatchSource.WIKI,doc/master/TGraph2DErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2DErrors_8h_source.html
https://root.cern/doc/master/TGraph2DErrors_8h_source.html:4309,Availability,error,errorsDefinition,4309,"DErrors~TGraph2DErrors() overrideTGraph2DErrors destructor.Definition TGraph2DErrors.cxx:137; TGraph2DErrors::GetYminEDouble_t GetYminE() const overrideReturns the Y minimum with errors.Definition TGraph2DErrors.cxx:274; TGraph2DErrors::GetXminEDouble_t GetXminE() const overrideReturns the X minimum with errors.Definition TGraph2DErrors.cxx:252; TGraph2DErrors::GetEZDouble_t * GetEZ() const overrideDefinition TGraph2DErrors.h:47; TGraph2DErrors::fEYDouble_t * fEY[fNpoints] array of Y errorsDefinition TGraph2DErrors.h:30; TGraph2DErrors::GetEYDouble_t * GetEY() const overrideDefinition TGraph2DErrors.h:46; TGraph2DErrors::SetPointvoid SetPoint(Int_t i, Double_t x, Double_t y, Double_t z) overrideSet x, y and z values for point number i.Definition TGraph2DErrors.cxx:404; TGraph2DErrors::Scalevoid Scale(Double_t c1=1., Option_t *option=""z"") overrideMultiply the values and errors of a TGraph2DErrors by a constant c1.Definition TGraph2DErrors.cxx:322; TGraph2DErrors::fEZDouble_t * fEZ[fNpoints] array of Z errorsDefinition TGraph2DErrors.h:31; TGraph2DErrors::GetEXDouble_t * GetEX() const overrideDefinition TGraph2DErrors.h:45; TGraph2DErrors::SetPointErrorvirtual void SetPointError(Int_t i, Double_t ex, Double_t ey, Double_t ez)Set ex, ey and ez values for point number i.Definition TGraph2DErrors.cxx:446; TGraph2DErrors::GetErrorXDouble_t GetErrorX(Int_t bin) const overrideThis function is called by Graph2DFitChisquare.Definition TGraph2DErrors.cxx:206; TGraph2DErrors::AddPointErrorvirtual void AddPointError(Double_t x, Double_t y, Double_t z, Double_t ex=0., Double_t ey=0., Double_t ez=0.)Add a point with errorbars to the graph.Definition TGraph2DErrors.cxx:196; TGraph2DErrors::Printvoid Print(Option_t *chopt="""") const overridePrint 2D graph and errors values.Definition TGraph2DErrors.cxx:307; TGraph2DErrors::GetZminEDouble_t GetZminE() const overrideReturns the Z minimum with errors.Definition TGraph2DErrors.cxx:296; TGraph2DErrors::operator=TGraph2DErrors & operator=(",MatchSource.WIKI,doc/master/TGraph2DErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2DErrors_8h_source.html
https://root.cern/doc/master/TGraph2DErrors_8h_source.html:4922,Availability,error,errorbars,4922,"tPointvoid SetPoint(Int_t i, Double_t x, Double_t y, Double_t z) overrideSet x, y and z values for point number i.Definition TGraph2DErrors.cxx:404; TGraph2DErrors::Scalevoid Scale(Double_t c1=1., Option_t *option=""z"") overrideMultiply the values and errors of a TGraph2DErrors by a constant c1.Definition TGraph2DErrors.cxx:322; TGraph2DErrors::fEZDouble_t * fEZ[fNpoints] array of Z errorsDefinition TGraph2DErrors.h:31; TGraph2DErrors::GetEXDouble_t * GetEX() const overrideDefinition TGraph2DErrors.h:45; TGraph2DErrors::SetPointErrorvirtual void SetPointError(Int_t i, Double_t ex, Double_t ey, Double_t ez)Set ex, ey and ez values for point number i.Definition TGraph2DErrors.cxx:446; TGraph2DErrors::GetErrorXDouble_t GetErrorX(Int_t bin) const overrideThis function is called by Graph2DFitChisquare.Definition TGraph2DErrors.cxx:206; TGraph2DErrors::AddPointErrorvirtual void AddPointError(Double_t x, Double_t y, Double_t z, Double_t ex=0., Double_t ey=0., Double_t ez=0.)Add a point with errorbars to the graph.Definition TGraph2DErrors.cxx:196; TGraph2DErrors::Printvoid Print(Option_t *chopt="""") const overridePrint 2D graph and errors values.Definition TGraph2DErrors.cxx:307; TGraph2DErrors::GetZminEDouble_t GetZminE() const overrideReturns the Z minimum with errors.Definition TGraph2DErrors.cxx:296; TGraph2DErrors::operator=TGraph2DErrors & operator=(const TGraph2DErrors &)Assignment operator Copy everything except list of functions.Definition TGraph2DErrors.cxx:167; TGraph2DErrors::GetErrorYDouble_t GetErrorY(Int_t bin) const overrideThis function is called by Graph2DFitChisquare.Definition TGraph2DErrors.cxx:218; TGraph2DErrors::fEXDouble_t * fEX[fNpoints] array of X errorsDefinition TGraph2DErrors.h:29; TGraph2DErrors::TGraph2DErrorsTGraph2DErrors()TGraph2DErrors default constructor.Definition TGraph2DErrors.cxx:80; TGraph2DErrors::GetYmaxEDouble_t GetYmaxE() const overrideReturns the Y maximum with errors.Definition TGraph2DErrors.cxx:263; TGraph2DErrors::GetXmaxEDou",MatchSource.WIKI,doc/master/TGraph2DErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2DErrors_8h_source.html
https://root.cern/doc/master/TGraph2DErrors_8h_source.html:5065,Availability,error,errors,5065,"int number i.Definition TGraph2DErrors.cxx:404; TGraph2DErrors::Scalevoid Scale(Double_t c1=1., Option_t *option=""z"") overrideMultiply the values and errors of a TGraph2DErrors by a constant c1.Definition TGraph2DErrors.cxx:322; TGraph2DErrors::fEZDouble_t * fEZ[fNpoints] array of Z errorsDefinition TGraph2DErrors.h:31; TGraph2DErrors::GetEXDouble_t * GetEX() const overrideDefinition TGraph2DErrors.h:45; TGraph2DErrors::SetPointErrorvirtual void SetPointError(Int_t i, Double_t ex, Double_t ey, Double_t ez)Set ex, ey and ez values for point number i.Definition TGraph2DErrors.cxx:446; TGraph2DErrors::GetErrorXDouble_t GetErrorX(Int_t bin) const overrideThis function is called by Graph2DFitChisquare.Definition TGraph2DErrors.cxx:206; TGraph2DErrors::AddPointErrorvirtual void AddPointError(Double_t x, Double_t y, Double_t z, Double_t ex=0., Double_t ey=0., Double_t ez=0.)Add a point with errorbars to the graph.Definition TGraph2DErrors.cxx:196; TGraph2DErrors::Printvoid Print(Option_t *chopt="""") const overridePrint 2D graph and errors values.Definition TGraph2DErrors.cxx:307; TGraph2DErrors::GetZminEDouble_t GetZminE() const overrideReturns the Z minimum with errors.Definition TGraph2DErrors.cxx:296; TGraph2DErrors::operator=TGraph2DErrors & operator=(const TGraph2DErrors &)Assignment operator Copy everything except list of functions.Definition TGraph2DErrors.cxx:167; TGraph2DErrors::GetErrorYDouble_t GetErrorY(Int_t bin) const overrideThis function is called by Graph2DFitChisquare.Definition TGraph2DErrors.cxx:218; TGraph2DErrors::fEXDouble_t * fEX[fNpoints] array of X errorsDefinition TGraph2DErrors.h:29; TGraph2DErrors::TGraph2DErrorsTGraph2DErrors()TGraph2DErrors default constructor.Definition TGraph2DErrors.cxx:80; TGraph2DErrors::GetYmaxEDouble_t GetYmaxE() const overrideReturns the Y maximum with errors.Definition TGraph2DErrors.cxx:263; TGraph2DErrors::GetXmaxEDouble_t GetXmaxE() const overrideReturns the X maximum with errors.Definition TGraph2DErrors.cxx:241; ",MatchSource.WIKI,doc/master/TGraph2DErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2DErrors_8h_source.html
https://root.cern/doc/master/TGraph2DErrors_8h_source.html:5199,Availability,error,errors,5199,"iply the values and errors of a TGraph2DErrors by a constant c1.Definition TGraph2DErrors.cxx:322; TGraph2DErrors::fEZDouble_t * fEZ[fNpoints] array of Z errorsDefinition TGraph2DErrors.h:31; TGraph2DErrors::GetEXDouble_t * GetEX() const overrideDefinition TGraph2DErrors.h:45; TGraph2DErrors::SetPointErrorvirtual void SetPointError(Int_t i, Double_t ex, Double_t ey, Double_t ez)Set ex, ey and ez values for point number i.Definition TGraph2DErrors.cxx:446; TGraph2DErrors::GetErrorXDouble_t GetErrorX(Int_t bin) const overrideThis function is called by Graph2DFitChisquare.Definition TGraph2DErrors.cxx:206; TGraph2DErrors::AddPointErrorvirtual void AddPointError(Double_t x, Double_t y, Double_t z, Double_t ex=0., Double_t ey=0., Double_t ez=0.)Add a point with errorbars to the graph.Definition TGraph2DErrors.cxx:196; TGraph2DErrors::Printvoid Print(Option_t *chopt="""") const overridePrint 2D graph and errors values.Definition TGraph2DErrors.cxx:307; TGraph2DErrors::GetZminEDouble_t GetZminE() const overrideReturns the Z minimum with errors.Definition TGraph2DErrors.cxx:296; TGraph2DErrors::operator=TGraph2DErrors & operator=(const TGraph2DErrors &)Assignment operator Copy everything except list of functions.Definition TGraph2DErrors.cxx:167; TGraph2DErrors::GetErrorYDouble_t GetErrorY(Int_t bin) const overrideThis function is called by Graph2DFitChisquare.Definition TGraph2DErrors.cxx:218; TGraph2DErrors::fEXDouble_t * fEX[fNpoints] array of X errorsDefinition TGraph2DErrors.h:29; TGraph2DErrors::TGraph2DErrorsTGraph2DErrors()TGraph2DErrors default constructor.Definition TGraph2DErrors.cxx:80; TGraph2DErrors::GetYmaxEDouble_t GetYmaxE() const overrideReturns the Y maximum with errors.Definition TGraph2DErrors.cxx:263; TGraph2DErrors::GetXmaxEDouble_t GetXmaxE() const overrideReturns the X maximum with errors.Definition TGraph2DErrors.cxx:241; TGraph2DErrors::GetZmaxEDouble_t GetZmaxE() const overrideReturns the Z maximum with errors.Definition TGraph2DErrors.cxx:285; TGra",MatchSource.WIKI,doc/master/TGraph2DErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2DErrors_8h_source.html
https://root.cern/doc/master/TGraph2DErrors_8h_source.html:5618,Availability,error,errorsDefinition,5618,"ors.cxx:446; TGraph2DErrors::GetErrorXDouble_t GetErrorX(Int_t bin) const overrideThis function is called by Graph2DFitChisquare.Definition TGraph2DErrors.cxx:206; TGraph2DErrors::AddPointErrorvirtual void AddPointError(Double_t x, Double_t y, Double_t z, Double_t ex=0., Double_t ey=0., Double_t ez=0.)Add a point with errorbars to the graph.Definition TGraph2DErrors.cxx:196; TGraph2DErrors::Printvoid Print(Option_t *chopt="""") const overridePrint 2D graph and errors values.Definition TGraph2DErrors.cxx:307; TGraph2DErrors::GetZminEDouble_t GetZminE() const overrideReturns the Z minimum with errors.Definition TGraph2DErrors.cxx:296; TGraph2DErrors::operator=TGraph2DErrors & operator=(const TGraph2DErrors &)Assignment operator Copy everything except list of functions.Definition TGraph2DErrors.cxx:167; TGraph2DErrors::GetErrorYDouble_t GetErrorY(Int_t bin) const overrideThis function is called by Graph2DFitChisquare.Definition TGraph2DErrors.cxx:218; TGraph2DErrors::fEXDouble_t * fEX[fNpoints] array of X errorsDefinition TGraph2DErrors.h:29; TGraph2DErrors::TGraph2DErrorsTGraph2DErrors()TGraph2DErrors default constructor.Definition TGraph2DErrors.cxx:80; TGraph2DErrors::GetYmaxEDouble_t GetYmaxE() const overrideReturns the Y maximum with errors.Definition TGraph2DErrors.cxx:263; TGraph2DErrors::GetXmaxEDouble_t GetXmaxE() const overrideReturns the X maximum with errors.Definition TGraph2DErrors.cxx:241; TGraph2DErrors::GetZmaxEDouble_t GetZmaxE() const overrideReturns the Z maximum with errors.Definition TGraph2DErrors.cxx:285; TGraph2DErrors::Setvoid Set(Int_t n) overrideSet number of points in the 2D graph.Definition TGraph2DErrors.cxx:345; TGraph2DErrors::RemovePointInt_t RemovePoint(Int_t ipoint)Deletes point number ipoint.Definition TGraph2DErrors.cxx:356; TGraph2DGraphics object made of three arrays X, Y and Z with the same number of points each.Definition TGraph2D.h:41; double; yDouble_t y[n]Definition legend1.C:17; c1return c1Definition legend1.C:41; xDouble_t x",MatchSource.WIKI,doc/master/TGraph2DErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2DErrors_8h_source.html
https://root.cern/doc/master/TGraph2DErrors_8h_source.html:5856,Availability,error,errors,5856,"intError(Double_t x, Double_t y, Double_t z, Double_t ex=0., Double_t ey=0., Double_t ez=0.)Add a point with errorbars to the graph.Definition TGraph2DErrors.cxx:196; TGraph2DErrors::Printvoid Print(Option_t *chopt="""") const overridePrint 2D graph and errors values.Definition TGraph2DErrors.cxx:307; TGraph2DErrors::GetZminEDouble_t GetZminE() const overrideReturns the Z minimum with errors.Definition TGraph2DErrors.cxx:296; TGraph2DErrors::operator=TGraph2DErrors & operator=(const TGraph2DErrors &)Assignment operator Copy everything except list of functions.Definition TGraph2DErrors.cxx:167; TGraph2DErrors::GetErrorYDouble_t GetErrorY(Int_t bin) const overrideThis function is called by Graph2DFitChisquare.Definition TGraph2DErrors.cxx:218; TGraph2DErrors::fEXDouble_t * fEX[fNpoints] array of X errorsDefinition TGraph2DErrors.h:29; TGraph2DErrors::TGraph2DErrorsTGraph2DErrors()TGraph2DErrors default constructor.Definition TGraph2DErrors.cxx:80; TGraph2DErrors::GetYmaxEDouble_t GetYmaxE() const overrideReturns the Y maximum with errors.Definition TGraph2DErrors.cxx:263; TGraph2DErrors::GetXmaxEDouble_t GetXmaxE() const overrideReturns the X maximum with errors.Definition TGraph2DErrors.cxx:241; TGraph2DErrors::GetZmaxEDouble_t GetZmaxE() const overrideReturns the Z maximum with errors.Definition TGraph2DErrors.cxx:285; TGraph2DErrors::Setvoid Set(Int_t n) overrideSet number of points in the 2D graph.Definition TGraph2DErrors.cxx:345; TGraph2DErrors::RemovePointInt_t RemovePoint(Int_t ipoint)Deletes point number ipoint.Definition TGraph2DErrors.cxx:356; TGraph2DGraphics object made of three arrays X, Y and Z with the same number of points each.Definition TGraph2D.h:41; double; yDouble_t y[n]Definition legend1.C:17; c1return c1Definition legend1.C:41; xDouble_t x[n]Definition legend1.C:17; eyDouble_t ey[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; exDouble_t ex[n]Definition legend1.C:17. histhistincTGraph2DErrors.h. ROOT master - Reference Guide Gen",MatchSource.WIKI,doc/master/TGraph2DErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2DErrors_8h_source.html
https://root.cern/doc/master/TGraph2DErrors_8h_source.html:5983,Availability,error,errors,5983,"y=0., Double_t ez=0.)Add a point with errorbars to the graph.Definition TGraph2DErrors.cxx:196; TGraph2DErrors::Printvoid Print(Option_t *chopt="""") const overridePrint 2D graph and errors values.Definition TGraph2DErrors.cxx:307; TGraph2DErrors::GetZminEDouble_t GetZminE() const overrideReturns the Z minimum with errors.Definition TGraph2DErrors.cxx:296; TGraph2DErrors::operator=TGraph2DErrors & operator=(const TGraph2DErrors &)Assignment operator Copy everything except list of functions.Definition TGraph2DErrors.cxx:167; TGraph2DErrors::GetErrorYDouble_t GetErrorY(Int_t bin) const overrideThis function is called by Graph2DFitChisquare.Definition TGraph2DErrors.cxx:218; TGraph2DErrors::fEXDouble_t * fEX[fNpoints] array of X errorsDefinition TGraph2DErrors.h:29; TGraph2DErrors::TGraph2DErrorsTGraph2DErrors()TGraph2DErrors default constructor.Definition TGraph2DErrors.cxx:80; TGraph2DErrors::GetYmaxEDouble_t GetYmaxE() const overrideReturns the Y maximum with errors.Definition TGraph2DErrors.cxx:263; TGraph2DErrors::GetXmaxEDouble_t GetXmaxE() const overrideReturns the X maximum with errors.Definition TGraph2DErrors.cxx:241; TGraph2DErrors::GetZmaxEDouble_t GetZmaxE() const overrideReturns the Z maximum with errors.Definition TGraph2DErrors.cxx:285; TGraph2DErrors::Setvoid Set(Int_t n) overrideSet number of points in the 2D graph.Definition TGraph2DErrors.cxx:345; TGraph2DErrors::RemovePointInt_t RemovePoint(Int_t ipoint)Deletes point number ipoint.Definition TGraph2DErrors.cxx:356; TGraph2DGraphics object made of three arrays X, Y and Z with the same number of points each.Definition TGraph2D.h:41; double; yDouble_t y[n]Definition legend1.C:17; c1return c1Definition legend1.C:41; xDouble_t x[n]Definition legend1.C:17; eyDouble_t ey[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; exDouble_t ex[n]Definition legend1.C:17. histhistincTGraph2DErrors.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TGraph2DErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2DErrors_8h_source.html
https://root.cern/doc/master/TGraph2DErrors_8h_source.html:6110,Availability,error,errors,6110,"y=0., Double_t ez=0.)Add a point with errorbars to the graph.Definition TGraph2DErrors.cxx:196; TGraph2DErrors::Printvoid Print(Option_t *chopt="""") const overridePrint 2D graph and errors values.Definition TGraph2DErrors.cxx:307; TGraph2DErrors::GetZminEDouble_t GetZminE() const overrideReturns the Z minimum with errors.Definition TGraph2DErrors.cxx:296; TGraph2DErrors::operator=TGraph2DErrors & operator=(const TGraph2DErrors &)Assignment operator Copy everything except list of functions.Definition TGraph2DErrors.cxx:167; TGraph2DErrors::GetErrorYDouble_t GetErrorY(Int_t bin) const overrideThis function is called by Graph2DFitChisquare.Definition TGraph2DErrors.cxx:218; TGraph2DErrors::fEXDouble_t * fEX[fNpoints] array of X errorsDefinition TGraph2DErrors.h:29; TGraph2DErrors::TGraph2DErrorsTGraph2DErrors()TGraph2DErrors default constructor.Definition TGraph2DErrors.cxx:80; TGraph2DErrors::GetYmaxEDouble_t GetYmaxE() const overrideReturns the Y maximum with errors.Definition TGraph2DErrors.cxx:263; TGraph2DErrors::GetXmaxEDouble_t GetXmaxE() const overrideReturns the X maximum with errors.Definition TGraph2DErrors.cxx:241; TGraph2DErrors::GetZmaxEDouble_t GetZmaxE() const overrideReturns the Z maximum with errors.Definition TGraph2DErrors.cxx:285; TGraph2DErrors::Setvoid Set(Int_t n) overrideSet number of points in the 2D graph.Definition TGraph2DErrors.cxx:345; TGraph2DErrors::RemovePointInt_t RemovePoint(Int_t ipoint)Deletes point number ipoint.Definition TGraph2DErrors.cxx:356; TGraph2DGraphics object made of three arrays X, Y and Z with the same number of points each.Definition TGraph2D.h:41; double; yDouble_t y[n]Definition legend1.C:17; c1return c1Definition legend1.C:41; xDouble_t x[n]Definition legend1.C:17; eyDouble_t ey[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; exDouble_t ex[n]Definition legend1.C:17. histhistincTGraph2DErrors.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TGraph2DErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2DErrors_8h_source.html
https://root.cern/doc/master/TGraph2D_8cxx_source.html:10842,Availability,error,errors,10842,"TAttFill(0, 1001), fNpoints(n); 283{; 284 Build(n);; 285 ; 286 // Copy the input vectors into local arrays; 287 for (Int_t i = 0; i < fNpoints; ++i) {; 288 fX[i] = x[i];; 289 fY[i] = y[i];; 290 fZ[i] = z[i];; 291 }; 292}; 293 ; 294 ; 295////////////////////////////////////////////////////////////////////////////////; 296/// Graph2D constructor with three vectors of doubles as input.; 297 ; 298TGraph2D::TGraph2D(Int_t n, Double_t *x, Double_t *y, Double_t *z); 299 : TNamed(""Graph2D"", ""Graph2D""), TAttLine(1, 1, 1), TAttFill(0, 1001), fNpoints(n); 300{; 301 Build(n);; 302 ; 303 // Copy the input vectors into local arrays; 304 for (Int_t i = 0; i < fNpoints; ++i) {; 305 fX[i] = x[i];; 306 fY[i] = y[i];; 307 fZ[i] = z[i];; 308 }; 309}; 310 ; 311 ; 312////////////////////////////////////////////////////////////////////////////////; 313/// Graph2D constructor with a TH2 (h2) as input.; 314/// Only the h2's bins within the X and Y axis ranges are used.; 315/// Empty bins, recognized when both content and errors are zero, are excluded.; 316 ; 317TGraph2D::TGraph2D(TH2 *h2); 318 : TNamed(""Graph2D"", ""Graph2D""), TAttLine(1, 1, 1), TAttFill(0, 1001), fNpoints(0); 319{; 320 Build(h2->GetNbinsX()*h2->GetNbinsY());; 321 ; 322 TString gname = ""Graph2D_from_"" + TString(h2->GetName());; 323 SetName(gname);; 324 // need to call later because sets title in ref histogram; 325 SetTitle(h2->GetTitle());; 326 ; 327 ; 328 ; 329 TAxis *xaxis = h2->GetXaxis();; 330 TAxis *yaxis = h2->GetYaxis();; 331 Int_t xfirst = xaxis->GetFirst();; 332 Int_t xlast = xaxis->GetLast();; 333 Int_t yfirst = yaxis->GetFirst();; 334 Int_t ylast = yaxis->GetLast();; 335 ; 336 ; 337 Double_t x, y, z;; 338 Int_t k = 0;; 339 ; 340 for (Int_t i = xfirst; i <= xlast; i++) {; 341 for (Int_t j = yfirst; j <= ylast; j++) {; 342 x = xaxis->GetBinCenter(i);; 343 y = yaxis->GetBinCenter(j);; 344 z = h2->GetBinContent(i, j);; 345 Double_t ez = h2->GetBinError(i, j);; 346 if (z != 0. || ez != 0) {; 347 SetPoint(k, x, y, z);; 3",MatchSource.WIKI,doc/master/TGraph2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2D_8cxx_source.html
https://root.cern/doc/master/TGraph2D_8cxx_source.html:15866,Availability,error,error,15866,"sDigit()) {; 442 Error(""TGraph2D"", ""Incorrect input format! Allowed format tags are {\""%%lg\"",\""%%*lg\"" or \""%%*s\""}"");; 443 return;; 444 }; 445 Int_t ntokens = format_.Length() ;; 446 if (ntokens < 3) {; 447 Error(""TGraph2D"", ""Incorrect input format! Only %d tag(s) in format whereas 3 \""%%lg\"" tags are expected!"", ntokens);; 448 return;; 449 }; 450 Int_t ntokensToBeSaved = 0 ;; 451 Bool_t * isTokenToBeSaved = new Bool_t [ntokens] ;; 452 for (Int_t idx = 0; idx < ntokens; idx++) {; 453 isTokenToBeSaved[idx] = TString::Format(""%c"", format_[idx]).Atoi() ; //atoi(&format_[idx]) does not work for some reason...; 454 if (isTokenToBeSaved[idx] == 1) {; 455 ntokensToBeSaved++ ;; 456 }; 457 }; 458 if (ntokens >= 3 && ntokensToBeSaved != 3) { //first condition not to repeat the previous error message; 459 Error(""TGraph2D"", ""Incorrect input format! There are %d \""%%lg\"" tag(s) in format whereas 3 and only 3 are expected!"", ntokensToBeSaved);; 460 delete [] isTokenToBeSaved ;; 461 return;; 462 }; 463 ; 464 // Initializing loop variables; 465 Bool_t isLineToBeSkipped = kFALSE ; //empty and ill-formed lines; 466 char * token = nullptr ;; 467 TString token_str = """" ;; 468 Int_t token_idx = 0 ;; 469 Double_t * value = new Double_t [3] ; //x,y,z buffers; 470 Int_t value_idx = 0 ;; 471 ; 472 // Looping; 473 char *rest;; 474 while (std::getline(infile, line, '\n')) {; 475 if (!line.empty()) {; 476 if (line[line.size() - 1] == char(13)) { // removing DOS CR character; 477 line.erase(line.end() - 1, line.end()) ;; 478 }; 479 token = R__STRTOK_R(const_cast<char*>(line.c_str()), option, &rest);; 480 while (token != nullptr && value_idx < 3) {; 481 if (isTokenToBeSaved[token_idx]) {; 482 token_str = TString(token) ;; 483 token_str.ReplaceAll(""\t"", """") ;; 484 if (!token_str.IsFloat()) {; 485 isLineToBeSkipped = kTRUE ;; 486 break ;; 487 } else {; 488 value[value_idx] = token_str.Atof() ;; 489 value_idx++ ;; 490 }; 491 }; 492 token = R__STRTOK_R(nullptr, option, &rest); // next token; 493 to",MatchSource.WIKI,doc/master/TGraph2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2D_8cxx_source.html
https://root.cern/doc/master/TGraph2D_8cxx_source.html:27363,Availability,avail,available,27363,"FitResultPtr TGraph2D::Fit(const char *fname, Option_t *option, Option_t *); 816{; 817 ; 818 char *linear;; 819 linear = (char*)strstr(fname, ""++"");; 820 ; 821 if (linear) {; 822 TF2 f2(fname, fname);; 823 return Fit(&f2, option, """");; 824 }; 825 TF2 * f2 = (TF2*)gROOT->GetFunction(fname);; 826 if (!f2) {; 827 Printf(""Unknown function: %s"", fname);; 828 return -1;; 829 }; 830 return Fit(f2, option, """");; 831 ; 832}; 833 ; 834 ; 835////////////////////////////////////////////////////////////////////////////////; 836/// Fits this 2D graph with function f2; 837///; 838/// f2 is an already predefined function created by TF2.; 839///; 840/// See TGraph::Fit for the available fitting options and fitting notes; 841///; 842TFitResultPtr TGraph2D::Fit(TF2 *f2, Option_t *option, Option_t *); 843{; 844 // internal graph2D fitting methods; 845 Foption_t fitOption;; 846 Option_t *goption = """";; 847 ROOT::Fit::FitOptionsMake(ROOT::Fit::EFitObjectType::kGraph, option, fitOption);; 848 ; 849 // create range and minimizer options with default values; 850 ROOT::Fit::DataRange range(2);; 851 ROOT::Math::MinimizerOptions minOption;; 852 return ROOT::Fit::FitObject(this, f2 , fitOption , minOption, goption, range);; 853}; 854 ; 855 ; 856////////////////////////////////////////////////////////////////////////////////; 857/// Display a GUI panel with all graph fit options.; 858///; 859/// See class TFitEditor for example; 860 ; 861void TGraph2D::FitPanel(); 862{; 863 if (!gPad); 864 gROOT->MakeDefCanvas();; 865 ; 866 if (!gPad) {; 867 Error(""FitPanel"", ""Unable to create a default canvas"");; 868 return;; 869 }; 870 ; 871 // use plugin manager to create instance of TFitEditor; 872 TPluginHandler *handler = gROOT->GetPluginManager()->FindHandler(""TFitEditor"");; 873 if (handler && handler->LoadPlugin() != -1) {; 874 if (handler->ExecPlugin(2, gPad, this) == 0); 875 Error(""FitPanel"", ""Unable to crate the FitPanel"");; 876 } else; 877 Error(""FitPanel"", ""Unable to find the FitPanel plug-in"");; 87",MatchSource.WIKI,doc/master/TGraph2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2D_8cxx_source.html
https://root.cern/doc/master/TGraph2D_8cxx_source.html:79294,Availability,error,error,79294,"etNamevirtual const char * GetName() constReturns name of object.Definition TObject.cxx:444; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::AppendPadvirtual void AppendPad(Option_t *option="""")Append graphics object to current pad.Definition TObject.cxx:190; TObject::SavePrimitivevirtual void SavePrimitive(std::ostream &out, Option_t *option="""")Save a primitive as a C++ statement(s) on output stream ""out"".Definition TObject.cxx:757; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TObject::MakeZombievoid MakeZombie()Definition TObject.h:53; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TObject::kInvalidObject@ kInvalidObjectif object ctor succeeded but object should not be usedDefinition TObject.h:72; TObject::kMustCleanup@ kMustCleanupif object destructor must call RecursiveRemove()Definition TObject.h:64; TPluginHandlerDefinition TPluginManager.h:103; TPluginHandler::ExecPluginLongptr_t ExecPlugin(int nargs)Definition TPluginManager.h:231; TPluginHandler::LoadPluginInt_t LoadPlugin()Load the plugin library for this handler.Definition TPluginManager.cxx:293; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cx",MatchSource.WIKI,doc/master/TGraph2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2D_8cxx_source.html
https://root.cern/doc/master/TGraph2D_8cxx_source.html:52568,Deployability,update,update,52568,"//////////////////////////////; 1617/// Set maximum.; 1618 ; 1619void TGraph2D::SetMaximum(Double_t maximum); 1620{; 1621 fMaximum = maximum;; 1622 TH1 * h = GetHistogram();; 1623 if (h) h->SetMaximum(maximum);; 1624}; 1625 ; 1626 ; 1627////////////////////////////////////////////////////////////////////////////////; 1628/// Set minimum.; 1629 ; 1630void TGraph2D::SetMinimum(Double_t minimum); 1631{; 1632 fMinimum = minimum;; 1633 TH1 * h = GetHistogram();; 1634 if (h) h->SetMinimum(minimum);; 1635}; 1636 ; 1637 ; 1638////////////////////////////////////////////////////////////////////////////////; 1639/// Changes the name of this 2D graph; 1640 ; 1641void TGraph2D::SetName(const char *name); 1642{; 1643 // 2D graphs are named objects in a THashList.; 1644 // We must update the hashlist if we change the name; 1645 if (fDirectory) fDirectory->Remove(this);; 1646 fName = name;; 1647 if (fDirectory) fDirectory->Append(this);; 1648}; 1649 ; 1650 ; 1651////////////////////////////////////////////////////////////////////////////////; 1652/// Change the name and title of this 2D graph; 1653///; 1654 ; 1655void TGraph2D::SetNameTitle(const char *name, const char *title); 1656{; 1657 // 2D graphs are named objects in a THashList.; 1658 // We must update the hashlist if we change the name; 1659 if (fDirectory) fDirectory->Remove(this);; 1660 fName = name;; 1661 SetTitle(title);; 1662 if (fDirectory) fDirectory->Append(this);; 1663}; 1664 ; 1665 ; 1666////////////////////////////////////////////////////////////////////////////////; 1667/// Sets the number of bins along X used to draw the function; 1668 ; 1669void TGraph2D::SetNpx(Int_t npx); 1670{; 1671 if (npx < 4) {; 1672 Warning(""SetNpx"", ""Number of points must be >4 && < 500, fNpx set to 4"");; 1673 fNpx = 4;; 1674 } else if (npx > 500) {; 1675 Warning(""SetNpx"", ""Number of points must be >4 && < 500, fNpx set to 500"");; 1676 fNpx = 500;; 1677 } else {; 1678 fNpx = npx;; 1679 }; 1680 if (fHistogram) {; 1681 delete fHistogram",MatchSource.WIKI,doc/master/TGraph2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2D_8cxx_source.html
https://root.cern/doc/master/TGraph2D_8cxx_source.html:53048,Deployability,update,update,53048,"/////////; 1652/// Change the name and title of this 2D graph; 1653///; 1654 ; 1655void TGraph2D::SetNameTitle(const char *name, const char *title); 1656{; 1657 // 2D graphs are named objects in a THashList.; 1658 // We must update the hashlist if we change the name; 1659 if (fDirectory) fDirectory->Remove(this);; 1660 fName = name;; 1661 SetTitle(title);; 1662 if (fDirectory) fDirectory->Append(this);; 1663}; 1664 ; 1665 ; 1666////////////////////////////////////////////////////////////////////////////////; 1667/// Sets the number of bins along X used to draw the function; 1668 ; 1669void TGraph2D::SetNpx(Int_t npx); 1670{; 1671 if (npx < 4) {; 1672 Warning(""SetNpx"", ""Number of points must be >4 && < 500, fNpx set to 4"");; 1673 fNpx = 4;; 1674 } else if (npx > 500) {; 1675 Warning(""SetNpx"", ""Number of points must be >4 && < 500, fNpx set to 500"");; 1676 fNpx = 500;; 1677 } else {; 1678 fNpx = npx;; 1679 }; 1680 if (fHistogram) {; 1681 delete fHistogram;; 1682 fHistogram = nullptr;; 1683 fDelaunay = nullptr;; 1684 }; 1685}; 1686 ; 1687 ; 1688////////////////////////////////////////////////////////////////////////////////; 1689/// Sets the number of bins along Y used to draw the function; 1690 ; 1691void TGraph2D::SetNpy(Int_t npy); 1692{; 1693 if (npy < 4) {; 1694 Warning(""SetNpy"", ""Number of points must be >4 && < 500, fNpy set to 4"");; 1695 fNpy = 4;; 1696 } else if (npy > 500) {; 1697 Warning(""SetNpy"", ""Number of points must be >4 && < 500, fNpy set to 500"");; 1698 fNpy = 500;; 1699 } else {; 1700 fNpy = npy;; 1701 }; 1702 if (fHistogram) {; 1703 delete fHistogram;; 1704 fHistogram = nullptr;; 1705 fDelaunay = nullptr;; 1706 }; 1707}; 1708 ; 1709 ; 1710////////////////////////////////////////////////////////////////////////////////; 1711/// Sets point number n.; 1712/// If n is greater than the current size, the arrays are automatically; 1713/// extended.; 1714 ; 1715void TGraph2D::SetPoint(Int_t n, Double_t x, Double_t y, Double_t z); 1716{; 1717 if (n < 0) retur",MatchSource.WIKI,doc/master/TGraph2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2D_8cxx_source.html
https://root.cern/doc/master/TGraph2D_8cxx_source.html:21981,Energy Efficiency,allocate,allocated,21981,"fPainter = nullptr;; 625 fUserHisto = kFALSE;; 626 ; 627 if (TH1::AddDirectoryStatus()) {; 628 fDirectory = gDirectory;; 629 if (fDirectory) {; 630 fDirectory->Append(this, kTRUE);; 631 }; 632 }; 633}; 634 ; 635////////////////////////////////////////////////////////////////////////////////; 636/// Performs the operation: `z = z + c1*f(x,y,z)`; 637/// Errors are not recalculated.; 638///; 639/// \param f may be a 2-D function TF2 or 3-d function TF3; 640/// \param c1 a scaling factor, 1 by default; 641 ; 642void TGraph2D::Add(TF2 *f, Double_t c1); 643{; 644 //if (fHistogram) SetBit(kResetHisto);; 645 ; 646 for (Int_t i = 0; i < fNpoints; i++) {; 647 fZ[i] += c1*f->Eval(fX[i], fY[i], fZ[i]);; 648 }; 649 if (gPad) gPad->Modified();; 650}; 651 ; 652////////////////////////////////////////////////////////////////////////////////; 653/// Apply function f to all the data points; 654/// f may be a 2-D function TF2 or 3-d function TF3; 655/// The Z values of the 2D graph are replaced by the new values computed; 656/// using the function; 657 ; 658void TGraph2D::Apply(TF2 *f); 659{; 660 //if (fHistogram) SetBit(kResetHisto);; 661 ; 662 for (Int_t i = 0; i < fNpoints; i++) {; 663 fZ[i] = f->Eval(fX[i], fY[i], fZ[i]);; 664 }; 665 if (gPad) gPad->Modified();; 666}; 667 ; 668////////////////////////////////////////////////////////////////////////////////; 669/// Browse; 670 ; 671void TGraph2D::Browse(TBrowser *); 672{; 673 Draw(""p0"");; 674 gPad->Update();; 675}; 676 ; 677 ; 678////////////////////////////////////////////////////////////////////////////////; 679/// Free all memory allocated by this object.; 680 ; 681void TGraph2D::Clear(Option_t * /*option = """" */); 682{; 683 if (fX) delete [] fX;; 684 fX = nullptr;; 685 if (fY) delete [] fY;; 686 fY = nullptr;; 687 if (fZ) delete [] fZ;; 688 fZ = nullptr;; 689 fSize = fNpoints = 0;; 690 if (fHistogram && !fUserHisto) {; 691 delete fHistogram;; 692 fHistogram = nullptr;; 693 fDelaunay = nullptr;; 694 }; 695 if (fFunctions) {; 696 ",MatchSource.WIKI,doc/master/TGraph2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2D_8cxx_source.html
https://root.cern/doc/master/TGraph2D_8cxx_source.html:54891,Energy Efficiency,allocate,allocate,54891,"Npy = 500;; 1699 } else {; 1700 fNpy = npy;; 1701 }; 1702 if (fHistogram) {; 1703 delete fHistogram;; 1704 fHistogram = nullptr;; 1705 fDelaunay = nullptr;; 1706 }; 1707}; 1708 ; 1709 ; 1710////////////////////////////////////////////////////////////////////////////////; 1711/// Sets point number n.; 1712/// If n is greater than the current size, the arrays are automatically; 1713/// extended.; 1714 ; 1715void TGraph2D::SetPoint(Int_t n, Double_t x, Double_t y, Double_t z); 1716{; 1717 if (n < 0) return;; 1718 ; 1719 if (!fX || !fY || !fZ || n >= fSize) {; 1720 // re-allocate the object; 1721 Int_t newN = TMath::Max(2 * fSize, n + 1);; 1722 Double_t *savex = new Double_t [newN];; 1723 Double_t *savey = new Double_t [newN];; 1724 Double_t *savez = new Double_t [newN];; 1725 if (fX && fSize) {; 1726 memcpy(savex, fX, fSize * sizeof(Double_t));; 1727 memset(&savex[fSize], 0, (newN - fSize)*sizeof(Double_t));; 1728 delete [] fX;; 1729 }; 1730 if (fY && fSize) {; 1731 memcpy(savey, fY, fSize * sizeof(Double_t));; 1732 memset(&savey[fSize], 0, (newN - fSize)*sizeof(Double_t));; 1733 delete [] fY;; 1734 }; 1735 if (fZ && fSize) {; 1736 memcpy(savez, fZ, fSize * sizeof(Double_t));; 1737 memset(&savez[fSize], 0, (newN - fSize)*sizeof(Double_t));; 1738 delete [] fZ;; 1739 }; 1740 fX = savex;; 1741 fY = savey;; 1742 fZ = savez;; 1743 fSize = newN;; 1744 }; 1745 fX[n] = x;; 1746 fY[n] = y;; 1747 fZ[n] = z;; 1748 fNpoints = TMath::Max(fNpoints, n + 1);; 1749}; 1750 ; 1751 ; 1752////////////////////////////////////////////////////////////////////////////////; 1753/// Sets the 2D graph title.; 1754///; 1755/// This method allows to change the global title and the axis' titles of a 2D; 1756/// graph. If `g` is the 2D graph one can do:; 1757///; 1758/// ~~~ {.cpp}; 1759/// g->SetTitle(""Graph title; X axis title; Y axis title; Z axis title"");; 1760/// ~~~; 1761 ; 1762void TGraph2D::SetTitle(const char* title); 1763{; 1764 fTitle = title;; 1765 if (fHistogram) fHistogram->SetTitle(tit",MatchSource.WIKI,doc/master/TGraph2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2D_8cxx_source.html
https://root.cern/doc/master/TGraph2D_8cxx_source.html:72777,Energy Efficiency,allocate,allocated,72777,"; TGraph2D::SetHistogramvirtual void SetHistogram(TH2 *h, Option_t *option="""")Sets the histogram to be filled.Definition TGraph2D.cxx:1568; TGraph2D::SetMaximumvoid SetMaximum(Double_t maximum=-1111)Set maximum.Definition TGraph2D.cxx:1619; TGraph2D::Addvirtual void Add(TF2 *f, Double_t c1=1)Performs the operation: z = z + c1*f(x,y,z) Errors are not recalculated.Definition TGraph2D.cxx:642; TGraph2D::GetYmaxDouble_t GetYmax() constReturns the Y maximum.Definition TGraph2D.cxx:1175; TGraph2D::DistancetoPrimitiveInt_t DistancetoPrimitive(Int_t px, Int_t py) overrideComputes distance from point px,py to a graph.Definition TGraph2D.cxx:730; TGraph2D::SetDirectoryvirtual void SetDirectory(TDirectory *dir)By default when an 2D graph is created, it is added to the list of 2D graph objects in the current di...Definition TGraph2D.cxx:1544; TGraph2D::fDirectoryTDirectory * fDirectory!Pointer to directory holding this 2D graphDefinition TGraph2D.h:60; TGraph2D::Clearvoid Clear(Option_t *option="""") overrideFree all memory allocated by this object.Definition TGraph2D.cxx:681; TGraph2D::Scalevirtual void Scale(Double_t c1=1., Option_t *option=""z"")Multiply the values of a TGraph2D by a constant c1.Definition TGraph2D.cxx:1506; TGraph2D::DirectoryAutoAddvirtual void DirectoryAutoAdd(TDirectory *)Perform the automatic addition of the graph to the given directory.Definition TGraph2D.cxx:715; TGraph2D::CreateInterpolatorvoid CreateInterpolator(Bool_t oldInterp)Add a TGraphDelaunay in the list of the fHistogram's functions.Definition TGraph2D.cxx:968; TGraph2D::fNpyInt_t fNpyNumber of bins along Y in fHistogram.Definition TGraph2D.h:47; TGraph2D::fFunctionsTList * fFunctionsPointer to list of functions (fits and user)Definition TGraph2D.h:57; TGraph2D::SetPointvirtual void SetPoint(Int_t point, Double_t x, Double_t y, Double_t z)Sets point number n.Definition TGraph2D.cxx:1715; TGraph2D::Paintvoid Paint(Option_t *option="""") overridePaints this 2D graph with its current attributes.Defin",MatchSource.WIKI,doc/master/TGraph2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2D_8cxx_source.html
https://root.cern/doc/master/TGraph2D_8cxx_source.html:15872,Integrability,message,message,15872,"sDigit()) {; 442 Error(""TGraph2D"", ""Incorrect input format! Allowed format tags are {\""%%lg\"",\""%%*lg\"" or \""%%*s\""}"");; 443 return;; 444 }; 445 Int_t ntokens = format_.Length() ;; 446 if (ntokens < 3) {; 447 Error(""TGraph2D"", ""Incorrect input format! Only %d tag(s) in format whereas 3 \""%%lg\"" tags are expected!"", ntokens);; 448 return;; 449 }; 450 Int_t ntokensToBeSaved = 0 ;; 451 Bool_t * isTokenToBeSaved = new Bool_t [ntokens] ;; 452 for (Int_t idx = 0; idx < ntokens; idx++) {; 453 isTokenToBeSaved[idx] = TString::Format(""%c"", format_[idx]).Atoi() ; //atoi(&format_[idx]) does not work for some reason...; 454 if (isTokenToBeSaved[idx] == 1) {; 455 ntokensToBeSaved++ ;; 456 }; 457 }; 458 if (ntokens >= 3 && ntokensToBeSaved != 3) { //first condition not to repeat the previous error message; 459 Error(""TGraph2D"", ""Incorrect input format! There are %d \""%%lg\"" tag(s) in format whereas 3 and only 3 are expected!"", ntokensToBeSaved);; 460 delete [] isTokenToBeSaved ;; 461 return;; 462 }; 463 ; 464 // Initializing loop variables; 465 Bool_t isLineToBeSkipped = kFALSE ; //empty and ill-formed lines; 466 char * token = nullptr ;; 467 TString token_str = """" ;; 468 Int_t token_idx = 0 ;; 469 Double_t * value = new Double_t [3] ; //x,y,z buffers; 470 Int_t value_idx = 0 ;; 471 ; 472 // Looping; 473 char *rest;; 474 while (std::getline(infile, line, '\n')) {; 475 if (!line.empty()) {; 476 if (line[line.size() - 1] == char(13)) { // removing DOS CR character; 477 line.erase(line.end() - 1, line.end()) ;; 478 }; 479 token = R__STRTOK_R(const_cast<char*>(line.c_str()), option, &rest);; 480 while (token != nullptr && value_idx < 3) {; 481 if (isTokenToBeSaved[token_idx]) {; 482 token_str = TString(token) ;; 483 token_str.ReplaceAll(""\t"", """") ;; 484 if (!token_str.IsFloat()) {; 485 isLineToBeSkipped = kTRUE ;; 486 break ;; 487 } else {; 488 value[value_idx] = token_str.Atof() ;; 489 value_idx++ ;; 490 }; 491 }; 492 token = R__STRTOK_R(nullptr, option, &rest); // next token; 493 to",MatchSource.WIKI,doc/master/TGraph2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2D_8cxx_source.html
https://root.cern/doc/master/TGraph2D_8cxx_source.html:32676,Integrability,rout,routine,32676," dt;; 984 ResetBit(kOldInterpolation);; 985 if (!hl->FindObject(""TGraphDelaunay2D"")) hl->Add(fDelaunay);; 986 }; 987}; 988 ; 989////////////////////////////////////////////////////////////////////////////////; 990/// By default returns a pointer to the Delaunay histogram. If fHistogram; 991/// doesn't exist, books the 2D histogram fHistogram with a margin around; 992/// the hull. Calls TGraphDelaunay::Interpolate at each bin centre to build up; 993/// an interpolated 2D histogram.; 994///; 995/// If the ""empty"" option is selected, returns an empty histogram booked with; 996/// the limits of fX, fY and fZ. This option is used when the data set is; 997/// drawn with markers only. In that particular case there is no need to; 998/// find the Delaunay triangles.; 999///; 1000/// By default use the new interpolation routine based on Triangles; 1001/// If the option ""old"" the old interpolation is used; 1002 ; 1003TH2D *TGraph2D::GetHistogram(Option_t *option); 1004{; 1005 // for an empty graph create histogram in [0,1][0,1]; 1006 if (fNpoints <= 0) {; 1007 if (!fHistogram) {; 1008 // do not add the histogram to gDirectory; 1009 TDirectory::TContext ctx(nullptr);; 1010 fHistogram = new TH2D(GetName(), GetTitle(), fNpx , 0., 1., fNpy, 0., 1.);; 1011 fHistogram->SetBit(TH1::kNoStats);; 1012 }; 1013 return fHistogram;; 1014 }; 1015 ; 1016 TString opt = option;; 1017 opt.ToLower();; 1018 Bool_t empty = opt.Contains(""empty"");; 1019 Bool_t oldInterp = opt.Contains(""old"");; 1020 ; 1021 if (fHistogram) {; 1022 if (!empty && fHistogram->GetEntries() == 0) {; 1023 if (!fUserHisto) {; 1024 delete fHistogram;; 1025 fHistogram = nullptr;; 1026 fDelaunay = nullptr;; 1027 }; 1028 } else if (fHistogram->GetEntries() == 0); 1029 {; }; 1030 // check case if interpolation type has changed; 1031 else if ( (TestBit(kOldInterpolation) && !oldInterp) || ( !TestBit(kOldInterpolation) && oldInterp ) ) {; 1032 delete fHistogram;; 1033 fHistogram = nullptr;; 1034 fDelaunay = nullptr;; 1035 }; 1036 // ",MatchSource.WIKI,doc/master/TGraph2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2D_8cxx_source.html
https://root.cern/doc/master/TGraph2D_8cxx_source.html:42582,Integrability,depend,depending,42582,"r"") && !opt.Contains(""tri"")) opt.Append(""tri0"");; 1288 ; 1289 if (opt.Contains(""tri0"")) {; 1290 GetHistogram(""empty"");; 1291 } else if (opt.Contains(""old"")) {; 1292 GetHistogram(""old"");; 1293 } else {; 1294 GetHistogram();; 1295 }; 1296 ; 1297 fHistogram->SetLineColor(GetLineColor());; 1298 fHistogram->SetLineStyle(GetLineStyle());; 1299 fHistogram->SetLineWidth(GetLineWidth());; 1300 fHistogram->SetFillColor(GetFillColor());; 1301 fHistogram->SetFillStyle(GetFillStyle());; 1302 fHistogram->SetMarkerColor(GetMarkerColor());; 1303 fHistogram->SetMarkerStyle(GetMarkerStyle());; 1304 fHistogram->SetMarkerSize(GetMarkerSize());; 1305 fHistogram->Paint(opt.Data());; 1306}; 1307 ; 1308 ; 1309////////////////////////////////////////////////////////////////////////////////; 1310/// Print 2D graph values.; 1311 ; 1312void TGraph2D::Print(Option_t *) const; 1313{; 1314 for (Int_t i = 0; i < fNpoints; i++) {; 1315 printf(""x[%d]=%g, y[%d]=%g, z[%d]=%g\n"", i, fX[i], i, fY[i], i, fZ[i]);; 1316 }; 1317}; 1318 ; 1319 ; 1320////////////////////////////////////////////////////////////////////////////////; 1321/// Projects a 2-d graph into 1 or 2-d histograms depending on the option parameter.; 1322/// option may contain a combination of the characters x,y,z:; 1323///; 1324/// - option = ""x"" return the x projection into a TH1D histogram; 1325/// - option = ""y"" return the y projection into a TH1D histogram; 1326/// - option = ""xy"" return the x versus y projection into a TH2D histogram; 1327/// - option = ""yx"" return the y versus x projection into a TH2D histogram; 1328 ; 1329TH1 *TGraph2D::Project(Option_t *option) const; 1330{; 1331 if (fNpoints <= 0) {; 1332 Error(""Project"", ""Empty TGraph2D"");; 1333 return nullptr;; 1334 }; 1335 ; 1336 TString opt = option;; 1337 opt.ToLower();; 1338 ; 1339 Int_t pcase = 0;; 1340 if (opt.Contains(""x"")) pcase = 1;; 1341 if (opt.Contains(""y"")) pcase = 2;; 1342 if (opt.Contains(""xy"")) pcase = 3;; 1343 if (opt.Contains(""yx"")) pcase = 4;; 1344 ; 1345 // C",MatchSource.WIKI,doc/master/TGraph2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2D_8cxx_source.html
https://root.cern/doc/master/TGraph2D_8cxx_source.html:50336,Integrability,rout,routine,50336,"o new directory dir. dir can be 0 in which case the; 1542/// 2D graph does not belong to any directory.; 1543 ; 1544void TGraph2D::SetDirectory(TDirectory *dir); 1545{; 1546 if (fDirectory == dir) return;; 1547 if (fDirectory) fDirectory->Remove(this);; 1548 fDirectory = dir;; 1549 if (fDirectory) fDirectory->Append(this);; 1550}; 1551 ; 1552 ; 1553////////////////////////////////////////////////////////////////////////////////; 1554/// Sets the histogram to be filled.; 1555/// If the 2D graph needs to be save in a TFile the following set should be; 1556/// followed to read it back:; 1557/// 1. Create TGraph2D; 1558/// 2. Call g->SetHistogram(h), and do whatever you need to do; 1559/// 3. Save g and h to the TFile, exit; 1560/// 4. Open the TFile, retrieve g and h; 1561/// 5. Call h->SetDirectory(0); 1562/// 6. Call g->SetHistogram(h) again; 1563/// 7. Carry on as normal; 1564///; 1565/// By default use the new interpolation routine based on Triangles; 1566/// If the option ""old"" the old interpolation is used; 1567 ; 1568void TGraph2D::SetHistogram(TH2 *h, Option_t *option); 1569{; 1570 TString opt = option;; 1571 opt.ToLower();; 1572 Bool_t oldInterp = opt.Contains(""old"");; 1573 ; 1574 fUserHisto = kTRUE;; 1575 fHistogram = (TH2D*)h;; 1576 fNpx = h->GetNbinsX();; 1577 fNpy = h->GetNbinsY();; 1578 CreateInterpolator(oldInterp);; 1579}; 1580 ; 1581 ; 1582////////////////////////////////////////////////////////////////////////////////; 1583/// Sets the extra space (in %) around interpolated area for the 2D histogram; 1584 ; 1585void TGraph2D::SetMargin(Double_t m); 1586{; 1587 if (m < 0 || m > 1) {; 1588 Warning(""SetMargin"", ""The margin must be >= 0 && <= 1, fMargin set to 0.1"");; 1589 fMargin = 0.1;; 1590 } else {; 1591 fMargin = m;; 1592 }; 1593 if (fHistogram) {; 1594 delete fHistogram;; 1595 fHistogram = nullptr;; 1596 fDelaunay = nullptr;; 1597 }; 1598}; 1599 ; 1600 ; 1601////////////////////////////////////////////////////////////////////////////////; 1602/// Se",MatchSource.WIKI,doc/master/TGraph2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2D_8cxx_source.html
https://root.cern/doc/master/TGraph2D_8cxx_source.html:71094,Integrability,depend,depending,71094,"2D::fHistogramTH2D * fHistogram!2D histogram of z values linearly interpolated on the trianglesDefinition TGraph2D.h:58; TGraph2D::GetXminEvirtual Double_t GetXminE() constDefinition TGraph2D.h:142; TGraph2D::GetContourListTList * GetContourList(Double_t contour)Returns the X and Y graphs building a contour.Definition TGraph2D.cxx:920; TGraph2D::GetXmaxDouble_t GetXmax() constReturns the X maximum.Definition TGraph2D.cxx:1153; TGraph2D::GetPointvirtual Int_t GetPoint(Int_t i, Double_t &x, Double_t &y, Double_t &z) constGet x, y and z values for point number i.Definition TGraph2D.cxx:1219; TGraph2D::GetYaxisTAxis * GetYaxis() constGet y axis of the graph.Definition TGraph2D.cxx:896; TGraph2D::GetErrorYvirtual Double_t GetErrorY(Int_t bin) constThis function is called by Graph2DFitChisquare.Definition TGraph2D.cxx:949; TGraph2D::fDelaunayTObject * fDelaunay! Pointer to Delaunay interpolator objectDefinition TGraph2D.h:59; TGraph2D::ProjectTH1 * Project(Option_t *option=""x"") constProjects a 2-d graph into 1 or 2-d histograms depending on the option parameter.Definition TGraph2D.cxx:1329; TGraph2D::GetNInt_t GetN() constDefinition TGraph2D.h:122; TGraph2D::GetXmaxEvirtual Double_t GetXmaxE() constDefinition TGraph2D.h:141; TGraph2D::Setvirtual void Set(Int_t n)Set number of points in the 2D graph.Definition TGraph2D.cxx:1528; TGraph2D::SetMinimumvoid SetMinimum(Double_t minimum=-1111)Set minimum.Definition TGraph2D.cxx:1630; TGraph2D::operator=TGraph2D & operator=(const TGraph2D &)Graph2D operator ""="".Definition TGraph2D.cxx:557; TGraph2D::fXDouble_t * fX[fNpoints]Definition TGraph2D.h:50; TGraph2D::fYDouble_t * fY[fNpoints] Data set to be plottedDefinition TGraph2D.h:51; TGraph2D::SetHistogramvirtual void SetHistogram(TH2 *h, Option_t *option="""")Sets the histogram to be filled.Definition TGraph2D.cxx:1568; TGraph2D::SetMaximumvoid SetMaximum(Double_t maximum=-1111)Set maximum.Definition TGraph2D.cxx:1619; TGraph2D::Addvirtual void Add(TF2 *f, Double_t c1=1)Performs the",MatchSource.WIKI,doc/master/TGraph2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2D_8cxx_source.html
https://root.cern/doc/master/TGraph2D_8cxx_source.html:76823,Integrability,rout,routine,76823,"18; TH1::kNoStats@ kNoStatsDon't draw stats box.Definition TH1.h:165; TH1::GetXaxisTAxis * GetXaxis()Definition TH1.h:324; TH1::GetPainterTVirtualHistPainter * GetPainter(Option_t *option="""")Return pointer to painter.Definition TH1.cxx:4511; TH1::GetMaximumvirtual Double_t GetMaximum(Double_t maxval=FLT_MAX) constReturn maximum value smaller than maxval of bins in the range, unless the value has been overridden b...Definition TH1.cxx:8545; TH1::SetMaximumvirtual void SetMaximum(Double_t maximum=-1111)Definition TH1.h:404; TH1::Fillvirtual Int_t Fill(Double_t x)Increment bin with abscissa X by 1.Definition TH1.cxx:3344; TH1::GetYaxisTAxis * GetYaxis()Definition TH1.h:325; TH1::SetMinimumvirtual void SetMinimum(Double_t minimum=-1111)Definition TH1.h:405; TH1::GetEntriesvirtual Double_t GetEntries() constReturn the current number of entries.Definition TH1.cxx:4423; TH1::GetListOfFunctionsTList * GetListOfFunctions() constDefinition TH1.h:244; TH1::Paintvoid Paint(Option_t *option="""") overrideControl routine to paint any kind of histograms.Definition TH1.cxx:6206; TH1::ExecuteEventvoid ExecuteEvent(Int_t event, Int_t px, Int_t py) overrideExecute action corresponding to one event.Definition TH1.cxx:3240; TH1::AddDirectoryStatusstatic Bool_t AddDirectoryStatus()Static function: cannot be inlined on Windows/NT.Definition TH1.cxx:754; TH2D2-D histogram with a double per channel (see TH1 documentation)Definition TH2.h:357; TH2Service class for 2-D histogram classes.Definition TH2.h:30; TH2::FillInt_t Fill(Double_t) overrideInvalid Fill method.Definition TH2.cxx:393; TIterDefinition TCollection.h:235; TListA doubly linked list.Definition TList.h:38; TList::FindObjectTObject * FindObject(const char *name) const overrideFind an object in this list using its name.Definition TList.cxx:576; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TList::Deletevoid Delete(Option_t *option="""") overrideRemove all objects from the list AND delete all heap based objects.Definit",MatchSource.WIKI,doc/master/TGraph2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2D_8cxx_source.html
https://root.cern/doc/master/TGraph2D_8cxx_source.html:78576,Integrability,message,message,78576,"his list using its name.Definition TList.cxx:576; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TList::Deletevoid Delete(Option_t *option="""") overrideRemove all objects from the list AND delete all heap based objects.Definition TList.cxx:468; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TNamed::GetTitleconst char * GetTitle() const overrideReturns title of object.Definition TNamed.h:48; TNamed::fTitleTString fTitleDefinition TNamed.h:33; TNamed::fNameTString fNameDefinition TNamed.h:32; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::GetNamevirtual const char * GetName() constReturns name of object.Definition TObject.cxx:444; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::AppendPadvirtual void AppendPad(Option_t *option="""")Append graphics object to current pad.Definition TObject.cxx:190; TObject::SavePrimitivevirtual void SavePrimitive(std::ostream &out, Option_t *option="""")Save a primitive as a C++ statement(s) on output stream ""out"".Definition TObject.cxx:757; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TObject::MakeZombievoid MakeZombie()Definition TObject.h:53; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::kCanDelete@ kCanDeleteif object ",MatchSource.WIKI,doc/master/TGraph2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2D_8cxx_source.html
https://root.cern/doc/master/TGraph2D_8cxx_source.html:79300,Integrability,message,message,79300,"etNamevirtual const char * GetName() constReturns name of object.Definition TObject.cxx:444; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::AppendPadvirtual void AppendPad(Option_t *option="""")Append graphics object to current pad.Definition TObject.cxx:190; TObject::SavePrimitivevirtual void SavePrimitive(std::ostream &out, Option_t *option="""")Save a primitive as a C++ statement(s) on output stream ""out"".Definition TObject.cxx:757; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TObject::MakeZombievoid MakeZombie()Definition TObject.h:53; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TObject::kInvalidObject@ kInvalidObjectif object ctor succeeded but object should not be usedDefinition TObject.h:72; TObject::kMustCleanup@ kMustCleanupif object destructor must call RecursiveRemove()Definition TObject.h:64; TPluginHandlerDefinition TPluginManager.h:103; TPluginHandler::ExecPluginLongptr_t ExecPlugin(int nargs)Definition TPluginManager.h:231; TPluginHandler::LoadPluginInt_t LoadPlugin()Load the plugin library for this handler.Definition TPluginManager.cxx:293; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cx",MatchSource.WIKI,doc/master/TGraph2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2D_8cxx_source.html
https://root.cern/doc/master/TGraph2D_8cxx_source.html:2858,Modifiability,extend,extended,2858,"s:; 58- With an array's dimension and three arrays x, y, and z:; 59~~~ {.cpp}; 60 auto g = new TGraph2D(n, x, y, z);; 61~~~; 62 x, y, z arrays can be doubles, floats, or ints.; 63- With an array's dimension only:; 64~~~ {.cpp}; 65 auto g = new TGraph2D(n);; 66~~~; 67 The internal arrays are then filled with `SetPoint()`. The following line; 68 fills the internal arrays at the position `i` with the values; 69 `x`, `y`, `z`.; 70~~~ {.cpp}; 71 g->SetPoint(i, x, y, z);; 72~~~; 73- Without parameters:; 74~~~ {.cpp}; 75 auto g = new TGraph2D();; 76~~~; 77 again `SetPoint()` must be used to fill the internal arrays.; 78- From a file:; 79~~~ {.cpp}; 80 auto g = new TGraph2D(""graph.dat"");; 81~~~; 82 Arrays are read from the ASCII file ""graph.dat"" according to a specifies; 83 format. The default format is `%%lg %%lg %%lg`; 84 ; 85Note that in any of these three cases, `SetPoint()` can be used to change a data; 86point or add a new one. If the data point index (`i`) is greater than the; 87current size of the internal arrays, they are automatically extended.; 88 ; 89Like TGraph some TGraph2D constructors do not have the TGraph2D title and name as parameters.; 90For these constructors TGraph2D has the default title and name ""Graph2D"". To change the; 91default title and name `SetTitle` and `SetName` should be called on the TGraph2D after its; 92creation.; 93 ; 94\anchor G2D01; 95## Drawing options; 96 ; 97Specific drawing options can be used to paint a TGraph2D:; 98 ; 99| Option | Description |; 100|----------|-------------------------------------------------------------------|; 101| ""TRI"" | The Delaunay triangles are drawn using filled area. An hidden surface drawing technique is used. The surface is painted with the current fill area color. The edges of each triangles are painted with the current line color. |; 102| ""TRIW"" | The Delaunay triangles are drawn as wire frame. |; 103| ""TRI1"" | The Delaunay triangles are painted with color levels. The edges of each triangles are paint",MatchSource.WIKI,doc/master/TGraph2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2D_8cxx_source.html
https://root.cern/doc/master/TGraph2D_8cxx_source.html:16109,Modifiability,variab,variables,16109,"sDigit()) {; 442 Error(""TGraph2D"", ""Incorrect input format! Allowed format tags are {\""%%lg\"",\""%%*lg\"" or \""%%*s\""}"");; 443 return;; 444 }; 445 Int_t ntokens = format_.Length() ;; 446 if (ntokens < 3) {; 447 Error(""TGraph2D"", ""Incorrect input format! Only %d tag(s) in format whereas 3 \""%%lg\"" tags are expected!"", ntokens);; 448 return;; 449 }; 450 Int_t ntokensToBeSaved = 0 ;; 451 Bool_t * isTokenToBeSaved = new Bool_t [ntokens] ;; 452 for (Int_t idx = 0; idx < ntokens; idx++) {; 453 isTokenToBeSaved[idx] = TString::Format(""%c"", format_[idx]).Atoi() ; //atoi(&format_[idx]) does not work for some reason...; 454 if (isTokenToBeSaved[idx] == 1) {; 455 ntokensToBeSaved++ ;; 456 }; 457 }; 458 if (ntokens >= 3 && ntokensToBeSaved != 3) { //first condition not to repeat the previous error message; 459 Error(""TGraph2D"", ""Incorrect input format! There are %d \""%%lg\"" tag(s) in format whereas 3 and only 3 are expected!"", ntokensToBeSaved);; 460 delete [] isTokenToBeSaved ;; 461 return;; 462 }; 463 ; 464 // Initializing loop variables; 465 Bool_t isLineToBeSkipped = kFALSE ; //empty and ill-formed lines; 466 char * token = nullptr ;; 467 TString token_str = """" ;; 468 Int_t token_idx = 0 ;; 469 Double_t * value = new Double_t [3] ; //x,y,z buffers; 470 Int_t value_idx = 0 ;; 471 ; 472 // Looping; 473 char *rest;; 474 while (std::getline(infile, line, '\n')) {; 475 if (!line.empty()) {; 476 if (line[line.size() - 1] == char(13)) { // removing DOS CR character; 477 line.erase(line.end() - 1, line.end()) ;; 478 }; 479 token = R__STRTOK_R(const_cast<char*>(line.c_str()), option, &rest);; 480 while (token != nullptr && value_idx < 3) {; 481 if (isTokenToBeSaved[token_idx]) {; 482 token_str = TString(token) ;; 483 token_str.ReplaceAll(""\t"", """") ;; 484 if (!token_str.IsFloat()) {; 485 isLineToBeSkipped = kTRUE ;; 486 break ;; 487 } else {; 488 value[value_idx] = token_str.Atof() ;; 489 value_idx++ ;; 490 }; 491 }; 492 token = R__STRTOK_R(nullptr, option, &rest); // next token; 493 to",MatchSource.WIKI,doc/master/TGraph2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2D_8cxx_source.html
https://root.cern/doc/master/TGraph2D_8cxx_source.html:28326,Modifiability,plugin,plugin,28326,"2 *f2, Option_t *option, Option_t *); 843{; 844 // internal graph2D fitting methods; 845 Foption_t fitOption;; 846 Option_t *goption = """";; 847 ROOT::Fit::FitOptionsMake(ROOT::Fit::EFitObjectType::kGraph, option, fitOption);; 848 ; 849 // create range and minimizer options with default values; 850 ROOT::Fit::DataRange range(2);; 851 ROOT::Math::MinimizerOptions minOption;; 852 return ROOT::Fit::FitObject(this, f2 , fitOption , minOption, goption, range);; 853}; 854 ; 855 ; 856////////////////////////////////////////////////////////////////////////////////; 857/// Display a GUI panel with all graph fit options.; 858///; 859/// See class TFitEditor for example; 860 ; 861void TGraph2D::FitPanel(); 862{; 863 if (!gPad); 864 gROOT->MakeDefCanvas();; 865 ; 866 if (!gPad) {; 867 Error(""FitPanel"", ""Unable to create a default canvas"");; 868 return;; 869 }; 870 ; 871 // use plugin manager to create instance of TFitEditor; 872 TPluginHandler *handler = gROOT->GetPluginManager()->FindHandler(""TFitEditor"");; 873 if (handler && handler->LoadPlugin() != -1) {; 874 if (handler->ExecPlugin(2, gPad, this) == 0); 875 Error(""FitPanel"", ""Unable to crate the FitPanel"");; 876 } else; 877 Error(""FitPanel"", ""Unable to find the FitPanel plug-in"");; 878 ; 879}; 880 ; 881 ; 882////////////////////////////////////////////////////////////////////////////////; 883/// Get x axis of the graph.; 884 ; 885TAxis *TGraph2D::GetXaxis() const; 886{; 887 TH1 *h = ((TGraph2D*)this)->GetHistogram(""empty"");; 888 if (!h) return nullptr;; 889 return h->GetXaxis();; 890}; 891 ; 892 ; 893////////////////////////////////////////////////////////////////////////////////; 894/// Get y axis of the graph.; 895 ; 896TAxis *TGraph2D::GetYaxis() const; 897{; 898 TH1 *h = ((TGraph2D*)this)->GetHistogram(""empty"");; 899 if (!h) return nullptr;; 900 return h->GetYaxis();; 901}; 902 ; 903 ; 904////////////////////////////////////////////////////////////////////////////////; 905/// Get z axis of the graph.; 906 ; 907TAxis *TGr",MatchSource.WIKI,doc/master/TGraph2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2D_8cxx_source.html
https://root.cern/doc/master/TGraph2D_8cxx_source.html:28680,Modifiability,plug-in,plug-in,28680,"2 *f2, Option_t *option, Option_t *); 843{; 844 // internal graph2D fitting methods; 845 Foption_t fitOption;; 846 Option_t *goption = """";; 847 ROOT::Fit::FitOptionsMake(ROOT::Fit::EFitObjectType::kGraph, option, fitOption);; 848 ; 849 // create range and minimizer options with default values; 850 ROOT::Fit::DataRange range(2);; 851 ROOT::Math::MinimizerOptions minOption;; 852 return ROOT::Fit::FitObject(this, f2 , fitOption , minOption, goption, range);; 853}; 854 ; 855 ; 856////////////////////////////////////////////////////////////////////////////////; 857/// Display a GUI panel with all graph fit options.; 858///; 859/// See class TFitEditor for example; 860 ; 861void TGraph2D::FitPanel(); 862{; 863 if (!gPad); 864 gROOT->MakeDefCanvas();; 865 ; 866 if (!gPad) {; 867 Error(""FitPanel"", ""Unable to create a default canvas"");; 868 return;; 869 }; 870 ; 871 // use plugin manager to create instance of TFitEditor; 872 TPluginHandler *handler = gROOT->GetPluginManager()->FindHandler(""TFitEditor"");; 873 if (handler && handler->LoadPlugin() != -1) {; 874 if (handler->ExecPlugin(2, gPad, this) == 0); 875 Error(""FitPanel"", ""Unable to crate the FitPanel"");; 876 } else; 877 Error(""FitPanel"", ""Unable to find the FitPanel plug-in"");; 878 ; 879}; 880 ; 881 ; 882////////////////////////////////////////////////////////////////////////////////; 883/// Get x axis of the graph.; 884 ; 885TAxis *TGraph2D::GetXaxis() const; 886{; 887 TH1 *h = ((TGraph2D*)this)->GetHistogram(""empty"");; 888 if (!h) return nullptr;; 889 return h->GetXaxis();; 890}; 891 ; 892 ; 893////////////////////////////////////////////////////////////////////////////////; 894/// Get y axis of the graph.; 895 ; 896TAxis *TGraph2D::GetYaxis() const; 897{; 898 TH1 *h = ((TGraph2D*)this)->GetHistogram(""empty"");; 899 if (!h) return nullptr;; 900 return h->GetYaxis();; 901}; 902 ; 903 ; 904////////////////////////////////////////////////////////////////////////////////; 905/// Get z axis of the graph.; 906 ; 907TAxis *TGr",MatchSource.WIKI,doc/master/TGraph2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2D_8cxx_source.html
https://root.cern/doc/master/TGraph2D_8cxx_source.html:54704,Modifiability,extend,extended,54704,"fNpx set to 500"");; 1676 fNpx = 500;; 1677 } else {; 1678 fNpx = npx;; 1679 }; 1680 if (fHistogram) {; 1681 delete fHistogram;; 1682 fHistogram = nullptr;; 1683 fDelaunay = nullptr;; 1684 }; 1685}; 1686 ; 1687 ; 1688////////////////////////////////////////////////////////////////////////////////; 1689/// Sets the number of bins along Y used to draw the function; 1690 ; 1691void TGraph2D::SetNpy(Int_t npy); 1692{; 1693 if (npy < 4) {; 1694 Warning(""SetNpy"", ""Number of points must be >4 && < 500, fNpy set to 4"");; 1695 fNpy = 4;; 1696 } else if (npy > 500) {; 1697 Warning(""SetNpy"", ""Number of points must be >4 && < 500, fNpy set to 500"");; 1698 fNpy = 500;; 1699 } else {; 1700 fNpy = npy;; 1701 }; 1702 if (fHistogram) {; 1703 delete fHistogram;; 1704 fHistogram = nullptr;; 1705 fDelaunay = nullptr;; 1706 }; 1707}; 1708 ; 1709 ; 1710////////////////////////////////////////////////////////////////////////////////; 1711/// Sets point number n.; 1712/// If n is greater than the current size, the arrays are automatically; 1713/// extended.; 1714 ; 1715void TGraph2D::SetPoint(Int_t n, Double_t x, Double_t y, Double_t z); 1716{; 1717 if (n < 0) return;; 1718 ; 1719 if (!fX || !fY || !fZ || n >= fSize) {; 1720 // re-allocate the object; 1721 Int_t newN = TMath::Max(2 * fSize, n + 1);; 1722 Double_t *savex = new Double_t [newN];; 1723 Double_t *savey = new Double_t [newN];; 1724 Double_t *savez = new Double_t [newN];; 1725 if (fX && fSize) {; 1726 memcpy(savex, fX, fSize * sizeof(Double_t));; 1727 memset(&savex[fSize], 0, (newN - fSize)*sizeof(Double_t));; 1728 delete [] fX;; 1729 }; 1730 if (fY && fSize) {; 1731 memcpy(savey, fY, fSize * sizeof(Double_t));; 1732 memset(&savey[fSize], 0, (newN - fSize)*sizeof(Double_t));; 1733 delete [] fY;; 1734 }; 1735 if (fZ && fSize) {; 1736 memcpy(savez, fZ, fSize * sizeof(Double_t));; 1737 memset(&savez[fSize], 0, (newN - fSize)*sizeof(Double_t));; 1738 delete [] fZ;; 1739 }; 1740 fX = savex;; 1741 fY = savey;; 1742 fZ = savez;; 1743 fSi",MatchSource.WIKI,doc/master/TGraph2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2D_8cxx_source.html
https://root.cern/doc/master/TGraph2D_8cxx_source.html:79146,Modifiability,inherit,inherits,79146,"on TNamed.h:48; TNamed::fTitleTString fTitleDefinition TNamed.h:33; TNamed::fNameTString fNameDefinition TNamed.h:32; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::GetNamevirtual const char * GetName() constReturns name of object.Definition TObject.cxx:444; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::AppendPadvirtual void AppendPad(Option_t *option="""")Append graphics object to current pad.Definition TObject.cxx:190; TObject::SavePrimitivevirtual void SavePrimitive(std::ostream &out, Option_t *option="""")Save a primitive as a C++ statement(s) on output stream ""out"".Definition TObject.cxx:757; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TObject::MakeZombievoid MakeZombie()Definition TObject.h:53; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TObject::kInvalidObject@ kInvalidObjectif object ctor succeeded but object should not be usedDefinition TObject.h:72; TObject::kMustCleanup@ kMustCleanupif object destructor must call RecursiveRemove()Definition TObject.h:64; TPluginHandlerDefinition TPluginManager.h:103; TPluginHandler::ExecPluginLongptr_t ExecPlugin(int nargs)Definition TPluginManager.h:231; TPluginHandler::LoadPluginInt_t LoadPlugin()Load the plugin library for this handler.Definition TPluginManager.cxx:293; TStri",MatchSource.WIKI,doc/master/TGraph2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2D_8cxx_source.html
https://root.cern/doc/master/TGraph2D_8cxx_source.html:80035,Modifiability,plugin,plugin,80035,"nition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TObject::MakeZombievoid MakeZombie()Definition TObject.h:53; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TObject::kInvalidObject@ kInvalidObjectif object ctor succeeded but object should not be usedDefinition TObject.h:72; TObject::kMustCleanup@ kMustCleanupif object destructor must call RecursiveRemove()Definition TObject.h:64; TPluginHandlerDefinition TPluginManager.h:103; TPluginHandler::ExecPluginLongptr_t ExecPlugin(int nargs)Definition TPluginManager.h:231; TPluginHandler::LoadPluginInt_t LoadPlugin()Load the plugin library for this handler.Definition TPluginManager.cxx:293; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::AtoiInt_t Atoi() constReturn integer value of string.Definition TString.cxx:1988; TString::AtofDouble_t Atof() constReturn floating-point value contained in string.Definition TString.cxx:2054; TString::IsFloatBool_t IsFloat() constReturns kTRUE if string contains a floating point or integer number.Definition TString.cxx:1858; TString::Dataconst char * Data() constDefinition TString.h:376; TString::IsDigitBool_t IsDigit() constReturns true if all characters in string are digits (0-9) or white spaces, i.e.Definition TString.cxx:1830; TString::ReplaceAllTString & ReplaceAll(const TString &s1, const TString &s2)Definition TString.h:704; TString::AppendTString & Append(const char *cs)Definition TString.h:",MatchSource.WIKI,doc/master/TGraph2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2D_8cxx_source.html
https://root.cern/doc/master/TGraph2D_8cxx_source.html:12079,Safety,avoid,avoid,12079,"rst();; 334 Int_t ylast = yaxis->GetLast();; 335 ; 336 ; 337 Double_t x, y, z;; 338 Int_t k = 0;; 339 ; 340 for (Int_t i = xfirst; i <= xlast; i++) {; 341 for (Int_t j = yfirst; j <= ylast; j++) {; 342 x = xaxis->GetBinCenter(i);; 343 y = yaxis->GetBinCenter(j);; 344 z = h2->GetBinContent(i, j);; 345 Double_t ez = h2->GetBinError(i, j);; 346 if (z != 0. || ez != 0) {; 347 SetPoint(k, x, y, z);; 348 k++;; 349 }; 350 }; 351 }; 352}; 353 ; 354 ; 355////////////////////////////////////////////////////////////////////////////////; 356/// Graph2D constructor with name, title and three vectors of doubles as input.; 357/// name : name of 2D graph (avoid blanks); 358/// title : 2D graph title; 359/// if title is of the form ""stringt;stringx;stringy;stringz""; 360/// the 2D graph title is set to stringt, the x axis title to stringx,; 361/// the y axis title to stringy,etc; 362 ; 363TGraph2D::TGraph2D(const char *name, const char *title,; 364 Int_t n, Double_t *x, Double_t *y, Double_t *z); 365 : TNamed(name, title), TAttLine(1, 1, 1), TAttFill(0, 1001), fNpoints(n); 366{; 367 Build(n);; 368 ; 369 // Copy the input vectors into local arrays; 370 for (Int_t i = 0; i < fNpoints; ++i) {; 371 fX[i] = x[i];; 372 fY[i] = y[i];; 373 fZ[i] = z[i];; 374 }; 375}; 376 ; 377 ; 378////////////////////////////////////////////////////////////////////////////////; 379/// Graph2D constructor. The arrays fX, fY and fZ should be filled via; 380/// calls to SetPoint; 381 ; 382TGraph2D::TGraph2D(Int_t n); 383 : TNamed(""Graph2D"", ""Graph2D""), TAttLine(1, 1, 1), TAttFill(0, 1001), fNpoints(n); 384{; 385 Build(n);; 386 for (Int_t i = 0; i < fNpoints; i++) {; 387 fX[i] = 0.;; 388 fY[i] = 0.;; 389 fZ[i] = 0.;; 390 }; 391}; 392 ; 393 ; 394////////////////////////////////////////////////////////////////////////////////; 395/// Graph2D constructor reading input from filename; 396/// filename is assumed to contain at least three columns of numbers.; 397/// For files separated by a specific delimiter differen",MatchSource.WIKI,doc/master/TGraph2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2D_8cxx_source.html
https://root.cern/doc/master/TGraph2D_8cxx_source.html:13492,Safety,avoid,avoid,13492,"; 368 ; 369 // Copy the input vectors into local arrays; 370 for (Int_t i = 0; i < fNpoints; ++i) {; 371 fX[i] = x[i];; 372 fY[i] = y[i];; 373 fZ[i] = z[i];; 374 }; 375}; 376 ; 377 ; 378////////////////////////////////////////////////////////////////////////////////; 379/// Graph2D constructor. The arrays fX, fY and fZ should be filled via; 380/// calls to SetPoint; 381 ; 382TGraph2D::TGraph2D(Int_t n); 383 : TNamed(""Graph2D"", ""Graph2D""), TAttLine(1, 1, 1), TAttFill(0, 1001), fNpoints(n); 384{; 385 Build(n);; 386 for (Int_t i = 0; i < fNpoints; i++) {; 387 fX[i] = 0.;; 388 fY[i] = 0.;; 389 fZ[i] = 0.;; 390 }; 391}; 392 ; 393 ; 394////////////////////////////////////////////////////////////////////////////////; 395/// Graph2D constructor reading input from filename; 396/// filename is assumed to contain at least three columns of numbers.; 397/// For files separated by a specific delimiter different from ' ' and '\\t' (e.g. ';' in csv files); 398/// you can avoid using %*s to bypass this delimiter by explicitly specify the ""option"" argument,; 399/// e.g. option="" \\t,;"" for columns of figures separated by any of these characters (' ', '\\t', ',', ';'); 400/// used once (e.g. ""1;1"") or in a combined way ("" 1;,;; 1"").; 401/// Note in that case, the instantiation is about 2 times slower.; 402 ; 403TGraph2D::TGraph2D(const char *filename, const char *format, Option_t *option); 404 : TNamed(""Graph2D"", filename), TAttLine(1, 1, 1), TAttFill(0, 1001), fNpoints(0); 405{; 406 Double_t x, y, z;; 407 TString fname = filename;; 408 gSystem->ExpandPathName(fname);; 409 ; 410 std::ifstream infile(fname.Data());; 411 if (!infile.good()) {; 412 MakeZombie();; 413 Error(""TGraph2D"", ""Cannot open file: %s, TGraph2D is Zombie"", filename);; 414 return;; 415 } else {; 416 Build(100);; 417 }; 418 std::string line;; 419 Int_t np = 0;; 420 ; 421 if (strcmp(option, """") == 0) { // No delimiters specified (standard constructor).; 422 ; 423 while (std::getline(infile, line, '\n')) {; 424 if (3 != ",MatchSource.WIKI,doc/master/TGraph2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2D_8cxx_source.html
https://root.cern/doc/master/TGraph2D_8cxx_source.html:35199,Safety,avoid,avoid,35199,"52 hxmax = xmax + fMargin * (xmax - xmin);; 1053 hymax = ymax + fMargin * (ymax - ymin);; 1054 Double_t epsilon = 1e-9;; 1055 if (TMath::AreEqualRel(hxmax,hxmin,epsilon)) {; 1056 if (TMath::Abs(hxmin) < epsilon) {; 1057 hxmin = -0.001;; 1058 hxmax = 0.001;; 1059 } else {; 1060 hxmin = hxmin-TMath::Abs(hxmin)*(epsilon/2.);; 1061 hxmax = hxmax+TMath::Abs(hxmax)*(epsilon/2.);; 1062 }; 1063 }; 1064 if (TMath::AreEqualRel(hymax, hymin, epsilon)) {; 1065 if (TMath::Abs(hymin) < epsilon) {; 1066 hymin = -0.001;; 1067 hymax = 0.001;; 1068 } else {; 1069 hymin = hymin-TMath::Abs(hymin)*(epsilon/2.);; 1070 hymax = hymax+TMath::Abs(hymax)*(epsilon/2.);; 1071 }; 1072 }; 1073 if (fHistogram) {; 1074 fHistogram->GetXaxis()->SetLimits(hxmin, hxmax);; 1075 fHistogram->GetYaxis()->SetLimits(hymin, hymax);; 1076 } else {; 1077 TDirectory::TContext ctx(nullptr); // to avoid adding fHistogram to gDirectory; 1078 fHistogram = new TH2D(GetName(), GetTitle(),; 1079 fNpx , hxmin, hxmax,; 1080 fNpy, hymin, hymax);; 1081 CreateInterpolator(oldInterp);; 1082 }; 1083 fHistogram->SetBit(TH1::kNoStats);; 1084 } else {; 1085 hxmin = fHistogram->GetXaxis()->GetXmin();; 1086 hymin = fHistogram->GetYaxis()->GetXmin();; 1087 hxmax = fHistogram->GetXaxis()->GetXmax();; 1088 hymax = fHistogram->GetYaxis()->GetXmax();; 1089 }; 1090 ; 1091 // Option ""empty"" is selected. An empty histogram is returned.; 1092 Double_t hzmax, hzmin;; 1093 if (empty) {; 1094 if (fMinimum != -1111) {; 1095 hzmin = fMinimum;; 1096 } else {; 1097 hzmin = GetZminE();; 1098 }; 1099 if (fMaximum != -1111) {; 1100 hzmax = fMaximum;; 1101 } else {; 1102 hzmax = GetZmaxE();; 1103 }; 1104 if (hzmin == hzmax) {; 1105 Double_t hz = hzmin;; 1106 if (hz==0) {; 1107 hzmin = -0.01;; 1108 hzmax = 0.01;; 1109 } else {; 1110 hzmin = hz - 0.01 * TMath::Abs(hz);; 1111 hzmax = hz + 0.01 * TMath::Abs(hz);; 1112 }; 1113 }; 1114 fHistogram->SetMinimum(hzmin);; 1115 fHistogram->SetMaximum(hzmax);; 1116 return fHistogram;; 1117 }; 1118 ; 1119 Double_t",MatchSource.WIKI,doc/master/TGraph2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2D_8cxx_source.html
https://root.cern/doc/master/TGraph2D_8cxx_source.html:5418,Security,access,accessed,5418,"s drawn with one of the 2D histogram drawing option,; 115an intermediate 2D histogram is filled using the Delaunay triangles; 116to interpolate the data set. The 2D histogram has equidistant bins along the X; 117and Y directions. The number of bins along each direction can be change using; 118`SetNpx()` and `SetNpy()`. Each bin is filled with the Z; 119value found via a linear interpolation on the plane defined by the triangle above; 120the (X,Y) coordinates of the bin center.; 121 ; 122The existing (X,Y,Z) points can be randomly scattered.; 123The Delaunay triangles are build in the (X,Y) plane. These 2D triangles are then; 124used to define flat planes in (X,Y,Z) over which the interpolation is done to fill; 125the 2D histogram. The 3D triangles int takes build a 3D surface in; 126the form of tessellating triangles at various angles. The triangles found can be; 127drawn in 3D with one of the TGraph2D specific drawing options.; 128 ; 129The histogram generated by the Delaunay interpolation can be accessed using the; 130`GetHistogram()` method.; 131 ; 132The axis settings (title, ranges etc ...) can be changed accessing the axis via; 133the GetXaxis GetYaxis and GetZaxis methods. They access the histogram axis created; 134at drawing time only. Therefore they should called after the TGraph2D is drawn:; 135 ; 136~~~ {.cpp}; 137 auto g = new TGraph2D();; 138 ; 139 [...]; 140 ; 141 g->Draw(""tri1"");; 142 gPad->Update();; 143 g->GetXaxis()->SetTitle(""X axis title"");; 144~~~; 145 ; 146\anchor G2D02; 147## Examples; 148 ; 149\anchor G2D021; 150### SURF1 Example; 151 ; 152Begin_Macro(source); 153{; 154 auto c = new TCanvas(""c"",""Graph2D example"",0,0,600,400);; 155 Double_t x, y, z, P = 6.;; 156 Int_t np = 200;; 157 auto dt = new TGraph2D();; 158 dt->SetTitle(""Graph title; X axis title; Y axis title; Z axis title"");; 159 auto r = new TRandom();; 160 for (Int_t N=0; N<np; N++) {; 161 x = 2*P*(r->Rndm(N))-P;; 162 y = 2*P*(r->Rndm(N))-P;; 163 z = (sin(x)/x)*(sin(y)/y)+0.2;; 164 dt",MatchSource.WIKI,doc/master/TGraph2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2D_8cxx_source.html
https://root.cern/doc/master/TGraph2D_8cxx_source.html:5533,Security,access,accessing,5533,"et. The 2D histogram has equidistant bins along the X; 117and Y directions. The number of bins along each direction can be change using; 118`SetNpx()` and `SetNpy()`. Each bin is filled with the Z; 119value found via a linear interpolation on the plane defined by the triangle above; 120the (X,Y) coordinates of the bin center.; 121 ; 122The existing (X,Y,Z) points can be randomly scattered.; 123The Delaunay triangles are build in the (X,Y) plane. These 2D triangles are then; 124used to define flat planes in (X,Y,Z) over which the interpolation is done to fill; 125the 2D histogram. The 3D triangles int takes build a 3D surface in; 126the form of tessellating triangles at various angles. The triangles found can be; 127drawn in 3D with one of the TGraph2D specific drawing options.; 128 ; 129The histogram generated by the Delaunay interpolation can be accessed using the; 130`GetHistogram()` method.; 131 ; 132The axis settings (title, ranges etc ...) can be changed accessing the axis via; 133the GetXaxis GetYaxis and GetZaxis methods. They access the histogram axis created; 134at drawing time only. Therefore they should called after the TGraph2D is drawn:; 135 ; 136~~~ {.cpp}; 137 auto g = new TGraph2D();; 138 ; 139 [...]; 140 ; 141 g->Draw(""tri1"");; 142 gPad->Update();; 143 g->GetXaxis()->SetTitle(""X axis title"");; 144~~~; 145 ; 146\anchor G2D02; 147## Examples; 148 ; 149\anchor G2D021; 150### SURF1 Example; 151 ; 152Begin_Macro(source); 153{; 154 auto c = new TCanvas(""c"",""Graph2D example"",0,0,600,400);; 155 Double_t x, y, z, P = 6.;; 156 Int_t np = 200;; 157 auto dt = new TGraph2D();; 158 dt->SetTitle(""Graph title; X axis title; Y axis title; Z axis title"");; 159 auto r = new TRandom();; 160 for (Int_t N=0; N<np; N++) {; 161 x = 2*P*(r->Rndm(N))-P;; 162 y = 2*P*(r->Rndm(N))-P;; 163 z = (sin(x)/x)*(sin(y)/y)+0.2;; 164 dt->SetPoint(N,x,y,z);; 165 }; 166 gStyle->SetPalette(1);; 167 dt->Draw(""surf1"");; 168}; 169End_Macro; 170 ; 171\anchor G2D022; 172### Fitting Example; 173 ",MatchSource.WIKI,doc/master/TGraph2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2D_8cxx_source.html
https://root.cern/doc/master/TGraph2D_8cxx_source.html:5609,Security,access,access,5609,"The number of bins along each direction can be change using; 118`SetNpx()` and `SetNpy()`. Each bin is filled with the Z; 119value found via a linear interpolation on the plane defined by the triangle above; 120the (X,Y) coordinates of the bin center.; 121 ; 122The existing (X,Y,Z) points can be randomly scattered.; 123The Delaunay triangles are build in the (X,Y) plane. These 2D triangles are then; 124used to define flat planes in (X,Y,Z) over which the interpolation is done to fill; 125the 2D histogram. The 3D triangles int takes build a 3D surface in; 126the form of tessellating triangles at various angles. The triangles found can be; 127drawn in 3D with one of the TGraph2D specific drawing options.; 128 ; 129The histogram generated by the Delaunay interpolation can be accessed using the; 130`GetHistogram()` method.; 131 ; 132The axis settings (title, ranges etc ...) can be changed accessing the axis via; 133the GetXaxis GetYaxis and GetZaxis methods. They access the histogram axis created; 134at drawing time only. Therefore they should called after the TGraph2D is drawn:; 135 ; 136~~~ {.cpp}; 137 auto g = new TGraph2D();; 138 ; 139 [...]; 140 ; 141 g->Draw(""tri1"");; 142 gPad->Update();; 143 g->GetXaxis()->SetTitle(""X axis title"");; 144~~~; 145 ; 146\anchor G2D02; 147## Examples; 148 ; 149\anchor G2D021; 150### SURF1 Example; 151 ; 152Begin_Macro(source); 153{; 154 auto c = new TCanvas(""c"",""Graph2D example"",0,0,600,400);; 155 Double_t x, y, z, P = 6.;; 156 Int_t np = 200;; 157 auto dt = new TGraph2D();; 158 dt->SetTitle(""Graph title; X axis title; Y axis title; Z axis title"");; 159 auto r = new TRandom();; 160 for (Int_t N=0; N<np; N++) {; 161 x = 2*P*(r->Rndm(N))-P;; 162 y = 2*P*(r->Rndm(N))-P;; 163 z = (sin(x)/x)*(sin(y)/y)+0.2;; 164 dt->SetPoint(N,x,y,z);; 165 }; 166 gStyle->SetPalette(1);; 167 dt->Draw(""surf1"");; 168}; 169End_Macro; 170 ; 171\anchor G2D022; 172### Fitting Example; 173 ; 1742D graphs can be fitted as shown by the following example:; 175 ; 176Be",MatchSource.WIKI,doc/master/TGraph2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2D_8cxx_source.html
https://root.cern/doc/master/TGraph2D_8cxx_source.html:52579,Security,hash,hashlist,52579,"//////////////////////////////; 1617/// Set maximum.; 1618 ; 1619void TGraph2D::SetMaximum(Double_t maximum); 1620{; 1621 fMaximum = maximum;; 1622 TH1 * h = GetHistogram();; 1623 if (h) h->SetMaximum(maximum);; 1624}; 1625 ; 1626 ; 1627////////////////////////////////////////////////////////////////////////////////; 1628/// Set minimum.; 1629 ; 1630void TGraph2D::SetMinimum(Double_t minimum); 1631{; 1632 fMinimum = minimum;; 1633 TH1 * h = GetHistogram();; 1634 if (h) h->SetMinimum(minimum);; 1635}; 1636 ; 1637 ; 1638////////////////////////////////////////////////////////////////////////////////; 1639/// Changes the name of this 2D graph; 1640 ; 1641void TGraph2D::SetName(const char *name); 1642{; 1643 // 2D graphs are named objects in a THashList.; 1644 // We must update the hashlist if we change the name; 1645 if (fDirectory) fDirectory->Remove(this);; 1646 fName = name;; 1647 if (fDirectory) fDirectory->Append(this);; 1648}; 1649 ; 1650 ; 1651////////////////////////////////////////////////////////////////////////////////; 1652/// Change the name and title of this 2D graph; 1653///; 1654 ; 1655void TGraph2D::SetNameTitle(const char *name, const char *title); 1656{; 1657 // 2D graphs are named objects in a THashList.; 1658 // We must update the hashlist if we change the name; 1659 if (fDirectory) fDirectory->Remove(this);; 1660 fName = name;; 1661 SetTitle(title);; 1662 if (fDirectory) fDirectory->Append(this);; 1663}; 1664 ; 1665 ; 1666////////////////////////////////////////////////////////////////////////////////; 1667/// Sets the number of bins along X used to draw the function; 1668 ; 1669void TGraph2D::SetNpx(Int_t npx); 1670{; 1671 if (npx < 4) {; 1672 Warning(""SetNpx"", ""Number of points must be >4 && < 500, fNpx set to 4"");; 1673 fNpx = 4;; 1674 } else if (npx > 500) {; 1675 Warning(""SetNpx"", ""Number of points must be >4 && < 500, fNpx set to 500"");; 1676 fNpx = 500;; 1677 } else {; 1678 fNpx = npx;; 1679 }; 1680 if (fHistogram) {; 1681 delete fHistogram",MatchSource.WIKI,doc/master/TGraph2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2D_8cxx_source.html
https://root.cern/doc/master/TGraph2D_8cxx_source.html:53059,Security,hash,hashlist,53059,"/////////; 1652/// Change the name and title of this 2D graph; 1653///; 1654 ; 1655void TGraph2D::SetNameTitle(const char *name, const char *title); 1656{; 1657 // 2D graphs are named objects in a THashList.; 1658 // We must update the hashlist if we change the name; 1659 if (fDirectory) fDirectory->Remove(this);; 1660 fName = name;; 1661 SetTitle(title);; 1662 if (fDirectory) fDirectory->Append(this);; 1663}; 1664 ; 1665 ; 1666////////////////////////////////////////////////////////////////////////////////; 1667/// Sets the number of bins along X used to draw the function; 1668 ; 1669void TGraph2D::SetNpx(Int_t npx); 1670{; 1671 if (npx < 4) {; 1672 Warning(""SetNpx"", ""Number of points must be >4 && < 500, fNpx set to 4"");; 1673 fNpx = 4;; 1674 } else if (npx > 500) {; 1675 Warning(""SetNpx"", ""Number of points must be >4 && < 500, fNpx set to 500"");; 1676 fNpx = 500;; 1677 } else {; 1678 fNpx = npx;; 1679 }; 1680 if (fHistogram) {; 1681 delete fHistogram;; 1682 fHistogram = nullptr;; 1683 fDelaunay = nullptr;; 1684 }; 1685}; 1686 ; 1687 ; 1688////////////////////////////////////////////////////////////////////////////////; 1689/// Sets the number of bins along Y used to draw the function; 1690 ; 1691void TGraph2D::SetNpy(Int_t npy); 1692{; 1693 if (npy < 4) {; 1694 Warning(""SetNpy"", ""Number of points must be >4 && < 500, fNpy set to 4"");; 1695 fNpy = 4;; 1696 } else if (npy > 500) {; 1697 Warning(""SetNpy"", ""Number of points must be >4 && < 500, fNpy set to 500"");; 1698 fNpy = 500;; 1699 } else {; 1700 fNpy = npy;; 1701 }; 1702 if (fHistogram) {; 1703 delete fHistogram;; 1704 fHistogram = nullptr;; 1705 fDelaunay = nullptr;; 1706 }; 1707}; 1708 ; 1709 ; 1710////////////////////////////////////////////////////////////////////////////////; 1711/// Sets point number n.; 1712/// If n is greater than the current size, the arrays are automatically; 1713/// extended.; 1714 ; 1715void TGraph2D::SetPoint(Int_t n, Double_t x, Double_t y, Double_t z); 1716{; 1717 if (n < 0) retur",MatchSource.WIKI,doc/master/TGraph2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2D_8cxx_source.html
https://root.cern/doc/master/TGraph2D_8cxx_source.html:40717,Testability,assert,assert,40717,"22 if (!fX || !fY || !fZ) return -1;; 1223 x = fX[i];; 1224 y = fY[i];; 1225 z = fZ[i];; 1226 return i;; 1227}; 1228 ; 1229////////////////////////////////////////////////////////////////////////////////; 1230/// Finds the z value at the position (x,y) thanks to; 1231/// the Delaunay interpolation.; 1232 ; 1233Double_t TGraph2D::Interpolate(Double_t x, Double_t y); 1234{; 1235 if (fNpoints <= 0) {; 1236 Error(""Interpolate"", ""Empty TGraph2D"");; 1237 return 0;; 1238 }; 1239 ; 1240 if (!fHistogram) GetHistogram(""empty"");; 1241 if (!fDelaunay) {; 1242 TList *hl = fHistogram->GetListOfFunctions();; 1243 if (!TestBit(kOldInterpolation) ) {; 1244 fDelaunay = hl->FindObject(""TGraphDelaunay2D"");; 1245 if (!fDelaunay) fDelaunay = hl->FindObject(""TGraphDelaunay"");; 1246 }; 1247 else {; 1248 // if using old implementation; 1249 fDelaunay = hl->FindObject(""TGraphDelaunay"");; 1250 if (!fDelaunay) fDelaunay = hl->FindObject(""TGraphDelaunay2D"");; 1251 }; 1252 }; 1253 ; 1254 if (!fDelaunay) return TMath::QuietNaN();; 1255 ; 1256 if (fDelaunay->IsA() == TGraphDelaunay2D::Class() ); 1257 return ((TGraphDelaunay2D*)fDelaunay)->ComputeZ(x, y);; 1258 else if (fDelaunay->IsA() == TGraphDelaunay::Class() ); 1259 return ((TGraphDelaunay*)fDelaunay)->ComputeZ(x, y);; 1260 ; 1261 // cannot be here; 1262 assert(false);; 1263 return TMath::QuietNaN();; 1264}; 1265 ; 1266 ; 1267////////////////////////////////////////////////////////////////////////////////; 1268/// Paints this 2D graph with its current attributes; 1269 ; 1270void TGraph2D::Paint(Option_t *option); 1271{; 1272 if (fNpoints <= 0) {; 1273 Error(""Paint"", ""Empty TGraph2D"");; 1274 return;; 1275 }; 1276 ; 1277 TString opt = option;; 1278 opt.ToLower();; 1279 if (opt.Contains(""p"") && !opt.Contains(""tri"")) {; 1280 if (!opt.Contains(""pol"") &&; 1281 !opt.Contains(""sph"") &&; 1282 !opt.Contains(""psr"")) opt.Append(""tri0"");; 1283 }; 1284 ; 1285 if (opt.Contains(""line"") && !opt.Contains(""tri"")) opt.Append(""tri0"");; 1286 ; 1287 if (opt.Contains(",MatchSource.WIKI,doc/master/TGraph2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2D_8cxx_source.html
https://root.cern/doc/master/TGraph2D_8cxx_source.html:75239,Testability,test,tested,75239,"ph2D::GetXaxisTAxis * GetXaxis() constGet x axis of the graph.Definition TGraph2D.cxx:885; TGraph2D::GetZDouble_t * GetZ() constDefinition TGraph2D.h:125; TGraph2D::SetNpxvoid SetNpx(Int_t npx=40)Sets the number of bins along X used to draw the function.Definition TGraph2D.cxx:1669; TGraphDelaunay2DTGraphDelaunay2D generates a Delaunay triangulation of a TGraph2D.Definition TGraphDelaunay2D.h:32; TGraphDelaunay2D::Classstatic TClass * Class(); TGraphDelaunay2D::SetMarginBinsContentvoid SetMarginBinsContent(Double_t z=0.)Definition TGraphDelaunay2D.h:63; TGraphDelaunayTGraphDelaunay generates a Delaunay triangulation of a TGraph2D.Definition TGraphDelaunay.h:30; TGraphDelaunay::Classstatic TClass * Class(); TGraphDelaunay::SetMarginBinsContentvoid SetMarginBinsContent(Double_t z=0.)Sets the histogram bin height for points lying outside the convex hull ie: the bins in the margin.Definition TGraphDelaunay.cxx:943; TGraphDelaunay::SetMaxItervoid SetMaxIter(Int_t n=100000)Defines the number of triangles tested for a Delaunay triangle (number of iterations) before abandoni...Definition TGraphDelaunay.cxx:932; TH1D1-D histogram with a double per channel (see TH1 documentation)Definition TH1.h:670; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::GetZaxisTAxis * GetZaxis()Definition TH1.h:326; TH1::DistancetoPrimitiveInt_t DistancetoPrimitive(Int_t px, Int_t py) overrideCompute distance from point px,py to a line.Definition TH1.cxx:2823; TH1::SetTitlevoid SetTitle(const char *title) overrideChange/set the title.Definition TH1.cxx:6718; TH1::kNoStats@ kNoStatsDon't draw stats box.Definition TH1.h:165; TH1::GetXaxisTAxis * GetXaxis()Definition TH1.h:324; TH1::GetPainterTVirtualHistPainter * GetPainter(Option_t *option="""")Return pointer to painter.Definition TH1.cxx:4511; TH1::GetMaximumvirtual Double_t GetMaximum(Double_t maxval=FLT_MAX) constReturn maximum value smaller than maxval of bins in the range, unless the value has been overridden ",MatchSource.WIKI,doc/master/TGraph2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2D_8cxx_source.html
https://root.cern/doc/master/TGraph2D_8h.html:295,Integrability,depend,dependency,295,". ROOT: hist/hist/inc/TGraph2D.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; TGraph2D.h File Reference. #include ""TNamed.h""; #include ""TAttLine.h""; #include ""TAttFill.h""; #include ""TAttMarker.h""; #include ""TFitResultPtr.h"". Include dependency graph for TGraph2D.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  TGraph2D;  Graphics object made of three arrays X, Y and Z with the same number of points each. More...;  . histhistincTGraph2D.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:20 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TGraph2D_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2D_8h.html
https://root.cern/doc/master/TGraph2D_8h_source.html:18431,Energy Efficiency,allocate,allocated,18431,"ts the histogram to be filled.Definition TGraph2D.cxx:1568; TGraph2D::SetMaximumvoid SetMaximum(Double_t maximum=-1111)Set maximum.Definition TGraph2D.cxx:1619; TGraph2D::GetEXlowvirtual Double_t * GetEXlow() constDefinition TGraph2D.h:129; TGraph2D::Addvirtual void Add(TF2 *f, Double_t c1=1)Performs the operation: z = z + c1*f(x,y,z) Errors are not recalculated.Definition TGraph2D.cxx:642; TGraph2D::GetYmaxDouble_t GetYmax() constReturns the Y maximum.Definition TGraph2D.cxx:1175; TGraph2D::DistancetoPrimitiveInt_t DistancetoPrimitive(Int_t px, Int_t py) overrideComputes distance from point px,py to a graph.Definition TGraph2D.cxx:730; TGraph2D::SetDirectoryvirtual void SetDirectory(TDirectory *dir)By default when an 2D graph is created, it is added to the list of 2D graph objects in the current di...Definition TGraph2D.cxx:1544; TGraph2D::fDirectoryTDirectory * fDirectory!Pointer to directory holding this 2D graphDefinition TGraph2D.h:60; TGraph2D::Clearvoid Clear(Option_t *option="""") overrideFree all memory allocated by this object.Definition TGraph2D.cxx:681; TGraph2D::Scalevirtual void Scale(Double_t c1=1., Option_t *option=""z"")Multiply the values of a TGraph2D by a constant c1.Definition TGraph2D.cxx:1506; TGraph2D::GetEXvirtual Double_t * GetEX() constDefinition TGraph2D.h:126; TGraph2D::DirectoryAutoAddvirtual void DirectoryAutoAdd(TDirectory *)Perform the automatic addition of the graph to the given directory.Definition TGraph2D.cxx:715; TGraph2D::CreateInterpolatorvoid CreateInterpolator(Bool_t oldInterp)Add a TGraphDelaunay in the list of the fHistogram's functions.Definition TGraph2D.cxx:968; TGraph2D::GetNpyInt_t GetNpy() constDefinition TGraph2D.h:110; TGraph2D::GetDirectoryTDirectory * GetDirectory() constDefinition TGraph2D.h:108; TGraph2D::fNpyInt_t fNpyNumber of bins along Y in fHistogram.Definition TGraph2D.h:47; TGraph2D::AddPointvirtual void AddPoint(Double_t x, Double_t y, Double_t z)Append a new point to the graph.Definition TGraph2D.h:93; TGr",MatchSource.WIKI,doc/master/TGraph2D_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2D_8h_source.html
https://root.cern/doc/master/TGraph2D_8h_source.html:16586,Integrability,depend,depending,16586,"(Double_t contour)Returns the X and Y graphs building a contour.Definition TGraph2D.cxx:920; TGraph2D::GetXmaxDouble_t GetXmax() constReturns the X maximum.Definition TGraph2D.cxx:1153; TGraph2D::GetPointvirtual Int_t GetPoint(Int_t i, Double_t &x, Double_t &y, Double_t &z) constGet x, y and z values for point number i.Definition TGraph2D.cxx:1219; TGraph2D::GetYaxisTAxis * GetYaxis() constGet y axis of the graph.Definition TGraph2D.cxx:896; TGraph2D::GetEYhighvirtual Double_t * GetEYhigh() constDefinition TGraph2D.h:132; TGraph2D::GetErrorYvirtual Double_t GetErrorY(Int_t bin) constThis function is called by Graph2DFitChisquare.Definition TGraph2D.cxx:949; TGraph2D::GetEYvirtual Double_t * GetEY() constDefinition TGraph2D.h:127; TGraph2D::GetListOfFunctionsTList * GetListOfFunctions() constDefinition TGraph2D.h:112; TGraph2D::fDelaunayTObject * fDelaunay! Pointer to Delaunay interpolator objectDefinition TGraph2D.h:59; TGraph2D::ProjectTH1 * Project(Option_t *option=""x"") constProjects a 2-d graph into 1 or 2-d histograms depending on the option parameter.Definition TGraph2D.cxx:1329; TGraph2D::GetNInt_t GetN() constDefinition TGraph2D.h:122; TGraph2D::GetXmaxEvirtual Double_t GetXmaxE() constDefinition TGraph2D.h:141; TGraph2D::Setvirtual void Set(Int_t n)Set number of points in the 2D graph.Definition TGraph2D.cxx:1528; TGraph2D::SetMinimumvoid SetMinimum(Double_t minimum=-1111)Set minimum.Definition TGraph2D.cxx:1630; TGraph2D::operator=TGraph2D & operator=(const TGraph2D &)Graph2D operator ""="".Definition TGraph2D.cxx:557; TGraph2D::GetEXhighvirtual Double_t * GetEXhigh() constDefinition TGraph2D.h:130; TGraph2D::fXDouble_t * fX[fNpoints]Definition TGraph2D.h:50; TGraph2D::fYDouble_t * fY[fNpoints] Data set to be plottedDefinition TGraph2D.h:51; TGraph2D::SetHistogramvirtual void SetHistogram(TH2 *h, Option_t *option="""")Sets the histogram to be filled.Definition TGraph2D.cxx:1568; TGraph2D::SetMaximumvoid SetMaximum(Double_t maximum=-1111)Set maximum.Definition T",MatchSource.WIKI,doc/master/TGraph2D_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2D_8h_source.html
https://root.cern/doc/master/TGraph2D_8h_source.html:21233,Integrability,interface,interface,21233,"raph with its current attributes.Definition TGraph2D.cxx:1270; TGraph2D::GetEZlowvirtual Double_t * GetEZlow() constDefinition TGraph2D.h:133; TGraph2D::GetNpxInt_t GetNpx() constDefinition TGraph2D.h:109; TGraph2D::ExecuteEventvoid ExecuteEvent(Int_t event, Int_t px, Int_t py) overrideExecutes action corresponding to one event.Definition TGraph2D.cxx:782; TGraph2D::fSizeInt_t fSize!Real size of fX, fY and fZDefinition TGraph2D.h:49; TGraph2D::SetMaxItervoid SetMaxIter(Int_t n=100000)Definition TGraph2D.h:162; TGraph2D::EStatusBitsEStatusBitsDefinition TGraph2D.h:69; TGraph2D::kOldInterpolation@ kOldInterpolationDefinition TGraph2D.h:70; TGraph2D::GetXaxisTAxis * GetXaxis() constGet x axis of the graph.Definition TGraph2D.cxx:885; TGraph2D::GetEYlowvirtual Double_t * GetEYlow() constDefinition TGraph2D.h:131; TGraph2D::GetZDouble_t * GetZ() constDefinition TGraph2D.h:125; TGraph2D::SetNpxvoid SetNpx(Int_t npx=40)Sets the number of bins along X used to draw the function.Definition TGraph2D.cxx:1669; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH2D2-D histogram with a double per channel (see TH1 documentation)Definition TH2.h:357; TH2Service class for 2-D histogram classes.Definition TH2.h:30; TListA doubly linked list.Definition TList.h:38; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TObjectMother of all ROOT objects.Definition TObject.h:41; TViewSee TView3D.Definition TView.h:25; TVirtualHistPainterAbstract interface to a histogram painter.Definition TVirtualHistPainter.h:30; bool; double; int; Interpolate#define Interpolate(a, x, b, y)Definition geom.c:179; yDouble_t y[n]Definition legend1.C:17; c1return c1Definition legend1.C:41; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; Drawth1 Draw(); mTMarker mDefinition textangle.C:8. histhistincTGraph2D.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TGraph2D_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2D_8h_source.html
https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html:1222,Availability,error,error,1222,"o Matches. TGraphAsymmErrors.cxx. Go to the documentation of this file. 1// @(#)root/hist:$Id$; 2// Author: Rene Brun 03/03/99; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12 ; 13#include ""TEfficiency.h""; 14#include ""TROOT.h""; 15#include ""TBuffer.h""; 16#include ""TGraphAsymmErrors.h""; 17#include ""TGraphErrors.h""; 18#include ""TStyle.h""; 19#include ""TMath.h""; 20#include ""TVirtualPad.h""; 21#include ""TF1.h""; 22#include ""TH1.h""; 23#include ""TVector.h""; 24#include ""TVectorD.h""; 25#include ""TSystem.h""; 26#include ""Math/QuantFuncMathCore.h""; 27#include ""strtok.h""; 28 ; 29#include <cstring>; 30#include <iostream>; 31#include <fstream>; 32 ; 33 ; 34ClassImp(TGraphAsymmErrors);; 35 ; 36/** \class TGraphAsymmErrors; 37 \ingroup Graphs; 38TGraph with asymmetric error bars.; 39 ; 40The TGraphAsymmErrors painting is performed thanks to the TGraphPainter; 41class. All details about the various painting options are given in this class.; 42 ; 43The picture below gives an example:; 44 ; 45Begin_Macro(source); 46{; 47 auto c1 = new TCanvas(""c1"",""A Simple Graph with asymmetric error bars"",200,10,700,500);; 48 c1->SetFillColor(42);; 49 c1->SetGrid();; 50 c1->GetFrame()->SetFillColor(21);; 51 c1->GetFrame()->SetBorderSize(12);; 52 const Int_t n = 10;; 53 Double_t x[n] = {-0.22, 0.05, 0.25, 0.35, 0.5, 0.61,0.7,0.85,0.89,0.95};; 54 Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; 55 Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; 56 Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; 57 Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; 58 Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.4,.5,.6};; 59 auto gr = new TGraphAsymmErrors(n,x,y,ex",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html
https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html:1536,Availability,error,error,1536,"***************************************************************/; 11 ; 12 ; 13#include ""TEfficiency.h""; 14#include ""TROOT.h""; 15#include ""TBuffer.h""; 16#include ""TGraphAsymmErrors.h""; 17#include ""TGraphErrors.h""; 18#include ""TStyle.h""; 19#include ""TMath.h""; 20#include ""TVirtualPad.h""; 21#include ""TF1.h""; 22#include ""TH1.h""; 23#include ""TVector.h""; 24#include ""TVectorD.h""; 25#include ""TSystem.h""; 26#include ""Math/QuantFuncMathCore.h""; 27#include ""strtok.h""; 28 ; 29#include <cstring>; 30#include <iostream>; 31#include <fstream>; 32 ; 33 ; 34ClassImp(TGraphAsymmErrors);; 35 ; 36/** \class TGraphAsymmErrors; 37 \ingroup Graphs; 38TGraph with asymmetric error bars.; 39 ; 40The TGraphAsymmErrors painting is performed thanks to the TGraphPainter; 41class. All details about the various painting options are given in this class.; 42 ; 43The picture below gives an example:; 44 ; 45Begin_Macro(source); 46{; 47 auto c1 = new TCanvas(""c1"",""A Simple Graph with asymmetric error bars"",200,10,700,500);; 48 c1->SetFillColor(42);; 49 c1->SetGrid();; 50 c1->GetFrame()->SetFillColor(21);; 51 c1->GetFrame()->SetBorderSize(12);; 52 const Int_t n = 10;; 53 Double_t x[n] = {-0.22, 0.05, 0.25, 0.35, 0.5, 0.61,0.7,0.85,0.89,0.95};; 54 Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; 55 Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; 56 Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; 57 Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; 58 Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.4,.5,.6};; 59 auto gr = new TGraphAsymmErrors(n,x,y,exl,exh,eyl,eyh);; 60 gr->SetTitle(""TGraphAsymmErrors Example"");; 61 gr->SetMarkerColor(4);; 62 gr->SetMarkerStyle(21);; 63 gr->Draw(""ALP"");; 64}; 65End_Macro; 66*/; 67 ; 68 ; 69////////////////////////////////////////////////////////////////////////////////; 70/// TGraphAsymmErrors default constructor.; 71 ; 72TGraphAsymmErrors::TGraphAsymmErrors() {}; 73 ; 74 ; 75///////////////////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html
https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html:5825,Availability,error,errors,5825,"t_t *eyh); 133 : TGraph(n,x,y); 134{; 135 if (!CtorAllocate()) return;; 136 ; 137 for (Int_t i=0;i<n;i++) {; 138 if (exl) fEXlow[i] = exl[i];; 139 else fEXlow[i] = 0;; 140 if (exh) fEXhigh[i] = exh[i];; 141 else fEXhigh[i] = 0;; 142 if (eyl) fEYlow[i] = eyl[i];; 143 else fEYlow[i] = 0;; 144 if (eyh) fEYhigh[i] = eyh[i];; 145 else fEYhigh[i] = 0;; 146 }; 147}; 148 ; 149 ; 150////////////////////////////////////////////////////////////////////////////////; 151/// TGraphAsymmErrors normal constructor.; 152///; 153/// if exl,h or eyl,h are null, the corresponding arrays are preset to zero; 154 ; 155TGraphAsymmErrors::TGraphAsymmErrors(Int_t n, const Double_t *x, const Double_t *y, const Double_t *exl, const Double_t *exh, const Double_t *eyl, const Double_t *eyh); 156 : TGraph(n,x,y); 157{; 158 if (!CtorAllocate()) return;; 159 ; 160 n = fNpoints*sizeof(Double_t);; 161 if (exl); 162 memcpy(fEXlow, exl, n);; 163 else; 164 memset(fEXlow, 0, n);; 165 if (exh); 166 memcpy(fEXhigh, exh, n);; 167 else; 168 memset(fEXhigh, 0, n);; 169 if (eyl); 170 memcpy(fEYlow, eyl, n);; 171 else; 172 memset(fEYlow, 0, n);; 173 if (eyh); 174 memcpy(fEYhigh, eyh, n);; 175 else; 176 memset(fEYhigh, 0, n);; 177}; 178 ; 179 ; 180////////////////////////////////////////////////////////////////////////////////; 181/// Constructor with six vectors of floats in input; 182/// A grapherrors is built with the X coordinates taken from vx and Y coord from vy; 183/// and the errors from vectors vexl/h and veyl/h.; 184/// The number of points in the graph is the minimum of number of points; 185/// in vx and vy.; 186 ; 187TGraphAsymmErrors::TGraphAsymmErrors(const TVectorF &vx, const TVectorF &vy, const TVectorF &vexl, const TVectorF &vexh, const TVectorF &veyl, const TVectorF &veyh); 188{; 189 fNpoints = TMath::Min(vx.GetNrows(), vy.GetNrows());; 190 if (!TGraph::CtorAllocate()) return;; 191 if (!CtorAllocate()) return;; 192 Int_t ivxlow = vx.GetLwb();; 193 Int_t ivylow = vy.GetLwb();; 194 Int_t ivexllow = ",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html
https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html:6997,Availability,error,errors,6997,"he X coordinates taken from vx and Y coord from vy; 183/// and the errors from vectors vexl/h and veyl/h.; 184/// The number of points in the graph is the minimum of number of points; 185/// in vx and vy.; 186 ; 187TGraphAsymmErrors::TGraphAsymmErrors(const TVectorF &vx, const TVectorF &vy, const TVectorF &vexl, const TVectorF &vexh, const TVectorF &veyl, const TVectorF &veyh); 188{; 189 fNpoints = TMath::Min(vx.GetNrows(), vy.GetNrows());; 190 if (!TGraph::CtorAllocate()) return;; 191 if (!CtorAllocate()) return;; 192 Int_t ivxlow = vx.GetLwb();; 193 Int_t ivylow = vy.GetLwb();; 194 Int_t ivexllow = vexl.GetLwb();; 195 Int_t ivexhlow = vexh.GetLwb();; 196 Int_t iveyllow = veyl.GetLwb();; 197 Int_t iveyhlow = veyh.GetLwb();; 198 for (Int_t i=0;i<fNpoints;i++) {; 199 fX[i] = vx(i+ivxlow);; 200 fY[i] = vy(i+ivylow);; 201 fEXlow[i] = vexl(i+ivexllow);; 202 fEYlow[i] = veyl(i+iveyllow);; 203 fEXhigh[i] = vexh(i+ivexhlow);; 204 fEYhigh[i] = veyh(i+iveyhlow);; 205 }; 206}; 207 ; 208 ; 209////////////////////////////////////////////////////////////////////////////////; 210/// Constructor with six vectors of doubles in input; 211/// A grapherrors is built with the X coordinates taken from vx and Y coord from vy; 212/// and the errors from vectors vexl/h and veyl/h.; 213/// The number of points in the graph is the minimum of number of points; 214/// in vx and vy.; 215 ; 216TGraphAsymmErrors::TGraphAsymmErrors(const TVectorD &vx, const TVectorD &vy, const TVectorD &vexl, const TVectorD &vexh, const TVectorD &veyl, const TVectorD &veyh); 217{; 218 fNpoints = TMath::Min(vx.GetNrows(), vy.GetNrows());; 219 if (!TGraph::CtorAllocate()) return;; 220 if (!CtorAllocate()) return;; 221 Int_t ivxlow = vx.GetLwb();; 222 Int_t ivylow = vy.GetLwb();; 223 Int_t ivexllow = vexl.GetLwb();; 224 Int_t ivexhlow = vexh.GetLwb();; 225 Int_t iveyllow = veyl.GetLwb();; 226 Int_t iveyhlow = veyh.GetLwb();; 227 for (Int_t i=0;i<fNpoints;i++) {; 228 fX[i] = vx(i+ivxlow);; 229 fY[i] = vy(i+ivylow);; 23",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html
https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html:8135,Availability,error,errors,8135,"uilt with the X coordinates taken from vx and Y coord from vy; 212/// and the errors from vectors vexl/h and veyl/h.; 213/// The number of points in the graph is the minimum of number of points; 214/// in vx and vy.; 215 ; 216TGraphAsymmErrors::TGraphAsymmErrors(const TVectorD &vx, const TVectorD &vy, const TVectorD &vexl, const TVectorD &vexh, const TVectorD &veyl, const TVectorD &veyh); 217{; 218 fNpoints = TMath::Min(vx.GetNrows(), vy.GetNrows());; 219 if (!TGraph::CtorAllocate()) return;; 220 if (!CtorAllocate()) return;; 221 Int_t ivxlow = vx.GetLwb();; 222 Int_t ivylow = vy.GetLwb();; 223 Int_t ivexllow = vexl.GetLwb();; 224 Int_t ivexhlow = vexh.GetLwb();; 225 Int_t iveyllow = veyl.GetLwb();; 226 Int_t iveyhlow = veyh.GetLwb();; 227 for (Int_t i=0;i<fNpoints;i++) {; 228 fX[i] = vx(i+ivxlow);; 229 fY[i] = vy(i+ivylow);; 230 fEXlow[i] = vexl(i+ivexllow);; 231 fEYlow[i] = veyl(i+iveyllow);; 232 fEXhigh[i] = vexh(i+ivexhlow);; 233 fEYhigh[i] = veyh(i+iveyhlow);; 234 }; 235}; 236 ; 237 ; 238////////////////////////////////////////////////////////////////////////////////; 239/// TGraphAsymmErrors constructor importing its parameters from the TH1 object passed as argument; 240/// the low and high errors are set to the bin error of the histogram.; 241 ; 242TGraphAsymmErrors::TGraphAsymmErrors(const TH1 *h); 243 : TGraph(h); 244{; 245 if (!CtorAllocate()) return;; 246 ; 247 for (Int_t i = 0; i < fNpoints; i++) {; 248 fEXlow[i] = h->GetBinWidth(i+1)*gStyle->GetErrorX();; 249 fEXhigh[i] = fEXlow[i];; 250 fEYlow[i] = h->GetBinErrorLow(i+1);; 251 fEYhigh[i] = h->GetBinErrorUp(i+1);; 252 }; 253}; 254 ; 255 ; 256////////////////////////////////////////////////////////////////////////////////; 257/// Creates a TGraphAsymmErrors by dividing two input TH1 histograms:; 258/// pass/total. (see TGraphAsymmErrors::Divide); 259 ; 260TGraphAsymmErrors::TGraphAsymmErrors(const TH1* pass, const TH1* total, Option_t *option); 261 : TGraph((pass)?pass->GetNbinsX():0); 262{; 263 if (!pas",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html
https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html:8161,Availability,error,error,8161,"uilt with the X coordinates taken from vx and Y coord from vy; 212/// and the errors from vectors vexl/h and veyl/h.; 213/// The number of points in the graph is the minimum of number of points; 214/// in vx and vy.; 215 ; 216TGraphAsymmErrors::TGraphAsymmErrors(const TVectorD &vx, const TVectorD &vy, const TVectorD &vexl, const TVectorD &vexh, const TVectorD &veyl, const TVectorD &veyh); 217{; 218 fNpoints = TMath::Min(vx.GetNrows(), vy.GetNrows());; 219 if (!TGraph::CtorAllocate()) return;; 220 if (!CtorAllocate()) return;; 221 Int_t ivxlow = vx.GetLwb();; 222 Int_t ivylow = vy.GetLwb();; 223 Int_t ivexllow = vexl.GetLwb();; 224 Int_t ivexhlow = vexh.GetLwb();; 225 Int_t iveyllow = veyl.GetLwb();; 226 Int_t iveyhlow = veyh.GetLwb();; 227 for (Int_t i=0;i<fNpoints;i++) {; 228 fX[i] = vx(i+ivxlow);; 229 fY[i] = vy(i+ivylow);; 230 fEXlow[i] = vexl(i+ivexllow);; 231 fEYlow[i] = veyl(i+iveyllow);; 232 fEXhigh[i] = vexh(i+ivexhlow);; 233 fEYhigh[i] = veyh(i+iveyhlow);; 234 }; 235}; 236 ; 237 ; 238////////////////////////////////////////////////////////////////////////////////; 239/// TGraphAsymmErrors constructor importing its parameters from the TH1 object passed as argument; 240/// the low and high errors are set to the bin error of the histogram.; 241 ; 242TGraphAsymmErrors::TGraphAsymmErrors(const TH1 *h); 243 : TGraph(h); 244{; 245 if (!CtorAllocate()) return;; 246 ; 247 for (Int_t i = 0; i < fNpoints; i++) {; 248 fEXlow[i] = h->GetBinWidth(i+1)*gStyle->GetErrorX();; 249 fEXhigh[i] = fEXlow[i];; 250 fEYlow[i] = h->GetBinErrorLow(i+1);; 251 fEYhigh[i] = h->GetBinErrorUp(i+1);; 252 }; 253}; 254 ; 255 ; 256////////////////////////////////////////////////////////////////////////////////; 257/// Creates a TGraphAsymmErrors by dividing two input TH1 histograms:; 258/// pass/total. (see TGraphAsymmErrors::Divide); 259 ; 260TGraphAsymmErrors::TGraphAsymmErrors(const TH1* pass, const TH1* total, Option_t *option); 261 : TGraph((pass)?pass->GetNbinsX():0); 262{; 263 if (!pas",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html
https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html:13053,Availability,error,error,13053,"IsDigit()) {; 349 Error(""TGraphAsymmErrors"", ""Incorrect input format! Allowed format tags are {\""%%lg\"",\""%%*lg\"" or \""%%*s\""}"");; 350 return ;; 351 }; 352 Int_t ntokens = format_.Length() ;; 353 if (ntokens < 2) {; 354 Error(""TGraphAsymmErrors"", ""Incorrect input format! Only %d tag(s) in format whereas at least 2 \""%%lg\"" tags are expected!"", ntokens);; 355 return ;; 356 }; 357 Int_t ntokensToBeSaved = 0;; 358 Bool_t * isTokenToBeSaved = new Bool_t[ntokens];; 359 for (Int_t idx = 0; idx < ntokens; idx++) {; 360 isTokenToBeSaved[idx] = TString::Format(""%c"", format_[idx]).Atoi(); //atoi(&format_[idx]) does not work for some reason...; 361 if (isTokenToBeSaved[idx] == 1) {; 362 ntokensToBeSaved++ ;; 363 }; 364 }; 365 if (ntokens >= 2 && (ntokensToBeSaved < 2 || ntokensToBeSaved > 4)) { //first condition not to repeat the previous error message; 366 Error(""TGraphAsymmErrors"", ""Incorrect input format! There are %d \""%%lg\"" tag(s) in format whereas 2,3 or 4 are expected!"", ntokensToBeSaved);; 367 delete [] isTokenToBeSaved;; 368 return ;; 369 }; 370 ; 371 // Initializing loop variables; 372 Bool_t isLineToBeSkipped = kFALSE; //empty and ill-formed lines; 373 char *token = nullptr;; 374 TString token_str = """";; 375 Int_t token_idx = 0;; 376 Double_t value[6]; //x,y,exl, exh, eyl, eyh buffers; 377 for (Int_t k = 0; k < 6; k++); 378 value[k] = 0.;; 379 Int_t value_idx = 0;; 380 ; 381 // Looping; 382 char *rest;; 383 while (std::getline(infile, line, '\n')) {; 384 if (!line.empty()) {; 385 if (line[line.size() - 1] == char(13)) { // removing DOS CR character; 386 line.erase(line.end() - 1, line.end()) ;; 387 }; 388 token = R__STRTOK_R(const_cast<char*>(line.c_str()), option, &rest) ;; 389 while (token != nullptr && value_idx < ntokensToBeSaved) {; 390 if (isTokenToBeSaved[token_idx]) {; 391 token_str = TString(token) ;; 392 token_str.ReplaceAll(""\t"", """") ;; 393 if (!token_str.IsFloat()) {; 394 isLineToBeSkipped = kTRUE ;; 395 break ;; 396 } else {; 397 value[value_idx] = tok",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html
https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html:15583,Availability,error,errorbars,15583,"08 exh = value[3];; 409 eyl = value[4];; 410 eyh = value[5];; 411 SetPoint(np, x, y);; 412 SetPointError(np, exl, exh, eyl, eyh);; 413 np++ ;; 414 }; 415 }; 416 isLineToBeSkipped = kFALSE;; 417 token = nullptr;; 418 token_idx = 0;; 419 value_idx = 0;; 420 }; 421 Set(np) ;; 422 ; 423 // Cleaning; 424 delete [] isTokenToBeSaved;; 425 delete token;; 426 }; 427 infile.close();; 428}; 429 ; 430////////////////////////////////////////////////////////////////////////////////; 431/// TGraphAsymmErrors default destructor.; 432 ; 433TGraphAsymmErrors::~TGraphAsymmErrors(); 434{; 435 if(fEXlow) delete [] fEXlow;; 436 if(fEXhigh) delete [] fEXhigh;; 437 if(fEYlow) delete [] fEYlow;; 438 if(fEYhigh) delete [] fEYhigh;; 439}; 440 ; 441////////////////////////////////////////////////////////////////////////////////; 442/// Allocate internal data structures for `size` points.; 443 ; 444Double_t** TGraphAsymmErrors::Allocate(Int_t size) {; 445 return AllocateArrays(6, size);; 446}; 447 ; 448////////////////////////////////////////////////////////////////////////////////; 449/// Add a point with asymmetric errorbars to the graph.; 450 ; 451void TGraphAsymmErrors::AddPointError(Double_t x, Double_t y, Double_t exl, Double_t exh, Double_t eyl, Double_t eyh); 452{; 453 AddPoint(x, y);; 454 SetPointError(fNpoints - 1, exl, exh, eyl, eyh);; 455}; 456 ; 457////////////////////////////////////////////////////////////////////////////////; 458/// Apply a function to all data points \f$ y = f(x,y) \f$; 459///; 460/// Errors are calculated as \f$ eyh = f(x,y+eyh)-f(x,y) \f$ and; 461/// \f$ eyl = f(x,y)-f(x,y-eyl) \f$; 462///; 463/// Special treatment has to be applied for the functions where the; 464/// role of ""up"" and ""down"" is reversed.; 465///; 466/// Function suggested/implemented by Miroslav Helbich <helbich@mail.desy.de>; 467 ; 468void TGraphAsymmErrors::Apply(TF1 *f); 469{; 470 Double_t x,y,exl,exh,eyl,eyh,eyl_new,eyh_new,fxy;; 471 ; 472 if (fHistogram) {; 473 delete fHistogram;; 474 fHi",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html
https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html:16199,Availability,down,down,16199,"//////////////////////////////////////; 431/// TGraphAsymmErrors default destructor.; 432 ; 433TGraphAsymmErrors::~TGraphAsymmErrors(); 434{; 435 if(fEXlow) delete [] fEXlow;; 436 if(fEXhigh) delete [] fEXhigh;; 437 if(fEYlow) delete [] fEYlow;; 438 if(fEYhigh) delete [] fEYhigh;; 439}; 440 ; 441////////////////////////////////////////////////////////////////////////////////; 442/// Allocate internal data structures for `size` points.; 443 ; 444Double_t** TGraphAsymmErrors::Allocate(Int_t size) {; 445 return AllocateArrays(6, size);; 446}; 447 ; 448////////////////////////////////////////////////////////////////////////////////; 449/// Add a point with asymmetric errorbars to the graph.; 450 ; 451void TGraphAsymmErrors::AddPointError(Double_t x, Double_t y, Double_t exl, Double_t exh, Double_t eyl, Double_t eyh); 452{; 453 AddPoint(x, y);; 454 SetPointError(fNpoints - 1, exl, exh, eyl, eyh);; 455}; 456 ; 457////////////////////////////////////////////////////////////////////////////////; 458/// Apply a function to all data points \f$ y = f(x,y) \f$; 459///; 460/// Errors are calculated as \f$ eyh = f(x,y+eyh)-f(x,y) \f$ and; 461/// \f$ eyl = f(x,y)-f(x,y-eyl) \f$; 462///; 463/// Special treatment has to be applied for the functions where the; 464/// role of ""up"" and ""down"" is reversed.; 465///; 466/// Function suggested/implemented by Miroslav Helbich <helbich@mail.desy.de>; 467 ; 468void TGraphAsymmErrors::Apply(TF1 *f); 469{; 470 Double_t x,y,exl,exh,eyl,eyh,eyl_new,eyh_new,fxy;; 471 ; 472 if (fHistogram) {; 473 delete fHistogram;; 474 fHistogram = nullptr;; 475 }; 476 for (Int_t i=0;i<GetN();i++) {; 477 GetPoint(i,x,y);; 478 exl = GetErrorXlow(i);; 479 exh = GetErrorXhigh(i);; 480 eyl = GetErrorYlow(i);; 481 eyh = GetErrorYhigh(i);; 482 ; 483 fxy = f->Eval(x,y);; 484 SetPoint(i,x,fxy);; 485 ; 486 // in the case of the functions like y-> -1*y the roles of the; 487 // upper and lower error bars is reversed; 488 if (f->Eval(x,y-eyl)<f->Eval(x,y+eyh)) {; 489 eyl_new =",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html
https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html:16829,Availability,error,error,16829,"/////////////////////////////////////////////////////////; 458/// Apply a function to all data points \f$ y = f(x,y) \f$; 459///; 460/// Errors are calculated as \f$ eyh = f(x,y+eyh)-f(x,y) \f$ and; 461/// \f$ eyl = f(x,y)-f(x,y-eyl) \f$; 462///; 463/// Special treatment has to be applied for the functions where the; 464/// role of ""up"" and ""down"" is reversed.; 465///; 466/// Function suggested/implemented by Miroslav Helbich <helbich@mail.desy.de>; 467 ; 468void TGraphAsymmErrors::Apply(TF1 *f); 469{; 470 Double_t x,y,exl,exh,eyl,eyh,eyl_new,eyh_new,fxy;; 471 ; 472 if (fHistogram) {; 473 delete fHistogram;; 474 fHistogram = nullptr;; 475 }; 476 for (Int_t i=0;i<GetN();i++) {; 477 GetPoint(i,x,y);; 478 exl = GetErrorXlow(i);; 479 exh = GetErrorXhigh(i);; 480 eyl = GetErrorYlow(i);; 481 eyh = GetErrorYhigh(i);; 482 ; 483 fxy = f->Eval(x,y);; 484 SetPoint(i,x,fxy);; 485 ; 486 // in the case of the functions like y-> -1*y the roles of the; 487 // upper and lower error bars is reversed; 488 if (f->Eval(x,y-eyl)<f->Eval(x,y+eyh)) {; 489 eyl_new = TMath::Abs(fxy - f->Eval(x,y-eyl));; 490 eyh_new = TMath::Abs(f->Eval(x,y+eyh) - fxy);; 491 } else {; 492 eyh_new = TMath::Abs(fxy - f->Eval(x,y-eyl));; 493 eyl_new = TMath::Abs(f->Eval(x,y+eyh) - fxy);; 494 }; 495 ; 496 //error on x doesn't change; 497 SetPointError(i,exl,exh,eyl_new,eyh_new);; 498 }; 499 if (gPad) gPad->Modified();; 500}; 501 ; 502////////////////////////////////////////////////////////////////////////////////; 503///This function is only kept for backward compatibility.; 504///You should rather use the Divide method.; 505///It calls `Divide(pass,total,""cl=0.683 b(1,1) mode"")` which is equivalent to the; 506///former BayesDivide method.; 507 ; 508void TGraphAsymmErrors::BayesDivide(const TH1* pass, const TH1* total, Option_t *); 509{; 510 Divide(pass,total,""cl=0.683 b(1,1) mode"");; 511}; 512 ; 513////////////////////////////////////////////////////////////////////////////////; 514/// Fill this TGraphAsymmErrors",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html
https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html:17136,Availability,error,error,17136,"/////////////////////////////////////////////////////////; 458/// Apply a function to all data points \f$ y = f(x,y) \f$; 459///; 460/// Errors are calculated as \f$ eyh = f(x,y+eyh)-f(x,y) \f$ and; 461/// \f$ eyl = f(x,y)-f(x,y-eyl) \f$; 462///; 463/// Special treatment has to be applied for the functions where the; 464/// role of ""up"" and ""down"" is reversed.; 465///; 466/// Function suggested/implemented by Miroslav Helbich <helbich@mail.desy.de>; 467 ; 468void TGraphAsymmErrors::Apply(TF1 *f); 469{; 470 Double_t x,y,exl,exh,eyl,eyh,eyl_new,eyh_new,fxy;; 471 ; 472 if (fHistogram) {; 473 delete fHistogram;; 474 fHistogram = nullptr;; 475 }; 476 for (Int_t i=0;i<GetN();i++) {; 477 GetPoint(i,x,y);; 478 exl = GetErrorXlow(i);; 479 exh = GetErrorXhigh(i);; 480 eyl = GetErrorYlow(i);; 481 eyh = GetErrorYhigh(i);; 482 ; 483 fxy = f->Eval(x,y);; 484 SetPoint(i,x,fxy);; 485 ; 486 // in the case of the functions like y-> -1*y the roles of the; 487 // upper and lower error bars is reversed; 488 if (f->Eval(x,y-eyl)<f->Eval(x,y+eyh)) {; 489 eyl_new = TMath::Abs(fxy - f->Eval(x,y-eyl));; 490 eyh_new = TMath::Abs(f->Eval(x,y+eyh) - fxy);; 491 } else {; 492 eyh_new = TMath::Abs(fxy - f->Eval(x,y-eyl));; 493 eyl_new = TMath::Abs(f->Eval(x,y+eyh) - fxy);; 494 }; 495 ; 496 //error on x doesn't change; 497 SetPointError(i,exl,exh,eyl_new,eyh_new);; 498 }; 499 if (gPad) gPad->Modified();; 500}; 501 ; 502////////////////////////////////////////////////////////////////////////////////; 503///This function is only kept for backward compatibility.; 504///You should rather use the Divide method.; 505///It calls `Divide(pass,total,""cl=0.683 b(1,1) mode"")` which is equivalent to the; 506///former BayesDivide method.; 507 ; 508void TGraphAsymmErrors::BayesDivide(const TH1* pass, const TH1* total, Option_t *); 509{; 510 Divide(pass,total,""cl=0.683 b(1,1) mode"");; 511}; 512 ; 513////////////////////////////////////////////////////////////////////////////////; 514/// Fill this TGraphAsymmErrors",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html
https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html:19602,Availability,error,errors,19602,"528/// \f]; 529/// The points are assigned a x value at the center of each histogram bin.; 530/// The y values are \f$\text{eff} = \frac{\text{pass}}{\text{total}}\f$; 531/// for all options except for the; 532/// bayesian methods where the result depends on the chosen option.; 533///; 534/// If the denominator becomes 0 or pass > total, the corresponding bin is; 535/// skipped.; 536///; 537/// ### 2) calculating ratios of two Poisson means (option 'pois'):; 538///; 539/// The two histograms are interpreted as independent Poisson processes and the ratio; 540/// \f[; 541/// \tau = \frac{n_{1}}{n_{2}} = \frac{\varepsilon}{1 - \varepsilon}; 542/// \f]; 543/// with \f$\varepsilon = \frac{n_{1}}{n_{1} + n_{2}}\f$.; 544/// The histogram 'pass' is interpreted as \f$n_{1}\f$ and the total histogram; 545/// is used for \f$n_{2}\f$.; 546///; 547/// The (asymmetric) uncertainties of the Poisson ratio are linked to the uncertainties; 548/// of efficiency by a parameter transformation:; 549/// \f[; 550/// \Delta \tau_{low/up} = \frac{1}{(1 - \varepsilon)^{2}} \Delta \varepsilon_{low/up}; 551/// \f]; 552///; 553/// The x errors span each histogram bin (lowedge ... lowedge+width); 554/// The y errors depend on the chosen statistic methode which can be determined; 555/// by the options given below. For a detailed description of the used statistic; 556/// calculations please have a look at the corresponding functions!; 557///; 558/// Options:; 559/// - v : verbose mode: prints information about the number of used bins; 560/// and calculated efficiencies with their errors; 561/// - cl=x : determine the used confidence level (0<x<1) (default is 0.683); 562/// - cp : Clopper-Pearson interval (see TEfficiency::ClopperPearson); 563/// - w : Wilson interval (see TEfficiency::Wilson); 564/// - n : normal approximation propagation (see TEfficiency::Normal); 565/// - ac : Agresti-Coull interval (see TEfficiency::AgrestiCoull); 566/// - fc : Feldman-Cousins interval (see TEfficiency::FeldmanC",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html
https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html:19675,Availability,error,errors,19675,"e the result depends on the chosen option.; 533///; 534/// If the denominator becomes 0 or pass > total, the corresponding bin is; 535/// skipped.; 536///; 537/// ### 2) calculating ratios of two Poisson means (option 'pois'):; 538///; 539/// The two histograms are interpreted as independent Poisson processes and the ratio; 540/// \f[; 541/// \tau = \frac{n_{1}}{n_{2}} = \frac{\varepsilon}{1 - \varepsilon}; 542/// \f]; 543/// with \f$\varepsilon = \frac{n_{1}}{n_{1} + n_{2}}\f$.; 544/// The histogram 'pass' is interpreted as \f$n_{1}\f$ and the total histogram; 545/// is used for \f$n_{2}\f$.; 546///; 547/// The (asymmetric) uncertainties of the Poisson ratio are linked to the uncertainties; 548/// of efficiency by a parameter transformation:; 549/// \f[; 550/// \Delta \tau_{low/up} = \frac{1}{(1 - \varepsilon)^{2}} \Delta \varepsilon_{low/up}; 551/// \f]; 552///; 553/// The x errors span each histogram bin (lowedge ... lowedge+width); 554/// The y errors depend on the chosen statistic methode which can be determined; 555/// by the options given below. For a detailed description of the used statistic; 556/// calculations please have a look at the corresponding functions!; 557///; 558/// Options:; 559/// - v : verbose mode: prints information about the number of used bins; 560/// and calculated efficiencies with their errors; 561/// - cl=x : determine the used confidence level (0<x<1) (default is 0.683); 562/// - cp : Clopper-Pearson interval (see TEfficiency::ClopperPearson); 563/// - w : Wilson interval (see TEfficiency::Wilson); 564/// - n : normal approximation propagation (see TEfficiency::Normal); 565/// - ac : Agresti-Coull interval (see TEfficiency::AgrestiCoull); 566/// - fc : Feldman-Cousins interval (see TEfficiency::FeldmanCousinsInterval); 567/// - midp : Lancaster mid-P interval (see TEfficiency::MidPInterval); 568/// - b(a,b): bayesian interval using a prior probability ~Beta(a,b); a,b > 0; 569/// (see TEfficiency::Bayesian); 570/// - mode : use mode of",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html
https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html:20051,Availability,error,errors,20051,"he two histograms are interpreted as independent Poisson processes and the ratio; 540/// \f[; 541/// \tau = \frac{n_{1}}{n_{2}} = \frac{\varepsilon}{1 - \varepsilon}; 542/// \f]; 543/// with \f$\varepsilon = \frac{n_{1}}{n_{1} + n_{2}}\f$.; 544/// The histogram 'pass' is interpreted as \f$n_{1}\f$ and the total histogram; 545/// is used for \f$n_{2}\f$.; 546///; 547/// The (asymmetric) uncertainties of the Poisson ratio are linked to the uncertainties; 548/// of efficiency by a parameter transformation:; 549/// \f[; 550/// \Delta \tau_{low/up} = \frac{1}{(1 - \varepsilon)^{2}} \Delta \varepsilon_{low/up}; 551/// \f]; 552///; 553/// The x errors span each histogram bin (lowedge ... lowedge+width); 554/// The y errors depend on the chosen statistic methode which can be determined; 555/// by the options given below. For a detailed description of the used statistic; 556/// calculations please have a look at the corresponding functions!; 557///; 558/// Options:; 559/// - v : verbose mode: prints information about the number of used bins; 560/// and calculated efficiencies with their errors; 561/// - cl=x : determine the used confidence level (0<x<1) (default is 0.683); 562/// - cp : Clopper-Pearson interval (see TEfficiency::ClopperPearson); 563/// - w : Wilson interval (see TEfficiency::Wilson); 564/// - n : normal approximation propagation (see TEfficiency::Normal); 565/// - ac : Agresti-Coull interval (see TEfficiency::AgrestiCoull); 566/// - fc : Feldman-Cousins interval (see TEfficiency::FeldmanCousinsInterval); 567/// - midp : Lancaster mid-P interval (see TEfficiency::MidPInterval); 568/// - b(a,b): bayesian interval using a prior probability ~Beta(a,b); a,b > 0; 569/// (see TEfficiency::Bayesian); 570/// - mode : use mode of posterior for Bayesian interval (default is mean); 571/// - shortest: use shortest interval (done by default if mode is set); 572/// - central: use central interval (done by default if mode is NOT set); 573/// - pois: interpret histograms as p",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html
https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html:27256,Availability,error,error,27256,"terval;; 742 }; 743 ; 744 // interpret as Poisson ratio; 745 Bool_t bPoissonRatio = false;; 746 if (option.Contains(""pois"")) {; 747 bPoissonRatio = true;; 748 option.ReplaceAll(""pois"", """");; 749 }; 750 Bool_t plot0Bins = false;; 751 if (option.Contains(""e0"")) {; 752 plot0Bins = true;; 753 option.ReplaceAll(""e0"", """");; 754 }; 755 ; 756 // weights works only in case of Normal approximation or Bayesian for binomial interval; 757 // in case of Poisson ratio we can use weights by rescaling the obtained results using the effective entries; 758 if ((bEffective && !bPoissonRatio) && !bIsBayesian && pBound != &TEfficiency::Normal) {; 759 Warning(""Divide"", ""Histograms have weights: only Normal or Bayesian error calculation is supported"");; 760 Info(""Divide"", ""Using now the Normal approximation for weighted histograms"");; 761 }; 762 ; 763 if (bPoissonRatio) {; 764 if (pass->GetDimension() != total->GetDimension()) {; 765 Error(""Divide"", ""passed histograms are not of the same dimension"");; 766 return;; 767 }; 768 ; 769 if (!TEfficiency::CheckBinning(*pass, *total)) {; 770 Error(""Divide"", ""passed histograms are not consistent"");; 771 return;; 772 }; 773 } else {; 774 // check consistency of histograms, allowing weights; 775 if (!TEfficiency::CheckConsistency(*pass, *total, ""w"")) {; 776 Error(""Divide"", ""passed histograms are not consistent"");; 777 return;; 778 }; 779 }; 780 ; 781 // Set the graph to have a number of points equal to the number of histogram; 782 // bins; 783 Int_t nbins = pass->GetNbinsX();; 784 Set(nbins);; 785 ; 786 // Ok, now set the points for each bin; 787 // (Note: the TH1 bin content is shifted to the right by one:; 788 // bin=0 is underflow, bin=nbins+1 is overflow.); 789 ; 790 //efficiency with lower and upper boundary of confidence interval; 791 double eff, low, upper;; 792 //this keeps track of the number of points added to the graph; 793 int npoint=0;; 794 //number of total and passed events; 795 Double_t t = 0 , p = 0;; 796 Double_t tw = 0, tw2 = 0, pw",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html
https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html:31022,Availability,error,errors,31022," && !plot0Bins); 849 continue; // skip bins with total <= 0; 850 ; 851 // in the case of weights have the formula only for; 852 // the normal and bayesian statistics (see below); 853 ; 854 }; 855 ; 856 // use bin contents; 857 else {; 858 t = std::round(total->GetBinContent(b));; 859 p = std::round(pass->GetBinContent(b));; 860 ; 861 if (bPoissonRatio); 862 t += p;; 863 ; 864 if (t == 0.0 && !plot0Bins); 865 continue; // skip bins with total = 0; 866 }; 867 ; 868 //using bayesian statistics; 869 if(bIsBayesian) {; 870 double aa,bb;; 871 ; 872 if ((bEffective && !bPoissonRatio) && tw2 <= 0) {; 873 // case of bins with zero errors; 874 eff = pw/tw;; 875 low = eff; upper = eff;; 876 }; 877 else {; 878 ; 879 if (bEffective && !bPoissonRatio) {; 880 // tw/tw2 re-normalize the weights; 881 double norm = tw/tw2; // case of tw2 = 0 is treated above; 882 aa = pw * norm + alpha;; 883 bb = (tw - pw) * norm + beta;; 884 }; 885 else {; 886 aa = double(p) + alpha;; 887 bb = double(t-p) + beta;; 888 }; 889 if (usePosteriorMode); 890 eff = TEfficiency::BetaMode(aa,bb);; 891 else; 892 eff = TEfficiency::BetaMean(aa,bb);; 893 ; 894 if (useShortestInterval) {; 895 TEfficiency::BetaShortestInterval(conf,aa,bb,low,upper);; 896 }; 897 else {; 898 low = TEfficiency::BetaCentralInterval(conf,aa,bb,false);; 899 upper = TEfficiency::BetaCentralInterval(conf,aa,bb,true);; 900 }; 901 }; 902 }; 903 // case of non-bayesian statistics; 904 else {; 905 if (bEffective && !bPoissonRatio) {; 906 ; 907 if (tw > 0) {; 908 ; 909 eff = pw/tw;; 910 ; 911 // use normal error calculation using variance of MLE with weights (F.James 8.5.2); 912 // this is the same formula used in ROOT for TH1::Divide(""B""); 913 ; 914 double variance = ( pw2 * (1. - 2 * eff) + tw2 * eff *eff ) / ( tw * tw) ;; 915 double sigma = sqrt(variance);; 916 ; 917 double prob = 0.5 * (1.-conf);; 918 double delta = ROOT::Math::normal_quantile_c(prob, sigma);; 919 low = eff - delta;; 920 upper = eff + delta;; 921 if (low < 0) low = 0;; 922 ",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html
https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html:31947,Availability,error,error,31947," && !plot0Bins); 849 continue; // skip bins with total <= 0; 850 ; 851 // in the case of weights have the formula only for; 852 // the normal and bayesian statistics (see below); 853 ; 854 }; 855 ; 856 // use bin contents; 857 else {; 858 t = std::round(total->GetBinContent(b));; 859 p = std::round(pass->GetBinContent(b));; 860 ; 861 if (bPoissonRatio); 862 t += p;; 863 ; 864 if (t == 0.0 && !plot0Bins); 865 continue; // skip bins with total = 0; 866 }; 867 ; 868 //using bayesian statistics; 869 if(bIsBayesian) {; 870 double aa,bb;; 871 ; 872 if ((bEffective && !bPoissonRatio) && tw2 <= 0) {; 873 // case of bins with zero errors; 874 eff = pw/tw;; 875 low = eff; upper = eff;; 876 }; 877 else {; 878 ; 879 if (bEffective && !bPoissonRatio) {; 880 // tw/tw2 re-normalize the weights; 881 double norm = tw/tw2; // case of tw2 = 0 is treated above; 882 aa = pw * norm + alpha;; 883 bb = (tw - pw) * norm + beta;; 884 }; 885 else {; 886 aa = double(p) + alpha;; 887 bb = double(t-p) + beta;; 888 }; 889 if (usePosteriorMode); 890 eff = TEfficiency::BetaMode(aa,bb);; 891 else; 892 eff = TEfficiency::BetaMean(aa,bb);; 893 ; 894 if (useShortestInterval) {; 895 TEfficiency::BetaShortestInterval(conf,aa,bb,low,upper);; 896 }; 897 else {; 898 low = TEfficiency::BetaCentralInterval(conf,aa,bb,false);; 899 upper = TEfficiency::BetaCentralInterval(conf,aa,bb,true);; 900 }; 901 }; 902 }; 903 // case of non-bayesian statistics; 904 else {; 905 if (bEffective && !bPoissonRatio) {; 906 ; 907 if (tw > 0) {; 908 ; 909 eff = pw/tw;; 910 ; 911 // use normal error calculation using variance of MLE with weights (F.James 8.5.2); 912 // this is the same formula used in ROOT for TH1::Divide(""B""); 913 ; 914 double variance = ( pw2 * (1. - 2 * eff) + tw2 * eff *eff ) / ( tw * tw) ;; 915 double sigma = sqrt(variance);; 916 ; 917 double prob = 0.5 * (1.-conf);; 918 double delta = ROOT::Math::normal_quantile_c(prob, sigma);; 919 low = eff - delta;; 920 upper = eff + delta;; 921 if (low < 0) low = 0;; 922 ",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html
https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html:33091,Availability,error,errors,33091,"upper = eff + delta;; 921 if (low < 0) low = 0;; 922 if (upper > 1) upper = 1.;; 923 }; 924 }; 925 else {; 926 // when not using weights (all cases) or in case of Poisson ratio with weights; 927 if(t != 0.0); 928 eff = ((Double_t)p)/t;; 929 ; 930 low = pBound(t,p,conf,false);; 931 upper = pBound(t,p,conf,true);; 932 }; 933 }; 934 // treat as Poisson ratio; 935 if(bPoissonRatio); 936 {; 937 Double_t ratio = eff/(1 - eff);; 938 // take the intervals in eff as intervals in the Poisson ratio; 939 low = low/(1. - low);; 940 upper = upper/(1.-upper);; 941 eff = ratio;; 942 if (bEffective) {; 943 //scale result by the ratio of the weight; 944 eff *= wratio;; 945 low *= wratio;; 946 upper *= wratio;; 947 }; 948 }; 949 //Set the point center and its errors; 950 if (TMath::Finite(eff)) {; 951 SetPoint(npoint,pass->GetBinCenter(b),eff);; 952 SetPointError(npoint,; 953 pass->GetBinCenter(b)-pass->GetBinLowEdge(b),; 954 pass->GetBinLowEdge(b)-pass->GetBinCenter(b)+pass->GetBinWidth(b),; 955 eff-low,upper-eff);; 956 npoint++;//we have added a point to the graph; 957 }; 958 }; 959 ; 960 Set(npoint);//tell the graph how many points we've really added; 961 if (npoint < nbins); 962 Warning(""Divide"",""Number of graph points is different than histogram bins - %d points have been skipped"",nbins-npoint);; 963 ; 964 ; 965 if (bVerbose) {; 966 Info(""Divide"",""made a graph with %d points from %d bins"",npoint,nbins);; 967 Info(""Divide"",""used confidence level: %.2lf\n"",conf);; 968 if(bIsBayesian); 969 Info(""Divide"",""used prior probability ~ beta(%.2lf,%.2lf)"",alpha,beta);; 970 Print();; 971 }; 972}; 973 ; 974////////////////////////////////////////////////////////////////////////////////; 975/// Compute Range.; 976 ; 977void TGraphAsymmErrors::ComputeRange(Double_t &xmin, Double_t &ymin, Double_t &xmax, Double_t &ymax) const; 978{; 979 TGraph::ComputeRange(xmin,ymin,xmax,ymax);; 980 ; 981 for (Int_t i=0;i<fNpoints;i++) {; 982 if (fX[i] -fEXlow[i] < xmin) {; 983 if (gPad && gPad->GetLogx()) {; 9",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html
https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html:35631,Availability,error,errors,35631," 984 if (fEXlow[i] < fX[i]) xmin = fX[i]-fEXlow[i];; 985 else xmin = TMath::Min(xmin,fX[i]/3);; 986 } else {; 987 xmin = fX[i]-fEXlow[i];; 988 }; 989 }; 990 if (fX[i] +fEXhigh[i] > xmax) xmax = fX[i]+fEXhigh[i];; 991 if (fY[i] -fEYlow[i] < ymin) {; 992 if (gPad && gPad->GetLogy()) {; 993 if (fEYlow[i] < fY[i]) ymin = fY[i]-fEYlow[i];; 994 else ymin = TMath::Min(ymin,fY[i]/3);; 995 } else {; 996 ymin = fY[i]-fEYlow[i];; 997 }; 998 }; 999 if (fY[i] +fEYhigh[i] > ymax) ymax = fY[i]+fEYhigh[i];; 1000 }; 1001}; 1002 ; 1003 ; 1004////////////////////////////////////////////////////////////////////////////////; 1005/// Copy and release.; 1006 ; 1007void TGraphAsymmErrors::CopyAndRelease(Double_t **newarrays,; 1008 Int_t ibegin, Int_t iend, Int_t obegin); 1009{; 1010 CopyPoints(newarrays, ibegin, iend, obegin);; 1011 if (newarrays) {; 1012 delete[] fEXlow;; 1013 fEXlow = newarrays[0];; 1014 delete[] fEXhigh;; 1015 fEXhigh = newarrays[1];; 1016 delete[] fEYlow;; 1017 fEYlow = newarrays[2];; 1018 delete[] fEYhigh;; 1019 fEYhigh = newarrays[3];; 1020 delete[] fX;; 1021 fX = newarrays[4];; 1022 delete[] fY;; 1023 fY = newarrays[5];; 1024 delete[] newarrays;; 1025 }; 1026}; 1027 ; 1028 ; 1029////////////////////////////////////////////////////////////////////////////////; 1030/// Copy errors from `fE***` to `arrays[***]`; 1031/// or to `f***` Copy points.; 1032 ; 1033Bool_t TGraphAsymmErrors::CopyPoints(Double_t **arrays,; 1034 Int_t ibegin, Int_t iend, Int_t obegin); 1035{; 1036 if (TGraph::CopyPoints(arrays ? arrays+4 : nullptr, ibegin, iend, obegin)) {; 1037 Int_t n = (iend - ibegin)*sizeof(Double_t);; 1038 if (arrays) {; 1039 memmove(&arrays[0][obegin], &fEXlow[ibegin], n);; 1040 memmove(&arrays[1][obegin], &fEXhigh[ibegin], n);; 1041 memmove(&arrays[2][obegin], &fEYlow[ibegin], n);; 1042 memmove(&arrays[3][obegin], &fEYhigh[ibegin], n);; 1043 } else {; 1044 memmove(&fEXlow[obegin], &fEXlow[ibegin], n);; 1045 memmove(&fEXhigh[obegin], &fEXhigh[ibegin], n);; 1046 memmove(&fEYl",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html
https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html:37335,Availability,error,errors,37335,"n], &fEXlow[ibegin], n);; 1040 memmove(&arrays[1][obegin], &fEXhigh[ibegin], n);; 1041 memmove(&arrays[2][obegin], &fEYlow[ibegin], n);; 1042 memmove(&arrays[3][obegin], &fEYhigh[ibegin], n);; 1043 } else {; 1044 memmove(&fEXlow[obegin], &fEXlow[ibegin], n);; 1045 memmove(&fEXhigh[obegin], &fEXhigh[ibegin], n);; 1046 memmove(&fEYlow[obegin], &fEYlow[ibegin], n);; 1047 memmove(&fEYhigh[obegin], &fEYhigh[ibegin], n);; 1048 }; 1049 return kTRUE;; 1050 } else {; 1051 return kFALSE;; 1052 }; 1053}; 1054 ; 1055 ; 1056////////////////////////////////////////////////////////////////////////////////; 1057/// Should be called from ctors after `fNpoints` has been set.; 1058/// Note: This function should be called only from the constructor; 1059/// since it does not delete previously existing arrays; 1060 ; 1061Bool_t TGraphAsymmErrors::CtorAllocate(); 1062{; 1063 if (!fNpoints) {; 1064 fEXlow = fEYlow = fEXhigh = fEYhigh = nullptr;; 1065 return kFALSE;; 1066 }; 1067 fEXlow = new Double_t[fMaxSize];; 1068 fEYlow = new Double_t[fMaxSize];; 1069 fEXhigh = new Double_t[fMaxSize];; 1070 fEYhigh = new Double_t[fMaxSize];; 1071 return kTRUE;; 1072}; 1073 ; 1074////////////////////////////////////////////////////////////////////////////////; 1075/// Protected function to perform the merge operation of a graph with asymmetric errors.; 1076 ; 1077Bool_t TGraphAsymmErrors::DoMerge(const TGraph *g); 1078{; 1079 if (g->GetN() == 0) return kFALSE;; 1080 ; 1081 Double_t * exl = g->GetEXlow();; 1082 Double_t * exh = g->GetEXhigh();; 1083 Double_t * eyl = g->GetEYlow();; 1084 Double_t * eyh = g->GetEYhigh();; 1085 if (exl == nullptr || exh == nullptr || eyl == nullptr || eyh == nullptr) {; 1086 if (g->IsA() != TGraph::Class() ); 1087 Warning(""DoMerge"",""Merging a %s is not compatible with a TGraphAsymmErrors - errors will be ignored"",g->IsA()->GetName());; 1088 return TGraph::DoMerge(g);; 1089 }; 1090 for (Int_t i = 0 ; i < g->GetN(); i++) {; 1091 Int_t ipoint = GetN();; 1092 Double_t x = g->Ge",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html
https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html:37820,Availability,error,errors,37820,"RUE;; 1072}; 1073 ; 1074////////////////////////////////////////////////////////////////////////////////; 1075/// Protected function to perform the merge operation of a graph with asymmetric errors.; 1076 ; 1077Bool_t TGraphAsymmErrors::DoMerge(const TGraph *g); 1078{; 1079 if (g->GetN() == 0) return kFALSE;; 1080 ; 1081 Double_t * exl = g->GetEXlow();; 1082 Double_t * exh = g->GetEXhigh();; 1083 Double_t * eyl = g->GetEYlow();; 1084 Double_t * eyh = g->GetEYhigh();; 1085 if (exl == nullptr || exh == nullptr || eyl == nullptr || eyh == nullptr) {; 1086 if (g->IsA() != TGraph::Class() ); 1087 Warning(""DoMerge"",""Merging a %s is not compatible with a TGraphAsymmErrors - errors will be ignored"",g->IsA()->GetName());; 1088 return TGraph::DoMerge(g);; 1089 }; 1090 for (Int_t i = 0 ; i < g->GetN(); i++) {; 1091 Int_t ipoint = GetN();; 1092 Double_t x = g->GetX()[i];; 1093 Double_t y = g->GetY()[i];; 1094 SetPoint(ipoint, x, y);; 1095 SetPointError(ipoint, exl[i], exh[i], eyl[i], eyh[i] );; 1096 }; 1097 ; 1098 return kTRUE;; 1099}; 1100 ; 1101////////////////////////////////////////////////////////////////////////////////; 1102/// Set zero values for point arrays in the range `[begin, end]`; 1103 ; 1104void TGraphAsymmErrors::FillZero(Int_t begin, Int_t end,; 1105 Bool_t from_ctor); 1106{; 1107 if (!from_ctor) {; 1108 TGraph::FillZero(begin, end, from_ctor);; 1109 }; 1110 Int_t n = (end - begin)*sizeof(Double_t);; 1111 memset(fEXlow + begin, 0, n);; 1112 memset(fEXhigh + begin, 0, n);; 1113 memset(fEYlow + begin, 0, n);; 1114 memset(fEYhigh + begin, 0, n);; 1115}; 1116 ; 1117 ; 1118////////////////////////////////////////////////////////////////////////////////; 1119/// Returns the combined error along X at point i by computing the average; 1120/// of the lower and upper variance.; 1121 ; 1122Double_t TGraphAsymmErrors::GetErrorX(Int_t i) const; 1123{; 1124 if (i < 0 || i >= fNpoints) return -1;; 1125 if (!fEXlow && !fEXhigh) return -1;; 1126 Double_t elow=0, ehigh=0;; 1127 ",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html
https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html:38856,Availability,error,error,38856,"RUE;; 1072}; 1073 ; 1074////////////////////////////////////////////////////////////////////////////////; 1075/// Protected function to perform the merge operation of a graph with asymmetric errors.; 1076 ; 1077Bool_t TGraphAsymmErrors::DoMerge(const TGraph *g); 1078{; 1079 if (g->GetN() == 0) return kFALSE;; 1080 ; 1081 Double_t * exl = g->GetEXlow();; 1082 Double_t * exh = g->GetEXhigh();; 1083 Double_t * eyl = g->GetEYlow();; 1084 Double_t * eyh = g->GetEYhigh();; 1085 if (exl == nullptr || exh == nullptr || eyl == nullptr || eyh == nullptr) {; 1086 if (g->IsA() != TGraph::Class() ); 1087 Warning(""DoMerge"",""Merging a %s is not compatible with a TGraphAsymmErrors - errors will be ignored"",g->IsA()->GetName());; 1088 return TGraph::DoMerge(g);; 1089 }; 1090 for (Int_t i = 0 ; i < g->GetN(); i++) {; 1091 Int_t ipoint = GetN();; 1092 Double_t x = g->GetX()[i];; 1093 Double_t y = g->GetY()[i];; 1094 SetPoint(ipoint, x, y);; 1095 SetPointError(ipoint, exl[i], exh[i], eyl[i], eyh[i] );; 1096 }; 1097 ; 1098 return kTRUE;; 1099}; 1100 ; 1101////////////////////////////////////////////////////////////////////////////////; 1102/// Set zero values for point arrays in the range `[begin, end]`; 1103 ; 1104void TGraphAsymmErrors::FillZero(Int_t begin, Int_t end,; 1105 Bool_t from_ctor); 1106{; 1107 if (!from_ctor) {; 1108 TGraph::FillZero(begin, end, from_ctor);; 1109 }; 1110 Int_t n = (end - begin)*sizeof(Double_t);; 1111 memset(fEXlow + begin, 0, n);; 1112 memset(fEXhigh + begin, 0, n);; 1113 memset(fEYlow + begin, 0, n);; 1114 memset(fEYhigh + begin, 0, n);; 1115}; 1116 ; 1117 ; 1118////////////////////////////////////////////////////////////////////////////////; 1119/// Returns the combined error along X at point i by computing the average; 1120/// of the lower and upper variance.; 1121 ; 1122Double_t TGraphAsymmErrors::GetErrorX(Int_t i) const; 1123{; 1124 if (i < 0 || i >= fNpoints) return -1;; 1125 if (!fEXlow && !fEXhigh) return -1;; 1126 Double_t elow=0, ehigh=0;; 1127 ",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html
https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html:39408,Availability,error,error,39408,"symmErrors::FillZero(Int_t begin, Int_t end,; 1105 Bool_t from_ctor); 1106{; 1107 if (!from_ctor) {; 1108 TGraph::FillZero(begin, end, from_ctor);; 1109 }; 1110 Int_t n = (end - begin)*sizeof(Double_t);; 1111 memset(fEXlow + begin, 0, n);; 1112 memset(fEXhigh + begin, 0, n);; 1113 memset(fEYlow + begin, 0, n);; 1114 memset(fEYhigh + begin, 0, n);; 1115}; 1116 ; 1117 ; 1118////////////////////////////////////////////////////////////////////////////////; 1119/// Returns the combined error along X at point i by computing the average; 1120/// of the lower and upper variance.; 1121 ; 1122Double_t TGraphAsymmErrors::GetErrorX(Int_t i) const; 1123{; 1124 if (i < 0 || i >= fNpoints) return -1;; 1125 if (!fEXlow && !fEXhigh) return -1;; 1126 Double_t elow=0, ehigh=0;; 1127 if (fEXlow) elow = fEXlow[i];; 1128 if (fEXhigh) ehigh = fEXhigh[i];; 1129 return TMath::Sqrt(0.5*(elow*elow + ehigh*ehigh));; 1130}; 1131 ; 1132 ; 1133////////////////////////////////////////////////////////////////////////////////; 1134/// Returns the combined error along Y at point i by computing the average; 1135/// of the lower and upper variance.; 1136 ; 1137Double_t TGraphAsymmErrors::GetErrorY(Int_t i) const; 1138{; 1139 if (i < 0 || i >= fNpoints) return -1;; 1140 if (!fEYlow && !fEYhigh) return -1;; 1141 Double_t elow=0, ehigh=0;; 1142 if (fEYlow) elow = fEYlow[i];; 1143 if (fEYhigh) ehigh = fEYhigh[i];; 1144 return TMath::Sqrt(0.5*(elow*elow + ehigh*ehigh));; 1145}; 1146 ; 1147 ; 1148////////////////////////////////////////////////////////////////////////////////; 1149/// Get high error on X.; 1150 ; 1151Double_t TGraphAsymmErrors::GetErrorXhigh(Int_t i) const; 1152{; 1153 if (i<0 || i>fNpoints) return -1;; 1154 if (fEXhigh) return fEXhigh[i];; 1155 return -1;; 1156}; 1157 ; 1158 ; 1159////////////////////////////////////////////////////////////////////////////////; 1160/// Get low error on X.; 1161 ; 1162Double_t TGraphAsymmErrors::GetErrorXlow(Int_t i) const; 1163{; 1164 if (i<0 || i>fNpoints)",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html
https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html:39948,Availability,error,error,39948,"nt i by computing the average; 1120/// of the lower and upper variance.; 1121 ; 1122Double_t TGraphAsymmErrors::GetErrorX(Int_t i) const; 1123{; 1124 if (i < 0 || i >= fNpoints) return -1;; 1125 if (!fEXlow && !fEXhigh) return -1;; 1126 Double_t elow=0, ehigh=0;; 1127 if (fEXlow) elow = fEXlow[i];; 1128 if (fEXhigh) ehigh = fEXhigh[i];; 1129 return TMath::Sqrt(0.5*(elow*elow + ehigh*ehigh));; 1130}; 1131 ; 1132 ; 1133////////////////////////////////////////////////////////////////////////////////; 1134/// Returns the combined error along Y at point i by computing the average; 1135/// of the lower and upper variance.; 1136 ; 1137Double_t TGraphAsymmErrors::GetErrorY(Int_t i) const; 1138{; 1139 if (i < 0 || i >= fNpoints) return -1;; 1140 if (!fEYlow && !fEYhigh) return -1;; 1141 Double_t elow=0, ehigh=0;; 1142 if (fEYlow) elow = fEYlow[i];; 1143 if (fEYhigh) ehigh = fEYhigh[i];; 1144 return TMath::Sqrt(0.5*(elow*elow + ehigh*ehigh));; 1145}; 1146 ; 1147 ; 1148////////////////////////////////////////////////////////////////////////////////; 1149/// Get high error on X.; 1150 ; 1151Double_t TGraphAsymmErrors::GetErrorXhigh(Int_t i) const; 1152{; 1153 if (i<0 || i>fNpoints) return -1;; 1154 if (fEXhigh) return fEXhigh[i];; 1155 return -1;; 1156}; 1157 ; 1158 ; 1159////////////////////////////////////////////////////////////////////////////////; 1160/// Get low error on X.; 1161 ; 1162Double_t TGraphAsymmErrors::GetErrorXlow(Int_t i) const; 1163{; 1164 if (i<0 || i>fNpoints) return -1;; 1165 if (fEXlow) return fEXlow[i];; 1166 return -1;; 1167}; 1168 ; 1169 ; 1170////////////////////////////////////////////////////////////////////////////////; 1171/// Get high error on Y.; 1172 ; 1173Double_t TGraphAsymmErrors::GetErrorYhigh(Int_t i) const; 1174{; 1175 if (i<0 || i>fNpoints) return -1;; 1176 if (fEYhigh) return fEYhigh[i];; 1177 return -1;; 1178}; 1179 ; 1180 ; 1181////////////////////////////////////////////////////////////////////////////////; 1182/// Get low error on ",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html
https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html:40255,Availability,error,error,40255," Double_t elow=0, ehigh=0;; 1127 if (fEXlow) elow = fEXlow[i];; 1128 if (fEXhigh) ehigh = fEXhigh[i];; 1129 return TMath::Sqrt(0.5*(elow*elow + ehigh*ehigh));; 1130}; 1131 ; 1132 ; 1133////////////////////////////////////////////////////////////////////////////////; 1134/// Returns the combined error along Y at point i by computing the average; 1135/// of the lower and upper variance.; 1136 ; 1137Double_t TGraphAsymmErrors::GetErrorY(Int_t i) const; 1138{; 1139 if (i < 0 || i >= fNpoints) return -1;; 1140 if (!fEYlow && !fEYhigh) return -1;; 1141 Double_t elow=0, ehigh=0;; 1142 if (fEYlow) elow = fEYlow[i];; 1143 if (fEYhigh) ehigh = fEYhigh[i];; 1144 return TMath::Sqrt(0.5*(elow*elow + ehigh*ehigh));; 1145}; 1146 ; 1147 ; 1148////////////////////////////////////////////////////////////////////////////////; 1149/// Get high error on X.; 1150 ; 1151Double_t TGraphAsymmErrors::GetErrorXhigh(Int_t i) const; 1152{; 1153 if (i<0 || i>fNpoints) return -1;; 1154 if (fEXhigh) return fEXhigh[i];; 1155 return -1;; 1156}; 1157 ; 1158 ; 1159////////////////////////////////////////////////////////////////////////////////; 1160/// Get low error on X.; 1161 ; 1162Double_t TGraphAsymmErrors::GetErrorXlow(Int_t i) const; 1163{; 1164 if (i<0 || i>fNpoints) return -1;; 1165 if (fEXlow) return fEXlow[i];; 1166 return -1;; 1167}; 1168 ; 1169 ; 1170////////////////////////////////////////////////////////////////////////////////; 1171/// Get high error on Y.; 1172 ; 1173Double_t TGraphAsymmErrors::GetErrorYhigh(Int_t i) const; 1174{; 1175 if (i<0 || i>fNpoints) return -1;; 1176 if (fEYhigh) return fEYhigh[i];; 1177 return -1;; 1178}; 1179 ; 1180 ; 1181////////////////////////////////////////////////////////////////////////////////; 1182/// Get low error on Y.; 1183 ; 1184Double_t TGraphAsymmErrors::GetErrorYlow(Int_t i) const; 1185{; 1186 if (i<0 || i>fNpoints) return -1;; 1187 if (fEYlow) return fEYlow[i];; 1188 return -1;; 1189}; 1190 ; 1191 ; 1192////////////////////////////////////////",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html
https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html:40560,Availability,error,error,40560,"g Y at point i by computing the average; 1135/// of the lower and upper variance.; 1136 ; 1137Double_t TGraphAsymmErrors::GetErrorY(Int_t i) const; 1138{; 1139 if (i < 0 || i >= fNpoints) return -1;; 1140 if (!fEYlow && !fEYhigh) return -1;; 1141 Double_t elow=0, ehigh=0;; 1142 if (fEYlow) elow = fEYlow[i];; 1143 if (fEYhigh) ehigh = fEYhigh[i];; 1144 return TMath::Sqrt(0.5*(elow*elow + ehigh*ehigh));; 1145}; 1146 ; 1147 ; 1148////////////////////////////////////////////////////////////////////////////////; 1149/// Get high error on X.; 1150 ; 1151Double_t TGraphAsymmErrors::GetErrorXhigh(Int_t i) const; 1152{; 1153 if (i<0 || i>fNpoints) return -1;; 1154 if (fEXhigh) return fEXhigh[i];; 1155 return -1;; 1156}; 1157 ; 1158 ; 1159////////////////////////////////////////////////////////////////////////////////; 1160/// Get low error on X.; 1161 ; 1162Double_t TGraphAsymmErrors::GetErrorXlow(Int_t i) const; 1163{; 1164 if (i<0 || i>fNpoints) return -1;; 1165 if (fEXlow) return fEXlow[i];; 1166 return -1;; 1167}; 1168 ; 1169 ; 1170////////////////////////////////////////////////////////////////////////////////; 1171/// Get high error on Y.; 1172 ; 1173Double_t TGraphAsymmErrors::GetErrorYhigh(Int_t i) const; 1174{; 1175 if (i<0 || i>fNpoints) return -1;; 1176 if (fEYhigh) return fEYhigh[i];; 1177 return -1;; 1178}; 1179 ; 1180 ; 1181////////////////////////////////////////////////////////////////////////////////; 1182/// Get low error on Y.; 1183 ; 1184Double_t TGraphAsymmErrors::GetErrorYlow(Int_t i) const; 1185{; 1186 if (i<0 || i>fNpoints) return -1;; 1187 if (fEYlow) return fEYlow[i];; 1188 return -1;; 1189}; 1190 ; 1191 ; 1192////////////////////////////////////////////////////////////////////////////////; 1193/// Adds all graphs with asymmetric errors from the collection to this graph.; 1194/// Returns the total number of points in the result or -1 in case of an error.; 1195 ; 1196Int_t TGraphAsymmErrors::Merge(TCollection* li); 1197{; 1198 TIter next(li);; 1199 wh",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html
https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html:40867,Availability,error,error,40867,"];; 1143 if (fEYhigh) ehigh = fEYhigh[i];; 1144 return TMath::Sqrt(0.5*(elow*elow + ehigh*ehigh));; 1145}; 1146 ; 1147 ; 1148////////////////////////////////////////////////////////////////////////////////; 1149/// Get high error on X.; 1150 ; 1151Double_t TGraphAsymmErrors::GetErrorXhigh(Int_t i) const; 1152{; 1153 if (i<0 || i>fNpoints) return -1;; 1154 if (fEXhigh) return fEXhigh[i];; 1155 return -1;; 1156}; 1157 ; 1158 ; 1159////////////////////////////////////////////////////////////////////////////////; 1160/// Get low error on X.; 1161 ; 1162Double_t TGraphAsymmErrors::GetErrorXlow(Int_t i) const; 1163{; 1164 if (i<0 || i>fNpoints) return -1;; 1165 if (fEXlow) return fEXlow[i];; 1166 return -1;; 1167}; 1168 ; 1169 ; 1170////////////////////////////////////////////////////////////////////////////////; 1171/// Get high error on Y.; 1172 ; 1173Double_t TGraphAsymmErrors::GetErrorYhigh(Int_t i) const; 1174{; 1175 if (i<0 || i>fNpoints) return -1;; 1176 if (fEYhigh) return fEYhigh[i];; 1177 return -1;; 1178}; 1179 ; 1180 ; 1181////////////////////////////////////////////////////////////////////////////////; 1182/// Get low error on Y.; 1183 ; 1184Double_t TGraphAsymmErrors::GetErrorYlow(Int_t i) const; 1185{; 1186 if (i<0 || i>fNpoints) return -1;; 1187 if (fEYlow) return fEYlow[i];; 1188 return -1;; 1189}; 1190 ; 1191 ; 1192////////////////////////////////////////////////////////////////////////////////; 1193/// Adds all graphs with asymmetric errors from the collection to this graph.; 1194/// Returns the total number of points in the result or -1 in case of an error.; 1195 ; 1196Int_t TGraphAsymmErrors::Merge(TCollection* li); 1197{; 1198 TIter next(li);; 1199 while (TObject* o = next()) {; 1200 TGraph *g = dynamic_cast<TGraph*>(o);; 1201 if (!g) {; 1202 Error(""Merge"",; 1203 ""Cannot merge - an object which doesn't inherit from TGraph found in the list"");; 1204 return -1;; 1205 }; 1206 int n0 = GetN();; 1207 int n1 = n0+g->GetN();; 1208 Set(n1);; 1209 Double_t * x",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html
https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html:41195,Availability,error,errors,41195,"points) return -1;; 1154 if (fEXhigh) return fEXhigh[i];; 1155 return -1;; 1156}; 1157 ; 1158 ; 1159////////////////////////////////////////////////////////////////////////////////; 1160/// Get low error on X.; 1161 ; 1162Double_t TGraphAsymmErrors::GetErrorXlow(Int_t i) const; 1163{; 1164 if (i<0 || i>fNpoints) return -1;; 1165 if (fEXlow) return fEXlow[i];; 1166 return -1;; 1167}; 1168 ; 1169 ; 1170////////////////////////////////////////////////////////////////////////////////; 1171/// Get high error on Y.; 1172 ; 1173Double_t TGraphAsymmErrors::GetErrorYhigh(Int_t i) const; 1174{; 1175 if (i<0 || i>fNpoints) return -1;; 1176 if (fEYhigh) return fEYhigh[i];; 1177 return -1;; 1178}; 1179 ; 1180 ; 1181////////////////////////////////////////////////////////////////////////////////; 1182/// Get low error on Y.; 1183 ; 1184Double_t TGraphAsymmErrors::GetErrorYlow(Int_t i) const; 1185{; 1186 if (i<0 || i>fNpoints) return -1;; 1187 if (fEYlow) return fEYlow[i];; 1188 return -1;; 1189}; 1190 ; 1191 ; 1192////////////////////////////////////////////////////////////////////////////////; 1193/// Adds all graphs with asymmetric errors from the collection to this graph.; 1194/// Returns the total number of points in the result or -1 in case of an error.; 1195 ; 1196Int_t TGraphAsymmErrors::Merge(TCollection* li); 1197{; 1198 TIter next(li);; 1199 while (TObject* o = next()) {; 1200 TGraph *g = dynamic_cast<TGraph*>(o);; 1201 if (!g) {; 1202 Error(""Merge"",; 1203 ""Cannot merge - an object which doesn't inherit from TGraph found in the list"");; 1204 return -1;; 1205 }; 1206 int n0 = GetN();; 1207 int n1 = n0+g->GetN();; 1208 Set(n1);; 1209 Double_t * x = g->GetX();; 1210 Double_t * y = g->GetY();; 1211 Double_t * exlow = g->GetEXlow();; 1212 Double_t * exhigh = g->GetEXhigh();; 1213 Double_t * eylow = g->GetEYlow();; 1214 Double_t * eyhigh = g->GetEYhigh();; 1215 for (Int_t i = 0 ; i < g->GetN(); i++) {; 1216 SetPoint(n0+i, x[i], y[i]);; 1217 if (exlow) fEXlow[n0+i] = exlow[i];",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html
https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html:41315,Availability,error,error,41315,"2Double_t TGraphAsymmErrors::GetErrorXlow(Int_t i) const; 1163{; 1164 if (i<0 || i>fNpoints) return -1;; 1165 if (fEXlow) return fEXlow[i];; 1166 return -1;; 1167}; 1168 ; 1169 ; 1170////////////////////////////////////////////////////////////////////////////////; 1171/// Get high error on Y.; 1172 ; 1173Double_t TGraphAsymmErrors::GetErrorYhigh(Int_t i) const; 1174{; 1175 if (i<0 || i>fNpoints) return -1;; 1176 if (fEYhigh) return fEYhigh[i];; 1177 return -1;; 1178}; 1179 ; 1180 ; 1181////////////////////////////////////////////////////////////////////////////////; 1182/// Get low error on Y.; 1183 ; 1184Double_t TGraphAsymmErrors::GetErrorYlow(Int_t i) const; 1185{; 1186 if (i<0 || i>fNpoints) return -1;; 1187 if (fEYlow) return fEYlow[i];; 1188 return -1;; 1189}; 1190 ; 1191 ; 1192////////////////////////////////////////////////////////////////////////////////; 1193/// Adds all graphs with asymmetric errors from the collection to this graph.; 1194/// Returns the total number of points in the result or -1 in case of an error.; 1195 ; 1196Int_t TGraphAsymmErrors::Merge(TCollection* li); 1197{; 1198 TIter next(li);; 1199 while (TObject* o = next()) {; 1200 TGraph *g = dynamic_cast<TGraph*>(o);; 1201 if (!g) {; 1202 Error(""Merge"",; 1203 ""Cannot merge - an object which doesn't inherit from TGraph found in the list"");; 1204 return -1;; 1205 }; 1206 int n0 = GetN();; 1207 int n1 = n0+g->GetN();; 1208 Set(n1);; 1209 Double_t * x = g->GetX();; 1210 Double_t * y = g->GetY();; 1211 Double_t * exlow = g->GetEXlow();; 1212 Double_t * exhigh = g->GetEXhigh();; 1213 Double_t * eylow = g->GetEYlow();; 1214 Double_t * eyhigh = g->GetEYhigh();; 1215 for (Int_t i = 0 ; i < g->GetN(); i++) {; 1216 SetPoint(n0+i, x[i], y[i]);; 1217 if (exlow) fEXlow[n0+i] = exlow[i];; 1218 if (exhigh) fEXhigh[n0+i] = exhigh[i];; 1219 if (eylow) fEYlow[n0+i] = eylow[i];; 1220 if (eyhigh) fEYhigh[n0+i] = eyhigh[i];; 1221 }; 1222 }; 1223 return GetN();; 1224}; 1225 ; 1226/////////////////////////////////",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html
https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html:42352,Availability,error,errors,42352,"//////; 1182/// Get low error on Y.; 1183 ; 1184Double_t TGraphAsymmErrors::GetErrorYlow(Int_t i) const; 1185{; 1186 if (i<0 || i>fNpoints) return -1;; 1187 if (fEYlow) return fEYlow[i];; 1188 return -1;; 1189}; 1190 ; 1191 ; 1192////////////////////////////////////////////////////////////////////////////////; 1193/// Adds all graphs with asymmetric errors from the collection to this graph.; 1194/// Returns the total number of points in the result or -1 in case of an error.; 1195 ; 1196Int_t TGraphAsymmErrors::Merge(TCollection* li); 1197{; 1198 TIter next(li);; 1199 while (TObject* o = next()) {; 1200 TGraph *g = dynamic_cast<TGraph*>(o);; 1201 if (!g) {; 1202 Error(""Merge"",; 1203 ""Cannot merge - an object which doesn't inherit from TGraph found in the list"");; 1204 return -1;; 1205 }; 1206 int n0 = GetN();; 1207 int n1 = n0+g->GetN();; 1208 Set(n1);; 1209 Double_t * x = g->GetX();; 1210 Double_t * y = g->GetY();; 1211 Double_t * exlow = g->GetEXlow();; 1212 Double_t * exhigh = g->GetEXhigh();; 1213 Double_t * eylow = g->GetEYlow();; 1214 Double_t * eyhigh = g->GetEYhigh();; 1215 for (Int_t i = 0 ; i < g->GetN(); i++) {; 1216 SetPoint(n0+i, x[i], y[i]);; 1217 if (exlow) fEXlow[n0+i] = exlow[i];; 1218 if (exhigh) fEXhigh[n0+i] = exhigh[i];; 1219 if (eylow) fEYlow[n0+i] = eylow[i];; 1220 if (eyhigh) fEYhigh[n0+i] = eyhigh[i];; 1221 }; 1222 }; 1223 return GetN();; 1224}; 1225 ; 1226////////////////////////////////////////////////////////////////////////////////; 1227/// Print graph and errors values.; 1228 ; 1229void TGraphAsymmErrors::Print(Option_t *) const; 1230{; 1231 for (Int_t i=0;i<fNpoints;i++) {; 1232 printf(""x[%d]=%g, y[%d]=%g, exl[%d]=%g, exh[%d]=%g, eyl[%d]=%g, eyh[%d]=%g\n""; 1233 ,i,fX[i],i,fY[i],i,fEXlow[i],i,fEXhigh[i],i,fEYlow[i],i,fEYhigh[i]);; 1234 }; 1235}; 1236 ; 1237 ; 1238////////////////////////////////////////////////////////////////////////////////; 1239/// Save primitive as a C++ statement(s) on output stream out.; 1240 ; 1241void TGraphAsymmE",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html
https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html:43951,Availability,error,errors,43951,"nt(Option_t *) const; 1230{; 1231 for (Int_t i=0;i<fNpoints;i++) {; 1232 printf(""x[%d]=%g, y[%d]=%g, exl[%d]=%g, exh[%d]=%g, eyl[%d]=%g, eyh[%d]=%g\n""; 1233 ,i,fX[i],i,fY[i],i,fEXlow[i],i,fEXhigh[i],i,fEYlow[i],i,fEYhigh[i]);; 1234 }; 1235}; 1236 ; 1237 ; 1238////////////////////////////////////////////////////////////////////////////////; 1239/// Save primitive as a C++ statement(s) on output stream out.; 1240 ; 1241void TGraphAsymmErrors::SavePrimitive(std::ostream &out, Option_t *option /*= """"*/); 1242{; 1243 out << "" "" << std::endl;; 1244 static Int_t frameNumber = 3000;; 1245 frameNumber++;; 1246 ; 1247 auto fXName = SaveArray(out, ""fx"", frameNumber, fX);; 1248 auto fYName = SaveArray(out, ""fy"", frameNumber, fY);; 1249 auto fElXName = SaveArray(out, ""felx"", frameNumber, fEXlow);; 1250 auto fElYName = SaveArray(out, ""fely"", frameNumber, fEYlow);; 1251 auto fEhXName = SaveArray(out, ""fehx"", frameNumber, fEXhigh);; 1252 auto fEhYName = SaveArray(out, ""fehy"", frameNumber, fEYhigh);; 1253 ; 1254 if (gROOT->ClassSaved(TGraphAsymmErrors::Class())); 1255 out<<"" "";; 1256 else; 1257 out << "" TGraphAsymmErrors *"";; 1258 out << ""grae = new TGraphAsymmErrors(""<< fNpoints << "",""; 1259 << fXName << "","" << fYName << "",""; 1260 << fElXName << "","" << fEhXName << "",""; 1261 << fElYName << "","" << fEhYName << "");""; 1262 << std::endl;; 1263 ; 1264 SaveHistogramAndFunctions(out, ""grae"", frameNumber, option);; 1265}; 1266 ; 1267////////////////////////////////////////////////////////////////////////////////; 1268/// Multiply the values and errors of a TGraphAsymmErrors by a constant c1.; 1269///; 1270/// If option contains ""x"" the x values and errors are scaled; 1271/// If option contains ""y"" the y values and errors are scaled; 1272/// If option contains ""xy"" both x and y values and errors are scaled; 1273 ; 1274void TGraphAsymmErrors::Scale(Double_t c1, Option_t *option); 1275{; 1276 TGraph::Scale(c1, option);; 1277 TString opt = option; opt.ToLower();; 1278 if (opt.Contains(""x"") && Ge",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html
https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html:44057,Availability,error,errors,44057,"rameNumber, fEXlow);; 1250 auto fElYName = SaveArray(out, ""fely"", frameNumber, fEYlow);; 1251 auto fEhXName = SaveArray(out, ""fehx"", frameNumber, fEXhigh);; 1252 auto fEhYName = SaveArray(out, ""fehy"", frameNumber, fEYhigh);; 1253 ; 1254 if (gROOT->ClassSaved(TGraphAsymmErrors::Class())); 1255 out<<"" "";; 1256 else; 1257 out << "" TGraphAsymmErrors *"";; 1258 out << ""grae = new TGraphAsymmErrors(""<< fNpoints << "",""; 1259 << fXName << "","" << fYName << "",""; 1260 << fElXName << "","" << fEhXName << "",""; 1261 << fElYName << "","" << fEhYName << "");""; 1262 << std::endl;; 1263 ; 1264 SaveHistogramAndFunctions(out, ""grae"", frameNumber, option);; 1265}; 1266 ; 1267////////////////////////////////////////////////////////////////////////////////; 1268/// Multiply the values and errors of a TGraphAsymmErrors by a constant c1.; 1269///; 1270/// If option contains ""x"" the x values and errors are scaled; 1271/// If option contains ""y"" the y values and errors are scaled; 1272/// If option contains ""xy"" both x and y values and errors are scaled; 1273 ; 1274void TGraphAsymmErrors::Scale(Double_t c1, Option_t *option); 1275{; 1276 TGraph::Scale(c1, option);; 1277 TString opt = option; opt.ToLower();; 1278 if (opt.Contains(""x"") && GetEXlow()) {; 1279 for (Int_t i=0; i<GetN(); i++); 1280 GetEXlow()[i] *= c1;; 1281 }; 1282 if (opt.Contains(""x"") && GetEXhigh()) {; 1283 for (Int_t i=0; i<GetN(); i++); 1284 GetEXhigh()[i] *= c1;; 1285 }; 1286 if (opt.Contains(""y"") && GetEYlow()) {; 1287 for (Int_t i=0; i<GetN(); i++); 1288 GetEYlow()[i] *= c1;; 1289 }; 1290 if (opt.Contains(""y"") && GetEYhigh()) {; 1291 for (Int_t i=0; i<GetN(); i++); 1292 GetEYhigh()[i] *= c1;; 1293 }; 1294}; 1295 ; 1296////////////////////////////////////////////////////////////////////////////////; 1297/// Set ex and ey values for point pointed by the mouse.; 1298 ; 1299void TGraphAsymmErrors::SetPointError(Double_t exl, Double_t exh, Double_t eyl, Double_t eyh); 1300{; 1301 if (!gPad) {; 1302 Error(""SetPointError"", ""Cannot be u",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html
https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html:44124,Availability,error,errors,44124,"rameNumber, fEXlow);; 1250 auto fElYName = SaveArray(out, ""fely"", frameNumber, fEYlow);; 1251 auto fEhXName = SaveArray(out, ""fehx"", frameNumber, fEXhigh);; 1252 auto fEhYName = SaveArray(out, ""fehy"", frameNumber, fEYhigh);; 1253 ; 1254 if (gROOT->ClassSaved(TGraphAsymmErrors::Class())); 1255 out<<"" "";; 1256 else; 1257 out << "" TGraphAsymmErrors *"";; 1258 out << ""grae = new TGraphAsymmErrors(""<< fNpoints << "",""; 1259 << fXName << "","" << fYName << "",""; 1260 << fElXName << "","" << fEhXName << "",""; 1261 << fElYName << "","" << fEhYName << "");""; 1262 << std::endl;; 1263 ; 1264 SaveHistogramAndFunctions(out, ""grae"", frameNumber, option);; 1265}; 1266 ; 1267////////////////////////////////////////////////////////////////////////////////; 1268/// Multiply the values and errors of a TGraphAsymmErrors by a constant c1.; 1269///; 1270/// If option contains ""x"" the x values and errors are scaled; 1271/// If option contains ""y"" the y values and errors are scaled; 1272/// If option contains ""xy"" both x and y values and errors are scaled; 1273 ; 1274void TGraphAsymmErrors::Scale(Double_t c1, Option_t *option); 1275{; 1276 TGraph::Scale(c1, option);; 1277 TString opt = option; opt.ToLower();; 1278 if (opt.Contains(""x"") && GetEXlow()) {; 1279 for (Int_t i=0; i<GetN(); i++); 1280 GetEXlow()[i] *= c1;; 1281 }; 1282 if (opt.Contains(""x"") && GetEXhigh()) {; 1283 for (Int_t i=0; i<GetN(); i++); 1284 GetEXhigh()[i] *= c1;; 1285 }; 1286 if (opt.Contains(""y"") && GetEYlow()) {; 1287 for (Int_t i=0; i<GetN(); i++); 1288 GetEYlow()[i] *= c1;; 1289 }; 1290 if (opt.Contains(""y"") && GetEYhigh()) {; 1291 for (Int_t i=0; i<GetN(); i++); 1292 GetEYhigh()[i] *= c1;; 1293 }; 1294}; 1295 ; 1296////////////////////////////////////////////////////////////////////////////////; 1297/// Set ex and ey values for point pointed by the mouse.; 1298 ; 1299void TGraphAsymmErrors::SetPointError(Double_t exl, Double_t exh, Double_t eyl, Double_t eyh); 1300{; 1301 if (!gPad) {; 1302 Error(""SetPointError"", ""Cannot be u",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html
https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html:44199,Availability,error,errors,44199,"rameNumber, fEXlow);; 1250 auto fElYName = SaveArray(out, ""fely"", frameNumber, fEYlow);; 1251 auto fEhXName = SaveArray(out, ""fehx"", frameNumber, fEXhigh);; 1252 auto fEhYName = SaveArray(out, ""fehy"", frameNumber, fEYhigh);; 1253 ; 1254 if (gROOT->ClassSaved(TGraphAsymmErrors::Class())); 1255 out<<"" "";; 1256 else; 1257 out << "" TGraphAsymmErrors *"";; 1258 out << ""grae = new TGraphAsymmErrors(""<< fNpoints << "",""; 1259 << fXName << "","" << fYName << "",""; 1260 << fElXName << "","" << fEhXName << "",""; 1261 << fElYName << "","" << fEhYName << "");""; 1262 << std::endl;; 1263 ; 1264 SaveHistogramAndFunctions(out, ""grae"", frameNumber, option);; 1265}; 1266 ; 1267////////////////////////////////////////////////////////////////////////////////; 1268/// Multiply the values and errors of a TGraphAsymmErrors by a constant c1.; 1269///; 1270/// If option contains ""x"" the x values and errors are scaled; 1271/// If option contains ""y"" the y values and errors are scaled; 1272/// If option contains ""xy"" both x and y values and errors are scaled; 1273 ; 1274void TGraphAsymmErrors::Scale(Double_t c1, Option_t *option); 1275{; 1276 TGraph::Scale(c1, option);; 1277 TString opt = option; opt.ToLower();; 1278 if (opt.Contains(""x"") && GetEXlow()) {; 1279 for (Int_t i=0; i<GetN(); i++); 1280 GetEXlow()[i] *= c1;; 1281 }; 1282 if (opt.Contains(""x"") && GetEXhigh()) {; 1283 for (Int_t i=0; i<GetN(); i++); 1284 GetEXhigh()[i] *= c1;; 1285 }; 1286 if (opt.Contains(""y"") && GetEYlow()) {; 1287 for (Int_t i=0; i<GetN(); i++); 1288 GetEYlow()[i] *= c1;; 1289 }; 1290 if (opt.Contains(""y"") && GetEYhigh()) {; 1291 for (Int_t i=0; i<GetN(); i++); 1292 GetEYhigh()[i] *= c1;; 1293 }; 1294}; 1295 ; 1296////////////////////////////////////////////////////////////////////////////////; 1297/// Set ex and ey values for point pointed by the mouse.; 1298 ; 1299void TGraphAsymmErrors::SetPointError(Double_t exl, Double_t exh, Double_t eyl, Double_t eyh); 1300{; 1301 if (!gPad) {; 1302 Error(""SetPointError"", ""Cannot be u",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html
https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html:50617,Availability,error,error,50617,"unt(R__s, R__c, TGraphAsymmErrors::IsA());; 1445 //====end of old versions; 1446 ; 1447 } else {; 1448 b.WriteClassBuffer(TGraphAsymmErrors::Class(),this);; 1449 }; 1450}; 1451 ; 1452 ; 1453////////////////////////////////////////////////////////////////////////////////; 1454/// Swap points.; 1455 ; 1456void TGraphAsymmErrors::SwapPoints(Int_t pos1, Int_t pos2); 1457{; 1458 SwapValues(fEXlow, pos1, pos2);; 1459 SwapValues(fEXhigh, pos1, pos2);; 1460 SwapValues(fEYlow, pos1, pos2);; 1461 SwapValues(fEYhigh, pos1, pos2);; 1462 TGraph::SwapPoints(pos1, pos2);; 1463}; 1464 ; 1465////////////////////////////////////////////////////////////////////////////////; 1466/// Update the fX, fY, fEXlow, fEXhigh, fEYlow and fEYhigh arrays with the sorted values.; 1467 ; 1468void TGraphAsymmErrors::UpdateArrays(const std::vector<Int_t> &sorting_indices, Int_t numSortedPoints, Int_t low); 1469{; 1470 std::vector<Double_t> fEXlowSorted(numSortedPoints);; 1471 std::vector<Double_t> fEXhighSorted(numSortedPoints);; 1472 std::vector<Double_t> fEYlowSorted(numSortedPoints);; 1473 std::vector<Double_t> fEYhighSorted(numSortedPoints);; 1474 ; 1475 // Fill the sorted X and Y error values based on the sorted indices; 1476 std::generate(fEXlowSorted.begin(), fEXlowSorted.end(),; 1477 [begin = low, &sorting_indices, this]() mutable { return fEXlow[sorting_indices[begin++]]; });; 1478 std::generate(fEXhighSorted.begin(), fEXhighSorted.end(),; 1479 [begin = low, &sorting_indices, this]() mutable { return fEXhigh[sorting_indices[begin++]]; });; 1480 std::generate(fEYlowSorted.begin(), fEYlowSorted.end(),; 1481 [begin = low, &sorting_indices, this]() mutable { return fEYlow[sorting_indices[begin++]]; });; 1482 std::generate(fEYhighSorted.begin(), fEYhighSorted.end(),; 1483 [begin = low, &sorting_indices, this]() mutable { return fEYhigh[sorting_indices[begin++]]; });; 1484 ; 1485 // Copy the sorted X and Y error values back to the original arrays; 1486 std::copy(fEXlowSorted.begin(), fEXlowSorted.",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html
https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html:51356,Availability,error,error,51356,"nts, Int_t low); 1469{; 1470 std::vector<Double_t> fEXlowSorted(numSortedPoints);; 1471 std::vector<Double_t> fEXhighSorted(numSortedPoints);; 1472 std::vector<Double_t> fEYlowSorted(numSortedPoints);; 1473 std::vector<Double_t> fEYhighSorted(numSortedPoints);; 1474 ; 1475 // Fill the sorted X and Y error values based on the sorted indices; 1476 std::generate(fEXlowSorted.begin(), fEXlowSorted.end(),; 1477 [begin = low, &sorting_indices, this]() mutable { return fEXlow[sorting_indices[begin++]]; });; 1478 std::generate(fEXhighSorted.begin(), fEXhighSorted.end(),; 1479 [begin = low, &sorting_indices, this]() mutable { return fEXhigh[sorting_indices[begin++]]; });; 1480 std::generate(fEYlowSorted.begin(), fEYlowSorted.end(),; 1481 [begin = low, &sorting_indices, this]() mutable { return fEYlow[sorting_indices[begin++]]; });; 1482 std::generate(fEYhighSorted.begin(), fEYhighSorted.end(),; 1483 [begin = low, &sorting_indices, this]() mutable { return fEYhigh[sorting_indices[begin++]]; });; 1484 ; 1485 // Copy the sorted X and Y error values back to the original arrays; 1486 std::copy(fEXlowSorted.begin(), fEXlowSorted.end(), fEXlow + low);; 1487 std::copy(fEXhighSorted.begin(), fEXhighSorted.end(), fEXhigh + low);; 1488 std::copy(fEYlowSorted.begin(), fEYlowSorted.end(), fEYlow + low);; 1489 std::copy(fEYhighSorted.begin(), fEYhighSorted.end(), fEYhigh + low);; 1490 ; 1491 TGraph::UpdateArrays(sorting_indices, numSortedPoints, low);; 1492}; QuantFuncMathCore.h; b#define b(i)Definition RSha256.hxx:100; f#define f(i)Definition RSha256.hxx:104; g#define g(i)Definition RSha256.hxx:105; a#define a(i)Definition RSha256.hxx:99; h#define h(i)Definition RSha256.hxx:106; e#define e(i)Definition RSha256.hxx:103; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; Bool_tbool Bool_tDefinition RtypesCore.h:63; Version_tshort Version_tDefinition RtypesCore.h:65; Float_tfloat Float_tDefinition RtypesCore.h:57; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html
https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html:58394,Availability,error,error,58394,"omial interval (Lancaster method) from B.Definition TEfficiency.cxx:1230; TEfficiency::Normalstatic Double_t Normal(Double_t total, Double_t passed, Double_t level, Bool_t bUpper)Returns the confidence limits for the efficiency supposing that the efficiency follows a normal distr...Definition TEfficiency.cxx:2952; TEfficiency::Wilsonstatic Double_t Wilson(Double_t total, Double_t passed, Double_t level, Bool_t bUpper)Calculates the boundaries for the frequentist Wilson interval.Definition TEfficiency.cxx:3873; TEfficiency::CheckConsistencystatic Bool_t CheckConsistency(const TH1 &pass, const TH1 &total, Option_t *opt="""")Checks the consistence of the given histograms.Definition TEfficiency.cxx:1576; TEfficiency::ClopperPearsonstatic Double_t ClopperPearson(Double_t total, Double_t passed, Double_t level, Bool_t bUpper)Calculates the boundaries for the frequentist Clopper-Pearson interval.Definition TEfficiency.cxx:2016; TF11-Dim function classDefinition TF1.h:233; TGraphAsymmErrorsTGraph with asymmetric error bars.Definition TGraphAsymmErrors.h:26; TGraphAsymmErrors::GetEXlowDouble_t * GetEXlow() const overrideDefinition TGraphAsymmErrors.h:74; TGraphAsymmErrors::SetPointEYlowvirtual void SetPointEYlow(Int_t i, Double_t eyl)Set EYlow for point i.Definition TGraphAsymmErrors.cxx:1376; TGraphAsymmErrors::fEXhighDouble_t * fEXhigh[fNpoints] array of X high errorsDefinition TGraphAsymmErrors.h:30; TGraphAsymmErrors::GetErrorYDouble_t GetErrorY(Int_t bin) const overrideReturns the combined error along Y at point i by computing the average of the lower and upper varianc...Definition TGraphAsymmErrors.cxx:1137; TGraphAsymmErrors::FillZerovoid FillZero(Int_t begin, Int_t end, Bool_t from_ctor=kTRUE) overrideSet zero values for point arrays in the range [begin, end]Definition TGraphAsymmErrors.cxx:1104; TGraphAsymmErrors::Dividevirtual void Divide(const TH1 *pass, const TH1 *total, Option_t *opt=""cp"")Fill this TGraphAsymmErrors by dividing two 1-dimensional histograms pass/to",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html
https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html:58751,Availability,error,errorsDefinition,58751,"ilson(Double_t total, Double_t passed, Double_t level, Bool_t bUpper)Calculates the boundaries for the frequentist Wilson interval.Definition TEfficiency.cxx:3873; TEfficiency::CheckConsistencystatic Bool_t CheckConsistency(const TH1 &pass, const TH1 &total, Option_t *opt="""")Checks the consistence of the given histograms.Definition TEfficiency.cxx:1576; TEfficiency::ClopperPearsonstatic Double_t ClopperPearson(Double_t total, Double_t passed, Double_t level, Bool_t bUpper)Calculates the boundaries for the frequentist Clopper-Pearson interval.Definition TEfficiency.cxx:2016; TF11-Dim function classDefinition TF1.h:233; TGraphAsymmErrorsTGraph with asymmetric error bars.Definition TGraphAsymmErrors.h:26; TGraphAsymmErrors::GetEXlowDouble_t * GetEXlow() const overrideDefinition TGraphAsymmErrors.h:74; TGraphAsymmErrors::SetPointEYlowvirtual void SetPointEYlow(Int_t i, Double_t eyl)Set EYlow for point i.Definition TGraphAsymmErrors.cxx:1376; TGraphAsymmErrors::fEXhighDouble_t * fEXhigh[fNpoints] array of X high errorsDefinition TGraphAsymmErrors.h:30; TGraphAsymmErrors::GetErrorYDouble_t GetErrorY(Int_t bin) const overrideReturns the combined error along Y at point i by computing the average of the lower and upper varianc...Definition TGraphAsymmErrors.cxx:1137; TGraphAsymmErrors::FillZerovoid FillZero(Int_t begin, Int_t end, Bool_t from_ctor=kTRUE) overrideSet zero values for point arrays in the range [begin, end]Definition TGraphAsymmErrors.cxx:1104; TGraphAsymmErrors::Dividevirtual void Divide(const TH1 *pass, const TH1 *total, Option_t *opt=""cp"")Fill this TGraphAsymmErrors by dividing two 1-dimensional histograms pass/total.Definition TGraphAsymmErrors.cxx:588; TGraphAsymmErrors::CtorAllocateBool_t CtorAllocate()Should be called from ctors after fNpoints has been set.Definition TGraphAsymmErrors.cxx:1061; TGraphAsymmErrors::Classstatic TClass * Class(); TGraphAsymmErrors::SetPointErrorvirtual void SetPointError(Double_t exl, Double_t exh, Double_t eyl, Double_t eyh)",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html
https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html:58885,Availability,error,error,58885,"iency.cxx:3873; TEfficiency::CheckConsistencystatic Bool_t CheckConsistency(const TH1 &pass, const TH1 &total, Option_t *opt="""")Checks the consistence of the given histograms.Definition TEfficiency.cxx:1576; TEfficiency::ClopperPearsonstatic Double_t ClopperPearson(Double_t total, Double_t passed, Double_t level, Bool_t bUpper)Calculates the boundaries for the frequentist Clopper-Pearson interval.Definition TEfficiency.cxx:2016; TF11-Dim function classDefinition TF1.h:233; TGraphAsymmErrorsTGraph with asymmetric error bars.Definition TGraphAsymmErrors.h:26; TGraphAsymmErrors::GetEXlowDouble_t * GetEXlow() const overrideDefinition TGraphAsymmErrors.h:74; TGraphAsymmErrors::SetPointEYlowvirtual void SetPointEYlow(Int_t i, Double_t eyl)Set EYlow for point i.Definition TGraphAsymmErrors.cxx:1376; TGraphAsymmErrors::fEXhighDouble_t * fEXhigh[fNpoints] array of X high errorsDefinition TGraphAsymmErrors.h:30; TGraphAsymmErrors::GetErrorYDouble_t GetErrorY(Int_t bin) const overrideReturns the combined error along Y at point i by computing the average of the lower and upper varianc...Definition TGraphAsymmErrors.cxx:1137; TGraphAsymmErrors::FillZerovoid FillZero(Int_t begin, Int_t end, Bool_t from_ctor=kTRUE) overrideSet zero values for point arrays in the range [begin, end]Definition TGraphAsymmErrors.cxx:1104; TGraphAsymmErrors::Dividevirtual void Divide(const TH1 *pass, const TH1 *total, Option_t *opt=""cp"")Fill this TGraphAsymmErrors by dividing two 1-dimensional histograms pass/total.Definition TGraphAsymmErrors.cxx:588; TGraphAsymmErrors::CtorAllocateBool_t CtorAllocate()Should be called from ctors after fNpoints has been set.Definition TGraphAsymmErrors.cxx:1061; TGraphAsymmErrors::Classstatic TClass * Class(); TGraphAsymmErrors::SetPointErrorvirtual void SetPointError(Double_t exl, Double_t exh, Double_t eyl, Double_t eyh)Set ex and ey values for point pointed by the mouse.Definition TGraphAsymmErrors.cxx:1299; TGraphAsymmErrors::GetErrorXhighDouble_t GetErrorXhigh(In",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html
https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html:59906,Availability,error,error,59906,"eReturns the combined error along Y at point i by computing the average of the lower and upper varianc...Definition TGraphAsymmErrors.cxx:1137; TGraphAsymmErrors::FillZerovoid FillZero(Int_t begin, Int_t end, Bool_t from_ctor=kTRUE) overrideSet zero values for point arrays in the range [begin, end]Definition TGraphAsymmErrors.cxx:1104; TGraphAsymmErrors::Dividevirtual void Divide(const TH1 *pass, const TH1 *total, Option_t *opt=""cp"")Fill this TGraphAsymmErrors by dividing two 1-dimensional histograms pass/total.Definition TGraphAsymmErrors.cxx:588; TGraphAsymmErrors::CtorAllocateBool_t CtorAllocate()Should be called from ctors after fNpoints has been set.Definition TGraphAsymmErrors.cxx:1061; TGraphAsymmErrors::Classstatic TClass * Class(); TGraphAsymmErrors::SetPointErrorvirtual void SetPointError(Double_t exl, Double_t exh, Double_t eyl, Double_t eyh)Set ex and ey values for point pointed by the mouse.Definition TGraphAsymmErrors.cxx:1299; TGraphAsymmErrors::GetErrorXhighDouble_t GetErrorXhigh(Int_t i) const overrideGet high error on X.Definition TGraphAsymmErrors.cxx:1151; TGraphAsymmErrors::fEYhighDouble_t * fEYhigh[fNpoints] array of Y high errorsDefinition TGraphAsymmErrors.h:32; TGraphAsymmErrors::CopyPointsBool_t CopyPoints(Double_t **arrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy errors from fE*** to arrays[***] or to f*** Copy points.Definition TGraphAsymmErrors.cxx:1033; TGraphAsymmErrors::AddPointErrorvirtual void AddPointError(Double_t x, Double_t y, Double_t exl=0., Double_t exh=0., Double_t eyl=0., Double_t eyh=0.)Add a point with asymmetric errorbars to the graph.Definition TGraphAsymmErrors.cxx:451; TGraphAsymmErrors::ComputeRangevoid ComputeRange(Double_t &xmin, Double_t &ymin, Double_t &xmax, Double_t &ymax) const overrideCompute Range.Definition TGraphAsymmErrors.cxx:977; TGraphAsymmErrors::SetPointEXlowvirtual void SetPointEXlow(Int_t i, Double_t exl)Set EXlow for point i.Definition TGraphAsymmErrors.cxx:1348; TGraphAsymmErrors::St",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html
https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html:60027,Availability,error,errorsDefinition,60027,"7; TGraphAsymmErrors::FillZerovoid FillZero(Int_t begin, Int_t end, Bool_t from_ctor=kTRUE) overrideSet zero values for point arrays in the range [begin, end]Definition TGraphAsymmErrors.cxx:1104; TGraphAsymmErrors::Dividevirtual void Divide(const TH1 *pass, const TH1 *total, Option_t *opt=""cp"")Fill this TGraphAsymmErrors by dividing two 1-dimensional histograms pass/total.Definition TGraphAsymmErrors.cxx:588; TGraphAsymmErrors::CtorAllocateBool_t CtorAllocate()Should be called from ctors after fNpoints has been set.Definition TGraphAsymmErrors.cxx:1061; TGraphAsymmErrors::Classstatic TClass * Class(); TGraphAsymmErrors::SetPointErrorvirtual void SetPointError(Double_t exl, Double_t exh, Double_t eyl, Double_t eyh)Set ex and ey values for point pointed by the mouse.Definition TGraphAsymmErrors.cxx:1299; TGraphAsymmErrors::GetErrorXhighDouble_t GetErrorXhigh(Int_t i) const overrideGet high error on X.Definition TGraphAsymmErrors.cxx:1151; TGraphAsymmErrors::fEYhighDouble_t * fEYhigh[fNpoints] array of Y high errorsDefinition TGraphAsymmErrors.h:32; TGraphAsymmErrors::CopyPointsBool_t CopyPoints(Double_t **arrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy errors from fE*** to arrays[***] or to f*** Copy points.Definition TGraphAsymmErrors.cxx:1033; TGraphAsymmErrors::AddPointErrorvirtual void AddPointError(Double_t x, Double_t y, Double_t exl=0., Double_t exh=0., Double_t eyl=0., Double_t eyh=0.)Add a point with asymmetric errorbars to the graph.Definition TGraphAsymmErrors.cxx:451; TGraphAsymmErrors::ComputeRangevoid ComputeRange(Double_t &xmin, Double_t &ymin, Double_t &xmax, Double_t &ymax) const overrideCompute Range.Definition TGraphAsymmErrors.cxx:977; TGraphAsymmErrors::SetPointEXlowvirtual void SetPointEXlow(Int_t i, Double_t exl)Set EXlow for point i.Definition TGraphAsymmErrors.cxx:1348; TGraphAsymmErrors::Streamervoid Streamer(TBuffer &) overrideStream an object of class TGraphAsymmErrors.Definition TGraphAsymmErrors.cxx:1404; TGraphAsymmErrors::",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html
https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html:60187,Availability,error,errors,60187,"egin, end]Definition TGraphAsymmErrors.cxx:1104; TGraphAsymmErrors::Dividevirtual void Divide(const TH1 *pass, const TH1 *total, Option_t *opt=""cp"")Fill this TGraphAsymmErrors by dividing two 1-dimensional histograms pass/total.Definition TGraphAsymmErrors.cxx:588; TGraphAsymmErrors::CtorAllocateBool_t CtorAllocate()Should be called from ctors after fNpoints has been set.Definition TGraphAsymmErrors.cxx:1061; TGraphAsymmErrors::Classstatic TClass * Class(); TGraphAsymmErrors::SetPointErrorvirtual void SetPointError(Double_t exl, Double_t exh, Double_t eyl, Double_t eyh)Set ex and ey values for point pointed by the mouse.Definition TGraphAsymmErrors.cxx:1299; TGraphAsymmErrors::GetErrorXhighDouble_t GetErrorXhigh(Int_t i) const overrideGet high error on X.Definition TGraphAsymmErrors.cxx:1151; TGraphAsymmErrors::fEYhighDouble_t * fEYhigh[fNpoints] array of Y high errorsDefinition TGraphAsymmErrors.h:32; TGraphAsymmErrors::CopyPointsBool_t CopyPoints(Double_t **arrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy errors from fE*** to arrays[***] or to f*** Copy points.Definition TGraphAsymmErrors.cxx:1033; TGraphAsymmErrors::AddPointErrorvirtual void AddPointError(Double_t x, Double_t y, Double_t exl=0., Double_t exh=0., Double_t eyl=0., Double_t eyh=0.)Add a point with asymmetric errorbars to the graph.Definition TGraphAsymmErrors.cxx:451; TGraphAsymmErrors::ComputeRangevoid ComputeRange(Double_t &xmin, Double_t &ymin, Double_t &xmax, Double_t &ymax) const overrideCompute Range.Definition TGraphAsymmErrors.cxx:977; TGraphAsymmErrors::SetPointEXlowvirtual void SetPointEXlow(Int_t i, Double_t exl)Set EXlow for point i.Definition TGraphAsymmErrors.cxx:1348; TGraphAsymmErrors::Streamervoid Streamer(TBuffer &) overrideStream an object of class TGraphAsymmErrors.Definition TGraphAsymmErrors.cxx:1404; TGraphAsymmErrors::SetPointEYhighvirtual void SetPointEYhigh(Int_t i, Double_t eyh)Set EYhigh for point i.Definition TGraphAsymmErrors.cxx:1390; TGraphAsymmErrors::Save",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html
https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html:60460,Availability,error,errorbars,60460,"torAllocate()Should be called from ctors after fNpoints has been set.Definition TGraphAsymmErrors.cxx:1061; TGraphAsymmErrors::Classstatic TClass * Class(); TGraphAsymmErrors::SetPointErrorvirtual void SetPointError(Double_t exl, Double_t exh, Double_t eyl, Double_t eyh)Set ex and ey values for point pointed by the mouse.Definition TGraphAsymmErrors.cxx:1299; TGraphAsymmErrors::GetErrorXhighDouble_t GetErrorXhigh(Int_t i) const overrideGet high error on X.Definition TGraphAsymmErrors.cxx:1151; TGraphAsymmErrors::fEYhighDouble_t * fEYhigh[fNpoints] array of Y high errorsDefinition TGraphAsymmErrors.h:32; TGraphAsymmErrors::CopyPointsBool_t CopyPoints(Double_t **arrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy errors from fE*** to arrays[***] or to f*** Copy points.Definition TGraphAsymmErrors.cxx:1033; TGraphAsymmErrors::AddPointErrorvirtual void AddPointError(Double_t x, Double_t y, Double_t exl=0., Double_t exh=0., Double_t eyl=0., Double_t eyh=0.)Add a point with asymmetric errorbars to the graph.Definition TGraphAsymmErrors.cxx:451; TGraphAsymmErrors::ComputeRangevoid ComputeRange(Double_t &xmin, Double_t &ymin, Double_t &xmax, Double_t &ymax) const overrideCompute Range.Definition TGraphAsymmErrors.cxx:977; TGraphAsymmErrors::SetPointEXlowvirtual void SetPointEXlow(Int_t i, Double_t exl)Set EXlow for point i.Definition TGraphAsymmErrors.cxx:1348; TGraphAsymmErrors::Streamervoid Streamer(TBuffer &) overrideStream an object of class TGraphAsymmErrors.Definition TGraphAsymmErrors.cxx:1404; TGraphAsymmErrors::SetPointEYhighvirtual void SetPointEYhigh(Int_t i, Double_t eyh)Set EYhigh for point i.Definition TGraphAsymmErrors.cxx:1390; TGraphAsymmErrors::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave primitive as a C++ statement(s) on output stream out.Definition TGraphAsymmErrors.cxx:1241; TGraphAsymmErrors::BayesDividevirtual void BayesDivide(const TH1 *pass, const TH1 *total, Option_t *opt="""")This function is only ke",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html
https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html:61710,Availability,error,errors,61710,"n TGraphAsymmErrors.cxx:977; TGraphAsymmErrors::SetPointEXlowvirtual void SetPointEXlow(Int_t i, Double_t exl)Set EXlow for point i.Definition TGraphAsymmErrors.cxx:1348; TGraphAsymmErrors::Streamervoid Streamer(TBuffer &) overrideStream an object of class TGraphAsymmErrors.Definition TGraphAsymmErrors.cxx:1404; TGraphAsymmErrors::SetPointEYhighvirtual void SetPointEYhigh(Int_t i, Double_t eyh)Set EYhigh for point i.Definition TGraphAsymmErrors.cxx:1390; TGraphAsymmErrors::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave primitive as a C++ statement(s) on output stream out.Definition TGraphAsymmErrors.cxx:1241; TGraphAsymmErrors::BayesDividevirtual void BayesDivide(const TH1 *pass, const TH1 *total, Option_t *opt="""")This function is only kept for backward compatibility.Definition TGraphAsymmErrors.cxx:508; TGraphAsymmErrors::GetEYhighDouble_t * GetEYhigh() const overrideDefinition TGraphAsymmErrors.h:77; TGraphAsymmErrors::Printvoid Print(Option_t *chopt="""") const overridePrint graph and errors values.Definition TGraphAsymmErrors.cxx:1229; TGraphAsymmErrors::GetErrorYhighDouble_t GetErrorYhigh(Int_t i) const overrideGet high error on Y.Definition TGraphAsymmErrors.cxx:1173; TGraphAsymmErrors::MergeInt_t Merge(TCollection *list) overrideAdds all graphs with asymmetric errors from the collection to this graph.Definition TGraphAsymmErrors.cxx:1196; TGraphAsymmErrors::GetErrorXlowDouble_t GetErrorXlow(Int_t i) const overrideGet low error on X.Definition TGraphAsymmErrors.cxx:1162; TGraphAsymmErrors::fEYlowDouble_t * fEYlow[fNpoints] array of Y low errorsDefinition TGraphAsymmErrors.h:31; TGraphAsymmErrors::UpdateArraysvoid UpdateArrays(const std::vector< Int_t > &sorting_indices, Int_t numSortedPoints, Int_t low) overrideUpdate the fX, fY, fEXlow, fEXhigh, fEYlow and fEYhigh arrays with the sorted values.Definition TGraphAsymmErrors.cxx:1468; TGraphAsymmErrors::SwapPointsvoid SwapPoints(Int_t pos1, Int_t pos2) overrideSwap points.Defin",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html
https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html:61850,Availability,error,error,61850,"nition TGraphAsymmErrors.cxx:1348; TGraphAsymmErrors::Streamervoid Streamer(TBuffer &) overrideStream an object of class TGraphAsymmErrors.Definition TGraphAsymmErrors.cxx:1404; TGraphAsymmErrors::SetPointEYhighvirtual void SetPointEYhigh(Int_t i, Double_t eyh)Set EYhigh for point i.Definition TGraphAsymmErrors.cxx:1390; TGraphAsymmErrors::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave primitive as a C++ statement(s) on output stream out.Definition TGraphAsymmErrors.cxx:1241; TGraphAsymmErrors::BayesDividevirtual void BayesDivide(const TH1 *pass, const TH1 *total, Option_t *opt="""")This function is only kept for backward compatibility.Definition TGraphAsymmErrors.cxx:508; TGraphAsymmErrors::GetEYhighDouble_t * GetEYhigh() const overrideDefinition TGraphAsymmErrors.h:77; TGraphAsymmErrors::Printvoid Print(Option_t *chopt="""") const overridePrint graph and errors values.Definition TGraphAsymmErrors.cxx:1229; TGraphAsymmErrors::GetErrorYhighDouble_t GetErrorYhigh(Int_t i) const overrideGet high error on Y.Definition TGraphAsymmErrors.cxx:1173; TGraphAsymmErrors::MergeInt_t Merge(TCollection *list) overrideAdds all graphs with asymmetric errors from the collection to this graph.Definition TGraphAsymmErrors.cxx:1196; TGraphAsymmErrors::GetErrorXlowDouble_t GetErrorXlow(Int_t i) const overrideGet low error on X.Definition TGraphAsymmErrors.cxx:1162; TGraphAsymmErrors::fEYlowDouble_t * fEYlow[fNpoints] array of Y low errorsDefinition TGraphAsymmErrors.h:31; TGraphAsymmErrors::UpdateArraysvoid UpdateArrays(const std::vector< Int_t > &sorting_indices, Int_t numSortedPoints, Int_t low) overrideUpdate the fX, fY, fEXlow, fEXhigh, fEYlow and fEYhigh arrays with the sorted values.Definition TGraphAsymmErrors.cxx:1468; TGraphAsymmErrors::SwapPointsvoid SwapPoints(Int_t pos1, Int_t pos2) overrideSwap points.Definition TGraphAsymmErrors.cxx:1456; TGraphAsymmErrors::GetEXhighDouble_t * GetEXhigh() const overrideDefinition TGraphAsymmErrors.h:75; T",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html
https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html:61995,Availability,error,errors,61995,"AsymmErrors.cxx:1404; TGraphAsymmErrors::SetPointEYhighvirtual void SetPointEYhigh(Int_t i, Double_t eyh)Set EYhigh for point i.Definition TGraphAsymmErrors.cxx:1390; TGraphAsymmErrors::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave primitive as a C++ statement(s) on output stream out.Definition TGraphAsymmErrors.cxx:1241; TGraphAsymmErrors::BayesDividevirtual void BayesDivide(const TH1 *pass, const TH1 *total, Option_t *opt="""")This function is only kept for backward compatibility.Definition TGraphAsymmErrors.cxx:508; TGraphAsymmErrors::GetEYhighDouble_t * GetEYhigh() const overrideDefinition TGraphAsymmErrors.h:77; TGraphAsymmErrors::Printvoid Print(Option_t *chopt="""") const overridePrint graph and errors values.Definition TGraphAsymmErrors.cxx:1229; TGraphAsymmErrors::GetErrorYhighDouble_t GetErrorYhigh(Int_t i) const overrideGet high error on Y.Definition TGraphAsymmErrors.cxx:1173; TGraphAsymmErrors::MergeInt_t Merge(TCollection *list) overrideAdds all graphs with asymmetric errors from the collection to this graph.Definition TGraphAsymmErrors.cxx:1196; TGraphAsymmErrors::GetErrorXlowDouble_t GetErrorXlow(Int_t i) const overrideGet low error on X.Definition TGraphAsymmErrors.cxx:1162; TGraphAsymmErrors::fEYlowDouble_t * fEYlow[fNpoints] array of Y low errorsDefinition TGraphAsymmErrors.h:31; TGraphAsymmErrors::UpdateArraysvoid UpdateArrays(const std::vector< Int_t > &sorting_indices, Int_t numSortedPoints, Int_t low) overrideUpdate the fX, fY, fEXlow, fEXhigh, fEYlow and fEYhigh arrays with the sorted values.Definition TGraphAsymmErrors.cxx:1468; TGraphAsymmErrors::SwapPointsvoid SwapPoints(Int_t pos1, Int_t pos2) overrideSwap points.Definition TGraphAsymmErrors.cxx:1456; TGraphAsymmErrors::GetEXhighDouble_t * GetEXhigh() const overrideDefinition TGraphAsymmErrors.h:75; TGraphAsymmErrors::fEXlowDouble_t * fEXlow[fNpoints] array of X low errorsDefinition TGraphAsymmErrors.h:29; TGraphAsymmErrors::Applyvoid Apply(TF1 *f) overr",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html
https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html:62159,Availability,error,error,62159,"rs.cxx:1390; TGraphAsymmErrors::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave primitive as a C++ statement(s) on output stream out.Definition TGraphAsymmErrors.cxx:1241; TGraphAsymmErrors::BayesDividevirtual void BayesDivide(const TH1 *pass, const TH1 *total, Option_t *opt="""")This function is only kept for backward compatibility.Definition TGraphAsymmErrors.cxx:508; TGraphAsymmErrors::GetEYhighDouble_t * GetEYhigh() const overrideDefinition TGraphAsymmErrors.h:77; TGraphAsymmErrors::Printvoid Print(Option_t *chopt="""") const overridePrint graph and errors values.Definition TGraphAsymmErrors.cxx:1229; TGraphAsymmErrors::GetErrorYhighDouble_t GetErrorYhigh(Int_t i) const overrideGet high error on Y.Definition TGraphAsymmErrors.cxx:1173; TGraphAsymmErrors::MergeInt_t Merge(TCollection *list) overrideAdds all graphs with asymmetric errors from the collection to this graph.Definition TGraphAsymmErrors.cxx:1196; TGraphAsymmErrors::GetErrorXlowDouble_t GetErrorXlow(Int_t i) const overrideGet low error on X.Definition TGraphAsymmErrors.cxx:1162; TGraphAsymmErrors::fEYlowDouble_t * fEYlow[fNpoints] array of Y low errorsDefinition TGraphAsymmErrors.h:31; TGraphAsymmErrors::UpdateArraysvoid UpdateArrays(const std::vector< Int_t > &sorting_indices, Int_t numSortedPoints, Int_t low) overrideUpdate the fX, fY, fEXlow, fEXhigh, fEYlow and fEYhigh arrays with the sorted values.Definition TGraphAsymmErrors.cxx:1468; TGraphAsymmErrors::SwapPointsvoid SwapPoints(Int_t pos1, Int_t pos2) overrideSwap points.Definition TGraphAsymmErrors.cxx:1456; TGraphAsymmErrors::GetEXhighDouble_t * GetEXhigh() const overrideDefinition TGraphAsymmErrors.h:75; TGraphAsymmErrors::fEXlowDouble_t * fEXlow[fNpoints] array of X low errorsDefinition TGraphAsymmErrors.h:29; TGraphAsymmErrors::Applyvoid Apply(TF1 *f) overrideApply a function to all data points .Definition TGraphAsymmErrors.cxx:468; TGraphAsymmErrors::AllocateDouble_t ** Allocate(Int_t size) overrideAllocate ",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html
https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html:62277,Availability,error,errorsDefinition,62277,"atement(s) on output stream out.Definition TGraphAsymmErrors.cxx:1241; TGraphAsymmErrors::BayesDividevirtual void BayesDivide(const TH1 *pass, const TH1 *total, Option_t *opt="""")This function is only kept for backward compatibility.Definition TGraphAsymmErrors.cxx:508; TGraphAsymmErrors::GetEYhighDouble_t * GetEYhigh() const overrideDefinition TGraphAsymmErrors.h:77; TGraphAsymmErrors::Printvoid Print(Option_t *chopt="""") const overridePrint graph and errors values.Definition TGraphAsymmErrors.cxx:1229; TGraphAsymmErrors::GetErrorYhighDouble_t GetErrorYhigh(Int_t i) const overrideGet high error on Y.Definition TGraphAsymmErrors.cxx:1173; TGraphAsymmErrors::MergeInt_t Merge(TCollection *list) overrideAdds all graphs with asymmetric errors from the collection to this graph.Definition TGraphAsymmErrors.cxx:1196; TGraphAsymmErrors::GetErrorXlowDouble_t GetErrorXlow(Int_t i) const overrideGet low error on X.Definition TGraphAsymmErrors.cxx:1162; TGraphAsymmErrors::fEYlowDouble_t * fEYlow[fNpoints] array of Y low errorsDefinition TGraphAsymmErrors.h:31; TGraphAsymmErrors::UpdateArraysvoid UpdateArrays(const std::vector< Int_t > &sorting_indices, Int_t numSortedPoints, Int_t low) overrideUpdate the fX, fY, fEXlow, fEXhigh, fEYlow and fEYhigh arrays with the sorted values.Definition TGraphAsymmErrors.cxx:1468; TGraphAsymmErrors::SwapPointsvoid SwapPoints(Int_t pos1, Int_t pos2) overrideSwap points.Definition TGraphAsymmErrors.cxx:1456; TGraphAsymmErrors::GetEXhighDouble_t * GetEXhigh() const overrideDefinition TGraphAsymmErrors.h:75; TGraphAsymmErrors::fEXlowDouble_t * fEXlow[fNpoints] array of X low errorsDefinition TGraphAsymmErrors.h:29; TGraphAsymmErrors::Applyvoid Apply(TF1 *f) overrideApply a function to all data points .Definition TGraphAsymmErrors.cxx:468; TGraphAsymmErrors::AllocateDouble_t ** Allocate(Int_t size) overrideAllocate internal data structures for size points.Definition TGraphAsymmErrors.cxx:444; TGraphAsymmErrors::GetEYlowDouble_t * GetEYlow() const over",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html
https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html:62874,Availability,error,errorsDefinition,62874,"r on Y.Definition TGraphAsymmErrors.cxx:1173; TGraphAsymmErrors::MergeInt_t Merge(TCollection *list) overrideAdds all graphs with asymmetric errors from the collection to this graph.Definition TGraphAsymmErrors.cxx:1196; TGraphAsymmErrors::GetErrorXlowDouble_t GetErrorXlow(Int_t i) const overrideGet low error on X.Definition TGraphAsymmErrors.cxx:1162; TGraphAsymmErrors::fEYlowDouble_t * fEYlow[fNpoints] array of Y low errorsDefinition TGraphAsymmErrors.h:31; TGraphAsymmErrors::UpdateArraysvoid UpdateArrays(const std::vector< Int_t > &sorting_indices, Int_t numSortedPoints, Int_t low) overrideUpdate the fX, fY, fEXlow, fEXhigh, fEYlow and fEYhigh arrays with the sorted values.Definition TGraphAsymmErrors.cxx:1468; TGraphAsymmErrors::SwapPointsvoid SwapPoints(Int_t pos1, Int_t pos2) overrideSwap points.Definition TGraphAsymmErrors.cxx:1456; TGraphAsymmErrors::GetEXhighDouble_t * GetEXhigh() const overrideDefinition TGraphAsymmErrors.h:75; TGraphAsymmErrors::fEXlowDouble_t * fEXlow[fNpoints] array of X low errorsDefinition TGraphAsymmErrors.h:29; TGraphAsymmErrors::Applyvoid Apply(TF1 *f) overrideApply a function to all data points .Definition TGraphAsymmErrors.cxx:468; TGraphAsymmErrors::AllocateDouble_t ** Allocate(Int_t size) overrideAllocate internal data structures for size points.Definition TGraphAsymmErrors.cxx:444; TGraphAsymmErrors::GetEYlowDouble_t * GetEYlow() const overrideDefinition TGraphAsymmErrors.h:76; TGraphAsymmErrors::DoMergeBool_t DoMerge(const TGraph *g) overrideProtected function to perform the merge operation of a graph with asymmetric errors.Definition TGraphAsymmErrors.cxx:1077; TGraphAsymmErrors::CopyAndReleasevoid CopyAndRelease(Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy and release.Definition TGraphAsymmErrors.cxx:1007; TGraphAsymmErrors::IsATClass * IsA() const overrideDefinition TGraphAsymmErrors.h:89; TGraphAsymmErrors::SetPointEXhighvirtual void SetPointEXhigh(Int_t i, Double_t exh)Set EXhigh for point i.",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html
https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html:63438,Availability,error,errors,63438,"const std::vector< Int_t > &sorting_indices, Int_t numSortedPoints, Int_t low) overrideUpdate the fX, fY, fEXlow, fEXhigh, fEYlow and fEYhigh arrays with the sorted values.Definition TGraphAsymmErrors.cxx:1468; TGraphAsymmErrors::SwapPointsvoid SwapPoints(Int_t pos1, Int_t pos2) overrideSwap points.Definition TGraphAsymmErrors.cxx:1456; TGraphAsymmErrors::GetEXhighDouble_t * GetEXhigh() const overrideDefinition TGraphAsymmErrors.h:75; TGraphAsymmErrors::fEXlowDouble_t * fEXlow[fNpoints] array of X low errorsDefinition TGraphAsymmErrors.h:29; TGraphAsymmErrors::Applyvoid Apply(TF1 *f) overrideApply a function to all data points .Definition TGraphAsymmErrors.cxx:468; TGraphAsymmErrors::AllocateDouble_t ** Allocate(Int_t size) overrideAllocate internal data structures for size points.Definition TGraphAsymmErrors.cxx:444; TGraphAsymmErrors::GetEYlowDouble_t * GetEYlow() const overrideDefinition TGraphAsymmErrors.h:76; TGraphAsymmErrors::DoMergeBool_t DoMerge(const TGraph *g) overrideProtected function to perform the merge operation of a graph with asymmetric errors.Definition TGraphAsymmErrors.cxx:1077; TGraphAsymmErrors::CopyAndReleasevoid CopyAndRelease(Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy and release.Definition TGraphAsymmErrors.cxx:1007; TGraphAsymmErrors::IsATClass * IsA() const overrideDefinition TGraphAsymmErrors.h:89; TGraphAsymmErrors::SetPointEXhighvirtual void SetPointEXhigh(Int_t i, Double_t exh)Set EXhigh for point i.Definition TGraphAsymmErrors.cxx:1362; TGraphAsymmErrors::GetErrorYlowDouble_t GetErrorYlow(Int_t i) const overrideGet low error on Y.Definition TGraphAsymmErrors.cxx:1184; TGraphAsymmErrors::GetErrorXDouble_t GetErrorX(Int_t bin) const overrideReturns the combined error along X at point i by computing the average of the lower and upper varianc...Definition TGraphAsymmErrors.cxx:1122; TGraphAsymmErrors::TGraphAsymmErrorsTGraphAsymmErrors()TGraphAsymmErrors default constructor.Definition TGraphAsymmErrors.cx",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html
https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html:63978,Availability,error,error,63978,"plyvoid Apply(TF1 *f) overrideApply a function to all data points .Definition TGraphAsymmErrors.cxx:468; TGraphAsymmErrors::AllocateDouble_t ** Allocate(Int_t size) overrideAllocate internal data structures for size points.Definition TGraphAsymmErrors.cxx:444; TGraphAsymmErrors::GetEYlowDouble_t * GetEYlow() const overrideDefinition TGraphAsymmErrors.h:76; TGraphAsymmErrors::DoMergeBool_t DoMerge(const TGraph *g) overrideProtected function to perform the merge operation of a graph with asymmetric errors.Definition TGraphAsymmErrors.cxx:1077; TGraphAsymmErrors::CopyAndReleasevoid CopyAndRelease(Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy and release.Definition TGraphAsymmErrors.cxx:1007; TGraphAsymmErrors::IsATClass * IsA() const overrideDefinition TGraphAsymmErrors.h:89; TGraphAsymmErrors::SetPointEXhighvirtual void SetPointEXhigh(Int_t i, Double_t exh)Set EXhigh for point i.Definition TGraphAsymmErrors.cxx:1362; TGraphAsymmErrors::GetErrorYlowDouble_t GetErrorYlow(Int_t i) const overrideGet low error on Y.Definition TGraphAsymmErrors.cxx:1184; TGraphAsymmErrors::GetErrorXDouble_t GetErrorX(Int_t bin) const overrideReturns the combined error along X at point i by computing the average of the lower and upper varianc...Definition TGraphAsymmErrors.cxx:1122; TGraphAsymmErrors::TGraphAsymmErrorsTGraphAsymmErrors()TGraphAsymmErrors default constructor.Definition TGraphAsymmErrors.cxx:72; TGraphAsymmErrors::operator=TGraphAsymmErrors & operator=(const TGraphAsymmErrors &gr)TGraphAsymmErrors assignment operator.Definition TGraphAsymmErrors.cxx:93; TGraphAsymmErrors::~TGraphAsymmErrors~TGraphAsymmErrors() overrideTGraphAsymmErrors default destructor.Definition TGraphAsymmErrors.cxx:433; TGraphAsymmErrors::Scalevoid Scale(Double_t c1=1., Option_t *option=""y"") overrideMultiply the values and errors of a TGraphAsymmErrors by a constant c1.Definition TGraphAsymmErrors.cxx:1274; TGraphErrors::CalculateScanfFieldsstatic Int_t CalculateScanfFields(con",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html
https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html:64121,Availability,error,error,64121,"llocate internal data structures for size points.Definition TGraphAsymmErrors.cxx:444; TGraphAsymmErrors::GetEYlowDouble_t * GetEYlow() const overrideDefinition TGraphAsymmErrors.h:76; TGraphAsymmErrors::DoMergeBool_t DoMerge(const TGraph *g) overrideProtected function to perform the merge operation of a graph with asymmetric errors.Definition TGraphAsymmErrors.cxx:1077; TGraphAsymmErrors::CopyAndReleasevoid CopyAndRelease(Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy and release.Definition TGraphAsymmErrors.cxx:1007; TGraphAsymmErrors::IsATClass * IsA() const overrideDefinition TGraphAsymmErrors.h:89; TGraphAsymmErrors::SetPointEXhighvirtual void SetPointEXhigh(Int_t i, Double_t exh)Set EXhigh for point i.Definition TGraphAsymmErrors.cxx:1362; TGraphAsymmErrors::GetErrorYlowDouble_t GetErrorYlow(Int_t i) const overrideGet low error on Y.Definition TGraphAsymmErrors.cxx:1184; TGraphAsymmErrors::GetErrorXDouble_t GetErrorX(Int_t bin) const overrideReturns the combined error along X at point i by computing the average of the lower and upper varianc...Definition TGraphAsymmErrors.cxx:1122; TGraphAsymmErrors::TGraphAsymmErrorsTGraphAsymmErrors()TGraphAsymmErrors default constructor.Definition TGraphAsymmErrors.cxx:72; TGraphAsymmErrors::operator=TGraphAsymmErrors & operator=(const TGraphAsymmErrors &gr)TGraphAsymmErrors assignment operator.Definition TGraphAsymmErrors.cxx:93; TGraphAsymmErrors::~TGraphAsymmErrors~TGraphAsymmErrors() overrideTGraphAsymmErrors default destructor.Definition TGraphAsymmErrors.cxx:433; TGraphAsymmErrors::Scalevoid Scale(Double_t c1=1., Option_t *option=""y"") overrideMultiply the values and errors of a TGraphAsymmErrors by a constant c1.Definition TGraphAsymmErrors.cxx:1274; TGraphErrors::CalculateScanfFieldsstatic Int_t CalculateScanfFields(const char *fmt)Calculate scan fields.Definition TGraphErrors.cxx:449; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; TGraph::",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html
https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html:64780,Availability,error,errors,64780,"tEXhighvirtual void SetPointEXhigh(Int_t i, Double_t exh)Set EXhigh for point i.Definition TGraphAsymmErrors.cxx:1362; TGraphAsymmErrors::GetErrorYlowDouble_t GetErrorYlow(Int_t i) const overrideGet low error on Y.Definition TGraphAsymmErrors.cxx:1184; TGraphAsymmErrors::GetErrorXDouble_t GetErrorX(Int_t bin) const overrideReturns the combined error along X at point i by computing the average of the lower and upper varianc...Definition TGraphAsymmErrors.cxx:1122; TGraphAsymmErrors::TGraphAsymmErrorsTGraphAsymmErrors()TGraphAsymmErrors default constructor.Definition TGraphAsymmErrors.cxx:72; TGraphAsymmErrors::operator=TGraphAsymmErrors & operator=(const TGraphAsymmErrors &gr)TGraphAsymmErrors assignment operator.Definition TGraphAsymmErrors.cxx:93; TGraphAsymmErrors::~TGraphAsymmErrors~TGraphAsymmErrors() overrideTGraphAsymmErrors default destructor.Definition TGraphAsymmErrors.cxx:433; TGraphAsymmErrors::Scalevoid Scale(Double_t c1=1., Option_t *option=""y"") overrideMultiply the values and errors of a TGraphAsymmErrors by a constant c1.Definition TGraphAsymmErrors.cxx:1274; TGraphErrors::CalculateScanfFieldsstatic Int_t CalculateScanfFields(const char *fmt)Calculate scan fields.Definition TGraphErrors.cxx:449; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; TGraph::Classstatic TClass * Class(); TGraph::AddPointvirtual void AddPoint(Double_t x, Double_t y)Append a new point to the graph.Definition TGraph.h:98; TGraph::fNpointsInt_t fNpointsNumber of points <= fMaxSize.Definition TGraph.h:46; TGraph::SetPointvirtual void SetPoint(Int_t i, Double_t x, Double_t y)Set x and y values for point number i.Definition TGraph.cxx:2342; TGraph::fMaxSizeInt_t fMaxSize!Current dimension of arrays fX and fYDefinition TGraph.h:45; TGraph::SaveHistogramAndFunctionsvoid SaveHistogramAndFunctions(std::ostream &out, const char *varname, Int_t &frameNumber, Option_t *option)Save histogram and list of functions of TGraph as C++ statement Use",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html
https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html:70157,Availability,error,error,70157,"1D histogram.Definition TH1.cxx:9152; TH1::GetBinContentvirtual Double_t GetBinContent(Int_t bin) constReturn content of bin number bin.Definition TH1.cxx:5061; TH1::GetSumw2virtual TArrayD * GetSumw2()Definition TH1.h:313; TH1::GetBinWidthvirtual Double_t GetBinWidth(Int_t bin) constReturn bin width for 1D histogram.Definition TH1.cxx:9163; TH1::GetSumOfWeightsvirtual Double_t GetSumOfWeights() constReturn the sum of weights excluding under/overflows.Definition TH1.cxx:7917; TIterDefinition TCollection.h:235; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TNamed::GetTitleconst char * GetTitle() const overrideReturns title of object.Definition TNamed.h:48; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::MakeZombievoid MakeZombie()Definition TObject.h:53; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::AtoiInt_t Atoi() constReturn integer value of string.Definition TString.cxx:1988; TString::AtofDouble_t Atof() constReturn floating-point value contained in string.Definition TString.cxx:2054; TString::IsFloatBool_t IsFloat() constReturns kTRUE if string contains a floating point or integer number.Definition TString.cxx:1858; TString::Dataconst char * Data() constDefinition TString.h:376; TString::IsDigitBool_t IsDigit() constReturns true if all characters in string are digits (0-9) or white spaces, i.e.Definition TString.cxx:1830; TString::ReplaceAllTStr",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html
https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html:72556,Availability,mask,mask,72556,"ts (0-9) or white spaces, i.e.Definition TString.cxx:1830; TString::ReplaceAllTString & ReplaceAll(const TString &s1, const TString &s2)Definition TString.h:704; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TStyle::GetErrorXFloat_t GetErrorX() constDefinition TStyle.h:186; TSystem::ExpandPathNamevirtual Bool_t ExpandPathName(TString &path)Expand a pathname getting rid of special shell characters like ~.Definition TSystem.cxx:1274; TVectorTTVectorT.Definition TVectorT.h:27; TVectorT::GetNrowsInt_t GetNrows() constDefinition TVectorT.h:73; TVectorT::GetLwbInt_t GetLwb() constDefinition TVectorT.h:71; bool; double; int; unsigned int; lineTLine * lineDefinition entrylistblock_figure1.C:235; ROOT::Math::normal_quantile_cdouble normal_quantile_c(double z, double sigma)Inverse ( ) of the cumulative distribution function of the upper tail of the normal (Gaussian) distri...Definition QuantFuncMathCore.cxx:126; sigmaconst Double_t sigmaDefinition h1analysisProxy.h:11; yDouble_t y[n]Definition legend1.C:17; c1return c1Definition legend1.C:41; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; grTGraphErrors * grDefinition legend1.C:25; TMath::FiniteInt_t Finite(Double_t x)Check if it is finite with a mask in order to be consistent in presence of fast math.Definition TMath.h:770; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662; TMath::MinShort_t Min(Short_t a, Short_t b)Returns the smallest of a and b.Definition TMathBase.h:198; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123. histhistsrcTGraphAsymmErrors.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:33 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html
https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html:34967,Deployability,release,release,34967,"bins); 962 Warning(""Divide"",""Number of graph points is different than histogram bins - %d points have been skipped"",nbins-npoint);; 963 ; 964 ; 965 if (bVerbose) {; 966 Info(""Divide"",""made a graph with %d points from %d bins"",npoint,nbins);; 967 Info(""Divide"",""used confidence level: %.2lf\n"",conf);; 968 if(bIsBayesian); 969 Info(""Divide"",""used prior probability ~ beta(%.2lf,%.2lf)"",alpha,beta);; 970 Print();; 971 }; 972}; 973 ; 974////////////////////////////////////////////////////////////////////////////////; 975/// Compute Range.; 976 ; 977void TGraphAsymmErrors::ComputeRange(Double_t &xmin, Double_t &ymin, Double_t &xmax, Double_t &ymax) const; 978{; 979 TGraph::ComputeRange(xmin,ymin,xmax,ymax);; 980 ; 981 for (Int_t i=0;i<fNpoints;i++) {; 982 if (fX[i] -fEXlow[i] < xmin) {; 983 if (gPad && gPad->GetLogx()) {; 984 if (fEXlow[i] < fX[i]) xmin = fX[i]-fEXlow[i];; 985 else xmin = TMath::Min(xmin,fX[i]/3);; 986 } else {; 987 xmin = fX[i]-fEXlow[i];; 988 }; 989 }; 990 if (fX[i] +fEXhigh[i] > xmax) xmax = fX[i]+fEXhigh[i];; 991 if (fY[i] -fEYlow[i] < ymin) {; 992 if (gPad && gPad->GetLogy()) {; 993 if (fEYlow[i] < fY[i]) ymin = fY[i]-fEYlow[i];; 994 else ymin = TMath::Min(ymin,fY[i]/3);; 995 } else {; 996 ymin = fY[i]-fEYlow[i];; 997 }; 998 }; 999 if (fY[i] +fEYhigh[i] > ymax) ymax = fY[i]+fEYhigh[i];; 1000 }; 1001}; 1002 ; 1003 ; 1004////////////////////////////////////////////////////////////////////////////////; 1005/// Copy and release.; 1006 ; 1007void TGraphAsymmErrors::CopyAndRelease(Double_t **newarrays,; 1008 Int_t ibegin, Int_t iend, Int_t obegin); 1009{; 1010 CopyPoints(newarrays, ibegin, iend, obegin);; 1011 if (newarrays) {; 1012 delete[] fEXlow;; 1013 fEXlow = newarrays[0];; 1014 delete[] fEXhigh;; 1015 fEXhigh = newarrays[1];; 1016 delete[] fEYlow;; 1017 fEYlow = newarrays[2];; 1018 delete[] fEYhigh;; 1019 fEYhigh = newarrays[3];; 1020 delete[] fX;; 1021 fX = newarrays[4];; 1022 delete[] fY;; 1023 fY = newarrays[5];; 1024 delete[] newarrays;; 1025 }; 10",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html
https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html:63616,Deployability,release,release,63616," TGraphAsymmErrors.cxx:1468; TGraphAsymmErrors::SwapPointsvoid SwapPoints(Int_t pos1, Int_t pos2) overrideSwap points.Definition TGraphAsymmErrors.cxx:1456; TGraphAsymmErrors::GetEXhighDouble_t * GetEXhigh() const overrideDefinition TGraphAsymmErrors.h:75; TGraphAsymmErrors::fEXlowDouble_t * fEXlow[fNpoints] array of X low errorsDefinition TGraphAsymmErrors.h:29; TGraphAsymmErrors::Applyvoid Apply(TF1 *f) overrideApply a function to all data points .Definition TGraphAsymmErrors.cxx:468; TGraphAsymmErrors::AllocateDouble_t ** Allocate(Int_t size) overrideAllocate internal data structures for size points.Definition TGraphAsymmErrors.cxx:444; TGraphAsymmErrors::GetEYlowDouble_t * GetEYlow() const overrideDefinition TGraphAsymmErrors.h:76; TGraphAsymmErrors::DoMergeBool_t DoMerge(const TGraph *g) overrideProtected function to perform the merge operation of a graph with asymmetric errors.Definition TGraphAsymmErrors.cxx:1077; TGraphAsymmErrors::CopyAndReleasevoid CopyAndRelease(Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy and release.Definition TGraphAsymmErrors.cxx:1007; TGraphAsymmErrors::IsATClass * IsA() const overrideDefinition TGraphAsymmErrors.h:89; TGraphAsymmErrors::SetPointEXhighvirtual void SetPointEXhigh(Int_t i, Double_t exh)Set EXhigh for point i.Definition TGraphAsymmErrors.cxx:1362; TGraphAsymmErrors::GetErrorYlowDouble_t GetErrorYlow(Int_t i) const overrideGet low error on Y.Definition TGraphAsymmErrors.cxx:1184; TGraphAsymmErrors::GetErrorXDouble_t GetErrorX(Int_t bin) const overrideReturns the combined error along X at point i by computing the average of the lower and upper varianc...Definition TGraphAsymmErrors.cxx:1122; TGraphAsymmErrors::TGraphAsymmErrorsTGraphAsymmErrors()TGraphAsymmErrors default constructor.Definition TGraphAsymmErrors.cxx:72; TGraphAsymmErrors::operator=TGraphAsymmErrors & operator=(const TGraphAsymmErrors &gr)TGraphAsymmErrors assignment operator.Definition TGraphAsymmErrors.cxx:93; TGraphAsymmErro",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html
https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html:46237,Energy Efficiency,allocate,allocate,46237," 1307 Int_t py = gPad->GetEventY();; 1308 ; 1309 //localize point to be deleted; 1310 Int_t ipoint = -2;; 1311 Int_t i;; 1312 // start with a small window (in case the mouse is very close to one point); 1313 for (i=0;i<fNpoints;i++) {; 1314 Int_t dpx = px - gPad->XtoAbsPixel(gPad->XtoPad(fX[i]));; 1315 Int_t dpy = py - gPad->YtoAbsPixel(gPad->YtoPad(fY[i]));; 1316 if (dpx*dpx+dpy*dpy < 25) {ipoint = i; break;}; 1317 }; 1318 if (ipoint == -2) return;; 1319 ; 1320 fEXlow[ipoint] = exl;; 1321 fEYlow[ipoint] = eyl;; 1322 fEXhigh[ipoint] = exh;; 1323 fEYhigh[ipoint] = eyh;; 1324 gPad->Modified();; 1325}; 1326 ; 1327 ; 1328////////////////////////////////////////////////////////////////////////////////; 1329/// Set ex and ey values for point number i.; 1330 ; 1331void TGraphAsymmErrors::SetPointError(Int_t i, Double_t exl, Double_t exh, Double_t eyl, Double_t eyh); 1332{; 1333 if (i < 0) return;; 1334 if (i >= fNpoints) {; 1335 // re-allocate the object; 1336 TGraphAsymmErrors::SetPoint(i,0,0);; 1337 }; 1338 fEXlow[i] = exl;; 1339 fEYlow[i] = eyl;; 1340 fEXhigh[i] = exh;; 1341 fEYhigh[i] = eyh;; 1342}; 1343 ; 1344 ; 1345////////////////////////////////////////////////////////////////////////////////; 1346/// Set EXlow for point `i`.; 1347 ; 1348void TGraphAsymmErrors::SetPointEXlow(Int_t i, Double_t exl); 1349{; 1350 if (i < 0) return;; 1351 if (i >= fNpoints) {; 1352 // re-allocate the object; 1353 TGraphAsymmErrors::SetPoint(i,0,0);; 1354 }; 1355 fEXlow[i] = exl;; 1356}; 1357 ; 1358 ; 1359////////////////////////////////////////////////////////////////////////////////; 1360/// Set EXhigh for point `i`.; 1361 ; 1362void TGraphAsymmErrors::SetPointEXhigh(Int_t i, Double_t exh); 1363{; 1364 if (i < 0) return;; 1365 if (i >= fNpoints) {; 1366 // re-allocate the object; 1367 TGraphAsymmErrors::SetPoint(i,0,0);; 1368 }; 1369 fEXhigh[i] = exh;; 1370}; 1371 ; 1372 ; 1373////////////////////////////////////////////////////////////////////////////////; 1374/// Set EYlow for point ",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html
https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html:46686,Energy Efficiency,allocate,allocate,46686,"int == -2) return;; 1319 ; 1320 fEXlow[ipoint] = exl;; 1321 fEYlow[ipoint] = eyl;; 1322 fEXhigh[ipoint] = exh;; 1323 fEYhigh[ipoint] = eyh;; 1324 gPad->Modified();; 1325}; 1326 ; 1327 ; 1328////////////////////////////////////////////////////////////////////////////////; 1329/// Set ex and ey values for point number i.; 1330 ; 1331void TGraphAsymmErrors::SetPointError(Int_t i, Double_t exl, Double_t exh, Double_t eyl, Double_t eyh); 1332{; 1333 if (i < 0) return;; 1334 if (i >= fNpoints) {; 1335 // re-allocate the object; 1336 TGraphAsymmErrors::SetPoint(i,0,0);; 1337 }; 1338 fEXlow[i] = exl;; 1339 fEYlow[i] = eyl;; 1340 fEXhigh[i] = exh;; 1341 fEYhigh[i] = eyh;; 1342}; 1343 ; 1344 ; 1345////////////////////////////////////////////////////////////////////////////////; 1346/// Set EXlow for point `i`.; 1347 ; 1348void TGraphAsymmErrors::SetPointEXlow(Int_t i, Double_t exl); 1349{; 1350 if (i < 0) return;; 1351 if (i >= fNpoints) {; 1352 // re-allocate the object; 1353 TGraphAsymmErrors::SetPoint(i,0,0);; 1354 }; 1355 fEXlow[i] = exl;; 1356}; 1357 ; 1358 ; 1359////////////////////////////////////////////////////////////////////////////////; 1360/// Set EXhigh for point `i`.; 1361 ; 1362void TGraphAsymmErrors::SetPointEXhigh(Int_t i, Double_t exh); 1363{; 1364 if (i < 0) return;; 1365 if (i >= fNpoints) {; 1366 // re-allocate the object; 1367 TGraphAsymmErrors::SetPoint(i,0,0);; 1368 }; 1369 fEXhigh[i] = exh;; 1370}; 1371 ; 1372 ; 1373////////////////////////////////////////////////////////////////////////////////; 1374/// Set EYlow for point `i`.; 1375 ; 1376void TGraphAsymmErrors::SetPointEYlow(Int_t i, Double_t eyl); 1377{; 1378 if (i < 0) return;; 1379 if (i >= fNpoints) {; 1380 // re-allocate the object; 1381 TGraphAsymmErrors::SetPoint(i,0,0);; 1382 }; 1383 fEYlow[i] = eyl;; 1384}; 1385 ; 1386 ; 1387////////////////////////////////////////////////////////////////////////////////; 1388/// Set EYhigh for point `i`.; 1389 ; 1390void TGraphAsymmErrors::SetPointEYhigh(",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html
https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html:47066,Energy Efficiency,allocate,allocate,47066,"Double_t exl, Double_t exh, Double_t eyl, Double_t eyh); 1332{; 1333 if (i < 0) return;; 1334 if (i >= fNpoints) {; 1335 // re-allocate the object; 1336 TGraphAsymmErrors::SetPoint(i,0,0);; 1337 }; 1338 fEXlow[i] = exl;; 1339 fEYlow[i] = eyl;; 1340 fEXhigh[i] = exh;; 1341 fEYhigh[i] = eyh;; 1342}; 1343 ; 1344 ; 1345////////////////////////////////////////////////////////////////////////////////; 1346/// Set EXlow for point `i`.; 1347 ; 1348void TGraphAsymmErrors::SetPointEXlow(Int_t i, Double_t exl); 1349{; 1350 if (i < 0) return;; 1351 if (i >= fNpoints) {; 1352 // re-allocate the object; 1353 TGraphAsymmErrors::SetPoint(i,0,0);; 1354 }; 1355 fEXlow[i] = exl;; 1356}; 1357 ; 1358 ; 1359////////////////////////////////////////////////////////////////////////////////; 1360/// Set EXhigh for point `i`.; 1361 ; 1362void TGraphAsymmErrors::SetPointEXhigh(Int_t i, Double_t exh); 1363{; 1364 if (i < 0) return;; 1365 if (i >= fNpoints) {; 1366 // re-allocate the object; 1367 TGraphAsymmErrors::SetPoint(i,0,0);; 1368 }; 1369 fEXhigh[i] = exh;; 1370}; 1371 ; 1372 ; 1373////////////////////////////////////////////////////////////////////////////////; 1374/// Set EYlow for point `i`.; 1375 ; 1376void TGraphAsymmErrors::SetPointEYlow(Int_t i, Double_t eyl); 1377{; 1378 if (i < 0) return;; 1379 if (i >= fNpoints) {; 1380 // re-allocate the object; 1381 TGraphAsymmErrors::SetPoint(i,0,0);; 1382 }; 1383 fEYlow[i] = eyl;; 1384}; 1385 ; 1386 ; 1387////////////////////////////////////////////////////////////////////////////////; 1388/// Set EYhigh for point `i`.; 1389 ; 1390void TGraphAsymmErrors::SetPointEYhigh(Int_t i, Double_t eyh); 1391{; 1392 if (i < 0) return;; 1393 if (i >= fNpoints) {; 1394 // re-allocate the object; 1395 TGraphAsymmErrors::SetPoint(i,0,0);; 1396 }; 1397 fEYhigh[i] = eyh;; 1398}; 1399 ; 1400 ; 1401////////////////////////////////////////////////////////////////////////////////; 1402/// Stream an object of class TGraphAsymmErrors.; 1403 ; 1404void TGraphAsymmEr",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html
https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html:47445,Energy Efficiency,allocate,allocate,47445,"//////////////////; 1346/// Set EXlow for point `i`.; 1347 ; 1348void TGraphAsymmErrors::SetPointEXlow(Int_t i, Double_t exl); 1349{; 1350 if (i < 0) return;; 1351 if (i >= fNpoints) {; 1352 // re-allocate the object; 1353 TGraphAsymmErrors::SetPoint(i,0,0);; 1354 }; 1355 fEXlow[i] = exl;; 1356}; 1357 ; 1358 ; 1359////////////////////////////////////////////////////////////////////////////////; 1360/// Set EXhigh for point `i`.; 1361 ; 1362void TGraphAsymmErrors::SetPointEXhigh(Int_t i, Double_t exh); 1363{; 1364 if (i < 0) return;; 1365 if (i >= fNpoints) {; 1366 // re-allocate the object; 1367 TGraphAsymmErrors::SetPoint(i,0,0);; 1368 }; 1369 fEXhigh[i] = exh;; 1370}; 1371 ; 1372 ; 1373////////////////////////////////////////////////////////////////////////////////; 1374/// Set EYlow for point `i`.; 1375 ; 1376void TGraphAsymmErrors::SetPointEYlow(Int_t i, Double_t eyl); 1377{; 1378 if (i < 0) return;; 1379 if (i >= fNpoints) {; 1380 // re-allocate the object; 1381 TGraphAsymmErrors::SetPoint(i,0,0);; 1382 }; 1383 fEYlow[i] = eyl;; 1384}; 1385 ; 1386 ; 1387////////////////////////////////////////////////////////////////////////////////; 1388/// Set EYhigh for point `i`.; 1389 ; 1390void TGraphAsymmErrors::SetPointEYhigh(Int_t i, Double_t eyh); 1391{; 1392 if (i < 0) return;; 1393 if (i >= fNpoints) {; 1394 // re-allocate the object; 1395 TGraphAsymmErrors::SetPoint(i,0,0);; 1396 }; 1397 fEYhigh[i] = eyh;; 1398}; 1399 ; 1400 ; 1401////////////////////////////////////////////////////////////////////////////////; 1402/// Stream an object of class TGraphAsymmErrors.; 1403 ; 1404void TGraphAsymmErrors::Streamer(TBuffer &b); 1405{; 1406 if (b.IsReading()) {; 1407 UInt_t R__s, R__c;; 1408 Version_t R__v = b.ReadVersion(&R__s, &R__c);; 1409 if (R__v > 2) {; 1410 b.ReadClassBuffer(TGraphAsymmErrors::Class(), this, R__v, R__s, R__c);; 1411 return;; 1412 }; 1413 //====process old versions before automatic schema evolution; 1414 TGraph::Streamer(b);; 1415 fEXlow = new Double_t",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html
https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html:47825,Energy Efficiency,allocate,allocate,47825,"//////; 1360/// Set EXhigh for point `i`.; 1361 ; 1362void TGraphAsymmErrors::SetPointEXhigh(Int_t i, Double_t exh); 1363{; 1364 if (i < 0) return;; 1365 if (i >= fNpoints) {; 1366 // re-allocate the object; 1367 TGraphAsymmErrors::SetPoint(i,0,0);; 1368 }; 1369 fEXhigh[i] = exh;; 1370}; 1371 ; 1372 ; 1373////////////////////////////////////////////////////////////////////////////////; 1374/// Set EYlow for point `i`.; 1375 ; 1376void TGraphAsymmErrors::SetPointEYlow(Int_t i, Double_t eyl); 1377{; 1378 if (i < 0) return;; 1379 if (i >= fNpoints) {; 1380 // re-allocate the object; 1381 TGraphAsymmErrors::SetPoint(i,0,0);; 1382 }; 1383 fEYlow[i] = eyl;; 1384}; 1385 ; 1386 ; 1387////////////////////////////////////////////////////////////////////////////////; 1388/// Set EYhigh for point `i`.; 1389 ; 1390void TGraphAsymmErrors::SetPointEYhigh(Int_t i, Double_t eyh); 1391{; 1392 if (i < 0) return;; 1393 if (i >= fNpoints) {; 1394 // re-allocate the object; 1395 TGraphAsymmErrors::SetPoint(i,0,0);; 1396 }; 1397 fEYhigh[i] = eyh;; 1398}; 1399 ; 1400 ; 1401////////////////////////////////////////////////////////////////////////////////; 1402/// Stream an object of class TGraphAsymmErrors.; 1403 ; 1404void TGraphAsymmErrors::Streamer(TBuffer &b); 1405{; 1406 if (b.IsReading()) {; 1407 UInt_t R__s, R__c;; 1408 Version_t R__v = b.ReadVersion(&R__s, &R__c);; 1409 if (R__v > 2) {; 1410 b.ReadClassBuffer(TGraphAsymmErrors::Class(), this, R__v, R__s, R__c);; 1411 return;; 1412 }; 1413 //====process old versions before automatic schema evolution; 1414 TGraph::Streamer(b);; 1415 fEXlow = new Double_t[fNpoints];; 1416 fEYlow = new Double_t[fNpoints];; 1417 fEXhigh = new Double_t[fNpoints];; 1418 fEYhigh = new Double_t[fNpoints];; 1419 if (R__v < 2) {; 1420 Float_t *exlow = new Float_t[fNpoints];; 1421 Float_t *eylow = new Float_t[fNpoints];; 1422 Float_t *exhigh = new Float_t[fNpoints];; 1423 Float_t *eyhigh = new Float_t[fNpoints];; 1424 b.ReadFastArray(exlow,fNpoints);; 1425 b.Rea",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html
https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html:13059,Integrability,message,message,13059,"IsDigit()) {; 349 Error(""TGraphAsymmErrors"", ""Incorrect input format! Allowed format tags are {\""%%lg\"",\""%%*lg\"" or \""%%*s\""}"");; 350 return ;; 351 }; 352 Int_t ntokens = format_.Length() ;; 353 if (ntokens < 2) {; 354 Error(""TGraphAsymmErrors"", ""Incorrect input format! Only %d tag(s) in format whereas at least 2 \""%%lg\"" tags are expected!"", ntokens);; 355 return ;; 356 }; 357 Int_t ntokensToBeSaved = 0;; 358 Bool_t * isTokenToBeSaved = new Bool_t[ntokens];; 359 for (Int_t idx = 0; idx < ntokens; idx++) {; 360 isTokenToBeSaved[idx] = TString::Format(""%c"", format_[idx]).Atoi(); //atoi(&format_[idx]) does not work for some reason...; 361 if (isTokenToBeSaved[idx] == 1) {; 362 ntokensToBeSaved++ ;; 363 }; 364 }; 365 if (ntokens >= 2 && (ntokensToBeSaved < 2 || ntokensToBeSaved > 4)) { //first condition not to repeat the previous error message; 366 Error(""TGraphAsymmErrors"", ""Incorrect input format! There are %d \""%%lg\"" tag(s) in format whereas 2,3 or 4 are expected!"", ntokensToBeSaved);; 367 delete [] isTokenToBeSaved;; 368 return ;; 369 }; 370 ; 371 // Initializing loop variables; 372 Bool_t isLineToBeSkipped = kFALSE; //empty and ill-formed lines; 373 char *token = nullptr;; 374 TString token_str = """";; 375 Int_t token_idx = 0;; 376 Double_t value[6]; //x,y,exl, exh, eyl, eyh buffers; 377 for (Int_t k = 0; k < 6; k++); 378 value[k] = 0.;; 379 Int_t value_idx = 0;; 380 ; 381 // Looping; 382 char *rest;; 383 while (std::getline(infile, line, '\n')) {; 384 if (!line.empty()) {; 385 if (line[line.size() - 1] == char(13)) { // removing DOS CR character; 386 line.erase(line.end() - 1, line.end()) ;; 387 }; 388 token = R__STRTOK_R(const_cast<char*>(line.c_str()), option, &rest) ;; 389 while (token != nullptr && value_idx < ntokensToBeSaved) {; 390 if (isTokenToBeSaved[token_idx]) {; 391 token_str = TString(token) ;; 392 token_str.ReplaceAll(""\t"", """") ;; 393 if (!token_str.IsFloat()) {; 394 isLineToBeSkipped = kTRUE ;; 395 break ;; 396 } else {; 397 value[value_idx] = tok",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html
https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html:18725,Integrability,depend,depends,18725,"tion_t *); 509{; 510 Divide(pass,total,""cl=0.683 b(1,1) mode"");; 511}; 512 ; 513////////////////////////////////////////////////////////////////////////////////; 514/// Fill this TGraphAsymmErrors by dividing two 1-dimensional histograms pass/total; 515///; 516/// This method serves two purposes:; 517///; 518/// ### 1) calculating efficiencies:; 519///; 520/// The assumption is that the entries in ""pass"" are a subset of those in; 521/// ""total"". That is, we create an ""efficiency"" graph, where each entry is; 522/// between 0 and 1, inclusive.; 523///; 524/// If the histograms are not filled with unit weights, the number of effective; 525/// entries is used to normalise the bin contents which might lead to wrong results.; 526/// \f[; 527/// \text{effective entries} = \frac{(\sum w_{i})^{2}}{\sum w_{i}^{2}}; 528/// \f]; 529/// The points are assigned a x value at the center of each histogram bin.; 530/// The y values are \f$\text{eff} = \frac{\text{pass}}{\text{total}}\f$; 531/// for all options except for the; 532/// bayesian methods where the result depends on the chosen option.; 533///; 534/// If the denominator becomes 0 or pass > total, the corresponding bin is; 535/// skipped.; 536///; 537/// ### 2) calculating ratios of two Poisson means (option 'pois'):; 538///; 539/// The two histograms are interpreted as independent Poisson processes and the ratio; 540/// \f[; 541/// \tau = \frac{n_{1}}{n_{2}} = \frac{\varepsilon}{1 - \varepsilon}; 542/// \f]; 543/// with \f$\varepsilon = \frac{n_{1}}{n_{1} + n_{2}}\f$.; 544/// The histogram 'pass' is interpreted as \f$n_{1}\f$ and the total histogram; 545/// is used for \f$n_{2}\f$.; 546///; 547/// The (asymmetric) uncertainties of the Poisson ratio are linked to the uncertainties; 548/// of efficiency by a parameter transformation:; 549/// \f[; 550/// \Delta \tau_{low/up} = \frac{1}{(1 - \varepsilon)^{2}} \Delta \varepsilon_{low/up}; 551/// \f]; 552///; 553/// The x errors span each histogram bin (lowedge ... lowedge+width)",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html
https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html:19682,Integrability,depend,depend,19682,"e the result depends on the chosen option.; 533///; 534/// If the denominator becomes 0 or pass > total, the corresponding bin is; 535/// skipped.; 536///; 537/// ### 2) calculating ratios of two Poisson means (option 'pois'):; 538///; 539/// The two histograms are interpreted as independent Poisson processes and the ratio; 540/// \f[; 541/// \tau = \frac{n_{1}}{n_{2}} = \frac{\varepsilon}{1 - \varepsilon}; 542/// \f]; 543/// with \f$\varepsilon = \frac{n_{1}}{n_{1} + n_{2}}\f$.; 544/// The histogram 'pass' is interpreted as \f$n_{1}\f$ and the total histogram; 545/// is used for \f$n_{2}\f$.; 546///; 547/// The (asymmetric) uncertainties of the Poisson ratio are linked to the uncertainties; 548/// of efficiency by a parameter transformation:; 549/// \f[; 550/// \Delta \tau_{low/up} = \frac{1}{(1 - \varepsilon)^{2}} \Delta \varepsilon_{low/up}; 551/// \f]; 552///; 553/// The x errors span each histogram bin (lowedge ... lowedge+width); 554/// The y errors depend on the chosen statistic methode which can be determined; 555/// by the options given below. For a detailed description of the used statistic; 556/// calculations please have a look at the corresponding functions!; 557///; 558/// Options:; 559/// - v : verbose mode: prints information about the number of used bins; 560/// and calculated efficiencies with their errors; 561/// - cl=x : determine the used confidence level (0<x<1) (default is 0.683); 562/// - cp : Clopper-Pearson interval (see TEfficiency::ClopperPearson); 563/// - w : Wilson interval (see TEfficiency::Wilson); 564/// - n : normal approximation propagation (see TEfficiency::Normal); 565/// - ac : Agresti-Coull interval (see TEfficiency::AgrestiCoull); 566/// - fc : Feldman-Cousins interval (see TEfficiency::FeldmanCousinsInterval); 567/// - midp : Lancaster mid-P interval (see TEfficiency::MidPInterval); 568/// - b(a,b): bayesian interval using a prior probability ~Beta(a,b); a,b > 0; 569/// (see TEfficiency::Bayesian); 570/// - mode : use mode of",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html
https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html:70033,Integrability,message,message,70033," GetNbinsX() constDefinition TH1.h:297; TH1::GetBinLowEdgevirtual Double_t GetBinLowEdge(Int_t bin) constReturn bin lower edge for 1D histogram.Definition TH1.cxx:9152; TH1::GetBinContentvirtual Double_t GetBinContent(Int_t bin) constReturn content of bin number bin.Definition TH1.cxx:5061; TH1::GetSumw2virtual TArrayD * GetSumw2()Definition TH1.h:313; TH1::GetBinWidthvirtual Double_t GetBinWidth(Int_t bin) constReturn bin width for 1D histogram.Definition TH1.cxx:9163; TH1::GetSumOfWeightsvirtual Double_t GetSumOfWeights() constReturn the sum of weights excluding under/overflows.Definition TH1.cxx:7917; TIterDefinition TCollection.h:235; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TNamed::GetTitleconst char * GetTitle() const overrideReturns title of object.Definition TNamed.h:48; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::MakeZombievoid MakeZombie()Definition TObject.h:53; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::AtoiInt_t Atoi() constReturn integer value of string.Definition TString.cxx:1988; TString::AtofDouble_t Atof() constReturn floating-point value contained in string.Definition TString.cxx:2054; TString::IsFloatBool_t IsFloat() constReturns kTRUE if string contains a floating point or integer number.Definition TString.cxx:1858; TString::Dataconst char * Data() constDefinition TString.h:376; TString::IsDigitBool_t IsDigit() const",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html
https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html:70163,Integrability,message,message,70163,"1D histogram.Definition TH1.cxx:9152; TH1::GetBinContentvirtual Double_t GetBinContent(Int_t bin) constReturn content of bin number bin.Definition TH1.cxx:5061; TH1::GetSumw2virtual TArrayD * GetSumw2()Definition TH1.h:313; TH1::GetBinWidthvirtual Double_t GetBinWidth(Int_t bin) constReturn bin width for 1D histogram.Definition TH1.cxx:9163; TH1::GetSumOfWeightsvirtual Double_t GetSumOfWeights() constReturn the sum of weights excluding under/overflows.Definition TH1.cxx:7917; TIterDefinition TCollection.h:235; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TNamed::GetTitleconst char * GetTitle() const overrideReturns title of object.Definition TNamed.h:48; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::MakeZombievoid MakeZombie()Definition TObject.h:53; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::AtoiInt_t Atoi() constReturn integer value of string.Definition TString.cxx:1988; TString::AtofDouble_t Atof() constReturn floating-point value contained in string.Definition TString.cxx:2054; TString::IsFloatBool_t IsFloat() constReturns kTRUE if string contains a floating point or integer number.Definition TString.cxx:1858; TString::Dataconst char * Data() constDefinition TString.h:376; TString::IsDigitBool_t IsDigit() constReturns true if all characters in string are digits (0-9) or white spaces, i.e.Definition TString.cxx:1830; TString::ReplaceAllTStr",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html
https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html:70351,Integrability,message,message,70351," * GetSumw2()Definition TH1.h:313; TH1::GetBinWidthvirtual Double_t GetBinWidth(Int_t bin) constReturn bin width for 1D histogram.Definition TH1.cxx:9163; TH1::GetSumOfWeightsvirtual Double_t GetSumOfWeights() constReturn the sum of weights excluding under/overflows.Definition TH1.cxx:7917; TIterDefinition TCollection.h:235; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TNamed::GetTitleconst char * GetTitle() const overrideReturns title of object.Definition TNamed.h:48; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::MakeZombievoid MakeZombie()Definition TObject.h:53; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::AtoiInt_t Atoi() constReturn integer value of string.Definition TString.cxx:1988; TString::AtofDouble_t Atof() constReturn floating-point value contained in string.Definition TString.cxx:2054; TString::IsFloatBool_t IsFloat() constReturns kTRUE if string contains a floating point or integer number.Definition TString.cxx:1858; TString::Dataconst char * Data() constDefinition TString.h:376; TString::IsDigitBool_t IsDigit() constReturns true if all characters in string are digits (0-9) or white spaces, i.e.Definition TString.cxx:1830; TString::ReplaceAllTString & ReplaceAll(const TString &s1, const TString &s2)Definition TString.h:704; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html
https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html:13301,Modifiability,variab,variables,13301,"IsDigit()) {; 349 Error(""TGraphAsymmErrors"", ""Incorrect input format! Allowed format tags are {\""%%lg\"",\""%%*lg\"" or \""%%*s\""}"");; 350 return ;; 351 }; 352 Int_t ntokens = format_.Length() ;; 353 if (ntokens < 2) {; 354 Error(""TGraphAsymmErrors"", ""Incorrect input format! Only %d tag(s) in format whereas at least 2 \""%%lg\"" tags are expected!"", ntokens);; 355 return ;; 356 }; 357 Int_t ntokensToBeSaved = 0;; 358 Bool_t * isTokenToBeSaved = new Bool_t[ntokens];; 359 for (Int_t idx = 0; idx < ntokens; idx++) {; 360 isTokenToBeSaved[idx] = TString::Format(""%c"", format_[idx]).Atoi(); //atoi(&format_[idx]) does not work for some reason...; 361 if (isTokenToBeSaved[idx] == 1) {; 362 ntokensToBeSaved++ ;; 363 }; 364 }; 365 if (ntokens >= 2 && (ntokensToBeSaved < 2 || ntokensToBeSaved > 4)) { //first condition not to repeat the previous error message; 366 Error(""TGraphAsymmErrors"", ""Incorrect input format! There are %d \""%%lg\"" tag(s) in format whereas 2,3 or 4 are expected!"", ntokensToBeSaved);; 367 delete [] isTokenToBeSaved;; 368 return ;; 369 }; 370 ; 371 // Initializing loop variables; 372 Bool_t isLineToBeSkipped = kFALSE; //empty and ill-formed lines; 373 char *token = nullptr;; 374 TString token_str = """";; 375 Int_t token_idx = 0;; 376 Double_t value[6]; //x,y,exl, exh, eyl, eyh buffers; 377 for (Int_t k = 0; k < 6; k++); 378 value[k] = 0.;; 379 Int_t value_idx = 0;; 380 ; 381 // Looping; 382 char *rest;; 383 while (std::getline(infile, line, '\n')) {; 384 if (!line.empty()) {; 385 if (line[line.size() - 1] == char(13)) { // removing DOS CR character; 386 line.erase(line.end() - 1, line.end()) ;; 387 }; 388 token = R__STRTOK_R(const_cast<char*>(line.c_str()), option, &rest) ;; 389 while (token != nullptr && value_idx < ntokensToBeSaved) {; 390 if (isTokenToBeSaved[token_idx]) {; 391 token_str = TString(token) ;; 392 token_str.ReplaceAll(""\t"", """") ;; 393 if (!token_str.IsFloat()) {; 394 isLineToBeSkipped = kTRUE ;; 395 break ;; 396 } else {; 397 value[value_idx] = tok",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html
https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html:41574,Modifiability,inherit,inherit,41574,"//////; 1182/// Get low error on Y.; 1183 ; 1184Double_t TGraphAsymmErrors::GetErrorYlow(Int_t i) const; 1185{; 1186 if (i<0 || i>fNpoints) return -1;; 1187 if (fEYlow) return fEYlow[i];; 1188 return -1;; 1189}; 1190 ; 1191 ; 1192////////////////////////////////////////////////////////////////////////////////; 1193/// Adds all graphs with asymmetric errors from the collection to this graph.; 1194/// Returns the total number of points in the result or -1 in case of an error.; 1195 ; 1196Int_t TGraphAsymmErrors::Merge(TCollection* li); 1197{; 1198 TIter next(li);; 1199 while (TObject* o = next()) {; 1200 TGraph *g = dynamic_cast<TGraph*>(o);; 1201 if (!g) {; 1202 Error(""Merge"",; 1203 ""Cannot merge - an object which doesn't inherit from TGraph found in the list"");; 1204 return -1;; 1205 }; 1206 int n0 = GetN();; 1207 int n1 = n0+g->GetN();; 1208 Set(n1);; 1209 Double_t * x = g->GetX();; 1210 Double_t * y = g->GetY();; 1211 Double_t * exlow = g->GetEXlow();; 1212 Double_t * exhigh = g->GetEXhigh();; 1213 Double_t * eylow = g->GetEYlow();; 1214 Double_t * eyhigh = g->GetEYhigh();; 1215 for (Int_t i = 0 ; i < g->GetN(); i++) {; 1216 SetPoint(n0+i, x[i], y[i]);; 1217 if (exlow) fEXlow[n0+i] = exlow[i];; 1218 if (exhigh) fEXhigh[n0+i] = exhigh[i];; 1219 if (eylow) fEYlow[n0+i] = eylow[i];; 1220 if (eyhigh) fEYhigh[n0+i] = eyhigh[i];; 1221 }; 1222 }; 1223 return GetN();; 1224}; 1225 ; 1226////////////////////////////////////////////////////////////////////////////////; 1227/// Print graph and errors values.; 1228 ; 1229void TGraphAsymmErrors::Print(Option_t *) const; 1230{; 1231 for (Int_t i=0;i<fNpoints;i++) {; 1232 printf(""x[%d]=%g, y[%d]=%g, exl[%d]=%g, exh[%d]=%g, eyl[%d]=%g, eyh[%d]=%g\n""; 1233 ,i,fX[i],i,fY[i],i,fEXlow[i],i,fEXhigh[i],i,fEYlow[i],i,fEYhigh[i]);; 1234 }; 1235}; 1236 ; 1237 ; 1238////////////////////////////////////////////////////////////////////////////////; 1239/// Save primitive as a C++ statement(s) on output stream out.; 1240 ; 1241void TGraphAsymmE",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html
https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html:1276,Performance,perform,performed,1276,"********************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12 ; 13#include ""TEfficiency.h""; 14#include ""TROOT.h""; 15#include ""TBuffer.h""; 16#include ""TGraphAsymmErrors.h""; 17#include ""TGraphErrors.h""; 18#include ""TStyle.h""; 19#include ""TMath.h""; 20#include ""TVirtualPad.h""; 21#include ""TF1.h""; 22#include ""TH1.h""; 23#include ""TVector.h""; 24#include ""TVectorD.h""; 25#include ""TSystem.h""; 26#include ""Math/QuantFuncMathCore.h""; 27#include ""strtok.h""; 28 ; 29#include <cstring>; 30#include <iostream>; 31#include <fstream>; 32 ; 33 ; 34ClassImp(TGraphAsymmErrors);; 35 ; 36/** \class TGraphAsymmErrors; 37 \ingroup Graphs; 38TGraph with asymmetric error bars.; 39 ; 40The TGraphAsymmErrors painting is performed thanks to the TGraphPainter; 41class. All details about the various painting options are given in this class.; 42 ; 43The picture below gives an example:; 44 ; 45Begin_Macro(source); 46{; 47 auto c1 = new TCanvas(""c1"",""A Simple Graph with asymmetric error bars"",200,10,700,500);; 48 c1->SetFillColor(42);; 49 c1->SetGrid();; 50 c1->GetFrame()->SetFillColor(21);; 51 c1->GetFrame()->SetBorderSize(12);; 52 const Int_t n = 10;; 53 Double_t x[n] = {-0.22, 0.05, 0.25, 0.35, 0.5, 0.61,0.7,0.85,0.89,0.95};; 54 Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; 55 Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; 56 Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; 57 Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; 58 Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.4,.5,.6};; 59 auto gr = new TGraphAsymmErrors(n,x,y,exl,exh,eyl,eyh);; 60 gr->SetTitle(""TGraphAsymmErrors Example"");; 61 gr->SetMarkerColor(4);; 62 gr->SetMarkerStyle(21);; 63 gr->Draw(""ALP"");; 64}; 65End",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html
https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html:23525,Performance,perform,performed,23525,"lls(); ++i) {; 611 psumw += pass->GetBinContent(i);; 612 psumw2 += pass->GetSumw2()->At(i);; 613 }; 614 }; 615 else {; 616 psumw = pass->GetSumOfWeights();; 617 psumw2 = psumw;; 618 }; 619 if (TMath::Abs(psumw - psumw2) > 1e-6); 620 bEffective = true;; 621 ; 622 Double_t tsumw = 0;; 623 Double_t tsumw2 = 0;; 624 if (total->GetSumw2()->fN > 0) {; 625 for (int i = 0; i < total->GetNcells(); ++i) {; 626 tsumw += total->GetBinContent(i);; 627 tsumw2 += total->GetSumw2()->At(i);; 628 }; 629 }; 630 else {; 631 tsumw = total->GetSumOfWeights();; 632 tsumw2 = tsumw;; 633 }; 634 if (TMath::Abs(tsumw - tsumw2) > 1e-6); 635 bEffective = true;; 636 ; 637 ; 638 ; 639 // we do not want to ignore the weights; 640 // if (bEffective && (pass->GetSumw2()->fN == 0 || total->GetSumw2()->fN == 0) ) {; 641 // Warning(""Divide"",""histogram have been computed with weights but the sum of weight squares are not stored in the histogram. Error calculation is performed ignoring the weights"");; 642 // bEffective = false;; 643 // }; 644 ; 645 //parse option; 646 TString option = opt;; 647 option.ToLower();; 648 ; 649 Bool_t bVerbose = false;; 650 //pointer to function returning the boundaries of the confidence interval; 651 //(is only used in the frequentist cases.); 652 Double_t (*pBound)(Double_t,Double_t,Double_t,Bool_t) = &TEfficiency::ClopperPearson; // default method; 653 //confidence level; 654 Double_t conf = 0.682689492137;; 655 //values for bayesian statistics; 656 Bool_t bIsBayesian = false;; 657 Double_t alpha = 1;; 658 Double_t beta = 1;; 659 ; 660 //verbose mode; 661 if(option.Contains(""v"")) {; 662 option.ReplaceAll(""v"","""");; 663 bVerbose = true;; 664 if (bEffective); 665 Info(""Divide"",""weight will be considered in the Histogram Ratio"");; 666 }; 667 ; 668 ; 669 //confidence level; 670 if(option.Contains(""cl="")) {; 671 Double_t level = -1;; 672 // coverity [secure_coding : FALSE]; 673 sscanf(strstr(option.Data(),""cl=""),""cl=%lf"",&level);; 674 if((level > 0) && (level < 1)); 675 conf = le",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html
https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html:37280,Performance,perform,perform,37280,"n], &fEXlow[ibegin], n);; 1040 memmove(&arrays[1][obegin], &fEXhigh[ibegin], n);; 1041 memmove(&arrays[2][obegin], &fEYlow[ibegin], n);; 1042 memmove(&arrays[3][obegin], &fEYhigh[ibegin], n);; 1043 } else {; 1044 memmove(&fEXlow[obegin], &fEXlow[ibegin], n);; 1045 memmove(&fEXhigh[obegin], &fEXhigh[ibegin], n);; 1046 memmove(&fEYlow[obegin], &fEYlow[ibegin], n);; 1047 memmove(&fEYhigh[obegin], &fEYhigh[ibegin], n);; 1048 }; 1049 return kTRUE;; 1050 } else {; 1051 return kFALSE;; 1052 }; 1053}; 1054 ; 1055 ; 1056////////////////////////////////////////////////////////////////////////////////; 1057/// Should be called from ctors after `fNpoints` has been set.; 1058/// Note: This function should be called only from the constructor; 1059/// since it does not delete previously existing arrays; 1060 ; 1061Bool_t TGraphAsymmErrors::CtorAllocate(); 1062{; 1063 if (!fNpoints) {; 1064 fEXlow = fEYlow = fEXhigh = fEYhigh = nullptr;; 1065 return kFALSE;; 1066 }; 1067 fEXlow = new Double_t[fMaxSize];; 1068 fEYlow = new Double_t[fMaxSize];; 1069 fEXhigh = new Double_t[fMaxSize];; 1070 fEYhigh = new Double_t[fMaxSize];; 1071 return kTRUE;; 1072}; 1073 ; 1074////////////////////////////////////////////////////////////////////////////////; 1075/// Protected function to perform the merge operation of a graph with asymmetric errors.; 1076 ; 1077Bool_t TGraphAsymmErrors::DoMerge(const TGraph *g); 1078{; 1079 if (g->GetN() == 0) return kFALSE;; 1080 ; 1081 Double_t * exl = g->GetEXlow();; 1082 Double_t * exh = g->GetEXhigh();; 1083 Double_t * eyl = g->GetEYlow();; 1084 Double_t * eyh = g->GetEYhigh();; 1085 if (exl == nullptr || exh == nullptr || eyl == nullptr || eyh == nullptr) {; 1086 if (g->IsA() != TGraph::Class() ); 1087 Warning(""DoMerge"",""Merging a %s is not compatible with a TGraphAsymmErrors - errors will be ignored"",g->IsA()->GetName());; 1088 return TGraph::DoMerge(g);; 1089 }; 1090 for (Int_t i = 0 ; i < g->GetN(); i++) {; 1091 Int_t ipoint = GetN();; 1092 Double_t x = g->Ge",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html
https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html:63383,Performance,perform,perform,63383,"const std::vector< Int_t > &sorting_indices, Int_t numSortedPoints, Int_t low) overrideUpdate the fX, fY, fEXlow, fEXhigh, fEYlow and fEYhigh arrays with the sorted values.Definition TGraphAsymmErrors.cxx:1468; TGraphAsymmErrors::SwapPointsvoid SwapPoints(Int_t pos1, Int_t pos2) overrideSwap points.Definition TGraphAsymmErrors.cxx:1456; TGraphAsymmErrors::GetEXhighDouble_t * GetEXhigh() const overrideDefinition TGraphAsymmErrors.h:75; TGraphAsymmErrors::fEXlowDouble_t * fEXlow[fNpoints] array of X low errorsDefinition TGraphAsymmErrors.h:29; TGraphAsymmErrors::Applyvoid Apply(TF1 *f) overrideApply a function to all data points .Definition TGraphAsymmErrors.cxx:468; TGraphAsymmErrors::AllocateDouble_t ** Allocate(Int_t size) overrideAllocate internal data structures for size points.Definition TGraphAsymmErrors.cxx:444; TGraphAsymmErrors::GetEYlowDouble_t * GetEYlow() const overrideDefinition TGraphAsymmErrors.h:76; TGraphAsymmErrors::DoMergeBool_t DoMerge(const TGraph *g) overrideProtected function to perform the merge operation of a graph with asymmetric errors.Definition TGraphAsymmErrors.cxx:1077; TGraphAsymmErrors::CopyAndReleasevoid CopyAndRelease(Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy and release.Definition TGraphAsymmErrors.cxx:1007; TGraphAsymmErrors::IsATClass * IsA() const overrideDefinition TGraphAsymmErrors.h:89; TGraphAsymmErrors::SetPointEXhighvirtual void SetPointEXhigh(Int_t i, Double_t exh)Set EXhigh for point i.Definition TGraphAsymmErrors.cxx:1362; TGraphAsymmErrors::GetErrorYlowDouble_t GetErrorYlow(Int_t i) const overrideGet low error on Y.Definition TGraphAsymmErrors.cxx:1184; TGraphAsymmErrors::GetErrorXDouble_t GetErrorX(Int_t bin) const overrideReturns the combined error along X at point i by computing the average of the lower and upper varianc...Definition TGraphAsymmErrors.cxx:1122; TGraphAsymmErrors::TGraphAsymmErrorsTGraphAsymmErrors()TGraphAsymmErrors default constructor.Definition TGraphAsymmErrors.cx",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html
https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html:67344,Performance,perform,perform,67344,"et fNpoints than call this method.Definition TGraph.cxx:805; TGraph::SaveArrayTString SaveArray(std::ostream &out, const char *suffix, Int_t frameNumber, Double_t *arr)Save array as C++ code Returns name of created array.Definition TGraph.cxx:2175; TGraph::ComputeRangevirtual void ComputeRange(Double_t &xmin, Double_t &ymin, Double_t &xmax, Double_t &ymax) constCompute the x/y range of the points in this graph.Definition TGraph.cxx:731; TGraph::AllocateArraysDouble_t ** AllocateArrays(Int_t Narrays, Int_t arraySize)Allocate arrays.Definition TGraph.cxx:598; TGraph::Scalevirtual void Scale(Double_t c1=1., Option_t *option=""y"")Multiply the values of a TGraph by a constant c1.Definition TGraph.cxx:2259; TGraph::SwapValuesstatic void SwapValues(Double_t *arr, Int_t pos1, Int_t pos2)Swap values.Definition TGraph.cxx:2611; TGraph::Streamervoid Streamer(TBuffer &) overrideStream an object of class TGraph.Definition TGraph.cxx:2516; TGraph::DoMergevirtual Bool_t DoMerge(const TGraph *g)protected function to perform the merge operation of a graphDefinition TGraph.cxx:2676; TGraph::SetNamevoid SetName(const char *name="""") overrideSet graph name.Definition TGraph.cxx:2381; TGraph::SwapPointsvirtual void SwapPoints(Int_t pos1, Int_t pos2)Swap points.Definition TGraph.cxx:2583; TGraph::FillZerovirtual void FillZero(Int_t begin, Int_t end, Bool_t from_ctor=kTRUE)Set zero values for point arrays in the range [begin, end) Should be redefined in descendant classes.Definition TGraph.cxx:1102; TGraph::fXDouble_t * fX[fNpoints] array of X pointsDefinition TGraph.h:47; TGraph::SetTitlevoid SetTitle(const char *title="""") overrideChange (i.e.Definition TGraph.cxx:2397; TGraph::Setvirtual void Set(Int_t n)Set number of points in the graph Existing coordinates are preserved New coordinates above fNpoints a...Definition TGraph.cxx:2277; TGraph::GetPointvirtual Int_t GetPoint(Int_t i, Double_t &x, Double_t &y) constGet x and y values for point number i.Definition TGraph.cxx:1533; TGraph::Copy",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html
https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html:10113,Safety,avoid,avoid,10113,"tring(total->GetName());; 271 SetName(sname.c_str());; 272 SetTitle(pass->GetTitle());; 273 ; 274 //copy style from pass; 275 pass->TAttLine::Copy(*this);; 276 pass->TAttFill::Copy(*this);; 277 pass->TAttMarker::Copy(*this);; 278 ; 279 Divide(pass, total, option);; 280}; 281 ; 282 ; 283////////////////////////////////////////////////////////////////////////////////; 284/// TGraphAsymmErrors constructor reading input from filename; 285/// filename is assumed to contain at least 2 columns of numbers; 286///; 287/// convention for format (default=`""%lg %lg %lg %lg %lg %lg""`); 288/// - format = `""%lg %lg""` read only 2 first columns into X, Y; 289/// - format = `""%lg %lg %lg %lg""` read only 4 first columns into X, Y, ELY, EHY; 290/// - format = `""%lg %lg %lg %lg %lg %lg""` read only 6 first columns into X, Y, EXL, EYH, EYL, EHY; 291///; 292/// For files separated by a specific delimiter different from `' '` and `'\\t'` (e.g. `';'` in csv files); 293/// you can avoid using `%*s` to bypass this delimiter by explicitly specify the `""option"" argument,; 294/// e.g. `option="" \\t,;""` for columns of figures separated by any of these characters `(' ', '\\t', ',', ';')`; 295/// used once `(e.g. ""1;1"")` or in a combined way `("" 1;,;; 1"")`.; 296/// Note in that case, the instantiation is about 2 times slower.; 297/// In case a delimiter is specified, the format `""%lg %lg %lg""` will read X,Y,EX.; 298 ; 299TGraphAsymmErrors::TGraphAsymmErrors(const char *filename, const char *format, Option_t *option); 300 : TGraph(100); 301{; 302 if (!CtorAllocate()) return;; 303 Double_t x, y, exl, exh, eyl, eyh;; 304 TString fname = filename;; 305 gSystem->ExpandPathName(fname);; 306 std::ifstream infile(fname.Data());; 307 if (!infile.good()) {; 308 MakeZombie();; 309 Error(""TGraphAsymmErrors"", ""Cannot open file: %s, TGraphAsymmErrors is Zombie"", filename);; 310 fNpoints = 0;; 311 return;; 312 }; 313 std::string line;; 314 Int_t np = 0;; 315 ; 316 if (strcmp(option, """") == 0) { // No delimiters sp",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html
https://root.cern/doc/master/TGraphAsymmErrors_8h_source.html:862,Availability,error,error,862,". ROOT: hist/hist/inc/TGraphAsymmErrors.h Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TGraphAsymmErrors.h. Go to the documentation of this file. 1// @(#)root/hist:$Id$; 2// Author: Rene Brun 03/03/99; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#ifndef ROOT_TGraphAsymmErrors; 13#define ROOT_TGraphAsymmErrors; 14 ; 15 ; 16//////////////////////////////////////////////////////////////////////////; 17// //; 18// TGraphAsymmErrors //; 19// //; 20// a Graph with asymmetric error bars //; 21// //; 22//////////////////////////////////////////////////////////////////////////; 23 ; 24#include ""TGraph.h""; 25 ; 26class TGraphAsymmErrors : public TGraph {; 27 ; 28protected:; 29 Double_t *fEXlow{nullptr}; ///<[fNpoints] array of X low errors; 30 Double_t *fEXhigh{nullptr}; ///<[fNpoints] array of X high errors; 31 Double_t *fEYlow{nullptr}; ///<[fNpoints] array of Y low errors; 32 Double_t *fEYhigh{nullptr}; ///<[fNpoints] array of Y high errors; 33 ; 34 void SwapPoints(Int_t pos1, Int_t pos2) override;; 35 void UpdateArrays(const std::vector<Int_t> &sorting_indices, Int_t numSortedPoints, Int_t low) override;; 36 ; 37 Double_t** Allocate(Int_t size) override;; 38 void CopyAndRelease(Double_t **newarrays,; 39 Int_t ibegin, Int_t iend, Int_t obegin) override;; 40 Bool_t CopyPoints(Double_t **arrays, Int_t ibegin, Int_t iend,; 41 Int_t obegin) override;; 42 Bool_t CtorAllocate();; 43 void FillZero(Int_t begin, Int_t end,; 44 Bool_t from_ctor = kTRUE) override;; 45 Bool_t DoMerge(const TGraph * g) override;; 46 ; 47public:; 48 TGraphAsymmErrors();; 49 TGraphAsymmErrors(Int_t n);; 50 TGraphAsymmErrors(",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8h_source.html
https://root.cern/doc/master/TGraphAsymmErrors_8h_source.html:1121,Availability,error,errors,1121,"h""; 25 ; 26class TGraphAsymmErrors : public TGraph {; 27 ; 28protected:; 29 Double_t *fEXlow{nullptr}; ///<[fNpoints] array of X low errors; 30 Double_t *fEXhigh{nullptr}; ///<[fNpoints] array of X high errors; 31 Double_t *fEYlow{nullptr}; ///<[fNpoints] array of Y low errors; 32 Double_t *fEYhigh{nullptr}; ///<[fNpoints] array of Y high errors; 33 ; 34 void SwapPoints(Int_t pos1, Int_t pos2) override;; 35 void UpdateArrays(const std::vector<Int_t> &sorting_indices, Int_t numSortedPoints, Int_t low) override;; 36 ; 37 Double_t** Allocate(Int_t size) override;; 38 void CopyAndRelease(Double_t **newarrays,; 39 Int_t ibegin, Int_t iend, Int_t obegin) override;; 40 Bool_t CopyPoints(Double_t **arrays, Int_t ibegin, Int_t iend,; 41 Int_t obegin) override;; 42 Bool_t CtorAllocate();; 43 void FillZero(Int_t begin, Int_t end,; 44 Bool_t from_ctor = kTRUE) override;; 45 Bool_t DoMerge(const TGraph * g) override;; 46 ; 47public:; 48 TGraphAsymmErrors();; 49 TGraphAsymmErrors(Int_t n);; 50 TGraphAsymmErrors(",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8h_source.html
https://root.cern/doc/master/TGraphAsymmErrors_8h_source.html:1191,Availability,error,errors,1191,"h""; 25 ; 26class TGraphAsymmErrors : public TGraph {; 27 ; 28protected:; 29 Double_t *fEXlow{nullptr}; ///<[fNpoints] array of X low errors; 30 Double_t *fEXhigh{nullptr}; ///<[fNpoints] array of X high errors; 31 Double_t *fEYlow{nullptr}; ///<[fNpoints] array of Y low errors; 32 Double_t *fEYhigh{nullptr}; ///<[fNpoints] array of Y high errors; 33 ; 34 void SwapPoints(Int_t pos1, Int_t pos2) override;; 35 void UpdateArrays(const std::vector<Int_t> &sorting_indices, Int_t numSortedPoints, Int_t low) override;; 36 ; 37 Double_t** Allocate(Int_t size) override;; 38 void CopyAndRelease(Double_t **newarrays,; 39 Int_t ibegin, Int_t iend, Int_t obegin) override;; 40 Bool_t CopyPoints(Double_t **arrays, Int_t ibegin, Int_t iend,; 41 Int_t obegin) override;; 42 Bool_t CtorAllocate();; 43 void FillZero(Int_t begin, Int_t end,; 44 Bool_t from_ctor = kTRUE) override;; 45 Bool_t DoMerge(const TGraph * g) override;; 46 ; 47public:; 48 TGraphAsymmErrors();; 49 TGraphAsymmErrors(Int_t n);; 50 TGraphAsymmErrors(",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8h_source.html
https://root.cern/doc/master/TGraphAsymmErrors_8h_source.html:1259,Availability,error,errors,1259,"h""; 25 ; 26class TGraphAsymmErrors : public TGraph {; 27 ; 28protected:; 29 Double_t *fEXlow{nullptr}; ///<[fNpoints] array of X low errors; 30 Double_t *fEXhigh{nullptr}; ///<[fNpoints] array of X high errors; 31 Double_t *fEYlow{nullptr}; ///<[fNpoints] array of Y low errors; 32 Double_t *fEYhigh{nullptr}; ///<[fNpoints] array of Y high errors; 33 ; 34 void SwapPoints(Int_t pos1, Int_t pos2) override;; 35 void UpdateArrays(const std::vector<Int_t> &sorting_indices, Int_t numSortedPoints, Int_t low) override;; 36 ; 37 Double_t** Allocate(Int_t size) override;; 38 void CopyAndRelease(Double_t **newarrays,; 39 Int_t ibegin, Int_t iend, Int_t obegin) override;; 40 Bool_t CopyPoints(Double_t **arrays, Int_t ibegin, Int_t iend,; 41 Int_t obegin) override;; 42 Bool_t CtorAllocate();; 43 void FillZero(Int_t begin, Int_t end,; 44 Bool_t from_ctor = kTRUE) override;; 45 Bool_t DoMerge(const TGraph * g) override;; 46 ; 47public:; 48 TGraphAsymmErrors();; 49 TGraphAsymmErrors(Int_t n);; 50 TGraphAsymmErrors(",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8h_source.html
https://root.cern/doc/master/TGraphAsymmErrors_8h_source.html:1329,Availability,error,errors,1329,"h""; 25 ; 26class TGraphAsymmErrors : public TGraph {; 27 ; 28protected:; 29 Double_t *fEXlow{nullptr}; ///<[fNpoints] array of X low errors; 30 Double_t *fEXhigh{nullptr}; ///<[fNpoints] array of X high errors; 31 Double_t *fEYlow{nullptr}; ///<[fNpoints] array of Y low errors; 32 Double_t *fEYhigh{nullptr}; ///<[fNpoints] array of Y high errors; 33 ; 34 void SwapPoints(Int_t pos1, Int_t pos2) override;; 35 void UpdateArrays(const std::vector<Int_t> &sorting_indices, Int_t numSortedPoints, Int_t low) override;; 36 ; 37 Double_t** Allocate(Int_t size) override;; 38 void CopyAndRelease(Double_t **newarrays,; 39 Int_t ibegin, Int_t iend, Int_t obegin) override;; 40 Bool_t CopyPoints(Double_t **arrays, Int_t ibegin, Int_t iend,; 41 Int_t obegin) override;; 42 Bool_t CtorAllocate();; 43 void FillZero(Int_t begin, Int_t end,; 44 Bool_t from_ctor = kTRUE) override;; 45 Bool_t DoMerge(const TGraph * g) override;; 46 ; 47public:; 48 TGraphAsymmErrors();; 49 TGraphAsymmErrors(Int_t n);; 50 TGraphAsymmErrors(",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8h_source.html
https://root.cern/doc/master/TGraphAsymmErrors_8h_source.html:4757,Availability,error,error,4757,"st override;; 69 Double_t GetErrorY(Int_t bin) const override;; 70 Double_t GetErrorXlow(Int_t i) const override;; 71 Double_t GetErrorXhigh(Int_t i) const override;; 72 Double_t GetErrorYlow(Int_t i) const override;; 73 Double_t GetErrorYhigh(Int_t i) const override;; 74 Double_t *GetEXlow() const override {return fEXlow;}; 75 Double_t *GetEXhigh() const override {return fEXhigh;}; 76 Double_t *GetEYlow() const override {return fEYlow;}; 77 Double_t *GetEYhigh() const override {return fEYhigh;}; 78 Int_t Merge(TCollection* list) override;; 79 void Print(Option_t *chopt="""") const override;; 80 void SavePrimitive(std::ostream &out, Option_t *option = """") override;; 81 void Scale(Double_t c1=1., Option_t *option=""y"") override; // *MENU*; 82 virtual void SetPointError(Double_t exl, Double_t exh, Double_t eyl, Double_t eyh); // *MENU*; 83 virtual void SetPointError(Int_t i, Double_t exl, Double_t exh, Double_t eyl, Double_t eyh);; 84 virtual void SetPointEXlow(Int_t i, Double_t exl);; 85 virtual void SetPointEXhigh(Int_t i, Double_t exh);; 86 virtual void SetPointEYlow(Int_t i, Double_t eyl);; 87 virtual void SetPointEYhigh(Int_t i, Double_t eyh);; 88 ; 89 ClassDefOverride(TGraphAsymmErrors,3) //A graph with asymmetric error bars; 90};; 91 ; 92#endif; f#define f(i)Definition RSha256.hxx:104; g#define g(i)Definition RSha256.hxx:105; h#define h(i)Definition RSha256.hxx:106; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; Float_tfloat Float_tDefinition RtypesCore.h:57; Double_tdouble Double_tDefinition RtypesCore.h:59; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; Option_tconst char Option_tDefinition RtypesCore.h:66; ClassDefOverride#define ClassDefOverride(name, id)Definition Rtypes.h:346; totalstatic unsigned int totalDefinition TGWin32ProxyDefs.h:40; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; filenameOption_t Option_t TPo",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8h_source.html
https://root.cern/doc/master/TGraphAsymmErrors_8h_source.html:7334,Availability,error,error,7334,"void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t formatDefinition TGWin32VirtualXProxy.cxx:249; TGraph.h; xminfloat xminDefinition THbookFile.cxx:95; yminfloat yminDefinition THbookFile.cxx:95; xmaxfloat xmaxDefinition THbookFile.cxx:95; ymaxfloat ymaxDefinition THbookFile.cxx:95; TCollectionCollection abstract base class.Definition TCollection.h:65; TF11-Dim function classDefinition TF1.h:233; TGraphAsymmErrorsTGraph with asymmetric error bars.Definition TGraphAsymmErrors.h:26; TGraphAsymmErrors::GetEXlowDouble_t * GetEXlow() const overrideDefinition TGraphAsymmErrors.h:74; TGraphAsymmErrors::SetPointEYlowvirtual void SetPointEYlow(Int_t i, Double_t eyl)Set EYlow for point i.Definition TGraphAsymmErrors.cxx:1376; TGraphAsymmErrors::fEXhighDouble_t * fEXhigh[fNpoints] array of X high errorsDefinition TGraphAsymmErrors.h:30; TGraphAsymmErrors::GetErrorYDouble_t GetErrorY(Int_t bin) const overrideReturns the combined error along Y at point i by computing the average of the lower and upper varianc...Definition TGraphAsymmErrors.cxx:1137; TGraphAsymmErrors::FillZerovoid FillZero(Int_t begin, Int_t end, Bool_t from_ctor=kTRUE) overrideSet zero values for point arrays in the range [begin, end]Definition TGraphAsymmErrors.cxx:1104; TGraphAsymmErrors::Dividevirtual void Divide(const TH1 *pass, const TH1 *total, Option_t *opt=""cp"")Fill this TGraphAsymmErrors by dividing two 1-dimensional histograms pass/to",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8h_source.html
https://root.cern/doc/master/TGraphAsymmErrors_8h_source.html:7691,Availability,error,errorsDefinition,7691,"nding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t formatDefinition TGWin32VirtualXProxy.cxx:249; TGraph.h; xminfloat xminDefinition THbookFile.cxx:95; yminfloat yminDefinition THbookFile.cxx:95; xmaxfloat xmaxDefinition THbookFile.cxx:95; ymaxfloat ymaxDefinition THbookFile.cxx:95; TCollectionCollection abstract base class.Definition TCollection.h:65; TF11-Dim function classDefinition TF1.h:233; TGraphAsymmErrorsTGraph with asymmetric error bars.Definition TGraphAsymmErrors.h:26; TGraphAsymmErrors::GetEXlowDouble_t * GetEXlow() const overrideDefinition TGraphAsymmErrors.h:74; TGraphAsymmErrors::SetPointEYlowvirtual void SetPointEYlow(Int_t i, Double_t eyl)Set EYlow for point i.Definition TGraphAsymmErrors.cxx:1376; TGraphAsymmErrors::fEXhighDouble_t * fEXhigh[fNpoints] array of X high errorsDefinition TGraphAsymmErrors.h:30; TGraphAsymmErrors::GetErrorYDouble_t GetErrorY(Int_t bin) const overrideReturns the combined error along Y at point i by computing the average of the lower and upper varianc...Definition TGraphAsymmErrors.cxx:1137; TGraphAsymmErrors::FillZerovoid FillZero(Int_t begin, Int_t end, Bool_t from_ctor=kTRUE) overrideSet zero values for point arrays in the range [begin, end]Definition TGraphAsymmErrors.cxx:1104; TGraphAsymmErrors::Dividevirtual void Divide(const TH1 *pass, const TH1 *total, Option_t *opt=""cp"")Fill this TGraphAsymmErrors by dividing two 1-dimensional histograms pass/total.Definition TGraphAsymmErrors.cxx:588; TGraphAsymmErrors::CtorAllocateBool_t CtorAllocate()Should be called from ctors after fNpoints has been set.Definition TGraphAsymmErrors.cxx:1061; TGraphAsymmErrors::SetPointErrorvirtual void SetPointError(Double_t exl, Double_t exh, Double_t eyl, Double_t eyh)Set ex and ey values for point pointed by the mou",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8h_source.html
https://root.cern/doc/master/TGraphAsymmErrors_8h_source.html:7825,Availability,error,error,7825,"nst char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t formatDefinition TGWin32VirtualXProxy.cxx:249; TGraph.h; xminfloat xminDefinition THbookFile.cxx:95; yminfloat yminDefinition THbookFile.cxx:95; xmaxfloat xmaxDefinition THbookFile.cxx:95; ymaxfloat ymaxDefinition THbookFile.cxx:95; TCollectionCollection abstract base class.Definition TCollection.h:65; TF11-Dim function classDefinition TF1.h:233; TGraphAsymmErrorsTGraph with asymmetric error bars.Definition TGraphAsymmErrors.h:26; TGraphAsymmErrors::GetEXlowDouble_t * GetEXlow() const overrideDefinition TGraphAsymmErrors.h:74; TGraphAsymmErrors::SetPointEYlowvirtual void SetPointEYlow(Int_t i, Double_t eyl)Set EYlow for point i.Definition TGraphAsymmErrors.cxx:1376; TGraphAsymmErrors::fEXhighDouble_t * fEXhigh[fNpoints] array of X high errorsDefinition TGraphAsymmErrors.h:30; TGraphAsymmErrors::GetErrorYDouble_t GetErrorY(Int_t bin) const overrideReturns the combined error along Y at point i by computing the average of the lower and upper varianc...Definition TGraphAsymmErrors.cxx:1137; TGraphAsymmErrors::FillZerovoid FillZero(Int_t begin, Int_t end, Bool_t from_ctor=kTRUE) overrideSet zero values for point arrays in the range [begin, end]Definition TGraphAsymmErrors.cxx:1104; TGraphAsymmErrors::Dividevirtual void Divide(const TH1 *pass, const TH1 *total, Option_t *opt=""cp"")Fill this TGraphAsymmErrors by dividing two 1-dimensional histograms pass/total.Definition TGraphAsymmErrors.cxx:588; TGraphAsymmErrors::CtorAllocateBool_t CtorAllocate()Should be called from ctors after fNpoints has been set.Definition TGraphAsymmErrors.cxx:1061; TGraphAsymmErrors::SetPointErrorvirtual void SetPointError(Double_t exl, Double_t exh, Double_t eyl, Double_t eyh)Set ex and ey values for point pointed by the mouse.Definition TGraphAsymmErrors.cxx:1299; TGraphAsymmErrors::GetErrorXhighDouble_t GetErrorXhigh(Int_t i) const overrideGet high error on X.Definiti",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8h_source.html
https://root.cern/doc/master/TGraphAsymmErrors_8h_source.html:8797,Availability,error,error,8797,"ErrorYDouble_t GetErrorY(Int_t bin) const overrideReturns the combined error along Y at point i by computing the average of the lower and upper varianc...Definition TGraphAsymmErrors.cxx:1137; TGraphAsymmErrors::FillZerovoid FillZero(Int_t begin, Int_t end, Bool_t from_ctor=kTRUE) overrideSet zero values for point arrays in the range [begin, end]Definition TGraphAsymmErrors.cxx:1104; TGraphAsymmErrors::Dividevirtual void Divide(const TH1 *pass, const TH1 *total, Option_t *opt=""cp"")Fill this TGraphAsymmErrors by dividing two 1-dimensional histograms pass/total.Definition TGraphAsymmErrors.cxx:588; TGraphAsymmErrors::CtorAllocateBool_t CtorAllocate()Should be called from ctors after fNpoints has been set.Definition TGraphAsymmErrors.cxx:1061; TGraphAsymmErrors::SetPointErrorvirtual void SetPointError(Double_t exl, Double_t exh, Double_t eyl, Double_t eyh)Set ex and ey values for point pointed by the mouse.Definition TGraphAsymmErrors.cxx:1299; TGraphAsymmErrors::GetErrorXhighDouble_t GetErrorXhigh(Int_t i) const overrideGet high error on X.Definition TGraphAsymmErrors.cxx:1151; TGraphAsymmErrors::fEYhighDouble_t * fEYhigh[fNpoints] array of Y high errorsDefinition TGraphAsymmErrors.h:32; TGraphAsymmErrors::CopyPointsBool_t CopyPoints(Double_t **arrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy errors from fE*** to arrays[***] or to f*** Copy points.Definition TGraphAsymmErrors.cxx:1033; TGraphAsymmErrors::AddPointErrorvirtual void AddPointError(Double_t x, Double_t y, Double_t exl=0., Double_t exh=0., Double_t eyl=0., Double_t eyh=0.)Add a point with asymmetric errorbars to the graph.Definition TGraphAsymmErrors.cxx:451; TGraphAsymmErrors::ComputeRangevoid ComputeRange(Double_t &xmin, Double_t &ymin, Double_t &xmax, Double_t &ymax) const overrideCompute Range.Definition TGraphAsymmErrors.cxx:977; TGraphAsymmErrors::SetPointEXlowvirtual void SetPointEXlow(Int_t i, Double_t exl)Set EXlow for point i.Definition TGraphAsymmErrors.cxx:1348; TGraphAsymmErrors::Se",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8h_source.html
https://root.cern/doc/master/TGraphAsymmErrors_8h_source.html:8918,Availability,error,errorsDefinition,8918,"er varianc...Definition TGraphAsymmErrors.cxx:1137; TGraphAsymmErrors::FillZerovoid FillZero(Int_t begin, Int_t end, Bool_t from_ctor=kTRUE) overrideSet zero values for point arrays in the range [begin, end]Definition TGraphAsymmErrors.cxx:1104; TGraphAsymmErrors::Dividevirtual void Divide(const TH1 *pass, const TH1 *total, Option_t *opt=""cp"")Fill this TGraphAsymmErrors by dividing two 1-dimensional histograms pass/total.Definition TGraphAsymmErrors.cxx:588; TGraphAsymmErrors::CtorAllocateBool_t CtorAllocate()Should be called from ctors after fNpoints has been set.Definition TGraphAsymmErrors.cxx:1061; TGraphAsymmErrors::SetPointErrorvirtual void SetPointError(Double_t exl, Double_t exh, Double_t eyl, Double_t eyh)Set ex and ey values for point pointed by the mouse.Definition TGraphAsymmErrors.cxx:1299; TGraphAsymmErrors::GetErrorXhighDouble_t GetErrorXhigh(Int_t i) const overrideGet high error on X.Definition TGraphAsymmErrors.cxx:1151; TGraphAsymmErrors::fEYhighDouble_t * fEYhigh[fNpoints] array of Y high errorsDefinition TGraphAsymmErrors.h:32; TGraphAsymmErrors::CopyPointsBool_t CopyPoints(Double_t **arrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy errors from fE*** to arrays[***] or to f*** Copy points.Definition TGraphAsymmErrors.cxx:1033; TGraphAsymmErrors::AddPointErrorvirtual void AddPointError(Double_t x, Double_t y, Double_t exl=0., Double_t exh=0., Double_t eyl=0., Double_t eyh=0.)Add a point with asymmetric errorbars to the graph.Definition TGraphAsymmErrors.cxx:451; TGraphAsymmErrors::ComputeRangevoid ComputeRange(Double_t &xmin, Double_t &ymin, Double_t &xmax, Double_t &ymax) const overrideCompute Range.Definition TGraphAsymmErrors.cxx:977; TGraphAsymmErrors::SetPointEXlowvirtual void SetPointEXlow(Int_t i, Double_t exl)Set EXlow for point i.Definition TGraphAsymmErrors.cxx:1348; TGraphAsymmErrors::SetPointEYhighvirtual void SetPointEYhigh(Int_t i, Double_t eyh)Set EYhigh for point i.Definition TGraphAsymmErrors.cxx:1390; TGraphAsymmErrors",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8h_source.html
https://root.cern/doc/master/TGraphAsymmErrors_8h_source.html:9078,Availability,error,errors,9078,"eSet zero values for point arrays in the range [begin, end]Definition TGraphAsymmErrors.cxx:1104; TGraphAsymmErrors::Dividevirtual void Divide(const TH1 *pass, const TH1 *total, Option_t *opt=""cp"")Fill this TGraphAsymmErrors by dividing two 1-dimensional histograms pass/total.Definition TGraphAsymmErrors.cxx:588; TGraphAsymmErrors::CtorAllocateBool_t CtorAllocate()Should be called from ctors after fNpoints has been set.Definition TGraphAsymmErrors.cxx:1061; TGraphAsymmErrors::SetPointErrorvirtual void SetPointError(Double_t exl, Double_t exh, Double_t eyl, Double_t eyh)Set ex and ey values for point pointed by the mouse.Definition TGraphAsymmErrors.cxx:1299; TGraphAsymmErrors::GetErrorXhighDouble_t GetErrorXhigh(Int_t i) const overrideGet high error on X.Definition TGraphAsymmErrors.cxx:1151; TGraphAsymmErrors::fEYhighDouble_t * fEYhigh[fNpoints] array of Y high errorsDefinition TGraphAsymmErrors.h:32; TGraphAsymmErrors::CopyPointsBool_t CopyPoints(Double_t **arrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy errors from fE*** to arrays[***] or to f*** Copy points.Definition TGraphAsymmErrors.cxx:1033; TGraphAsymmErrors::AddPointErrorvirtual void AddPointError(Double_t x, Double_t y, Double_t exl=0., Double_t exh=0., Double_t eyl=0., Double_t eyh=0.)Add a point with asymmetric errorbars to the graph.Definition TGraphAsymmErrors.cxx:451; TGraphAsymmErrors::ComputeRangevoid ComputeRange(Double_t &xmin, Double_t &ymin, Double_t &xmax, Double_t &ymax) const overrideCompute Range.Definition TGraphAsymmErrors.cxx:977; TGraphAsymmErrors::SetPointEXlowvirtual void SetPointEXlow(Int_t i, Double_t exl)Set EXlow for point i.Definition TGraphAsymmErrors.cxx:1348; TGraphAsymmErrors::SetPointEYhighvirtual void SetPointEYhigh(Int_t i, Double_t eyh)Set EYhigh for point i.Definition TGraphAsymmErrors.cxx:1390; TGraphAsymmErrors::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave primitive as a C++ statement(s) on output stream out.Definitio",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8h_source.html
https://root.cern/doc/master/TGraphAsymmErrors_8h_source.html:9351,Availability,error,errorbars,9351,".cxx:588; TGraphAsymmErrors::CtorAllocateBool_t CtorAllocate()Should be called from ctors after fNpoints has been set.Definition TGraphAsymmErrors.cxx:1061; TGraphAsymmErrors::SetPointErrorvirtual void SetPointError(Double_t exl, Double_t exh, Double_t eyl, Double_t eyh)Set ex and ey values for point pointed by the mouse.Definition TGraphAsymmErrors.cxx:1299; TGraphAsymmErrors::GetErrorXhighDouble_t GetErrorXhigh(Int_t i) const overrideGet high error on X.Definition TGraphAsymmErrors.cxx:1151; TGraphAsymmErrors::fEYhighDouble_t * fEYhigh[fNpoints] array of Y high errorsDefinition TGraphAsymmErrors.h:32; TGraphAsymmErrors::CopyPointsBool_t CopyPoints(Double_t **arrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy errors from fE*** to arrays[***] or to f*** Copy points.Definition TGraphAsymmErrors.cxx:1033; TGraphAsymmErrors::AddPointErrorvirtual void AddPointError(Double_t x, Double_t y, Double_t exl=0., Double_t exh=0., Double_t eyl=0., Double_t eyh=0.)Add a point with asymmetric errorbars to the graph.Definition TGraphAsymmErrors.cxx:451; TGraphAsymmErrors::ComputeRangevoid ComputeRange(Double_t &xmin, Double_t &ymin, Double_t &xmax, Double_t &ymax) const overrideCompute Range.Definition TGraphAsymmErrors.cxx:977; TGraphAsymmErrors::SetPointEXlowvirtual void SetPointEXlow(Int_t i, Double_t exl)Set EXlow for point i.Definition TGraphAsymmErrors.cxx:1348; TGraphAsymmErrors::SetPointEYhighvirtual void SetPointEYhigh(Int_t i, Double_t eyh)Set EYhigh for point i.Definition TGraphAsymmErrors.cxx:1390; TGraphAsymmErrors::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave primitive as a C++ statement(s) on output stream out.Definition TGraphAsymmErrors.cxx:1241; TGraphAsymmErrors::BayesDividevirtual void BayesDivide(const TH1 *pass, const TH1 *total, Option_t *opt="""")This function is only kept for backward compatibility.Definition TGraphAsymmErrors.cxx:508; TGraphAsymmErrors::GetEYhighDouble_t * GetEYhigh() const overrideDefinition",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8h_source.html
https://root.cern/doc/master/TGraphAsymmErrors_8h_source.html:10458,Availability,error,errors,10458,"symmErrors::ComputeRangevoid ComputeRange(Double_t &xmin, Double_t &ymin, Double_t &xmax, Double_t &ymax) const overrideCompute Range.Definition TGraphAsymmErrors.cxx:977; TGraphAsymmErrors::SetPointEXlowvirtual void SetPointEXlow(Int_t i, Double_t exl)Set EXlow for point i.Definition TGraphAsymmErrors.cxx:1348; TGraphAsymmErrors::SetPointEYhighvirtual void SetPointEYhigh(Int_t i, Double_t eyh)Set EYhigh for point i.Definition TGraphAsymmErrors.cxx:1390; TGraphAsymmErrors::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave primitive as a C++ statement(s) on output stream out.Definition TGraphAsymmErrors.cxx:1241; TGraphAsymmErrors::BayesDividevirtual void BayesDivide(const TH1 *pass, const TH1 *total, Option_t *opt="""")This function is only kept for backward compatibility.Definition TGraphAsymmErrors.cxx:508; TGraphAsymmErrors::GetEYhighDouble_t * GetEYhigh() const overrideDefinition TGraphAsymmErrors.h:77; TGraphAsymmErrors::Printvoid Print(Option_t *chopt="""") const overridePrint graph and errors values.Definition TGraphAsymmErrors.cxx:1229; TGraphAsymmErrors::GetErrorYhighDouble_t GetErrorYhigh(Int_t i) const overrideGet high error on Y.Definition TGraphAsymmErrors.cxx:1173; TGraphAsymmErrors::MergeInt_t Merge(TCollection *list) overrideAdds all graphs with asymmetric errors from the collection to this graph.Definition TGraphAsymmErrors.cxx:1196; TGraphAsymmErrors::GetErrorXlowDouble_t GetErrorXlow(Int_t i) const overrideGet low error on X.Definition TGraphAsymmErrors.cxx:1162; TGraphAsymmErrors::fEYlowDouble_t * fEYlow[fNpoints] array of Y low errorsDefinition TGraphAsymmErrors.h:31; TGraphAsymmErrors::UpdateArraysvoid UpdateArrays(const std::vector< Int_t > &sorting_indices, Int_t numSortedPoints, Int_t low) overrideUpdate the fX, fY, fEXlow, fEXhigh, fEYlow and fEYhigh arrays with the sorted values.Definition TGraphAsymmErrors.cxx:1468; TGraphAsymmErrors::SwapPointsvoid SwapPoints(Int_t pos1, Int_t pos2) overrideSwap points.Defin",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8h_source.html
https://root.cern/doc/master/TGraphAsymmErrors_8h_source.html:10598,Availability,error,error,10598,"finition TGraphAsymmErrors.cxx:977; TGraphAsymmErrors::SetPointEXlowvirtual void SetPointEXlow(Int_t i, Double_t exl)Set EXlow for point i.Definition TGraphAsymmErrors.cxx:1348; TGraphAsymmErrors::SetPointEYhighvirtual void SetPointEYhigh(Int_t i, Double_t eyh)Set EYhigh for point i.Definition TGraphAsymmErrors.cxx:1390; TGraphAsymmErrors::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave primitive as a C++ statement(s) on output stream out.Definition TGraphAsymmErrors.cxx:1241; TGraphAsymmErrors::BayesDividevirtual void BayesDivide(const TH1 *pass, const TH1 *total, Option_t *opt="""")This function is only kept for backward compatibility.Definition TGraphAsymmErrors.cxx:508; TGraphAsymmErrors::GetEYhighDouble_t * GetEYhigh() const overrideDefinition TGraphAsymmErrors.h:77; TGraphAsymmErrors::Printvoid Print(Option_t *chopt="""") const overridePrint graph and errors values.Definition TGraphAsymmErrors.cxx:1229; TGraphAsymmErrors::GetErrorYhighDouble_t GetErrorYhigh(Int_t i) const overrideGet high error on Y.Definition TGraphAsymmErrors.cxx:1173; TGraphAsymmErrors::MergeInt_t Merge(TCollection *list) overrideAdds all graphs with asymmetric errors from the collection to this graph.Definition TGraphAsymmErrors.cxx:1196; TGraphAsymmErrors::GetErrorXlowDouble_t GetErrorXlow(Int_t i) const overrideGet low error on X.Definition TGraphAsymmErrors.cxx:1162; TGraphAsymmErrors::fEYlowDouble_t * fEYlow[fNpoints] array of Y low errorsDefinition TGraphAsymmErrors.h:31; TGraphAsymmErrors::UpdateArraysvoid UpdateArrays(const std::vector< Int_t > &sorting_indices, Int_t numSortedPoints, Int_t low) overrideUpdate the fX, fY, fEXlow, fEXhigh, fEYlow and fEYhigh arrays with the sorted values.Definition TGraphAsymmErrors.cxx:1468; TGraphAsymmErrors::SwapPointsvoid SwapPoints(Int_t pos1, Int_t pos2) overrideSwap points.Definition TGraphAsymmErrors.cxx:1456; TGraphAsymmErrors::GetEXhighDouble_t * GetEXhigh() const overrideDefinition TGraphAsymmErrors.h:75; T",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8h_source.html
https://root.cern/doc/master/TGraphAsymmErrors_8h_source.html:10743,Availability,error,errors,10743,"AsymmErrors.cxx:1348; TGraphAsymmErrors::SetPointEYhighvirtual void SetPointEYhigh(Int_t i, Double_t eyh)Set EYhigh for point i.Definition TGraphAsymmErrors.cxx:1390; TGraphAsymmErrors::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave primitive as a C++ statement(s) on output stream out.Definition TGraphAsymmErrors.cxx:1241; TGraphAsymmErrors::BayesDividevirtual void BayesDivide(const TH1 *pass, const TH1 *total, Option_t *opt="""")This function is only kept for backward compatibility.Definition TGraphAsymmErrors.cxx:508; TGraphAsymmErrors::GetEYhighDouble_t * GetEYhigh() const overrideDefinition TGraphAsymmErrors.h:77; TGraphAsymmErrors::Printvoid Print(Option_t *chopt="""") const overridePrint graph and errors values.Definition TGraphAsymmErrors.cxx:1229; TGraphAsymmErrors::GetErrorYhighDouble_t GetErrorYhigh(Int_t i) const overrideGet high error on Y.Definition TGraphAsymmErrors.cxx:1173; TGraphAsymmErrors::MergeInt_t Merge(TCollection *list) overrideAdds all graphs with asymmetric errors from the collection to this graph.Definition TGraphAsymmErrors.cxx:1196; TGraphAsymmErrors::GetErrorXlowDouble_t GetErrorXlow(Int_t i) const overrideGet low error on X.Definition TGraphAsymmErrors.cxx:1162; TGraphAsymmErrors::fEYlowDouble_t * fEYlow[fNpoints] array of Y low errorsDefinition TGraphAsymmErrors.h:31; TGraphAsymmErrors::UpdateArraysvoid UpdateArrays(const std::vector< Int_t > &sorting_indices, Int_t numSortedPoints, Int_t low) overrideUpdate the fX, fY, fEXlow, fEXhigh, fEYlow and fEYhigh arrays with the sorted values.Definition TGraphAsymmErrors.cxx:1468; TGraphAsymmErrors::SwapPointsvoid SwapPoints(Int_t pos1, Int_t pos2) overrideSwap points.Definition TGraphAsymmErrors.cxx:1456; TGraphAsymmErrors::GetEXhighDouble_t * GetEXhigh() const overrideDefinition TGraphAsymmErrors.h:75; TGraphAsymmErrors::fEXlowDouble_t * fEXlow[fNpoints] array of X low errorsDefinition TGraphAsymmErrors.h:29; TGraphAsymmErrors::Applyvoid Apply(TF1 *f) overr",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8h_source.html
https://root.cern/doc/master/TGraphAsymmErrors_8h_source.html:10907,Availability,error,error,10907,"rs.cxx:1390; TGraphAsymmErrors::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave primitive as a C++ statement(s) on output stream out.Definition TGraphAsymmErrors.cxx:1241; TGraphAsymmErrors::BayesDividevirtual void BayesDivide(const TH1 *pass, const TH1 *total, Option_t *opt="""")This function is only kept for backward compatibility.Definition TGraphAsymmErrors.cxx:508; TGraphAsymmErrors::GetEYhighDouble_t * GetEYhigh() const overrideDefinition TGraphAsymmErrors.h:77; TGraphAsymmErrors::Printvoid Print(Option_t *chopt="""") const overridePrint graph and errors values.Definition TGraphAsymmErrors.cxx:1229; TGraphAsymmErrors::GetErrorYhighDouble_t GetErrorYhigh(Int_t i) const overrideGet high error on Y.Definition TGraphAsymmErrors.cxx:1173; TGraphAsymmErrors::MergeInt_t Merge(TCollection *list) overrideAdds all graphs with asymmetric errors from the collection to this graph.Definition TGraphAsymmErrors.cxx:1196; TGraphAsymmErrors::GetErrorXlowDouble_t GetErrorXlow(Int_t i) const overrideGet low error on X.Definition TGraphAsymmErrors.cxx:1162; TGraphAsymmErrors::fEYlowDouble_t * fEYlow[fNpoints] array of Y low errorsDefinition TGraphAsymmErrors.h:31; TGraphAsymmErrors::UpdateArraysvoid UpdateArrays(const std::vector< Int_t > &sorting_indices, Int_t numSortedPoints, Int_t low) overrideUpdate the fX, fY, fEXlow, fEXhigh, fEYlow and fEYhigh arrays with the sorted values.Definition TGraphAsymmErrors.cxx:1468; TGraphAsymmErrors::SwapPointsvoid SwapPoints(Int_t pos1, Int_t pos2) overrideSwap points.Definition TGraphAsymmErrors.cxx:1456; TGraphAsymmErrors::GetEXhighDouble_t * GetEXhigh() const overrideDefinition TGraphAsymmErrors.h:75; TGraphAsymmErrors::fEXlowDouble_t * fEXlow[fNpoints] array of X low errorsDefinition TGraphAsymmErrors.h:29; TGraphAsymmErrors::Applyvoid Apply(TF1 *f) overrideApply a function to all data points .Definition TGraphAsymmErrors.cxx:468; TGraphAsymmErrors::AllocateDouble_t ** Allocate(Int_t size) overrideAllocate ",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8h_source.html
https://root.cern/doc/master/TGraphAsymmErrors_8h_source.html:11025,Availability,error,errorsDefinition,11025,"atement(s) on output stream out.Definition TGraphAsymmErrors.cxx:1241; TGraphAsymmErrors::BayesDividevirtual void BayesDivide(const TH1 *pass, const TH1 *total, Option_t *opt="""")This function is only kept for backward compatibility.Definition TGraphAsymmErrors.cxx:508; TGraphAsymmErrors::GetEYhighDouble_t * GetEYhigh() const overrideDefinition TGraphAsymmErrors.h:77; TGraphAsymmErrors::Printvoid Print(Option_t *chopt="""") const overridePrint graph and errors values.Definition TGraphAsymmErrors.cxx:1229; TGraphAsymmErrors::GetErrorYhighDouble_t GetErrorYhigh(Int_t i) const overrideGet high error on Y.Definition TGraphAsymmErrors.cxx:1173; TGraphAsymmErrors::MergeInt_t Merge(TCollection *list) overrideAdds all graphs with asymmetric errors from the collection to this graph.Definition TGraphAsymmErrors.cxx:1196; TGraphAsymmErrors::GetErrorXlowDouble_t GetErrorXlow(Int_t i) const overrideGet low error on X.Definition TGraphAsymmErrors.cxx:1162; TGraphAsymmErrors::fEYlowDouble_t * fEYlow[fNpoints] array of Y low errorsDefinition TGraphAsymmErrors.h:31; TGraphAsymmErrors::UpdateArraysvoid UpdateArrays(const std::vector< Int_t > &sorting_indices, Int_t numSortedPoints, Int_t low) overrideUpdate the fX, fY, fEXlow, fEXhigh, fEYlow and fEYhigh arrays with the sorted values.Definition TGraphAsymmErrors.cxx:1468; TGraphAsymmErrors::SwapPointsvoid SwapPoints(Int_t pos1, Int_t pos2) overrideSwap points.Definition TGraphAsymmErrors.cxx:1456; TGraphAsymmErrors::GetEXhighDouble_t * GetEXhigh() const overrideDefinition TGraphAsymmErrors.h:75; TGraphAsymmErrors::fEXlowDouble_t * fEXlow[fNpoints] array of X low errorsDefinition TGraphAsymmErrors.h:29; TGraphAsymmErrors::Applyvoid Apply(TF1 *f) overrideApply a function to all data points .Definition TGraphAsymmErrors.cxx:468; TGraphAsymmErrors::AllocateDouble_t ** Allocate(Int_t size) overrideAllocate internal data structures for size points.Definition TGraphAsymmErrors.cxx:444; TGraphAsymmErrors::GetEYlowDouble_t * GetEYlow() const over",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8h_source.html
https://root.cern/doc/master/TGraphAsymmErrors_8h_source.html:11622,Availability,error,errorsDefinition,11622,"r on Y.Definition TGraphAsymmErrors.cxx:1173; TGraphAsymmErrors::MergeInt_t Merge(TCollection *list) overrideAdds all graphs with asymmetric errors from the collection to this graph.Definition TGraphAsymmErrors.cxx:1196; TGraphAsymmErrors::GetErrorXlowDouble_t GetErrorXlow(Int_t i) const overrideGet low error on X.Definition TGraphAsymmErrors.cxx:1162; TGraphAsymmErrors::fEYlowDouble_t * fEYlow[fNpoints] array of Y low errorsDefinition TGraphAsymmErrors.h:31; TGraphAsymmErrors::UpdateArraysvoid UpdateArrays(const std::vector< Int_t > &sorting_indices, Int_t numSortedPoints, Int_t low) overrideUpdate the fX, fY, fEXlow, fEXhigh, fEYlow and fEYhigh arrays with the sorted values.Definition TGraphAsymmErrors.cxx:1468; TGraphAsymmErrors::SwapPointsvoid SwapPoints(Int_t pos1, Int_t pos2) overrideSwap points.Definition TGraphAsymmErrors.cxx:1456; TGraphAsymmErrors::GetEXhighDouble_t * GetEXhigh() const overrideDefinition TGraphAsymmErrors.h:75; TGraphAsymmErrors::fEXlowDouble_t * fEXlow[fNpoints] array of X low errorsDefinition TGraphAsymmErrors.h:29; TGraphAsymmErrors::Applyvoid Apply(TF1 *f) overrideApply a function to all data points .Definition TGraphAsymmErrors.cxx:468; TGraphAsymmErrors::AllocateDouble_t ** Allocate(Int_t size) overrideAllocate internal data structures for size points.Definition TGraphAsymmErrors.cxx:444; TGraphAsymmErrors::GetEYlowDouble_t * GetEYlow() const overrideDefinition TGraphAsymmErrors.h:76; TGraphAsymmErrors::DoMergeBool_t DoMerge(const TGraph *g) overrideProtected function to perform the merge operation of a graph with asymmetric errors.Definition TGraphAsymmErrors.cxx:1077; TGraphAsymmErrors::CopyAndReleasevoid CopyAndRelease(Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy and release.Definition TGraphAsymmErrors.cxx:1007; TGraphAsymmErrors::SetPointEXhighvirtual void SetPointEXhigh(Int_t i, Double_t exh)Set EXhigh for point i.Definition TGraphAsymmErrors.cxx:1362; TGraphAsymmErrors::GetErrorYlowDouble_t GetErro",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8h_source.html
https://root.cern/doc/master/TGraphAsymmErrors_8h_source.html:12186,Availability,error,errors,12186,"const std::vector< Int_t > &sorting_indices, Int_t numSortedPoints, Int_t low) overrideUpdate the fX, fY, fEXlow, fEXhigh, fEYlow and fEYhigh arrays with the sorted values.Definition TGraphAsymmErrors.cxx:1468; TGraphAsymmErrors::SwapPointsvoid SwapPoints(Int_t pos1, Int_t pos2) overrideSwap points.Definition TGraphAsymmErrors.cxx:1456; TGraphAsymmErrors::GetEXhighDouble_t * GetEXhigh() const overrideDefinition TGraphAsymmErrors.h:75; TGraphAsymmErrors::fEXlowDouble_t * fEXlow[fNpoints] array of X low errorsDefinition TGraphAsymmErrors.h:29; TGraphAsymmErrors::Applyvoid Apply(TF1 *f) overrideApply a function to all data points .Definition TGraphAsymmErrors.cxx:468; TGraphAsymmErrors::AllocateDouble_t ** Allocate(Int_t size) overrideAllocate internal data structures for size points.Definition TGraphAsymmErrors.cxx:444; TGraphAsymmErrors::GetEYlowDouble_t * GetEYlow() const overrideDefinition TGraphAsymmErrors.h:76; TGraphAsymmErrors::DoMergeBool_t DoMerge(const TGraph *g) overrideProtected function to perform the merge operation of a graph with asymmetric errors.Definition TGraphAsymmErrors.cxx:1077; TGraphAsymmErrors::CopyAndReleasevoid CopyAndRelease(Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy and release.Definition TGraphAsymmErrors.cxx:1007; TGraphAsymmErrors::SetPointEXhighvirtual void SetPointEXhigh(Int_t i, Double_t exh)Set EXhigh for point i.Definition TGraphAsymmErrors.cxx:1362; TGraphAsymmErrors::GetErrorYlowDouble_t GetErrorYlow(Int_t i) const overrideGet low error on Y.Definition TGraphAsymmErrors.cxx:1184; TGraphAsymmErrors::GetErrorXDouble_t GetErrorX(Int_t bin) const overrideReturns the combined error along X at point i by computing the average of the lower and upper varianc...Definition TGraphAsymmErrors.cxx:1122; TGraphAsymmErrors::TGraphAsymmErrorsTGraphAsymmErrors()TGraphAsymmErrors default constructor.Definition TGraphAsymmErrors.cxx:72; TGraphAsymmErrors::operator=TGraphAsymmErrors & operator=(const TGraphAsymmError",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8h_source.html
https://root.cern/doc/master/TGraphAsymmErrors_8h_source.html:12640,Availability,error,error,12640,"Npoints] array of X low errorsDefinition TGraphAsymmErrors.h:29; TGraphAsymmErrors::Applyvoid Apply(TF1 *f) overrideApply a function to all data points .Definition TGraphAsymmErrors.cxx:468; TGraphAsymmErrors::AllocateDouble_t ** Allocate(Int_t size) overrideAllocate internal data structures for size points.Definition TGraphAsymmErrors.cxx:444; TGraphAsymmErrors::GetEYlowDouble_t * GetEYlow() const overrideDefinition TGraphAsymmErrors.h:76; TGraphAsymmErrors::DoMergeBool_t DoMerge(const TGraph *g) overrideProtected function to perform the merge operation of a graph with asymmetric errors.Definition TGraphAsymmErrors.cxx:1077; TGraphAsymmErrors::CopyAndReleasevoid CopyAndRelease(Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy and release.Definition TGraphAsymmErrors.cxx:1007; TGraphAsymmErrors::SetPointEXhighvirtual void SetPointEXhigh(Int_t i, Double_t exh)Set EXhigh for point i.Definition TGraphAsymmErrors.cxx:1362; TGraphAsymmErrors::GetErrorYlowDouble_t GetErrorYlow(Int_t i) const overrideGet low error on Y.Definition TGraphAsymmErrors.cxx:1184; TGraphAsymmErrors::GetErrorXDouble_t GetErrorX(Int_t bin) const overrideReturns the combined error along X at point i by computing the average of the lower and upper varianc...Definition TGraphAsymmErrors.cxx:1122; TGraphAsymmErrors::TGraphAsymmErrorsTGraphAsymmErrors()TGraphAsymmErrors default constructor.Definition TGraphAsymmErrors.cxx:72; TGraphAsymmErrors::operator=TGraphAsymmErrors & operator=(const TGraphAsymmErrors &gr)TGraphAsymmErrors assignment operator.Definition TGraphAsymmErrors.cxx:93; TGraphAsymmErrors::~TGraphAsymmErrors~TGraphAsymmErrors() overrideTGraphAsymmErrors default destructor.Definition TGraphAsymmErrors.cxx:433; TGraphAsymmErrors::Scalevoid Scale(Double_t c1=1., Option_t *option=""y"") overrideMultiply the values and errors of a TGraphAsymmErrors by a constant c1.Definition TGraphAsymmErrors.cxx:1274; TGraphA TGraph is an object made of two arrays X and Y with npoints eac",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8h_source.html
https://root.cern/doc/master/TGraphAsymmErrors_8h_source.html:12783,Availability,error,error,12783,"mErrors.cxx:468; TGraphAsymmErrors::AllocateDouble_t ** Allocate(Int_t size) overrideAllocate internal data structures for size points.Definition TGraphAsymmErrors.cxx:444; TGraphAsymmErrors::GetEYlowDouble_t * GetEYlow() const overrideDefinition TGraphAsymmErrors.h:76; TGraphAsymmErrors::DoMergeBool_t DoMerge(const TGraph *g) overrideProtected function to perform the merge operation of a graph with asymmetric errors.Definition TGraphAsymmErrors.cxx:1077; TGraphAsymmErrors::CopyAndReleasevoid CopyAndRelease(Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy and release.Definition TGraphAsymmErrors.cxx:1007; TGraphAsymmErrors::SetPointEXhighvirtual void SetPointEXhigh(Int_t i, Double_t exh)Set EXhigh for point i.Definition TGraphAsymmErrors.cxx:1362; TGraphAsymmErrors::GetErrorYlowDouble_t GetErrorYlow(Int_t i) const overrideGet low error on Y.Definition TGraphAsymmErrors.cxx:1184; TGraphAsymmErrors::GetErrorXDouble_t GetErrorX(Int_t bin) const overrideReturns the combined error along X at point i by computing the average of the lower and upper varianc...Definition TGraphAsymmErrors.cxx:1122; TGraphAsymmErrors::TGraphAsymmErrorsTGraphAsymmErrors()TGraphAsymmErrors default constructor.Definition TGraphAsymmErrors.cxx:72; TGraphAsymmErrors::operator=TGraphAsymmErrors & operator=(const TGraphAsymmErrors &gr)TGraphAsymmErrors assignment operator.Definition TGraphAsymmErrors.cxx:93; TGraphAsymmErrors::~TGraphAsymmErrors~TGraphAsymmErrors() overrideTGraphAsymmErrors default destructor.Definition TGraphAsymmErrors.cxx:433; TGraphAsymmErrors::Scalevoid Scale(Double_t c1=1., Option_t *option=""y"") overrideMultiply the values and errors of a TGraphAsymmErrors by a constant c1.Definition TGraphAsymmErrors.cxx:1274; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TVectorTTVectorT.Definition TVectorT.h:27; double; yDouble_t y[n]Def",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8h_source.html
https://root.cern/doc/master/TGraphAsymmErrors_8h_source.html:13442,Availability,error,errors,13442,"t TGraph *g) overrideProtected function to perform the merge operation of a graph with asymmetric errors.Definition TGraphAsymmErrors.cxx:1077; TGraphAsymmErrors::CopyAndReleasevoid CopyAndRelease(Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy and release.Definition TGraphAsymmErrors.cxx:1007; TGraphAsymmErrors::SetPointEXhighvirtual void SetPointEXhigh(Int_t i, Double_t exh)Set EXhigh for point i.Definition TGraphAsymmErrors.cxx:1362; TGraphAsymmErrors::GetErrorYlowDouble_t GetErrorYlow(Int_t i) const overrideGet low error on Y.Definition TGraphAsymmErrors.cxx:1184; TGraphAsymmErrors::GetErrorXDouble_t GetErrorX(Int_t bin) const overrideReturns the combined error along X at point i by computing the average of the lower and upper varianc...Definition TGraphAsymmErrors.cxx:1122; TGraphAsymmErrors::TGraphAsymmErrorsTGraphAsymmErrors()TGraphAsymmErrors default constructor.Definition TGraphAsymmErrors.cxx:72; TGraphAsymmErrors::operator=TGraphAsymmErrors & operator=(const TGraphAsymmErrors &gr)TGraphAsymmErrors assignment operator.Definition TGraphAsymmErrors.cxx:93; TGraphAsymmErrors::~TGraphAsymmErrors~TGraphAsymmErrors() overrideTGraphAsymmErrors default destructor.Definition TGraphAsymmErrors.cxx:433; TGraphAsymmErrors::Scalevoid Scale(Double_t c1=1., Option_t *option=""y"") overrideMultiply the values and errors of a TGraphAsymmErrors by a constant c1.Definition TGraphAsymmErrors.cxx:1274; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TVectorTTVectorT.Definition TVectorT.h:27; double; yDouble_t y[n]Definition legend1.C:17; c1return c1Definition legend1.C:41; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; grTGraphErrors * grDefinition legend1.C:25. histhistincTGraphAsymmErrors.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8h_source.html
https://root.cern/doc/master/TGraphAsymmErrors_8h_source.html:12364,Deployability,release,release,12364," TGraphAsymmErrors.cxx:1468; TGraphAsymmErrors::SwapPointsvoid SwapPoints(Int_t pos1, Int_t pos2) overrideSwap points.Definition TGraphAsymmErrors.cxx:1456; TGraphAsymmErrors::GetEXhighDouble_t * GetEXhigh() const overrideDefinition TGraphAsymmErrors.h:75; TGraphAsymmErrors::fEXlowDouble_t * fEXlow[fNpoints] array of X low errorsDefinition TGraphAsymmErrors.h:29; TGraphAsymmErrors::Applyvoid Apply(TF1 *f) overrideApply a function to all data points .Definition TGraphAsymmErrors.cxx:468; TGraphAsymmErrors::AllocateDouble_t ** Allocate(Int_t size) overrideAllocate internal data structures for size points.Definition TGraphAsymmErrors.cxx:444; TGraphAsymmErrors::GetEYlowDouble_t * GetEYlow() const overrideDefinition TGraphAsymmErrors.h:76; TGraphAsymmErrors::DoMergeBool_t DoMerge(const TGraph *g) overrideProtected function to perform the merge operation of a graph with asymmetric errors.Definition TGraphAsymmErrors.cxx:1077; TGraphAsymmErrors::CopyAndReleasevoid CopyAndRelease(Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy and release.Definition TGraphAsymmErrors.cxx:1007; TGraphAsymmErrors::SetPointEXhighvirtual void SetPointEXhigh(Int_t i, Double_t exh)Set EXhigh for point i.Definition TGraphAsymmErrors.cxx:1362; TGraphAsymmErrors::GetErrorYlowDouble_t GetErrorYlow(Int_t i) const overrideGet low error on Y.Definition TGraphAsymmErrors.cxx:1184; TGraphAsymmErrors::GetErrorXDouble_t GetErrorX(Int_t bin) const overrideReturns the combined error along X at point i by computing the average of the lower and upper varianc...Definition TGraphAsymmErrors.cxx:1122; TGraphAsymmErrors::TGraphAsymmErrorsTGraphAsymmErrors()TGraphAsymmErrors default constructor.Definition TGraphAsymmErrors.cxx:72; TGraphAsymmErrors::operator=TGraphAsymmErrors & operator=(const TGraphAsymmErrors &gr)TGraphAsymmErrors assignment operator.Definition TGraphAsymmErrors.cxx:93; TGraphAsymmErrors::~TGraphAsymmErrors~TGraphAsymmErrors() overrideTGraphAsymmErrors default destructo",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8h_source.html
https://root.cern/doc/master/TGraphAsymmErrors_8h_source.html:12131,Performance,perform,perform,12131,"const std::vector< Int_t > &sorting_indices, Int_t numSortedPoints, Int_t low) overrideUpdate the fX, fY, fEXlow, fEXhigh, fEYlow and fEYhigh arrays with the sorted values.Definition TGraphAsymmErrors.cxx:1468; TGraphAsymmErrors::SwapPointsvoid SwapPoints(Int_t pos1, Int_t pos2) overrideSwap points.Definition TGraphAsymmErrors.cxx:1456; TGraphAsymmErrors::GetEXhighDouble_t * GetEXhigh() const overrideDefinition TGraphAsymmErrors.h:75; TGraphAsymmErrors::fEXlowDouble_t * fEXlow[fNpoints] array of X low errorsDefinition TGraphAsymmErrors.h:29; TGraphAsymmErrors::Applyvoid Apply(TF1 *f) overrideApply a function to all data points .Definition TGraphAsymmErrors.cxx:468; TGraphAsymmErrors::AllocateDouble_t ** Allocate(Int_t size) overrideAllocate internal data structures for size points.Definition TGraphAsymmErrors.cxx:444; TGraphAsymmErrors::GetEYlowDouble_t * GetEYlow() const overrideDefinition TGraphAsymmErrors.h:76; TGraphAsymmErrors::DoMergeBool_t DoMerge(const TGraph *g) overrideProtected function to perform the merge operation of a graph with asymmetric errors.Definition TGraphAsymmErrors.cxx:1077; TGraphAsymmErrors::CopyAndReleasevoid CopyAndRelease(Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy and release.Definition TGraphAsymmErrors.cxx:1007; TGraphAsymmErrors::SetPointEXhighvirtual void SetPointEXhigh(Int_t i, Double_t exh)Set EXhigh for point i.Definition TGraphAsymmErrors.cxx:1362; TGraphAsymmErrors::GetErrorYlowDouble_t GetErrorYlow(Int_t i) const overrideGet low error on Y.Definition TGraphAsymmErrors.cxx:1184; TGraphAsymmErrors::GetErrorXDouble_t GetErrorX(Int_t bin) const overrideReturns the combined error along X at point i by computing the average of the lower and upper varianc...Definition TGraphAsymmErrors.cxx:1122; TGraphAsymmErrors::TGraphAsymmErrorsTGraphAsymmErrors()TGraphAsymmErrors default constructor.Definition TGraphAsymmErrors.cxx:72; TGraphAsymmErrors::operator=TGraphAsymmErrors & operator=(const TGraphAsymmError",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8h_source.html
https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html:1076,Availability,error,error,1076,". ROOT: hist/hist/src/TGraphBentErrors.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TGraphBentErrors.cxx. Go to the documentation of this file. 1// @(#)root/hist:$Id$; 2// Author: Dave Morrison 30/06/2003; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2003, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#include <cstring>; 13#include <iostream>; 14 ; 15#include ""TROOT.h""; 16#include ""TGraphBentErrors.h""; 17#include ""TMath.h""; 18#include ""TVirtualPad.h""; 19#include ""TH1.h""; 20#include ""TF1.h""; 21 ; 22ClassImp(TGraphBentErrors);; 23 ; 24 ; 25////////////////////////////////////////////////////////////////////////////////; 26 ; 27/** \class TGraphBentErrors; 28 \ingroup Graphs; 29A TGraphBentErrors is a TGraph with bent, asymmetric error bars.; 30 ; 31The TGraphBentErrors painting is performed thanks to the TGraphPainter; 32class. All details about the various painting options are given in this class.; 33 ; 34The picture below gives an example:; 35Begin_Macro(source); 36{; 37 auto c1 = new TCanvas(""c1"",""A Simple Graph with bent error bars"",200,10,700,500);; 38 const Int_t n = 10;; 39 Double_t x[n] = {-0.22, 0.05, 0.25, 0.35, 0.5, 0.61,0.7,0.85,0.89,0.95};; 40 Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; 41 Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; 42 Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; 43 Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; 44 Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.4,.5,.6};; 45 Double_t exld[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; 46 Double_t eyld[n] = {.0,.0,.05,.0,.0,.0,.0,.0,.0,.0};; 47 Double_t exhd[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; 48 Double_t eyhd[n] = {.0,.",MatchSource.WIKI,doc/master/TGraphBentErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html
https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html:1378,Availability,error,error,1378,"ht (C) 1995-2003, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#include <cstring>; 13#include <iostream>; 14 ; 15#include ""TROOT.h""; 16#include ""TGraphBentErrors.h""; 17#include ""TMath.h""; 18#include ""TVirtualPad.h""; 19#include ""TH1.h""; 20#include ""TF1.h""; 21 ; 22ClassImp(TGraphBentErrors);; 23 ; 24 ; 25////////////////////////////////////////////////////////////////////////////////; 26 ; 27/** \class TGraphBentErrors; 28 \ingroup Graphs; 29A TGraphBentErrors is a TGraph with bent, asymmetric error bars.; 30 ; 31The TGraphBentErrors painting is performed thanks to the TGraphPainter; 32class. All details about the various painting options are given in this class.; 33 ; 34The picture below gives an example:; 35Begin_Macro(source); 36{; 37 auto c1 = new TCanvas(""c1"",""A Simple Graph with bent error bars"",200,10,700,500);; 38 const Int_t n = 10;; 39 Double_t x[n] = {-0.22, 0.05, 0.25, 0.35, 0.5, 0.61,0.7,0.85,0.89,0.95};; 40 Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; 41 Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; 42 Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; 43 Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; 44 Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.4,.5,.6};; 45 Double_t exld[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; 46 Double_t eyld[n] = {.0,.0,.05,.0,.0,.0,.0,.0,.0,.0};; 47 Double_t exhd[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; 48 Double_t eyhd[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.05,.0};; 49 auto gr = new TGraphBentErrors(n,x,y,exl,exh,eyl,eyh,exld,exhd,eyld,eyhd);; 50 gr->SetTitle(""TGraphBentErrors Example"");; 51 gr->SetMarkerColor(4);; 52 gr->SetMarkerStyle(21);; 53 gr->Draw(""ALP"");; 54}; 55End_Macro; 56*/; 57 ; 58 ; 59////////////////////////////////////////////////////////////////////////////////; 60",MatchSource.WIKI,doc/master/TGraphBentErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html
https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html:6329,Availability,error,errors,6329,"153 if (exl) memcpy(fEXlow, exl, memsz);; 154 else memset(fEXlow, 0, memsz);; 155 if (exh) memcpy(fEXhigh, exh, memsz);; 156 else memset(fEXhigh, 0, memsz);; 157 if (eyl) memcpy(fEYlow, eyl, memsz);; 158 else memset(fEYlow, 0, memsz);; 159 if (eyh) memcpy(fEYhigh, eyh, memsz);; 160 else memset(fEYhigh, 0, memsz);; 161 ; 162 if (exld) memcpy(fEXlowd, exld, memsz);; 163 else memset(fEXlowd, 0, memsz);; 164 if (exhd) memcpy(fEXhighd, exhd, memsz);; 165 else memset(fEXhighd, 0, memsz);; 166 if (eyld) memcpy(fEYlowd, eyld, memsz);; 167 else memset(fEYlowd, 0, memsz);; 168 if (eyhd) memcpy(fEYhighd, eyhd, memsz);; 169 else memset(fEYhighd, 0, memsz);; 170}; 171 ; 172 ; 173////////////////////////////////////////////////////////////////////////////////; 174/// TGraphBentErrors default destructor.; 175 ; 176TGraphBentErrors::~TGraphBentErrors(); 177{; 178 delete [] fEXlow;; 179 delete [] fEXhigh;; 180 delete [] fEYlow;; 181 delete [] fEYhigh;; 182 ; 183 delete [] fEXlowd;; 184 delete [] fEXhighd;; 185 delete [] fEYlowd;; 186 delete [] fEYhighd;; 187}; 188 ; 189////////////////////////////////////////////////////////////////////////////////; 190/// Add a point with bent errors to the graph.; 191 ; 192void TGraphBentErrors::AddPointError(Double_t x, Double_t y, Double_t exl, Double_t exh, Double_t eyl, Double_t eyh,; 193 Double_t exld, Double_t exhd, Double_t eyld, Double_t eyhd); 194{; 195 AddPoint(x, y);; 196 SetPointError(fNpoints - 1, exl, exh, eyl, eyh, exld, exhd, eyld, eyhd);; 197}; 198 ; 199////////////////////////////////////////////////////////////////////////////////; 200/// Apply a function to all data points \f$ y = f(x,y) \f$.; 201///; 202/// Errors are calculated as \f$ eyh = f(x,y+eyh)-f(x,y) \f$ and; 203/// \f$ eyl = f(x,y)-f(x,y-eyl) \f$.; 204///; 205/// Special treatment has to be applied for the functions where the; 206/// role of ""up"" and ""down"" is reversed.; 207///; 208/// Function suggested/implemented by Miroslav Helbich <helbich@mail.desy.de>; 209 ; 2",MatchSource.WIKI,doc/master/TGraphBentErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html
https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html:7032,Availability,down,down,7032,"ntErrors(); 177{; 178 delete [] fEXlow;; 179 delete [] fEXhigh;; 180 delete [] fEYlow;; 181 delete [] fEYhigh;; 182 ; 183 delete [] fEXlowd;; 184 delete [] fEXhighd;; 185 delete [] fEYlowd;; 186 delete [] fEYhighd;; 187}; 188 ; 189////////////////////////////////////////////////////////////////////////////////; 190/// Add a point with bent errors to the graph.; 191 ; 192void TGraphBentErrors::AddPointError(Double_t x, Double_t y, Double_t exl, Double_t exh, Double_t eyl, Double_t eyh,; 193 Double_t exld, Double_t exhd, Double_t eyld, Double_t eyhd); 194{; 195 AddPoint(x, y);; 196 SetPointError(fNpoints - 1, exl, exh, eyl, eyh, exld, exhd, eyld, eyhd);; 197}; 198 ; 199////////////////////////////////////////////////////////////////////////////////; 200/// Apply a function to all data points \f$ y = f(x,y) \f$.; 201///; 202/// Errors are calculated as \f$ eyh = f(x,y+eyh)-f(x,y) \f$ and; 203/// \f$ eyl = f(x,y)-f(x,y-eyl) \f$.; 204///; 205/// Special treatment has to be applied for the functions where the; 206/// role of ""up"" and ""down"" is reversed.; 207///; 208/// Function suggested/implemented by Miroslav Helbich <helbich@mail.desy.de>; 209 ; 210void TGraphBentErrors::Apply(TF1 *f); 211{; 212 Double_t x,y,exl,exh,eyl,eyh,eyl_new,eyh_new,fxy;; 213 ; 214 if (fHistogram) {; 215 delete fHistogram;; 216 fHistogram = nullptr;; 217 }; 218 for (Int_t i = 0; i < GetN(); i++) {; 219 GetPoint(i, x, y);; 220 exl = GetErrorXlow(i);; 221 exh = GetErrorXhigh(i);; 222 eyl = GetErrorYlow(i);; 223 eyh = GetErrorYhigh(i);; 224 ; 225 fxy = f->Eval(x, y);; 226 SetPoint(i, x, fxy);; 227 ; 228 // in the case of the functions like y-> -1*y the roles of the; 229 // upper and lower error bars is reversed; 230 if (f->Eval(x,y-eyl) < f->Eval(x,y+eyh)) {; 231 eyl_new = TMath::Abs(fxy - f->Eval(x,y-eyl));; 232 eyh_new = TMath::Abs(f->Eval(x,y+eyh) - fxy);; 233 } else {; 234 eyh_new = TMath::Abs(fxy - f->Eval(x,y-eyl));; 235 eyl_new = TMath::Abs(f->Eval(x,y+eyh) - fxy);; 236 }; 237 ; 238 //error o",MatchSource.WIKI,doc/master/TGraphBentErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html
https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html:7672,Availability,error,error,7672,"/////////////////////////////////////////////////////////////////; 200/// Apply a function to all data points \f$ y = f(x,y) \f$.; 201///; 202/// Errors are calculated as \f$ eyh = f(x,y+eyh)-f(x,y) \f$ and; 203/// \f$ eyl = f(x,y)-f(x,y-eyl) \f$.; 204///; 205/// Special treatment has to be applied for the functions where the; 206/// role of ""up"" and ""down"" is reversed.; 207///; 208/// Function suggested/implemented by Miroslav Helbich <helbich@mail.desy.de>; 209 ; 210void TGraphBentErrors::Apply(TF1 *f); 211{; 212 Double_t x,y,exl,exh,eyl,eyh,eyl_new,eyh_new,fxy;; 213 ; 214 if (fHistogram) {; 215 delete fHistogram;; 216 fHistogram = nullptr;; 217 }; 218 for (Int_t i = 0; i < GetN(); i++) {; 219 GetPoint(i, x, y);; 220 exl = GetErrorXlow(i);; 221 exh = GetErrorXhigh(i);; 222 eyl = GetErrorYlow(i);; 223 eyh = GetErrorYhigh(i);; 224 ; 225 fxy = f->Eval(x, y);; 226 SetPoint(i, x, fxy);; 227 ; 228 // in the case of the functions like y-> -1*y the roles of the; 229 // upper and lower error bars is reversed; 230 if (f->Eval(x,y-eyl) < f->Eval(x,y+eyh)) {; 231 eyl_new = TMath::Abs(fxy - f->Eval(x,y-eyl));; 232 eyh_new = TMath::Abs(f->Eval(x,y+eyh) - fxy);; 233 } else {; 234 eyh_new = TMath::Abs(fxy - f->Eval(x,y-eyl));; 235 eyl_new = TMath::Abs(f->Eval(x,y+eyh) - fxy);; 236 }; 237 ; 238 //error on x doesn't change; 239 SetPointError(i,exl,exh,eyl_new,eyh_new);; 240 }; 241 if (gPad) gPad->Modified();; 242}; 243 ; 244 ; 245////////////////////////////////////////////////////////////////////////////////; 246/// Compute range.; 247 ; 248void TGraphBentErrors::ComputeRange(Double_t &xmin, Double_t &ymin, Double_t &xmax, Double_t &ymax) const; 249{; 250 TGraph::ComputeRange(xmin,ymin,xmax,ymax);; 251 ; 252 for (Int_t i=0;i<fNpoints;i++) {; 253 if (fX[i] -fEXlow[i] < xmin) {; 254 if (gPad && gPad->GetLogx()) {; 255 if (fEXlow[i] < fX[i]) xmin = fX[i]-fEXlow[i];; 256 else xmin = TMath::Min(xmin,fX[i]/3);; 257 } else {; 258 xmin = fX[i]-fEXlow[i];; 259 }; 260 }; 261 if (fX[i] +fEXh",MatchSource.WIKI,doc/master/TGraphBentErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html
https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html:7981,Availability,error,error,7981,"/////////////////////////////////////////////////////////////////; 200/// Apply a function to all data points \f$ y = f(x,y) \f$.; 201///; 202/// Errors are calculated as \f$ eyh = f(x,y+eyh)-f(x,y) \f$ and; 203/// \f$ eyl = f(x,y)-f(x,y-eyl) \f$.; 204///; 205/// Special treatment has to be applied for the functions where the; 206/// role of ""up"" and ""down"" is reversed.; 207///; 208/// Function suggested/implemented by Miroslav Helbich <helbich@mail.desy.de>; 209 ; 210void TGraphBentErrors::Apply(TF1 *f); 211{; 212 Double_t x,y,exl,exh,eyl,eyh,eyl_new,eyh_new,fxy;; 213 ; 214 if (fHistogram) {; 215 delete fHistogram;; 216 fHistogram = nullptr;; 217 }; 218 for (Int_t i = 0; i < GetN(); i++) {; 219 GetPoint(i, x, y);; 220 exl = GetErrorXlow(i);; 221 exh = GetErrorXhigh(i);; 222 eyl = GetErrorYlow(i);; 223 eyh = GetErrorYhigh(i);; 224 ; 225 fxy = f->Eval(x, y);; 226 SetPoint(i, x, fxy);; 227 ; 228 // in the case of the functions like y-> -1*y the roles of the; 229 // upper and lower error bars is reversed; 230 if (f->Eval(x,y-eyl) < f->Eval(x,y+eyh)) {; 231 eyl_new = TMath::Abs(fxy - f->Eval(x,y-eyl));; 232 eyh_new = TMath::Abs(f->Eval(x,y+eyh) - fxy);; 233 } else {; 234 eyh_new = TMath::Abs(fxy - f->Eval(x,y-eyl));; 235 eyl_new = TMath::Abs(f->Eval(x,y+eyh) - fxy);; 236 }; 237 ; 238 //error on x doesn't change; 239 SetPointError(i,exl,exh,eyl_new,eyh_new);; 240 }; 241 if (gPad) gPad->Modified();; 242}; 243 ; 244 ; 245////////////////////////////////////////////////////////////////////////////////; 246/// Compute range.; 247 ; 248void TGraphBentErrors::ComputeRange(Double_t &xmin, Double_t &ymin, Double_t &xmax, Double_t &ymax) const; 249{; 250 TGraph::ComputeRange(xmin,ymin,xmax,ymax);; 251 ; 252 for (Int_t i=0;i<fNpoints;i++) {; 253 if (fX[i] -fEXlow[i] < xmin) {; 254 if (gPad && gPad->GetLogx()) {; 255 if (fEXlow[i] < fX[i]) xmin = fX[i]-fEXlow[i];; 256 else xmin = TMath::Min(xmin,fX[i]/3);; 257 } else {; 258 xmin = fX[i]-fEXlow[i];; 259 }; 260 }; 261 if (fX[i] +fEXh",MatchSource.WIKI,doc/master/TGraphBentErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html
https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html:9979,Availability,error,errors,9979,"[i]/3);; 257 } else {; 258 xmin = fX[i]-fEXlow[i];; 259 }; 260 }; 261 if (fX[i] +fEXhigh[i] > xmax) xmax = fX[i]+fEXhigh[i];; 262 if (fY[i] -fEYlow[i] < ymin) {; 263 if (gPad && gPad->GetLogy()) {; 264 if (fEYlow[i] < fY[i]) ymin = fY[i]-fEYlow[i];; 265 else ymin = TMath::Min(ymin,fY[i]/3);; 266 } else {; 267 ymin = fY[i]-fEYlow[i];; 268 }; 269 }; 270 if (fY[i] +fEYhigh[i] > ymax) ymax = fY[i]+fEYhigh[i];; 271 }; 272}; 273 ; 274 ; 275////////////////////////////////////////////////////////////////////////////////; 276/// Copy and release.; 277 ; 278void TGraphBentErrors::CopyAndRelease(Double_t **newarrays,; 279 Int_t ibegin, Int_t iend, Int_t obegin); 280{; 281 CopyPoints(newarrays, ibegin, iend, obegin);; 282 if (newarrays) {; 283 delete[] fEXlow;; 284 fEXlow = newarrays[0];; 285 delete[] fEXhigh;; 286 fEXhigh = newarrays[1];; 287 delete[] fEYlow;; 288 fEYlow = newarrays[2];; 289 delete[] fEYhigh;; 290 fEYhigh = newarrays[3];; 291 delete[] fEXlowd;; 292 fEXlowd = newarrays[4];; 293 delete[] fEXhighd;; 294 fEXhighd = newarrays[5];; 295 delete[] fEYlowd;; 296 fEYlowd = newarrays[6];; 297 delete[] fEYhighd;; 298 fEYhighd = newarrays[7];; 299 delete[] fX;; 300 fX = newarrays[8];; 301 delete[] fY;; 302 fY = newarrays[9];; 303 delete[] newarrays;; 304 }; 305}; 306 ; 307 ; 308////////////////////////////////////////////////////////////////////////////////; 309/// Copy errors from `fE*** `to `arrays[***]`; 310/// or to `f***` Copy points.; 311 ; 312Bool_t TGraphBentErrors::CopyPoints(Double_t **arrays,; 313 Int_t ibegin, Int_t iend, Int_t obegin); 314{; 315 if (TGraph::CopyPoints(arrays ? arrays+8 : nullptr, ibegin, iend, obegin)) {; 316 Int_t n = (iend - ibegin)*sizeof(Double_t);; 317 if (arrays) {; 318 memmove(&arrays[0][obegin], &fEXlow[ibegin], n);; 319 memmove(&arrays[1][obegin], &fEXhigh[ibegin], n);; 320 memmove(&arrays[2][obegin], &fEYlow[ibegin], n);; 321 memmove(&arrays[3][obegin], &fEYhigh[ibegin], n);; 322 memmove(&arrays[4][obegin], &fEXlowd[ibegin], n);; 323",MatchSource.WIKI,doc/master/TGraphBentErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html
https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html:12157,Availability,error,errors,12157,"], &fEXlow[ibegin], n);; 328 memmove(&fEXhigh[obegin], &fEXhigh[ibegin], n);; 329 memmove(&fEYlow[obegin], &fEYlow[ibegin], n);; 330 memmove(&fEYhigh[obegin], &fEYhigh[ibegin], n);; 331 memmove(&fEXlowd[obegin], &fEXlowd[ibegin], n);; 332 memmove(&fEXhighd[obegin], &fEXhighd[ibegin], n);; 333 memmove(&fEYlowd[obegin], &fEYlowd[ibegin], n);; 334 memmove(&fEYhighd[obegin], &fEYhighd[ibegin], n);; 335 }; 336 return kTRUE;; 337 } else {; 338 return kFALSE;; 339 }; 340}; 341 ; 342 ; 343////////////////////////////////////////////////////////////////////////////////; 344/// Should be called from ctors after `fNpoints` has been set.; 345 ; 346Bool_t TGraphBentErrors::CtorAllocate(); 347{; 348 if (!fNpoints) {; 349 fEXlow = fEYlow = fEXhigh = fEYhigh = nullptr;; 350 fEXlowd = fEYlowd = fEXhighd = fEYhighd = nullptr;; 351 return kFALSE;; 352 }; 353 fEXlow = new Double_t[fMaxSize];; 354 fEYlow = new Double_t[fMaxSize];; 355 fEXhigh = new Double_t[fMaxSize];; 356 fEYhigh = new Double_t[fMaxSize];; 357 fEXlowd = new Double_t[fMaxSize];; 358 fEYlowd = new Double_t[fMaxSize];; 359 fEXhighd = new Double_t[fMaxSize];; 360 fEYhighd = new Double_t[fMaxSize];; 361 return kTRUE;; 362}; 363 ; 364////////////////////////////////////////////////////////////////////////////////; 365/// Protected function to perform the merge operation of a graph with asymmetric errors.; 366 ; 367Bool_t TGraphBentErrors::DoMerge(const TGraph *g); 368{; 369 if (g->GetN() == 0) return kFALSE;; 370 ; 371 Double_t *exl = g->GetEXlow();; 372 Double_t *exh = g->GetEXhigh();; 373 Double_t *eyl = g->GetEYlow();; 374 Double_t *eyh = g->GetEYhigh();; 375 ; 376 Double_t *exld = g->GetEXlowd();; 377 Double_t *exhd = g->GetEXhighd();; 378 Double_t *eyld = g->GetEYlowd();; 379 Double_t *eyhd = g->GetEYhighd();; 380 ; 381 if (!exl || !exh || !eyl || !eyh ||; 382 !exld || !exhd || !eyld || !eyhd) {; 383 if (g->IsA() != TGraph::Class() ); 384 Warning(""DoMerge"", ""Merging a %s is not compatible with a TGraphBentErrors - error",MatchSource.WIKI,doc/master/TGraphBentErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html
https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html:12792,Availability,error,errors,12792,"e_t[fMaxSize];; 356 fEYhigh = new Double_t[fMaxSize];; 357 fEXlowd = new Double_t[fMaxSize];; 358 fEYlowd = new Double_t[fMaxSize];; 359 fEXhighd = new Double_t[fMaxSize];; 360 fEYhighd = new Double_t[fMaxSize];; 361 return kTRUE;; 362}; 363 ; 364////////////////////////////////////////////////////////////////////////////////; 365/// Protected function to perform the merge operation of a graph with asymmetric errors.; 366 ; 367Bool_t TGraphBentErrors::DoMerge(const TGraph *g); 368{; 369 if (g->GetN() == 0) return kFALSE;; 370 ; 371 Double_t *exl = g->GetEXlow();; 372 Double_t *exh = g->GetEXhigh();; 373 Double_t *eyl = g->GetEYlow();; 374 Double_t *eyh = g->GetEYhigh();; 375 ; 376 Double_t *exld = g->GetEXlowd();; 377 Double_t *exhd = g->GetEXhighd();; 378 Double_t *eyld = g->GetEYlowd();; 379 Double_t *eyhd = g->GetEYhighd();; 380 ; 381 if (!exl || !exh || !eyl || !eyh ||; 382 !exld || !exhd || !eyld || !eyhd) {; 383 if (g->IsA() != TGraph::Class() ); 384 Warning(""DoMerge"", ""Merging a %s is not compatible with a TGraphBentErrors - errors will be ignored"", g->IsA()->GetName());; 385 return TGraph::DoMerge(g);; 386 }; 387 for (Int_t i = 0 ; i < g->GetN(); i++) {; 388 Int_t ipoint = GetN();; 389 Double_t x = g->GetX()[i];; 390 Double_t y = g->GetY()[i];; 391 SetPoint(ipoint, x, y);; 392 SetPointError(ipoint, exl[i], exh[i], eyl[i], eyh[i],; 393 exld[i], exhd[i], eyld[i], eyhd[i]);; 394 }; 395 ; 396 return kTRUE;; 397 ; 398}; 399////////////////////////////////////////////////////////////////////////////////; 400/// It returns the error along X at point `i`.; 401 ; 402Double_t TGraphBentErrors::GetErrorX(Int_t i) const; 403{; 404 if (i < 0 || i >= fNpoints) return -1;; 405 if (!fEXlow && !fEXhigh) return -1;; 406 Double_t elow = 0, ehigh = 0;; 407 if (fEXlow) elow = fEXlow[i];; 408 if (fEXhigh) ehigh = fEXhigh[i];; 409 return TMath::Sqrt(0.5*(elow*elow + ehigh*ehigh));; 410}; 411 ; 412 ; 413////////////////////////////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TGraphBentErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html
https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html:13298,Availability,error,error,13298,"e_t[fMaxSize];; 356 fEYhigh = new Double_t[fMaxSize];; 357 fEXlowd = new Double_t[fMaxSize];; 358 fEYlowd = new Double_t[fMaxSize];; 359 fEXhighd = new Double_t[fMaxSize];; 360 fEYhighd = new Double_t[fMaxSize];; 361 return kTRUE;; 362}; 363 ; 364////////////////////////////////////////////////////////////////////////////////; 365/// Protected function to perform the merge operation of a graph with asymmetric errors.; 366 ; 367Bool_t TGraphBentErrors::DoMerge(const TGraph *g); 368{; 369 if (g->GetN() == 0) return kFALSE;; 370 ; 371 Double_t *exl = g->GetEXlow();; 372 Double_t *exh = g->GetEXhigh();; 373 Double_t *eyl = g->GetEYlow();; 374 Double_t *eyh = g->GetEYhigh();; 375 ; 376 Double_t *exld = g->GetEXlowd();; 377 Double_t *exhd = g->GetEXhighd();; 378 Double_t *eyld = g->GetEYlowd();; 379 Double_t *eyhd = g->GetEYhighd();; 380 ; 381 if (!exl || !exh || !eyl || !eyh ||; 382 !exld || !exhd || !eyld || !eyhd) {; 383 if (g->IsA() != TGraph::Class() ); 384 Warning(""DoMerge"", ""Merging a %s is not compatible with a TGraphBentErrors - errors will be ignored"", g->IsA()->GetName());; 385 return TGraph::DoMerge(g);; 386 }; 387 for (Int_t i = 0 ; i < g->GetN(); i++) {; 388 Int_t ipoint = GetN();; 389 Double_t x = g->GetX()[i];; 390 Double_t y = g->GetY()[i];; 391 SetPoint(ipoint, x, y);; 392 SetPointError(ipoint, exl[i], exh[i], eyl[i], eyh[i],; 393 exld[i], exhd[i], eyld[i], eyhd[i]);; 394 }; 395 ; 396 return kTRUE;; 397 ; 398}; 399////////////////////////////////////////////////////////////////////////////////; 400/// It returns the error along X at point `i`.; 401 ; 402Double_t TGraphBentErrors::GetErrorX(Int_t i) const; 403{; 404 if (i < 0 || i >= fNpoints) return -1;; 405 if (!fEXlow && !fEXhigh) return -1;; 406 Double_t elow = 0, ehigh = 0;; 407 if (fEXlow) elow = fEXlow[i];; 408 if (fEXhigh) ehigh = fEXhigh[i];; 409 return TMath::Sqrt(0.5*(elow*elow + ehigh*ehigh));; 410}; 411 ; 412 ; 413////////////////////////////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TGraphBentErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html
https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html:13769,Availability,error,error,13769,"s() ); 384 Warning(""DoMerge"", ""Merging a %s is not compatible with a TGraphBentErrors - errors will be ignored"", g->IsA()->GetName());; 385 return TGraph::DoMerge(g);; 386 }; 387 for (Int_t i = 0 ; i < g->GetN(); i++) {; 388 Int_t ipoint = GetN();; 389 Double_t x = g->GetX()[i];; 390 Double_t y = g->GetY()[i];; 391 SetPoint(ipoint, x, y);; 392 SetPointError(ipoint, exl[i], exh[i], eyl[i], eyh[i],; 393 exld[i], exhd[i], eyld[i], eyhd[i]);; 394 }; 395 ; 396 return kTRUE;; 397 ; 398}; 399////////////////////////////////////////////////////////////////////////////////; 400/// It returns the error along X at point `i`.; 401 ; 402Double_t TGraphBentErrors::GetErrorX(Int_t i) const; 403{; 404 if (i < 0 || i >= fNpoints) return -1;; 405 if (!fEXlow && !fEXhigh) return -1;; 406 Double_t elow = 0, ehigh = 0;; 407 if (fEXlow) elow = fEXlow[i];; 408 if (fEXhigh) ehigh = fEXhigh[i];; 409 return TMath::Sqrt(0.5*(elow*elow + ehigh*ehigh));; 410}; 411 ; 412 ; 413////////////////////////////////////////////////////////////////////////////////; 414/// It returns the error along Y at point `i`.; 415 ; 416Double_t TGraphBentErrors::GetErrorY(Int_t i) const; 417{; 418 if (i < 0 || i >= fNpoints) return -1;; 419 if (!fEYlow && !fEYhigh) return -1;; 420 Double_t elow=0, ehigh=0;; 421 if (fEYlow) elow = fEYlow[i];; 422 if (fEYhigh) ehigh = fEYhigh[i];; 423 return TMath::Sqrt(0.5*(elow*elow + ehigh*ehigh));; 424}; 425 ; 426 ; 427////////////////////////////////////////////////////////////////////////////////; 428/// Get high error on X[i].; 429 ; 430Double_t TGraphBentErrors::GetErrorXhigh(Int_t i) const; 431{; 432 if (i<0 || i>fNpoints) return -1;; 433 if (fEXhigh) return fEXhigh[i];; 434 return -1;; 435}; 436 ; 437 ; 438////////////////////////////////////////////////////////////////////////////////; 439/// Get low error on X[i].; 440 ; 441Double_t TGraphBentErrors::GetErrorXlow(Int_t i) const; 442{; 443 if (i<0 || i>fNpoints) return -1;; 444 if (fEXlow) return fEXlow[i];; 445 return -1;; ",MatchSource.WIKI,doc/master/TGraphBentErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html
https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html:14230,Availability,error,error,14230,"6 return kTRUE;; 397 ; 398}; 399////////////////////////////////////////////////////////////////////////////////; 400/// It returns the error along X at point `i`.; 401 ; 402Double_t TGraphBentErrors::GetErrorX(Int_t i) const; 403{; 404 if (i < 0 || i >= fNpoints) return -1;; 405 if (!fEXlow && !fEXhigh) return -1;; 406 Double_t elow = 0, ehigh = 0;; 407 if (fEXlow) elow = fEXlow[i];; 408 if (fEXhigh) ehigh = fEXhigh[i];; 409 return TMath::Sqrt(0.5*(elow*elow + ehigh*ehigh));; 410}; 411 ; 412 ; 413////////////////////////////////////////////////////////////////////////////////; 414/// It returns the error along Y at point `i`.; 415 ; 416Double_t TGraphBentErrors::GetErrorY(Int_t i) const; 417{; 418 if (i < 0 || i >= fNpoints) return -1;; 419 if (!fEYlow && !fEYhigh) return -1;; 420 Double_t elow=0, ehigh=0;; 421 if (fEYlow) elow = fEYlow[i];; 422 if (fEYhigh) ehigh = fEYhigh[i];; 423 return TMath::Sqrt(0.5*(elow*elow + ehigh*ehigh));; 424}; 425 ; 426 ; 427////////////////////////////////////////////////////////////////////////////////; 428/// Get high error on X[i].; 429 ; 430Double_t TGraphBentErrors::GetErrorXhigh(Int_t i) const; 431{; 432 if (i<0 || i>fNpoints) return -1;; 433 if (fEXhigh) return fEXhigh[i];; 434 return -1;; 435}; 436 ; 437 ; 438////////////////////////////////////////////////////////////////////////////////; 439/// Get low error on X[i].; 440 ; 441Double_t TGraphBentErrors::GetErrorXlow(Int_t i) const; 442{; 443 if (i<0 || i>fNpoints) return -1;; 444 if (fEXlow) return fEXlow[i];; 445 return -1;; 446}; 447 ; 448 ; 449////////////////////////////////////////////////////////////////////////////////; 450/// Get high error on Y[i].; 451 ; 452Double_t TGraphBentErrors::GetErrorYhigh(Int_t i) const; 453{; 454 if (i<0 || i>fNpoints) return -1;; 455 if (fEYhigh) return fEYhigh[i];; 456 return -1;; 457}; 458 ; 459 ; 460////////////////////////////////////////////////////////////////////////////////; 461/// Get low error on Y[i].; 462 ; 463Double_t TGraph",MatchSource.WIKI,doc/master/TGraphBentErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html
https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html:14528,Availability,error,error,14528,"; 404 if (i < 0 || i >= fNpoints) return -1;; 405 if (!fEXlow && !fEXhigh) return -1;; 406 Double_t elow = 0, ehigh = 0;; 407 if (fEXlow) elow = fEXlow[i];; 408 if (fEXhigh) ehigh = fEXhigh[i];; 409 return TMath::Sqrt(0.5*(elow*elow + ehigh*ehigh));; 410}; 411 ; 412 ; 413////////////////////////////////////////////////////////////////////////////////; 414/// It returns the error along Y at point `i`.; 415 ; 416Double_t TGraphBentErrors::GetErrorY(Int_t i) const; 417{; 418 if (i < 0 || i >= fNpoints) return -1;; 419 if (!fEYlow && !fEYhigh) return -1;; 420 Double_t elow=0, ehigh=0;; 421 if (fEYlow) elow = fEYlow[i];; 422 if (fEYhigh) ehigh = fEYhigh[i];; 423 return TMath::Sqrt(0.5*(elow*elow + ehigh*ehigh));; 424}; 425 ; 426 ; 427////////////////////////////////////////////////////////////////////////////////; 428/// Get high error on X[i].; 429 ; 430Double_t TGraphBentErrors::GetErrorXhigh(Int_t i) const; 431{; 432 if (i<0 || i>fNpoints) return -1;; 433 if (fEXhigh) return fEXhigh[i];; 434 return -1;; 435}; 436 ; 437 ; 438////////////////////////////////////////////////////////////////////////////////; 439/// Get low error on X[i].; 440 ; 441Double_t TGraphBentErrors::GetErrorXlow(Int_t i) const; 442{; 443 if (i<0 || i>fNpoints) return -1;; 444 if (fEXlow) return fEXlow[i];; 445 return -1;; 446}; 447 ; 448 ; 449////////////////////////////////////////////////////////////////////////////////; 450/// Get high error on Y[i].; 451 ; 452Double_t TGraphBentErrors::GetErrorYhigh(Int_t i) const; 453{; 454 if (i<0 || i>fNpoints) return -1;; 455 if (fEYhigh) return fEYhigh[i];; 456 return -1;; 457}; 458 ; 459 ; 460////////////////////////////////////////////////////////////////////////////////; 461/// Get low error on Y[i].; 462 ; 463Double_t TGraphBentErrors::GetErrorYlow(Int_t i) const; 464{; 465 if (i<0 || i>fNpoints) return -1;; 466 if (fEYlow) return fEYlow[i];; 467 return -1;; 468}; 469 ; 470 ; 471/////////////////////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TGraphBentErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html
https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html:14824,Availability,error,error,14824,"///////////////////////////////////////////////////////; 414/// It returns the error along Y at point `i`.; 415 ; 416Double_t TGraphBentErrors::GetErrorY(Int_t i) const; 417{; 418 if (i < 0 || i >= fNpoints) return -1;; 419 if (!fEYlow && !fEYhigh) return -1;; 420 Double_t elow=0, ehigh=0;; 421 if (fEYlow) elow = fEYlow[i];; 422 if (fEYhigh) ehigh = fEYhigh[i];; 423 return TMath::Sqrt(0.5*(elow*elow + ehigh*ehigh));; 424}; 425 ; 426 ; 427////////////////////////////////////////////////////////////////////////////////; 428/// Get high error on X[i].; 429 ; 430Double_t TGraphBentErrors::GetErrorXhigh(Int_t i) const; 431{; 432 if (i<0 || i>fNpoints) return -1;; 433 if (fEXhigh) return fEXhigh[i];; 434 return -1;; 435}; 436 ; 437 ; 438////////////////////////////////////////////////////////////////////////////////; 439/// Get low error on X[i].; 440 ; 441Double_t TGraphBentErrors::GetErrorXlow(Int_t i) const; 442{; 443 if (i<0 || i>fNpoints) return -1;; 444 if (fEXlow) return fEXlow[i];; 445 return -1;; 446}; 447 ; 448 ; 449////////////////////////////////////////////////////////////////////////////////; 450/// Get high error on Y[i].; 451 ; 452Double_t TGraphBentErrors::GetErrorYhigh(Int_t i) const; 453{; 454 if (i<0 || i>fNpoints) return -1;; 455 if (fEYhigh) return fEYhigh[i];; 456 return -1;; 457}; 458 ; 459 ; 460////////////////////////////////////////////////////////////////////////////////; 461/// Get low error on Y[i].; 462 ; 463Double_t TGraphBentErrors::GetErrorYlow(Int_t i) const; 464{; 465 if (i<0 || i>fNpoints) return -1;; 466 if (fEYlow) return fEYlow[i];; 467 return -1;; 468}; 469 ; 470 ; 471////////////////////////////////////////////////////////////////////////////////; 472/// Set zero values for point arrays in the range `[begin, end]`; 473 ; 474void TGraphBentErrors::FillZero(Int_t begin, Int_t end,; 475 Bool_t from_ctor); 476{; 477 if (!from_ctor) {; 478 TGraph::FillZero(begin, end, from_ctor);; 479 }; 480 Int_t n = (end - begin)*sizeof(Double_t);; 4",MatchSource.WIKI,doc/master/TGraphBentErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html
https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html:15122,Availability,error,error,15122,"f (fEYlow) elow = fEYlow[i];; 422 if (fEYhigh) ehigh = fEYhigh[i];; 423 return TMath::Sqrt(0.5*(elow*elow + ehigh*ehigh));; 424}; 425 ; 426 ; 427////////////////////////////////////////////////////////////////////////////////; 428/// Get high error on X[i].; 429 ; 430Double_t TGraphBentErrors::GetErrorXhigh(Int_t i) const; 431{; 432 if (i<0 || i>fNpoints) return -1;; 433 if (fEXhigh) return fEXhigh[i];; 434 return -1;; 435}; 436 ; 437 ; 438////////////////////////////////////////////////////////////////////////////////; 439/// Get low error on X[i].; 440 ; 441Double_t TGraphBentErrors::GetErrorXlow(Int_t i) const; 442{; 443 if (i<0 || i>fNpoints) return -1;; 444 if (fEXlow) return fEXlow[i];; 445 return -1;; 446}; 447 ; 448 ; 449////////////////////////////////////////////////////////////////////////////////; 450/// Get high error on Y[i].; 451 ; 452Double_t TGraphBentErrors::GetErrorYhigh(Int_t i) const; 453{; 454 if (i<0 || i>fNpoints) return -1;; 455 if (fEYhigh) return fEYhigh[i];; 456 return -1;; 457}; 458 ; 459 ; 460////////////////////////////////////////////////////////////////////////////////; 461/// Get low error on Y[i].; 462 ; 463Double_t TGraphBentErrors::GetErrorYlow(Int_t i) const; 464{; 465 if (i<0 || i>fNpoints) return -1;; 466 if (fEYlow) return fEYlow[i];; 467 return -1;; 468}; 469 ; 470 ; 471////////////////////////////////////////////////////////////////////////////////; 472/// Set zero values for point arrays in the range `[begin, end]`; 473 ; 474void TGraphBentErrors::FillZero(Int_t begin, Int_t end,; 475 Bool_t from_ctor); 476{; 477 if (!from_ctor) {; 478 TGraph::FillZero(begin, end, from_ctor);; 479 }; 480 Int_t n = (end - begin)*sizeof(Double_t);; 481 memset(fEXlow + begin, 0, n);; 482 memset(fEXhigh + begin, 0, n);; 483 memset(fEYlow + begin, 0, n);; 484 memset(fEYhigh + begin, 0, n);; 485 memset(fEXlowd + begin, 0, n);; 486 memset(fEXhighd + begin, 0, n);; 487 memset(fEYlowd + begin, 0, n);; 488 memset(fEYhighd + begin, 0, n);; 489}; 490 ",MatchSource.WIKI,doc/master/TGraphBentErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html
https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html:16103,Availability,error,errors,16103," || i>fNpoints) return -1;; 444 if (fEXlow) return fEXlow[i];; 445 return -1;; 446}; 447 ; 448 ; 449////////////////////////////////////////////////////////////////////////////////; 450/// Get high error on Y[i].; 451 ; 452Double_t TGraphBentErrors::GetErrorYhigh(Int_t i) const; 453{; 454 if (i<0 || i>fNpoints) return -1;; 455 if (fEYhigh) return fEYhigh[i];; 456 return -1;; 457}; 458 ; 459 ; 460////////////////////////////////////////////////////////////////////////////////; 461/// Get low error on Y[i].; 462 ; 463Double_t TGraphBentErrors::GetErrorYlow(Int_t i) const; 464{; 465 if (i<0 || i>fNpoints) return -1;; 466 if (fEYlow) return fEYlow[i];; 467 return -1;; 468}; 469 ; 470 ; 471////////////////////////////////////////////////////////////////////////////////; 472/// Set zero values for point arrays in the range `[begin, end]`; 473 ; 474void TGraphBentErrors::FillZero(Int_t begin, Int_t end,; 475 Bool_t from_ctor); 476{; 477 if (!from_ctor) {; 478 TGraph::FillZero(begin, end, from_ctor);; 479 }; 480 Int_t n = (end - begin)*sizeof(Double_t);; 481 memset(fEXlow + begin, 0, n);; 482 memset(fEXhigh + begin, 0, n);; 483 memset(fEYlow + begin, 0, n);; 484 memset(fEYhigh + begin, 0, n);; 485 memset(fEXlowd + begin, 0, n);; 486 memset(fEXhighd + begin, 0, n);; 487 memset(fEYlowd + begin, 0, n);; 488 memset(fEYhighd + begin, 0, n);; 489}; 490 ; 491 ; 492////////////////////////////////////////////////////////////////////////////////; 493/// Print graph and errors values.; 494 ; 495void TGraphBentErrors::Print(Option_t *) const; 496{; 497 for (Int_t i=0;i<fNpoints;i++) {; 498 printf(""x[%d]=%g, y[%d]=%g, exl[%d]=%g, exh[%d]=%g, eyl[%d]=%g, eyh[%d]=%g\n""; 499 ,i,fX[i],i,fY[i],i,fEXlow[i],i,fEXhigh[i],i,fEYlow[i],i,fEYhigh[i]);; 500 }; 501}; 502 ; 503////////////////////////////////////////////////////////////////////////////////; 504/// Multiply the values and errors of a TGraphBentErrors by a constant c1.; 505///; 506/// If option contains ""x"" the x values and errors are s",MatchSource.WIKI,doc/master/TGraphBentErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html
https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html:16512,Availability,error,errors,16512,"///////////////////////////////////////////////////////////////; 472/// Set zero values for point arrays in the range `[begin, end]`; 473 ; 474void TGraphBentErrors::FillZero(Int_t begin, Int_t end,; 475 Bool_t from_ctor); 476{; 477 if (!from_ctor) {; 478 TGraph::FillZero(begin, end, from_ctor);; 479 }; 480 Int_t n = (end - begin)*sizeof(Double_t);; 481 memset(fEXlow + begin, 0, n);; 482 memset(fEXhigh + begin, 0, n);; 483 memset(fEYlow + begin, 0, n);; 484 memset(fEYhigh + begin, 0, n);; 485 memset(fEXlowd + begin, 0, n);; 486 memset(fEXhighd + begin, 0, n);; 487 memset(fEYlowd + begin, 0, n);; 488 memset(fEYhighd + begin, 0, n);; 489}; 490 ; 491 ; 492////////////////////////////////////////////////////////////////////////////////; 493/// Print graph and errors values.; 494 ; 495void TGraphBentErrors::Print(Option_t *) const; 496{; 497 for (Int_t i=0;i<fNpoints;i++) {; 498 printf(""x[%d]=%g, y[%d]=%g, exl[%d]=%g, exh[%d]=%g, eyl[%d]=%g, eyh[%d]=%g\n""; 499 ,i,fX[i],i,fY[i],i,fEXlow[i],i,fEXhigh[i],i,fEYlow[i],i,fEYhigh[i]);; 500 }; 501}; 502 ; 503////////////////////////////////////////////////////////////////////////////////; 504/// Multiply the values and errors of a TGraphBentErrors by a constant c1.; 505///; 506/// If option contains ""x"" the x values and errors are scaled; 507/// If option contains ""y"" the y values and errors are scaled; 508/// If option contains ""xy"" both x and y values and errors are scaled; 509 ; 510void TGraphBentErrors::Scale(Double_t c1, Option_t *option); 511{; 512 TGraph::Scale(c1, option);; 513 TString opt = option; opt.ToLower();; 514 if (opt.Contains(""x"") && GetEXlow()) {; 515 for (Int_t i=0; i<GetN(); i++); 516 GetEXlow()[i] *= c1;; 517 }; 518 if (opt.Contains(""x"") && GetEXhigh()) {; 519 for (Int_t i=0; i<GetN(); i++); 520 GetEXhigh()[i] *= c1;; 521 }; 522 if (opt.Contains(""y"") && GetEYlow()) {; 523 for (Int_t i=0; i<GetN(); i++); 524 GetEYlow()[i] *= c1;; 525 }; 526 if (opt.Contains(""y"") && GetEYhigh()) {; 527 for (Int_t i=0; i<GetN()",MatchSource.WIKI,doc/master/TGraphBentErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html
https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html:16615,Availability,error,errors,16615,"fEXhigh + begin, 0, n);; 483 memset(fEYlow + begin, 0, n);; 484 memset(fEYhigh + begin, 0, n);; 485 memset(fEXlowd + begin, 0, n);; 486 memset(fEXhighd + begin, 0, n);; 487 memset(fEYlowd + begin, 0, n);; 488 memset(fEYhighd + begin, 0, n);; 489}; 490 ; 491 ; 492////////////////////////////////////////////////////////////////////////////////; 493/// Print graph and errors values.; 494 ; 495void TGraphBentErrors::Print(Option_t *) const; 496{; 497 for (Int_t i=0;i<fNpoints;i++) {; 498 printf(""x[%d]=%g, y[%d]=%g, exl[%d]=%g, exh[%d]=%g, eyl[%d]=%g, eyh[%d]=%g\n""; 499 ,i,fX[i],i,fY[i],i,fEXlow[i],i,fEXhigh[i],i,fEYlow[i],i,fEYhigh[i]);; 500 }; 501}; 502 ; 503////////////////////////////////////////////////////////////////////////////////; 504/// Multiply the values and errors of a TGraphBentErrors by a constant c1.; 505///; 506/// If option contains ""x"" the x values and errors are scaled; 507/// If option contains ""y"" the y values and errors are scaled; 508/// If option contains ""xy"" both x and y values and errors are scaled; 509 ; 510void TGraphBentErrors::Scale(Double_t c1, Option_t *option); 511{; 512 TGraph::Scale(c1, option);; 513 TString opt = option; opt.ToLower();; 514 if (opt.Contains(""x"") && GetEXlow()) {; 515 for (Int_t i=0; i<GetN(); i++); 516 GetEXlow()[i] *= c1;; 517 }; 518 if (opt.Contains(""x"") && GetEXhigh()) {; 519 for (Int_t i=0; i<GetN(); i++); 520 GetEXhigh()[i] *= c1;; 521 }; 522 if (opt.Contains(""y"") && GetEYlow()) {; 523 for (Int_t i=0; i<GetN(); i++); 524 GetEYlow()[i] *= c1;; 525 }; 526 if (opt.Contains(""y"") && GetEYhigh()) {; 527 for (Int_t i=0; i<GetN(); i++); 528 GetEYhigh()[i] *= c1;; 529 }; 530 if (opt.Contains(""x"") && GetEXlowd()) {; 531 for (Int_t i=0; i<GetN(); i++); 532 GetEXlowd()[i] *= c1;; 533 }; 534 if (opt.Contains(""x"") && GetEXhighd()) {; 535 for (Int_t i=0; i<GetN(); i++); 536 GetEXhighd()[i] *= c1;; 537 }; 538 if (opt.Contains(""y"") && GetEYlowd()) {; 539 for (Int_t i=0; i<GetN(); i++); 540 GetEYlowd()[i] *= c1;; 541 }; 542 if (",MatchSource.WIKI,doc/master/TGraphBentErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html
https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html:16681,Availability,error,errors,16681,"fEXhigh + begin, 0, n);; 483 memset(fEYlow + begin, 0, n);; 484 memset(fEYhigh + begin, 0, n);; 485 memset(fEXlowd + begin, 0, n);; 486 memset(fEXhighd + begin, 0, n);; 487 memset(fEYlowd + begin, 0, n);; 488 memset(fEYhighd + begin, 0, n);; 489}; 490 ; 491 ; 492////////////////////////////////////////////////////////////////////////////////; 493/// Print graph and errors values.; 494 ; 495void TGraphBentErrors::Print(Option_t *) const; 496{; 497 for (Int_t i=0;i<fNpoints;i++) {; 498 printf(""x[%d]=%g, y[%d]=%g, exl[%d]=%g, exh[%d]=%g, eyl[%d]=%g, eyh[%d]=%g\n""; 499 ,i,fX[i],i,fY[i],i,fEXlow[i],i,fEXhigh[i],i,fEYlow[i],i,fEYhigh[i]);; 500 }; 501}; 502 ; 503////////////////////////////////////////////////////////////////////////////////; 504/// Multiply the values and errors of a TGraphBentErrors by a constant c1.; 505///; 506/// If option contains ""x"" the x values and errors are scaled; 507/// If option contains ""y"" the y values and errors are scaled; 508/// If option contains ""xy"" both x and y values and errors are scaled; 509 ; 510void TGraphBentErrors::Scale(Double_t c1, Option_t *option); 511{; 512 TGraph::Scale(c1, option);; 513 TString opt = option; opt.ToLower();; 514 if (opt.Contains(""x"") && GetEXlow()) {; 515 for (Int_t i=0; i<GetN(); i++); 516 GetEXlow()[i] *= c1;; 517 }; 518 if (opt.Contains(""x"") && GetEXhigh()) {; 519 for (Int_t i=0; i<GetN(); i++); 520 GetEXhigh()[i] *= c1;; 521 }; 522 if (opt.Contains(""y"") && GetEYlow()) {; 523 for (Int_t i=0; i<GetN(); i++); 524 GetEYlow()[i] *= c1;; 525 }; 526 if (opt.Contains(""y"") && GetEYhigh()) {; 527 for (Int_t i=0; i<GetN(); i++); 528 GetEYhigh()[i] *= c1;; 529 }; 530 if (opt.Contains(""x"") && GetEXlowd()) {; 531 for (Int_t i=0; i<GetN(); i++); 532 GetEXlowd()[i] *= c1;; 533 }; 534 if (opt.Contains(""x"") && GetEXhighd()) {; 535 for (Int_t i=0; i<GetN(); i++); 536 GetEXhighd()[i] *= c1;; 537 }; 538 if (opt.Contains(""y"") && GetEYlowd()) {; 539 for (Int_t i=0; i<GetN(); i++); 540 GetEYlowd()[i] *= c1;; 541 }; 542 if (",MatchSource.WIKI,doc/master/TGraphBentErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html
https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html:16755,Availability,error,errors,16755,"fEXhigh + begin, 0, n);; 483 memset(fEYlow + begin, 0, n);; 484 memset(fEYhigh + begin, 0, n);; 485 memset(fEXlowd + begin, 0, n);; 486 memset(fEXhighd + begin, 0, n);; 487 memset(fEYlowd + begin, 0, n);; 488 memset(fEYhighd + begin, 0, n);; 489}; 490 ; 491 ; 492////////////////////////////////////////////////////////////////////////////////; 493/// Print graph and errors values.; 494 ; 495void TGraphBentErrors::Print(Option_t *) const; 496{; 497 for (Int_t i=0;i<fNpoints;i++) {; 498 printf(""x[%d]=%g, y[%d]=%g, exl[%d]=%g, exh[%d]=%g, eyl[%d]=%g, eyh[%d]=%g\n""; 499 ,i,fX[i],i,fY[i],i,fEXlow[i],i,fEXhigh[i],i,fEYlow[i],i,fEYhigh[i]);; 500 }; 501}; 502 ; 503////////////////////////////////////////////////////////////////////////////////; 504/// Multiply the values and errors of a TGraphBentErrors by a constant c1.; 505///; 506/// If option contains ""x"" the x values and errors are scaled; 507/// If option contains ""y"" the y values and errors are scaled; 508/// If option contains ""xy"" both x and y values and errors are scaled; 509 ; 510void TGraphBentErrors::Scale(Double_t c1, Option_t *option); 511{; 512 TGraph::Scale(c1, option);; 513 TString opt = option; opt.ToLower();; 514 if (opt.Contains(""x"") && GetEXlow()) {; 515 for (Int_t i=0; i<GetN(); i++); 516 GetEXlow()[i] *= c1;; 517 }; 518 if (opt.Contains(""x"") && GetEXhigh()) {; 519 for (Int_t i=0; i<GetN(); i++); 520 GetEXhigh()[i] *= c1;; 521 }; 522 if (opt.Contains(""y"") && GetEYlow()) {; 523 for (Int_t i=0; i<GetN(); i++); 524 GetEYlow()[i] *= c1;; 525 }; 526 if (opt.Contains(""y"") && GetEYhigh()) {; 527 for (Int_t i=0; i<GetN(); i++); 528 GetEYhigh()[i] *= c1;; 529 }; 530 if (opt.Contains(""x"") && GetEXlowd()) {; 531 for (Int_t i=0; i<GetN(); i++); 532 GetEXlowd()[i] *= c1;; 533 }; 534 if (opt.Contains(""x"") && GetEXhighd()) {; 535 for (Int_t i=0; i<GetN(); i++); 536 GetEXhighd()[i] *= c1;; 537 }; 538 if (opt.Contains(""y"") && GetEYlowd()) {; 539 for (Int_t i=0; i<GetN(); i++); 540 GetEYlowd()[i] *= c1;; 541 }; 542 if (",MatchSource.WIKI,doc/master/TGraphBentErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html
https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html:22649,Availability,error,error,22649,"tErrors::SwapPoints(Int_t pos1, Int_t pos2); 647{; 648 SwapValues(fEXlow, pos1, pos2);; 649 SwapValues(fEXhigh, pos1, pos2);; 650 SwapValues(fEYlow, pos1, pos2);; 651 SwapValues(fEYhigh, pos1, pos2);; 652 ; 653 SwapValues(fEXlowd, pos1, pos2);; 654 SwapValues(fEXhighd, pos1, pos2);; 655 SwapValues(fEYlowd, pos1, pos2);; 656 SwapValues(fEYhighd, pos1, pos2);; 657 ; 658 TGraph::SwapPoints(pos1, pos2);; 659}; 660 ; 661////////////////////////////////////////////////////////////////////////////////; 662/// Update the fX, fY, fEXlow, fEXhigh, fEXlowd, fEXhighd, fEYlow, fEYhigh, fEYlowd, ; 663/// and fEYhighd arrays with the sorted values.; 664 ; 665void TGraphBentErrors::UpdateArrays(const std::vector<Int_t> &sorting_indices, Int_t numSortedPoints, Int_t low); 666{; 667 std::vector<Double_t> fEXlowSorted(numSortedPoints);; 668 std::vector<Double_t> fEXhighSorted(numSortedPoints);; 669 std::vector<Double_t> fEXlowdSorted(numSortedPoints);; 670 std::vector<Double_t> fEXhighdSorted(numSortedPoints);; 671 ; 672 std::vector<Double_t> fEYlowSorted(numSortedPoints);; 673 std::vector<Double_t> fEYhighSorted(numSortedPoints);; 674 std::vector<Double_t> fEYlowdSorted(numSortedPoints);; 675 std::vector<Double_t> fEYhighdSorted(numSortedPoints);; 676 ; 677 // Fill the sorted X and Y error values based on the sorted indices; 678 std::generate(fEXlowSorted.begin(), fEXlowSorted.end(),; 679 [begin = low, &sorting_indices, this]() mutable { return fEXlow[sorting_indices[begin++]]; });; 680 std::generate(fEXhighSorted.begin(), fEXhighSorted.end(),; 681 [begin = low, &sorting_indices, this]() mutable { return fEXhigh[sorting_indices[begin++]]; });; 682 std::generate(fEXlowdSorted.begin(), fEXlowdSorted.end(),; 683 [begin = low, &sorting_indices, this]() mutable { return fEXlowd[sorting_indices[begin++]]; });; 684 std::generate(fEXhighdSorted.begin(), fEXhighdSorted.end(),; 685 [begin = low, &sorting_indices, this]() mutable { return fEXhighd[sorting_indices[begin++]]; });; 686 ; 687 std::g",MatchSource.WIKI,doc/master/TGraphBentErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html
https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html:24046,Availability,error,error,24046,"]]; });; 682 std::generate(fEXlowdSorted.begin(), fEXlowdSorted.end(),; 683 [begin = low, &sorting_indices, this]() mutable { return fEXlowd[sorting_indices[begin++]]; });; 684 std::generate(fEXhighdSorted.begin(), fEXhighdSorted.end(),; 685 [begin = low, &sorting_indices, this]() mutable { return fEXhighd[sorting_indices[begin++]]; });; 686 ; 687 std::generate(fEYlowSorted.begin(), fEYlowSorted.end(),; 688 [begin = low, &sorting_indices, this]() mutable { return fEYlow[sorting_indices[begin++]]; });; 689 std::generate(fEYhighSorted.begin(), fEYhighSorted.end(),; 690 [begin = low, &sorting_indices, this]() mutable { return fEYhigh[sorting_indices[begin++]]; });; 691 std::generate(fEYlowdSorted.begin(), fEYlowdSorted.end(),; 692 [begin = low, &sorting_indices, this]() mutable { return fEYlowd[sorting_indices[begin++]]; });; 693 std::generate(fEYhighdSorted.begin(), fEYhighdSorted.end(),; 694 [begin = low, &sorting_indices, this]() mutable { return fEYhighd[sorting_indices[begin++]]; });; 695 ; 696 // Copy the sorted X and Y error values back to the original arrays; 697 std::copy(fEXlowSorted.begin(), fEXlowSorted.end(), fEXlow + low);; 698 std::copy(fEXhighSorted.begin(), fEXhighSorted.end(), fEXhigh + low);; 699 std::copy(fEXlowdSorted.begin(), fEXlowdSorted.end(), fEXlowd + low);; 700 std::copy(fEXhighdSorted.begin(), fEXhighdSorted.end(), fEXhighd + low);; 701 ; 702 std::copy(fEYlowSorted.begin(), fEYlowSorted.end(), fEYlow + low);; 703 std::copy(fEYhighSorted.begin(), fEYhighSorted.end(), fEYhigh + low);; 704 std::copy(fEYlowdSorted.begin(), fEYlowdSorted.end(), fEYlowd + low);; 705 std::copy(fEYhighdSorted.begin(), fEYhighdSorted.end(), fEYhighd + low);; 706 ; 707 TGraph::UpdateArrays(sorting_indices, numSortedPoints, low);; 708}; f#define f(i)Definition RSha256.hxx:104; g#define g(i)Definition RSha256.hxx:105; Float_tfloat Float_tDefinition RtypesCore.h:57; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; Double_tdouble Double_tDefinition RtypesCore.h:5",MatchSource.WIKI,doc/master/TGraphBentErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html
https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html:25690,Availability,error,error,25690,"highdSorted.end(), fEYhighd + low);; 706 ; 707 TGraph::UpdateArrays(sorting_indices, numSortedPoints, low);; 708}; f#define f(i)Definition RSha256.hxx:104; g#define g(i)Definition RSha256.hxx:105; Float_tfloat Float_tDefinition RtypesCore.h:57; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; Double_tdouble Double_tDefinition RtypesCore.h:59; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; Option_tconst char Option_tDefinition RtypesCore.h:66; ClassImp#define ClassImp(name)Definition Rtypes.h:382; TF1.h; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; TGraphBentErrors.h; TH1.h; xminfloat xminDefinition THbookFile.cxx:95; yminfloat yminDefinition THbookFile.cxx:95; xmaxfloat xmaxDefinition THbookFile.cxx:95; ymaxfloat ymaxDefinition THbookFile.cxx:95; TMath.h; TROOT.h; gROOT#define gROOTDefinition TROOT.h:406; TVirtualPad.h; gPad#define gPadDefinition TVirtualPad.h:308; TF11-Dim function classDefinition TF1.h:233; TGraphBentErrorsA TGraphBentErrors is a TGraph with bent, asymmetric error bars.Definition TGraphBentErrors.h:25; TGraphBentErrors::UpdateArraysvoid UpdateArrays(const std::vector< Int_t > &sorting_indices, Int_t numSortedPoints, Int_t low) overrideUpdate the fX, fY, fEXlow, fEXhigh, fEXlowd, fEXhighd, fEYlow, fEYhigh, fEYlowd, and fEYhighd array...Definition TGraphBentErrors.cxx:665; TGraphBentErrors::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave primitive as a C++ statement(s) on output stream out.Definition TGraphBentErrors.cxx:551; TGraphBentErrors::TGraphBentErrorsTGraphBentErrors()TGraphBentErrors default constructor.Definition TGraphBentErrors.cxx:62; TGraphBentErrors::GetEXlowDouble_t * GetEXlow() const overrideDefinition TGraphBentErrors.h:80; TGraphBentErrors::fEYhighDouble_t * fEYhigh[fNpoints] array of Y high errorsDefinition TGraphBentErrors.h:31; TGraphBentErrors::fEXlowdDouble_t * fEXlowd[fNpoints] array of X low displacementsDefinition TGraphBentErrors.h:33; TGraphBen",MatchSource.WIKI,doc/master/TGraphBentErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html
https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html:26493,Availability,error,errorsDefinition,26493," gROOT#define gROOTDefinition TROOT.h:406; TVirtualPad.h; gPad#define gPadDefinition TVirtualPad.h:308; TF11-Dim function classDefinition TF1.h:233; TGraphBentErrorsA TGraphBentErrors is a TGraph with bent, asymmetric error bars.Definition TGraphBentErrors.h:25; TGraphBentErrors::UpdateArraysvoid UpdateArrays(const std::vector< Int_t > &sorting_indices, Int_t numSortedPoints, Int_t low) overrideUpdate the fX, fY, fEXlow, fEXhigh, fEXlowd, fEXhighd, fEYlow, fEYhigh, fEYlowd, and fEYhighd array...Definition TGraphBentErrors.cxx:665; TGraphBentErrors::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave primitive as a C++ statement(s) on output stream out.Definition TGraphBentErrors.cxx:551; TGraphBentErrors::TGraphBentErrorsTGraphBentErrors()TGraphBentErrors default constructor.Definition TGraphBentErrors.cxx:62; TGraphBentErrors::GetEXlowDouble_t * GetEXlow() const overrideDefinition TGraphBentErrors.h:80; TGraphBentErrors::fEYhighDouble_t * fEYhigh[fNpoints] array of Y high errorsDefinition TGraphBentErrors.h:31; TGraphBentErrors::fEXlowdDouble_t * fEXlowd[fNpoints] array of X low displacementsDefinition TGraphBentErrors.h:33; TGraphBentErrors::fEYlowdDouble_t * fEYlowd[fNpoints] array of Y low displacementsDefinition TGraphBentErrors.h:35; TGraphBentErrors::CtorAllocateBool_t CtorAllocate()Should be called from ctors after fNpoints has been set.Definition TGraphBentErrors.cxx:346; TGraphBentErrors::DoMergeBool_t DoMerge(const TGraph *g) overrideProtected function to perform the merge operation of a graph with asymmetric errors.Definition TGraphBentErrors.cxx:367; TGraphBentErrors::GetEYhighDouble_t * GetEYhigh() const overrideDefinition TGraphBentErrors.h:83; TGraphBentErrors::GetErrorXlowDouble_t GetErrorXlow(Int_t bin) const overrideGet low error on X[i].Definition TGraphBentErrors.cxx:441; TGraphBentErrors::GetEYlowDouble_t * GetEYlow() const overrideDefinition TGraphBentErrors.h:82; TGraphBentErrors::GetEYhighdDouble_t * GetEYhig",MatchSource.WIKI,doc/master/TGraphBentErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html
https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html:27051,Availability,error,errors,27051,"ion TGraphBentErrors.cxx:665; TGraphBentErrors::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave primitive as a C++ statement(s) on output stream out.Definition TGraphBentErrors.cxx:551; TGraphBentErrors::TGraphBentErrorsTGraphBentErrors()TGraphBentErrors default constructor.Definition TGraphBentErrors.cxx:62; TGraphBentErrors::GetEXlowDouble_t * GetEXlow() const overrideDefinition TGraphBentErrors.h:80; TGraphBentErrors::fEYhighDouble_t * fEYhigh[fNpoints] array of Y high errorsDefinition TGraphBentErrors.h:31; TGraphBentErrors::fEXlowdDouble_t * fEXlowd[fNpoints] array of X low displacementsDefinition TGraphBentErrors.h:33; TGraphBentErrors::fEYlowdDouble_t * fEYlowd[fNpoints] array of Y low displacementsDefinition TGraphBentErrors.h:35; TGraphBentErrors::CtorAllocateBool_t CtorAllocate()Should be called from ctors after fNpoints has been set.Definition TGraphBentErrors.cxx:346; TGraphBentErrors::DoMergeBool_t DoMerge(const TGraph *g) overrideProtected function to perform the merge operation of a graph with asymmetric errors.Definition TGraphBentErrors.cxx:367; TGraphBentErrors::GetEYhighDouble_t * GetEYhigh() const overrideDefinition TGraphBentErrors.h:83; TGraphBentErrors::GetErrorXlowDouble_t GetErrorXlow(Int_t bin) const overrideGet low error on X[i].Definition TGraphBentErrors.cxx:441; TGraphBentErrors::GetEYlowDouble_t * GetEYlow() const overrideDefinition TGraphBentErrors.h:82; TGraphBentErrors::GetEYhighdDouble_t * GetEYhighd() const overrideDefinition TGraphBentErrors.h:87; TGraphBentErrors::ComputeRangevoid ComputeRange(Double_t &xmin, Double_t &ymin, Double_t &xmax, Double_t &ymax) const overrideCompute range.Definition TGraphBentErrors.cxx:248; TGraphBentErrors::GetEXhighDouble_t * GetEXhigh() const overrideDefinition TGraphBentErrors.h:81; TGraphBentErrors::Classstatic TClass * Class(); TGraphBentErrors::GetEYlowdDouble_t * GetEYlowd() const overrideDefinition TGraphBentErrors.h:86; TGraphBentErrors::fEXhighdDouble_",MatchSource.WIKI,doc/master/TGraphBentErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html
https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html:27278,Availability,error,error,27278,"aphBentErrors()TGraphBentErrors default constructor.Definition TGraphBentErrors.cxx:62; TGraphBentErrors::GetEXlowDouble_t * GetEXlow() const overrideDefinition TGraphBentErrors.h:80; TGraphBentErrors::fEYhighDouble_t * fEYhigh[fNpoints] array of Y high errorsDefinition TGraphBentErrors.h:31; TGraphBentErrors::fEXlowdDouble_t * fEXlowd[fNpoints] array of X low displacementsDefinition TGraphBentErrors.h:33; TGraphBentErrors::fEYlowdDouble_t * fEYlowd[fNpoints] array of Y low displacementsDefinition TGraphBentErrors.h:35; TGraphBentErrors::CtorAllocateBool_t CtorAllocate()Should be called from ctors after fNpoints has been set.Definition TGraphBentErrors.cxx:346; TGraphBentErrors::DoMergeBool_t DoMerge(const TGraph *g) overrideProtected function to perform the merge operation of a graph with asymmetric errors.Definition TGraphBentErrors.cxx:367; TGraphBentErrors::GetEYhighDouble_t * GetEYhigh() const overrideDefinition TGraphBentErrors.h:83; TGraphBentErrors::GetErrorXlowDouble_t GetErrorXlow(Int_t bin) const overrideGet low error on X[i].Definition TGraphBentErrors.cxx:441; TGraphBentErrors::GetEYlowDouble_t * GetEYlow() const overrideDefinition TGraphBentErrors.h:82; TGraphBentErrors::GetEYhighdDouble_t * GetEYhighd() const overrideDefinition TGraphBentErrors.h:87; TGraphBentErrors::ComputeRangevoid ComputeRange(Double_t &xmin, Double_t &ymin, Double_t &xmax, Double_t &ymax) const overrideCompute range.Definition TGraphBentErrors.cxx:248; TGraphBentErrors::GetEXhighDouble_t * GetEXhigh() const overrideDefinition TGraphBentErrors.h:81; TGraphBentErrors::Classstatic TClass * Class(); TGraphBentErrors::GetEYlowdDouble_t * GetEYlowd() const overrideDefinition TGraphBentErrors.h:86; TGraphBentErrors::fEXhighdDouble_t * fEXhighd[fNpoints] array of X high displacementsDefinition TGraphBentErrors.h:34; TGraphBentErrors::GetEXhighdDouble_t * GetEXhighd() const overrideDefinition TGraphBentErrors.h:85; TGraphBentErrors::GetErrorXhighDouble_t GetErrorXhigh(Int_t bin) const over",MatchSource.WIKI,doc/master/TGraphBentErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html
https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html:28253,Availability,error,error,28253,"tErrorXlowDouble_t GetErrorXlow(Int_t bin) const overrideGet low error on X[i].Definition TGraphBentErrors.cxx:441; TGraphBentErrors::GetEYlowDouble_t * GetEYlow() const overrideDefinition TGraphBentErrors.h:82; TGraphBentErrors::GetEYhighdDouble_t * GetEYhighd() const overrideDefinition TGraphBentErrors.h:87; TGraphBentErrors::ComputeRangevoid ComputeRange(Double_t &xmin, Double_t &ymin, Double_t &xmax, Double_t &ymax) const overrideCompute range.Definition TGraphBentErrors.cxx:248; TGraphBentErrors::GetEXhighDouble_t * GetEXhigh() const overrideDefinition TGraphBentErrors.h:81; TGraphBentErrors::Classstatic TClass * Class(); TGraphBentErrors::GetEYlowdDouble_t * GetEYlowd() const overrideDefinition TGraphBentErrors.h:86; TGraphBentErrors::fEXhighdDouble_t * fEXhighd[fNpoints] array of X high displacementsDefinition TGraphBentErrors.h:34; TGraphBentErrors::GetEXhighdDouble_t * GetEXhighd() const overrideDefinition TGraphBentErrors.h:85; TGraphBentErrors::GetErrorXhighDouble_t GetErrorXhigh(Int_t bin) const overrideGet high error on X[i].Definition TGraphBentErrors.cxx:430; TGraphBentErrors::AddPointErrorvirtual void AddPointError(Double_t x, Double_t y, Double_t exl, Double_t exh, Double_t eyl, Double_t eyh, Double_t exld=0, Double_t exhd=0, Double_t eyld=0, Double_t eyhd=0)Add a point with bent errors to the graph.Definition TGraphBentErrors.cxx:192; TGraphBentErrors::SetPointErrorvirtual void SetPointError(Double_t exl, Double_t exh, Double_t eyl, Double_t eyh, Double_t exld=0, Double_t exhd=0, Double_t eyld=0, Double_t eyhd=0)Set ex and ey values for point pointed by the mouse.Definition TGraphBentErrors.cxx:587; TGraphBentErrors::fEXlowDouble_t * fEXlow[fNpoints] array of X low errorsDefinition TGraphBentErrors.h:28; TGraphBentErrors::fEXhighDouble_t * fEXhigh[fNpoints] array of X high errorsDefinition TGraphBentErrors.h:29; TGraphBentErrors::~TGraphBentErrors~TGraphBentErrors() overrideTGraphBentErrors default destructor.Definition TGraphBentErrors.cxx:176; TG",MatchSource.WIKI,doc/master/TGraphBentErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html
https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html:28531,Availability,error,errors,28531,"; TGraphBentErrors::GetEYhighdDouble_t * GetEYhighd() const overrideDefinition TGraphBentErrors.h:87; TGraphBentErrors::ComputeRangevoid ComputeRange(Double_t &xmin, Double_t &ymin, Double_t &xmax, Double_t &ymax) const overrideCompute range.Definition TGraphBentErrors.cxx:248; TGraphBentErrors::GetEXhighDouble_t * GetEXhigh() const overrideDefinition TGraphBentErrors.h:81; TGraphBentErrors::Classstatic TClass * Class(); TGraphBentErrors::GetEYlowdDouble_t * GetEYlowd() const overrideDefinition TGraphBentErrors.h:86; TGraphBentErrors::fEXhighdDouble_t * fEXhighd[fNpoints] array of X high displacementsDefinition TGraphBentErrors.h:34; TGraphBentErrors::GetEXhighdDouble_t * GetEXhighd() const overrideDefinition TGraphBentErrors.h:85; TGraphBentErrors::GetErrorXhighDouble_t GetErrorXhigh(Int_t bin) const overrideGet high error on X[i].Definition TGraphBentErrors.cxx:430; TGraphBentErrors::AddPointErrorvirtual void AddPointError(Double_t x, Double_t y, Double_t exl, Double_t exh, Double_t eyl, Double_t eyh, Double_t exld=0, Double_t exhd=0, Double_t eyld=0, Double_t eyhd=0)Add a point with bent errors to the graph.Definition TGraphBentErrors.cxx:192; TGraphBentErrors::SetPointErrorvirtual void SetPointError(Double_t exl, Double_t exh, Double_t eyl, Double_t eyh, Double_t exld=0, Double_t exhd=0, Double_t eyld=0, Double_t eyhd=0)Set ex and ey values for point pointed by the mouse.Definition TGraphBentErrors.cxx:587; TGraphBentErrors::fEXlowDouble_t * fEXlow[fNpoints] array of X low errorsDefinition TGraphBentErrors.h:28; TGraphBentErrors::fEXhighDouble_t * fEXhigh[fNpoints] array of X high errorsDefinition TGraphBentErrors.h:29; TGraphBentErrors::~TGraphBentErrors~TGraphBentErrors() overrideTGraphBentErrors default destructor.Definition TGraphBentErrors.cxx:176; TGraphBentErrors::Printvoid Print(Option_t *chopt="""") const overridePrint graph and errors values.Definition TGraphBentErrors.cxx:495; TGraphBentErrors::Scalevoid Scale(Double_t c1=1., Option_t *option=""y"") overr",MatchSource.WIKI,doc/master/TGraphBentErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html
https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html:28925,Availability,error,errorsDefinition,28925,"overrideDefinition TGraphBentErrors.h:86; TGraphBentErrors::fEXhighdDouble_t * fEXhighd[fNpoints] array of X high displacementsDefinition TGraphBentErrors.h:34; TGraphBentErrors::GetEXhighdDouble_t * GetEXhighd() const overrideDefinition TGraphBentErrors.h:85; TGraphBentErrors::GetErrorXhighDouble_t GetErrorXhigh(Int_t bin) const overrideGet high error on X[i].Definition TGraphBentErrors.cxx:430; TGraphBentErrors::AddPointErrorvirtual void AddPointError(Double_t x, Double_t y, Double_t exl, Double_t exh, Double_t eyl, Double_t eyh, Double_t exld=0, Double_t exhd=0, Double_t eyld=0, Double_t eyhd=0)Add a point with bent errors to the graph.Definition TGraphBentErrors.cxx:192; TGraphBentErrors::SetPointErrorvirtual void SetPointError(Double_t exl, Double_t exh, Double_t eyl, Double_t eyh, Double_t exld=0, Double_t exhd=0, Double_t eyld=0, Double_t eyhd=0)Set ex and ey values for point pointed by the mouse.Definition TGraphBentErrors.cxx:587; TGraphBentErrors::fEXlowDouble_t * fEXlow[fNpoints] array of X low errorsDefinition TGraphBentErrors.h:28; TGraphBentErrors::fEXhighDouble_t * fEXhigh[fNpoints] array of X high errorsDefinition TGraphBentErrors.h:29; TGraphBentErrors::~TGraphBentErrors~TGraphBentErrors() overrideTGraphBentErrors default destructor.Definition TGraphBentErrors.cxx:176; TGraphBentErrors::Printvoid Print(Option_t *chopt="""") const overridePrint graph and errors values.Definition TGraphBentErrors.cxx:495; TGraphBentErrors::Scalevoid Scale(Double_t c1=1., Option_t *option=""y"") overrideMultiply the values and errors of a TGraphBentErrors by a constant c1.Definition TGraphBentErrors.cxx:510; TGraphBentErrors::FillZerovoid FillZero(Int_t begin, Int_t end, Bool_t from_ctor=kTRUE) overrideSet zero values for point arrays in the range [begin, end]Definition TGraphBentErrors.cxx:474; TGraphBentErrors::GetEXlowdDouble_t * GetEXlowd() const overrideDefinition TGraphBentErrors.h:84; TGraphBentErrors::GetErrorYDouble_t GetErrorY(Int_t bin) const overrideIt returns ",MatchSource.WIKI,doc/master/TGraphBentErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html
https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html:29035,Availability,error,errorsDefinition,29035,"igh displacementsDefinition TGraphBentErrors.h:34; TGraphBentErrors::GetEXhighdDouble_t * GetEXhighd() const overrideDefinition TGraphBentErrors.h:85; TGraphBentErrors::GetErrorXhighDouble_t GetErrorXhigh(Int_t bin) const overrideGet high error on X[i].Definition TGraphBentErrors.cxx:430; TGraphBentErrors::AddPointErrorvirtual void AddPointError(Double_t x, Double_t y, Double_t exl, Double_t exh, Double_t eyl, Double_t eyh, Double_t exld=0, Double_t exhd=0, Double_t eyld=0, Double_t eyhd=0)Add a point with bent errors to the graph.Definition TGraphBentErrors.cxx:192; TGraphBentErrors::SetPointErrorvirtual void SetPointError(Double_t exl, Double_t exh, Double_t eyl, Double_t eyh, Double_t exld=0, Double_t exhd=0, Double_t eyld=0, Double_t eyhd=0)Set ex and ey values for point pointed by the mouse.Definition TGraphBentErrors.cxx:587; TGraphBentErrors::fEXlowDouble_t * fEXlow[fNpoints] array of X low errorsDefinition TGraphBentErrors.h:28; TGraphBentErrors::fEXhighDouble_t * fEXhigh[fNpoints] array of X high errorsDefinition TGraphBentErrors.h:29; TGraphBentErrors::~TGraphBentErrors~TGraphBentErrors() overrideTGraphBentErrors default destructor.Definition TGraphBentErrors.cxx:176; TGraphBentErrors::Printvoid Print(Option_t *chopt="""") const overridePrint graph and errors values.Definition TGraphBentErrors.cxx:495; TGraphBentErrors::Scalevoid Scale(Double_t c1=1., Option_t *option=""y"") overrideMultiply the values and errors of a TGraphBentErrors by a constant c1.Definition TGraphBentErrors.cxx:510; TGraphBentErrors::FillZerovoid FillZero(Int_t begin, Int_t end, Bool_t from_ctor=kTRUE) overrideSet zero values for point arrays in the range [begin, end]Definition TGraphBentErrors.cxx:474; TGraphBentErrors::GetEXlowdDouble_t * GetEXlowd() const overrideDefinition TGraphBentErrors.h:84; TGraphBentErrors::GetErrorYDouble_t GetErrorY(Int_t bin) const overrideIt returns the error along Y at point i.Definition TGraphBentErrors.cxx:416; TGraphBentErrors::fEYlowDouble_t * fEYlow[fN",MatchSource.WIKI,doc/master/TGraphBentErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html
https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html:29295,Availability,error,errors,29295,"ror on X[i].Definition TGraphBentErrors.cxx:430; TGraphBentErrors::AddPointErrorvirtual void AddPointError(Double_t x, Double_t y, Double_t exl, Double_t exh, Double_t eyl, Double_t eyh, Double_t exld=0, Double_t exhd=0, Double_t eyld=0, Double_t eyhd=0)Add a point with bent errors to the graph.Definition TGraphBentErrors.cxx:192; TGraphBentErrors::SetPointErrorvirtual void SetPointError(Double_t exl, Double_t exh, Double_t eyl, Double_t eyh, Double_t exld=0, Double_t exhd=0, Double_t eyld=0, Double_t eyhd=0)Set ex and ey values for point pointed by the mouse.Definition TGraphBentErrors.cxx:587; TGraphBentErrors::fEXlowDouble_t * fEXlow[fNpoints] array of X low errorsDefinition TGraphBentErrors.h:28; TGraphBentErrors::fEXhighDouble_t * fEXhigh[fNpoints] array of X high errorsDefinition TGraphBentErrors.h:29; TGraphBentErrors::~TGraphBentErrors~TGraphBentErrors() overrideTGraphBentErrors default destructor.Definition TGraphBentErrors.cxx:176; TGraphBentErrors::Printvoid Print(Option_t *chopt="""") const overridePrint graph and errors values.Definition TGraphBentErrors.cxx:495; TGraphBentErrors::Scalevoid Scale(Double_t c1=1., Option_t *option=""y"") overrideMultiply the values and errors of a TGraphBentErrors by a constant c1.Definition TGraphBentErrors.cxx:510; TGraphBentErrors::FillZerovoid FillZero(Int_t begin, Int_t end, Bool_t from_ctor=kTRUE) overrideSet zero values for point arrays in the range [begin, end]Definition TGraphBentErrors.cxx:474; TGraphBentErrors::GetEXlowdDouble_t * GetEXlowd() const overrideDefinition TGraphBentErrors.h:84; TGraphBentErrors::GetErrorYDouble_t GetErrorY(Int_t bin) const overrideIt returns the error along Y at point i.Definition TGraphBentErrors.cxx:416; TGraphBentErrors::fEYlowDouble_t * fEYlow[fNpoints] array of Y low errorsDefinition TGraphBentErrors.h:30; TGraphBentErrors::fEYhighdDouble_t * fEYhighd[fNpoints] array of Y high displacementsDefinition TGraphBentErrors.h:36; TGraphBentErrors::CopyAndReleasevoid CopyAndRelease(Double_t",MatchSource.WIKI,doc/master/TGraphBentErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html
https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html:29450,Availability,error,errors,29450,"ble_t exld=0, Double_t exhd=0, Double_t eyld=0, Double_t eyhd=0)Add a point with bent errors to the graph.Definition TGraphBentErrors.cxx:192; TGraphBentErrors::SetPointErrorvirtual void SetPointError(Double_t exl, Double_t exh, Double_t eyl, Double_t eyh, Double_t exld=0, Double_t exhd=0, Double_t eyld=0, Double_t eyhd=0)Set ex and ey values for point pointed by the mouse.Definition TGraphBentErrors.cxx:587; TGraphBentErrors::fEXlowDouble_t * fEXlow[fNpoints] array of X low errorsDefinition TGraphBentErrors.h:28; TGraphBentErrors::fEXhighDouble_t * fEXhigh[fNpoints] array of X high errorsDefinition TGraphBentErrors.h:29; TGraphBentErrors::~TGraphBentErrors~TGraphBentErrors() overrideTGraphBentErrors default destructor.Definition TGraphBentErrors.cxx:176; TGraphBentErrors::Printvoid Print(Option_t *chopt="""") const overridePrint graph and errors values.Definition TGraphBentErrors.cxx:495; TGraphBentErrors::Scalevoid Scale(Double_t c1=1., Option_t *option=""y"") overrideMultiply the values and errors of a TGraphBentErrors by a constant c1.Definition TGraphBentErrors.cxx:510; TGraphBentErrors::FillZerovoid FillZero(Int_t begin, Int_t end, Bool_t from_ctor=kTRUE) overrideSet zero values for point arrays in the range [begin, end]Definition TGraphBentErrors.cxx:474; TGraphBentErrors::GetEXlowdDouble_t * GetEXlowd() const overrideDefinition TGraphBentErrors.h:84; TGraphBentErrors::GetErrorYDouble_t GetErrorY(Int_t bin) const overrideIt returns the error along Y at point i.Definition TGraphBentErrors.cxx:416; TGraphBentErrors::fEYlowDouble_t * fEYlow[fNpoints] array of Y low errorsDefinition TGraphBentErrors.h:30; TGraphBentErrors::fEYhighdDouble_t * fEYhighd[fNpoints] array of Y high displacementsDefinition TGraphBentErrors.h:36; TGraphBentErrors::CopyAndReleasevoid CopyAndRelease(Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy and release.Definition TGraphBentErrors.cxx:278; TGraphBentErrors::SwapPointsvoid SwapPoints(Int_t pos1, Int_t pos2) overr",MatchSource.WIKI,doc/master/TGraphBentErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html
https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html:29908,Availability,error,error,29908,"::fEXlowDouble_t * fEXlow[fNpoints] array of X low errorsDefinition TGraphBentErrors.h:28; TGraphBentErrors::fEXhighDouble_t * fEXhigh[fNpoints] array of X high errorsDefinition TGraphBentErrors.h:29; TGraphBentErrors::~TGraphBentErrors~TGraphBentErrors() overrideTGraphBentErrors default destructor.Definition TGraphBentErrors.cxx:176; TGraphBentErrors::Printvoid Print(Option_t *chopt="""") const overridePrint graph and errors values.Definition TGraphBentErrors.cxx:495; TGraphBentErrors::Scalevoid Scale(Double_t c1=1., Option_t *option=""y"") overrideMultiply the values and errors of a TGraphBentErrors by a constant c1.Definition TGraphBentErrors.cxx:510; TGraphBentErrors::FillZerovoid FillZero(Int_t begin, Int_t end, Bool_t from_ctor=kTRUE) overrideSet zero values for point arrays in the range [begin, end]Definition TGraphBentErrors.cxx:474; TGraphBentErrors::GetEXlowdDouble_t * GetEXlowd() const overrideDefinition TGraphBentErrors.h:84; TGraphBentErrors::GetErrorYDouble_t GetErrorY(Int_t bin) const overrideIt returns the error along Y at point i.Definition TGraphBentErrors.cxx:416; TGraphBentErrors::fEYlowDouble_t * fEYlow[fNpoints] array of Y low errorsDefinition TGraphBentErrors.h:30; TGraphBentErrors::fEYhighdDouble_t * fEYhighd[fNpoints] array of Y high displacementsDefinition TGraphBentErrors.h:36; TGraphBentErrors::CopyAndReleasevoid CopyAndRelease(Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy and release.Definition TGraphBentErrors.cxx:278; TGraphBentErrors::SwapPointsvoid SwapPoints(Int_t pos1, Int_t pos2) overrideSwap points.Definition TGraphBentErrors.cxx:646; TGraphBentErrors::CopyPointsBool_t CopyPoints(Double_t **arrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy errors from fE***to arrays[***] or to f*** Copy points.Definition TGraphBentErrors.cxx:312; TGraphBentErrors::GetErrorYlowDouble_t GetErrorYlow(Int_t bin) const overrideGet low error on Y[i].Definition TGraphBentErrors.cxx:463; TGraphBentErrors::GetErrorXDoubl",MatchSource.WIKI,doc/master/TGraphBentErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html
https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html:30037,Availability,error,errorsDefinition,30037,"s] array of X high errorsDefinition TGraphBentErrors.h:29; TGraphBentErrors::~TGraphBentErrors~TGraphBentErrors() overrideTGraphBentErrors default destructor.Definition TGraphBentErrors.cxx:176; TGraphBentErrors::Printvoid Print(Option_t *chopt="""") const overridePrint graph and errors values.Definition TGraphBentErrors.cxx:495; TGraphBentErrors::Scalevoid Scale(Double_t c1=1., Option_t *option=""y"") overrideMultiply the values and errors of a TGraphBentErrors by a constant c1.Definition TGraphBentErrors.cxx:510; TGraphBentErrors::FillZerovoid FillZero(Int_t begin, Int_t end, Bool_t from_ctor=kTRUE) overrideSet zero values for point arrays in the range [begin, end]Definition TGraphBentErrors.cxx:474; TGraphBentErrors::GetEXlowdDouble_t * GetEXlowd() const overrideDefinition TGraphBentErrors.h:84; TGraphBentErrors::GetErrorYDouble_t GetErrorY(Int_t bin) const overrideIt returns the error along Y at point i.Definition TGraphBentErrors.cxx:416; TGraphBentErrors::fEYlowDouble_t * fEYlow[fNpoints] array of Y low errorsDefinition TGraphBentErrors.h:30; TGraphBentErrors::fEYhighdDouble_t * fEYhighd[fNpoints] array of Y high displacementsDefinition TGraphBentErrors.h:36; TGraphBentErrors::CopyAndReleasevoid CopyAndRelease(Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy and release.Definition TGraphBentErrors.cxx:278; TGraphBentErrors::SwapPointsvoid SwapPoints(Int_t pos1, Int_t pos2) overrideSwap points.Definition TGraphBentErrors.cxx:646; TGraphBentErrors::CopyPointsBool_t CopyPoints(Double_t **arrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy errors from fE***to arrays[***] or to f*** Copy points.Definition TGraphBentErrors.cxx:312; TGraphBentErrors::GetErrorYlowDouble_t GetErrorYlow(Int_t bin) const overrideGet low error on Y[i].Definition TGraphBentErrors.cxx:463; TGraphBentErrors::GetErrorXDouble_t GetErrorX(Int_t bin) const overrideIt returns the error along X at point i.Definition TGraphBentErrors.cxx:402; TGraphBentErrors::GetErro",MatchSource.WIKI,doc/master/TGraphBentErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html
https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html:30615,Availability,error,errors,30615,"begin, Int_t end, Bool_t from_ctor=kTRUE) overrideSet zero values for point arrays in the range [begin, end]Definition TGraphBentErrors.cxx:474; TGraphBentErrors::GetEXlowdDouble_t * GetEXlowd() const overrideDefinition TGraphBentErrors.h:84; TGraphBentErrors::GetErrorYDouble_t GetErrorY(Int_t bin) const overrideIt returns the error along Y at point i.Definition TGraphBentErrors.cxx:416; TGraphBentErrors::fEYlowDouble_t * fEYlow[fNpoints] array of Y low errorsDefinition TGraphBentErrors.h:30; TGraphBentErrors::fEYhighdDouble_t * fEYhighd[fNpoints] array of Y high displacementsDefinition TGraphBentErrors.h:36; TGraphBentErrors::CopyAndReleasevoid CopyAndRelease(Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy and release.Definition TGraphBentErrors.cxx:278; TGraphBentErrors::SwapPointsvoid SwapPoints(Int_t pos1, Int_t pos2) overrideSwap points.Definition TGraphBentErrors.cxx:646; TGraphBentErrors::CopyPointsBool_t CopyPoints(Double_t **arrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy errors from fE***to arrays[***] or to f*** Copy points.Definition TGraphBentErrors.cxx:312; TGraphBentErrors::GetErrorYlowDouble_t GetErrorYlow(Int_t bin) const overrideGet low error on Y[i].Definition TGraphBentErrors.cxx:463; TGraphBentErrors::GetErrorXDouble_t GetErrorX(Int_t bin) const overrideIt returns the error along X at point i.Definition TGraphBentErrors.cxx:402; TGraphBentErrors::GetErrorYhighDouble_t GetErrorYhigh(Int_t bin) const overrideGet high error on Y[i].Definition TGraphBentErrors.cxx:452; TGraphBentErrors::Applyvoid Apply(TF1 *f) overrideApply a function to all data points .Definition TGraphBentErrors.cxx:210; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; TGraph::Classstatic TClass * Class(); TGraph::AddPointvirtual void AddPoint(Double_t x, Double_t y)Append a new point to the graph.Definition TGraph.h:98; TGraph::fNpointsInt_t fNpointsNumber of points <= fMaxSize.Definition TGr",MatchSource.WIKI,doc/master/TGraphBentErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html
https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html:30792,Availability,error,error,30792,"ouble_t * GetEXlowd() const overrideDefinition TGraphBentErrors.h:84; TGraphBentErrors::GetErrorYDouble_t GetErrorY(Int_t bin) const overrideIt returns the error along Y at point i.Definition TGraphBentErrors.cxx:416; TGraphBentErrors::fEYlowDouble_t * fEYlow[fNpoints] array of Y low errorsDefinition TGraphBentErrors.h:30; TGraphBentErrors::fEYhighdDouble_t * fEYhighd[fNpoints] array of Y high displacementsDefinition TGraphBentErrors.h:36; TGraphBentErrors::CopyAndReleasevoid CopyAndRelease(Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy and release.Definition TGraphBentErrors.cxx:278; TGraphBentErrors::SwapPointsvoid SwapPoints(Int_t pos1, Int_t pos2) overrideSwap points.Definition TGraphBentErrors.cxx:646; TGraphBentErrors::CopyPointsBool_t CopyPoints(Double_t **arrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy errors from fE***to arrays[***] or to f*** Copy points.Definition TGraphBentErrors.cxx:312; TGraphBentErrors::GetErrorYlowDouble_t GetErrorYlow(Int_t bin) const overrideGet low error on Y[i].Definition TGraphBentErrors.cxx:463; TGraphBentErrors::GetErrorXDouble_t GetErrorX(Int_t bin) const overrideIt returns the error along X at point i.Definition TGraphBentErrors.cxx:402; TGraphBentErrors::GetErrorYhighDouble_t GetErrorYhigh(Int_t bin) const overrideGet high error on Y[i].Definition TGraphBentErrors.cxx:452; TGraphBentErrors::Applyvoid Apply(TF1 *f) overrideApply a function to all data points .Definition TGraphBentErrors.cxx:210; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; TGraph::Classstatic TClass * Class(); TGraph::AddPointvirtual void AddPoint(Double_t x, Double_t y)Append a new point to the graph.Definition TGraph.h:98; TGraph::fNpointsInt_t fNpointsNumber of points <= fMaxSize.Definition TGraph.h:46; TGraph::SetPointvirtual void SetPoint(Int_t i, Double_t x, Double_t y)Set x and y values for point number i.Definition TGraph.cxx:2342; TGraph::fMaxSizeInt_t fMaxS",MatchSource.WIKI,doc/master/TGraphBentErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html
https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html:30929,Availability,error,error,30929,"t returns the error along Y at point i.Definition TGraphBentErrors.cxx:416; TGraphBentErrors::fEYlowDouble_t * fEYlow[fNpoints] array of Y low errorsDefinition TGraphBentErrors.h:30; TGraphBentErrors::fEYhighdDouble_t * fEYhighd[fNpoints] array of Y high displacementsDefinition TGraphBentErrors.h:36; TGraphBentErrors::CopyAndReleasevoid CopyAndRelease(Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy and release.Definition TGraphBentErrors.cxx:278; TGraphBentErrors::SwapPointsvoid SwapPoints(Int_t pos1, Int_t pos2) overrideSwap points.Definition TGraphBentErrors.cxx:646; TGraphBentErrors::CopyPointsBool_t CopyPoints(Double_t **arrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy errors from fE***to arrays[***] or to f*** Copy points.Definition TGraphBentErrors.cxx:312; TGraphBentErrors::GetErrorYlowDouble_t GetErrorYlow(Int_t bin) const overrideGet low error on Y[i].Definition TGraphBentErrors.cxx:463; TGraphBentErrors::GetErrorXDouble_t GetErrorX(Int_t bin) const overrideIt returns the error along X at point i.Definition TGraphBentErrors.cxx:402; TGraphBentErrors::GetErrorYhighDouble_t GetErrorYhigh(Int_t bin) const overrideGet high error on Y[i].Definition TGraphBentErrors.cxx:452; TGraphBentErrors::Applyvoid Apply(TF1 *f) overrideApply a function to all data points .Definition TGraphBentErrors.cxx:210; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; TGraph::Classstatic TClass * Class(); TGraph::AddPointvirtual void AddPoint(Double_t x, Double_t y)Append a new point to the graph.Definition TGraph.h:98; TGraph::fNpointsInt_t fNpointsNumber of points <= fMaxSize.Definition TGraph.h:46; TGraph::SetPointvirtual void SetPoint(Int_t i, Double_t x, Double_t y)Set x and y values for point number i.Definition TGraph.cxx:2342; TGraph::fMaxSizeInt_t fMaxSize!Current dimension of arrays fX and fYDefinition TGraph.h:45; TGraph::SaveHistogramAndFunctionsvoid SaveHistogramAndFunctions(std::ostream ",MatchSource.WIKI,doc/master/TGraphBentErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html
https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html:31079,Availability,error,error,31079,"errorsDefinition TGraphBentErrors.h:30; TGraphBentErrors::fEYhighdDouble_t * fEYhighd[fNpoints] array of Y high displacementsDefinition TGraphBentErrors.h:36; TGraphBentErrors::CopyAndReleasevoid CopyAndRelease(Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy and release.Definition TGraphBentErrors.cxx:278; TGraphBentErrors::SwapPointsvoid SwapPoints(Int_t pos1, Int_t pos2) overrideSwap points.Definition TGraphBentErrors.cxx:646; TGraphBentErrors::CopyPointsBool_t CopyPoints(Double_t **arrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy errors from fE***to arrays[***] or to f*** Copy points.Definition TGraphBentErrors.cxx:312; TGraphBentErrors::GetErrorYlowDouble_t GetErrorYlow(Int_t bin) const overrideGet low error on Y[i].Definition TGraphBentErrors.cxx:463; TGraphBentErrors::GetErrorXDouble_t GetErrorX(Int_t bin) const overrideIt returns the error along X at point i.Definition TGraphBentErrors.cxx:402; TGraphBentErrors::GetErrorYhighDouble_t GetErrorYhigh(Int_t bin) const overrideGet high error on Y[i].Definition TGraphBentErrors.cxx:452; TGraphBentErrors::Applyvoid Apply(TF1 *f) overrideApply a function to all data points .Definition TGraphBentErrors.cxx:210; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; TGraph::Classstatic TClass * Class(); TGraph::AddPointvirtual void AddPoint(Double_t x, Double_t y)Append a new point to the graph.Definition TGraph.h:98; TGraph::fNpointsInt_t fNpointsNumber of points <= fMaxSize.Definition TGraph.h:46; TGraph::SetPointvirtual void SetPoint(Int_t i, Double_t x, Double_t y)Set x and y values for point number i.Definition TGraph.cxx:2342; TGraph::fMaxSizeInt_t fMaxSize!Current dimension of arrays fX and fYDefinition TGraph.h:45; TGraph::SaveHistogramAndFunctionsvoid SaveHistogramAndFunctions(std::ostream &out, const char *varname, Int_t &frameNumber, Option_t *option)Save histogram and list of functions of TGraph as C++ statement Used in all TGra",MatchSource.WIKI,doc/master/TGraphBentErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html
https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html:34302,Availability,error,error,34302,"form the merge operation of a graphDefinition TGraph.cxx:2676; TGraph::SwapPointsvirtual void SwapPoints(Int_t pos1, Int_t pos2)Swap points.Definition TGraph.cxx:2583; TGraph::FillZerovirtual void FillZero(Int_t begin, Int_t end, Bool_t from_ctor=kTRUE)Set zero values for point arrays in the range [begin, end) Should be redefined in descendant classes.Definition TGraph.cxx:1102; TGraph::fXDouble_t * fX[fNpoints] array of X pointsDefinition TGraph.h:47; TGraph::GetPointvirtual Int_t GetPoint(Int_t i, Double_t &x, Double_t &y) constGet x and y values for point number i.Definition TGraph.cxx:1533; TGraph::CopyPointsvirtual Bool_t CopyPoints(Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin)Copy points from fX and fY to arrays[0] and arrays[1] or to fX and fY if arrays == 0 and ibegin !...Definition TGraph.cxx:779; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TStringBasic string class.Definition TString.h:139; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; bool; double; int; yDouble_t y[n]Definition legend1.C:17; c1return c1Definition legend1.C:41; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; grTGraphErrors * grDefinition legend1.C:25; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662; TMath::MinShort_t Min(Short_t a, Short_t b)Returns the smallest of a and b.Definition TMathBase.h:198; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123. histhistsrcTGraphBentErrors.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:33 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TGraphBentErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html
https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html:9129,Deployability,release,release,9129,"bars is reversed; 230 if (f->Eval(x,y-eyl) < f->Eval(x,y+eyh)) {; 231 eyl_new = TMath::Abs(fxy - f->Eval(x,y-eyl));; 232 eyh_new = TMath::Abs(f->Eval(x,y+eyh) - fxy);; 233 } else {; 234 eyh_new = TMath::Abs(fxy - f->Eval(x,y-eyl));; 235 eyl_new = TMath::Abs(f->Eval(x,y+eyh) - fxy);; 236 }; 237 ; 238 //error on x doesn't change; 239 SetPointError(i,exl,exh,eyl_new,eyh_new);; 240 }; 241 if (gPad) gPad->Modified();; 242}; 243 ; 244 ; 245////////////////////////////////////////////////////////////////////////////////; 246/// Compute range.; 247 ; 248void TGraphBentErrors::ComputeRange(Double_t &xmin, Double_t &ymin, Double_t &xmax, Double_t &ymax) const; 249{; 250 TGraph::ComputeRange(xmin,ymin,xmax,ymax);; 251 ; 252 for (Int_t i=0;i<fNpoints;i++) {; 253 if (fX[i] -fEXlow[i] < xmin) {; 254 if (gPad && gPad->GetLogx()) {; 255 if (fEXlow[i] < fX[i]) xmin = fX[i]-fEXlow[i];; 256 else xmin = TMath::Min(xmin,fX[i]/3);; 257 } else {; 258 xmin = fX[i]-fEXlow[i];; 259 }; 260 }; 261 if (fX[i] +fEXhigh[i] > xmax) xmax = fX[i]+fEXhigh[i];; 262 if (fY[i] -fEYlow[i] < ymin) {; 263 if (gPad && gPad->GetLogy()) {; 264 if (fEYlow[i] < fY[i]) ymin = fY[i]-fEYlow[i];; 265 else ymin = TMath::Min(ymin,fY[i]/3);; 266 } else {; 267 ymin = fY[i]-fEYlow[i];; 268 }; 269 }; 270 if (fY[i] +fEYhigh[i] > ymax) ymax = fY[i]+fEYhigh[i];; 271 }; 272}; 273 ; 274 ; 275////////////////////////////////////////////////////////////////////////////////; 276/// Copy and release.; 277 ; 278void TGraphBentErrors::CopyAndRelease(Double_t **newarrays,; 279 Int_t ibegin, Int_t iend, Int_t obegin); 280{; 281 CopyPoints(newarrays, ibegin, iend, obegin);; 282 if (newarrays) {; 283 delete[] fEXlow;; 284 fEXlow = newarrays[0];; 285 delete[] fEXhigh;; 286 fEXhigh = newarrays[1];; 287 delete[] fEYlow;; 288 fEYlow = newarrays[2];; 289 delete[] fEYhigh;; 290 fEYhigh = newarrays[3];; 291 delete[] fEXlowd;; 292 fEXlowd = newarrays[4];; 293 delete[] fEXhighd;; 294 fEXhighd = newarrays[5];; 295 delete[] fEYlowd;; 296 fEYlowd =",MatchSource.WIKI,doc/master/TGraphBentErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html
https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html:30327,Deployability,release,release,30327,""") const overridePrint graph and errors values.Definition TGraphBentErrors.cxx:495; TGraphBentErrors::Scalevoid Scale(Double_t c1=1., Option_t *option=""y"") overrideMultiply the values and errors of a TGraphBentErrors by a constant c1.Definition TGraphBentErrors.cxx:510; TGraphBentErrors::FillZerovoid FillZero(Int_t begin, Int_t end, Bool_t from_ctor=kTRUE) overrideSet zero values for point arrays in the range [begin, end]Definition TGraphBentErrors.cxx:474; TGraphBentErrors::GetEXlowdDouble_t * GetEXlowd() const overrideDefinition TGraphBentErrors.h:84; TGraphBentErrors::GetErrorYDouble_t GetErrorY(Int_t bin) const overrideIt returns the error along Y at point i.Definition TGraphBentErrors.cxx:416; TGraphBentErrors::fEYlowDouble_t * fEYlow[fNpoints] array of Y low errorsDefinition TGraphBentErrors.h:30; TGraphBentErrors::fEYhighdDouble_t * fEYhighd[fNpoints] array of Y high displacementsDefinition TGraphBentErrors.h:36; TGraphBentErrors::CopyAndReleasevoid CopyAndRelease(Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy and release.Definition TGraphBentErrors.cxx:278; TGraphBentErrors::SwapPointsvoid SwapPoints(Int_t pos1, Int_t pos2) overrideSwap points.Definition TGraphBentErrors.cxx:646; TGraphBentErrors::CopyPointsBool_t CopyPoints(Double_t **arrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy errors from fE***to arrays[***] or to f*** Copy points.Definition TGraphBentErrors.cxx:312; TGraphBentErrors::GetErrorYlowDouble_t GetErrorYlow(Int_t bin) const overrideGet low error on Y[i].Definition TGraphBentErrors.cxx:463; TGraphBentErrors::GetErrorXDouble_t GetErrorX(Int_t bin) const overrideIt returns the error along X at point i.Definition TGraphBentErrors.cxx:402; TGraphBentErrors::GetErrorYhighDouble_t GetErrorYhigh(Int_t bin) const overrideGet high error on Y[i].Definition TGraphBentErrors.cxx:452; TGraphBentErrors::Applyvoid Apply(TF1 *f) overrideApply a function to all data points .Definition TGraphBentErrors.cxx:210; TGraphA T",MatchSource.WIKI,doc/master/TGraphBentErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html
https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html:20959,Energy Efficiency,allocate,allocate,20959," to one point); 601 for (Int_t i = 0; i < fNpoints; i++) {; 602 Int_t dpx = px - gPad->XtoAbsPixel(gPad->XtoPad(fX[i]));; 603 Int_t dpy = py - gPad->YtoAbsPixel(gPad->YtoPad(fY[i]));; 604 if (dpx*dpx+dpy*dpy < 25) {ipoint = i; break;}; 605 }; 606 if (ipoint == -2) return;; 607 ; 608 fEXlow[ipoint] = exl;; 609 fEYlow[ipoint] = eyl;; 610 fEXhigh[ipoint] = exh;; 611 fEYhigh[ipoint] = eyh;; 612 fEXlowd[ipoint] = exld;; 613 fEXhighd[ipoint] = exhd;; 614 fEYlowd[ipoint] = eyld;; 615 fEYhighd[ipoint] = eyhd;; 616 ; 617 gPad->Modified();; 618}; 619 ; 620 ; 621////////////////////////////////////////////////////////////////////////////////; 622/// Set ex and ey values for point number `i`.; 623 ; 624void TGraphBentErrors::SetPointError(Int_t i, Double_t exl, Double_t exh, Double_t eyl, Double_t eyh,; 625 Double_t exld, Double_t exhd, Double_t eyld, Double_t eyhd); 626{; 627 if (i < 0) return;; 628 if (i >= fNpoints) {; 629 // re-allocate the object; 630 TGraphBentErrors::SetPoint(i,0,0);; 631 }; 632 fEXlow[i] = exl;; 633 fEYlow[i] = eyl;; 634 fEXhigh[i] = exh;; 635 fEYhigh[i] = eyh;; 636 fEXlowd[i] = exld;; 637 fEXhighd[i] = exhd;; 638 fEYlowd[i] = eyld;; 639 fEYhighd[i] = eyhd;; 640}; 641 ; 642 ; 643////////////////////////////////////////////////////////////////////////////////; 644/// Swap points.; 645 ; 646void TGraphBentErrors::SwapPoints(Int_t pos1, Int_t pos2); 647{; 648 SwapValues(fEXlow, pos1, pos2);; 649 SwapValues(fEXhigh, pos1, pos2);; 650 SwapValues(fEYlow, pos1, pos2);; 651 SwapValues(fEYhigh, pos1, pos2);; 652 ; 653 SwapValues(fEXlowd, pos1, pos2);; 654 SwapValues(fEXhighd, pos1, pos2);; 655 SwapValues(fEYlowd, pos1, pos2);; 656 SwapValues(fEYhighd, pos1, pos2);; 657 ; 658 TGraph::SwapPoints(pos1, pos2);; 659}; 660 ; 661////////////////////////////////////////////////////////////////////////////////; 662/// Update the fX, fY, fEXlow, fEXhigh, fEXlowd, fEXhighd, fEYlow, fEYhigh, fEYlowd, ; 663/// and fEYhighd arrays with the sorted values.; 664 ; 665void TGraphB",MatchSource.WIKI,doc/master/TGraphBentErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html
https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html:34178,Integrability,message,message,34178,"::DoMergevirtual Bool_t DoMerge(const TGraph *g)protected function to perform the merge operation of a graphDefinition TGraph.cxx:2676; TGraph::SwapPointsvirtual void SwapPoints(Int_t pos1, Int_t pos2)Swap points.Definition TGraph.cxx:2583; TGraph::FillZerovirtual void FillZero(Int_t begin, Int_t end, Bool_t from_ctor=kTRUE)Set zero values for point arrays in the range [begin, end) Should be redefined in descendant classes.Definition TGraph.cxx:1102; TGraph::fXDouble_t * fX[fNpoints] array of X pointsDefinition TGraph.h:47; TGraph::GetPointvirtual Int_t GetPoint(Int_t i, Double_t &x, Double_t &y) constGet x and y values for point number i.Definition TGraph.cxx:1533; TGraph::CopyPointsvirtual Bool_t CopyPoints(Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin)Copy points from fX and fY to arrays[0] and arrays[1] or to fX and fY if arrays == 0 and ibegin !...Definition TGraph.cxx:779; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TStringBasic string class.Definition TString.h:139; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; bool; double; int; yDouble_t y[n]Definition legend1.C:17; c1return c1Definition legend1.C:41; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; grTGraphErrors * grDefinition legend1.C:25; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662; TMath::MinShort_t Min(Short_t a, Short_t b)Returns the smallest of a and b.Definition TMathBase.h:198; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123. histhistsrcTGraphBentErrors.cxx. ROOT master - Reference Guide Ge",MatchSource.WIKI,doc/master/TGraphBentErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html
https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html:34308,Integrability,message,message,34308,"form the merge operation of a graphDefinition TGraph.cxx:2676; TGraph::SwapPointsvirtual void SwapPoints(Int_t pos1, Int_t pos2)Swap points.Definition TGraph.cxx:2583; TGraph::FillZerovirtual void FillZero(Int_t begin, Int_t end, Bool_t from_ctor=kTRUE)Set zero values for point arrays in the range [begin, end) Should be redefined in descendant classes.Definition TGraph.cxx:1102; TGraph::fXDouble_t * fX[fNpoints] array of X pointsDefinition TGraph.h:47; TGraph::GetPointvirtual Int_t GetPoint(Int_t i, Double_t &x, Double_t &y) constGet x and y values for point number i.Definition TGraph.cxx:1533; TGraph::CopyPointsvirtual Bool_t CopyPoints(Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin)Copy points from fX and fY to arrays[0] and arrays[1] or to fX and fY if arrays == 0 and ibegin !...Definition TGraph.cxx:779; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TStringBasic string class.Definition TString.h:139; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; bool; double; int; yDouble_t y[n]Definition legend1.C:17; c1return c1Definition legend1.C:41; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; grTGraphErrors * grDefinition legend1.C:25; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662; TMath::MinShort_t Min(Short_t a, Short_t b)Returns the smallest of a and b.Definition TMathBase.h:198; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123. histhistsrcTGraphBentErrors.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:33 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TGraphBentErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html
https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html:1129,Performance,perform,performed,1129,"ches. TGraphBentErrors.cxx. Go to the documentation of this file. 1// @(#)root/hist:$Id$; 2// Author: Dave Morrison 30/06/2003; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2003, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#include <cstring>; 13#include <iostream>; 14 ; 15#include ""TROOT.h""; 16#include ""TGraphBentErrors.h""; 17#include ""TMath.h""; 18#include ""TVirtualPad.h""; 19#include ""TH1.h""; 20#include ""TF1.h""; 21 ; 22ClassImp(TGraphBentErrors);; 23 ; 24 ; 25////////////////////////////////////////////////////////////////////////////////; 26 ; 27/** \class TGraphBentErrors; 28 \ingroup Graphs; 29A TGraphBentErrors is a TGraph with bent, asymmetric error bars.; 30 ; 31The TGraphBentErrors painting is performed thanks to the TGraphPainter; 32class. All details about the various painting options are given in this class.; 33 ; 34The picture below gives an example:; 35Begin_Macro(source); 36{; 37 auto c1 = new TCanvas(""c1"",""A Simple Graph with bent error bars"",200,10,700,500);; 38 const Int_t n = 10;; 39 Double_t x[n] = {-0.22, 0.05, 0.25, 0.35, 0.5, 0.61,0.7,0.85,0.89,0.95};; 40 Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; 41 Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; 42 Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; 43 Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; 44 Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.4,.5,.6};; 45 Double_t exld[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; 46 Double_t eyld[n] = {.0,.0,.05,.0,.0,.0,.0,.0,.0,.0};; 47 Double_t exhd[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; 48 Double_t eyhd[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.05,.0};; 49 auto gr = new TGraphBentErrors(n,x,y,exl,exh,eyl,eyh,exld,exhd,eyld,eyhd);; 50 gr->SetTitle(""TGrap",MatchSource.WIKI,doc/master/TGraphBentErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html
https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html:12102,Performance,perform,perform,12102,"], &fEXlow[ibegin], n);; 328 memmove(&fEXhigh[obegin], &fEXhigh[ibegin], n);; 329 memmove(&fEYlow[obegin], &fEYlow[ibegin], n);; 330 memmove(&fEYhigh[obegin], &fEYhigh[ibegin], n);; 331 memmove(&fEXlowd[obegin], &fEXlowd[ibegin], n);; 332 memmove(&fEXhighd[obegin], &fEXhighd[ibegin], n);; 333 memmove(&fEYlowd[obegin], &fEYlowd[ibegin], n);; 334 memmove(&fEYhighd[obegin], &fEYhighd[ibegin], n);; 335 }; 336 return kTRUE;; 337 } else {; 338 return kFALSE;; 339 }; 340}; 341 ; 342 ; 343////////////////////////////////////////////////////////////////////////////////; 344/// Should be called from ctors after `fNpoints` has been set.; 345 ; 346Bool_t TGraphBentErrors::CtorAllocate(); 347{; 348 if (!fNpoints) {; 349 fEXlow = fEYlow = fEXhigh = fEYhigh = nullptr;; 350 fEXlowd = fEYlowd = fEXhighd = fEYhighd = nullptr;; 351 return kFALSE;; 352 }; 353 fEXlow = new Double_t[fMaxSize];; 354 fEYlow = new Double_t[fMaxSize];; 355 fEXhigh = new Double_t[fMaxSize];; 356 fEYhigh = new Double_t[fMaxSize];; 357 fEXlowd = new Double_t[fMaxSize];; 358 fEYlowd = new Double_t[fMaxSize];; 359 fEXhighd = new Double_t[fMaxSize];; 360 fEYhighd = new Double_t[fMaxSize];; 361 return kTRUE;; 362}; 363 ; 364////////////////////////////////////////////////////////////////////////////////; 365/// Protected function to perform the merge operation of a graph with asymmetric errors.; 366 ; 367Bool_t TGraphBentErrors::DoMerge(const TGraph *g); 368{; 369 if (g->GetN() == 0) return kFALSE;; 370 ; 371 Double_t *exl = g->GetEXlow();; 372 Double_t *exh = g->GetEXhigh();; 373 Double_t *eyl = g->GetEYlow();; 374 Double_t *eyh = g->GetEYhigh();; 375 ; 376 Double_t *exld = g->GetEXlowd();; 377 Double_t *exhd = g->GetEXhighd();; 378 Double_t *eyld = g->GetEYlowd();; 379 Double_t *eyhd = g->GetEYhighd();; 380 ; 381 if (!exl || !exh || !eyl || !eyh ||; 382 !exld || !exhd || !eyld || !eyhd) {; 383 if (g->IsA() != TGraph::Class() ); 384 Warning(""DoMerge"", ""Merging a %s is not compatible with a TGraphBentErrors - error",MatchSource.WIKI,doc/master/TGraphBentErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html
https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html:26996,Performance,perform,perform,26996,"ion TGraphBentErrors.cxx:665; TGraphBentErrors::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave primitive as a C++ statement(s) on output stream out.Definition TGraphBentErrors.cxx:551; TGraphBentErrors::TGraphBentErrorsTGraphBentErrors()TGraphBentErrors default constructor.Definition TGraphBentErrors.cxx:62; TGraphBentErrors::GetEXlowDouble_t * GetEXlow() const overrideDefinition TGraphBentErrors.h:80; TGraphBentErrors::fEYhighDouble_t * fEYhigh[fNpoints] array of Y high errorsDefinition TGraphBentErrors.h:31; TGraphBentErrors::fEXlowdDouble_t * fEXlowd[fNpoints] array of X low displacementsDefinition TGraphBentErrors.h:33; TGraphBentErrors::fEYlowdDouble_t * fEYlowd[fNpoints] array of Y low displacementsDefinition TGraphBentErrors.h:35; TGraphBentErrors::CtorAllocateBool_t CtorAllocate()Should be called from ctors after fNpoints has been set.Definition TGraphBentErrors.cxx:346; TGraphBentErrors::DoMergeBool_t DoMerge(const TGraph *g) overrideProtected function to perform the merge operation of a graph with asymmetric errors.Definition TGraphBentErrors.cxx:367; TGraphBentErrors::GetEYhighDouble_t * GetEYhigh() const overrideDefinition TGraphBentErrors.h:83; TGraphBentErrors::GetErrorXlowDouble_t GetErrorXlow(Int_t bin) const overrideGet low error on X[i].Definition TGraphBentErrors.cxx:441; TGraphBentErrors::GetEYlowDouble_t * GetEYlow() const overrideDefinition TGraphBentErrors.h:82; TGraphBentErrors::GetEYhighdDouble_t * GetEYhighd() const overrideDefinition TGraphBentErrors.h:87; TGraphBentErrors::ComputeRangevoid ComputeRange(Double_t &xmin, Double_t &ymin, Double_t &xmax, Double_t &ymax) const overrideCompute range.Definition TGraphBentErrors.cxx:248; TGraphBentErrors::GetEXhighDouble_t * GetEXhigh() const overrideDefinition TGraphBentErrors.h:81; TGraphBentErrors::Classstatic TClass * Class(); TGraphBentErrors::GetEYlowdDouble_t * GetEYlowd() const overrideDefinition TGraphBentErrors.h:86; TGraphBentErrors::fEXhighdDouble_",MatchSource.WIKI,doc/master/TGraphBentErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html
https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html:33241,Performance,perform,perform,33241,"Arrays(const std::vector< Int_t > &sorting_indices, Int_t numSortedPoints, Int_t low)Update the fX and fY arrays with the sorted values.Definition TGraph.cxx:2592; TGraph::GetNInt_t GetN() constDefinition TGraph.h:132; TGraph::fYDouble_t * fY[fNpoints] array of Y pointsDefinition TGraph.h:48; TGraph::SaveArrayTString SaveArray(std::ostream &out, const char *suffix, Int_t frameNumber, Double_t *arr)Save array as C++ code Returns name of created array.Definition TGraph.cxx:2175; TGraph::ComputeRangevirtual void ComputeRange(Double_t &xmin, Double_t &ymin, Double_t &xmax, Double_t &ymax) constCompute the x/y range of the points in this graph.Definition TGraph.cxx:731; TGraph::Scalevirtual void Scale(Double_t c1=1., Option_t *option=""y"")Multiply the values of a TGraph by a constant c1.Definition TGraph.cxx:2259; TGraph::SwapValuesstatic void SwapValues(Double_t *arr, Int_t pos1, Int_t pos2)Swap values.Definition TGraph.cxx:2611; TGraph::DoMergevirtual Bool_t DoMerge(const TGraph *g)protected function to perform the merge operation of a graphDefinition TGraph.cxx:2676; TGraph::SwapPointsvirtual void SwapPoints(Int_t pos1, Int_t pos2)Swap points.Definition TGraph.cxx:2583; TGraph::FillZerovirtual void FillZero(Int_t begin, Int_t end, Bool_t from_ctor=kTRUE)Set zero values for point arrays in the range [begin, end) Should be redefined in descendant classes.Definition TGraph.cxx:1102; TGraph::fXDouble_t * fX[fNpoints] array of X pointsDefinition TGraph.h:47; TGraph::GetPointvirtual Int_t GetPoint(Int_t i, Double_t &x, Double_t &y) constGet x and y values for point number i.Definition TGraph.cxx:1533; TGraph::CopyPointsvirtual Bool_t CopyPoints(Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin)Copy points from fX and fY to arrays[0] and arrays[1] or to fX and fY if arrays == 0 and ibegin !...Definition TGraph.cxx:779; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Err",MatchSource.WIKI,doc/master/TGraphBentErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html
https://root.cern/doc/master/TGraphBentErrors_8h_source.html:864,Availability,error,error,864,". ROOT: hist/hist/inc/TGraphBentErrors.h Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TGraphBentErrors.h. Go to the documentation of this file. 1// @(#)root/hist:$Id$; 2// Author: Dave Morrison 30/06/2003; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#ifndef ROOT_TGraphBentErrors; 13#define ROOT_TGraphBentErrors; 14 ; 15//////////////////////////////////////////////////////////////////////////; 16// //; 17// TGraphBentErrors //; 18// //; 19// a Graph with bent, asymmetric error bars //; 20// //; 21//////////////////////////////////////////////////////////////////////////; 22 ; 23#include ""TGraph.h""; 24 ; 25class TGraphBentErrors : public TGraph {; 26 ; 27protected:; 28 Double_t *fEXlow; ///<[fNpoints] array of X low errors; 29 Double_t *fEXhigh; ///<[fNpoints] array of X high errors; 30 Double_t *fEYlow; ///<[fNpoints] array of Y low errors; 31 Double_t *fEYhigh; ///<[fNpoints] array of Y high errors; 32 ; 33 Double_t *fEXlowd; ///<[fNpoints] array of X low displacements; 34 Double_t *fEXhighd; ///<[fNpoints] array of X high displacements; 35 Double_t *fEYlowd; ///<[fNpoints] array of Y low displacements; 36 Double_t *fEYhighd; ///<[fNpoints] array of Y high displacements; 37 ; 38 void SwapPoints(Int_t pos1, Int_t pos2) override;; 39 void UpdateArrays(const std::vector<Int_t> &sorting_indices, Int_t numSortedPoints, Int_t low) override;; 40 ; 41 Double_t** Allocate(Int_t size) override;; 42 void CopyAndRelease(Double_t **newarrays,; 43 Int_t ibegin, Int_t iend, Int_t obegin) override;; 44 Bool_t CopyPoints(Double_t **arrays, Int_t ibegin, Int_t iend,; 45 Int_t obegin) override;; 46 Bool_",MatchSource.WIKI,doc/master/TGraphBentErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphBentErrors_8h_source.html
https://root.cern/doc/master/TGraphBentErrors_8h_source.html:1113,Availability,error,errors,1113,"h""; 24 ; 25class TGraphBentErrors : public TGraph {; 26 ; 27protected:; 28 Double_t *fEXlow; ///<[fNpoints] array of X low errors; 29 Double_t *fEXhigh; ///<[fNpoints] array of X high errors; 30 Double_t *fEYlow; ///<[fNpoints] array of Y low errors; 31 Double_t *fEYhigh; ///<[fNpoints] array of Y high errors; 32 ; 33 Double_t *fEXlowd; ///<[fNpoints] array of X low displacements; 34 Double_t *fEXhighd; ///<[fNpoints] array of X high displacements; 35 Double_t *fEYlowd; ///<[fNpoints] array of Y low displacements; 36 Double_t *fEYhighd; ///<[fNpoints] array of Y high displacements; 37 ; 38 void SwapPoints(Int_t pos1, Int_t pos2) override;; 39 void UpdateArrays(const std::vector<Int_t> &sorting_indices, Int_t numSortedPoints, Int_t low) override;; 40 ; 41 Double_t** Allocate(Int_t size) override;; 42 void CopyAndRelease(Double_t **newarrays,; 43 Int_t ibegin, Int_t iend, Int_t obegin) override;; 44 Bool_t CopyPoints(Double_t **arrays, Int_t ibegin, Int_t iend,; 45 Int_t obegin) override;; 46 Bool_",MatchSource.WIKI,doc/master/TGraphBentErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphBentErrors_8h_source.html
https://root.cern/doc/master/TGraphBentErrors_8h_source.html:1174,Availability,error,errors,1174,"h""; 24 ; 25class TGraphBentErrors : public TGraph {; 26 ; 27protected:; 28 Double_t *fEXlow; ///<[fNpoints] array of X low errors; 29 Double_t *fEXhigh; ///<[fNpoints] array of X high errors; 30 Double_t *fEYlow; ///<[fNpoints] array of Y low errors; 31 Double_t *fEYhigh; ///<[fNpoints] array of Y high errors; 32 ; 33 Double_t *fEXlowd; ///<[fNpoints] array of X low displacements; 34 Double_t *fEXhighd; ///<[fNpoints] array of X high displacements; 35 Double_t *fEYlowd; ///<[fNpoints] array of Y low displacements; 36 Double_t *fEYhighd; ///<[fNpoints] array of Y high displacements; 37 ; 38 void SwapPoints(Int_t pos1, Int_t pos2) override;; 39 void UpdateArrays(const std::vector<Int_t> &sorting_indices, Int_t numSortedPoints, Int_t low) override;; 40 ; 41 Double_t** Allocate(Int_t size) override;; 42 void CopyAndRelease(Double_t **newarrays,; 43 Int_t ibegin, Int_t iend, Int_t obegin) override;; 44 Bool_t CopyPoints(Double_t **arrays, Int_t ibegin, Int_t iend,; 45 Int_t obegin) override;; 46 Bool_",MatchSource.WIKI,doc/master/TGraphBentErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphBentErrors_8h_source.html
https://root.cern/doc/master/TGraphBentErrors_8h_source.html:1233,Availability,error,errors,1233,"h""; 24 ; 25class TGraphBentErrors : public TGraph {; 26 ; 27protected:; 28 Double_t *fEXlow; ///<[fNpoints] array of X low errors; 29 Double_t *fEXhigh; ///<[fNpoints] array of X high errors; 30 Double_t *fEYlow; ///<[fNpoints] array of Y low errors; 31 Double_t *fEYhigh; ///<[fNpoints] array of Y high errors; 32 ; 33 Double_t *fEXlowd; ///<[fNpoints] array of X low displacements; 34 Double_t *fEXhighd; ///<[fNpoints] array of X high displacements; 35 Double_t *fEYlowd; ///<[fNpoints] array of Y low displacements; 36 Double_t *fEYhighd; ///<[fNpoints] array of Y high displacements; 37 ; 38 void SwapPoints(Int_t pos1, Int_t pos2) override;; 39 void UpdateArrays(const std::vector<Int_t> &sorting_indices, Int_t numSortedPoints, Int_t low) override;; 40 ; 41 Double_t** Allocate(Int_t size) override;; 42 void CopyAndRelease(Double_t **newarrays,; 43 Int_t ibegin, Int_t iend, Int_t obegin) override;; 44 Bool_t CopyPoints(Double_t **arrays, Int_t ibegin, Int_t iend,; 45 Int_t obegin) override;; 46 Bool_",MatchSource.WIKI,doc/master/TGraphBentErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphBentErrors_8h_source.html
https://root.cern/doc/master/TGraphBentErrors_8h_source.html:1294,Availability,error,errors,1294,"h""; 24 ; 25class TGraphBentErrors : public TGraph {; 26 ; 27protected:; 28 Double_t *fEXlow; ///<[fNpoints] array of X low errors; 29 Double_t *fEXhigh; ///<[fNpoints] array of X high errors; 30 Double_t *fEYlow; ///<[fNpoints] array of Y low errors; 31 Double_t *fEYhigh; ///<[fNpoints] array of Y high errors; 32 ; 33 Double_t *fEXlowd; ///<[fNpoints] array of X low displacements; 34 Double_t *fEXhighd; ///<[fNpoints] array of X high displacements; 35 Double_t *fEYlowd; ///<[fNpoints] array of Y low displacements; 36 Double_t *fEYhighd; ///<[fNpoints] array of Y high displacements; 37 ; 38 void SwapPoints(Int_t pos1, Int_t pos2) override;; 39 void UpdateArrays(const std::vector<Int_t> &sorting_indices, Int_t numSortedPoints, Int_t low) override;; 40 ; 41 Double_t** Allocate(Int_t size) override;; 42 void CopyAndRelease(Double_t **newarrays,; 43 Int_t ibegin, Int_t iend, Int_t obegin) override;; 44 Bool_t CopyPoints(Double_t **arrays, Int_t ibegin, Int_t iend,; 45 Int_t obegin) override;; 46 Bool_",MatchSource.WIKI,doc/master/TGraphBentErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphBentErrors_8h_source.html
https://root.cern/doc/master/TGraphBentErrors_8h_source.html:4703,Availability,error,error,4703,"GetErrorYhigh(Int_t bin) const override;; 80 Double_t *GetEXlow() const override {return fEXlow;}; 81 Double_t *GetEXhigh() const override {return fEXhigh;}; 82 Double_t *GetEYlow() const override {return fEYlow;}; 83 Double_t *GetEYhigh() const override {return fEYhigh;}; 84 Double_t *GetEXlowd() const override {return fEXlowd;}; 85 Double_t *GetEXhighd() const override {return fEXhighd;}; 86 Double_t *GetEYlowd() const override {return fEYlowd;}; 87 Double_t *GetEYhighd() const override {return fEYhighd;}; 88 void Print(Option_t *chopt="""") const override;; 89 void SavePrimitive(std::ostream &out, Option_t *option = """") override;; 90 void Scale(Double_t c1=1., Option_t *option=""y"") override; // *MENU*; 91 virtual void SetPointError(Double_t exl, Double_t exh,; 92 Double_t eyl, Double_t eyh,; 93 Double_t exld=0, Double_t exhd=0,; 94 Double_t eyld=0, Double_t eyhd=0); // *MENU*; 95 virtual void SetPointError(Int_t i,; 96 Double_t exl, Double_t exh,; 97 Double_t eyl, Double_t eyh,; 98 Double_t exld=0, Double_t exhd=0,; 99 Double_t eyld=0, Double_t eyhd=0);; 100 ; 101 ClassDefOverride(TGraphBentErrors,1) //A graph with bent, asymmetric error bars; 102};; 103 ; 104inline Double_t **TGraphBentErrors::Allocate(Int_t size) {; 105 return AllocateArrays(10, size);; 106}; 107 ; 108#endif; f#define f(i)Definition RSha256.hxx:104; g#define g(i)Definition RSha256.hxx:105; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; Int_tint Int_tDefinition RtypesCore.h:45; Float_tfloat Float_tDefinition RtypesCore.h:57; Double_tdouble Double_tDefinition RtypesCore.h:59; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; Option_tconst char Option_tDefinition RtypesCore.h:66; ClassDefOverride#define ClassDefOverride(name, id)Definition Rtypes.h:346; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; TGraph.h; xminfloat xminDefinition THbookFile.cxx:95; yminfloat yminDefinition THbookFile.cxx:95; xmaxfloat xmaxDefinition THbookFile.cxx:95; ymax",MatchSource.WIKI,doc/master/TGraphBentErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphBentErrors_8h_source.html
https://root.cern/doc/master/TGraphBentErrors_8h_source.html:5706,Availability,error,error,5706,"A graph with bent, asymmetric error bars; 102};; 103 ; 104inline Double_t **TGraphBentErrors::Allocate(Int_t size) {; 105 return AllocateArrays(10, size);; 106}; 107 ; 108#endif; f#define f(i)Definition RSha256.hxx:104; g#define g(i)Definition RSha256.hxx:105; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; Int_tint Int_tDefinition RtypesCore.h:45; Float_tfloat Float_tDefinition RtypesCore.h:57; Double_tdouble Double_tDefinition RtypesCore.h:59; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; Option_tconst char Option_tDefinition RtypesCore.h:66; ClassDefOverride#define ClassDefOverride(name, id)Definition Rtypes.h:346; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; TGraph.h; xminfloat xminDefinition THbookFile.cxx:95; yminfloat yminDefinition THbookFile.cxx:95; xmaxfloat xmaxDefinition THbookFile.cxx:95; ymaxfloat ymaxDefinition THbookFile.cxx:95; TF11-Dim function classDefinition TF1.h:233; TGraphBentErrorsA TGraphBentErrors is a TGraph with bent, asymmetric error bars.Definition TGraphBentErrors.h:25; TGraphBentErrors::UpdateArraysvoid UpdateArrays(const std::vector< Int_t > &sorting_indices, Int_t numSortedPoints, Int_t low) overrideUpdate the fX, fY, fEXlow, fEXhigh, fEXlowd, fEXhighd, fEYlow, fEYhigh, fEYlowd, and fEYhighd array...Definition TGraphBentErrors.cxx:665; TGraphBentErrors::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave primitive as a C++ statement(s) on output stream out.Definition TGraphBentErrors.cxx:551; TGraphBentErrors::TGraphBentErrorsTGraphBentErrors()TGraphBentErrors default constructor.Definition TGraphBentErrors.cxx:62; TGraphBentErrors::GetEXlowDouble_t * GetEXlow() const overrideDefinition TGraphBentErrors.h:80; TGraphBentErrors::fEYhighDouble_t * fEYhigh[fNpoints] array of Y high errorsDefinition TGraphBentErrors.h:31; TGraphBentErrors::fEXlowdDouble_t * fEXlowd[fNpoints] array of X low displacementsDefinition TGraphBentErrors.h:33; TGraphBen",MatchSource.WIKI,doc/master/TGraphBentErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphBentErrors_8h_source.html
https://root.cern/doc/master/TGraphBentErrors_8h_source.html:6509,Availability,error,errorsDefinition,6509,"ookFile.cxx:95; xmaxfloat xmaxDefinition THbookFile.cxx:95; ymaxfloat ymaxDefinition THbookFile.cxx:95; TF11-Dim function classDefinition TF1.h:233; TGraphBentErrorsA TGraphBentErrors is a TGraph with bent, asymmetric error bars.Definition TGraphBentErrors.h:25; TGraphBentErrors::UpdateArraysvoid UpdateArrays(const std::vector< Int_t > &sorting_indices, Int_t numSortedPoints, Int_t low) overrideUpdate the fX, fY, fEXlow, fEXhigh, fEXlowd, fEXhighd, fEYlow, fEYhigh, fEYlowd, and fEYhighd array...Definition TGraphBentErrors.cxx:665; TGraphBentErrors::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave primitive as a C++ statement(s) on output stream out.Definition TGraphBentErrors.cxx:551; TGraphBentErrors::TGraphBentErrorsTGraphBentErrors()TGraphBentErrors default constructor.Definition TGraphBentErrors.cxx:62; TGraphBentErrors::GetEXlowDouble_t * GetEXlow() const overrideDefinition TGraphBentErrors.h:80; TGraphBentErrors::fEYhighDouble_t * fEYhigh[fNpoints] array of Y high errorsDefinition TGraphBentErrors.h:31; TGraphBentErrors::fEXlowdDouble_t * fEXlowd[fNpoints] array of X low displacementsDefinition TGraphBentErrors.h:33; TGraphBentErrors::fEYlowdDouble_t * fEYlowd[fNpoints] array of Y low displacementsDefinition TGraphBentErrors.h:35; TGraphBentErrors::CtorAllocateBool_t CtorAllocate()Should be called from ctors after fNpoints has been set.Definition TGraphBentErrors.cxx:346; TGraphBentErrors::DoMergeBool_t DoMerge(const TGraph *g) overrideProtected function to perform the merge operation of a graph with asymmetric errors.Definition TGraphBentErrors.cxx:367; TGraphBentErrors::GetEYhighDouble_t * GetEYhigh() const overrideDefinition TGraphBentErrors.h:83; TGraphBentErrors::GetErrorXlowDouble_t GetErrorXlow(Int_t bin) const overrideGet low error on X[i].Definition TGraphBentErrors.cxx:441; TGraphBentErrors::GetEYlowDouble_t * GetEYlow() const overrideDefinition TGraphBentErrors.h:82; TGraphBentErrors::GetEYhighdDouble_t * GetEYhig",MatchSource.WIKI,doc/master/TGraphBentErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphBentErrors_8h_source.html
https://root.cern/doc/master/TGraphBentErrors_8h_source.html:7067,Availability,error,errors,7067,"ion TGraphBentErrors.cxx:665; TGraphBentErrors::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave primitive as a C++ statement(s) on output stream out.Definition TGraphBentErrors.cxx:551; TGraphBentErrors::TGraphBentErrorsTGraphBentErrors()TGraphBentErrors default constructor.Definition TGraphBentErrors.cxx:62; TGraphBentErrors::GetEXlowDouble_t * GetEXlow() const overrideDefinition TGraphBentErrors.h:80; TGraphBentErrors::fEYhighDouble_t * fEYhigh[fNpoints] array of Y high errorsDefinition TGraphBentErrors.h:31; TGraphBentErrors::fEXlowdDouble_t * fEXlowd[fNpoints] array of X low displacementsDefinition TGraphBentErrors.h:33; TGraphBentErrors::fEYlowdDouble_t * fEYlowd[fNpoints] array of Y low displacementsDefinition TGraphBentErrors.h:35; TGraphBentErrors::CtorAllocateBool_t CtorAllocate()Should be called from ctors after fNpoints has been set.Definition TGraphBentErrors.cxx:346; TGraphBentErrors::DoMergeBool_t DoMerge(const TGraph *g) overrideProtected function to perform the merge operation of a graph with asymmetric errors.Definition TGraphBentErrors.cxx:367; TGraphBentErrors::GetEYhighDouble_t * GetEYhigh() const overrideDefinition TGraphBentErrors.h:83; TGraphBentErrors::GetErrorXlowDouble_t GetErrorXlow(Int_t bin) const overrideGet low error on X[i].Definition TGraphBentErrors.cxx:441; TGraphBentErrors::GetEYlowDouble_t * GetEYlow() const overrideDefinition TGraphBentErrors.h:82; TGraphBentErrors::GetEYhighdDouble_t * GetEYhighd() const overrideDefinition TGraphBentErrors.h:87; TGraphBentErrors::ComputeRangevoid ComputeRange(Double_t &xmin, Double_t &ymin, Double_t &xmax, Double_t &ymax) const overrideCompute range.Definition TGraphBentErrors.cxx:248; TGraphBentErrors::GetEXhighDouble_t * GetEXhigh() const overrideDefinition TGraphBentErrors.h:81; TGraphBentErrors::GetEYlowdDouble_t * GetEYlowd() const overrideDefinition TGraphBentErrors.h:86; TGraphBentErrors::fEXhighdDouble_t * fEXhighd[fNpoints] array of X high displacem",MatchSource.WIKI,doc/master/TGraphBentErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphBentErrors_8h_source.html
https://root.cern/doc/master/TGraphBentErrors_8h_source.html:7294,Availability,error,error,7294,"aphBentErrors()TGraphBentErrors default constructor.Definition TGraphBentErrors.cxx:62; TGraphBentErrors::GetEXlowDouble_t * GetEXlow() const overrideDefinition TGraphBentErrors.h:80; TGraphBentErrors::fEYhighDouble_t * fEYhigh[fNpoints] array of Y high errorsDefinition TGraphBentErrors.h:31; TGraphBentErrors::fEXlowdDouble_t * fEXlowd[fNpoints] array of X low displacementsDefinition TGraphBentErrors.h:33; TGraphBentErrors::fEYlowdDouble_t * fEYlowd[fNpoints] array of Y low displacementsDefinition TGraphBentErrors.h:35; TGraphBentErrors::CtorAllocateBool_t CtorAllocate()Should be called from ctors after fNpoints has been set.Definition TGraphBentErrors.cxx:346; TGraphBentErrors::DoMergeBool_t DoMerge(const TGraph *g) overrideProtected function to perform the merge operation of a graph with asymmetric errors.Definition TGraphBentErrors.cxx:367; TGraphBentErrors::GetEYhighDouble_t * GetEYhigh() const overrideDefinition TGraphBentErrors.h:83; TGraphBentErrors::GetErrorXlowDouble_t GetErrorXlow(Int_t bin) const overrideGet low error on X[i].Definition TGraphBentErrors.cxx:441; TGraphBentErrors::GetEYlowDouble_t * GetEYlow() const overrideDefinition TGraphBentErrors.h:82; TGraphBentErrors::GetEYhighdDouble_t * GetEYhighd() const overrideDefinition TGraphBentErrors.h:87; TGraphBentErrors::ComputeRangevoid ComputeRange(Double_t &xmin, Double_t &ymin, Double_t &xmax, Double_t &ymax) const overrideCompute range.Definition TGraphBentErrors.cxx:248; TGraphBentErrors::GetEXhighDouble_t * GetEXhigh() const overrideDefinition TGraphBentErrors.h:81; TGraphBentErrors::GetEYlowdDouble_t * GetEYlowd() const overrideDefinition TGraphBentErrors.h:86; TGraphBentErrors::fEXhighdDouble_t * fEXhighd[fNpoints] array of X high displacementsDefinition TGraphBentErrors.h:34; TGraphBentErrors::GetEXhighdDouble_t * GetEXhighd() const overrideDefinition TGraphBentErrors.h:85; TGraphBentErrors::GetErrorXhighDouble_t GetErrorXhigh(Int_t bin) const overrideGet high error on X[i].Definition TGraphBent",MatchSource.WIKI,doc/master/TGraphBentErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphBentErrors_8h_source.html
https://root.cern/doc/master/TGraphBentErrors_8h_source.html:8221,Availability,error,error,8221,"tion TGraphBentErrors.h:83; TGraphBentErrors::GetErrorXlowDouble_t GetErrorXlow(Int_t bin) const overrideGet low error on X[i].Definition TGraphBentErrors.cxx:441; TGraphBentErrors::GetEYlowDouble_t * GetEYlow() const overrideDefinition TGraphBentErrors.h:82; TGraphBentErrors::GetEYhighdDouble_t * GetEYhighd() const overrideDefinition TGraphBentErrors.h:87; TGraphBentErrors::ComputeRangevoid ComputeRange(Double_t &xmin, Double_t &ymin, Double_t &xmax, Double_t &ymax) const overrideCompute range.Definition TGraphBentErrors.cxx:248; TGraphBentErrors::GetEXhighDouble_t * GetEXhigh() const overrideDefinition TGraphBentErrors.h:81; TGraphBentErrors::GetEYlowdDouble_t * GetEYlowd() const overrideDefinition TGraphBentErrors.h:86; TGraphBentErrors::fEXhighdDouble_t * fEXhighd[fNpoints] array of X high displacementsDefinition TGraphBentErrors.h:34; TGraphBentErrors::GetEXhighdDouble_t * GetEXhighd() const overrideDefinition TGraphBentErrors.h:85; TGraphBentErrors::GetErrorXhighDouble_t GetErrorXhigh(Int_t bin) const overrideGet high error on X[i].Definition TGraphBentErrors.cxx:430; TGraphBentErrors::AddPointErrorvirtual void AddPointError(Double_t x, Double_t y, Double_t exl, Double_t exh, Double_t eyl, Double_t eyh, Double_t exld=0, Double_t exhd=0, Double_t eyld=0, Double_t eyhd=0)Add a point with bent errors to the graph.Definition TGraphBentErrors.cxx:192; TGraphBentErrors::AllocateDouble_t ** Allocate(Int_t size) overrideAllocate internal data structures for newsize points.Definition TGraphBentErrors.h:104; TGraphBentErrors::SetPointErrorvirtual void SetPointError(Double_t exl, Double_t exh, Double_t eyl, Double_t eyh, Double_t exld=0, Double_t exhd=0, Double_t eyld=0, Double_t eyhd=0)Set ex and ey values for point pointed by the mouse.Definition TGraphBentErrors.cxx:587; TGraphBentErrors::fEXlowDouble_t * fEXlow[fNpoints] array of X low errorsDefinition TGraphBentErrors.h:28; TGraphBentErrors::fEXhighDouble_t * fEXhigh[fNpoints] array of X high errorsDefinition TGraph",MatchSource.WIKI,doc/master/TGraphBentErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphBentErrors_8h_source.html
https://root.cern/doc/master/TGraphBentErrors_8h_source.html:8499,Availability,error,errors,8499,") const overrideDefinition TGraphBentErrors.h:82; TGraphBentErrors::GetEYhighdDouble_t * GetEYhighd() const overrideDefinition TGraphBentErrors.h:87; TGraphBentErrors::ComputeRangevoid ComputeRange(Double_t &xmin, Double_t &ymin, Double_t &xmax, Double_t &ymax) const overrideCompute range.Definition TGraphBentErrors.cxx:248; TGraphBentErrors::GetEXhighDouble_t * GetEXhigh() const overrideDefinition TGraphBentErrors.h:81; TGraphBentErrors::GetEYlowdDouble_t * GetEYlowd() const overrideDefinition TGraphBentErrors.h:86; TGraphBentErrors::fEXhighdDouble_t * fEXhighd[fNpoints] array of X high displacementsDefinition TGraphBentErrors.h:34; TGraphBentErrors::GetEXhighdDouble_t * GetEXhighd() const overrideDefinition TGraphBentErrors.h:85; TGraphBentErrors::GetErrorXhighDouble_t GetErrorXhigh(Int_t bin) const overrideGet high error on X[i].Definition TGraphBentErrors.cxx:430; TGraphBentErrors::AddPointErrorvirtual void AddPointError(Double_t x, Double_t y, Double_t exl, Double_t exh, Double_t eyl, Double_t eyh, Double_t exld=0, Double_t exhd=0, Double_t eyld=0, Double_t eyhd=0)Add a point with bent errors to the graph.Definition TGraphBentErrors.cxx:192; TGraphBentErrors::AllocateDouble_t ** Allocate(Int_t size) overrideAllocate internal data structures for newsize points.Definition TGraphBentErrors.h:104; TGraphBentErrors::SetPointErrorvirtual void SetPointError(Double_t exl, Double_t exh, Double_t eyl, Double_t eyh, Double_t exld=0, Double_t exhd=0, Double_t eyld=0, Double_t eyhd=0)Set ex and ey values for point pointed by the mouse.Definition TGraphBentErrors.cxx:587; TGraphBentErrors::fEXlowDouble_t * fEXlow[fNpoints] array of X low errorsDefinition TGraphBentErrors.h:28; TGraphBentErrors::fEXhighDouble_t * fEXhigh[fNpoints] array of X high errorsDefinition TGraphBentErrors.h:29; TGraphBentErrors::~TGraphBentErrors~TGraphBentErrors() overrideTGraphBentErrors default destructor.Definition TGraphBentErrors.cxx:176; TGraphBentErrors::Printvoid Print(Option_t *chopt="""") con",MatchSource.WIKI,doc/master/TGraphBentErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphBentErrors_8h_source.html
https://root.cern/doc/master/TGraphBentErrors_8h_source.html:9048,Availability,error,errorsDefinition,9048,"h:34; TGraphBentErrors::GetEXhighdDouble_t * GetEXhighd() const overrideDefinition TGraphBentErrors.h:85; TGraphBentErrors::GetErrorXhighDouble_t GetErrorXhigh(Int_t bin) const overrideGet high error on X[i].Definition TGraphBentErrors.cxx:430; TGraphBentErrors::AddPointErrorvirtual void AddPointError(Double_t x, Double_t y, Double_t exl, Double_t exh, Double_t eyl, Double_t eyh, Double_t exld=0, Double_t exhd=0, Double_t eyld=0, Double_t eyhd=0)Add a point with bent errors to the graph.Definition TGraphBentErrors.cxx:192; TGraphBentErrors::AllocateDouble_t ** Allocate(Int_t size) overrideAllocate internal data structures for newsize points.Definition TGraphBentErrors.h:104; TGraphBentErrors::SetPointErrorvirtual void SetPointError(Double_t exl, Double_t exh, Double_t eyl, Double_t eyh, Double_t exld=0, Double_t exhd=0, Double_t eyld=0, Double_t eyhd=0)Set ex and ey values for point pointed by the mouse.Definition TGraphBentErrors.cxx:587; TGraphBentErrors::fEXlowDouble_t * fEXlow[fNpoints] array of X low errorsDefinition TGraphBentErrors.h:28; TGraphBentErrors::fEXhighDouble_t * fEXhigh[fNpoints] array of X high errorsDefinition TGraphBentErrors.h:29; TGraphBentErrors::~TGraphBentErrors~TGraphBentErrors() overrideTGraphBentErrors default destructor.Definition TGraphBentErrors.cxx:176; TGraphBentErrors::Printvoid Print(Option_t *chopt="""") const overridePrint graph and errors values.Definition TGraphBentErrors.cxx:495; TGraphBentErrors::Scalevoid Scale(Double_t c1=1., Option_t *option=""y"") overrideMultiply the values and errors of a TGraphBentErrors by a constant c1.Definition TGraphBentErrors.cxx:510; TGraphBentErrors::FillZerovoid FillZero(Int_t begin, Int_t end, Bool_t from_ctor=kTRUE) overrideSet zero values for point arrays in the range [begin, end]Definition TGraphBentErrors.cxx:474; TGraphBentErrors::GetEXlowdDouble_t * GetEXlowd() const overrideDefinition TGraphBentErrors.h:84; TGraphBentErrors::GetErrorYDouble_t GetErrorY(Int_t bin) const overrideIt returns ",MatchSource.WIKI,doc/master/TGraphBentErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphBentErrors_8h_source.html
https://root.cern/doc/master/TGraphBentErrors_8h_source.html:9158,Availability,error,errorsDefinition,9158,"phBentErrors::GetErrorXhighDouble_t GetErrorXhigh(Int_t bin) const overrideGet high error on X[i].Definition TGraphBentErrors.cxx:430; TGraphBentErrors::AddPointErrorvirtual void AddPointError(Double_t x, Double_t y, Double_t exl, Double_t exh, Double_t eyl, Double_t eyh, Double_t exld=0, Double_t exhd=0, Double_t eyld=0, Double_t eyhd=0)Add a point with bent errors to the graph.Definition TGraphBentErrors.cxx:192; TGraphBentErrors::AllocateDouble_t ** Allocate(Int_t size) overrideAllocate internal data structures for newsize points.Definition TGraphBentErrors.h:104; TGraphBentErrors::SetPointErrorvirtual void SetPointError(Double_t exl, Double_t exh, Double_t eyl, Double_t eyh, Double_t exld=0, Double_t exhd=0, Double_t eyld=0, Double_t eyhd=0)Set ex and ey values for point pointed by the mouse.Definition TGraphBentErrors.cxx:587; TGraphBentErrors::fEXlowDouble_t * fEXlow[fNpoints] array of X low errorsDefinition TGraphBentErrors.h:28; TGraphBentErrors::fEXhighDouble_t * fEXhigh[fNpoints] array of X high errorsDefinition TGraphBentErrors.h:29; TGraphBentErrors::~TGraphBentErrors~TGraphBentErrors() overrideTGraphBentErrors default destructor.Definition TGraphBentErrors.cxx:176; TGraphBentErrors::Printvoid Print(Option_t *chopt="""") const overridePrint graph and errors values.Definition TGraphBentErrors.cxx:495; TGraphBentErrors::Scalevoid Scale(Double_t c1=1., Option_t *option=""y"") overrideMultiply the values and errors of a TGraphBentErrors by a constant c1.Definition TGraphBentErrors.cxx:510; TGraphBentErrors::FillZerovoid FillZero(Int_t begin, Int_t end, Bool_t from_ctor=kTRUE) overrideSet zero values for point arrays in the range [begin, end]Definition TGraphBentErrors.cxx:474; TGraphBentErrors::GetEXlowdDouble_t * GetEXlowd() const overrideDefinition TGraphBentErrors.h:84; TGraphBentErrors::GetErrorYDouble_t GetErrorY(Int_t bin) const overrideIt returns the error along Y at point i.Definition TGraphBentErrors.cxx:416; TGraphBentErrors::fEYlowDouble_t * fEYlow[fN",MatchSource.WIKI,doc/master/TGraphBentErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphBentErrors_8h_source.html
https://root.cern/doc/master/TGraphBentErrors_8h_source.html:9418,Availability,error,errors,9418,"xh, Double_t eyl, Double_t eyh, Double_t exld=0, Double_t exhd=0, Double_t eyld=0, Double_t eyhd=0)Add a point with bent errors to the graph.Definition TGraphBentErrors.cxx:192; TGraphBentErrors::AllocateDouble_t ** Allocate(Int_t size) overrideAllocate internal data structures for newsize points.Definition TGraphBentErrors.h:104; TGraphBentErrors::SetPointErrorvirtual void SetPointError(Double_t exl, Double_t exh, Double_t eyl, Double_t eyh, Double_t exld=0, Double_t exhd=0, Double_t eyld=0, Double_t eyhd=0)Set ex and ey values for point pointed by the mouse.Definition TGraphBentErrors.cxx:587; TGraphBentErrors::fEXlowDouble_t * fEXlow[fNpoints] array of X low errorsDefinition TGraphBentErrors.h:28; TGraphBentErrors::fEXhighDouble_t * fEXhigh[fNpoints] array of X high errorsDefinition TGraphBentErrors.h:29; TGraphBentErrors::~TGraphBentErrors~TGraphBentErrors() overrideTGraphBentErrors default destructor.Definition TGraphBentErrors.cxx:176; TGraphBentErrors::Printvoid Print(Option_t *chopt="""") const overridePrint graph and errors values.Definition TGraphBentErrors.cxx:495; TGraphBentErrors::Scalevoid Scale(Double_t c1=1., Option_t *option=""y"") overrideMultiply the values and errors of a TGraphBentErrors by a constant c1.Definition TGraphBentErrors.cxx:510; TGraphBentErrors::FillZerovoid FillZero(Int_t begin, Int_t end, Bool_t from_ctor=kTRUE) overrideSet zero values for point arrays in the range [begin, end]Definition TGraphBentErrors.cxx:474; TGraphBentErrors::GetEXlowdDouble_t * GetEXlowd() const overrideDefinition TGraphBentErrors.h:84; TGraphBentErrors::GetErrorYDouble_t GetErrorY(Int_t bin) const overrideIt returns the error along Y at point i.Definition TGraphBentErrors.cxx:416; TGraphBentErrors::fEYlowDouble_t * fEYlow[fNpoints] array of Y low errorsDefinition TGraphBentErrors.h:30; TGraphBentErrors::fEYhighdDouble_t * fEYhighd[fNpoints] array of Y high displacementsDefinition TGraphBentErrors.h:36; TGraphBentErrors::CopyAndReleasevoid CopyAndRelease(Double_t",MatchSource.WIKI,doc/master/TGraphBentErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphBentErrors_8h_source.html
https://root.cern/doc/master/TGraphBentErrors_8h_source.html:9573,Availability,error,errors,9573,"rors::AllocateDouble_t ** Allocate(Int_t size) overrideAllocate internal data structures for newsize points.Definition TGraphBentErrors.h:104; TGraphBentErrors::SetPointErrorvirtual void SetPointError(Double_t exl, Double_t exh, Double_t eyl, Double_t eyh, Double_t exld=0, Double_t exhd=0, Double_t eyld=0, Double_t eyhd=0)Set ex and ey values for point pointed by the mouse.Definition TGraphBentErrors.cxx:587; TGraphBentErrors::fEXlowDouble_t * fEXlow[fNpoints] array of X low errorsDefinition TGraphBentErrors.h:28; TGraphBentErrors::fEXhighDouble_t * fEXhigh[fNpoints] array of X high errorsDefinition TGraphBentErrors.h:29; TGraphBentErrors::~TGraphBentErrors~TGraphBentErrors() overrideTGraphBentErrors default destructor.Definition TGraphBentErrors.cxx:176; TGraphBentErrors::Printvoid Print(Option_t *chopt="""") const overridePrint graph and errors values.Definition TGraphBentErrors.cxx:495; TGraphBentErrors::Scalevoid Scale(Double_t c1=1., Option_t *option=""y"") overrideMultiply the values and errors of a TGraphBentErrors by a constant c1.Definition TGraphBentErrors.cxx:510; TGraphBentErrors::FillZerovoid FillZero(Int_t begin, Int_t end, Bool_t from_ctor=kTRUE) overrideSet zero values for point arrays in the range [begin, end]Definition TGraphBentErrors.cxx:474; TGraphBentErrors::GetEXlowdDouble_t * GetEXlowd() const overrideDefinition TGraphBentErrors.h:84; TGraphBentErrors::GetErrorYDouble_t GetErrorY(Int_t bin) const overrideIt returns the error along Y at point i.Definition TGraphBentErrors.cxx:416; TGraphBentErrors::fEYlowDouble_t * fEYlow[fNpoints] array of Y low errorsDefinition TGraphBentErrors.h:30; TGraphBentErrors::fEYhighdDouble_t * fEYhighd[fNpoints] array of Y high displacementsDefinition TGraphBentErrors.h:36; TGraphBentErrors::CopyAndReleasevoid CopyAndRelease(Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy and release.Definition TGraphBentErrors.cxx:278; TGraphBentErrors::SwapPointsvoid SwapPoints(Int_t pos1, Int_t pos2) overr",MatchSource.WIKI,doc/master/TGraphBentErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphBentErrors_8h_source.html
https://root.cern/doc/master/TGraphBentErrors_8h_source.html:10031,Availability,error,error,10031,"::fEXlowDouble_t * fEXlow[fNpoints] array of X low errorsDefinition TGraphBentErrors.h:28; TGraphBentErrors::fEXhighDouble_t * fEXhigh[fNpoints] array of X high errorsDefinition TGraphBentErrors.h:29; TGraphBentErrors::~TGraphBentErrors~TGraphBentErrors() overrideTGraphBentErrors default destructor.Definition TGraphBentErrors.cxx:176; TGraphBentErrors::Printvoid Print(Option_t *chopt="""") const overridePrint graph and errors values.Definition TGraphBentErrors.cxx:495; TGraphBentErrors::Scalevoid Scale(Double_t c1=1., Option_t *option=""y"") overrideMultiply the values and errors of a TGraphBentErrors by a constant c1.Definition TGraphBentErrors.cxx:510; TGraphBentErrors::FillZerovoid FillZero(Int_t begin, Int_t end, Bool_t from_ctor=kTRUE) overrideSet zero values for point arrays in the range [begin, end]Definition TGraphBentErrors.cxx:474; TGraphBentErrors::GetEXlowdDouble_t * GetEXlowd() const overrideDefinition TGraphBentErrors.h:84; TGraphBentErrors::GetErrorYDouble_t GetErrorY(Int_t bin) const overrideIt returns the error along Y at point i.Definition TGraphBentErrors.cxx:416; TGraphBentErrors::fEYlowDouble_t * fEYlow[fNpoints] array of Y low errorsDefinition TGraphBentErrors.h:30; TGraphBentErrors::fEYhighdDouble_t * fEYhighd[fNpoints] array of Y high displacementsDefinition TGraphBentErrors.h:36; TGraphBentErrors::CopyAndReleasevoid CopyAndRelease(Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy and release.Definition TGraphBentErrors.cxx:278; TGraphBentErrors::SwapPointsvoid SwapPoints(Int_t pos1, Int_t pos2) overrideSwap points.Definition TGraphBentErrors.cxx:646; TGraphBentErrors::CopyPointsBool_t CopyPoints(Double_t **arrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy errors from fE***to arrays[***] or to f*** Copy points.Definition TGraphBentErrors.cxx:312; TGraphBentErrors::GetErrorYlowDouble_t GetErrorYlow(Int_t bin) const overrideGet low error on Y[i].Definition TGraphBentErrors.cxx:463; TGraphBentErrors::GetErrorXDoubl",MatchSource.WIKI,doc/master/TGraphBentErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphBentErrors_8h_source.html
https://root.cern/doc/master/TGraphBentErrors_8h_source.html:10160,Availability,error,errorsDefinition,10160,"s] array of X high errorsDefinition TGraphBentErrors.h:29; TGraphBentErrors::~TGraphBentErrors~TGraphBentErrors() overrideTGraphBentErrors default destructor.Definition TGraphBentErrors.cxx:176; TGraphBentErrors::Printvoid Print(Option_t *chopt="""") const overridePrint graph and errors values.Definition TGraphBentErrors.cxx:495; TGraphBentErrors::Scalevoid Scale(Double_t c1=1., Option_t *option=""y"") overrideMultiply the values and errors of a TGraphBentErrors by a constant c1.Definition TGraphBentErrors.cxx:510; TGraphBentErrors::FillZerovoid FillZero(Int_t begin, Int_t end, Bool_t from_ctor=kTRUE) overrideSet zero values for point arrays in the range [begin, end]Definition TGraphBentErrors.cxx:474; TGraphBentErrors::GetEXlowdDouble_t * GetEXlowd() const overrideDefinition TGraphBentErrors.h:84; TGraphBentErrors::GetErrorYDouble_t GetErrorY(Int_t bin) const overrideIt returns the error along Y at point i.Definition TGraphBentErrors.cxx:416; TGraphBentErrors::fEYlowDouble_t * fEYlow[fNpoints] array of Y low errorsDefinition TGraphBentErrors.h:30; TGraphBentErrors::fEYhighdDouble_t * fEYhighd[fNpoints] array of Y high displacementsDefinition TGraphBentErrors.h:36; TGraphBentErrors::CopyAndReleasevoid CopyAndRelease(Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy and release.Definition TGraphBentErrors.cxx:278; TGraphBentErrors::SwapPointsvoid SwapPoints(Int_t pos1, Int_t pos2) overrideSwap points.Definition TGraphBentErrors.cxx:646; TGraphBentErrors::CopyPointsBool_t CopyPoints(Double_t **arrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy errors from fE***to arrays[***] or to f*** Copy points.Definition TGraphBentErrors.cxx:312; TGraphBentErrors::GetErrorYlowDouble_t GetErrorYlow(Int_t bin) const overrideGet low error on Y[i].Definition TGraphBentErrors.cxx:463; TGraphBentErrors::GetErrorXDouble_t GetErrorX(Int_t bin) const overrideIt returns the error along X at point i.Definition TGraphBentErrors.cxx:402; TGraphBentErrors::GetErro",MatchSource.WIKI,doc/master/TGraphBentErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphBentErrors_8h_source.html
https://root.cern/doc/master/TGraphBentErrors_8h_source.html:10738,Availability,error,errors,10738,"begin, Int_t end, Bool_t from_ctor=kTRUE) overrideSet zero values for point arrays in the range [begin, end]Definition TGraphBentErrors.cxx:474; TGraphBentErrors::GetEXlowdDouble_t * GetEXlowd() const overrideDefinition TGraphBentErrors.h:84; TGraphBentErrors::GetErrorYDouble_t GetErrorY(Int_t bin) const overrideIt returns the error along Y at point i.Definition TGraphBentErrors.cxx:416; TGraphBentErrors::fEYlowDouble_t * fEYlow[fNpoints] array of Y low errorsDefinition TGraphBentErrors.h:30; TGraphBentErrors::fEYhighdDouble_t * fEYhighd[fNpoints] array of Y high displacementsDefinition TGraphBentErrors.h:36; TGraphBentErrors::CopyAndReleasevoid CopyAndRelease(Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy and release.Definition TGraphBentErrors.cxx:278; TGraphBentErrors::SwapPointsvoid SwapPoints(Int_t pos1, Int_t pos2) overrideSwap points.Definition TGraphBentErrors.cxx:646; TGraphBentErrors::CopyPointsBool_t CopyPoints(Double_t **arrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy errors from fE***to arrays[***] or to f*** Copy points.Definition TGraphBentErrors.cxx:312; TGraphBentErrors::GetErrorYlowDouble_t GetErrorYlow(Int_t bin) const overrideGet low error on Y[i].Definition TGraphBentErrors.cxx:463; TGraphBentErrors::GetErrorXDouble_t GetErrorX(Int_t bin) const overrideIt returns the error along X at point i.Definition TGraphBentErrors.cxx:402; TGraphBentErrors::GetErrorYhighDouble_t GetErrorYhigh(Int_t bin) const overrideGet high error on Y[i].Definition TGraphBentErrors.cxx:452; TGraphBentErrors::Applyvoid Apply(TF1 *f) overrideApply a function to all data points .Definition TGraphBentErrors.cxx:210; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; TGraph::AllocateArraysDouble_t ** AllocateArrays(Int_t Narrays, Int_t arraySize)Allocate arrays.Definition TGraph.cxx:598; bool; double; int; yDouble_t y[n]Definition legend1.C:17; c1return c1Definition legend1.C:41; xDouble_t x",MatchSource.WIKI,doc/master/TGraphBentErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphBentErrors_8h_source.html
https://root.cern/doc/master/TGraphBentErrors_8h_source.html:10915,Availability,error,error,10915,"ouble_t * GetEXlowd() const overrideDefinition TGraphBentErrors.h:84; TGraphBentErrors::GetErrorYDouble_t GetErrorY(Int_t bin) const overrideIt returns the error along Y at point i.Definition TGraphBentErrors.cxx:416; TGraphBentErrors::fEYlowDouble_t * fEYlow[fNpoints] array of Y low errorsDefinition TGraphBentErrors.h:30; TGraphBentErrors::fEYhighdDouble_t * fEYhighd[fNpoints] array of Y high displacementsDefinition TGraphBentErrors.h:36; TGraphBentErrors::CopyAndReleasevoid CopyAndRelease(Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy and release.Definition TGraphBentErrors.cxx:278; TGraphBentErrors::SwapPointsvoid SwapPoints(Int_t pos1, Int_t pos2) overrideSwap points.Definition TGraphBentErrors.cxx:646; TGraphBentErrors::CopyPointsBool_t CopyPoints(Double_t **arrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy errors from fE***to arrays[***] or to f*** Copy points.Definition TGraphBentErrors.cxx:312; TGraphBentErrors::GetErrorYlowDouble_t GetErrorYlow(Int_t bin) const overrideGet low error on Y[i].Definition TGraphBentErrors.cxx:463; TGraphBentErrors::GetErrorXDouble_t GetErrorX(Int_t bin) const overrideIt returns the error along X at point i.Definition TGraphBentErrors.cxx:402; TGraphBentErrors::GetErrorYhighDouble_t GetErrorYhigh(Int_t bin) const overrideGet high error on Y[i].Definition TGraphBentErrors.cxx:452; TGraphBentErrors::Applyvoid Apply(TF1 *f) overrideApply a function to all data points .Definition TGraphBentErrors.cxx:210; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; TGraph::AllocateArraysDouble_t ** AllocateArrays(Int_t Narrays, Int_t arraySize)Allocate arrays.Definition TGraph.cxx:598; bool; double; int; yDouble_t y[n]Definition legend1.C:17; c1return c1Definition legend1.C:41; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; grTGraphErrors * grDefinition legend1.C:25. histhistincTGraphBentErrors.h. ROOT master - Reference Guide G",MatchSource.WIKI,doc/master/TGraphBentErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphBentErrors_8h_source.html
https://root.cern/doc/master/TGraphBentErrors_8h_source.html:11052,Availability,error,error,11052,"aphBentErrors::GetErrorYDouble_t GetErrorY(Int_t bin) const overrideIt returns the error along Y at point i.Definition TGraphBentErrors.cxx:416; TGraphBentErrors::fEYlowDouble_t * fEYlow[fNpoints] array of Y low errorsDefinition TGraphBentErrors.h:30; TGraphBentErrors::fEYhighdDouble_t * fEYhighd[fNpoints] array of Y high displacementsDefinition TGraphBentErrors.h:36; TGraphBentErrors::CopyAndReleasevoid CopyAndRelease(Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy and release.Definition TGraphBentErrors.cxx:278; TGraphBentErrors::SwapPointsvoid SwapPoints(Int_t pos1, Int_t pos2) overrideSwap points.Definition TGraphBentErrors.cxx:646; TGraphBentErrors::CopyPointsBool_t CopyPoints(Double_t **arrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy errors from fE***to arrays[***] or to f*** Copy points.Definition TGraphBentErrors.cxx:312; TGraphBentErrors::GetErrorYlowDouble_t GetErrorYlow(Int_t bin) const overrideGet low error on Y[i].Definition TGraphBentErrors.cxx:463; TGraphBentErrors::GetErrorXDouble_t GetErrorX(Int_t bin) const overrideIt returns the error along X at point i.Definition TGraphBentErrors.cxx:402; TGraphBentErrors::GetErrorYhighDouble_t GetErrorYhigh(Int_t bin) const overrideGet high error on Y[i].Definition TGraphBentErrors.cxx:452; TGraphBentErrors::Applyvoid Apply(TF1 *f) overrideApply a function to all data points .Definition TGraphBentErrors.cxx:210; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; TGraph::AllocateArraysDouble_t ** AllocateArrays(Int_t Narrays, Int_t arraySize)Allocate arrays.Definition TGraph.cxx:598; bool; double; int; yDouble_t y[n]Definition legend1.C:17; c1return c1Definition legend1.C:41; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; grTGraphErrors * grDefinition legend1.C:25. histhistincTGraphBentErrors.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TGraphBentErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphBentErrors_8h_source.html
https://root.cern/doc/master/TGraphBentErrors_8h_source.html:11202,Availability,error,error,11202,"aphBentErrors::GetErrorYDouble_t GetErrorY(Int_t bin) const overrideIt returns the error along Y at point i.Definition TGraphBentErrors.cxx:416; TGraphBentErrors::fEYlowDouble_t * fEYlow[fNpoints] array of Y low errorsDefinition TGraphBentErrors.h:30; TGraphBentErrors::fEYhighdDouble_t * fEYhighd[fNpoints] array of Y high displacementsDefinition TGraphBentErrors.h:36; TGraphBentErrors::CopyAndReleasevoid CopyAndRelease(Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy and release.Definition TGraphBentErrors.cxx:278; TGraphBentErrors::SwapPointsvoid SwapPoints(Int_t pos1, Int_t pos2) overrideSwap points.Definition TGraphBentErrors.cxx:646; TGraphBentErrors::CopyPointsBool_t CopyPoints(Double_t **arrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy errors from fE***to arrays[***] or to f*** Copy points.Definition TGraphBentErrors.cxx:312; TGraphBentErrors::GetErrorYlowDouble_t GetErrorYlow(Int_t bin) const overrideGet low error on Y[i].Definition TGraphBentErrors.cxx:463; TGraphBentErrors::GetErrorXDouble_t GetErrorX(Int_t bin) const overrideIt returns the error along X at point i.Definition TGraphBentErrors.cxx:402; TGraphBentErrors::GetErrorYhighDouble_t GetErrorYhigh(Int_t bin) const overrideGet high error on Y[i].Definition TGraphBentErrors.cxx:452; TGraphBentErrors::Applyvoid Apply(TF1 *f) overrideApply a function to all data points .Definition TGraphBentErrors.cxx:210; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; TGraph::AllocateArraysDouble_t ** AllocateArrays(Int_t Narrays, Int_t arraySize)Allocate arrays.Definition TGraph.cxx:598; bool; double; int; yDouble_t y[n]Definition legend1.C:17; c1return c1Definition legend1.C:41; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; grTGraphErrors * grDefinition legend1.C:25. histhistincTGraphBentErrors.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TGraphBentErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphBentErrors_8h_source.html
https://root.cern/doc/master/TGraphBentErrors_8h_source.html:10450,Deployability,release,release,10450,""") const overridePrint graph and errors values.Definition TGraphBentErrors.cxx:495; TGraphBentErrors::Scalevoid Scale(Double_t c1=1., Option_t *option=""y"") overrideMultiply the values and errors of a TGraphBentErrors by a constant c1.Definition TGraphBentErrors.cxx:510; TGraphBentErrors::FillZerovoid FillZero(Int_t begin, Int_t end, Bool_t from_ctor=kTRUE) overrideSet zero values for point arrays in the range [begin, end]Definition TGraphBentErrors.cxx:474; TGraphBentErrors::GetEXlowdDouble_t * GetEXlowd() const overrideDefinition TGraphBentErrors.h:84; TGraphBentErrors::GetErrorYDouble_t GetErrorY(Int_t bin) const overrideIt returns the error along Y at point i.Definition TGraphBentErrors.cxx:416; TGraphBentErrors::fEYlowDouble_t * fEYlow[fNpoints] array of Y low errorsDefinition TGraphBentErrors.h:30; TGraphBentErrors::fEYhighdDouble_t * fEYhighd[fNpoints] array of Y high displacementsDefinition TGraphBentErrors.h:36; TGraphBentErrors::CopyAndReleasevoid CopyAndRelease(Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy and release.Definition TGraphBentErrors.cxx:278; TGraphBentErrors::SwapPointsvoid SwapPoints(Int_t pos1, Int_t pos2) overrideSwap points.Definition TGraphBentErrors.cxx:646; TGraphBentErrors::CopyPointsBool_t CopyPoints(Double_t **arrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy errors from fE***to arrays[***] or to f*** Copy points.Definition TGraphBentErrors.cxx:312; TGraphBentErrors::GetErrorYlowDouble_t GetErrorYlow(Int_t bin) const overrideGet low error on Y[i].Definition TGraphBentErrors.cxx:463; TGraphBentErrors::GetErrorXDouble_t GetErrorX(Int_t bin) const overrideIt returns the error along X at point i.Definition TGraphBentErrors.cxx:402; TGraphBentErrors::GetErrorYhighDouble_t GetErrorYhigh(Int_t bin) const overrideGet high error on Y[i].Definition TGraphBentErrors.cxx:452; TGraphBentErrors::Applyvoid Apply(TF1 *f) overrideApply a function to all data points .Definition TGraphBentErrors.cxx:210; TGraphA T",MatchSource.WIKI,doc/master/TGraphBentErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphBentErrors_8h_source.html
https://root.cern/doc/master/TGraphBentErrors_8h_source.html:7012,Performance,perform,perform,7012,"ion TGraphBentErrors.cxx:665; TGraphBentErrors::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave primitive as a C++ statement(s) on output stream out.Definition TGraphBentErrors.cxx:551; TGraphBentErrors::TGraphBentErrorsTGraphBentErrors()TGraphBentErrors default constructor.Definition TGraphBentErrors.cxx:62; TGraphBentErrors::GetEXlowDouble_t * GetEXlow() const overrideDefinition TGraphBentErrors.h:80; TGraphBentErrors::fEYhighDouble_t * fEYhigh[fNpoints] array of Y high errorsDefinition TGraphBentErrors.h:31; TGraphBentErrors::fEXlowdDouble_t * fEXlowd[fNpoints] array of X low displacementsDefinition TGraphBentErrors.h:33; TGraphBentErrors::fEYlowdDouble_t * fEYlowd[fNpoints] array of Y low displacementsDefinition TGraphBentErrors.h:35; TGraphBentErrors::CtorAllocateBool_t CtorAllocate()Should be called from ctors after fNpoints has been set.Definition TGraphBentErrors.cxx:346; TGraphBentErrors::DoMergeBool_t DoMerge(const TGraph *g) overrideProtected function to perform the merge operation of a graph with asymmetric errors.Definition TGraphBentErrors.cxx:367; TGraphBentErrors::GetEYhighDouble_t * GetEYhigh() const overrideDefinition TGraphBentErrors.h:83; TGraphBentErrors::GetErrorXlowDouble_t GetErrorXlow(Int_t bin) const overrideGet low error on X[i].Definition TGraphBentErrors.cxx:441; TGraphBentErrors::GetEYlowDouble_t * GetEYlow() const overrideDefinition TGraphBentErrors.h:82; TGraphBentErrors::GetEYhighdDouble_t * GetEYhighd() const overrideDefinition TGraphBentErrors.h:87; TGraphBentErrors::ComputeRangevoid ComputeRange(Double_t &xmin, Double_t &ymin, Double_t &xmax, Double_t &ymax) const overrideCompute range.Definition TGraphBentErrors.cxx:248; TGraphBentErrors::GetEXhighDouble_t * GetEXhigh() const overrideDefinition TGraphBentErrors.h:81; TGraphBentErrors::GetEYlowdDouble_t * GetEYlowd() const overrideDefinition TGraphBentErrors.h:86; TGraphBentErrors::fEXhighdDouble_t * fEXhighd[fNpoints] array of X high displacem",MatchSource.WIKI,doc/master/TGraphBentErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphBentErrors_8h_source.html
https://root.cern/doc/master/TGraphDelaunay_8cxx_source.html:13482,Availability,error,errors,13482,"360 if (m == 1) {; 361 p1 = pa;; 362 p2 = na;; 363 p3 = ma;; 364 } else if (m == 2) {; 365 p1 = pa;; 366 p2 = ma;; 367 p3 = na;; 368 } else if (m == 3) {; 369 p1 = na;; 370 p2 = ma;; 371 p3 = pa;; 372 }; 373 // get the coordinates of the centre of this side; 374 xm = (fXN[p1]+fXN[p2])/2.;; 375 ym = (fYN[p1]+fYN[p2])/2.;; 376 // we want to add a little to these coordinates to get a point just; 377 // outside the triangle; (sx,sy) will be the vector that represents; 378 // the side; 379 sx = fXN[p1]-fXN[p2];; 380 sy = fYN[p1]-fYN[p2];; 381 // (nx,ny) will be the normal to the side, but don't know if it's; 382 // pointing in or out yet; 383 nx = sy;; 384 ny = -sx;; 385 nn = TMath::Sqrt(nx*nx+ny*ny);; 386 nx = nx/nn;; 387 ny = ny/nn;; 388 mx = fXN[p3]-xm;; 389 my = fYN[p3]-ym;; 390 mdotn = mx*nx+my*ny;; 391 if (mdotn > 0) {; 392 // (nx,ny) is pointing in, we want it pointing out; 393 nx = -nx;; 394 ny = -ny;; 395 }; 396 // increase/decrease xm and ym a little to produce a point; 397 // just outside the triangle (ensuring that the amount added will; 398 // be large enough such that it won't be lost in rounding errors); 399 a = TMath::Abs(TMath::Max(alittlebit*xm,alittlebit*ym));; 400 xx = xm+nx*a;; 401 yy = ym+ny*a;; 402 // try and find a new Delaunay triangle for this point; 403 Interpolate(xx,yy);; 404 ; 405 // this side of t1 should now, hopefully, if it's not part of the; 406 // hull, be shared with a new Delaunay triangle just calculated by Interpolate; 407 }; 408 }; 409 t1++;; 410 }; 411}; 412 ; 413 ; 414////////////////////////////////////////////////////////////////////////////////; 415/// Finds those points which make up the convex hull of the set. If the xy; 416/// plane were a sheet of wood, and the points were nails hammered into it; 417/// at the respective coordinates, then if an elastic band were stretched; 418/// over all the nails it would form the shape of the convex hull. Those; 419/// nails in contact with it are the points that make up the hull.; 420",MatchSource.WIKI,doc/master/TGraphDelaunay_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphDelaunay_8cxx_source.html
https://root.cern/doc/master/TGraphDelaunay_8cxx_source.html:29240,Availability,error,errors,29240," dko1 = TMath::Sqrt((fXN[z]-fXN[o1])*(fXN[z]-fXN[o1])+(fYN[z]-fYN[o1])*(fYN[z]-fYN[o1]));; 835 dko2 = TMath::Sqrt((fXN[z]-fXN[o2])*(fXN[z]-fXN[o2])+(fYN[z]-fYN[o2])*(fYN[z]-fYN[o2]));; 836 dfo1 = TMath::Sqrt((fXN[f]-fXN[o1])*(fXN[f]-fXN[o1])+(fYN[f]-fYN[o1])*(fYN[f]-fYN[o1]));; 837 dfo2 = TMath::Sqrt((fXN[f]-fXN[o2])*(fXN[f]-fXN[o2])+(fYN[f]-fYN[o2])*(fYN[f]-fYN[o2]));; 838 c1 = ((fXN[z]-fXN[o1])*(fXN[z]-fXN[o2])+(fYN[z]-fYN[o1])*(fYN[z]-fYN[o2]))/dko1/dko2;; 839 c2 = ((fXN[f]-fXN[o1])*(fXN[f]-fXN[o2])+(fYN[f]-fYN[o1])*(fYN[f]-fYN[o2]))/dfo1/dfo2;; 840 sin_sum = c1*TMath::Sqrt(1-c2*c2)+c2*TMath::Sqrt(1-c1*c1);; 841 ; 842 // sin_sum doesn't always come out as zero when it should do.; 843 if (sin_sum < -1.E-6) {; 844 // z is inside the circle, this is not a Delaunay triangle; 845 goto L90;; 846 } else if (TMath::Abs(sin_sum) <= 1.E-6) {; 847 // point z lies on the circumference of the circle (within rounding errors); 848 // defined by the triangle, so there is potential for degeneracy in the; 849 // triangle set (Delaunay triangulation does not give a unique way to split; 850 // a polygon whose points lie on a circle into constituent triangles). Make; 851 // a note of the additional point number.; 852 ndegen++;; 853 degen = z;; 854 fdegen = f;; 855 o1degen = o1;; 856 o2degen = o2;; 857 }; 858L50:; 859 continue;; 860 }; 861 // This is a good triangle; 862 if (ndegen > 0) {; 863 // but is degenerate with at least one other,; 864 // haven't figured out what to do if more than 4 points are involved; 865/// if (ndegen > 1) {; 866/// Error(""Interpolate"",; 867/// ""More than 4 points lying on a circle. No decision making process formulated for triangulating this region in a non-arbitrary way %d %d %d %d"",; 868/// p,n,m,degen);; 869/// return thevalue;; 870/// }; 871 ; 872 // we have a quadrilateral which can be split down either diagonal; 873 // (d<->f or o1<->o2) to form valid Delaunay triangles. Choose diagonal; 874 // with highest average z-value. Whichever we choose we wil",MatchSource.WIKI,doc/master/TGraphDelaunay_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphDelaunay_8cxx_source.html
https://root.cern/doc/master/TGraphDelaunay_8cxx_source.html:30159,Availability,down,down,30159,"aunay triangle; 845 goto L90;; 846 } else if (TMath::Abs(sin_sum) <= 1.E-6) {; 847 // point z lies on the circumference of the circle (within rounding errors); 848 // defined by the triangle, so there is potential for degeneracy in the; 849 // triangle set (Delaunay triangulation does not give a unique way to split; 850 // a polygon whose points lie on a circle into constituent triangles). Make; 851 // a note of the additional point number.; 852 ndegen++;; 853 degen = z;; 854 fdegen = f;; 855 o1degen = o1;; 856 o2degen = o2;; 857 }; 858L50:; 859 continue;; 860 }; 861 // This is a good triangle; 862 if (ndegen > 0) {; 863 // but is degenerate with at least one other,; 864 // haven't figured out what to do if more than 4 points are involved; 865/// if (ndegen > 1) {; 866/// Error(""Interpolate"",; 867/// ""More than 4 points lying on a circle. No decision making process formulated for triangulating this region in a non-arbitrary way %d %d %d %d"",; 868/// p,n,m,degen);; 869/// return thevalue;; 870/// }; 871 ; 872 // we have a quadrilateral which can be split down either diagonal; 873 // (d<->f or o1<->o2) to form valid Delaunay triangles. Choose diagonal; 874 // with highest average z-value. Whichever we choose we will have; 875 // verified two triangles as good and two as bad, only note the good ones; 876 d = degen;; 877 f = fdegen;; 878 o1 = o1degen;; 879 o2 = o2degen;; 880 if ((fZ[o1-1]+fZ[o2-1]) > (fZ[d-1]+fZ[f-1])) {; 881 // best diagonalisation of quadrilateral is current one, we have; 882 // the triangle; 883 t1 = p;; 884 t2 = n;; 885 t3 = m;; 886 // file the good triangles; 887 FileIt(p, n, m);; 888 FileIt(d, o1, o2);; 889 } else {; 890 // use other diagonal to split quadrilateral, use triangle formed by; 891 // point f, the degnerate point d and whichever of o1 and o2 create; 892 // an enclosing triangle; 893 t1 = f;; 894 t2 = d;; 895 if (Enclose(f,d,o1,0)) {; 896 t3 = o1;; 897 } else {; 898 t3 = o2;; 899 }; 900 // file the good triangles; 901 FileIt(f, d, o1);; ",MatchSource.WIKI,doc/master/TGraphDelaunay_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphDelaunay_8cxx_source.html
https://root.cern/doc/master/TGraphDelaunay_8cxx_source.html:40086,Availability,error,error,40086,"t_t * fPTried!Definition TGraphDelaunay.h:59; TGraphDelaunay::fNhullInt_t fNhull! Number of points in the hullDefinition TGraphDelaunay.h:41; TGraphDelaunay::InterpolateDouble_t Interpolate(Double_t x, Double_t y)Finds the Delaunay triangle that the point (xi,yi) sits in (if any) and calculate a z-value for it by...Definition TGraphDelaunay.cxx:595; TGraphDelaunay::TGraphDelaunayTGraphDelaunay()TGraphDelaunay default constructor.Definition TGraphDelaunay.cxx:49; TGraphDelaunay::fHullPointsInt_t * fHullPoints! Hull points of size fNhullDefinition TGraphDelaunay.h:62; TGraphDelaunay::fXNDouble_t * fXN! fGraph2D vectors normalized of size fNpointsDefinition TGraphDelaunay.h:45; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; bool; double; int; Interpolate#define Interpolate(a, x, b, y)Definition geom.c:179; yDouble_t y[n]Definition legend1.C:17; c1return c1Definition legend1.C:41; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; f1TF1 * f1Definition legend1.C:11; c2return c2Definition legend2.C:14; TMath::MaxShort_t Max(Short_t a, Short_t b)Returns the largest of a and b.Definition TMathBase.h:250; TMath::IsInsideBool_t IsInside(T xp, T yp, Int_t np, T *x, T *y)Function which returns kTRUE if point xp,yp lies inside the polygon defined by the np points in array...Definition TMath.h:1233; TMath::ATan2Double_t ATan2(Double_t y, Double_t x)Returns the principal value of the arc tangent of y/x, expressed in radians.Definition TMath.h:646; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662; TMath::Piconstexpr Double_t Pi()Definition TMath.h:37; TMath::Sortvoid Sort(Index n, const Element *a, Index *index, ",MatchSource.WIKI,doc/master/TGraphDelaunay_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphDelaunay_8cxx_source.html
https://root.cern/doc/master/TGraphDelaunay_8cxx_source.html:41094,Availability,down,down,41094,"2; TGraphDelaunay::fXNDouble_t * fXN! fGraph2D vectors normalized of size fNpointsDefinition TGraphDelaunay.h:45; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; bool; double; int; Interpolate#define Interpolate(a, x, b, y)Definition geom.c:179; yDouble_t y[n]Definition legend1.C:17; c1return c1Definition legend1.C:41; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; f1TF1 * f1Definition legend1.C:11; c2return c2Definition legend2.C:14; TMath::MaxShort_t Max(Short_t a, Short_t b)Returns the largest of a and b.Definition TMathBase.h:250; TMath::IsInsideBool_t IsInside(T xp, T yp, Int_t np, T *x, T *y)Function which returns kTRUE if point xp,yp lies inside the polygon defined by the np points in array...Definition TMath.h:1233; TMath::ATan2Double_t ATan2(Double_t y, Double_t x)Returns the principal value of the arc tangent of y/x, expressed in radians.Definition TMath.h:646; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662; TMath::Piconstexpr Double_t Pi()Definition TMath.h:37; TMath::Sortvoid Sort(Index n, const Element *a, Index *index, Bool_t down=kTRUE)Sort the n elements of the array a of generic templated type Element.Definition TMathBase.h:431; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123; TMath::TwoPiconstexpr Double_t TwoPi()Definition TMath.h:44; v@ vDefinition rootcling_impl.cxx:3699; mTMarker mDefinition textangle.C:8; lTLine lDefinition textangle.C:4; t1auto * t1Definition textangle.C:20. histhistsrcTGraphDelaunay.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:33 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TGraphDelaunay_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphDelaunay_8cxx_source.html
https://root.cern/doc/master/TGraphDelaunay_8cxx_source.html:39962,Integrability,message,message,39962,"ucturevoid CreateTrianglesDataStructure()Function used internally only.Definition TGraphDelaunay.cxx:178; TGraphDelaunay::fPTriedInt_t * fPTried!Definition TGraphDelaunay.h:59; TGraphDelaunay::fNhullInt_t fNhull! Number of points in the hullDefinition TGraphDelaunay.h:41; TGraphDelaunay::InterpolateDouble_t Interpolate(Double_t x, Double_t y)Finds the Delaunay triangle that the point (xi,yi) sits in (if any) and calculate a z-value for it by...Definition TGraphDelaunay.cxx:595; TGraphDelaunay::TGraphDelaunayTGraphDelaunay()TGraphDelaunay default constructor.Definition TGraphDelaunay.cxx:49; TGraphDelaunay::fHullPointsInt_t * fHullPoints! Hull points of size fNhullDefinition TGraphDelaunay.h:62; TGraphDelaunay::fXNDouble_t * fXN! fGraph2D vectors normalized of size fNpointsDefinition TGraphDelaunay.h:45; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; bool; double; int; Interpolate#define Interpolate(a, x, b, y)Definition geom.c:179; yDouble_t y[n]Definition legend1.C:17; c1return c1Definition legend1.C:41; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; f1TF1 * f1Definition legend1.C:11; c2return c2Definition legend2.C:14; TMath::MaxShort_t Max(Short_t a, Short_t b)Returns the largest of a and b.Definition TMathBase.h:250; TMath::IsInsideBool_t IsInside(T xp, T yp, Int_t np, T *x, T *y)Function which returns kTRUE if point xp,yp lies inside the polygon defined by the np points in array...Definition TMath.h:1233; TMath::ATan2Double_t ATan2(Double_t y, Double_t x)Returns the principal value of the arc tangent of y/x, expressed in radians.Definition TMath.h:646; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition",MatchSource.WIKI,doc/master/TGraphDelaunay_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphDelaunay_8cxx_source.html
https://root.cern/doc/master/TGraphDelaunay_8cxx_source.html:40092,Integrability,message,message,40092,"t_t * fPTried!Definition TGraphDelaunay.h:59; TGraphDelaunay::fNhullInt_t fNhull! Number of points in the hullDefinition TGraphDelaunay.h:41; TGraphDelaunay::InterpolateDouble_t Interpolate(Double_t x, Double_t y)Finds the Delaunay triangle that the point (xi,yi) sits in (if any) and calculate a z-value for it by...Definition TGraphDelaunay.cxx:595; TGraphDelaunay::TGraphDelaunayTGraphDelaunay()TGraphDelaunay default constructor.Definition TGraphDelaunay.cxx:49; TGraphDelaunay::fHullPointsInt_t * fHullPoints! Hull points of size fNhullDefinition TGraphDelaunay.h:62; TGraphDelaunay::fXNDouble_t * fXN! fGraph2D vectors normalized of size fNpointsDefinition TGraphDelaunay.h:45; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; bool; double; int; Interpolate#define Interpolate(a, x, b, y)Definition geom.c:179; yDouble_t y[n]Definition legend1.C:17; c1return c1Definition legend1.C:41; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; f1TF1 * f1Definition legend1.C:11; c2return c2Definition legend2.C:14; TMath::MaxShort_t Max(Short_t a, Short_t b)Returns the largest of a and b.Definition TMathBase.h:250; TMath::IsInsideBool_t IsInside(T xp, T yp, Int_t np, T *x, T *y)Function which returns kTRUE if point xp,yp lies inside the polygon defined by the np points in array...Definition TMath.h:1233; TMath::ATan2Double_t ATan2(Double_t y, Double_t x)Returns the principal value of the arc tangent of y/x, expressed in radians.Definition TMath.h:646; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662; TMath::Piconstexpr Double_t Pi()Definition TMath.h:37; TMath::Sortvoid Sort(Index n, const Element *a, Index *index, ",MatchSource.WIKI,doc/master/TGraphDelaunay_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphDelaunay_8cxx_source.html
https://root.cern/doc/master/TGraphDelaunay_8cxx_source.html:37436,Performance,perform,performed,37436,"ffset!Definition TGraphDelaunay.h:51; TGraphDelaunay::fDistDouble_t * fDist! Array used to order mass points by distanceDefinition TGraphDelaunay.h:56; TGraphDelaunay::FileItvoid FileIt(Int_t P, Int_t N, Int_t M)Files the triangle defined by the 3 vertices p, n and m into the fxTried arrays.Definition TGraphDelaunay.cxx:237; TGraphDelaunay::fYNminDouble_t fYNmin! Minimum value of fYNDefinition TGraphDelaunay.h:49; TGraphDelaunay::fTriedSizeInt_t fTriedSize! Real size of the fxTried arraysDefinition TGraphDelaunay.h:58; TGraphDelaunay::fMTriedInt_t * fMTried!Definition TGraphDelaunay.h:61; TGraphDelaunay::fXDouble_t * fX! Pointer to fGraph2D->fXDefinition TGraphDelaunay.h:42; TGraphDelaunay::fGraph2DTGraph2D * fGraph2D! 2D graph containing the user dataDefinition TGraphDelaunay.h:66; TGraphDelaunay::FindAllTrianglesvoid FindAllTriangles()Attempt to find all the Delaunay triangles of the point set.Definition TGraphDelaunay.cxx:290; TGraphDelaunay::fAllTriBool_t fAllTri! True if FindAllTriangles() has been performed on fGraph2DDefinition TGraphDelaunay.h:64; TGraphDelaunay::SetMaxItervoid SetMaxIter(Int_t n=100000)Defines the number of triangles tested for a Delaunay triangle (number of iterations) before abandoni...Definition TGraphDelaunay.cxx:932; TGraphDelaunay::fMaxIterInt_t fMaxIter! Maximum number of iterations to find Delaunay trianglesDefinition TGraphDelaunay.h:57; TGraphDelaunay::fInitBool_t fInit! True if CreateTrianglesDataStructure() and FindHull() have been performedDefinition TGraphDelaunay.h:65; TGraphDelaunay::fOrderInt_t * fOrder! Array used to order mass points by distanceDefinition TGraphDelaunay.h:63; TGraphDelaunay::EncloseBool_t Enclose(Int_t T1, Int_t T2, Int_t T3, Int_t Ex) constIs point e inside the triangle t1-t2-t3 ?Definition TGraphDelaunay.cxx:215; TGraphDelaunay::fXScaleFactorDouble_t fXScaleFactor!Definition TGraphDelaunay.h:53; TGraphDelaunay::fNdtInt_t fNdt! Number of Delaunay triangles foundDefinition TGraphDelaunay.h:39; TGraphDelaun",MatchSource.WIKI,doc/master/TGraphDelaunay_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphDelaunay_8cxx_source.html
