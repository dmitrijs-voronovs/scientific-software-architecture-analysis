id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://psicode.org/psi4manual/1.2.1/plugins-1.html:6826,Modifiability,plugin,plugin,6826,"e build (the . part). Then just run make in; your plugin directory. After any change to the plugin C++ code,; make must be run in the plugin directory to recompile the; myplugin.so executable, but recompiling the main PSI4 code; is not necessary. Should you add additional (non-header) files to; the plugin or need to link to additional external libraries, add that; information here.; input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file.; This is usually done by manipulating PSIPATH. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection.; pymodule.py — Python component of the plugin.; By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build ",MatchSource.WIKI,psi4manual/1.2.1/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins-1.html
https://psicode.org/psi4manual/1.2.1/plugins-1.html:6900,Modifiability,plugin,plugin,6900,"ctory to recompile the; myplugin.so executable, but recompiling the main PSI4 code; is not necessary. Should you add additional (non-header) files to; the plugin or need to link to additional external libraries, add that; information here.; input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file.; This is usually done by manipulating PSIPATH. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection.; pymodule.py — Python component of the plugin.; By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any doc",MatchSource.WIKI,psi4manual/1.2.1/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins-1.html
https://psicode.org/psi4manual/1.2.1/plugins-1.html:6957,Modifiability,plugin,plugin,6957,"ctory to recompile the; myplugin.so executable, but recompiling the main PSI4 code; is not necessary. Should you add additional (non-header) files to; the plugin or need to link to additional external libraries, add that; information here.; input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file.; This is usually done by manipulating PSIPATH. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection.; pymodule.py — Python component of the plugin.; By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any doc",MatchSource.WIKI,psi4manual/1.2.1/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins-1.html
https://psicode.org/psi4manual/1.2.1/plugins-1.html:7184,Modifiability,plugin,plugin,7184,"at — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file.; This is usually done by manipulating PSIPATH. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection.; pymodule.py — Python component of the plugin.; By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation. Please note that pure virtual functions in a plugin may cause undefined symbols errors when; the plugin is loaded.; To c",MatchSource.WIKI,psi4manual/1.2.1/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins-1.html
https://psicode.org/psi4manual/1.2.1/plugins-1.html:7221,Modifiability,plugin,plugin,7221,"at — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file.; This is usually done by manipulating PSIPATH. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection.; pymodule.py — Python component of the plugin.; By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation. Please note that pure virtual functions in a plugin may cause undefined symbols errors when; the plugin is loaded.; To c",MatchSource.WIKI,psi4manual/1.2.1/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins-1.html
https://psicode.org/psi4manual/1.2.1/plugins-1.html:7347,Modifiability,plugin,plugin,7347," as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file.; This is usually done by manipulating PSIPATH. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection.; pymodule.py — Python component of the plugin.; By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation. Please note that pure virtual functions in a plugin may cause undefined symbols errors when; the plugin is loaded.; To create a purely Python plugin, create a new plugin directory, then; remove the Makefile and myplugin.cc files and; erase the shared object loading ",MatchSource.WIKI,psi4manual/1.2.1/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins-1.html
https://psicode.org/psi4manual/1.2.1/plugins-1.html:7433,Modifiability,plugin,plugin,7433," as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file.; This is usually done by manipulating PSIPATH. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection.; pymodule.py — Python component of the plugin.; By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation. Please note that pure virtual functions in a plugin may cause undefined symbols errors when; the plugin is loaded.; To create a purely Python plugin, create a new plugin directory, then; remove the Makefile and myplugin.cc files and; erase the shared object loading ",MatchSource.WIKI,psi4manual/1.2.1/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins-1.html
https://psicode.org/psi4manual/1.2.1/plugins-1.html:7470,Modifiability,plugin,plugin,7470,"s is usually done by manipulating PSIPATH. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection.; pymodule.py — Python component of the plugin.; By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation. Please note that pure virtual functions in a plugin may cause undefined symbols errors when; the plugin is loaded.; To create a purely Python plugin, create a new plugin directory, then; remove the Makefile and myplugin.cc files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; input.dat as a model for loading the plugin, no recompile ever; ",MatchSource.WIKI,psi4manual/1.2.1/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins-1.html
https://psicode.org/psi4manual/1.2.1/plugins-1.html:7548,Modifiability,plugin,plugin,7548,"s is usually done by manipulating PSIPATH. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection.; pymodule.py — Python component of the plugin.; By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation. Please note that pure virtual functions in a plugin may cause undefined symbols errors when; the plugin is loaded.; To create a purely Python plugin, create a new plugin directory, then; remove the Makefile and myplugin.cc files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; input.dat as a model for loading the plugin, no recompile ever; ",MatchSource.WIKI,psi4manual/1.2.1/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins-1.html
https://psicode.org/psi4manual/1.2.1/plugins-1.html:7584,Modifiability,plugin,plugin,7584,"s is usually done by manipulating PSIPATH. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection.; pymodule.py — Python component of the plugin.; By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation. Please note that pure virtual functions in a plugin may cause undefined symbols errors when; the plugin is loaded.; To create a purely Python plugin, create a new plugin directory, then; remove the Makefile and myplugin.cc files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; input.dat as a model for loading the plugin, no recompile ever; ",MatchSource.WIKI,psi4manual/1.2.1/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins-1.html
https://psicode.org/psi4manual/1.2.1/plugins-1.html:8134,Modifiability,plugin,plugin,8134,"; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation. Please note that pure virtual functions in a plugin may cause undefined symbols errors when; the plugin is loaded.; To create a purely Python plugin, create a new plugin directory, then; remove the Makefile and myplugin.cc files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; input.dat as a model for loading the plugin, no recompile ever; necessary. table of contents. Plugins: Adding New Functionality to PSI4; Modular Approach to Development; Creating a New Plugin; Creating a New Plugin Using a Conda Pre-compiled Binary; Files in a Plugin Directory. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Contributions: Intro to Programming in PSI4. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins-1.html
https://psicode.org/psi4manual/1.2.1/plugins-1.html:8186,Modifiability,plugin,plugin,8186,"; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation. Please note that pure virtual functions in a plugin may cause undefined symbols errors when; the plugin is loaded.; To create a purely Python plugin, create a new plugin directory, then; remove the Makefile and myplugin.cc files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; input.dat as a model for loading the plugin, no recompile ever; necessary. table of contents. Plugins: Adding New Functionality to PSI4; Modular Approach to Development; Creating a New Plugin; Creating a New Plugin Using a Conda Pre-compiled Binary; Files in a Plugin Directory. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Contributions: Intro to Programming in PSI4. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins-1.html
https://psicode.org/psi4manual/1.2.1/plugins-1.html:8231,Modifiability,plugin,plugin,8231,"; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation. Please note that pure virtual functions in a plugin may cause undefined symbols errors when; the plugin is loaded.; To create a purely Python plugin, create a new plugin directory, then; remove the Makefile and myplugin.cc files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; input.dat as a model for loading the plugin, no recompile ever; necessary. table of contents. Plugins: Adding New Functionality to PSI4; Modular Approach to Development; Creating a New Plugin; Creating a New Plugin Using a Conda Pre-compiled Binary; Files in a Plugin Directory. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Contributions: Intro to Programming in PSI4. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins-1.html
https://psicode.org/psi4manual/1.2.1/plugins-1.html:8252,Modifiability,plugin,plugin,8252,"; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation. Please note that pure virtual functions in a plugin may cause undefined symbols errors when; the plugin is loaded.; To create a purely Python plugin, create a new plugin directory, then; remove the Makefile and myplugin.cc files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; input.dat as a model for loading the plugin, no recompile ever; necessary. table of contents. Plugins: Adding New Functionality to PSI4; Modular Approach to Development; Creating a New Plugin; Creating a New Plugin Using a Conda Pre-compiled Binary; Files in a Plugin Directory. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Contributions: Intro to Programming in PSI4. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins-1.html
https://psicode.org/psi4manual/1.2.1/plugins-1.html:8499,Modifiability,plugin,plugin,8499,"; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation. Please note that pure virtual functions in a plugin may cause undefined symbols errors when; the plugin is loaded.; To create a purely Python plugin, create a new plugin directory, then; remove the Makefile and myplugin.cc files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; input.dat as a model for loading the plugin, no recompile ever; necessary. table of contents. Plugins: Adding New Functionality to PSI4; Modular Approach to Development; Creating a New Plugin; Creating a New Plugin Using a Conda Pre-compiled Binary; Files in a Plugin Directory. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Contributions: Intro to Programming in PSI4. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins-1.html
https://psicode.org/psi4manual/1.2.1/plugins-1.html:890,Performance,load,loaded,890,"﻿. Plugins: Adding New Functionality to PSI4. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Contributions: Intro to Programming in PSI4. Plugins: Adding New Functionality to PSI4¶. Modular Approach to Development¶; It is slightly cumbersome to the development cycle to recompile PSI4; every time a change is made to the C++ code.; It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with Psi3 due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; 1>>> psi4 --plugin-name myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory, use PSI4 to generate; a Makefile, and type make. Then execute psi4 in the directory on the; default input file.; 1; 2; 3; 4>>> cd myplugin; >>> `psi4 --plugin-compile`; >>> make; >>> psi4. PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; 1; 2; 3; 4; 5; 6>>> psi4 --plugin-name myplugin --plugin-template aointegrals; >>> psi4 --plugin-name myplugin --plugin-template mointegrals; >>> psi4 --plugin-name myplugin --plu",MatchSource.WIKI,psi4manual/1.2.1/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins-1.html
https://psicode.org/psi4manual/1.2.1/plugins-1.html:3801,Performance,load,loading,3801," a blank line. yes, LD_LIBRARY_PATH irrelevant; >>> echo $PYTHONHOME $PYTHONPATH $DYLD_LIBRARY_PATH $PSIDATADIR. >>> which python psi4 g++ gfortran # Linux; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/gcc++; $PSI4CONDA/bin/gfortran; >>> which python psi4 g++ gfortran clang++ # Mac; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/g++; $PSI4CONDA/bin/gfortran; /usr/bin/clang++. >>> which cmake; $PSI4CONDA/bin/cmake; # if above empty, ``conda install cmake``. Create and compile plugin; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35; 36>>> psi4 --plugin-name testplugin; -- Creating ""testplugin"" with ""basic"" template. -----------------; ==> Created plugin files (in testplugin as basic):; __init__.py, CMakeLists.txt, doc.rst, input.dat, plugin.cc, pymodule.py. # move into plugin directory; >>> cd testplugin. # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencies of target testplugin; [ 50%] Building CXX object CMakeFiles/testplugin.dir/plugin.cc.o; [100%] Linking CXX shared module testplugin.so; [100%] Built target testplugin. # run sample input.dat; >>> psi4; Attention! This SCF may be",MatchSource.WIKI,psi4manual/1.2.1/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins-1.html
https://psicode.org/psi4manual/1.2.1/plugins-1.html:3817,Performance,cache,cache,3817," a blank line. yes, LD_LIBRARY_PATH irrelevant; >>> echo $PYTHONHOME $PYTHONPATH $DYLD_LIBRARY_PATH $PSIDATADIR. >>> which python psi4 g++ gfortran # Linux; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/gcc++; $PSI4CONDA/bin/gfortran; >>> which python psi4 g++ gfortran clang++ # Mac; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/g++; $PSI4CONDA/bin/gfortran; /usr/bin/clang++. >>> which cmake; $PSI4CONDA/bin/cmake; # if above empty, ``conda install cmake``. Create and compile plugin; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35; 36>>> psi4 --plugin-name testplugin; -- Creating ""testplugin"" with ""basic"" template. -----------------; ==> Created plugin files (in testplugin as basic):; __init__.py, CMakeLists.txt, doc.rst, input.dat, plugin.cc, pymodule.py. # move into plugin directory; >>> cd testplugin. # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencies of target testplugin; [ 50%] Building CXX object CMakeFiles/testplugin.dir/plugin.cc.o; [100%] Linking CXX shared module testplugin.so; [100%] Built target testplugin. # run sample input.dat; >>> psi4; Attention! This SCF may be",MatchSource.WIKI,psi4manual/1.2.1/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins-1.html
https://psicode.org/psi4manual/1.2.1/plugins-1.html:4156,Performance,load,loading,4156,"SI4CONDA/bin/g++; $PSI4CONDA/bin/gfortran; /usr/bin/clang++. >>> which cmake; $PSI4CONDA/bin/cmake; # if above empty, ``conda install cmake``. Create and compile plugin; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35; 36>>> psi4 --plugin-name testplugin; -- Creating ""testplugin"" with ""basic"" template. -----------------; ==> Created plugin files (in testplugin as basic):; __init__.py, CMakeLists.txt, doc.rst, input.dat, plugin.cc, pymodule.py. # move into plugin directory; >>> cd testplugin. # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencies of target testplugin; [ 50%] Building CXX object CMakeFiles/testplugin.dir/plugin.cc.o; [100%] Linking CXX shared module testplugin.so; [100%] Built target testplugin. # run sample input.dat; >>> psi4; Attention! This SCF may be density-fitted. Please note that the conda distribution must be in $PATH or the; conda enviroment must be activated before compilation and execution of; plugins created using this procedure. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. CMakeLists.txt — CMake fil",MatchSource.WIKI,psi4manual/1.2.1/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins-1.html
https://psicode.org/psi4manual/1.2.1/plugins-1.html:4172,Performance,cache,cache,4172,"SI4CONDA/bin/g++; $PSI4CONDA/bin/gfortran; /usr/bin/clang++. >>> which cmake; $PSI4CONDA/bin/cmake; # if above empty, ``conda install cmake``. Create and compile plugin; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35; 36>>> psi4 --plugin-name testplugin; -- Creating ""testplugin"" with ""basic"" template. -----------------; ==> Created plugin files (in testplugin as basic):; __init__.py, CMakeLists.txt, doc.rst, input.dat, plugin.cc, pymodule.py. # move into plugin directory; >>> cd testplugin. # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencies of target testplugin; [ 50%] Building CXX object CMakeFiles/testplugin.dir/plugin.cc.o; [100%] Linking CXX shared module testplugin.so; [100%] Built target testplugin. # run sample input.dat; >>> psi4; Attention! This SCF may be density-fitted. Please note that the conda distribution must be in $PATH or the; conda enviroment must be activated before compilation and execution of; plugins created using this procedure. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. CMakeLists.txt — CMake fil",MatchSource.WIKI,psi4manual/1.2.1/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins-1.html
https://psicode.org/psi4manual/1.2.1/plugins-1.html:5493,Performance,load,loading,5493,"in.cc.o; [100%] Linking CXX shared module testplugin.so; [100%] Built target testplugin. # run sample input.dat; >>> psi4; Attention! This SCF may be density-fitted. Please note that the conda distribution must be in $PATH or the; conda enviroment must be activated before compilation and execution of; plugins created using this procedure. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. CMakeLists.txt — CMake file governing project plugin.; The plugin source and CMakeLists.txt is independent of platform; and PSI4 installation. You use CMake (version 3.1 or later); to generate a Makefile for the plugin by pointing it to a specific; PSI4 installation. Run psi4 --plugin-compile to get a command; to execute to generate the Makefile. What that command is doing is; loading the compilers and options used to build the parent PSI4; (the -C psi4PluginCache part) which in turn can be overridden; by passing -Doption=value commands to cmake and pointing; toward a particular PSI4 (and probably pybind11) library to; link against (the CMAKE_PREFIX_PATH part) and telling it to; do an in-source build (the . part). Then just run make in; your plugin directory. After any change to the plugin C++ code,; make must be run in the plugin directory to recompile the; myplugin.so executable, but recompiling the main PSI4 code; is not necessary. Should you add additional (non-header) files to; the plugin or need to link to additional external libraries, add that; information here.; input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file.; This is usually done by manipulating PSIPATH. Then,; the plugin can be loaded as import myplugin and executed as; energy('",MatchSource.WIKI,psi4manual/1.2.1/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins-1.html
https://psicode.org/psi4manual/1.2.1/plugins-1.html:6594,Performance,load,loaded,6594,"rridden; by passing -Doption=value commands to cmake and pointing; toward a particular PSI4 (and probably pybind11) library to; link against (the CMAKE_PREFIX_PATH part) and telling it to; do an in-source build (the . part). Then just run make in; your plugin directory. After any change to the plugin C++ code,; make must be run in the plugin directory to recompile the; myplugin.so executable, but recompiling the main PSI4 code; is not necessary. Should you add additional (non-header) files to; the plugin or need to link to additional external libraries, add that; information here.; input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file.; This is usually done by manipulating PSIPATH. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection.; pymodule.py — Python component of the plugin.; By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section). doc.rst — D",MatchSource.WIKI,psi4manual/1.2.1/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins-1.html
https://psicode.org/psi4manual/1.2.1/plugins-1.html:8196,Performance,load,loaded,8196,"; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation. Please note that pure virtual functions in a plugin may cause undefined symbols errors when; the plugin is loaded.; To create a purely Python plugin, create a new plugin directory, then; remove the Makefile and myplugin.cc files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; input.dat as a model for loading the plugin, no recompile ever; necessary. table of contents. Plugins: Adding New Functionality to PSI4; Modular Approach to Development; Creating a New Plugin; Creating a New Plugin Using a Conda Pre-compiled Binary; Files in a Plugin Directory. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Contributions: Intro to Programming in PSI4. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins-1.html
https://psicode.org/psi4manual/1.2.1/plugins-1.html:8347,Performance,load,loading,8347,"; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation. Please note that pure virtual functions in a plugin may cause undefined symbols errors when; the plugin is loaded.; To create a purely Python plugin, create a new plugin directory, then; remove the Makefile and myplugin.cc files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; input.dat as a model for loading the plugin, no recompile ever; necessary. table of contents. Plugins: Adding New Functionality to PSI4; Modular Approach to Development; Creating a New Plugin; Creating a New Plugin Using a Conda Pre-compiled Binary; Files in a Plugin Directory. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Contributions: Intro to Programming in PSI4. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins-1.html
https://psicode.org/psi4manual/1.2.1/plugins-1.html:8487,Performance,load,loading,8487,"; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation. Please note that pure virtual functions in a plugin may cause undefined symbols errors when; the plugin is loaded.; To create a purely Python plugin, create a new plugin directory, then; remove the Makefile and myplugin.cc files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; input.dat as a model for loading the plugin, no recompile ever; necessary. table of contents. Plugins: Adding New Functionality to PSI4; Modular Approach to Development; Creating a New Plugin; Creating a New Plugin Using a Conda Pre-compiled Binary; Files in a Plugin Directory. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Contributions: Intro to Programming in PSI4. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins-1.html
https://psicode.org/psi4manual/1.2.1/plugins-1.html:7033,Security,access,accessed,7033,"ctory to recompile the; myplugin.so executable, but recompiling the main PSI4 code; is not necessary. Should you add additional (non-header) files to; the plugin or need to link to additional external libraries, add that; information here.; input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file.; This is usually done by manipulating PSIPATH. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection.; pymodule.py — Python component of the plugin.; By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any doc",MatchSource.WIKI,psi4manual/1.2.1/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins-1.html
https://psicode.org/psi4manual/1.2.1/plugins-1.html:3464,Testability,test,testplugin,3464,"an use the gcc; compiler installed alongside psi4 itself in the Conda distribution; or environment (below, $PSI4CONDA). On Mac, one must use; libc++.so (not libstdc++.so), and this can be accomplished by; installing XCode from the App Store that provides clang and; clang++ compilers. Check environment; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18# yes, the following returns a blank line. yes, LD_LIBRARY_PATH irrelevant; >>> echo $PYTHONHOME $PYTHONPATH $DYLD_LIBRARY_PATH $PSIDATADIR. >>> which python psi4 g++ gfortran # Linux; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/gcc++; $PSI4CONDA/bin/gfortran; >>> which python psi4 g++ gfortran clang++ # Mac; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/g++; $PSI4CONDA/bin/gfortran; /usr/bin/clang++. >>> which cmake; $PSI4CONDA/bin/cmake; # if above empty, ``conda install cmake``. Create and compile plugin; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35; 36>>> psi4 --plugin-name testplugin; -- Creating ""testplugin"" with ""basic"" template. -----------------; ==> Created plugin files (in testplugin as basic):; __init__.py, CMakeLists.txt, doc.rst, input.dat, plugin.cc, pymodule.py. # move into plugin directory; >>> cd testplugin. # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++",MatchSource.WIKI,psi4manual/1.2.1/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins-1.html
https://psicode.org/psi4manual/1.2.1/plugins-1.html:3489,Testability,test,testplugin,3489,"an use the gcc; compiler installed alongside psi4 itself in the Conda distribution; or environment (below, $PSI4CONDA). On Mac, one must use; libc++.so (not libstdc++.so), and this can be accomplished by; installing XCode from the App Store that provides clang and; clang++ compilers. Check environment; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18# yes, the following returns a blank line. yes, LD_LIBRARY_PATH irrelevant; >>> echo $PYTHONHOME $PYTHONPATH $DYLD_LIBRARY_PATH $PSIDATADIR. >>> which python psi4 g++ gfortran # Linux; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/gcc++; $PSI4CONDA/bin/gfortran; >>> which python psi4 g++ gfortran clang++ # Mac; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/g++; $PSI4CONDA/bin/gfortran; /usr/bin/clang++. >>> which cmake; $PSI4CONDA/bin/cmake; # if above empty, ``conda install cmake``. Create and compile plugin; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35; 36>>> psi4 --plugin-name testplugin; -- Creating ""testplugin"" with ""basic"" template. -----------------; ==> Created plugin files (in testplugin as basic):; __init__.py, CMakeLists.txt, doc.rst, input.dat, plugin.cc, pymodule.py. # move into plugin directory; >>> cd testplugin. # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++",MatchSource.WIKI,psi4manual/1.2.1/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins-1.html
https://psicode.org/psi4manual/1.2.1/plugins-1.html:3572,Testability,test,testplugin,3572,"dc++.so), and this can be accomplished by; installing XCode from the App Store that provides clang and; clang++ compilers. Check environment; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18# yes, the following returns a blank line. yes, LD_LIBRARY_PATH irrelevant; >>> echo $PYTHONHOME $PYTHONPATH $DYLD_LIBRARY_PATH $PSIDATADIR. >>> which python psi4 g++ gfortran # Linux; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/gcc++; $PSI4CONDA/bin/gfortran; >>> which python psi4 g++ gfortran clang++ # Mac; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/g++; $PSI4CONDA/bin/gfortran; /usr/bin/clang++. >>> which cmake; $PSI4CONDA/bin/cmake; # if above empty, ``conda install cmake``. Create and compile plugin; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35; 36>>> psi4 --plugin-name testplugin; -- Creating ""testplugin"" with ""basic"" template. -----------------; ==> Created plugin files (in testplugin as basic):; __init__.py, CMakeLists.txt, doc.rst, input.dat, plugin.cc, pymodule.py. # move into plugin directory; >>> cd testplugin. # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencie",MatchSource.WIKI,psi4manual/1.2.1/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins-1.html
https://psicode.org/psi4manual/1.2.1/plugins-1.html:3705,Testability,test,testplugin,3705," environment; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18# yes, the following returns a blank line. yes, LD_LIBRARY_PATH irrelevant; >>> echo $PYTHONHOME $PYTHONPATH $DYLD_LIBRARY_PATH $PSIDATADIR. >>> which python psi4 g++ gfortran # Linux; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/gcc++; $PSI4CONDA/bin/gfortran; >>> which python psi4 g++ gfortran clang++ # Mac; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/g++; $PSI4CONDA/bin/gfortran; /usr/bin/clang++. >>> which cmake; $PSI4CONDA/bin/cmake; # if above empty, ``conda install cmake``. Create and compile plugin; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35; 36>>> psi4 --plugin-name testplugin; -- Creating ""testplugin"" with ""basic"" template. -----------------; ==> Created plugin files (in testplugin as basic):; __init__.py, CMakeLists.txt, doc.rst, input.dat, plugin.cc, pymodule.py. # move into plugin directory; >>> cd testplugin. # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencies of target testplugin; [ 50%] Building CXX object CMakeFiles/testplugin.dir/plugin.cc.o; [100%] Linking CXX shared module testp",MatchSource.WIKI,psi4manual/1.2.1/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins-1.html
https://psicode.org/psi4manual/1.2.1/plugins-1.html:4109,Testability,test,testplugin,4109,"SI4CONDA/bin/g++; $PSI4CONDA/bin/gfortran; /usr/bin/clang++. >>> which cmake; $PSI4CONDA/bin/cmake; # if above empty, ``conda install cmake``. Create and compile plugin; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35; 36>>> psi4 --plugin-name testplugin; -- Creating ""testplugin"" with ""basic"" template. -----------------; ==> Created plugin files (in testplugin as basic):; __init__.py, CMakeLists.txt, doc.rst, input.dat, plugin.cc, pymodule.py. # move into plugin directory; >>> cd testplugin. # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencies of target testplugin; [ 50%] Building CXX object CMakeFiles/testplugin.dir/plugin.cc.o; [100%] Linking CXX shared module testplugin.so; [100%] Built target testplugin. # run sample input.dat; >>> psi4; Attention! This SCF may be density-fitted. Please note that the conda distribution must be in $PATH or the; conda enviroment must be activated before compilation and execution of; plugins created using this procedure. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. CMakeLists.txt — CMake fil",MatchSource.WIKI,psi4manual/1.2.1/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins-1.html
https://psicode.org/psi4manual/1.2.1/plugins-1.html:4475,Testability,test,testplugin,4475,"-plugin-name testplugin; -- Creating ""testplugin"" with ""basic"" template. -----------------; ==> Created plugin files (in testplugin as basic):; __init__.py, CMakeLists.txt, doc.rst, input.dat, plugin.cc, pymodule.py. # move into plugin directory; >>> cd testplugin. # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencies of target testplugin; [ 50%] Building CXX object CMakeFiles/testplugin.dir/plugin.cc.o; [100%] Linking CXX shared module testplugin.so; [100%] Built target testplugin. # run sample input.dat; >>> psi4; Attention! This SCF may be density-fitted. Please note that the conda distribution must be in $PATH or the; conda enviroment must be activated before compilation and execution of; plugins created using this procedure. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. CMakeLists.txt — CMake file governing project plugin.; The plugin source and CMakeLists.txt is independent of platform; and PSI4 installation. You use CMake (version 3.1 or later); to generate a Makefile for the plugin by pointing it to a specific; PSI4 installation. Run psi4 --plugin-compile to get a command; to execute to generate the",MatchSource.WIKI,psi4manual/1.2.1/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins-1.html
https://psicode.org/psi4manual/1.2.1/plugins-1.html:4519,Testability,test,testplugin,4519,"asic"" template. -----------------; ==> Created plugin files (in testplugin as basic):; __init__.py, CMakeLists.txt, doc.rst, input.dat, plugin.cc, pymodule.py. # move into plugin directory; >>> cd testplugin. # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencies of target testplugin; [ 50%] Building CXX object CMakeFiles/testplugin.dir/plugin.cc.o; [100%] Linking CXX shared module testplugin.so; [100%] Built target testplugin. # run sample input.dat; >>> psi4; Attention! This SCF may be density-fitted. Please note that the conda distribution must be in $PATH or the; conda enviroment must be activated before compilation and execution of; plugins created using this procedure. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. CMakeLists.txt — CMake file governing project plugin.; The plugin source and CMakeLists.txt is independent of platform; and PSI4 installation. You use CMake (version 3.1 or later); to generate a Makefile for the plugin by pointing it to a specific; PSI4 installation. Run psi4 --plugin-compile to get a command; to execute to generate the Makefile. What that command is doing is; loading the com",MatchSource.WIKI,psi4manual/1.2.1/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins-1.html
https://psicode.org/psi4manual/1.2.1/plugins-1.html:4576,Testability,test,testplugin,4576,"as basic):; __init__.py, CMakeLists.txt, doc.rst, input.dat, plugin.cc, pymodule.py. # move into plugin directory; >>> cd testplugin. # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencies of target testplugin; [ 50%] Building CXX object CMakeFiles/testplugin.dir/plugin.cc.o; [100%] Linking CXX shared module testplugin.so; [100%] Built target testplugin. # run sample input.dat; >>> psi4; Attention! This SCF may be density-fitted. Please note that the conda distribution must be in $PATH or the; conda enviroment must be activated before compilation and execution of; plugins created using this procedure. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. CMakeLists.txt — CMake file governing project plugin.; The plugin source and CMakeLists.txt is independent of platform; and PSI4 installation. You use CMake (version 3.1 or later); to generate a Makefile for the plugin by pointing it to a specific; PSI4 installation. Run psi4 --plugin-compile to get a command; to execute to generate the Makefile. What that command is doing is; loading the compilers and options used to build the parent PSI4; (the -C psi4PluginCache pa",MatchSource.WIKI,psi4manual/1.2.1/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins-1.html
https://psicode.org/psi4manual/1.2.1/plugins-1.html:4626,Testability,test,testplugin,4626,"as basic):; __init__.py, CMakeLists.txt, doc.rst, input.dat, plugin.cc, pymodule.py. # move into plugin directory; >>> cd testplugin. # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencies of target testplugin; [ 50%] Building CXX object CMakeFiles/testplugin.dir/plugin.cc.o; [100%] Linking CXX shared module testplugin.so; [100%] Built target testplugin. # run sample input.dat; >>> psi4; Attention! This SCF may be density-fitted. Please note that the conda distribution must be in $PATH or the; conda enviroment must be activated before compilation and execution of; plugins created using this procedure. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. CMakeLists.txt — CMake file governing project plugin.; The plugin source and CMakeLists.txt is independent of platform; and PSI4 installation. You use CMake (version 3.1 or later); to generate a Makefile for the plugin by pointing it to a specific; PSI4 installation. Run psi4 --plugin-compile to get a command; to execute to generate the Makefile. What that command is doing is; loading the compilers and options used to build the parent PSI4; (the -C psi4PluginCache pa",MatchSource.WIKI,psi4manual/1.2.1/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins-1.html
https://psicode.org/psi4manual/1.2.1/plugins-1.html:4687,Testability,test,testplugin,4687," into plugin directory; >>> cd testplugin. # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencies of target testplugin; [ 50%] Building CXX object CMakeFiles/testplugin.dir/plugin.cc.o; [100%] Linking CXX shared module testplugin.so; [100%] Built target testplugin. # run sample input.dat; >>> psi4; Attention! This SCF may be density-fitted. Please note that the conda distribution must be in $PATH or the; conda enviroment must be activated before compilation and execution of; plugins created using this procedure. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. CMakeLists.txt — CMake file governing project plugin.; The plugin source and CMakeLists.txt is independent of platform; and PSI4 installation. You use CMake (version 3.1 or later); to generate a Makefile for the plugin by pointing it to a specific; PSI4 installation. Run psi4 --plugin-compile to get a command; to execute to generate the Makefile. What that command is doing is; loading the compilers and options used to build the parent PSI4; (the -C psi4PluginCache part) which in turn can be overridden; by passing -Doption=value commands to cmake and pointi",MatchSource.WIKI,psi4manual/1.2.1/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins-1.html
https://psicode.org/psi4manual/1.2.1/plugins-1.html:4722,Testability,test,testplugin,4722,". # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencies of target testplugin; [ 50%] Building CXX object CMakeFiles/testplugin.dir/plugin.cc.o; [100%] Linking CXX shared module testplugin.so; [100%] Built target testplugin. # run sample input.dat; >>> psi4; Attention! This SCF may be density-fitted. Please note that the conda distribution must be in $PATH or the; conda enviroment must be activated before compilation and execution of; plugins created using this procedure. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. CMakeLists.txt — CMake file governing project plugin.; The plugin source and CMakeLists.txt is independent of platform; and PSI4 installation. You use CMake (version 3.1 or later); to generate a Makefile for the plugin by pointing it to a specific; PSI4 installation. Run psi4 --plugin-compile to get a command; to execute to generate the Makefile. What that command is doing is; loading the compilers and options used to build the parent PSI4; (the -C psi4PluginCache part) which in turn can be overridden; by passing -Doption=value commands to cmake and pointing; toward a particular PSI4 (and probabl",MatchSource.WIKI,psi4manual/1.2.1/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins-1.html
https://psicode.org/psi4manual/1.2.1/plugins-1.html:6739,Testability,test,testfunction,6739,"E_PREFIX_PATH part) and telling it to; do an in-source build (the . part). Then just run make in; your plugin directory. After any change to the plugin C++ code,; make must be run in the plugin directory to recompile the; myplugin.so executable, but recompiling the main PSI4 code; is not necessary. Should you add additional (non-header) files to; the plugin or need to link to additional external libraries, add that; information here.; input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file.; This is usually done by manipulating PSIPATH. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection.; pymodule.py — Python component of the plugin.; By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the u",MatchSource.WIKI,psi4manual/1.2.1/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins-1.html
https://psicode.org/psi4manual/1.2.1/plugins-1.html:416,Usability,learn,learn,416,"﻿. Plugins: Adding New Functionality to PSI4. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Contributions: Intro to Programming in PSI4. Plugins: Adding New Functionality to PSI4¶. Modular Approach to Development¶; It is slightly cumbersome to the development cycle to recompile PSI4; every time a change is made to the C++ code.; It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with Psi3 due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; 1>>> psi4 --plugin-name myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory, use PSI4 to generate; a Makefile, and type make. Then execute psi4 in the directory on the; default input file.; 1; 2; 3; 4>>> cd myplugin; >>> `psi4 --plugin-compile`; >>> make; >>> psi4. PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; 1; 2; 3; 4; 5; 6>>> psi4 --plugin-name myplugin --plugin-template aointegrals; >>> psi4 --plugin-name myplugin --plugin-template mointegrals; >>> psi4 --plugin-name myplugin --plu",MatchSource.WIKI,psi4manual/1.2.1/plugins-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins-1.html
https://psicode.org/psi4manual/1.2.1/plugins.html:2846,Availability,echo,echo,2846,"ame myplugin --plugin-template aointegrals; >>> psi4 --plugin-name myplugin --plugin-template mointegrals; >>> psi4 --plugin-name myplugin --plugin-template sointegrals; >>> psi4 --plugin-name myplugin --plugin-template wavefunction; >>> psi4 --plugin-name myplugin --plugin-template scf; >>> psi4 --plugin-name myplugin --plugin-template dfmp2. Creating a New Plugin Using a Conda Pre-compiled Binary¶; PSI4 plugins can also be created using Conda for both PSI4; binary and development environment. On Linux (or Ubuntu shell on Windows), one can use the gcc; compiler installed alongside psi4 itself in the Conda distribution; or environment (below, $PSI4CONDA). On Mac, one must use; libc++.so (not libstdc++.so), and this can be accomplished by; installing XCode from the App Store that provides clang and; clang++ compilers. Check environment; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18# yes, the following returns a blank line. yes, LD_LIBRARY_PATH irrelevant; >>> echo $PYTHONHOME $PYTHONPATH $DYLD_LIBRARY_PATH $PSIDATADIR. >>> which python psi4 g++ gfortran # Linux; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/gcc++; $PSI4CONDA/bin/gfortran; >>> which python psi4 g++ gfortran clang++ # Mac; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/g++; $PSI4CONDA/bin/gfortran; /usr/bin/clang++. >>> which cmake; $PSI4CONDA/bin/cmake; # if above empty, ``conda install cmake``. Create and compile plugin; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35; 36>>> psi4 --plugin-name testplugin; -- Creating ""testplugin"" with ""basic"" template. -----------------; ==> Created plugin files (in testplugin as basic):; __init__.py, CMakeLists.txt, doc.rst, input.dat, plugin.cc, pymodule.py. # move into plugin directory; >>> cd testplugin. # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/p",MatchSource.WIKI,psi4manual/1.2.1/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins.html
https://psicode.org/psi4manual/1.2.1/plugins.html:6693,Availability,avail,available,6693,"ticular PSI4 (and probably pybind11) library to; link against (the CMAKE_PREFIX_PATH part) and telling it to; do an in-source build (the . part). Then just run make in; your plugin directory. After any change to the plugin C++ code,; make must be run in the plugin directory to recompile the; myplugin.so executable, but recompiling the main PSI4 code; is not necessary. Should you add additional (non-header) files to; the plugin or need to link to additional external libraries, add that; information here.; input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file.; This is usually done by manipulating PSIPATH. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection.; pymodule.py — Python component of the plugin.; By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, ",MatchSource.WIKI,psi4manual/1.2.1/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins.html
https://psicode.org/psi4manual/1.2.1/plugins.html:8169,Availability,error,errors,8169,"; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation. Please note that pure virtual functions in a plugin may cause undefined symbols errors when; the plugin is loaded.; To create a purely Python plugin, create a new plugin directory, then; remove the Makefile and myplugin.cc files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; input.dat as a model for loading the plugin, no recompile ever; necessary. table of contents. Plugins: Adding New Functionality to PSI4; Modular Approach to Development; Creating a New Plugin; Creating a New Plugin Using a Conda Pre-compiled Binary; Files in a Plugin Directory. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Contributions: Intro to Programming in PSI4. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins.html
https://psicode.org/psi4manual/1.2.1/plugins.html:2426,Deployability,install,installed,2426,"e PSI4 to generate; a Makefile, and type make. Then execute psi4 in the directory on the; default input file.; 1; 2; 3; 4>>> cd myplugin; >>> `psi4 --plugin-compile`; >>> make; >>> psi4. PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; 1; 2; 3; 4; 5; 6>>> psi4 --plugin-name myplugin --plugin-template aointegrals; >>> psi4 --plugin-name myplugin --plugin-template mointegrals; >>> psi4 --plugin-name myplugin --plugin-template sointegrals; >>> psi4 --plugin-name myplugin --plugin-template wavefunction; >>> psi4 --plugin-name myplugin --plugin-template scf; >>> psi4 --plugin-name myplugin --plugin-template dfmp2. Creating a New Plugin Using a Conda Pre-compiled Binary¶; PSI4 plugins can also be created using Conda for both PSI4; binary and development environment. On Linux (or Ubuntu shell on Windows), one can use the gcc; compiler installed alongside psi4 itself in the Conda distribution; or environment (below, $PSI4CONDA). On Mac, one must use; libc++.so (not libstdc++.so), and this can be accomplished by; installing XCode from the App Store that provides clang and; clang++ compilers. Check environment; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18# yes, the following returns a blank line. yes, LD_LIBRARY_PATH irrelevant; >>> echo $PYTHONHOME $PYTHONPATH $DYLD_LIBRARY_PATH $PSIDATADIR. >>> which python psi4 g++ gfortran # Linux; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/gcc++; $PSI4CONDA/bin/gfortran; >>> which python psi4 g++ gfortran clang++ # Mac; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/g++; $PSI4CONDA/bin/gfortran; /usr/bin/clang++. >>> which cmake; $PSI4CONDA/bin/cmake; # if above empty, ``conda install cmake``. Create and compile plugin; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35;",MatchSource.WIKI,psi4manual/1.2.1/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins.html
https://psicode.org/psi4manual/1.2.1/plugins.html:2606,Deployability,install,installing,2606,"SI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; 1; 2; 3; 4; 5; 6>>> psi4 --plugin-name myplugin --plugin-template aointegrals; >>> psi4 --plugin-name myplugin --plugin-template mointegrals; >>> psi4 --plugin-name myplugin --plugin-template sointegrals; >>> psi4 --plugin-name myplugin --plugin-template wavefunction; >>> psi4 --plugin-name myplugin --plugin-template scf; >>> psi4 --plugin-name myplugin --plugin-template dfmp2. Creating a New Plugin Using a Conda Pre-compiled Binary¶; PSI4 plugins can also be created using Conda for both PSI4; binary and development environment. On Linux (or Ubuntu shell on Windows), one can use the gcc; compiler installed alongside psi4 itself in the Conda distribution; or environment (below, $PSI4CONDA). On Mac, one must use; libc++.so (not libstdc++.so), and this can be accomplished by; installing XCode from the App Store that provides clang and; clang++ compilers. Check environment; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18# yes, the following returns a blank line. yes, LD_LIBRARY_PATH irrelevant; >>> echo $PYTHONHOME $PYTHONPATH $DYLD_LIBRARY_PATH $PSIDATADIR. >>> which python psi4 g++ gfortran # Linux; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/gcc++; $PSI4CONDA/bin/gfortran; >>> which python psi4 g++ gfortran clang++ # Mac; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/g++; $PSI4CONDA/bin/gfortran; /usr/bin/clang++. >>> which cmake; $PSI4CONDA/bin/cmake; # if above empty, ``conda install cmake``. Create and compile plugin; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35; 36>>> psi4 --plugin-name testplugin; -- Creating ""testplugin"" with ""basic"" template. -----------------; ==> Created plugin files (in testplugin as basic):; __init__.py, CMakeLists.txt, doc",MatchSource.WIKI,psi4manual/1.2.1/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins.html
https://psicode.org/psi4manual/1.2.1/plugins.html:3264,Deployability,install,install,3264,"Pre-compiled Binary¶; PSI4 plugins can also be created using Conda for both PSI4; binary and development environment. On Linux (or Ubuntu shell on Windows), one can use the gcc; compiler installed alongside psi4 itself in the Conda distribution; or environment (below, $PSI4CONDA). On Mac, one must use; libc++.so (not libstdc++.so), and this can be accomplished by; installing XCode from the App Store that provides clang and; clang++ compilers. Check environment; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18# yes, the following returns a blank line. yes, LD_LIBRARY_PATH irrelevant; >>> echo $PYTHONHOME $PYTHONPATH $DYLD_LIBRARY_PATH $PSIDATADIR. >>> which python psi4 g++ gfortran # Linux; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/gcc++; $PSI4CONDA/bin/gfortran; >>> which python psi4 g++ gfortran clang++ # Mac; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/g++; $PSI4CONDA/bin/gfortran; /usr/bin/clang++. >>> which cmake; $PSI4CONDA/bin/cmake; # if above empty, ``conda install cmake``. Create and compile plugin; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35; 36>>> psi4 --plugin-name testplugin; -- Creating ""testplugin"" with ""basic"" template. -----------------; ==> Created plugin files (in testplugin as basic):; __init__.py, CMakeLists.txt, doc.rst, input.dat, plugin.cc, pymodule.py. # move into plugin directory; >>> cd testplugin. # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- Th",MatchSource.WIKI,psi4manual/1.2.1/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins.html
https://psicode.org/psi4manual/1.2.1/plugins.html:5242,Deployability,install,installation,5242,"make; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencies of target testplugin; [ 50%] Building CXX object CMakeFiles/testplugin.dir/plugin.cc.o; [100%] Linking CXX shared module testplugin.so; [100%] Built target testplugin. # run sample input.dat; >>> psi4; Attention! This SCF may be density-fitted. Please note that the conda distribution must be in $PATH or the; conda enviroment must be activated before compilation and execution of; plugins created using this procedure. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. CMakeLists.txt — CMake file governing project plugin.; The plugin source and CMakeLists.txt is independent of platform; and PSI4 installation. You use CMake (version 3.1 or later); to generate a Makefile for the plugin by pointing it to a specific; PSI4 installation. Run psi4 --plugin-compile to get a command; to execute to generate the Makefile. What that command is doing is; loading the compilers and options used to build the parent PSI4; (the -C psi4PluginCache part) which in turn can be overridden; by passing -Doption=value commands to cmake and pointing; toward a particular PSI4 (and probably pybind11) library to; link against (the CMAKE_PREFIX_PATH part) and telling it to; do an in-source build (the . part). Then just run make in; your plugin directory. After any change to the plugin C++ code,; make must be run in the plugin directory to recompile the; myplugin.so executable, but recompiling the main PSI4 code; is not necessary. Should you add additional (non-header) files to; the plugin or need to link to additional external libraries, add that; information here.; input.dat — Sample input fi",MatchSource.WIKI,psi4manual/1.2.1/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins.html
https://psicode.org/psi4manual/1.2.1/plugins.html:5367,Deployability,install,installation,5367,"r: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencies of target testplugin; [ 50%] Building CXX object CMakeFiles/testplugin.dir/plugin.cc.o; [100%] Linking CXX shared module testplugin.so; [100%] Built target testplugin. # run sample input.dat; >>> psi4; Attention! This SCF may be density-fitted. Please note that the conda distribution must be in $PATH or the; conda enviroment must be activated before compilation and execution of; plugins created using this procedure. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. CMakeLists.txt — CMake file governing project plugin.; The plugin source and CMakeLists.txt is independent of platform; and PSI4 installation. You use CMake (version 3.1 or later); to generate a Makefile for the plugin by pointing it to a specific; PSI4 installation. Run psi4 --plugin-compile to get a command; to execute to generate the Makefile. What that command is doing is; loading the compilers and options used to build the parent PSI4; (the -C psi4PluginCache part) which in turn can be overridden; by passing -Doption=value commands to cmake and pointing; toward a particular PSI4 (and probably pybind11) library to; link against (the CMAKE_PREFIX_PATH part) and telling it to; do an in-source build (the . part). Then just run make in; your plugin directory. After any change to the plugin C++ code,; make must be run in the plugin directory to recompile the; myplugin.so executable, but recompiling the main PSI4 code; is not necessary. Should you add additional (non-header) files to; the plugin or need to link to additional external libraries, add that; information here.; input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, t",MatchSource.WIKI,psi4manual/1.2.1/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins.html
https://psicode.org/psi4manual/1.2.1/plugins.html:8932,Deployability,update,updated,8932,"; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation. Please note that pure virtual functions in a plugin may cause undefined symbols errors when; the plugin is loaded.; To create a purely Python plugin, create a new plugin directory, then; remove the Makefile and myplugin.cc files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; input.dat as a model for loading the plugin, no recompile ever; necessary. table of contents. Plugins: Adding New Functionality to PSI4; Modular Approach to Development; Creating a New Plugin; Creating a New Plugin Using a Conda Pre-compiled Binary; Files in a Plugin Directory. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Contributions: Intro to Programming in PSI4. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins.html
https://psicode.org/psi4manual/1.2.1/plugins.html:6637,Energy Efficiency,energy,energy,6637,"rridden; by passing -Doption=value commands to cmake and pointing; toward a particular PSI4 (and probably pybind11) library to; link against (the CMAKE_PREFIX_PATH part) and telling it to; do an in-source build (the . part). Then just run make in; your plugin directory. After any change to the plugin C++ code,; make must be run in the plugin directory to recompile the; myplugin.so executable, but recompiling the main PSI4 code; is not necessary. Should you add additional (non-header) files to; the plugin or need to link to additional external libraries, add that; information here.; input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file.; This is usually done by manipulating PSIPATH. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection.; pymodule.py — Python component of the plugin.; By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section). doc.rst — D",MatchSource.WIKI,psi4manual/1.2.1/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins.html
https://psicode.org/psi4manual/1.2.1/plugins.html:7010,Energy Efficiency,energy,energy,7010,"ctory to recompile the; myplugin.so executable, but recompiling the main PSI4 code; is not necessary. Should you add additional (non-header) files to; the plugin or need to link to additional external libraries, add that; information here.; input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file.; This is usually done by manipulating PSIPATH. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection.; pymodule.py — Python component of the plugin.; By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any doc",MatchSource.WIKI,psi4manual/1.2.1/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins.html
https://psicode.org/psi4manual/1.2.1/plugins.html:7051,Energy Efficiency,energy,energy,7051,"ctory to recompile the; myplugin.so executable, but recompiling the main PSI4 code; is not necessary. Should you add additional (non-header) files to; the plugin or need to link to additional external libraries, add that; information here.; input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file.; This is usually done by manipulating PSIPATH. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection.; pymodule.py — Python component of the plugin.; By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any doc",MatchSource.WIKI,psi4manual/1.2.1/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins.html
https://psicode.org/psi4manual/1.2.1/plugins.html:4553,Integrability,depend,dependencies,4553,"as basic):; __init__.py, CMakeLists.txt, doc.rst, input.dat, plugin.cc, pymodule.py. # move into plugin directory; >>> cd testplugin. # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencies of target testplugin; [ 50%] Building CXX object CMakeFiles/testplugin.dir/plugin.cc.o; [100%] Linking CXX shared module testplugin.so; [100%] Built target testplugin. # run sample input.dat; >>> psi4; Attention! This SCF may be density-fitted. Please note that the conda distribution must be in $PATH or the; conda enviroment must be activated before compilation and execution of; plugins created using this procedure. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. CMakeLists.txt — CMake file governing project plugin.; The plugin source and CMakeLists.txt is independent of platform; and PSI4 installation. You use CMake (version 3.1 or later); to generate a Makefile for the plugin by pointing it to a specific; PSI4 installation. Run psi4 --plugin-compile to get a command; to execute to generate the Makefile. What that command is doing is; loading the compilers and options used to build the parent PSI4; (the -C psi4PluginCache pa",MatchSource.WIKI,psi4manual/1.2.1/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins.html
https://psicode.org/psi4manual/1.2.1/plugins.html:7440,Integrability,depend,depends,7440," as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file.; This is usually done by manipulating PSIPATH. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection.; pymodule.py — Python component of the plugin.; By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation. Please note that pure virtual functions in a plugin may cause undefined symbols errors when; the plugin is loaded.; To create a purely Python plugin, create a new plugin directory, then; remove the Makefile and myplugin.cc files and; erase the shared object loading ",MatchSource.WIKI,psi4manual/1.2.1/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins.html
https://psicode.org/psi4manual/1.2.1/plugins.html:696,Modifiability,plugin,plugin,696,"﻿. Plugins: Adding New Functionality to PSI4. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Contributions: Intro to Programming in PSI4. Plugins: Adding New Functionality to PSI4¶. Modular Approach to Development¶; It is slightly cumbersome to the development cycle to recompile PSI4; every time a change is made to the C++ code.; It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with Psi3 due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; 1>>> psi4 --plugin-name myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory, use PSI4 to generate; a Makefile, and type make. Then execute psi4 in the directory on the; default input file.; 1; 2; 3; 4>>> cd myplugin; >>> `psi4 --plugin-compile`; >>> make; >>> psi4. PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; 1; 2; 3; 4; 5; 6>>> psi4 --plugin-name myplugin --plugin-template aointegrals; >>> psi4 --plugin-name myplugin --plugin-template mointegrals; >>> psi4 --plugin-name myplugin --plu",MatchSource.WIKI,psi4manual/1.2.1/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins.html
https://psicode.org/psi4manual/1.2.1/plugins.html:875,Modifiability,plugin,plugins,875,"﻿. Plugins: Adding New Functionality to PSI4. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Contributions: Intro to Programming in PSI4. Plugins: Adding New Functionality to PSI4¶. Modular Approach to Development¶; It is slightly cumbersome to the development cycle to recompile PSI4; every time a change is made to the C++ code.; It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with Psi3 due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; 1>>> psi4 --plugin-name myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory, use PSI4 to generate; a Makefile, and type make. Then execute psi4 in the directory on the; default input file.; 1; 2; 3; 4>>> cd myplugin; >>> `psi4 --plugin-compile`; >>> make; >>> psi4. PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; 1; 2; 3; 4; 5; 6>>> psi4 --plugin-name myplugin --plugin-template aointegrals; >>> psi4 --plugin-name myplugin --plugin-template mointegrals; >>> psi4 --plugin-name myplugin --plu",MatchSource.WIKI,psi4manual/1.2.1/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins.html
https://psicode.org/psi4manual/1.2.1/plugins.html:975,Modifiability,plugin,plugins,975,"﻿. Plugins: Adding New Functionality to PSI4. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Contributions: Intro to Programming in PSI4. Plugins: Adding New Functionality to PSI4¶. Modular Approach to Development¶; It is slightly cumbersome to the development cycle to recompile PSI4; every time a change is made to the C++ code.; It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with Psi3 due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; 1>>> psi4 --plugin-name myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory, use PSI4 to generate; a Makefile, and type make. Then execute psi4 in the directory on the; default input file.; 1; 2; 3; 4>>> cd myplugin; >>> `psi4 --plugin-compile`; >>> make; >>> psi4. PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; 1; 2; 3; 4; 5; 6>>> psi4 --plugin-name myplugin --plugin-template aointegrals; >>> psi4 --plugin-name myplugin --plugin-template mointegrals; >>> psi4 --plugin-name myplugin --plu",MatchSource.WIKI,psi4manual/1.2.1/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins.html
https://psicode.org/psi4manual/1.2.1/plugins.html:1073,Modifiability,plugin,plugin,1073,"· . PSI4. Contributions: Intro to Programming in PSI4. Plugins: Adding New Functionality to PSI4¶. Modular Approach to Development¶; It is slightly cumbersome to the development cycle to recompile PSI4; every time a change is made to the C++ code.; It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with Psi3 due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; 1>>> psi4 --plugin-name myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory, use PSI4 to generate; a Makefile, and type make. Then execute psi4 in the directory on the; default input file.; 1; 2; 3; 4>>> cd myplugin; >>> `psi4 --plugin-compile`; >>> make; >>> psi4. PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; 1; 2; 3; 4; 5; 6>>> psi4 --plugin-name myplugin --plugin-template aointegrals; >>> psi4 --plugin-name myplugin --plugin-template mointegrals; >>> psi4 --plugin-name myplugin --plugin-template sointegrals; >>> psi4 --plugin-name myplugin --plugin-template wavefunction; >>> psi4 --plug",MatchSource.WIKI,psi4manual/1.2.1/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins.html
https://psicode.org/psi4manual/1.2.1/plugins.html:1231,Modifiability,plugin,plugin-name,1231,"nt¶; It is slightly cumbersome to the development cycle to recompile PSI4; every time a change is made to the C++ code.; It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with Psi3 due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; 1>>> psi4 --plugin-name myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory, use PSI4 to generate; a Makefile, and type make. Then execute psi4 in the directory on the; default input file.; 1; 2; 3; 4>>> cd myplugin; >>> `psi4 --plugin-compile`; >>> make; >>> psi4. PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; 1; 2; 3; 4; 5; 6>>> psi4 --plugin-name myplugin --plugin-template aointegrals; >>> psi4 --plugin-name myplugin --plugin-template mointegrals; >>> psi4 --plugin-name myplugin --plugin-template sointegrals; >>> psi4 --plugin-name myplugin --plugin-template wavefunction; >>> psi4 --plugin-name myplugin --plugin-template scf; >>> psi4 --plugin-name myplugin --plugin-template dfmp2. Creating a New Plugin Using a Co",MatchSource.WIKI,psi4manual/1.2.1/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins.html
https://psicode.org/psi4manual/1.2.1/plugins.html:1321,Modifiability,plugin,plugin,1321,"to recompile PSI4; every time a change is made to the C++ code.; It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with Psi3 due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; 1>>> psi4 --plugin-name myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory, use PSI4 to generate; a Makefile, and type make. Then execute psi4 in the directory on the; default input file.; 1; 2; 3; 4>>> cd myplugin; >>> `psi4 --plugin-compile`; >>> make; >>> psi4. PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; 1; 2; 3; 4; 5; 6>>> psi4 --plugin-name myplugin --plugin-template aointegrals; >>> psi4 --plugin-name myplugin --plugin-template mointegrals; >>> psi4 --plugin-name myplugin --plugin-template sointegrals; >>> psi4 --plugin-name myplugin --plugin-template wavefunction; >>> psi4 --plugin-name myplugin --plugin-template scf; >>> psi4 --plugin-name myplugin --plugin-template dfmp2. Creating a New Plugin Using a Conda Pre-compiled Binary¶; PSI4 plugins can also be crea",MatchSource.WIKI,psi4manual/1.2.1/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins.html
https://psicode.org/psi4manual/1.2.1/plugins.html:1588,Modifiability,plugin,plugin-compile,1588,"em with Psi3 due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; 1>>> psi4 --plugin-name myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory, use PSI4 to generate; a Makefile, and type make. Then execute psi4 in the directory on the; default input file.; 1; 2; 3; 4>>> cd myplugin; >>> `psi4 --plugin-compile`; >>> make; >>> psi4. PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; 1; 2; 3; 4; 5; 6>>> psi4 --plugin-name myplugin --plugin-template aointegrals; >>> psi4 --plugin-name myplugin --plugin-template mointegrals; >>> psi4 --plugin-name myplugin --plugin-template sointegrals; >>> psi4 --plugin-name myplugin --plugin-template wavefunction; >>> psi4 --plugin-name myplugin --plugin-template scf; >>> psi4 --plugin-name myplugin --plugin-template dfmp2. Creating a New Plugin Using a Conda Pre-compiled Binary¶; PSI4 plugins can also be created using Conda for both PSI4; binary and development environment. On Linux (or Ubuntu shell on Windows), one can use the gcc; compiler installed alongside psi4 itself in the Conda distribution; or environment (below, $PSI4CONDA). On Mac, one must use; libc++.so (not libstdc++.so), and this can ",MatchSource.WIKI,psi4manual/1.2.1/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins.html
https://psicode.org/psi4manual/1.2.1/plugins.html:1849,Modifiability,plugin,plugin-name,1849," for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; 1>>> psi4 --plugin-name myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory, use PSI4 to generate; a Makefile, and type make. Then execute psi4 in the directory on the; default input file.; 1; 2; 3; 4>>> cd myplugin; >>> `psi4 --plugin-compile`; >>> make; >>> psi4. PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; 1; 2; 3; 4; 5; 6>>> psi4 --plugin-name myplugin --plugin-template aointegrals; >>> psi4 --plugin-name myplugin --plugin-template mointegrals; >>> psi4 --plugin-name myplugin --plugin-template sointegrals; >>> psi4 --plugin-name myplugin --plugin-template wavefunction; >>> psi4 --plugin-name myplugin --plugin-template scf; >>> psi4 --plugin-name myplugin --plugin-template dfmp2. Creating a New Plugin Using a Conda Pre-compiled Binary¶; PSI4 plugins can also be created using Conda for both PSI4; binary and development environment. On Linux (or Ubuntu shell on Windows), one can use the gcc; compiler installed alongside psi4 itself in the Conda distribution; or environment (below, $PSI4CONDA). On Mac, one must use; libc++.so (not libstdc++.so), and this can be accomplished by; installing XCode from the App Store that provides clang and; clang++ compilers. Check environment; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18# yes, the following returns a blank line. yes, LD_LIBRARY_PATH irrelevant; >>> echo $PYTHONHOME $PYTHONPATH $DYLD_LIBRARY_PATH $PSIDATADIR. >>> which python psi4 g++ gfortran # Linux; $PSI4CONDA/bin/python; $PSI4CON",MatchSource.WIKI,psi4manual/1.2.1/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins.html
https://psicode.org/psi4manual/1.2.1/plugins.html:1872,Modifiability,plugin,plugin-template,1872," for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; 1>>> psi4 --plugin-name myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory, use PSI4 to generate; a Makefile, and type make. Then execute psi4 in the directory on the; default input file.; 1; 2; 3; 4>>> cd myplugin; >>> `psi4 --plugin-compile`; >>> make; >>> psi4. PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; 1; 2; 3; 4; 5; 6>>> psi4 --plugin-name myplugin --plugin-template aointegrals; >>> psi4 --plugin-name myplugin --plugin-template mointegrals; >>> psi4 --plugin-name myplugin --plugin-template sointegrals; >>> psi4 --plugin-name myplugin --plugin-template wavefunction; >>> psi4 --plugin-name myplugin --plugin-template scf; >>> psi4 --plugin-name myplugin --plugin-template dfmp2. Creating a New Plugin Using a Conda Pre-compiled Binary¶; PSI4 plugins can also be created using Conda for both PSI4; binary and development environment. On Linux (or Ubuntu shell on Windows), one can use the gcc; compiler installed alongside psi4 itself in the Conda distribution; or environment (below, $PSI4CONDA). On Mac, one must use; libc++.so (not libstdc++.so), and this can be accomplished by; installing XCode from the App Store that provides clang and; clang++ compilers. Check environment; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18# yes, the following returns a blank line. yes, LD_LIBRARY_PATH irrelevant; >>> echo $PYTHONHOME $PYTHONPATH $DYLD_LIBRARY_PATH $PSIDATADIR. >>> which python psi4 g++ gfortran # Linux; $PSI4CONDA/bin/python; $PSI4CON",MatchSource.WIKI,psi4manual/1.2.1/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins.html
https://psicode.org/psi4manual/1.2.1/plugins.html:1912,Modifiability,plugin,plugin-name,1912," for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; 1>>> psi4 --plugin-name myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory, use PSI4 to generate; a Makefile, and type make. Then execute psi4 in the directory on the; default input file.; 1; 2; 3; 4>>> cd myplugin; >>> `psi4 --plugin-compile`; >>> make; >>> psi4. PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; 1; 2; 3; 4; 5; 6>>> psi4 --plugin-name myplugin --plugin-template aointegrals; >>> psi4 --plugin-name myplugin --plugin-template mointegrals; >>> psi4 --plugin-name myplugin --plugin-template sointegrals; >>> psi4 --plugin-name myplugin --plugin-template wavefunction; >>> psi4 --plugin-name myplugin --plugin-template scf; >>> psi4 --plugin-name myplugin --plugin-template dfmp2. Creating a New Plugin Using a Conda Pre-compiled Binary¶; PSI4 plugins can also be created using Conda for both PSI4; binary and development environment. On Linux (or Ubuntu shell on Windows), one can use the gcc; compiler installed alongside psi4 itself in the Conda distribution; or environment (below, $PSI4CONDA). On Mac, one must use; libc++.so (not libstdc++.so), and this can be accomplished by; installing XCode from the App Store that provides clang and; clang++ compilers. Check environment; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18# yes, the following returns a blank line. yes, LD_LIBRARY_PATH irrelevant; >>> echo $PYTHONHOME $PYTHONPATH $DYLD_LIBRARY_PATH $PSIDATADIR. >>> which python psi4 g++ gfortran # Linux; $PSI4CONDA/bin/python; $PSI4CON",MatchSource.WIKI,psi4manual/1.2.1/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins.html
https://psicode.org/psi4manual/1.2.1/plugins.html:1935,Modifiability,plugin,plugin-template,1935," for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; 1>>> psi4 --plugin-name myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory, use PSI4 to generate; a Makefile, and type make. Then execute psi4 in the directory on the; default input file.; 1; 2; 3; 4>>> cd myplugin; >>> `psi4 --plugin-compile`; >>> make; >>> psi4. PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; 1; 2; 3; 4; 5; 6>>> psi4 --plugin-name myplugin --plugin-template aointegrals; >>> psi4 --plugin-name myplugin --plugin-template mointegrals; >>> psi4 --plugin-name myplugin --plugin-template sointegrals; >>> psi4 --plugin-name myplugin --plugin-template wavefunction; >>> psi4 --plugin-name myplugin --plugin-template scf; >>> psi4 --plugin-name myplugin --plugin-template dfmp2. Creating a New Plugin Using a Conda Pre-compiled Binary¶; PSI4 plugins can also be created using Conda for both PSI4; binary and development environment. On Linux (or Ubuntu shell on Windows), one can use the gcc; compiler installed alongside psi4 itself in the Conda distribution; or environment (below, $PSI4CONDA). On Mac, one must use; libc++.so (not libstdc++.so), and this can be accomplished by; installing XCode from the App Store that provides clang and; clang++ compilers. Check environment; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18# yes, the following returns a blank line. yes, LD_LIBRARY_PATH irrelevant; >>> echo $PYTHONHOME $PYTHONPATH $DYLD_LIBRARY_PATH $PSIDATADIR. >>> which python psi4 g++ gfortran # Linux; $PSI4CONDA/bin/python; $PSI4CON",MatchSource.WIKI,psi4manual/1.2.1/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins.html
https://psicode.org/psi4manual/1.2.1/plugins.html:1975,Modifiability,plugin,plugin-name,1975," for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; 1>>> psi4 --plugin-name myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory, use PSI4 to generate; a Makefile, and type make. Then execute psi4 in the directory on the; default input file.; 1; 2; 3; 4>>> cd myplugin; >>> `psi4 --plugin-compile`; >>> make; >>> psi4. PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; 1; 2; 3; 4; 5; 6>>> psi4 --plugin-name myplugin --plugin-template aointegrals; >>> psi4 --plugin-name myplugin --plugin-template mointegrals; >>> psi4 --plugin-name myplugin --plugin-template sointegrals; >>> psi4 --plugin-name myplugin --plugin-template wavefunction; >>> psi4 --plugin-name myplugin --plugin-template scf; >>> psi4 --plugin-name myplugin --plugin-template dfmp2. Creating a New Plugin Using a Conda Pre-compiled Binary¶; PSI4 plugins can also be created using Conda for both PSI4; binary and development environment. On Linux (or Ubuntu shell on Windows), one can use the gcc; compiler installed alongside psi4 itself in the Conda distribution; or environment (below, $PSI4CONDA). On Mac, one must use; libc++.so (not libstdc++.so), and this can be accomplished by; installing XCode from the App Store that provides clang and; clang++ compilers. Check environment; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18# yes, the following returns a blank line. yes, LD_LIBRARY_PATH irrelevant; >>> echo $PYTHONHOME $PYTHONPATH $DYLD_LIBRARY_PATH $PSIDATADIR. >>> which python psi4 g++ gfortran # Linux; $PSI4CONDA/bin/python; $PSI4CON",MatchSource.WIKI,psi4manual/1.2.1/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins.html
https://psicode.org/psi4manual/1.2.1/plugins.html:1998,Modifiability,plugin,plugin-template,1998," for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; 1>>> psi4 --plugin-name myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory, use PSI4 to generate; a Makefile, and type make. Then execute psi4 in the directory on the; default input file.; 1; 2; 3; 4>>> cd myplugin; >>> `psi4 --plugin-compile`; >>> make; >>> psi4. PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; 1; 2; 3; 4; 5; 6>>> psi4 --plugin-name myplugin --plugin-template aointegrals; >>> psi4 --plugin-name myplugin --plugin-template mointegrals; >>> psi4 --plugin-name myplugin --plugin-template sointegrals; >>> psi4 --plugin-name myplugin --plugin-template wavefunction; >>> psi4 --plugin-name myplugin --plugin-template scf; >>> psi4 --plugin-name myplugin --plugin-template dfmp2. Creating a New Plugin Using a Conda Pre-compiled Binary¶; PSI4 plugins can also be created using Conda for both PSI4; binary and development environment. On Linux (or Ubuntu shell on Windows), one can use the gcc; compiler installed alongside psi4 itself in the Conda distribution; or environment (below, $PSI4CONDA). On Mac, one must use; libc++.so (not libstdc++.so), and this can be accomplished by; installing XCode from the App Store that provides clang and; clang++ compilers. Check environment; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18# yes, the following returns a blank line. yes, LD_LIBRARY_PATH irrelevant; >>> echo $PYTHONHOME $PYTHONPATH $DYLD_LIBRARY_PATH $PSIDATADIR. >>> which python psi4 g++ gfortran # Linux; $PSI4CONDA/bin/python; $PSI4CON",MatchSource.WIKI,psi4manual/1.2.1/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins.html
https://psicode.org/psi4manual/1.2.1/plugins.html:2038,Modifiability,plugin,plugin-name,2038," for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; 1>>> psi4 --plugin-name myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory, use PSI4 to generate; a Makefile, and type make. Then execute psi4 in the directory on the; default input file.; 1; 2; 3; 4>>> cd myplugin; >>> `psi4 --plugin-compile`; >>> make; >>> psi4. PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; 1; 2; 3; 4; 5; 6>>> psi4 --plugin-name myplugin --plugin-template aointegrals; >>> psi4 --plugin-name myplugin --plugin-template mointegrals; >>> psi4 --plugin-name myplugin --plugin-template sointegrals; >>> psi4 --plugin-name myplugin --plugin-template wavefunction; >>> psi4 --plugin-name myplugin --plugin-template scf; >>> psi4 --plugin-name myplugin --plugin-template dfmp2. Creating a New Plugin Using a Conda Pre-compiled Binary¶; PSI4 plugins can also be created using Conda for both PSI4; binary and development environment. On Linux (or Ubuntu shell on Windows), one can use the gcc; compiler installed alongside psi4 itself in the Conda distribution; or environment (below, $PSI4CONDA). On Mac, one must use; libc++.so (not libstdc++.so), and this can be accomplished by; installing XCode from the App Store that provides clang and; clang++ compilers. Check environment; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18# yes, the following returns a blank line. yes, LD_LIBRARY_PATH irrelevant; >>> echo $PYTHONHOME $PYTHONPATH $DYLD_LIBRARY_PATH $PSIDATADIR. >>> which python psi4 g++ gfortran # Linux; $PSI4CONDA/bin/python; $PSI4CON",MatchSource.WIKI,psi4manual/1.2.1/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins.html
https://psicode.org/psi4manual/1.2.1/plugins.html:2061,Modifiability,plugin,plugin-template,2061," for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; 1>>> psi4 --plugin-name myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory, use PSI4 to generate; a Makefile, and type make. Then execute psi4 in the directory on the; default input file.; 1; 2; 3; 4>>> cd myplugin; >>> `psi4 --plugin-compile`; >>> make; >>> psi4. PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; 1; 2; 3; 4; 5; 6>>> psi4 --plugin-name myplugin --plugin-template aointegrals; >>> psi4 --plugin-name myplugin --plugin-template mointegrals; >>> psi4 --plugin-name myplugin --plugin-template sointegrals; >>> psi4 --plugin-name myplugin --plugin-template wavefunction; >>> psi4 --plugin-name myplugin --plugin-template scf; >>> psi4 --plugin-name myplugin --plugin-template dfmp2. Creating a New Plugin Using a Conda Pre-compiled Binary¶; PSI4 plugins can also be created using Conda for both PSI4; binary and development environment. On Linux (or Ubuntu shell on Windows), one can use the gcc; compiler installed alongside psi4 itself in the Conda distribution; or environment (below, $PSI4CONDA). On Mac, one must use; libc++.so (not libstdc++.so), and this can be accomplished by; installing XCode from the App Store that provides clang and; clang++ compilers. Check environment; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18# yes, the following returns a blank line. yes, LD_LIBRARY_PATH irrelevant; >>> echo $PYTHONHOME $PYTHONPATH $DYLD_LIBRARY_PATH $PSIDATADIR. >>> which python psi4 g++ gfortran # Linux; $PSI4CONDA/bin/python; $PSI4CON",MatchSource.WIKI,psi4manual/1.2.1/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins.html
https://psicode.org/psi4manual/1.2.1/plugins.html:2102,Modifiability,plugin,plugin-name,2102," for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; 1>>> psi4 --plugin-name myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory, use PSI4 to generate; a Makefile, and type make. Then execute psi4 in the directory on the; default input file.; 1; 2; 3; 4>>> cd myplugin; >>> `psi4 --plugin-compile`; >>> make; >>> psi4. PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; 1; 2; 3; 4; 5; 6>>> psi4 --plugin-name myplugin --plugin-template aointegrals; >>> psi4 --plugin-name myplugin --plugin-template mointegrals; >>> psi4 --plugin-name myplugin --plugin-template sointegrals; >>> psi4 --plugin-name myplugin --plugin-template wavefunction; >>> psi4 --plugin-name myplugin --plugin-template scf; >>> psi4 --plugin-name myplugin --plugin-template dfmp2. Creating a New Plugin Using a Conda Pre-compiled Binary¶; PSI4 plugins can also be created using Conda for both PSI4; binary and development environment. On Linux (or Ubuntu shell on Windows), one can use the gcc; compiler installed alongside psi4 itself in the Conda distribution; or environment (below, $PSI4CONDA). On Mac, one must use; libc++.so (not libstdc++.so), and this can be accomplished by; installing XCode from the App Store that provides clang and; clang++ compilers. Check environment; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18# yes, the following returns a blank line. yes, LD_LIBRARY_PATH irrelevant; >>> echo $PYTHONHOME $PYTHONPATH $DYLD_LIBRARY_PATH $PSIDATADIR. >>> which python psi4 g++ gfortran # Linux; $PSI4CONDA/bin/python; $PSI4CON",MatchSource.WIKI,psi4manual/1.2.1/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins.html
https://psicode.org/psi4manual/1.2.1/plugins.html:2125,Modifiability,plugin,plugin-template,2125," for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; 1>>> psi4 --plugin-name myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory, use PSI4 to generate; a Makefile, and type make. Then execute psi4 in the directory on the; default input file.; 1; 2; 3; 4>>> cd myplugin; >>> `psi4 --plugin-compile`; >>> make; >>> psi4. PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; 1; 2; 3; 4; 5; 6>>> psi4 --plugin-name myplugin --plugin-template aointegrals; >>> psi4 --plugin-name myplugin --plugin-template mointegrals; >>> psi4 --plugin-name myplugin --plugin-template sointegrals; >>> psi4 --plugin-name myplugin --plugin-template wavefunction; >>> psi4 --plugin-name myplugin --plugin-template scf; >>> psi4 --plugin-name myplugin --plugin-template dfmp2. Creating a New Plugin Using a Conda Pre-compiled Binary¶; PSI4 plugins can also be created using Conda for both PSI4; binary and development environment. On Linux (or Ubuntu shell on Windows), one can use the gcc; compiler installed alongside psi4 itself in the Conda distribution; or environment (below, $PSI4CONDA). On Mac, one must use; libc++.so (not libstdc++.so), and this can be accomplished by; installing XCode from the App Store that provides clang and; clang++ compilers. Check environment; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18# yes, the following returns a blank line. yes, LD_LIBRARY_PATH irrelevant; >>> echo $PYTHONHOME $PYTHONPATH $DYLD_LIBRARY_PATH $PSIDATADIR. >>> which python psi4 g++ gfortran # Linux; $PSI4CONDA/bin/python; $PSI4CON",MatchSource.WIKI,psi4manual/1.2.1/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins.html
https://psicode.org/psi4manual/1.2.1/plugins.html:2157,Modifiability,plugin,plugin-name,2157," for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; 1>>> psi4 --plugin-name myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory, use PSI4 to generate; a Makefile, and type make. Then execute psi4 in the directory on the; default input file.; 1; 2; 3; 4>>> cd myplugin; >>> `psi4 --plugin-compile`; >>> make; >>> psi4. PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; 1; 2; 3; 4; 5; 6>>> psi4 --plugin-name myplugin --plugin-template aointegrals; >>> psi4 --plugin-name myplugin --plugin-template mointegrals; >>> psi4 --plugin-name myplugin --plugin-template sointegrals; >>> psi4 --plugin-name myplugin --plugin-template wavefunction; >>> psi4 --plugin-name myplugin --plugin-template scf; >>> psi4 --plugin-name myplugin --plugin-template dfmp2. Creating a New Plugin Using a Conda Pre-compiled Binary¶; PSI4 plugins can also be created using Conda for both PSI4; binary and development environment. On Linux (or Ubuntu shell on Windows), one can use the gcc; compiler installed alongside psi4 itself in the Conda distribution; or environment (below, $PSI4CONDA). On Mac, one must use; libc++.so (not libstdc++.so), and this can be accomplished by; installing XCode from the App Store that provides clang and; clang++ compilers. Check environment; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18# yes, the following returns a blank line. yes, LD_LIBRARY_PATH irrelevant; >>> echo $PYTHONHOME $PYTHONPATH $DYLD_LIBRARY_PATH $PSIDATADIR. >>> which python psi4 g++ gfortran # Linux; $PSI4CONDA/bin/python; $PSI4CON",MatchSource.WIKI,psi4manual/1.2.1/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins.html
https://psicode.org/psi4manual/1.2.1/plugins.html:2180,Modifiability,plugin,plugin-template,2180," for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; 1>>> psi4 --plugin-name myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory, use PSI4 to generate; a Makefile, and type make. Then execute psi4 in the directory on the; default input file.; 1; 2; 3; 4>>> cd myplugin; >>> `psi4 --plugin-compile`; >>> make; >>> psi4. PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; 1; 2; 3; 4; 5; 6>>> psi4 --plugin-name myplugin --plugin-template aointegrals; >>> psi4 --plugin-name myplugin --plugin-template mointegrals; >>> psi4 --plugin-name myplugin --plugin-template sointegrals; >>> psi4 --plugin-name myplugin --plugin-template wavefunction; >>> psi4 --plugin-name myplugin --plugin-template scf; >>> psi4 --plugin-name myplugin --plugin-template dfmp2. Creating a New Plugin Using a Conda Pre-compiled Binary¶; PSI4 plugins can also be created using Conda for both PSI4; binary and development environment. On Linux (or Ubuntu shell on Windows), one can use the gcc; compiler installed alongside psi4 itself in the Conda distribution; or environment (below, $PSI4CONDA). On Mac, one must use; libc++.so (not libstdc++.so), and this can be accomplished by; installing XCode from the App Store that provides clang and; clang++ compilers. Check environment; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18# yes, the following returns a blank line. yes, LD_LIBRARY_PATH irrelevant; >>> echo $PYTHONHOME $PYTHONPATH $DYLD_LIBRARY_PATH $PSIDATADIR. >>> which python psi4 g++ gfortran # Linux; $PSI4CONDA/bin/python; $PSI4CON",MatchSource.WIKI,psi4manual/1.2.1/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins.html
https://psicode.org/psi4manual/1.2.1/plugins.html:2266,Modifiability,plugin,plugins,2266,"ectory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory, use PSI4 to generate; a Makefile, and type make. Then execute psi4 in the directory on the; default input file.; 1; 2; 3; 4>>> cd myplugin; >>> `psi4 --plugin-compile`; >>> make; >>> psi4. PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; 1; 2; 3; 4; 5; 6>>> psi4 --plugin-name myplugin --plugin-template aointegrals; >>> psi4 --plugin-name myplugin --plugin-template mointegrals; >>> psi4 --plugin-name myplugin --plugin-template sointegrals; >>> psi4 --plugin-name myplugin --plugin-template wavefunction; >>> psi4 --plugin-name myplugin --plugin-template scf; >>> psi4 --plugin-name myplugin --plugin-template dfmp2. Creating a New Plugin Using a Conda Pre-compiled Binary¶; PSI4 plugins can also be created using Conda for both PSI4; binary and development environment. On Linux (or Ubuntu shell on Windows), one can use the gcc; compiler installed alongside psi4 itself in the Conda distribution; or environment (below, $PSI4CONDA). On Mac, one must use; libc++.so (not libstdc++.so), and this can be accomplished by; installing XCode from the App Store that provides clang and; clang++ compilers. Check environment; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18# yes, the following returns a blank line. yes, LD_LIBRARY_PATH irrelevant; >>> echo $PYTHONHOME $PYTHONPATH $DYLD_LIBRARY_PATH $PSIDATADIR. >>> which python psi4 g++ gfortran # Linux; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/gcc++; $PSI4CONDA/bin/gfortran; >>> which python psi4 g++ gfortran clang++ # Mac; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/g++; $PSI4CONDA/bin/gfortran; /usr/bin/clang++. >>> which cmake; $PSI4CONDA/bin/cmake; # if above empty, ``conda install cmake``",MatchSource.WIKI,psi4manual/1.2.1/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins.html
https://psicode.org/psi4manual/1.2.1/plugins.html:3300,Modifiability,plugin,plugin,3300,"an use the gcc; compiler installed alongside psi4 itself in the Conda distribution; or environment (below, $PSI4CONDA). On Mac, one must use; libc++.so (not libstdc++.so), and this can be accomplished by; installing XCode from the App Store that provides clang and; clang++ compilers. Check environment; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18# yes, the following returns a blank line. yes, LD_LIBRARY_PATH irrelevant; >>> echo $PYTHONHOME $PYTHONPATH $DYLD_LIBRARY_PATH $PSIDATADIR. >>> which python psi4 g++ gfortran # Linux; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/gcc++; $PSI4CONDA/bin/gfortran; >>> which python psi4 g++ gfortran clang++ # Mac; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/g++; $PSI4CONDA/bin/gfortran; /usr/bin/clang++. >>> which cmake; $PSI4CONDA/bin/cmake; # if above empty, ``conda install cmake``. Create and compile plugin; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35; 36>>> psi4 --plugin-name testplugin; -- Creating ""testplugin"" with ""basic"" template. -----------------; ==> Created plugin files (in testplugin as basic):; __init__.py, CMakeLists.txt, doc.rst, input.dat, plugin.cc, pymodule.py. # move into plugin directory; >>> cd testplugin. # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++",MatchSource.WIKI,psi4manual/1.2.1/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins.html
https://psicode.org/psi4manual/1.2.1/plugins.html:3452,Modifiability,plugin,plugin-name,3452,"an use the gcc; compiler installed alongside psi4 itself in the Conda distribution; or environment (below, $PSI4CONDA). On Mac, one must use; libc++.so (not libstdc++.so), and this can be accomplished by; installing XCode from the App Store that provides clang and; clang++ compilers. Check environment; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18# yes, the following returns a blank line. yes, LD_LIBRARY_PATH irrelevant; >>> echo $PYTHONHOME $PYTHONPATH $DYLD_LIBRARY_PATH $PSIDATADIR. >>> which python psi4 g++ gfortran # Linux; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/gcc++; $PSI4CONDA/bin/gfortran; >>> which python psi4 g++ gfortran clang++ # Mac; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/g++; $PSI4CONDA/bin/gfortran; /usr/bin/clang++. >>> which cmake; $PSI4CONDA/bin/cmake; # if above empty, ``conda install cmake``. Create and compile plugin; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35; 36>>> psi4 --plugin-name testplugin; -- Creating ""testplugin"" with ""basic"" template. -----------------; ==> Created plugin files (in testplugin as basic):; __init__.py, CMakeLists.txt, doc.rst, input.dat, plugin.cc, pymodule.py. # move into plugin directory; >>> cd testplugin. # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++",MatchSource.WIKI,psi4manual/1.2.1/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins.html
https://psicode.org/psi4manual/1.2.1/plugins.html:3555,Modifiability,plugin,plugin,3555,"dc++.so), and this can be accomplished by; installing XCode from the App Store that provides clang and; clang++ compilers. Check environment; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18# yes, the following returns a blank line. yes, LD_LIBRARY_PATH irrelevant; >>> echo $PYTHONHOME $PYTHONPATH $DYLD_LIBRARY_PATH $PSIDATADIR. >>> which python psi4 g++ gfortran # Linux; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/gcc++; $PSI4CONDA/bin/gfortran; >>> which python psi4 g++ gfortran clang++ # Mac; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/g++; $PSI4CONDA/bin/gfortran; /usr/bin/clang++. >>> which cmake; $PSI4CONDA/bin/cmake; # if above empty, ``conda install cmake``. Create and compile plugin; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35; 36>>> psi4 --plugin-name testplugin; -- Creating ""testplugin"" with ""basic"" template. -----------------; ==> Created plugin files (in testplugin as basic):; __init__.py, CMakeLists.txt, doc.rst, input.dat, plugin.cc, pymodule.py. # move into plugin directory; >>> cd testplugin. # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencie",MatchSource.WIKI,psi4manual/1.2.1/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins.html
https://psicode.org/psi4manual/1.2.1/plugins.html:3644,Modifiability,plugin,plugin,3644,"t provides clang and; clang++ compilers. Check environment; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18# yes, the following returns a blank line. yes, LD_LIBRARY_PATH irrelevant; >>> echo $PYTHONHOME $PYTHONPATH $DYLD_LIBRARY_PATH $PSIDATADIR. >>> which python psi4 g++ gfortran # Linux; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/gcc++; $PSI4CONDA/bin/gfortran; >>> which python psi4 g++ gfortran clang++ # Mac; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/g++; $PSI4CONDA/bin/gfortran; /usr/bin/clang++. >>> which cmake; $PSI4CONDA/bin/cmake; # if above empty, ``conda install cmake``. Create and compile plugin; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35; 36>>> psi4 --plugin-name testplugin; -- Creating ""testplugin"" with ""basic"" template. -----------------; ==> Created plugin files (in testplugin as basic):; __init__.py, CMakeLists.txt, doc.rst, input.dat, plugin.cc, pymodule.py. # move into plugin directory; >>> cd testplugin. # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencies of target testplugin; [ 50%] Building CXX object CMakeFiles/testplugin.dir/plug",MatchSource.WIKI,psi4manual/1.2.1/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins.html
https://psicode.org/psi4manual/1.2.1/plugins.html:3680,Modifiability,plugin,plugin,3680," environment; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18# yes, the following returns a blank line. yes, LD_LIBRARY_PATH irrelevant; >>> echo $PYTHONHOME $PYTHONPATH $DYLD_LIBRARY_PATH $PSIDATADIR. >>> which python psi4 g++ gfortran # Linux; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/gcc++; $PSI4CONDA/bin/gfortran; >>> which python psi4 g++ gfortran clang++ # Mac; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/g++; $PSI4CONDA/bin/gfortran; /usr/bin/clang++. >>> which cmake; $PSI4CONDA/bin/cmake; # if above empty, ``conda install cmake``. Create and compile plugin; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35; 36>>> psi4 --plugin-name testplugin; -- Creating ""testplugin"" with ""basic"" template. -----------------; ==> Created plugin files (in testplugin as basic):; __init__.py, CMakeLists.txt, doc.rst, input.dat, plugin.cc, pymodule.py. # move into plugin directory; >>> cd testplugin. # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencies of target testplugin; [ 50%] Building CXX object CMakeFiles/testplugin.dir/plugin.cc.o; [100%] Linking CXX shared module testp",MatchSource.WIKI,psi4manual/1.2.1/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins.html
https://psicode.org/psi4manual/1.2.1/plugins.html:3719,Modifiability,config,configure,3719," a blank line. yes, LD_LIBRARY_PATH irrelevant; >>> echo $PYTHONHOME $PYTHONPATH $DYLD_LIBRARY_PATH $PSIDATADIR. >>> which python psi4 g++ gfortran # Linux; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/gcc++; $PSI4CONDA/bin/gfortran; >>> which python psi4 g++ gfortran clang++ # Mac; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/g++; $PSI4CONDA/bin/gfortran; /usr/bin/clang++. >>> which cmake; $PSI4CONDA/bin/cmake; # if above empty, ``conda install cmake``. Create and compile plugin; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35; 36>>> psi4 --plugin-name testplugin; -- Creating ""testplugin"" with ""basic"" template. -----------------; ==> Created plugin files (in testplugin as basic):; __init__.py, CMakeLists.txt, doc.rst, input.dat, plugin.cc, pymodule.py. # move into plugin directory; >>> cd testplugin. # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencies of target testplugin; [ 50%] Building CXX object CMakeFiles/testplugin.dir/plugin.cc.o; [100%] Linking CXX shared module testplugin.so; [100%] Built target testplugin. # run sample input.dat; >>> psi4; Attention! This SCF may be",MatchSource.WIKI,psi4manual/1.2.1/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins.html
https://psicode.org/psi4manual/1.2.1/plugins.html:3776,Modifiability,plugin,plugin-compile,3776," a blank line. yes, LD_LIBRARY_PATH irrelevant; >>> echo $PYTHONHOME $PYTHONPATH $DYLD_LIBRARY_PATH $PSIDATADIR. >>> which python psi4 g++ gfortran # Linux; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/gcc++; $PSI4CONDA/bin/gfortran; >>> which python psi4 g++ gfortran clang++ # Mac; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/g++; $PSI4CONDA/bin/gfortran; /usr/bin/clang++. >>> which cmake; $PSI4CONDA/bin/cmake; # if above empty, ``conda install cmake``. Create and compile plugin; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35; 36>>> psi4 --plugin-name testplugin; -- Creating ""testplugin"" with ""basic"" template. -----------------; ==> Created plugin files (in testplugin as basic):; __init__.py, CMakeLists.txt, doc.rst, input.dat, plugin.cc, pymodule.py. # move into plugin directory; >>> cd testplugin. # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencies of target testplugin; [ 50%] Building CXX object CMakeFiles/testplugin.dir/plugin.cc.o; [100%] Linking CXX shared module testplugin.so; [100%] Built target testplugin. # run sample input.dat; >>> psi4; Attention! This SCF may be",MatchSource.WIKI,psi4manual/1.2.1/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins.html
https://psicode.org/psi4manual/1.2.1/plugins.html:4133,Modifiability,plugin,plugin-compile,4133,"SI4CONDA/bin/g++; $PSI4CONDA/bin/gfortran; /usr/bin/clang++. >>> which cmake; $PSI4CONDA/bin/cmake; # if above empty, ``conda install cmake``. Create and compile plugin; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35; 36>>> psi4 --plugin-name testplugin; -- Creating ""testplugin"" with ""basic"" template. -----------------; ==> Created plugin files (in testplugin as basic):; __init__.py, CMakeLists.txt, doc.rst, input.dat, plugin.cc, pymodule.py. # move into plugin directory; >>> cd testplugin. # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencies of target testplugin; [ 50%] Building CXX object CMakeFiles/testplugin.dir/plugin.cc.o; [100%] Linking CXX shared module testplugin.so; [100%] Built target testplugin. # run sample input.dat; >>> psi4; Attention! This SCF may be density-fitted. Please note that the conda distribution must be in $PATH or the; conda enviroment must be activated before compilation and execution of; plugins created using this procedure. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. CMakeLists.txt — CMake fil",MatchSource.WIKI,psi4manual/1.2.1/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins.html
https://psicode.org/psi4manual/1.2.1/plugins.html:4501,Modifiability,plugin,plugin,4501,"asic"" template. -----------------; ==> Created plugin files (in testplugin as basic):; __init__.py, CMakeLists.txt, doc.rst, input.dat, plugin.cc, pymodule.py. # move into plugin directory; >>> cd testplugin. # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencies of target testplugin; [ 50%] Building CXX object CMakeFiles/testplugin.dir/plugin.cc.o; [100%] Linking CXX shared module testplugin.so; [100%] Built target testplugin. # run sample input.dat; >>> psi4; Attention! This SCF may be density-fitted. Please note that the conda distribution must be in $PATH or the; conda enviroment must be activated before compilation and execution of; plugins created using this procedure. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. CMakeLists.txt — CMake file governing project plugin.; The plugin source and CMakeLists.txt is independent of platform; and PSI4 installation. You use CMake (version 3.1 or later); to generate a Makefile for the plugin by pointing it to a specific; PSI4 installation. Run psi4 --plugin-compile to get a command; to execute to generate the Makefile. What that command is doing is; loading the com",MatchSource.WIKI,psi4manual/1.2.1/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins.html
https://psicode.org/psi4manual/1.2.1/plugins.html:4641,Modifiability,plugin,plugin,4641,", plugin.cc, pymodule.py. # move into plugin directory; >>> cd testplugin. # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencies of target testplugin; [ 50%] Building CXX object CMakeFiles/testplugin.dir/plugin.cc.o; [100%] Linking CXX shared module testplugin.so; [100%] Built target testplugin. # run sample input.dat; >>> psi4; Attention! This SCF may be density-fitted. Please note that the conda distribution must be in $PATH or the; conda enviroment must be activated before compilation and execution of; plugins created using this procedure. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. CMakeLists.txt — CMake file governing project plugin.; The plugin source and CMakeLists.txt is independent of platform; and PSI4 installation. You use CMake (version 3.1 or later); to generate a Makefile for the plugin by pointing it to a specific; PSI4 installation. Run psi4 --plugin-compile to get a command; to execute to generate the Makefile. What that command is doing is; loading the compilers and options used to build the parent PSI4; (the -C psi4PluginCache part) which in turn can be overridden; by passing -Doption=va",MatchSource.WIKI,psi4manual/1.2.1/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins.html
https://psicode.org/psi4manual/1.2.1/plugins.html:4948,Modifiability,plugin,plugins,4948,"r identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencies of target testplugin; [ 50%] Building CXX object CMakeFiles/testplugin.dir/plugin.cc.o; [100%] Linking CXX shared module testplugin.so; [100%] Built target testplugin. # run sample input.dat; >>> psi4; Attention! This SCF may be density-fitted. Please note that the conda distribution must be in $PATH or the; conda enviroment must be activated before compilation and execution of; plugins created using this procedure. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. CMakeLists.txt — CMake file governing project plugin.; The plugin source and CMakeLists.txt is independent of platform; and PSI4 installation. You use CMake (version 3.1 or later); to generate a Makefile for the plugin by pointing it to a specific; PSI4 installation. Run psi4 --plugin-compile to get a command; to execute to generate the Makefile. What that command is doing is; loading the compilers and options used to build the parent PSI4; (the -C psi4PluginCache part) which in turn can be overridden; by passing -Doption=value commands to cmake and pointing; toward a particular PSI4 (and probably pybind11) library to; link against (the CMAKE_PREFIX_PATH part) and telling it to; do an in-source build (the . part). Then just run make in; your plugin directory. After any chang",MatchSource.WIKI,psi4manual/1.2.1/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins.html
https://psicode.org/psi4manual/1.2.1/plugins.html:5066,Modifiability,plugin,plugin,5066," files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencies of target testplugin; [ 50%] Building CXX object CMakeFiles/testplugin.dir/plugin.cc.o; [100%] Linking CXX shared module testplugin.so; [100%] Built target testplugin. # run sample input.dat; >>> psi4; Attention! This SCF may be density-fitted. Please note that the conda distribution must be in $PATH or the; conda enviroment must be activated before compilation and execution of; plugins created using this procedure. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. CMakeLists.txt — CMake file governing project plugin.; The plugin source and CMakeLists.txt is independent of platform; and PSI4 installation. You use CMake (version 3.1 or later); to generate a Makefile for the plugin by pointing it to a specific; PSI4 installation. Run psi4 --plugin-compile to get a command; to execute to generate the Makefile. What that command is doing is; loading the compilers and options used to build the parent PSI4; (the -C psi4PluginCache part) which in turn can be overridden; by passing -Doption=value commands to cmake and pointing; toward a particular PSI4 (and probably pybind11) library to; link against (the CMAKE_PREFIX_PATH part) and telling it to; do an in-source build (the . part). Then just run make in; your plugin directory. After any change to the plugin C++ code,; make must be run in the plugin directory to recompile the; myplugin.so executable, but recompiling the main PSI4 code; is not necessary. Should you add addi",MatchSource.WIKI,psi4manual/1.2.1/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins.html
https://psicode.org/psi4manual/1.2.1/plugins.html:5159,Modifiability,plugin,plugin,5159,"le` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencies of target testplugin; [ 50%] Building CXX object CMakeFiles/testplugin.dir/plugin.cc.o; [100%] Linking CXX shared module testplugin.so; [100%] Built target testplugin. # run sample input.dat; >>> psi4; Attention! This SCF may be density-fitted. Please note that the conda distribution must be in $PATH or the; conda enviroment must be activated before compilation and execution of; plugins created using this procedure. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. CMakeLists.txt — CMake file governing project plugin.; The plugin source and CMakeLists.txt is independent of platform; and PSI4 installation. You use CMake (version 3.1 or later); to generate a Makefile for the plugin by pointing it to a specific; PSI4 installation. Run psi4 --plugin-compile to get a command; to execute to generate the Makefile. What that command is doing is; loading the compilers and options used to build the parent PSI4; (the -C psi4PluginCache part) which in turn can be overridden; by passing -Doption=value commands to cmake and pointing; toward a particular PSI4 (and probably pybind11) library to; link against (the CMAKE_PREFIX_PATH part) and telling it to; do an in-source build (the . part). Then just run make in; your plugin directory. After any change to the plugin C++ code,; make must be run in the plugin directory to recompile the; myplugin.so executable, but recompiling the main PSI4 code; is not necessary. Should you add additional (non-header) files to; the plugin or need to link to addi",MatchSource.WIKI,psi4manual/1.2.1/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins.html
https://psicode.org/psi4manual/1.2.1/plugins.html:5172,Modifiability,plugin,plugin,5172,"$PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencies of target testplugin; [ 50%] Building CXX object CMakeFiles/testplugin.dir/plugin.cc.o; [100%] Linking CXX shared module testplugin.so; [100%] Built target testplugin. # run sample input.dat; >>> psi4; Attention! This SCF may be density-fitted. Please note that the conda distribution must be in $PATH or the; conda enviroment must be activated before compilation and execution of; plugins created using this procedure. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. CMakeLists.txt — CMake file governing project plugin.; The plugin source and CMakeLists.txt is independent of platform; and PSI4 installation. You use CMake (version 3.1 or later); to generate a Makefile for the plugin by pointing it to a specific; PSI4 installation. Run psi4 --plugin-compile to get a command; to execute to generate the Makefile. What that command is doing is; loading the compilers and options used to build the parent PSI4; (the -C psi4PluginCache part) which in turn can be overridden; by passing -Doption=value commands to cmake and pointing; toward a particular PSI4 (and probably pybind11) library to; link against (the CMAKE_PREFIX_PATH part) and telling it to; do an in-source build (the . part). Then just run make in; your plugin directory. After any change to the plugin C++ code,; make must be run in the plugin directory to recompile the; myplugin.so executable, but recompiling the main PSI4 code; is not necessary. Should you add additional (non-header) files to; the plugin or need to link to additional external libraries, add that; in",MatchSource.WIKI,psi4manual/1.2.1/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins.html
https://psicode.org/psi4manual/1.2.1/plugins.html:5325,Modifiability,plugin,plugin,5325,"r: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencies of target testplugin; [ 50%] Building CXX object CMakeFiles/testplugin.dir/plugin.cc.o; [100%] Linking CXX shared module testplugin.so; [100%] Built target testplugin. # run sample input.dat; >>> psi4; Attention! This SCF may be density-fitted. Please note that the conda distribution must be in $PATH or the; conda enviroment must be activated before compilation and execution of; plugins created using this procedure. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. CMakeLists.txt — CMake file governing project plugin.; The plugin source and CMakeLists.txt is independent of platform; and PSI4 installation. You use CMake (version 3.1 or later); to generate a Makefile for the plugin by pointing it to a specific; PSI4 installation. Run psi4 --plugin-compile to get a command; to execute to generate the Makefile. What that command is doing is; loading the compilers and options used to build the parent PSI4; (the -C psi4PluginCache part) which in turn can be overridden; by passing -Doption=value commands to cmake and pointing; toward a particular PSI4 (and probably pybind11) library to; link against (the CMAKE_PREFIX_PATH part) and telling it to; do an in-source build (the . part). Then just run make in; your plugin directory. After any change to the plugin C++ code,; make must be run in the plugin directory to recompile the; myplugin.so executable, but recompiling the main PSI4 code; is not necessary. Should you add additional (non-header) files to; the plugin or need to link to additional external libraries, add that; information here.; input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, t",MatchSource.WIKI,psi4manual/1.2.1/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins.html
https://psicode.org/psi4manual/1.2.1/plugins.html:5392,Modifiability,plugin,plugin-compile,5392," Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencies of target testplugin; [ 50%] Building CXX object CMakeFiles/testplugin.dir/plugin.cc.o; [100%] Linking CXX shared module testplugin.so; [100%] Built target testplugin. # run sample input.dat; >>> psi4; Attention! This SCF may be density-fitted. Please note that the conda distribution must be in $PATH or the; conda enviroment must be activated before compilation and execution of; plugins created using this procedure. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. CMakeLists.txt — CMake file governing project plugin.; The plugin source and CMakeLists.txt is independent of platform; and PSI4 installation. You use CMake (version 3.1 or later); to generate a Makefile for the plugin by pointing it to a specific; PSI4 installation. Run psi4 --plugin-compile to get a command; to execute to generate the Makefile. What that command is doing is; loading the compilers and options used to build the parent PSI4; (the -C psi4PluginCache part) which in turn can be overridden; by passing -Doption=value commands to cmake and pointing; toward a particular PSI4 (and probably pybind11) library to; link against (the CMAKE_PREFIX_PATH part) and telling it to; do an in-source build (the . part). Then just run make in; your plugin directory. After any change to the plugin C++ code,; make must be run in the plugin directory to recompile the; myplugin.so executable, but recompiling the main PSI4 code; is not necessary. Should you add additional (non-header) files to; the plugin or need to link to additional external libraries, add that; information here.; input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory m",MatchSource.WIKI,psi4manual/1.2.1/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins.html
https://psicode.org/psi4manual/1.2.1/plugins.html:5865,Modifiability,plugin,plugin,5865,"in $PATH or the; conda enviroment must be activated before compilation and execution of; plugins created using this procedure. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. CMakeLists.txt — CMake file governing project plugin.; The plugin source and CMakeLists.txt is independent of platform; and PSI4 installation. You use CMake (version 3.1 or later); to generate a Makefile for the plugin by pointing it to a specific; PSI4 installation. Run psi4 --plugin-compile to get a command; to execute to generate the Makefile. What that command is doing is; loading the compilers and options used to build the parent PSI4; (the -C psi4PluginCache part) which in turn can be overridden; by passing -Doption=value commands to cmake and pointing; toward a particular PSI4 (and probably pybind11) library to; link against (the CMAKE_PREFIX_PATH part) and telling it to; do an in-source build (the . part). Then just run make in; your plugin directory. After any change to the plugin C++ code,; make must be run in the plugin directory to recompile the; myplugin.so executable, but recompiling the main PSI4 code; is not necessary. Should you add additional (non-header) files to; the plugin or need to link to additional external libraries, add that; information here.; input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file.; This is usually done by manipulating PSIPATH. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection.; pymodule.py — Python component of the plugin.; By encoding the sequence",MatchSource.WIKI,psi4manual/1.2.1/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins.html
https://psicode.org/psi4manual/1.2.1/plugins.html:5907,Modifiability,plugin,plugin,5907,"cution of; plugins created using this procedure. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. CMakeLists.txt — CMake file governing project plugin.; The plugin source and CMakeLists.txt is independent of platform; and PSI4 installation. You use CMake (version 3.1 or later); to generate a Makefile for the plugin by pointing it to a specific; PSI4 installation. Run psi4 --plugin-compile to get a command; to execute to generate the Makefile. What that command is doing is; loading the compilers and options used to build the parent PSI4; (the -C psi4PluginCache part) which in turn can be overridden; by passing -Doption=value commands to cmake and pointing; toward a particular PSI4 (and probably pybind11) library to; link against (the CMAKE_PREFIX_PATH part) and telling it to; do an in-source build (the . part). Then just run make in; your plugin directory. After any change to the plugin C++ code,; make must be run in the plugin directory to recompile the; myplugin.so executable, but recompiling the main PSI4 code; is not necessary. Should you add additional (non-header) files to; the plugin or need to link to additional external libraries, add that; information here.; input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file.; This is usually done by manipulating PSIPATH. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection.; pymodule.py — Python component of the plugin.; By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function ",MatchSource.WIKI,psi4manual/1.2.1/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins.html
https://psicode.org/psi4manual/1.2.1/plugins.html:5949,Modifiability,plugin,plugin,5949,"cution of; plugins created using this procedure. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. CMakeLists.txt — CMake file governing project plugin.; The plugin source and CMakeLists.txt is independent of platform; and PSI4 installation. You use CMake (version 3.1 or later); to generate a Makefile for the plugin by pointing it to a specific; PSI4 installation. Run psi4 --plugin-compile to get a command; to execute to generate the Makefile. What that command is doing is; loading the compilers and options used to build the parent PSI4; (the -C psi4PluginCache part) which in turn can be overridden; by passing -Doption=value commands to cmake and pointing; toward a particular PSI4 (and probably pybind11) library to; link against (the CMAKE_PREFIX_PATH part) and telling it to; do an in-source build (the . part). Then just run make in; your plugin directory. After any change to the plugin C++ code,; make must be run in the plugin directory to recompile the; myplugin.so executable, but recompiling the main PSI4 code; is not necessary. Should you add additional (non-header) files to; the plugin or need to link to additional external libraries, add that; information here.; input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file.; This is usually done by manipulating PSIPATH. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection.; pymodule.py — Python component of the plugin.; By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function ",MatchSource.WIKI,psi4manual/1.2.1/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins.html
https://psicode.org/psi4manual/1.2.1/plugins.html:6115,Modifiability,plugin,plugin,6115,"CMake file governing project plugin.; The plugin source and CMakeLists.txt is independent of platform; and PSI4 installation. You use CMake (version 3.1 or later); to generate a Makefile for the plugin by pointing it to a specific; PSI4 installation. Run psi4 --plugin-compile to get a command; to execute to generate the Makefile. What that command is doing is; loading the compilers and options used to build the parent PSI4; (the -C psi4PluginCache part) which in turn can be overridden; by passing -Doption=value commands to cmake and pointing; toward a particular PSI4 (and probably pybind11) library to; link against (the CMAKE_PREFIX_PATH part) and telling it to; do an in-source build (the . part). Then just run make in; your plugin directory. After any change to the plugin C++ code,; make must be run in the plugin directory to recompile the; myplugin.so executable, but recompiling the main PSI4 code; is not necessary. Should you add additional (non-header) files to; the plugin or need to link to additional external libraries, add that; information here.; input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file.; This is usually done by manipulating PSIPATH. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection.; pymodule.py — Python component of the plugin.; By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be pl",MatchSource.WIKI,psi4manual/1.2.1/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins.html
https://psicode.org/psi4manual/1.2.1/plugins.html:6239,Modifiability,plugin,plugin,6239,"tform; and PSI4 installation. You use CMake (version 3.1 or later); to generate a Makefile for the plugin by pointing it to a specific; PSI4 installation. Run psi4 --plugin-compile to get a command; to execute to generate the Makefile. What that command is doing is; loading the compilers and options used to build the parent PSI4; (the -C psi4PluginCache part) which in turn can be overridden; by passing -Doption=value commands to cmake and pointing; toward a particular PSI4 (and probably pybind11) library to; link against (the CMAKE_PREFIX_PATH part) and telling it to; do an in-source build (the . part). Then just run make in; your plugin directory. After any change to the plugin C++ code,; make must be run in the plugin directory to recompile the; myplugin.so executable, but recompiling the main PSI4 code; is not necessary. Should you add additional (non-header) files to; the plugin or need to link to additional external libraries, add that; information here.; input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file.; This is usually done by manipulating PSIPATH. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection.; pymodule.py — Python component of the plugin.; By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin",MatchSource.WIKI,psi4manual/1.2.1/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins.html
https://psicode.org/psi4manual/1.2.1/plugins.html:6285,Modifiability,plugin,plugin,6285," plugin by pointing it to a specific; PSI4 installation. Run psi4 --plugin-compile to get a command; to execute to generate the Makefile. What that command is doing is; loading the compilers and options used to build the parent PSI4; (the -C psi4PluginCache part) which in turn can be overridden; by passing -Doption=value commands to cmake and pointing; toward a particular PSI4 (and probably pybind11) library to; link against (the CMAKE_PREFIX_PATH part) and telling it to; do an in-source build (the . part). Then just run make in; your plugin directory. After any change to the plugin C++ code,; make must be run in the plugin directory to recompile the; myplugin.so executable, but recompiling the main PSI4 code; is not necessary. Should you add additional (non-header) files to; the plugin or need to link to additional external libraries, add that; information here.; input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file.; This is usually done by manipulating PSIPATH. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection.; pymodule.py — Python component of the plugin.; By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python ",MatchSource.WIKI,psi4manual/1.2.1/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins.html
https://psicode.org/psi4manual/1.2.1/plugins.html:6334,Modifiability,plugin,plugin,6334," plugin by pointing it to a specific; PSI4 installation. Run psi4 --plugin-compile to get a command; to execute to generate the Makefile. What that command is doing is; loading the compilers and options used to build the parent PSI4; (the -C psi4PluginCache part) which in turn can be overridden; by passing -Doption=value commands to cmake and pointing; toward a particular PSI4 (and probably pybind11) library to; link against (the CMAKE_PREFIX_PATH part) and telling it to; do an in-source build (the . part). Then just run make in; your plugin directory. After any change to the plugin C++ code,; make must be run in the plugin directory to recompile the; myplugin.so executable, but recompiling the main PSI4 code; is not necessary. Should you add additional (non-header) files to; the plugin or need to link to additional external libraries, add that; information here.; input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file.; This is usually done by manipulating PSIPATH. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection.; pymodule.py — Python component of the plugin.; By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python ",MatchSource.WIKI,psi4manual/1.2.1/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins.html
https://psicode.org/psi4manual/1.2.1/plugins.html:6403,Modifiability,plugin,plugin,6403," Makefile. What that command is doing is; loading the compilers and options used to build the parent PSI4; (the -C psi4PluginCache part) which in turn can be overridden; by passing -Doption=value commands to cmake and pointing; toward a particular PSI4 (and probably pybind11) library to; link against (the CMAKE_PREFIX_PATH part) and telling it to; do an in-source build (the . part). Then just run make in; your plugin directory. After any change to the plugin C++ code,; make must be run in the plugin directory to recompile the; myplugin.so executable, but recompiling the main PSI4 code; is not necessary. Should you add additional (non-header) files to; the plugin or need to link to additional external libraries, add that; information here.; input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file.; This is usually done by manipulating PSIPATH. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection.; pymodule.py — Python component of the plugin.; By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on ",MatchSource.WIKI,psi4manual/1.2.1/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins.html
https://psicode.org/psi4manual/1.2.1/plugins.html:6580,Modifiability,plugin,plugin,6580,"rridden; by passing -Doption=value commands to cmake and pointing; toward a particular PSI4 (and probably pybind11) library to; link against (the CMAKE_PREFIX_PATH part) and telling it to; do an in-source build (the . part). Then just run make in; your plugin directory. After any change to the plugin C++ code,; make must be run in the plugin directory to recompile the; myplugin.so executable, but recompiling the main PSI4 code; is not necessary. Should you add additional (non-header) files to; the plugin or need to link to additional external libraries, add that; information here.; input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file.; This is usually done by manipulating PSIPATH. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection.; pymodule.py — Python component of the plugin.; By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section). doc.rst — D",MatchSource.WIKI,psi4manual/1.2.1/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins.html
https://psicode.org/psi4manual/1.2.1/plugins.html:6826,Modifiability,plugin,plugin,6826,"e build (the . part). Then just run make in; your plugin directory. After any change to the plugin C++ code,; make must be run in the plugin directory to recompile the; myplugin.so executable, but recompiling the main PSI4 code; is not necessary. Should you add additional (non-header) files to; the plugin or need to link to additional external libraries, add that; information here.; input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file.; This is usually done by manipulating PSIPATH. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection.; pymodule.py — Python component of the plugin.; By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build ",MatchSource.WIKI,psi4manual/1.2.1/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins.html
https://psicode.org/psi4manual/1.2.1/plugins.html:6900,Modifiability,plugin,plugin,6900,"ctory to recompile the; myplugin.so executable, but recompiling the main PSI4 code; is not necessary. Should you add additional (non-header) files to; the plugin or need to link to additional external libraries, add that; information here.; input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file.; This is usually done by manipulating PSIPATH. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection.; pymodule.py — Python component of the plugin.; By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any doc",MatchSource.WIKI,psi4manual/1.2.1/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins.html
https://psicode.org/psi4manual/1.2.1/plugins.html:6957,Modifiability,plugin,plugin,6957,"ctory to recompile the; myplugin.so executable, but recompiling the main PSI4 code; is not necessary. Should you add additional (non-header) files to; the plugin or need to link to additional external libraries, add that; information here.; input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file.; This is usually done by manipulating PSIPATH. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection.; pymodule.py — Python component of the plugin.; By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any doc",MatchSource.WIKI,psi4manual/1.2.1/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins.html
https://psicode.org/psi4manual/1.2.1/plugins.html:7184,Modifiability,plugin,plugin,7184,"at — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file.; This is usually done by manipulating PSIPATH. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection.; pymodule.py — Python component of the plugin.; By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation. Please note that pure virtual functions in a plugin may cause undefined symbols errors when; the plugin is loaded.; To c",MatchSource.WIKI,psi4manual/1.2.1/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins.html
https://psicode.org/psi4manual/1.2.1/plugins.html:7221,Modifiability,plugin,plugin,7221,"at — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file.; This is usually done by manipulating PSIPATH. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection.; pymodule.py — Python component of the plugin.; By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation. Please note that pure virtual functions in a plugin may cause undefined symbols errors when; the plugin is loaded.; To c",MatchSource.WIKI,psi4manual/1.2.1/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins.html
https://psicode.org/psi4manual/1.2.1/plugins.html:7347,Modifiability,plugin,plugin,7347," as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file.; This is usually done by manipulating PSIPATH. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection.; pymodule.py — Python component of the plugin.; By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation. Please note that pure virtual functions in a plugin may cause undefined symbols errors when; the plugin is loaded.; To create a purely Python plugin, create a new plugin directory, then; remove the Makefile and myplugin.cc files and; erase the shared object loading ",MatchSource.WIKI,psi4manual/1.2.1/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins.html
https://psicode.org/psi4manual/1.2.1/plugins.html:7433,Modifiability,plugin,plugin,7433," as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file.; This is usually done by manipulating PSIPATH. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection.; pymodule.py — Python component of the plugin.; By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation. Please note that pure virtual functions in a plugin may cause undefined symbols errors when; the plugin is loaded.; To create a purely Python plugin, create a new plugin directory, then; remove the Makefile and myplugin.cc files and; erase the shared object loading ",MatchSource.WIKI,psi4manual/1.2.1/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins.html
https://psicode.org/psi4manual/1.2.1/plugins.html:7470,Modifiability,plugin,plugin,7470,"s is usually done by manipulating PSIPATH. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection.; pymodule.py — Python component of the plugin.; By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation. Please note that pure virtual functions in a plugin may cause undefined symbols errors when; the plugin is loaded.; To create a purely Python plugin, create a new plugin directory, then; remove the Makefile and myplugin.cc files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; input.dat as a model for loading the plugin, no recompile ever; ",MatchSource.WIKI,psi4manual/1.2.1/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins.html
https://psicode.org/psi4manual/1.2.1/plugins.html:7548,Modifiability,plugin,plugin,7548,"s is usually done by manipulating PSIPATH. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection.; pymodule.py — Python component of the plugin.; By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation. Please note that pure virtual functions in a plugin may cause undefined symbols errors when; the plugin is loaded.; To create a purely Python plugin, create a new plugin directory, then; remove the Makefile and myplugin.cc files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; input.dat as a model for loading the plugin, no recompile ever; ",MatchSource.WIKI,psi4manual/1.2.1/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins.html
https://psicode.org/psi4manual/1.2.1/plugins.html:7584,Modifiability,plugin,plugin,7584,"s is usually done by manipulating PSIPATH. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection.; pymodule.py — Python component of the plugin.; By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation. Please note that pure virtual functions in a plugin may cause undefined symbols errors when; the plugin is loaded.; To create a purely Python plugin, create a new plugin directory, then; remove the Makefile and myplugin.cc files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; input.dat as a model for loading the plugin, no recompile ever; ",MatchSource.WIKI,psi4manual/1.2.1/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins.html
https://psicode.org/psi4manual/1.2.1/plugins.html:8134,Modifiability,plugin,plugin,8134,"; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation. Please note that pure virtual functions in a plugin may cause undefined symbols errors when; the plugin is loaded.; To create a purely Python plugin, create a new plugin directory, then; remove the Makefile and myplugin.cc files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; input.dat as a model for loading the plugin, no recompile ever; necessary. table of contents. Plugins: Adding New Functionality to PSI4; Modular Approach to Development; Creating a New Plugin; Creating a New Plugin Using a Conda Pre-compiled Binary; Files in a Plugin Directory. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Contributions: Intro to Programming in PSI4. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins.html
https://psicode.org/psi4manual/1.2.1/plugins.html:8186,Modifiability,plugin,plugin,8186,"; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation. Please note that pure virtual functions in a plugin may cause undefined symbols errors when; the plugin is loaded.; To create a purely Python plugin, create a new plugin directory, then; remove the Makefile and myplugin.cc files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; input.dat as a model for loading the plugin, no recompile ever; necessary. table of contents. Plugins: Adding New Functionality to PSI4; Modular Approach to Development; Creating a New Plugin; Creating a New Plugin Using a Conda Pre-compiled Binary; Files in a Plugin Directory. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Contributions: Intro to Programming in PSI4. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins.html
https://psicode.org/psi4manual/1.2.1/plugins.html:8231,Modifiability,plugin,plugin,8231,"; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation. Please note that pure virtual functions in a plugin may cause undefined symbols errors when; the plugin is loaded.; To create a purely Python plugin, create a new plugin directory, then; remove the Makefile and myplugin.cc files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; input.dat as a model for loading the plugin, no recompile ever; necessary. table of contents. Plugins: Adding New Functionality to PSI4; Modular Approach to Development; Creating a New Plugin; Creating a New Plugin Using a Conda Pre-compiled Binary; Files in a Plugin Directory. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Contributions: Intro to Programming in PSI4. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins.html
https://psicode.org/psi4manual/1.2.1/plugins.html:8252,Modifiability,plugin,plugin,8252,"; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation. Please note that pure virtual functions in a plugin may cause undefined symbols errors when; the plugin is loaded.; To create a purely Python plugin, create a new plugin directory, then; remove the Makefile and myplugin.cc files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; input.dat as a model for loading the plugin, no recompile ever; necessary. table of contents. Plugins: Adding New Functionality to PSI4; Modular Approach to Development; Creating a New Plugin; Creating a New Plugin Using a Conda Pre-compiled Binary; Files in a Plugin Directory. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Contributions: Intro to Programming in PSI4. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins.html
https://psicode.org/psi4manual/1.2.1/plugins.html:8499,Modifiability,plugin,plugin,8499,"; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation. Please note that pure virtual functions in a plugin may cause undefined symbols errors when; the plugin is loaded.; To create a purely Python plugin, create a new plugin directory, then; remove the Makefile and myplugin.cc files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; input.dat as a model for loading the plugin, no recompile ever; necessary. table of contents. Plugins: Adding New Functionality to PSI4; Modular Approach to Development; Creating a New Plugin; Creating a New Plugin Using a Conda Pre-compiled Binary; Files in a Plugin Directory. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Contributions: Intro to Programming in PSI4. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins.html
https://psicode.org/psi4manual/1.2.1/plugins.html:890,Performance,load,loaded,890,"﻿. Plugins: Adding New Functionality to PSI4. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Contributions: Intro to Programming in PSI4. Plugins: Adding New Functionality to PSI4¶. Modular Approach to Development¶; It is slightly cumbersome to the development cycle to recompile PSI4; every time a change is made to the C++ code.; It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with Psi3 due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; 1>>> psi4 --plugin-name myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory, use PSI4 to generate; a Makefile, and type make. Then execute psi4 in the directory on the; default input file.; 1; 2; 3; 4>>> cd myplugin; >>> `psi4 --plugin-compile`; >>> make; >>> psi4. PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; 1; 2; 3; 4; 5; 6>>> psi4 --plugin-name myplugin --plugin-template aointegrals; >>> psi4 --plugin-name myplugin --plugin-template mointegrals; >>> psi4 --plugin-name myplugin --plu",MatchSource.WIKI,psi4manual/1.2.1/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins.html
https://psicode.org/psi4manual/1.2.1/plugins.html:3801,Performance,load,loading,3801," a blank line. yes, LD_LIBRARY_PATH irrelevant; >>> echo $PYTHONHOME $PYTHONPATH $DYLD_LIBRARY_PATH $PSIDATADIR. >>> which python psi4 g++ gfortran # Linux; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/gcc++; $PSI4CONDA/bin/gfortran; >>> which python psi4 g++ gfortran clang++ # Mac; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/g++; $PSI4CONDA/bin/gfortran; /usr/bin/clang++. >>> which cmake; $PSI4CONDA/bin/cmake; # if above empty, ``conda install cmake``. Create and compile plugin; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35; 36>>> psi4 --plugin-name testplugin; -- Creating ""testplugin"" with ""basic"" template. -----------------; ==> Created plugin files (in testplugin as basic):; __init__.py, CMakeLists.txt, doc.rst, input.dat, plugin.cc, pymodule.py. # move into plugin directory; >>> cd testplugin. # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencies of target testplugin; [ 50%] Building CXX object CMakeFiles/testplugin.dir/plugin.cc.o; [100%] Linking CXX shared module testplugin.so; [100%] Built target testplugin. # run sample input.dat; >>> psi4; Attention! This SCF may be",MatchSource.WIKI,psi4manual/1.2.1/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins.html
https://psicode.org/psi4manual/1.2.1/plugins.html:3817,Performance,cache,cache,3817," a blank line. yes, LD_LIBRARY_PATH irrelevant; >>> echo $PYTHONHOME $PYTHONPATH $DYLD_LIBRARY_PATH $PSIDATADIR. >>> which python psi4 g++ gfortran # Linux; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/gcc++; $PSI4CONDA/bin/gfortran; >>> which python psi4 g++ gfortran clang++ # Mac; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/g++; $PSI4CONDA/bin/gfortran; /usr/bin/clang++. >>> which cmake; $PSI4CONDA/bin/cmake; # if above empty, ``conda install cmake``. Create and compile plugin; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35; 36>>> psi4 --plugin-name testplugin; -- Creating ""testplugin"" with ""basic"" template. -----------------; ==> Created plugin files (in testplugin as basic):; __init__.py, CMakeLists.txt, doc.rst, input.dat, plugin.cc, pymodule.py. # move into plugin directory; >>> cd testplugin. # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencies of target testplugin; [ 50%] Building CXX object CMakeFiles/testplugin.dir/plugin.cc.o; [100%] Linking CXX shared module testplugin.so; [100%] Built target testplugin. # run sample input.dat; >>> psi4; Attention! This SCF may be",MatchSource.WIKI,psi4manual/1.2.1/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins.html
https://psicode.org/psi4manual/1.2.1/plugins.html:4156,Performance,load,loading,4156,"SI4CONDA/bin/g++; $PSI4CONDA/bin/gfortran; /usr/bin/clang++. >>> which cmake; $PSI4CONDA/bin/cmake; # if above empty, ``conda install cmake``. Create and compile plugin; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35; 36>>> psi4 --plugin-name testplugin; -- Creating ""testplugin"" with ""basic"" template. -----------------; ==> Created plugin files (in testplugin as basic):; __init__.py, CMakeLists.txt, doc.rst, input.dat, plugin.cc, pymodule.py. # move into plugin directory; >>> cd testplugin. # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencies of target testplugin; [ 50%] Building CXX object CMakeFiles/testplugin.dir/plugin.cc.o; [100%] Linking CXX shared module testplugin.so; [100%] Built target testplugin. # run sample input.dat; >>> psi4; Attention! This SCF may be density-fitted. Please note that the conda distribution must be in $PATH or the; conda enviroment must be activated before compilation and execution of; plugins created using this procedure. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. CMakeLists.txt — CMake fil",MatchSource.WIKI,psi4manual/1.2.1/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins.html
https://psicode.org/psi4manual/1.2.1/plugins.html:4172,Performance,cache,cache,4172,"SI4CONDA/bin/g++; $PSI4CONDA/bin/gfortran; /usr/bin/clang++. >>> which cmake; $PSI4CONDA/bin/cmake; # if above empty, ``conda install cmake``. Create and compile plugin; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35; 36>>> psi4 --plugin-name testplugin; -- Creating ""testplugin"" with ""basic"" template. -----------------; ==> Created plugin files (in testplugin as basic):; __init__.py, CMakeLists.txt, doc.rst, input.dat, plugin.cc, pymodule.py. # move into plugin directory; >>> cd testplugin. # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencies of target testplugin; [ 50%] Building CXX object CMakeFiles/testplugin.dir/plugin.cc.o; [100%] Linking CXX shared module testplugin.so; [100%] Built target testplugin. # run sample input.dat; >>> psi4; Attention! This SCF may be density-fitted. Please note that the conda distribution must be in $PATH or the; conda enviroment must be activated before compilation and execution of; plugins created using this procedure. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. CMakeLists.txt — CMake fil",MatchSource.WIKI,psi4manual/1.2.1/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins.html
https://psicode.org/psi4manual/1.2.1/plugins.html:5493,Performance,load,loading,5493,"in.cc.o; [100%] Linking CXX shared module testplugin.so; [100%] Built target testplugin. # run sample input.dat; >>> psi4; Attention! This SCF may be density-fitted. Please note that the conda distribution must be in $PATH or the; conda enviroment must be activated before compilation and execution of; plugins created using this procedure. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. CMakeLists.txt — CMake file governing project plugin.; The plugin source and CMakeLists.txt is independent of platform; and PSI4 installation. You use CMake (version 3.1 or later); to generate a Makefile for the plugin by pointing it to a specific; PSI4 installation. Run psi4 --plugin-compile to get a command; to execute to generate the Makefile. What that command is doing is; loading the compilers and options used to build the parent PSI4; (the -C psi4PluginCache part) which in turn can be overridden; by passing -Doption=value commands to cmake and pointing; toward a particular PSI4 (and probably pybind11) library to; link against (the CMAKE_PREFIX_PATH part) and telling it to; do an in-source build (the . part). Then just run make in; your plugin directory. After any change to the plugin C++ code,; make must be run in the plugin directory to recompile the; myplugin.so executable, but recompiling the main PSI4 code; is not necessary. Should you add additional (non-header) files to; the plugin or need to link to additional external libraries, add that; information here.; input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file.; This is usually done by manipulating PSIPATH. Then,; the plugin can be loaded as import myplugin and executed as; energy('",MatchSource.WIKI,psi4manual/1.2.1/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins.html
https://psicode.org/psi4manual/1.2.1/plugins.html:6594,Performance,load,loaded,6594,"rridden; by passing -Doption=value commands to cmake and pointing; toward a particular PSI4 (and probably pybind11) library to; link against (the CMAKE_PREFIX_PATH part) and telling it to; do an in-source build (the . part). Then just run make in; your plugin directory. After any change to the plugin C++ code,; make must be run in the plugin directory to recompile the; myplugin.so executable, but recompiling the main PSI4 code; is not necessary. Should you add additional (non-header) files to; the plugin or need to link to additional external libraries, add that; information here.; input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file.; This is usually done by manipulating PSIPATH. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection.; pymodule.py — Python component of the plugin.; By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section). doc.rst — D",MatchSource.WIKI,psi4manual/1.2.1/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins.html
https://psicode.org/psi4manual/1.2.1/plugins.html:8196,Performance,load,loaded,8196,"; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation. Please note that pure virtual functions in a plugin may cause undefined symbols errors when; the plugin is loaded.; To create a purely Python plugin, create a new plugin directory, then; remove the Makefile and myplugin.cc files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; input.dat as a model for loading the plugin, no recompile ever; necessary. table of contents. Plugins: Adding New Functionality to PSI4; Modular Approach to Development; Creating a New Plugin; Creating a New Plugin Using a Conda Pre-compiled Binary; Files in a Plugin Directory. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Contributions: Intro to Programming in PSI4. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins.html
https://psicode.org/psi4manual/1.2.1/plugins.html:8347,Performance,load,loading,8347,"; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation. Please note that pure virtual functions in a plugin may cause undefined symbols errors when; the plugin is loaded.; To create a purely Python plugin, create a new plugin directory, then; remove the Makefile and myplugin.cc files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; input.dat as a model for loading the plugin, no recompile ever; necessary. table of contents. Plugins: Adding New Functionality to PSI4; Modular Approach to Development; Creating a New Plugin; Creating a New Plugin Using a Conda Pre-compiled Binary; Files in a Plugin Directory. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Contributions: Intro to Programming in PSI4. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins.html
https://psicode.org/psi4manual/1.2.1/plugins.html:8487,Performance,load,loading,8487,"; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation. Please note that pure virtual functions in a plugin may cause undefined symbols errors when; the plugin is loaded.; To create a purely Python plugin, create a new plugin directory, then; remove the Makefile and myplugin.cc files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; input.dat as a model for loading the plugin, no recompile ever; necessary. table of contents. Plugins: Adding New Functionality to PSI4; Modular Approach to Development; Creating a New Plugin; Creating a New Plugin Using a Conda Pre-compiled Binary; Files in a Plugin Directory. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Contributions: Intro to Programming in PSI4. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins.html
https://psicode.org/psi4manual/1.2.1/plugins.html:7033,Security,access,accessed,7033,"ctory to recompile the; myplugin.so executable, but recompiling the main PSI4 code; is not necessary. Should you add additional (non-header) files to; the plugin or need to link to additional external libraries, add that; information here.; input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file.; This is usually done by manipulating PSIPATH. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection.; pymodule.py — Python component of the plugin.; By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any doc",MatchSource.WIKI,psi4manual/1.2.1/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins.html
https://psicode.org/psi4manual/1.2.1/plugins.html:3464,Testability,test,testplugin,3464,"an use the gcc; compiler installed alongside psi4 itself in the Conda distribution; or environment (below, $PSI4CONDA). On Mac, one must use; libc++.so (not libstdc++.so), and this can be accomplished by; installing XCode from the App Store that provides clang and; clang++ compilers. Check environment; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18# yes, the following returns a blank line. yes, LD_LIBRARY_PATH irrelevant; >>> echo $PYTHONHOME $PYTHONPATH $DYLD_LIBRARY_PATH $PSIDATADIR. >>> which python psi4 g++ gfortran # Linux; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/gcc++; $PSI4CONDA/bin/gfortran; >>> which python psi4 g++ gfortran clang++ # Mac; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/g++; $PSI4CONDA/bin/gfortran; /usr/bin/clang++. >>> which cmake; $PSI4CONDA/bin/cmake; # if above empty, ``conda install cmake``. Create and compile plugin; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35; 36>>> psi4 --plugin-name testplugin; -- Creating ""testplugin"" with ""basic"" template. -----------------; ==> Created plugin files (in testplugin as basic):; __init__.py, CMakeLists.txt, doc.rst, input.dat, plugin.cc, pymodule.py. # move into plugin directory; >>> cd testplugin. # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++",MatchSource.WIKI,psi4manual/1.2.1/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins.html
https://psicode.org/psi4manual/1.2.1/plugins.html:3489,Testability,test,testplugin,3489,"an use the gcc; compiler installed alongside psi4 itself in the Conda distribution; or environment (below, $PSI4CONDA). On Mac, one must use; libc++.so (not libstdc++.so), and this can be accomplished by; installing XCode from the App Store that provides clang and; clang++ compilers. Check environment; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18# yes, the following returns a blank line. yes, LD_LIBRARY_PATH irrelevant; >>> echo $PYTHONHOME $PYTHONPATH $DYLD_LIBRARY_PATH $PSIDATADIR. >>> which python psi4 g++ gfortran # Linux; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/gcc++; $PSI4CONDA/bin/gfortran; >>> which python psi4 g++ gfortran clang++ # Mac; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/g++; $PSI4CONDA/bin/gfortran; /usr/bin/clang++. >>> which cmake; $PSI4CONDA/bin/cmake; # if above empty, ``conda install cmake``. Create and compile plugin; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35; 36>>> psi4 --plugin-name testplugin; -- Creating ""testplugin"" with ""basic"" template. -----------------; ==> Created plugin files (in testplugin as basic):; __init__.py, CMakeLists.txt, doc.rst, input.dat, plugin.cc, pymodule.py. # move into plugin directory; >>> cd testplugin. # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++",MatchSource.WIKI,psi4manual/1.2.1/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins.html
https://psicode.org/psi4manual/1.2.1/plugins.html:3572,Testability,test,testplugin,3572,"dc++.so), and this can be accomplished by; installing XCode from the App Store that provides clang and; clang++ compilers. Check environment; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18# yes, the following returns a blank line. yes, LD_LIBRARY_PATH irrelevant; >>> echo $PYTHONHOME $PYTHONPATH $DYLD_LIBRARY_PATH $PSIDATADIR. >>> which python psi4 g++ gfortran # Linux; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/gcc++; $PSI4CONDA/bin/gfortran; >>> which python psi4 g++ gfortran clang++ # Mac; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/g++; $PSI4CONDA/bin/gfortran; /usr/bin/clang++. >>> which cmake; $PSI4CONDA/bin/cmake; # if above empty, ``conda install cmake``. Create and compile plugin; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35; 36>>> psi4 --plugin-name testplugin; -- Creating ""testplugin"" with ""basic"" template. -----------------; ==> Created plugin files (in testplugin as basic):; __init__.py, CMakeLists.txt, doc.rst, input.dat, plugin.cc, pymodule.py. # move into plugin directory; >>> cd testplugin. # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencie",MatchSource.WIKI,psi4manual/1.2.1/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins.html
https://psicode.org/psi4manual/1.2.1/plugins.html:3705,Testability,test,testplugin,3705," environment; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18# yes, the following returns a blank line. yes, LD_LIBRARY_PATH irrelevant; >>> echo $PYTHONHOME $PYTHONPATH $DYLD_LIBRARY_PATH $PSIDATADIR. >>> which python psi4 g++ gfortran # Linux; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/gcc++; $PSI4CONDA/bin/gfortran; >>> which python psi4 g++ gfortran clang++ # Mac; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/g++; $PSI4CONDA/bin/gfortran; /usr/bin/clang++. >>> which cmake; $PSI4CONDA/bin/cmake; # if above empty, ``conda install cmake``. Create and compile plugin; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35; 36>>> psi4 --plugin-name testplugin; -- Creating ""testplugin"" with ""basic"" template. -----------------; ==> Created plugin files (in testplugin as basic):; __init__.py, CMakeLists.txt, doc.rst, input.dat, plugin.cc, pymodule.py. # move into plugin directory; >>> cd testplugin. # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencies of target testplugin; [ 50%] Building CXX object CMakeFiles/testplugin.dir/plugin.cc.o; [100%] Linking CXX shared module testp",MatchSource.WIKI,psi4manual/1.2.1/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins.html
https://psicode.org/psi4manual/1.2.1/plugins.html:4109,Testability,test,testplugin,4109,"SI4CONDA/bin/g++; $PSI4CONDA/bin/gfortran; /usr/bin/clang++. >>> which cmake; $PSI4CONDA/bin/cmake; # if above empty, ``conda install cmake``. Create and compile plugin; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35; 36>>> psi4 --plugin-name testplugin; -- Creating ""testplugin"" with ""basic"" template. -----------------; ==> Created plugin files (in testplugin as basic):; __init__.py, CMakeLists.txt, doc.rst, input.dat, plugin.cc, pymodule.py. # move into plugin directory; >>> cd testplugin. # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencies of target testplugin; [ 50%] Building CXX object CMakeFiles/testplugin.dir/plugin.cc.o; [100%] Linking CXX shared module testplugin.so; [100%] Built target testplugin. # run sample input.dat; >>> psi4; Attention! This SCF may be density-fitted. Please note that the conda distribution must be in $PATH or the; conda enviroment must be activated before compilation and execution of; plugins created using this procedure. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. CMakeLists.txt — CMake fil",MatchSource.WIKI,psi4manual/1.2.1/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins.html
https://psicode.org/psi4manual/1.2.1/plugins.html:4475,Testability,test,testplugin,4475,"-plugin-name testplugin; -- Creating ""testplugin"" with ""basic"" template. -----------------; ==> Created plugin files (in testplugin as basic):; __init__.py, CMakeLists.txt, doc.rst, input.dat, plugin.cc, pymodule.py. # move into plugin directory; >>> cd testplugin. # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencies of target testplugin; [ 50%] Building CXX object CMakeFiles/testplugin.dir/plugin.cc.o; [100%] Linking CXX shared module testplugin.so; [100%] Built target testplugin. # run sample input.dat; >>> psi4; Attention! This SCF may be density-fitted. Please note that the conda distribution must be in $PATH or the; conda enviroment must be activated before compilation and execution of; plugins created using this procedure. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. CMakeLists.txt — CMake file governing project plugin.; The plugin source and CMakeLists.txt is independent of platform; and PSI4 installation. You use CMake (version 3.1 or later); to generate a Makefile for the plugin by pointing it to a specific; PSI4 installation. Run psi4 --plugin-compile to get a command; to execute to generate the",MatchSource.WIKI,psi4manual/1.2.1/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins.html
https://psicode.org/psi4manual/1.2.1/plugins.html:4519,Testability,test,testplugin,4519,"asic"" template. -----------------; ==> Created plugin files (in testplugin as basic):; __init__.py, CMakeLists.txt, doc.rst, input.dat, plugin.cc, pymodule.py. # move into plugin directory; >>> cd testplugin. # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencies of target testplugin; [ 50%] Building CXX object CMakeFiles/testplugin.dir/plugin.cc.o; [100%] Linking CXX shared module testplugin.so; [100%] Built target testplugin. # run sample input.dat; >>> psi4; Attention! This SCF may be density-fitted. Please note that the conda distribution must be in $PATH or the; conda enviroment must be activated before compilation and execution of; plugins created using this procedure. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. CMakeLists.txt — CMake file governing project plugin.; The plugin source and CMakeLists.txt is independent of platform; and PSI4 installation. You use CMake (version 3.1 or later); to generate a Makefile for the plugin by pointing it to a specific; PSI4 installation. Run psi4 --plugin-compile to get a command; to execute to generate the Makefile. What that command is doing is; loading the com",MatchSource.WIKI,psi4manual/1.2.1/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins.html
https://psicode.org/psi4manual/1.2.1/plugins.html:4576,Testability,test,testplugin,4576,"as basic):; __init__.py, CMakeLists.txt, doc.rst, input.dat, plugin.cc, pymodule.py. # move into plugin directory; >>> cd testplugin. # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencies of target testplugin; [ 50%] Building CXX object CMakeFiles/testplugin.dir/plugin.cc.o; [100%] Linking CXX shared module testplugin.so; [100%] Built target testplugin. # run sample input.dat; >>> psi4; Attention! This SCF may be density-fitted. Please note that the conda distribution must be in $PATH or the; conda enviroment must be activated before compilation and execution of; plugins created using this procedure. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. CMakeLists.txt — CMake file governing project plugin.; The plugin source and CMakeLists.txt is independent of platform; and PSI4 installation. You use CMake (version 3.1 or later); to generate a Makefile for the plugin by pointing it to a specific; PSI4 installation. Run psi4 --plugin-compile to get a command; to execute to generate the Makefile. What that command is doing is; loading the compilers and options used to build the parent PSI4; (the -C psi4PluginCache pa",MatchSource.WIKI,psi4manual/1.2.1/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins.html
https://psicode.org/psi4manual/1.2.1/plugins.html:4626,Testability,test,testplugin,4626,"as basic):; __init__.py, CMakeLists.txt, doc.rst, input.dat, plugin.cc, pymodule.py. # move into plugin directory; >>> cd testplugin. # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencies of target testplugin; [ 50%] Building CXX object CMakeFiles/testplugin.dir/plugin.cc.o; [100%] Linking CXX shared module testplugin.so; [100%] Built target testplugin. # run sample input.dat; >>> psi4; Attention! This SCF may be density-fitted. Please note that the conda distribution must be in $PATH or the; conda enviroment must be activated before compilation and execution of; plugins created using this procedure. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. CMakeLists.txt — CMake file governing project plugin.; The plugin source and CMakeLists.txt is independent of platform; and PSI4 installation. You use CMake (version 3.1 or later); to generate a Makefile for the plugin by pointing it to a specific; PSI4 installation. Run psi4 --plugin-compile to get a command; to execute to generate the Makefile. What that command is doing is; loading the compilers and options used to build the parent PSI4; (the -C psi4PluginCache pa",MatchSource.WIKI,psi4manual/1.2.1/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins.html
https://psicode.org/psi4manual/1.2.1/plugins.html:4687,Testability,test,testplugin,4687," into plugin directory; >>> cd testplugin. # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencies of target testplugin; [ 50%] Building CXX object CMakeFiles/testplugin.dir/plugin.cc.o; [100%] Linking CXX shared module testplugin.so; [100%] Built target testplugin. # run sample input.dat; >>> psi4; Attention! This SCF may be density-fitted. Please note that the conda distribution must be in $PATH or the; conda enviroment must be activated before compilation and execution of; plugins created using this procedure. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. CMakeLists.txt — CMake file governing project plugin.; The plugin source and CMakeLists.txt is independent of platform; and PSI4 installation. You use CMake (version 3.1 or later); to generate a Makefile for the plugin by pointing it to a specific; PSI4 installation. Run psi4 --plugin-compile to get a command; to execute to generate the Makefile. What that command is doing is; loading the compilers and options used to build the parent PSI4; (the -C psi4PluginCache part) which in turn can be overridden; by passing -Doption=value commands to cmake and pointi",MatchSource.WIKI,psi4manual/1.2.1/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins.html
https://psicode.org/psi4manual/1.2.1/plugins.html:4722,Testability,test,testplugin,4722,". # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencies of target testplugin; [ 50%] Building CXX object CMakeFiles/testplugin.dir/plugin.cc.o; [100%] Linking CXX shared module testplugin.so; [100%] Built target testplugin. # run sample input.dat; >>> psi4; Attention! This SCF may be density-fitted. Please note that the conda distribution must be in $PATH or the; conda enviroment must be activated before compilation and execution of; plugins created using this procedure. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. CMakeLists.txt — CMake file governing project plugin.; The plugin source and CMakeLists.txt is independent of platform; and PSI4 installation. You use CMake (version 3.1 or later); to generate a Makefile for the plugin by pointing it to a specific; PSI4 installation. Run psi4 --plugin-compile to get a command; to execute to generate the Makefile. What that command is doing is; loading the compilers and options used to build the parent PSI4; (the -C psi4PluginCache part) which in turn can be overridden; by passing -Doption=value commands to cmake and pointing; toward a particular PSI4 (and probabl",MatchSource.WIKI,psi4manual/1.2.1/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins.html
https://psicode.org/psi4manual/1.2.1/plugins.html:6739,Testability,test,testfunction,6739,"E_PREFIX_PATH part) and telling it to; do an in-source build (the . part). Then just run make in; your plugin directory. After any change to the plugin C++ code,; make must be run in the plugin directory to recompile the; myplugin.so executable, but recompiling the main PSI4 code; is not necessary. Should you add additional (non-header) files to; the plugin or need to link to additional external libraries, add that; information here.; input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file.; This is usually done by manipulating PSIPATH. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection.; pymodule.py — Python component of the plugin.; By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the u",MatchSource.WIKI,psi4manual/1.2.1/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins.html
https://psicode.org/psi4manual/1.2.1/plugins.html:416,Usability,learn,learn,416,"﻿. Plugins: Adding New Functionality to PSI4. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Contributions: Intro to Programming in PSI4. Plugins: Adding New Functionality to PSI4¶. Modular Approach to Development¶; It is slightly cumbersome to the development cycle to recompile PSI4; every time a change is made to the C++ code.; It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with Psi3 due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; 1>>> psi4 --plugin-name myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory, use PSI4 to generate; a Makefile, and type make. Then execute psi4 in the directory on the; default input file.; 1; 2; 3; 4>>> cd myplugin; >>> `psi4 --plugin-compile`; >>> make; >>> psi4. PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; 1; 2; 3; 4; 5; 6>>> psi4 --plugin-name myplugin --plugin-template aointegrals; >>> psi4 --plugin-name myplugin --plugin-template mointegrals; >>> psi4 --plugin-name myplugin --plu",MatchSource.WIKI,psi4manual/1.2.1/plugins.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins.html
https://psicode.org/psi4manual/1.2.1/plugin_snsmp2-1.html:610,Availability,avail,available,610,"﻿. Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw¶; Code author: D. E. Shaw Research; Section author: Shannon E. Houck. This plugin is an implementation of the SNS-MP2 algorithm developed by McGibbon; et. al. [McGibbon:2017:161725]. The SNS-MP2 method uses neural networking to; improve the accuracy of MP2 (dfmp2) interaction energies for dimer molecules.; The plugin is distributed under the 2-clause BSD license. Installation¶; Binary. snsmp2 is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). If using the Psi4conda installer, snsmp2 has already been installed alongside. If using the PSI4 conda package, the snsmp2 conda package can; be obtained through conda install snsmp2 -c psi4 or conda install; psi4-rt -c psi4. If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; snsmp2 can be obtained through conda install snsmp2 -c psi4.; Then, hint its location with PYTHONPATH. To remove a conda installation, conda remove snsmp2. Source. Download the plugin from the GitHub repository:; >>> git clone https://github.com/DEShawResearch/sns-mp2. Once dowloaded, the plugin can be installed as outlined in the documentation:; >>> cd {top-level-sns-mp2-directory}; >>> PSI4_PYTHON=$(head $(which psi4) -n 1 | sed -r 's/^.{2}//'); >>> $PSI4_PYTHON -m pip install . Sample Input¶; A sample input file, adapted from the documentation, is shown below:; 1; 2; 3; 4; 5; 6; 7; 8; 9# Sample SNS-MP2 calculation for two helium atoms. molecule dimer {; He 0 0 0; --; He 2 0 0; }. energy('sns-mp2'). Note that the two monomers are separated by double dashes, indicating that; they should be treated as separate molecules. (See; sec:analysis-of-intermolecular-interactions for more details on; setting up dimer molecules.) This input file ",MatchSource.WIKI,psi4manual/1.2.1/plugin_snsmp2-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugin_snsmp2-1.html
https://psicode.org/psi4manual/1.2.1/plugin_snsmp2-1.html:723,Deployability,install,installer,723,"﻿. Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw¶; Code author: D. E. Shaw Research; Section author: Shannon E. Houck. This plugin is an implementation of the SNS-MP2 algorithm developed by McGibbon; et. al. [McGibbon:2017:161725]. The SNS-MP2 method uses neural networking to; improve the accuracy of MP2 (dfmp2) interaction energies for dimer molecules.; The plugin is distributed under the 2-clause BSD license. Installation¶; Binary. snsmp2 is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). If using the Psi4conda installer, snsmp2 has already been installed alongside. If using the PSI4 conda package, the snsmp2 conda package can; be obtained through conda install snsmp2 -c psi4 or conda install; psi4-rt -c psi4. If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; snsmp2 can be obtained through conda install snsmp2 -c psi4.; Then, hint its location with PYTHONPATH. To remove a conda installation, conda remove snsmp2. Source. Download the plugin from the GitHub repository:; >>> git clone https://github.com/DEShawResearch/sns-mp2. Once dowloaded, the plugin can be installed as outlined in the documentation:; >>> cd {top-level-sns-mp2-directory}; >>> PSI4_PYTHON=$(head $(which psi4) -n 1 | sed -r 's/^.{2}//'); >>> $PSI4_PYTHON -m pip install . Sample Input¶; A sample input file, adapted from the documentation, is shown below:; 1; 2; 3; 4; 5; 6; 7; 8; 9# Sample SNS-MP2 calculation for two helium atoms. molecule dimer {; He 0 0 0; --; He 2 0 0; }. energy('sns-mp2'). Note that the two monomers are separated by double dashes, indicating that; they should be treated as separate molecules. (See; sec:analysis-of-intermolecular-interactions for more details on; setting up dimer molecules.) This input file ",MatchSource.WIKI,psi4manual/1.2.1/plugin_snsmp2-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugin_snsmp2-1.html
https://psicode.org/psi4manual/1.2.1/plugin_snsmp2-1.html:758,Deployability,install,installed,758,"﻿. Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw¶; Code author: D. E. Shaw Research; Section author: Shannon E. Houck. This plugin is an implementation of the SNS-MP2 algorithm developed by McGibbon; et. al. [McGibbon:2017:161725]. The SNS-MP2 method uses neural networking to; improve the accuracy of MP2 (dfmp2) interaction energies for dimer molecules.; The plugin is distributed under the 2-clause BSD license. Installation¶; Binary. snsmp2 is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). If using the Psi4conda installer, snsmp2 has already been installed alongside. If using the PSI4 conda package, the snsmp2 conda package can; be obtained through conda install snsmp2 -c psi4 or conda install; psi4-rt -c psi4. If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; snsmp2 can be obtained through conda install snsmp2 -c psi4.; Then, hint its location with PYTHONPATH. To remove a conda installation, conda remove snsmp2. Source. Download the plugin from the GitHub repository:; >>> git clone https://github.com/DEShawResearch/sns-mp2. Once dowloaded, the plugin can be installed as outlined in the documentation:; >>> cd {top-level-sns-mp2-directory}; >>> PSI4_PYTHON=$(head $(which psi4) -n 1 | sed -r 's/^.{2}//'); >>> $PSI4_PYTHON -m pip install . Sample Input¶; A sample input file, adapted from the documentation, is shown below:; 1; 2; 3; 4; 5; 6; 7; 8; 9# Sample SNS-MP2 calculation for two helium atoms. molecule dimer {; He 0 0 0; --; He 2 0 0; }. energy('sns-mp2'). Note that the two monomers are separated by double dashes, indicating that; they should be treated as separate molecules. (See; sec:analysis-of-intermolecular-interactions for more details on; setting up dimer molecules.) This input file ",MatchSource.WIKI,psi4manual/1.2.1/plugin_snsmp2-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugin_snsmp2-1.html
https://psicode.org/psi4manual/1.2.1/plugin_snsmp2-1.html:868,Deployability,install,install,868,"﻿. Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw¶; Code author: D. E. Shaw Research; Section author: Shannon E. Houck. This plugin is an implementation of the SNS-MP2 algorithm developed by McGibbon; et. al. [McGibbon:2017:161725]. The SNS-MP2 method uses neural networking to; improve the accuracy of MP2 (dfmp2) interaction energies for dimer molecules.; The plugin is distributed under the 2-clause BSD license. Installation¶; Binary. snsmp2 is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). If using the Psi4conda installer, snsmp2 has already been installed alongside. If using the PSI4 conda package, the snsmp2 conda package can; be obtained through conda install snsmp2 -c psi4 or conda install; psi4-rt -c psi4. If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; snsmp2 can be obtained through conda install snsmp2 -c psi4.; Then, hint its location with PYTHONPATH. To remove a conda installation, conda remove snsmp2. Source. Download the plugin from the GitHub repository:; >>> git clone https://github.com/DEShawResearch/sns-mp2. Once dowloaded, the plugin can be installed as outlined in the documentation:; >>> cd {top-level-sns-mp2-directory}; >>> PSI4_PYTHON=$(head $(which psi4) -n 1 | sed -r 's/^.{2}//'); >>> $PSI4_PYTHON -m pip install . Sample Input¶; A sample input file, adapted from the documentation, is shown below:; 1; 2; 3; 4; 5; 6; 7; 8; 9# Sample SNS-MP2 calculation for two helium atoms. molecule dimer {; He 0 0 0; --; He 2 0 0; }. energy('sns-mp2'). Note that the two monomers are separated by double dashes, indicating that; they should be treated as separate molecules. (See; sec:analysis-of-intermolecular-interactions for more details on; setting up dimer molecules.) This input file ",MatchSource.WIKI,psi4manual/1.2.1/plugin_snsmp2-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugin_snsmp2-1.html
https://psicode.org/psi4manual/1.2.1/plugin_snsmp2-1.html:900,Deployability,install,install,900,"﻿. Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw¶; Code author: D. E. Shaw Research; Section author: Shannon E. Houck. This plugin is an implementation of the SNS-MP2 algorithm developed by McGibbon; et. al. [McGibbon:2017:161725]. The SNS-MP2 method uses neural networking to; improve the accuracy of MP2 (dfmp2) interaction energies for dimer molecules.; The plugin is distributed under the 2-clause BSD license. Installation¶; Binary. snsmp2 is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). If using the Psi4conda installer, snsmp2 has already been installed alongside. If using the PSI4 conda package, the snsmp2 conda package can; be obtained through conda install snsmp2 -c psi4 or conda install; psi4-rt -c psi4. If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; snsmp2 can be obtained through conda install snsmp2 -c psi4.; Then, hint its location with PYTHONPATH. To remove a conda installation, conda remove snsmp2. Source. Download the plugin from the GitHub repository:; >>> git clone https://github.com/DEShawResearch/sns-mp2. Once dowloaded, the plugin can be installed as outlined in the documentation:; >>> cd {top-level-sns-mp2-directory}; >>> PSI4_PYTHON=$(head $(which psi4) -n 1 | sed -r 's/^.{2}//'); >>> $PSI4_PYTHON -m pip install . Sample Input¶; A sample input file, adapted from the documentation, is shown below:; 1; 2; 3; 4; 5; 6; 7; 8; 9# Sample SNS-MP2 calculation for two helium atoms. molecule dimer {; He 0 0 0; --; He 2 0 0; }. energy('sns-mp2'). Note that the two monomers are separated by double dashes, indicating that; they should be treated as separate molecules. (See; sec:analysis-of-intermolecular-interactions for more details on; setting up dimer molecules.) This input file ",MatchSource.WIKI,psi4manual/1.2.1/plugin_snsmp2-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugin_snsmp2-1.html
https://psicode.org/psi4manual/1.2.1/plugin_snsmp2-1.html:1003,Deployability,install,installed,1003,"aled MP2 (SNS-MP2) by D. E. Shaw. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw¶; Code author: D. E. Shaw Research; Section author: Shannon E. Houck. This plugin is an implementation of the SNS-MP2 algorithm developed by McGibbon; et. al. [McGibbon:2017:161725]. The SNS-MP2 method uses neural networking to; improve the accuracy of MP2 (dfmp2) interaction energies for dimer molecules.; The plugin is distributed under the 2-clause BSD license. Installation¶; Binary. snsmp2 is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). If using the Psi4conda installer, snsmp2 has already been installed alongside. If using the PSI4 conda package, the snsmp2 conda package can; be obtained through conda install snsmp2 -c psi4 or conda install; psi4-rt -c psi4. If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; snsmp2 can be obtained through conda install snsmp2 -c psi4.; Then, hint its location with PYTHONPATH. To remove a conda installation, conda remove snsmp2. Source. Download the plugin from the GitHub repository:; >>> git clone https://github.com/DEShawResearch/sns-mp2. Once dowloaded, the plugin can be installed as outlined in the documentation:; >>> cd {top-level-sns-mp2-directory}; >>> PSI4_PYTHON=$(head $(which psi4) -n 1 | sed -r 's/^.{2}//'); >>> $PSI4_PYTHON -m pip install . Sample Input¶; A sample input file, adapted from the documentation, is shown below:; 1; 2; 3; 4; 5; 6; 7; 8; 9# Sample SNS-MP2 calculation for two helium atoms. molecule dimer {; He 0 0 0; --; He 2 0 0; }. energy('sns-mp2'). Note that the two monomers are separated by double dashes, indicating that; they should be treated as separate molecules. (See; sec:analysis-of-intermolecular-interactions for more details on; setting up dimer molecules.) This input file can be run in the ",MatchSource.WIKI,psi4manual/1.2.1/plugin_snsmp2-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugin_snsmp2-1.html
https://psicode.org/psi4manual/1.2.1/plugin_snsmp2-1.html:1089,Deployability,install,install,1089,"aled MP2 (SNS-MP2) by D. E. Shaw. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw¶; Code author: D. E. Shaw Research; Section author: Shannon E. Houck. This plugin is an implementation of the SNS-MP2 algorithm developed by McGibbon; et. al. [McGibbon:2017:161725]. The SNS-MP2 method uses neural networking to; improve the accuracy of MP2 (dfmp2) interaction energies for dimer molecules.; The plugin is distributed under the 2-clause BSD license. Installation¶; Binary. snsmp2 is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). If using the Psi4conda installer, snsmp2 has already been installed alongside. If using the PSI4 conda package, the snsmp2 conda package can; be obtained through conda install snsmp2 -c psi4 or conda install; psi4-rt -c psi4. If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; snsmp2 can be obtained through conda install snsmp2 -c psi4.; Then, hint its location with PYTHONPATH. To remove a conda installation, conda remove snsmp2. Source. Download the plugin from the GitHub repository:; >>> git clone https://github.com/DEShawResearch/sns-mp2. Once dowloaded, the plugin can be installed as outlined in the documentation:; >>> cd {top-level-sns-mp2-directory}; >>> PSI4_PYTHON=$(head $(which psi4) -n 1 | sed -r 's/^.{2}//'); >>> $PSI4_PYTHON -m pip install . Sample Input¶; A sample input file, adapted from the documentation, is shown below:; 1; 2; 3; 4; 5; 6; 7; 8; 9# Sample SNS-MP2 calculation for two helium atoms. molecule dimer {; He 0 0 0; --; He 2 0 0; }. energy('sns-mp2'). Note that the two monomers are separated by double dashes, indicating that; they should be treated as separate molecules. (See; sec:analysis-of-intermolecular-interactions for more details on; setting up dimer molecules.) This input file can be run in the ",MatchSource.WIKI,psi4manual/1.2.1/plugin_snsmp2-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugin_snsmp2-1.html
https://psicode.org/psi4manual/1.2.1/plugin_snsmp2-1.html:1173,Deployability,install,installation,1173,"ed MP2 (SNS-MP2) by D. E. Shaw¶; Code author: D. E. Shaw Research; Section author: Shannon E. Houck. This plugin is an implementation of the SNS-MP2 algorithm developed by McGibbon; et. al. [McGibbon:2017:161725]. The SNS-MP2 method uses neural networking to; improve the accuracy of MP2 (dfmp2) interaction energies for dimer molecules.; The plugin is distributed under the 2-clause BSD license. Installation¶; Binary. snsmp2 is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). If using the Psi4conda installer, snsmp2 has already been installed alongside. If using the PSI4 conda package, the snsmp2 conda package can; be obtained through conda install snsmp2 -c psi4 or conda install; psi4-rt -c psi4. If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; snsmp2 can be obtained through conda install snsmp2 -c psi4.; Then, hint its location with PYTHONPATH. To remove a conda installation, conda remove snsmp2. Source. Download the plugin from the GitHub repository:; >>> git clone https://github.com/DEShawResearch/sns-mp2. Once dowloaded, the plugin can be installed as outlined in the documentation:; >>> cd {top-level-sns-mp2-directory}; >>> PSI4_PYTHON=$(head $(which psi4) -n 1 | sed -r 's/^.{2}//'); >>> $PSI4_PYTHON -m pip install . Sample Input¶; A sample input file, adapted from the documentation, is shown below:; 1; 2; 3; 4; 5; 6; 7; 8; 9# Sample SNS-MP2 calculation for two helium atoms. molecule dimer {; He 0 0 0; --; He 2 0 0; }. energy('sns-mp2'). Note that the two monomers are separated by double dashes, indicating that; they should be treated as separate molecules. (See; sec:analysis-of-intermolecular-interactions for more details on; setting up dimer molecules.) This input file can be run in the usual fashion:; >>> psi4 input.dat. table of contents. Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw; Installation; Sample Input. «; hide menu. menu; sidebar; »",MatchSource.WIKI,psi4manual/1.2.1/plugin_snsmp2-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugin_snsmp2-1.html
https://psicode.org/psi4manual/1.2.1/plugin_snsmp2-1.html:1356,Deployability,install,installed,1356,"thod uses neural networking to; improve the accuracy of MP2 (dfmp2) interaction energies for dimer molecules.; The plugin is distributed under the 2-clause BSD license. Installation¶; Binary. snsmp2 is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). If using the Psi4conda installer, snsmp2 has already been installed alongside. If using the PSI4 conda package, the snsmp2 conda package can; be obtained through conda install snsmp2 -c psi4 or conda install; psi4-rt -c psi4. If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; snsmp2 can be obtained through conda install snsmp2 -c psi4.; Then, hint its location with PYTHONPATH. To remove a conda installation, conda remove snsmp2. Source. Download the plugin from the GitHub repository:; >>> git clone https://github.com/DEShawResearch/sns-mp2. Once dowloaded, the plugin can be installed as outlined in the documentation:; >>> cd {top-level-sns-mp2-directory}; >>> PSI4_PYTHON=$(head $(which psi4) -n 1 | sed -r 's/^.{2}//'); >>> $PSI4_PYTHON -m pip install . Sample Input¶; A sample input file, adapted from the documentation, is shown below:; 1; 2; 3; 4; 5; 6; 7; 8; 9# Sample SNS-MP2 calculation for two helium atoms. molecule dimer {; He 0 0 0; --; He 2 0 0; }. energy('sns-mp2'). Note that the two monomers are separated by double dashes, indicating that; they should be treated as separate molecules. (See; sec:analysis-of-intermolecular-interactions for more details on; setting up dimer molecules.) This input file can be run in the usual fashion:; >>> psi4 input.dat. table of contents. Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw; Installation; Sample Input. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.",MatchSource.WIKI,psi4manual/1.2.1/plugin_snsmp2-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugin_snsmp2-1.html
https://psicode.org/psi4manual/1.2.1/plugin_snsmp2-1.html:1528,Deployability,install,install,1528,"ses neural networking to; improve the accuracy of MP2 (dfmp2) interaction energies for dimer molecules.; The plugin is distributed under the 2-clause BSD license. Installation¶; Binary. snsmp2 is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). If using the Psi4conda installer, snsmp2 has already been installed alongside. If using the PSI4 conda package, the snsmp2 conda package can; be obtained through conda install snsmp2 -c psi4 or conda install; psi4-rt -c psi4. If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; snsmp2 can be obtained through conda install snsmp2 -c psi4.; Then, hint its location with PYTHONPATH. To remove a conda installation, conda remove snsmp2. Source. Download the plugin from the GitHub repository:; >>> git clone https://github.com/DEShawResearch/sns-mp2. Once dowloaded, the plugin can be installed as outlined in the documentation:; >>> cd {top-level-sns-mp2-directory}; >>> PSI4_PYTHON=$(head $(which psi4) -n 1 | sed -r 's/^.{2}//'); >>> $PSI4_PYTHON -m pip install . Sample Input¶; A sample input file, adapted from the documentation, is shown below:; 1; 2; 3; 4; 5; 6; 7; 8; 9# Sample SNS-MP2 calculation for two helium atoms. molecule dimer {; He 0 0 0; --; He 2 0 0; }. energy('sns-mp2'). Note that the two monomers are separated by double dashes, indicating that; they should be treated as separate molecules. (See; sec:analysis-of-intermolecular-interactions for more details on; setting up dimer molecules.) This input file can be run in the usual fashion:; >>> psi4 input.dat. table of contents. Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw; Installation; Sample Input. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/plugin_snsmp2-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugin_snsmp2-1.html
https://psicode.org/psi4manual/1.2.1/plugin_snsmp2-1.html:2338,Deployability,update,updated,2338,"ses neural networking to; improve the accuracy of MP2 (dfmp2) interaction energies for dimer molecules.; The plugin is distributed under the 2-clause BSD license. Installation¶; Binary. snsmp2 is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). If using the Psi4conda installer, snsmp2 has already been installed alongside. If using the PSI4 conda package, the snsmp2 conda package can; be obtained through conda install snsmp2 -c psi4 or conda install; psi4-rt -c psi4. If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; snsmp2 can be obtained through conda install snsmp2 -c psi4.; Then, hint its location with PYTHONPATH. To remove a conda installation, conda remove snsmp2. Source. Download the plugin from the GitHub repository:; >>> git clone https://github.com/DEShawResearch/sns-mp2. Once dowloaded, the plugin can be installed as outlined in the documentation:; >>> cd {top-level-sns-mp2-directory}; >>> PSI4_PYTHON=$(head $(which psi4) -n 1 | sed -r 's/^.{2}//'); >>> $PSI4_PYTHON -m pip install . Sample Input¶; A sample input file, adapted from the documentation, is shown below:; 1; 2; 3; 4; 5; 6; 7; 8; 9# Sample SNS-MP2 calculation for two helium atoms. molecule dimer {; He 0 0 0; --; He 2 0 0; }. energy('sns-mp2'). Note that the two monomers are separated by double dashes, indicating that; they should be treated as separate molecules. (See; sec:analysis-of-intermolecular-interactions for more details on; setting up dimer molecules.) This input file can be run in the usual fashion:; >>> psi4 input.dat. table of contents. Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw; Installation; Sample Input. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/plugin_snsmp2-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugin_snsmp2-1.html
https://psicode.org/psi4manual/1.2.1/plugin_snsmp2-1.html:1574,Energy Efficiency,adapt,adapted,1574,"ses neural networking to; improve the accuracy of MP2 (dfmp2) interaction energies for dimer molecules.; The plugin is distributed under the 2-clause BSD license. Installation¶; Binary. snsmp2 is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). If using the Psi4conda installer, snsmp2 has already been installed alongside. If using the PSI4 conda package, the snsmp2 conda package can; be obtained through conda install snsmp2 -c psi4 or conda install; psi4-rt -c psi4. If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; snsmp2 can be obtained through conda install snsmp2 -c psi4.; Then, hint its location with PYTHONPATH. To remove a conda installation, conda remove snsmp2. Source. Download the plugin from the GitHub repository:; >>> git clone https://github.com/DEShawResearch/sns-mp2. Once dowloaded, the plugin can be installed as outlined in the documentation:; >>> cd {top-level-sns-mp2-directory}; >>> PSI4_PYTHON=$(head $(which psi4) -n 1 | sed -r 's/^.{2}//'); >>> $PSI4_PYTHON -m pip install . Sample Input¶; A sample input file, adapted from the documentation, is shown below:; 1; 2; 3; 4; 5; 6; 7; 8; 9# Sample SNS-MP2 calculation for two helium atoms. molecule dimer {; He 0 0 0; --; He 2 0 0; }. energy('sns-mp2'). Note that the two monomers are separated by double dashes, indicating that; they should be treated as separate molecules. (See; sec:analysis-of-intermolecular-interactions for more details on; setting up dimer molecules.) This input file can be run in the usual fashion:; >>> psi4 input.dat. table of contents. Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw; Installation; Sample Input. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/plugin_snsmp2-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugin_snsmp2-1.html
https://psicode.org/psi4manual/1.2.1/plugin_snsmp2-1.html:1744,Energy Efficiency,energy,energy,1744,"ses neural networking to; improve the accuracy of MP2 (dfmp2) interaction energies for dimer molecules.; The plugin is distributed under the 2-clause BSD license. Installation¶; Binary. snsmp2 is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). If using the Psi4conda installer, snsmp2 has already been installed alongside. If using the PSI4 conda package, the snsmp2 conda package can; be obtained through conda install snsmp2 -c psi4 or conda install; psi4-rt -c psi4. If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; snsmp2 can be obtained through conda install snsmp2 -c psi4.; Then, hint its location with PYTHONPATH. To remove a conda installation, conda remove snsmp2. Source. Download the plugin from the GitHub repository:; >>> git clone https://github.com/DEShawResearch/sns-mp2. Once dowloaded, the plugin can be installed as outlined in the documentation:; >>> cd {top-level-sns-mp2-directory}; >>> PSI4_PYTHON=$(head $(which psi4) -n 1 | sed -r 's/^.{2}//'); >>> $PSI4_PYTHON -m pip install . Sample Input¶; A sample input file, adapted from the documentation, is shown below:; 1; 2; 3; 4; 5; 6; 7; 8; 9# Sample SNS-MP2 calculation for two helium atoms. molecule dimer {; He 0 0 0; --; He 2 0 0; }. energy('sns-mp2'). Note that the two monomers are separated by double dashes, indicating that; they should be treated as separate molecules. (See; sec:analysis-of-intermolecular-interactions for more details on; setting up dimer molecules.) This input file can be run in the usual fashion:; >>> psi4 input.dat. table of contents. Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw; Installation; Sample Input. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/plugin_snsmp2-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugin_snsmp2-1.html
https://psicode.org/psi4manual/1.2.1/plugin_snsmp2-1.html:286,Modifiability,plugin,plugin,286,"﻿. Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw¶; Code author: D. E. Shaw Research; Section author: Shannon E. Houck. This plugin is an implementation of the SNS-MP2 algorithm developed by McGibbon; et. al. [McGibbon:2017:161725]. The SNS-MP2 method uses neural networking to; improve the accuracy of MP2 (dfmp2) interaction energies for dimer molecules.; The plugin is distributed under the 2-clause BSD license. Installation¶; Binary. snsmp2 is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). If using the Psi4conda installer, snsmp2 has already been installed alongside. If using the PSI4 conda package, the snsmp2 conda package can; be obtained through conda install snsmp2 -c psi4 or conda install; psi4-rt -c psi4. If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; snsmp2 can be obtained through conda install snsmp2 -c psi4.; Then, hint its location with PYTHONPATH. To remove a conda installation, conda remove snsmp2. Source. Download the plugin from the GitHub repository:; >>> git clone https://github.com/DEShawResearch/sns-mp2. Once dowloaded, the plugin can be installed as outlined in the documentation:; >>> cd {top-level-sns-mp2-directory}; >>> PSI4_PYTHON=$(head $(which psi4) -n 1 | sed -r 's/^.{2}//'); >>> $PSI4_PYTHON -m pip install . Sample Input¶; A sample input file, adapted from the documentation, is shown below:; 1; 2; 3; 4; 5; 6; 7; 8; 9# Sample SNS-MP2 calculation for two helium atoms. molecule dimer {; He 0 0 0; --; He 2 0 0; }. energy('sns-mp2'). Note that the two monomers are separated by double dashes, indicating that; they should be treated as separate molecules. (See; sec:analysis-of-intermolecular-interactions for more details on; setting up dimer molecules.) This input file ",MatchSource.WIKI,psi4manual/1.2.1/plugin_snsmp2-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugin_snsmp2-1.html
https://psicode.org/psi4manual/1.2.1/plugin_snsmp2-1.html:523,Modifiability,plugin,plugin,523,"﻿. Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw¶; Code author: D. E. Shaw Research; Section author: Shannon E. Houck. This plugin is an implementation of the SNS-MP2 algorithm developed by McGibbon; et. al. [McGibbon:2017:161725]. The SNS-MP2 method uses neural networking to; improve the accuracy of MP2 (dfmp2) interaction energies for dimer molecules.; The plugin is distributed under the 2-clause BSD license. Installation¶; Binary. snsmp2 is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). If using the Psi4conda installer, snsmp2 has already been installed alongside. If using the PSI4 conda package, the snsmp2 conda package can; be obtained through conda install snsmp2 -c psi4 or conda install; psi4-rt -c psi4. If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; snsmp2 can be obtained through conda install snsmp2 -c psi4.; Then, hint its location with PYTHONPATH. To remove a conda installation, conda remove snsmp2. Source. Download the plugin from the GitHub repository:; >>> git clone https://github.com/DEShawResearch/sns-mp2. Once dowloaded, the plugin can be installed as outlined in the documentation:; >>> cd {top-level-sns-mp2-directory}; >>> PSI4_PYTHON=$(head $(which psi4) -n 1 | sed -r 's/^.{2}//'); >>> $PSI4_PYTHON -m pip install . Sample Input¶; A sample input file, adapted from the documentation, is shown below:; 1; 2; 3; 4; 5; 6; 7; 8; 9# Sample SNS-MP2 calculation for two helium atoms. molecule dimer {; He 0 0 0; --; He 2 0 0; }. energy('sns-mp2'). Note that the two monomers are separated by double dashes, indicating that; they should be treated as separate molecules. (See; sec:analysis-of-intermolecular-interactions for more details on; setting up dimer molecules.) This input file ",MatchSource.WIKI,psi4manual/1.2.1/plugin_snsmp2-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugin_snsmp2-1.html
https://psicode.org/psi4manual/1.2.1/plugin_snsmp2-1.html:1229,Modifiability,plugin,plugin,1229," author: Shannon E. Houck. This plugin is an implementation of the SNS-MP2 algorithm developed by McGibbon; et. al. [McGibbon:2017:161725]. The SNS-MP2 method uses neural networking to; improve the accuracy of MP2 (dfmp2) interaction energies for dimer molecules.; The plugin is distributed under the 2-clause BSD license. Installation¶; Binary. snsmp2 is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). If using the Psi4conda installer, snsmp2 has already been installed alongside. If using the PSI4 conda package, the snsmp2 conda package can; be obtained through conda install snsmp2 -c psi4 or conda install; psi4-rt -c psi4. If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; snsmp2 can be obtained through conda install snsmp2 -c psi4.; Then, hint its location with PYTHONPATH. To remove a conda installation, conda remove snsmp2. Source. Download the plugin from the GitHub repository:; >>> git clone https://github.com/DEShawResearch/sns-mp2. Once dowloaded, the plugin can be installed as outlined in the documentation:; >>> cd {top-level-sns-mp2-directory}; >>> PSI4_PYTHON=$(head $(which psi4) -n 1 | sed -r 's/^.{2}//'); >>> $PSI4_PYTHON -m pip install . Sample Input¶; A sample input file, adapted from the documentation, is shown below:; 1; 2; 3; 4; 5; 6; 7; 8; 9# Sample SNS-MP2 calculation for two helium atoms. molecule dimer {; He 0 0 0; --; He 2 0 0; }. energy('sns-mp2'). Note that the two monomers are separated by double dashes, indicating that; they should be treated as separate molecules. (See; sec:analysis-of-intermolecular-interactions for more details on; setting up dimer molecules.) This input file can be run in the usual fashion:; >>> psi4 input.dat. table of contents. Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw; Installation; Sample Input. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. ",MatchSource.WIKI,psi4manual/1.2.1/plugin_snsmp2-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugin_snsmp2-1.html
https://psicode.org/psi4manual/1.2.1/plugin_snsmp2-1.html:1342,Modifiability,plugin,plugin,1342,"thod uses neural networking to; improve the accuracy of MP2 (dfmp2) interaction energies for dimer molecules.; The plugin is distributed under the 2-clause BSD license. Installation¶; Binary. snsmp2 is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). If using the Psi4conda installer, snsmp2 has already been installed alongside. If using the PSI4 conda package, the snsmp2 conda package can; be obtained through conda install snsmp2 -c psi4 or conda install; psi4-rt -c psi4. If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; snsmp2 can be obtained through conda install snsmp2 -c psi4.; Then, hint its location with PYTHONPATH. To remove a conda installation, conda remove snsmp2. Source. Download the plugin from the GitHub repository:; >>> git clone https://github.com/DEShawResearch/sns-mp2. Once dowloaded, the plugin can be installed as outlined in the documentation:; >>> cd {top-level-sns-mp2-directory}; >>> PSI4_PYTHON=$(head $(which psi4) -n 1 | sed -r 's/^.{2}//'); >>> $PSI4_PYTHON -m pip install . Sample Input¶; A sample input file, adapted from the documentation, is shown below:; 1; 2; 3; 4; 5; 6; 7; 8; 9# Sample SNS-MP2 calculation for two helium atoms. molecule dimer {; He 0 0 0; --; He 2 0 0; }. energy('sns-mp2'). Note that the two monomers are separated by double dashes, indicating that; they should be treated as separate molecules. (See; sec:analysis-of-intermolecular-interactions for more details on; setting up dimer molecules.) This input file can be run in the usual fashion:; >>> psi4 input.dat. table of contents. Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw; Installation; Sample Input. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.",MatchSource.WIKI,psi4manual/1.2.1/plugin_snsmp2-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugin_snsmp2-1.html
https://psicode.org/psi4manual/1.2.1/plugin_snsmp2-1.html:1574,Modifiability,adapt,adapted,1574,"ses neural networking to; improve the accuracy of MP2 (dfmp2) interaction energies for dimer molecules.; The plugin is distributed under the 2-clause BSD license. Installation¶; Binary. snsmp2 is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). If using the Psi4conda installer, snsmp2 has already been installed alongside. If using the PSI4 conda package, the snsmp2 conda package can; be obtained through conda install snsmp2 -c psi4 or conda install; psi4-rt -c psi4. If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; snsmp2 can be obtained through conda install snsmp2 -c psi4.; Then, hint its location with PYTHONPATH. To remove a conda installation, conda remove snsmp2. Source. Download the plugin from the GitHub repository:; >>> git clone https://github.com/DEShawResearch/sns-mp2. Once dowloaded, the plugin can be installed as outlined in the documentation:; >>> cd {top-level-sns-mp2-directory}; >>> PSI4_PYTHON=$(head $(which psi4) -n 1 | sed -r 's/^.{2}//'); >>> $PSI4_PYTHON -m pip install . Sample Input¶; A sample input file, adapted from the documentation, is shown below:; 1; 2; 3; 4; 5; 6; 7; 8; 9# Sample SNS-MP2 calculation for two helium atoms. molecule dimer {; He 0 0 0; --; He 2 0 0; }. energy('sns-mp2'). Note that the two monomers are separated by double dashes, indicating that; they should be treated as separate molecules. (See; sec:analysis-of-intermolecular-interactions for more details on; setting up dimer molecules.) This input file can be run in the usual fashion:; >>> psi4 input.dat. table of contents. Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw; Installation; Sample Input. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/plugin_snsmp2-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugin_snsmp2-1.html
https://psicode.org/psi4manual/1.2.1/plugin_snsmp2.html:610,Availability,avail,available,610,"﻿. Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw¶; Code author: D. E. Shaw Research; Section author: Shannon E. Houck. This plugin is an implementation of the SNS-MP2 algorithm developed by McGibbon; et. al. [McGibbon:2017:161725]. The SNS-MP2 method uses neural networking to; improve the accuracy of MP2 (dfmp2) interaction energies for dimer molecules.; The plugin is distributed under the 2-clause BSD license. Installation¶; Binary. snsmp2 is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). If using the Psi4conda installer, snsmp2 has already been installed alongside. If using the PSI4 conda package, the snsmp2 conda package can; be obtained through conda install snsmp2 -c psi4 or conda install; psi4-rt -c psi4. If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; snsmp2 can be obtained through conda install snsmp2 -c psi4.; Then, hint its location with PYTHONPATH. To remove a conda installation, conda remove snsmp2. Source. Download the plugin from the GitHub repository:; >>> git clone https://github.com/DEShawResearch/sns-mp2. Once dowloaded, the plugin can be installed as outlined in the documentation:; >>> cd {top-level-sns-mp2-directory}; >>> PSI4_PYTHON=$(head $(which psi4) -n 1 | sed -r 's/^.{2}//'); >>> $PSI4_PYTHON -m pip install . Sample Input¶; A sample input file, adapted from the documentation, is shown below:; 1; 2; 3; 4; 5; 6; 7; 8; 9# Sample SNS-MP2 calculation for two helium atoms. molecule dimer {; He 0 0 0; --; He 2 0 0; }. energy('sns-mp2'). Note that the two monomers are separated by double dashes, indicating that; they should be treated as separate molecules. (See; sec:analysis-of-intermolecular-interactions for more details on; setting up dimer molecules.) This input file ",MatchSource.WIKI,psi4manual/1.2.1/plugin_snsmp2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugin_snsmp2.html
https://psicode.org/psi4manual/1.2.1/plugin_snsmp2.html:723,Deployability,install,installer,723,"﻿. Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw¶; Code author: D. E. Shaw Research; Section author: Shannon E. Houck. This plugin is an implementation of the SNS-MP2 algorithm developed by McGibbon; et. al. [McGibbon:2017:161725]. The SNS-MP2 method uses neural networking to; improve the accuracy of MP2 (dfmp2) interaction energies for dimer molecules.; The plugin is distributed under the 2-clause BSD license. Installation¶; Binary. snsmp2 is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). If using the Psi4conda installer, snsmp2 has already been installed alongside. If using the PSI4 conda package, the snsmp2 conda package can; be obtained through conda install snsmp2 -c psi4 or conda install; psi4-rt -c psi4. If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; snsmp2 can be obtained through conda install snsmp2 -c psi4.; Then, hint its location with PYTHONPATH. To remove a conda installation, conda remove snsmp2. Source. Download the plugin from the GitHub repository:; >>> git clone https://github.com/DEShawResearch/sns-mp2. Once dowloaded, the plugin can be installed as outlined in the documentation:; >>> cd {top-level-sns-mp2-directory}; >>> PSI4_PYTHON=$(head $(which psi4) -n 1 | sed -r 's/^.{2}//'); >>> $PSI4_PYTHON -m pip install . Sample Input¶; A sample input file, adapted from the documentation, is shown below:; 1; 2; 3; 4; 5; 6; 7; 8; 9# Sample SNS-MP2 calculation for two helium atoms. molecule dimer {; He 0 0 0; --; He 2 0 0; }. energy('sns-mp2'). Note that the two monomers are separated by double dashes, indicating that; they should be treated as separate molecules. (See; sec:analysis-of-intermolecular-interactions for more details on; setting up dimer molecules.) This input file ",MatchSource.WIKI,psi4manual/1.2.1/plugin_snsmp2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugin_snsmp2.html
https://psicode.org/psi4manual/1.2.1/plugin_snsmp2.html:758,Deployability,install,installed,758,"﻿. Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw¶; Code author: D. E. Shaw Research; Section author: Shannon E. Houck. This plugin is an implementation of the SNS-MP2 algorithm developed by McGibbon; et. al. [McGibbon:2017:161725]. The SNS-MP2 method uses neural networking to; improve the accuracy of MP2 (dfmp2) interaction energies for dimer molecules.; The plugin is distributed under the 2-clause BSD license. Installation¶; Binary. snsmp2 is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). If using the Psi4conda installer, snsmp2 has already been installed alongside. If using the PSI4 conda package, the snsmp2 conda package can; be obtained through conda install snsmp2 -c psi4 or conda install; psi4-rt -c psi4. If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; snsmp2 can be obtained through conda install snsmp2 -c psi4.; Then, hint its location with PYTHONPATH. To remove a conda installation, conda remove snsmp2. Source. Download the plugin from the GitHub repository:; >>> git clone https://github.com/DEShawResearch/sns-mp2. Once dowloaded, the plugin can be installed as outlined in the documentation:; >>> cd {top-level-sns-mp2-directory}; >>> PSI4_PYTHON=$(head $(which psi4) -n 1 | sed -r 's/^.{2}//'); >>> $PSI4_PYTHON -m pip install . Sample Input¶; A sample input file, adapted from the documentation, is shown below:; 1; 2; 3; 4; 5; 6; 7; 8; 9# Sample SNS-MP2 calculation for two helium atoms. molecule dimer {; He 0 0 0; --; He 2 0 0; }. energy('sns-mp2'). Note that the two monomers are separated by double dashes, indicating that; they should be treated as separate molecules. (See; sec:analysis-of-intermolecular-interactions for more details on; setting up dimer molecules.) This input file ",MatchSource.WIKI,psi4manual/1.2.1/plugin_snsmp2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugin_snsmp2.html
https://psicode.org/psi4manual/1.2.1/plugin_snsmp2.html:868,Deployability,install,install,868,"﻿. Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw¶; Code author: D. E. Shaw Research; Section author: Shannon E. Houck. This plugin is an implementation of the SNS-MP2 algorithm developed by McGibbon; et. al. [McGibbon:2017:161725]. The SNS-MP2 method uses neural networking to; improve the accuracy of MP2 (dfmp2) interaction energies for dimer molecules.; The plugin is distributed under the 2-clause BSD license. Installation¶; Binary. snsmp2 is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). If using the Psi4conda installer, snsmp2 has already been installed alongside. If using the PSI4 conda package, the snsmp2 conda package can; be obtained through conda install snsmp2 -c psi4 or conda install; psi4-rt -c psi4. If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; snsmp2 can be obtained through conda install snsmp2 -c psi4.; Then, hint its location with PYTHONPATH. To remove a conda installation, conda remove snsmp2. Source. Download the plugin from the GitHub repository:; >>> git clone https://github.com/DEShawResearch/sns-mp2. Once dowloaded, the plugin can be installed as outlined in the documentation:; >>> cd {top-level-sns-mp2-directory}; >>> PSI4_PYTHON=$(head $(which psi4) -n 1 | sed -r 's/^.{2}//'); >>> $PSI4_PYTHON -m pip install . Sample Input¶; A sample input file, adapted from the documentation, is shown below:; 1; 2; 3; 4; 5; 6; 7; 8; 9# Sample SNS-MP2 calculation for two helium atoms. molecule dimer {; He 0 0 0; --; He 2 0 0; }. energy('sns-mp2'). Note that the two monomers are separated by double dashes, indicating that; they should be treated as separate molecules. (See; sec:analysis-of-intermolecular-interactions for more details on; setting up dimer molecules.) This input file ",MatchSource.WIKI,psi4manual/1.2.1/plugin_snsmp2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugin_snsmp2.html
https://psicode.org/psi4manual/1.2.1/plugin_snsmp2.html:900,Deployability,install,install,900,"﻿. Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw¶; Code author: D. E. Shaw Research; Section author: Shannon E. Houck. This plugin is an implementation of the SNS-MP2 algorithm developed by McGibbon; et. al. [McGibbon:2017:161725]. The SNS-MP2 method uses neural networking to; improve the accuracy of MP2 (dfmp2) interaction energies for dimer molecules.; The plugin is distributed under the 2-clause BSD license. Installation¶; Binary. snsmp2 is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). If using the Psi4conda installer, snsmp2 has already been installed alongside. If using the PSI4 conda package, the snsmp2 conda package can; be obtained through conda install snsmp2 -c psi4 or conda install; psi4-rt -c psi4. If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; snsmp2 can be obtained through conda install snsmp2 -c psi4.; Then, hint its location with PYTHONPATH. To remove a conda installation, conda remove snsmp2. Source. Download the plugin from the GitHub repository:; >>> git clone https://github.com/DEShawResearch/sns-mp2. Once dowloaded, the plugin can be installed as outlined in the documentation:; >>> cd {top-level-sns-mp2-directory}; >>> PSI4_PYTHON=$(head $(which psi4) -n 1 | sed -r 's/^.{2}//'); >>> $PSI4_PYTHON -m pip install . Sample Input¶; A sample input file, adapted from the documentation, is shown below:; 1; 2; 3; 4; 5; 6; 7; 8; 9# Sample SNS-MP2 calculation for two helium atoms. molecule dimer {; He 0 0 0; --; He 2 0 0; }. energy('sns-mp2'). Note that the two monomers are separated by double dashes, indicating that; they should be treated as separate molecules. (See; sec:analysis-of-intermolecular-interactions for more details on; setting up dimer molecules.) This input file ",MatchSource.WIKI,psi4manual/1.2.1/plugin_snsmp2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugin_snsmp2.html
https://psicode.org/psi4manual/1.2.1/plugin_snsmp2.html:1003,Deployability,install,installed,1003,"aled MP2 (SNS-MP2) by D. E. Shaw. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw¶; Code author: D. E. Shaw Research; Section author: Shannon E. Houck. This plugin is an implementation of the SNS-MP2 algorithm developed by McGibbon; et. al. [McGibbon:2017:161725]. The SNS-MP2 method uses neural networking to; improve the accuracy of MP2 (dfmp2) interaction energies for dimer molecules.; The plugin is distributed under the 2-clause BSD license. Installation¶; Binary. snsmp2 is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). If using the Psi4conda installer, snsmp2 has already been installed alongside. If using the PSI4 conda package, the snsmp2 conda package can; be obtained through conda install snsmp2 -c psi4 or conda install; psi4-rt -c psi4. If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; snsmp2 can be obtained through conda install snsmp2 -c psi4.; Then, hint its location with PYTHONPATH. To remove a conda installation, conda remove snsmp2. Source. Download the plugin from the GitHub repository:; >>> git clone https://github.com/DEShawResearch/sns-mp2. Once dowloaded, the plugin can be installed as outlined in the documentation:; >>> cd {top-level-sns-mp2-directory}; >>> PSI4_PYTHON=$(head $(which psi4) -n 1 | sed -r 's/^.{2}//'); >>> $PSI4_PYTHON -m pip install . Sample Input¶; A sample input file, adapted from the documentation, is shown below:; 1; 2; 3; 4; 5; 6; 7; 8; 9# Sample SNS-MP2 calculation for two helium atoms. molecule dimer {; He 0 0 0; --; He 2 0 0; }. energy('sns-mp2'). Note that the two monomers are separated by double dashes, indicating that; they should be treated as separate molecules. (See; sec:analysis-of-intermolecular-interactions for more details on; setting up dimer molecules.) This input file can be run in the ",MatchSource.WIKI,psi4manual/1.2.1/plugin_snsmp2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugin_snsmp2.html
https://psicode.org/psi4manual/1.2.1/plugin_snsmp2.html:1089,Deployability,install,install,1089,"aled MP2 (SNS-MP2) by D. E. Shaw. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw¶; Code author: D. E. Shaw Research; Section author: Shannon E. Houck. This plugin is an implementation of the SNS-MP2 algorithm developed by McGibbon; et. al. [McGibbon:2017:161725]. The SNS-MP2 method uses neural networking to; improve the accuracy of MP2 (dfmp2) interaction energies for dimer molecules.; The plugin is distributed under the 2-clause BSD license. Installation¶; Binary. snsmp2 is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). If using the Psi4conda installer, snsmp2 has already been installed alongside. If using the PSI4 conda package, the snsmp2 conda package can; be obtained through conda install snsmp2 -c psi4 or conda install; psi4-rt -c psi4. If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; snsmp2 can be obtained through conda install snsmp2 -c psi4.; Then, hint its location with PYTHONPATH. To remove a conda installation, conda remove snsmp2. Source. Download the plugin from the GitHub repository:; >>> git clone https://github.com/DEShawResearch/sns-mp2. Once dowloaded, the plugin can be installed as outlined in the documentation:; >>> cd {top-level-sns-mp2-directory}; >>> PSI4_PYTHON=$(head $(which psi4) -n 1 | sed -r 's/^.{2}//'); >>> $PSI4_PYTHON -m pip install . Sample Input¶; A sample input file, adapted from the documentation, is shown below:; 1; 2; 3; 4; 5; 6; 7; 8; 9# Sample SNS-MP2 calculation for two helium atoms. molecule dimer {; He 0 0 0; --; He 2 0 0; }. energy('sns-mp2'). Note that the two monomers are separated by double dashes, indicating that; they should be treated as separate molecules. (See; sec:analysis-of-intermolecular-interactions for more details on; setting up dimer molecules.) This input file can be run in the ",MatchSource.WIKI,psi4manual/1.2.1/plugin_snsmp2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugin_snsmp2.html
https://psicode.org/psi4manual/1.2.1/plugin_snsmp2.html:1173,Deployability,install,installation,1173,"ed MP2 (SNS-MP2) by D. E. Shaw¶; Code author: D. E. Shaw Research; Section author: Shannon E. Houck. This plugin is an implementation of the SNS-MP2 algorithm developed by McGibbon; et. al. [McGibbon:2017:161725]. The SNS-MP2 method uses neural networking to; improve the accuracy of MP2 (dfmp2) interaction energies for dimer molecules.; The plugin is distributed under the 2-clause BSD license. Installation¶; Binary. snsmp2 is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). If using the Psi4conda installer, snsmp2 has already been installed alongside. If using the PSI4 conda package, the snsmp2 conda package can; be obtained through conda install snsmp2 -c psi4 or conda install; psi4-rt -c psi4. If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; snsmp2 can be obtained through conda install snsmp2 -c psi4.; Then, hint its location with PYTHONPATH. To remove a conda installation, conda remove snsmp2. Source. Download the plugin from the GitHub repository:; >>> git clone https://github.com/DEShawResearch/sns-mp2. Once dowloaded, the plugin can be installed as outlined in the documentation:; >>> cd {top-level-sns-mp2-directory}; >>> PSI4_PYTHON=$(head $(which psi4) -n 1 | sed -r 's/^.{2}//'); >>> $PSI4_PYTHON -m pip install . Sample Input¶; A sample input file, adapted from the documentation, is shown below:; 1; 2; 3; 4; 5; 6; 7; 8; 9# Sample SNS-MP2 calculation for two helium atoms. molecule dimer {; He 0 0 0; --; He 2 0 0; }. energy('sns-mp2'). Note that the two monomers are separated by double dashes, indicating that; they should be treated as separate molecules. (See; sec:analysis-of-intermolecular-interactions for more details on; setting up dimer molecules.) This input file can be run in the usual fashion:; >>> psi4 input.dat. table of contents. Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw; Installation; Sample Input. «; hide menu. menu; sidebar; »",MatchSource.WIKI,psi4manual/1.2.1/plugin_snsmp2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugin_snsmp2.html
https://psicode.org/psi4manual/1.2.1/plugin_snsmp2.html:1356,Deployability,install,installed,1356,"thod uses neural networking to; improve the accuracy of MP2 (dfmp2) interaction energies for dimer molecules.; The plugin is distributed under the 2-clause BSD license. Installation¶; Binary. snsmp2 is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). If using the Psi4conda installer, snsmp2 has already been installed alongside. If using the PSI4 conda package, the snsmp2 conda package can; be obtained through conda install snsmp2 -c psi4 or conda install; psi4-rt -c psi4. If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; snsmp2 can be obtained through conda install snsmp2 -c psi4.; Then, hint its location with PYTHONPATH. To remove a conda installation, conda remove snsmp2. Source. Download the plugin from the GitHub repository:; >>> git clone https://github.com/DEShawResearch/sns-mp2. Once dowloaded, the plugin can be installed as outlined in the documentation:; >>> cd {top-level-sns-mp2-directory}; >>> PSI4_PYTHON=$(head $(which psi4) -n 1 | sed -r 's/^.{2}//'); >>> $PSI4_PYTHON -m pip install . Sample Input¶; A sample input file, adapted from the documentation, is shown below:; 1; 2; 3; 4; 5; 6; 7; 8; 9# Sample SNS-MP2 calculation for two helium atoms. molecule dimer {; He 0 0 0; --; He 2 0 0; }. energy('sns-mp2'). Note that the two monomers are separated by double dashes, indicating that; they should be treated as separate molecules. (See; sec:analysis-of-intermolecular-interactions for more details on; setting up dimer molecules.) This input file can be run in the usual fashion:; >>> psi4 input.dat. table of contents. Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw; Installation; Sample Input. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.",MatchSource.WIKI,psi4manual/1.2.1/plugin_snsmp2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugin_snsmp2.html
https://psicode.org/psi4manual/1.2.1/plugin_snsmp2.html:1528,Deployability,install,install,1528,"ses neural networking to; improve the accuracy of MP2 (dfmp2) interaction energies for dimer molecules.; The plugin is distributed under the 2-clause BSD license. Installation¶; Binary. snsmp2 is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). If using the Psi4conda installer, snsmp2 has already been installed alongside. If using the PSI4 conda package, the snsmp2 conda package can; be obtained through conda install snsmp2 -c psi4 or conda install; psi4-rt -c psi4. If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; snsmp2 can be obtained through conda install snsmp2 -c psi4.; Then, hint its location with PYTHONPATH. To remove a conda installation, conda remove snsmp2. Source. Download the plugin from the GitHub repository:; >>> git clone https://github.com/DEShawResearch/sns-mp2. Once dowloaded, the plugin can be installed as outlined in the documentation:; >>> cd {top-level-sns-mp2-directory}; >>> PSI4_PYTHON=$(head $(which psi4) -n 1 | sed -r 's/^.{2}//'); >>> $PSI4_PYTHON -m pip install . Sample Input¶; A sample input file, adapted from the documentation, is shown below:; 1; 2; 3; 4; 5; 6; 7; 8; 9# Sample SNS-MP2 calculation for two helium atoms. molecule dimer {; He 0 0 0; --; He 2 0 0; }. energy('sns-mp2'). Note that the two monomers are separated by double dashes, indicating that; they should be treated as separate molecules. (See; sec:analysis-of-intermolecular-interactions for more details on; setting up dimer molecules.) This input file can be run in the usual fashion:; >>> psi4 input.dat. table of contents. Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw; Installation; Sample Input. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/plugin_snsmp2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugin_snsmp2.html
https://psicode.org/psi4manual/1.2.1/plugin_snsmp2.html:2338,Deployability,update,updated,2338,"ses neural networking to; improve the accuracy of MP2 (dfmp2) interaction energies for dimer molecules.; The plugin is distributed under the 2-clause BSD license. Installation¶; Binary. snsmp2 is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). If using the Psi4conda installer, snsmp2 has already been installed alongside. If using the PSI4 conda package, the snsmp2 conda package can; be obtained through conda install snsmp2 -c psi4 or conda install; psi4-rt -c psi4. If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; snsmp2 can be obtained through conda install snsmp2 -c psi4.; Then, hint its location with PYTHONPATH. To remove a conda installation, conda remove snsmp2. Source. Download the plugin from the GitHub repository:; >>> git clone https://github.com/DEShawResearch/sns-mp2. Once dowloaded, the plugin can be installed as outlined in the documentation:; >>> cd {top-level-sns-mp2-directory}; >>> PSI4_PYTHON=$(head $(which psi4) -n 1 | sed -r 's/^.{2}//'); >>> $PSI4_PYTHON -m pip install . Sample Input¶; A sample input file, adapted from the documentation, is shown below:; 1; 2; 3; 4; 5; 6; 7; 8; 9# Sample SNS-MP2 calculation for two helium atoms. molecule dimer {; He 0 0 0; --; He 2 0 0; }. energy('sns-mp2'). Note that the two monomers are separated by double dashes, indicating that; they should be treated as separate molecules. (See; sec:analysis-of-intermolecular-interactions for more details on; setting up dimer molecules.) This input file can be run in the usual fashion:; >>> psi4 input.dat. table of contents. Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw; Installation; Sample Input. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/plugin_snsmp2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugin_snsmp2.html
https://psicode.org/psi4manual/1.2.1/plugin_snsmp2.html:1574,Energy Efficiency,adapt,adapted,1574,"ses neural networking to; improve the accuracy of MP2 (dfmp2) interaction energies for dimer molecules.; The plugin is distributed under the 2-clause BSD license. Installation¶; Binary. snsmp2 is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). If using the Psi4conda installer, snsmp2 has already been installed alongside. If using the PSI4 conda package, the snsmp2 conda package can; be obtained through conda install snsmp2 -c psi4 or conda install; psi4-rt -c psi4. If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; snsmp2 can be obtained through conda install snsmp2 -c psi4.; Then, hint its location with PYTHONPATH. To remove a conda installation, conda remove snsmp2. Source. Download the plugin from the GitHub repository:; >>> git clone https://github.com/DEShawResearch/sns-mp2. Once dowloaded, the plugin can be installed as outlined in the documentation:; >>> cd {top-level-sns-mp2-directory}; >>> PSI4_PYTHON=$(head $(which psi4) -n 1 | sed -r 's/^.{2}//'); >>> $PSI4_PYTHON -m pip install . Sample Input¶; A sample input file, adapted from the documentation, is shown below:; 1; 2; 3; 4; 5; 6; 7; 8; 9# Sample SNS-MP2 calculation for two helium atoms. molecule dimer {; He 0 0 0; --; He 2 0 0; }. energy('sns-mp2'). Note that the two monomers are separated by double dashes, indicating that; they should be treated as separate molecules. (See; sec:analysis-of-intermolecular-interactions for more details on; setting up dimer molecules.) This input file can be run in the usual fashion:; >>> psi4 input.dat. table of contents. Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw; Installation; Sample Input. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/plugin_snsmp2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugin_snsmp2.html
https://psicode.org/psi4manual/1.2.1/plugin_snsmp2.html:1744,Energy Efficiency,energy,energy,1744,"ses neural networking to; improve the accuracy of MP2 (dfmp2) interaction energies for dimer molecules.; The plugin is distributed under the 2-clause BSD license. Installation¶; Binary. snsmp2 is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). If using the Psi4conda installer, snsmp2 has already been installed alongside. If using the PSI4 conda package, the snsmp2 conda package can; be obtained through conda install snsmp2 -c psi4 or conda install; psi4-rt -c psi4. If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; snsmp2 can be obtained through conda install snsmp2 -c psi4.; Then, hint its location with PYTHONPATH. To remove a conda installation, conda remove snsmp2. Source. Download the plugin from the GitHub repository:; >>> git clone https://github.com/DEShawResearch/sns-mp2. Once dowloaded, the plugin can be installed as outlined in the documentation:; >>> cd {top-level-sns-mp2-directory}; >>> PSI4_PYTHON=$(head $(which psi4) -n 1 | sed -r 's/^.{2}//'); >>> $PSI4_PYTHON -m pip install . Sample Input¶; A sample input file, adapted from the documentation, is shown below:; 1; 2; 3; 4; 5; 6; 7; 8; 9# Sample SNS-MP2 calculation for two helium atoms. molecule dimer {; He 0 0 0; --; He 2 0 0; }. energy('sns-mp2'). Note that the two monomers are separated by double dashes, indicating that; they should be treated as separate molecules. (See; sec:analysis-of-intermolecular-interactions for more details on; setting up dimer molecules.) This input file can be run in the usual fashion:; >>> psi4 input.dat. table of contents. Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw; Installation; Sample Input. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/plugin_snsmp2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugin_snsmp2.html
https://psicode.org/psi4manual/1.2.1/plugin_snsmp2.html:286,Modifiability,plugin,plugin,286,"﻿. Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw¶; Code author: D. E. Shaw Research; Section author: Shannon E. Houck. This plugin is an implementation of the SNS-MP2 algorithm developed by McGibbon; et. al. [McGibbon:2017:161725]. The SNS-MP2 method uses neural networking to; improve the accuracy of MP2 (dfmp2) interaction energies for dimer molecules.; The plugin is distributed under the 2-clause BSD license. Installation¶; Binary. snsmp2 is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). If using the Psi4conda installer, snsmp2 has already been installed alongside. If using the PSI4 conda package, the snsmp2 conda package can; be obtained through conda install snsmp2 -c psi4 or conda install; psi4-rt -c psi4. If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; snsmp2 can be obtained through conda install snsmp2 -c psi4.; Then, hint its location with PYTHONPATH. To remove a conda installation, conda remove snsmp2. Source. Download the plugin from the GitHub repository:; >>> git clone https://github.com/DEShawResearch/sns-mp2. Once dowloaded, the plugin can be installed as outlined in the documentation:; >>> cd {top-level-sns-mp2-directory}; >>> PSI4_PYTHON=$(head $(which psi4) -n 1 | sed -r 's/^.{2}//'); >>> $PSI4_PYTHON -m pip install . Sample Input¶; A sample input file, adapted from the documentation, is shown below:; 1; 2; 3; 4; 5; 6; 7; 8; 9# Sample SNS-MP2 calculation for two helium atoms. molecule dimer {; He 0 0 0; --; He 2 0 0; }. energy('sns-mp2'). Note that the two monomers are separated by double dashes, indicating that; they should be treated as separate molecules. (See; sec:analysis-of-intermolecular-interactions for more details on; setting up dimer molecules.) This input file ",MatchSource.WIKI,psi4manual/1.2.1/plugin_snsmp2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugin_snsmp2.html
https://psicode.org/psi4manual/1.2.1/plugin_snsmp2.html:523,Modifiability,plugin,plugin,523,"﻿. Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw¶; Code author: D. E. Shaw Research; Section author: Shannon E. Houck. This plugin is an implementation of the SNS-MP2 algorithm developed by McGibbon; et. al. [McGibbon:2017:161725]. The SNS-MP2 method uses neural networking to; improve the accuracy of MP2 (dfmp2) interaction energies for dimer molecules.; The plugin is distributed under the 2-clause BSD license. Installation¶; Binary. snsmp2 is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). If using the Psi4conda installer, snsmp2 has already been installed alongside. If using the PSI4 conda package, the snsmp2 conda package can; be obtained through conda install snsmp2 -c psi4 or conda install; psi4-rt -c psi4. If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; snsmp2 can be obtained through conda install snsmp2 -c psi4.; Then, hint its location with PYTHONPATH. To remove a conda installation, conda remove snsmp2. Source. Download the plugin from the GitHub repository:; >>> git clone https://github.com/DEShawResearch/sns-mp2. Once dowloaded, the plugin can be installed as outlined in the documentation:; >>> cd {top-level-sns-mp2-directory}; >>> PSI4_PYTHON=$(head $(which psi4) -n 1 | sed -r 's/^.{2}//'); >>> $PSI4_PYTHON -m pip install . Sample Input¶; A sample input file, adapted from the documentation, is shown below:; 1; 2; 3; 4; 5; 6; 7; 8; 9# Sample SNS-MP2 calculation for two helium atoms. molecule dimer {; He 0 0 0; --; He 2 0 0; }. energy('sns-mp2'). Note that the two monomers are separated by double dashes, indicating that; they should be treated as separate molecules. (See; sec:analysis-of-intermolecular-interactions for more details on; setting up dimer molecules.) This input file ",MatchSource.WIKI,psi4manual/1.2.1/plugin_snsmp2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugin_snsmp2.html
https://psicode.org/psi4manual/1.2.1/plugin_snsmp2.html:1229,Modifiability,plugin,plugin,1229," author: Shannon E. Houck. This plugin is an implementation of the SNS-MP2 algorithm developed by McGibbon; et. al. [McGibbon:2017:161725]. The SNS-MP2 method uses neural networking to; improve the accuracy of MP2 (dfmp2) interaction energies for dimer molecules.; The plugin is distributed under the 2-clause BSD license. Installation¶; Binary. snsmp2 is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). If using the Psi4conda installer, snsmp2 has already been installed alongside. If using the PSI4 conda package, the snsmp2 conda package can; be obtained through conda install snsmp2 -c psi4 or conda install; psi4-rt -c psi4. If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; snsmp2 can be obtained through conda install snsmp2 -c psi4.; Then, hint its location with PYTHONPATH. To remove a conda installation, conda remove snsmp2. Source. Download the plugin from the GitHub repository:; >>> git clone https://github.com/DEShawResearch/sns-mp2. Once dowloaded, the plugin can be installed as outlined in the documentation:; >>> cd {top-level-sns-mp2-directory}; >>> PSI4_PYTHON=$(head $(which psi4) -n 1 | sed -r 's/^.{2}//'); >>> $PSI4_PYTHON -m pip install . Sample Input¶; A sample input file, adapted from the documentation, is shown below:; 1; 2; 3; 4; 5; 6; 7; 8; 9# Sample SNS-MP2 calculation for two helium atoms. molecule dimer {; He 0 0 0; --; He 2 0 0; }. energy('sns-mp2'). Note that the two monomers are separated by double dashes, indicating that; they should be treated as separate molecules. (See; sec:analysis-of-intermolecular-interactions for more details on; setting up dimer molecules.) This input file can be run in the usual fashion:; >>> psi4 input.dat. table of contents. Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw; Installation; Sample Input. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. ",MatchSource.WIKI,psi4manual/1.2.1/plugin_snsmp2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugin_snsmp2.html
https://psicode.org/psi4manual/1.2.1/plugin_snsmp2.html:1342,Modifiability,plugin,plugin,1342,"thod uses neural networking to; improve the accuracy of MP2 (dfmp2) interaction energies for dimer molecules.; The plugin is distributed under the 2-clause BSD license. Installation¶; Binary. snsmp2 is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). If using the Psi4conda installer, snsmp2 has already been installed alongside. If using the PSI4 conda package, the snsmp2 conda package can; be obtained through conda install snsmp2 -c psi4 or conda install; psi4-rt -c psi4. If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; snsmp2 can be obtained through conda install snsmp2 -c psi4.; Then, hint its location with PYTHONPATH. To remove a conda installation, conda remove snsmp2. Source. Download the plugin from the GitHub repository:; >>> git clone https://github.com/DEShawResearch/sns-mp2. Once dowloaded, the plugin can be installed as outlined in the documentation:; >>> cd {top-level-sns-mp2-directory}; >>> PSI4_PYTHON=$(head $(which psi4) -n 1 | sed -r 's/^.{2}//'); >>> $PSI4_PYTHON -m pip install . Sample Input¶; A sample input file, adapted from the documentation, is shown below:; 1; 2; 3; 4; 5; 6; 7; 8; 9# Sample SNS-MP2 calculation for two helium atoms. molecule dimer {; He 0 0 0; --; He 2 0 0; }. energy('sns-mp2'). Note that the two monomers are separated by double dashes, indicating that; they should be treated as separate molecules. (See; sec:analysis-of-intermolecular-interactions for more details on; setting up dimer molecules.) This input file can be run in the usual fashion:; >>> psi4 input.dat. table of contents. Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw; Installation; Sample Input. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.",MatchSource.WIKI,psi4manual/1.2.1/plugin_snsmp2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugin_snsmp2.html
https://psicode.org/psi4manual/1.2.1/plugin_snsmp2.html:1574,Modifiability,adapt,adapted,1574,"ses neural networking to; improve the accuracy of MP2 (dfmp2) interaction energies for dimer molecules.; The plugin is distributed under the 2-clause BSD license. Installation¶; Binary. snsmp2 is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). If using the Psi4conda installer, snsmp2 has already been installed alongside. If using the PSI4 conda package, the snsmp2 conda package can; be obtained through conda install snsmp2 -c psi4 or conda install; psi4-rt -c psi4. If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; snsmp2 can be obtained through conda install snsmp2 -c psi4.; Then, hint its location with PYTHONPATH. To remove a conda installation, conda remove snsmp2. Source. Download the plugin from the GitHub repository:; >>> git clone https://github.com/DEShawResearch/sns-mp2. Once dowloaded, the plugin can be installed as outlined in the documentation:; >>> cd {top-level-sns-mp2-directory}; >>> PSI4_PYTHON=$(head $(which psi4) -n 1 | sed -r 's/^.{2}//'); >>> $PSI4_PYTHON -m pip install . Sample Input¶; A sample input file, adapted from the documentation, is shown below:; 1; 2; 3; 4; 5; 6; 7; 8; 9# Sample SNS-MP2 calculation for two helium atoms. molecule dimer {; He 0 0 0; --; He 2 0 0; }. energy('sns-mp2'). Note that the two monomers are separated by double dashes, indicating that; they should be treated as separate molecules. (See; sec:analysis-of-intermolecular-interactions for more details on; setting up dimer molecules.) This input file can be run in the usual fashion:; >>> psi4 input.dat. table of contents. Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw; Installation; Sample Input. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/plugin_snsmp2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugin_snsmp2.html
https://psicode.org/psi4manual/1.2.1/plugin_v2rdm_casscf-1.html:342,Availability,avail,available,342,"﻿. Plugin v2rdm_casscf by A. E. DePrince. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. Plugin v2rdm_casscf by A. E. DePrince¶; Code author: A. E. DePrince; Section author: Lori A. Burns. A variational 2-RDM-driven CASSCF plugin to PSI4. Installation¶; Binary. v2rdm_casscf is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). If using the Psi4conda installer, v2rdm_casscf has already been installed alongside. If using the PSI4 conda package, the v2rdm_casscf conda package can; be obtained through conda install v2rdm_casscf -c psi4 or conda install; psi4-rt -c psi4. If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; v2rdm_casscf can be obtained through conda install v2rdm_casscf -c psi4.; Then, hint its location with PYTHONPATH. To remove a conda installation, conda remove v2rdm_casscf. Source. If using PSI4 built from source and you want v2rdm_casscf built from; from source also,; build it, then hint its location with PYTHONPATH. table of contents. Plugin v2rdm_casscf by A. E. DePrince; Installation. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/plugin_v2rdm_casscf-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugin_v2rdm_casscf-1.html
https://psicode.org/psi4manual/1.2.1/plugin_v2rdm_casscf-1.html:455,Deployability,install,installer,455,"﻿. Plugin v2rdm_casscf by A. E. DePrince. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. Plugin v2rdm_casscf by A. E. DePrince¶; Code author: A. E. DePrince; Section author: Lori A. Burns. A variational 2-RDM-driven CASSCF plugin to PSI4. Installation¶; Binary. v2rdm_casscf is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). If using the Psi4conda installer, v2rdm_casscf has already been installed alongside. If using the PSI4 conda package, the v2rdm_casscf conda package can; be obtained through conda install v2rdm_casscf -c psi4 or conda install; psi4-rt -c psi4. If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; v2rdm_casscf can be obtained through conda install v2rdm_casscf -c psi4.; Then, hint its location with PYTHONPATH. To remove a conda installation, conda remove v2rdm_casscf. Source. If using PSI4 built from source and you want v2rdm_casscf built from; from source also,; build it, then hint its location with PYTHONPATH. table of contents. Plugin v2rdm_casscf by A. E. DePrince; Installation. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/plugin_v2rdm_casscf-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugin_v2rdm_casscf-1.html
https://psicode.org/psi4manual/1.2.1/plugin_v2rdm_casscf-1.html:496,Deployability,install,installed,496,"﻿. Plugin v2rdm_casscf by A. E. DePrince. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. Plugin v2rdm_casscf by A. E. DePrince¶; Code author: A. E. DePrince; Section author: Lori A. Burns. A variational 2-RDM-driven CASSCF plugin to PSI4. Installation¶; Binary. v2rdm_casscf is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). If using the Psi4conda installer, v2rdm_casscf has already been installed alongside. If using the PSI4 conda package, the v2rdm_casscf conda package can; be obtained through conda install v2rdm_casscf -c psi4 or conda install; psi4-rt -c psi4. If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; v2rdm_casscf can be obtained through conda install v2rdm_casscf -c psi4.; Then, hint its location with PYTHONPATH. To remove a conda installation, conda remove v2rdm_casscf. Source. If using PSI4 built from source and you want v2rdm_casscf built from; from source also,; build it, then hint its location with PYTHONPATH. table of contents. Plugin v2rdm_casscf by A. E. DePrince; Installation. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/plugin_v2rdm_casscf-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugin_v2rdm_casscf-1.html
https://psicode.org/psi4manual/1.2.1/plugin_v2rdm_casscf-1.html:612,Deployability,install,install,612,"﻿. Plugin v2rdm_casscf by A. E. DePrince. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. Plugin v2rdm_casscf by A. E. DePrince¶; Code author: A. E. DePrince; Section author: Lori A. Burns. A variational 2-RDM-driven CASSCF plugin to PSI4. Installation¶; Binary. v2rdm_casscf is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). If using the Psi4conda installer, v2rdm_casscf has already been installed alongside. If using the PSI4 conda package, the v2rdm_casscf conda package can; be obtained through conda install v2rdm_casscf -c psi4 or conda install; psi4-rt -c psi4. If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; v2rdm_casscf can be obtained through conda install v2rdm_casscf -c psi4.; Then, hint its location with PYTHONPATH. To remove a conda installation, conda remove v2rdm_casscf. Source. If using PSI4 built from source and you want v2rdm_casscf built from; from source also,; build it, then hint its location with PYTHONPATH. table of contents. Plugin v2rdm_casscf by A. E. DePrince; Installation. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/plugin_v2rdm_casscf-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugin_v2rdm_casscf-1.html
https://psicode.org/psi4manual/1.2.1/plugin_v2rdm_casscf-1.html:650,Deployability,install,install,650,"﻿. Plugin v2rdm_casscf by A. E. DePrince. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. Plugin v2rdm_casscf by A. E. DePrince¶; Code author: A. E. DePrince; Section author: Lori A. Burns. A variational 2-RDM-driven CASSCF plugin to PSI4. Installation¶; Binary. v2rdm_casscf is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). If using the Psi4conda installer, v2rdm_casscf has already been installed alongside. If using the PSI4 conda package, the v2rdm_casscf conda package can; be obtained through conda install v2rdm_casscf -c psi4 or conda install; psi4-rt -c psi4. If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; v2rdm_casscf can be obtained through conda install v2rdm_casscf -c psi4.; Then, hint its location with PYTHONPATH. To remove a conda installation, conda remove v2rdm_casscf. Source. If using PSI4 built from source and you want v2rdm_casscf built from; from source also,; build it, then hint its location with PYTHONPATH. table of contents. Plugin v2rdm_casscf by A. E. DePrince; Installation. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/plugin_v2rdm_casscf-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugin_v2rdm_casscf-1.html
https://psicode.org/psi4manual/1.2.1/plugin_v2rdm_casscf-1.html:753,Deployability,install,installed,753,"﻿. Plugin v2rdm_casscf by A. E. DePrince. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. Plugin v2rdm_casscf by A. E. DePrince¶; Code author: A. E. DePrince; Section author: Lori A. Burns. A variational 2-RDM-driven CASSCF plugin to PSI4. Installation¶; Binary. v2rdm_casscf is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). If using the Psi4conda installer, v2rdm_casscf has already been installed alongside. If using the PSI4 conda package, the v2rdm_casscf conda package can; be obtained through conda install v2rdm_casscf -c psi4 or conda install; psi4-rt -c psi4. If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; v2rdm_casscf can be obtained through conda install v2rdm_casscf -c psi4.; Then, hint its location with PYTHONPATH. To remove a conda installation, conda remove v2rdm_casscf. Source. If using PSI4 built from source and you want v2rdm_casscf built from; from source also,; build it, then hint its location with PYTHONPATH. table of contents. Plugin v2rdm_casscf by A. E. DePrince; Installation. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/plugin_v2rdm_casscf-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugin_v2rdm_casscf-1.html
https://psicode.org/psi4manual/1.2.1/plugin_v2rdm_casscf-1.html:845,Deployability,install,install,845,"﻿. Plugin v2rdm_casscf by A. E. DePrince. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. Plugin v2rdm_casscf by A. E. DePrince¶; Code author: A. E. DePrince; Section author: Lori A. Burns. A variational 2-RDM-driven CASSCF plugin to PSI4. Installation¶; Binary. v2rdm_casscf is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). If using the Psi4conda installer, v2rdm_casscf has already been installed alongside. If using the PSI4 conda package, the v2rdm_casscf conda package can; be obtained through conda install v2rdm_casscf -c psi4 or conda install; psi4-rt -c psi4. If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; v2rdm_casscf can be obtained through conda install v2rdm_casscf -c psi4.; Then, hint its location with PYTHONPATH. To remove a conda installation, conda remove v2rdm_casscf. Source. If using PSI4 built from source and you want v2rdm_casscf built from; from source also,; build it, then hint its location with PYTHONPATH. table of contents. Plugin v2rdm_casscf by A. E. DePrince; Installation. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/plugin_v2rdm_casscf-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugin_v2rdm_casscf-1.html
https://psicode.org/psi4manual/1.2.1/plugin_v2rdm_casscf-1.html:935,Deployability,install,installation,935,"﻿. Plugin v2rdm_casscf by A. E. DePrince. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. Plugin v2rdm_casscf by A. E. DePrince¶; Code author: A. E. DePrince; Section author: Lori A. Burns. A variational 2-RDM-driven CASSCF plugin to PSI4. Installation¶; Binary. v2rdm_casscf is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). If using the Psi4conda installer, v2rdm_casscf has already been installed alongside. If using the PSI4 conda package, the v2rdm_casscf conda package can; be obtained through conda install v2rdm_casscf -c psi4 or conda install; psi4-rt -c psi4. If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; v2rdm_casscf can be obtained through conda install v2rdm_casscf -c psi4.; Then, hint its location with PYTHONPATH. To remove a conda installation, conda remove v2rdm_casscf. Source. If using PSI4 built from source and you want v2rdm_casscf built from; from source also,; build it, then hint its location with PYTHONPATH. table of contents. Plugin v2rdm_casscf by A. E. DePrince; Installation. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/plugin_v2rdm_casscf-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugin_v2rdm_casscf-1.html
https://psicode.org/psi4manual/1.2.1/plugin_v2rdm_casscf-1.html:1382,Deployability,update,updated,1382,"﻿. Plugin v2rdm_casscf by A. E. DePrince. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. Plugin v2rdm_casscf by A. E. DePrince¶; Code author: A. E. DePrince; Section author: Lori A. Burns. A variational 2-RDM-driven CASSCF plugin to PSI4. Installation¶; Binary. v2rdm_casscf is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). If using the Psi4conda installer, v2rdm_casscf has already been installed alongside. If using the PSI4 conda package, the v2rdm_casscf conda package can; be obtained through conda install v2rdm_casscf -c psi4 or conda install; psi4-rt -c psi4. If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; v2rdm_casscf can be obtained through conda install v2rdm_casscf -c psi4.; Then, hint its location with PYTHONPATH. To remove a conda installation, conda remove v2rdm_casscf. Source. If using PSI4 built from source and you want v2rdm_casscf built from; from source also,; build it, then hint its location with PYTHONPATH. table of contents. Plugin v2rdm_casscf by A. E. DePrince; Installation. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/plugin_v2rdm_casscf-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugin_v2rdm_casscf-1.html
https://psicode.org/psi4manual/1.2.1/plugin_v2rdm_casscf-1.html:287,Modifiability,plugin,plugin,287,"﻿. Plugin v2rdm_casscf by A. E. DePrince. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. Plugin v2rdm_casscf by A. E. DePrince¶; Code author: A. E. DePrince; Section author: Lori A. Burns. A variational 2-RDM-driven CASSCF plugin to PSI4. Installation¶; Binary. v2rdm_casscf is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). If using the Psi4conda installer, v2rdm_casscf has already been installed alongside. If using the PSI4 conda package, the v2rdm_casscf conda package can; be obtained through conda install v2rdm_casscf -c psi4 or conda install; psi4-rt -c psi4. If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; v2rdm_casscf can be obtained through conda install v2rdm_casscf -c psi4.; Then, hint its location with PYTHONPATH. To remove a conda installation, conda remove v2rdm_casscf. Source. If using PSI4 built from source and you want v2rdm_casscf built from; from source also,; build it, then hint its location with PYTHONPATH. table of contents. Plugin v2rdm_casscf by A. E. DePrince; Installation. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/plugin_v2rdm_casscf-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugin_v2rdm_casscf-1.html
https://psicode.org/psi4manual/1.2.1/plugin_v2rdm_casscf.html:342,Availability,avail,available,342,"﻿. Plugin v2rdm_casscf by A. E. DePrince. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. Plugin v2rdm_casscf by A. E. DePrince¶; Code author: A. E. DePrince; Section author: Lori A. Burns. A variational 2-RDM-driven CASSCF plugin to PSI4. Installation¶; Binary. v2rdm_casscf is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). If using the Psi4conda installer, v2rdm_casscf has already been installed alongside. If using the PSI4 conda package, the v2rdm_casscf conda package can; be obtained through conda install v2rdm_casscf -c psi4 or conda install; psi4-rt -c psi4. If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; v2rdm_casscf can be obtained through conda install v2rdm_casscf -c psi4.; Then, hint its location with PYTHONPATH. To remove a conda installation, conda remove v2rdm_casscf. Source. If using PSI4 built from source and you want v2rdm_casscf built from; from source also,; build it, then hint its location with PYTHONPATH. table of contents. Plugin v2rdm_casscf by A. E. DePrince; Installation. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/plugin_v2rdm_casscf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugin_v2rdm_casscf.html
https://psicode.org/psi4manual/1.2.1/plugin_v2rdm_casscf.html:455,Deployability,install,installer,455,"﻿. Plugin v2rdm_casscf by A. E. DePrince. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. Plugin v2rdm_casscf by A. E. DePrince¶; Code author: A. E. DePrince; Section author: Lori A. Burns. A variational 2-RDM-driven CASSCF plugin to PSI4. Installation¶; Binary. v2rdm_casscf is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). If using the Psi4conda installer, v2rdm_casscf has already been installed alongside. If using the PSI4 conda package, the v2rdm_casscf conda package can; be obtained through conda install v2rdm_casscf -c psi4 or conda install; psi4-rt -c psi4. If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; v2rdm_casscf can be obtained through conda install v2rdm_casscf -c psi4.; Then, hint its location with PYTHONPATH. To remove a conda installation, conda remove v2rdm_casscf. Source. If using PSI4 built from source and you want v2rdm_casscf built from; from source also,; build it, then hint its location with PYTHONPATH. table of contents. Plugin v2rdm_casscf by A. E. DePrince; Installation. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/plugin_v2rdm_casscf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugin_v2rdm_casscf.html
https://psicode.org/psi4manual/1.2.1/plugin_v2rdm_casscf.html:496,Deployability,install,installed,496,"﻿. Plugin v2rdm_casscf by A. E. DePrince. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. Plugin v2rdm_casscf by A. E. DePrince¶; Code author: A. E. DePrince; Section author: Lori A. Burns. A variational 2-RDM-driven CASSCF plugin to PSI4. Installation¶; Binary. v2rdm_casscf is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). If using the Psi4conda installer, v2rdm_casscf has already been installed alongside. If using the PSI4 conda package, the v2rdm_casscf conda package can; be obtained through conda install v2rdm_casscf -c psi4 or conda install; psi4-rt -c psi4. If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; v2rdm_casscf can be obtained through conda install v2rdm_casscf -c psi4.; Then, hint its location with PYTHONPATH. To remove a conda installation, conda remove v2rdm_casscf. Source. If using PSI4 built from source and you want v2rdm_casscf built from; from source also,; build it, then hint its location with PYTHONPATH. table of contents. Plugin v2rdm_casscf by A. E. DePrince; Installation. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/plugin_v2rdm_casscf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugin_v2rdm_casscf.html
https://psicode.org/psi4manual/1.2.1/plugin_v2rdm_casscf.html:612,Deployability,install,install,612,"﻿. Plugin v2rdm_casscf by A. E. DePrince. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. Plugin v2rdm_casscf by A. E. DePrince¶; Code author: A. E. DePrince; Section author: Lori A. Burns. A variational 2-RDM-driven CASSCF plugin to PSI4. Installation¶; Binary. v2rdm_casscf is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). If using the Psi4conda installer, v2rdm_casscf has already been installed alongside. If using the PSI4 conda package, the v2rdm_casscf conda package can; be obtained through conda install v2rdm_casscf -c psi4 or conda install; psi4-rt -c psi4. If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; v2rdm_casscf can be obtained through conda install v2rdm_casscf -c psi4.; Then, hint its location with PYTHONPATH. To remove a conda installation, conda remove v2rdm_casscf. Source. If using PSI4 built from source and you want v2rdm_casscf built from; from source also,; build it, then hint its location with PYTHONPATH. table of contents. Plugin v2rdm_casscf by A. E. DePrince; Installation. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/plugin_v2rdm_casscf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugin_v2rdm_casscf.html
https://psicode.org/psi4manual/1.2.1/plugin_v2rdm_casscf.html:650,Deployability,install,install,650,"﻿. Plugin v2rdm_casscf by A. E. DePrince. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. Plugin v2rdm_casscf by A. E. DePrince¶; Code author: A. E. DePrince; Section author: Lori A. Burns. A variational 2-RDM-driven CASSCF plugin to PSI4. Installation¶; Binary. v2rdm_casscf is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). If using the Psi4conda installer, v2rdm_casscf has already been installed alongside. If using the PSI4 conda package, the v2rdm_casscf conda package can; be obtained through conda install v2rdm_casscf -c psi4 or conda install; psi4-rt -c psi4. If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; v2rdm_casscf can be obtained through conda install v2rdm_casscf -c psi4.; Then, hint its location with PYTHONPATH. To remove a conda installation, conda remove v2rdm_casscf. Source. If using PSI4 built from source and you want v2rdm_casscf built from; from source also,; build it, then hint its location with PYTHONPATH. table of contents. Plugin v2rdm_casscf by A. E. DePrince; Installation. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/plugin_v2rdm_casscf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugin_v2rdm_casscf.html
https://psicode.org/psi4manual/1.2.1/plugin_v2rdm_casscf.html:753,Deployability,install,installed,753,"﻿. Plugin v2rdm_casscf by A. E. DePrince. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. Plugin v2rdm_casscf by A. E. DePrince¶; Code author: A. E. DePrince; Section author: Lori A. Burns. A variational 2-RDM-driven CASSCF plugin to PSI4. Installation¶; Binary. v2rdm_casscf is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). If using the Psi4conda installer, v2rdm_casscf has already been installed alongside. If using the PSI4 conda package, the v2rdm_casscf conda package can; be obtained through conda install v2rdm_casscf -c psi4 or conda install; psi4-rt -c psi4. If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; v2rdm_casscf can be obtained through conda install v2rdm_casscf -c psi4.; Then, hint its location with PYTHONPATH. To remove a conda installation, conda remove v2rdm_casscf. Source. If using PSI4 built from source and you want v2rdm_casscf built from; from source also,; build it, then hint its location with PYTHONPATH. table of contents. Plugin v2rdm_casscf by A. E. DePrince; Installation. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/plugin_v2rdm_casscf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugin_v2rdm_casscf.html
https://psicode.org/psi4manual/1.2.1/plugin_v2rdm_casscf.html:845,Deployability,install,install,845,"﻿. Plugin v2rdm_casscf by A. E. DePrince. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. Plugin v2rdm_casscf by A. E. DePrince¶; Code author: A. E. DePrince; Section author: Lori A. Burns. A variational 2-RDM-driven CASSCF plugin to PSI4. Installation¶; Binary. v2rdm_casscf is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). If using the Psi4conda installer, v2rdm_casscf has already been installed alongside. If using the PSI4 conda package, the v2rdm_casscf conda package can; be obtained through conda install v2rdm_casscf -c psi4 or conda install; psi4-rt -c psi4. If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; v2rdm_casscf can be obtained through conda install v2rdm_casscf -c psi4.; Then, hint its location with PYTHONPATH. To remove a conda installation, conda remove v2rdm_casscf. Source. If using PSI4 built from source and you want v2rdm_casscf built from; from source also,; build it, then hint its location with PYTHONPATH. table of contents. Plugin v2rdm_casscf by A. E. DePrince; Installation. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/plugin_v2rdm_casscf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugin_v2rdm_casscf.html
https://psicode.org/psi4manual/1.2.1/plugin_v2rdm_casscf.html:935,Deployability,install,installation,935,"﻿. Plugin v2rdm_casscf by A. E. DePrince. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. Plugin v2rdm_casscf by A. E. DePrince¶; Code author: A. E. DePrince; Section author: Lori A. Burns. A variational 2-RDM-driven CASSCF plugin to PSI4. Installation¶; Binary. v2rdm_casscf is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). If using the Psi4conda installer, v2rdm_casscf has already been installed alongside. If using the PSI4 conda package, the v2rdm_casscf conda package can; be obtained through conda install v2rdm_casscf -c psi4 or conda install; psi4-rt -c psi4. If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; v2rdm_casscf can be obtained through conda install v2rdm_casscf -c psi4.; Then, hint its location with PYTHONPATH. To remove a conda installation, conda remove v2rdm_casscf. Source. If using PSI4 built from source and you want v2rdm_casscf built from; from source also,; build it, then hint its location with PYTHONPATH. table of contents. Plugin v2rdm_casscf by A. E. DePrince; Installation. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/plugin_v2rdm_casscf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugin_v2rdm_casscf.html
https://psicode.org/psi4manual/1.2.1/plugin_v2rdm_casscf.html:1382,Deployability,update,updated,1382,"﻿. Plugin v2rdm_casscf by A. E. DePrince. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. Plugin v2rdm_casscf by A. E. DePrince¶; Code author: A. E. DePrince; Section author: Lori A. Burns. A variational 2-RDM-driven CASSCF plugin to PSI4. Installation¶; Binary. v2rdm_casscf is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). If using the Psi4conda installer, v2rdm_casscf has already been installed alongside. If using the PSI4 conda package, the v2rdm_casscf conda package can; be obtained through conda install v2rdm_casscf -c psi4 or conda install; psi4-rt -c psi4. If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; v2rdm_casscf can be obtained through conda install v2rdm_casscf -c psi4.; Then, hint its location with PYTHONPATH. To remove a conda installation, conda remove v2rdm_casscf. Source. If using PSI4 built from source and you want v2rdm_casscf built from; from source also,; build it, then hint its location with PYTHONPATH. table of contents. Plugin v2rdm_casscf by A. E. DePrince; Installation. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/plugin_v2rdm_casscf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugin_v2rdm_casscf.html
https://psicode.org/psi4manual/1.2.1/plugin_v2rdm_casscf.html:287,Modifiability,plugin,plugin,287,"﻿. Plugin v2rdm_casscf by A. E. DePrince. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. Plugin v2rdm_casscf by A. E. DePrince¶; Code author: A. E. DePrince; Section author: Lori A. Burns. A variational 2-RDM-driven CASSCF plugin to PSI4. Installation¶; Binary. v2rdm_casscf is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). If using the Psi4conda installer, v2rdm_casscf has already been installed alongside. If using the PSI4 conda package, the v2rdm_casscf conda package can; be obtained through conda install v2rdm_casscf -c psi4 or conda install; psi4-rt -c psi4. If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; v2rdm_casscf can be obtained through conda install v2rdm_casscf -c psi4.; Then, hint its location with PYTHONPATH. To remove a conda installation, conda remove v2rdm_casscf. Source. If using PSI4 built from source and you want v2rdm_casscf built from; from source also,; build it, then hint its location with PYTHONPATH. table of contents. Plugin v2rdm_casscf by A. E. DePrince; Installation. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/plugin_v2rdm_casscf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugin_v2rdm_casscf.html
https://psicode.org/psi4manual/1.2.1/proc_py-1.html:5072,Availability,error,error,5072,"ged methods handle both these cases through the addition of a new; keyword QC_MODULE and a set of type keywords analogous to; MP2_TYPE: MP_TYPE,; CI_TYPE, CC_TYPE, which can have values CONV,; DF, and CD. These are all global keywords, as their values are; shared among modules rather than (or in addition to) being used internally; by the module). We’re sticking with SCF_TYPE and; MP2_TYPE defaulting to DF, while everything higher defaults; to CONV. In psi4/share/python/driver.py, a managed method calls a; “select” function rather than a “run” function.; 1; 2; 3; 4; 5procedures = {; 'energy': {; 'scf' : run_scf,; 'mp3' : select_mp3,; 'dcft' : run_dcft,. Then in psi4/share/python/proc.py, the select function runs through; reference (always outer loop) and type (inner loop) to specify the proc; function to call for any able, non-default module (e.g., mtd_type ==; 'DETCI' ) or able, default module (e.g., mtd_typd == ['', 'FNOCC'] ).; Don’t worry about ‘else’ statements as anything that falls through will be; caught and a readable error generated.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35; 36; 37; 38; 39; 40; 41; 42; 43; 44def select_mp3(name, **kwargs):; """"""Function selecting the algorithm for a MP3 energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ/fnocc/detci. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_typ",MatchSource.WIKI,psi4manual/1.2.1/proc_py-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/proc_py-1.html
https://psicode.org/psi4manual/1.2.1/proc_py-1.html:6930,Availability,error,error,6930," func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['DETCI']:; func = run_detci. if func is None:; raise ManagedMethodError(['select_mp3', name, 'MP_TYPE', mtd_type, reference, module]). return func(name, **kwargs). Naturally, in the run function, you must either use the type keyword for; type switching or translate it into whatever DO_CD-like keywords your; module uses. At run time with a closed-shell molecule,; 1energy('mp3'). will run OCC, while; 1; 2set qc_module fnocc; energy('mp3'). will run FNOCC mp3.; A special case is DETCI that can run mp3, but oughtn’t to be used for such. So above, ROHF CONV mp3 has no default, but can still access the detci code with; 1; 2; 3set reference rohf; set qc_module detci; energy('mp3'). While the below gives an error; 1; 2set reference rohf; energy('mp3'). Again, whenever a single method name needs to call multiple proc.py run; functions, it should be managed. In Overlapping capabilities of . “Y” is available; “D” is default. “Y” means method available in; module, “D” means module is default for that method, “” mean method not; available. table of contents. Adding Methods to Driver; proc.py; Managed Methods. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Programming: Using the Core Libraries. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/proc_py-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/proc_py-1.html
https://psicode.org/psi4manual/1.2.1/proc_py-1.html:7122,Availability,avail,available,7122," func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['DETCI']:; func = run_detci. if func is None:; raise ManagedMethodError(['select_mp3', name, 'MP_TYPE', mtd_type, reference, module]). return func(name, **kwargs). Naturally, in the run function, you must either use the type keyword for; type switching or translate it into whatever DO_CD-like keywords your; module uses. At run time with a closed-shell molecule,; 1energy('mp3'). will run OCC, while; 1; 2set qc_module fnocc; energy('mp3'). will run FNOCC mp3.; A special case is DETCI that can run mp3, but oughtn’t to be used for such. So above, ROHF CONV mp3 has no default, but can still access the detci code with; 1; 2; 3set reference rohf; set qc_module detci; energy('mp3'). While the below gives an error; 1; 2set reference rohf; energy('mp3'). Again, whenever a single method name needs to call multiple proc.py run; functions, it should be managed. In Overlapping capabilities of . “Y” is available; “D” is default. “Y” means method available in; module, “D” means module is default for that method, “” mean method not; available. table of contents. Adding Methods to Driver; proc.py; Managed Methods. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Programming: Using the Core Libraries. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/proc_py-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/proc_py-1.html
https://psicode.org/psi4manual/1.2.1/proc_py-1.html:7166,Availability,avail,available,7166," func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['DETCI']:; func = run_detci. if func is None:; raise ManagedMethodError(['select_mp3', name, 'MP_TYPE', mtd_type, reference, module]). return func(name, **kwargs). Naturally, in the run function, you must either use the type keyword for; type switching or translate it into whatever DO_CD-like keywords your; module uses. At run time with a closed-shell molecule,; 1energy('mp3'). will run OCC, while; 1; 2set qc_module fnocc; energy('mp3'). will run FNOCC mp3.; A special case is DETCI that can run mp3, but oughtn’t to be used for such. So above, ROHF CONV mp3 has no default, but can still access the detci code with; 1; 2; 3set reference rohf; set qc_module detci; energy('mp3'). While the below gives an error; 1; 2set reference rohf; energy('mp3'). Again, whenever a single method name needs to call multiple proc.py run; functions, it should be managed. In Overlapping capabilities of . “Y” is available; “D” is default. “Y” means method available in; module, “D” means module is default for that method, “” mean method not; available. table of contents. Adding Methods to Driver; proc.py; Managed Methods. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Programming: Using the Core Libraries. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/proc_py-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/proc_py-1.html
https://psicode.org/psi4manual/1.2.1/proc_py-1.html:7253,Availability,avail,available,7253," func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['DETCI']:; func = run_detci. if func is None:; raise ManagedMethodError(['select_mp3', name, 'MP_TYPE', mtd_type, reference, module]). return func(name, **kwargs). Naturally, in the run function, you must either use the type keyword for; type switching or translate it into whatever DO_CD-like keywords your; module uses. At run time with a closed-shell molecule,; 1energy('mp3'). will run OCC, while; 1; 2set qc_module fnocc; energy('mp3'). will run FNOCC mp3.; A special case is DETCI that can run mp3, but oughtn’t to be used for such. So above, ROHF CONV mp3 has no default, but can still access the detci code with; 1; 2; 3set reference rohf; set qc_module detci; energy('mp3'). While the below gives an error; 1; 2set reference rohf; energy('mp3'). Again, whenever a single method name needs to call multiple proc.py run; functions, it should be managed. In Overlapping capabilities of . “Y” is available; “D” is default. “Y” means method available in; module, “D” means module is default for that method, “” mean method not; available. table of contents. Adding Methods to Driver; proc.py; Managed Methods. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Programming: Using the Core Libraries. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/proc_py-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/proc_py-1.html
https://psicode.org/psi4manual/1.2.1/proc_py-1.html:7520,Deployability,update,updated,7520," func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['DETCI']:; func = run_detci. if func is None:; raise ManagedMethodError(['select_mp3', name, 'MP_TYPE', mtd_type, reference, module]). return func(name, **kwargs). Naturally, in the run function, you must either use the type keyword for; type switching or translate it into whatever DO_CD-like keywords your; module uses. At run time with a closed-shell molecule,; 1energy('mp3'). will run OCC, while; 1; 2set qc_module fnocc; energy('mp3'). will run FNOCC mp3.; A special case is DETCI that can run mp3, but oughtn’t to be used for such. So above, ROHF CONV mp3 has no default, but can still access the detci code with; 1; 2; 3set reference rohf; set qc_module detci; energy('mp3'). While the below gives an error; 1; 2set reference rohf; energy('mp3'). Again, whenever a single method name needs to call multiple proc.py run; functions, it should be managed. In Overlapping capabilities of . “Y” is available; “D” is default. “Y” means method available in; module, “D” means module is default for that method, “” mean method not; available. table of contents. Adding Methods to Driver; proc.py; Managed Methods. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Programming: Using the Core Libraries. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/proc_py-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/proc_py-1.html
https://psicode.org/psi4manual/1.2.1/proc_py-1.html:645,Energy Efficiency,energy,energy,645,"﻿. Adding Methods to Driver. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Programming: Using the Core Libraries. Adding Methods to Driver¶. proc.py¶; This is concerned at present with normal methods added first to the; procedures table in driver.py that associates method names with functions; to run them located in proc.py .; The function should start with a declaration, as below. methodname is; never seen by users, so it’s good to be specific; if there’s lots of; modules that can run mp2, call methodname modulenamemethodname, perhaps.; The function must always take as arguments (name, **kwargs).; 1; 2; 3; 4; 5# energy method; def run_methodname(name, **kwargs):. # gradient method; def run_methodname_gradient(name, **kwargs):. If the function needs to test the identity of name several times, it; can be convenient to predefine the lowercase version of the variable. The; case of all other py-side options (in kwargs) has already been handled by; energy(), etc. in driver.py and need not be repeated here.; 1; 2; 3; 4; 5# include if convenient; lowername = name.lower(). # never include; kwargs = kwargs_lower(kwargs). It’s often necessary to The function often needs to set options for the; c-side modules it calls. In order that the state of the options set by the; user remains when control is returned to the user, an; OptionsState object is set up. See; LibOptions: globals, locals, has_changed and all that for details. All options set by the; function need to be included here, and only options set by the function; should be included. Most options should be associated with a particular; module, but a few (see below) are given without module.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13# include if any options set; optstash = OptionsState(; # these and other basis options should have no associated module; ['BASIS'],; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['PUREAM'],; ['FREEZE_CORE'],; # all others should have an associated module; ['SCF', 'SCF_TYPE'],; ",MatchSource.WIKI,psi4manual/1.2.1/proc_py-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/proc_py-1.html
https://psicode.org/psi4manual/1.2.1/proc_py-1.html:982,Energy Efficiency,energy,energy,982,"﻿. Adding Methods to Driver. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Programming: Using the Core Libraries. Adding Methods to Driver¶. proc.py¶; This is concerned at present with normal methods added first to the; procedures table in driver.py that associates method names with functions; to run them located in proc.py .; The function should start with a declaration, as below. methodname is; never seen by users, so it’s good to be specific; if there’s lots of; modules that can run mp2, call methodname modulenamemethodname, perhaps.; The function must always take as arguments (name, **kwargs).; 1; 2; 3; 4; 5# energy method; def run_methodname(name, **kwargs):. # gradient method; def run_methodname_gradient(name, **kwargs):. If the function needs to test the identity of name several times, it; can be convenient to predefine the lowercase version of the variable. The; case of all other py-side options (in kwargs) has already been handled by; energy(), etc. in driver.py and need not be repeated here.; 1; 2; 3; 4; 5# include if convenient; lowername = name.lower(). # never include; kwargs = kwargs_lower(kwargs). It’s often necessary to The function often needs to set options for the; c-side modules it calls. In order that the state of the options set by the; user remains when control is returned to the user, an; OptionsState object is set up. See; LibOptions: globals, locals, has_changed and all that for details. All options set by the; function need to be included here, and only options set by the function; should be included. Most options should be associated with a particular; module, but a few (see below) are given without module.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13# include if any options set; optstash = OptionsState(; # these and other basis options should have no associated module; ['BASIS'],; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['PUREAM'],; ['FREEZE_CORE'],; # all others should have an associated module; ['SCF', 'SCF_TYPE'],; ",MatchSource.WIKI,psi4manual/1.2.1/proc_py-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/proc_py-1.html
https://psicode.org/psi4manual/1.2.1/proc_py-1.html:3672,Energy Efficiency,energy,energy,3672,"ference wavefunction by pre-running scf,; then running the module with the ref_wfn kwarg. Also, if the full; two-electron integrals are necessary for the post-scf, compute them if; only the df integrals were run previously.; 1; 2; 3; 4; 5; 6; 7; 8; 9# Bypass the scf call if a reference wavefunction is given. ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # If the scf type is DF/CD, then the AO integrals were never written to disk; if psi4.get_option('SCF', 'SCF_TYPE') in ['DF', 'CD']:; psi4.MintsHelper(ref_wfn.basisset()).integrals(). Direct any post-scf modules to be run.; 1; 2; 3; 4# include if further post-scf modules are needed; psi4.transqt2(); psi4.ccsort(); psi4.mp2(). If an OptionsState object was set up, those options; need to be returned to the original user state with the following.; 1; 2# include if optstash = OptionsState( was set up previously; optstash.restore(). No function should return anything. CURRENT ENERGY will be set by; energy(), etc.; 1; 2# never include; return returnvalue. Managed Methods¶; When functionality overlaps between modules, a pattern is needed to (1); access each route through the code without contrivances like ccsd2,; _ccsd, sdci and (2) apportion defaulting among the modules, taking; into account reference (RHF/UHF/ROHF) and calc type (CONV, DF, CD).; Managed methods handle both these cases through the addition of a new; keyword QC_MODULE and a set of type keywords analogous to; MP2_TYPE: MP_TYPE,; CI_TYPE, CC_TYPE, which can have values CONV,; DF, and CD. These are all global keywords, as their values are; shared among modules rather than (or in addition to) being used internally; by the module). We’re sticking with SCF_TYPE and; MP2_TYPE defaulting to DF, while everything higher defaults; to CONV. In psi4/share/python/driver.py, a managed method calls a; “select” function rather than a “run” function.; 1; 2; 3; 4; 5procedures = {; 'energy': {; 'scf' : run_scf,; 'mp3' : selec",MatchSource.WIKI,psi4manual/1.2.1/proc_py-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/proc_py-1.html
https://psicode.org/psi4manual/1.2.1/proc_py-1.html:4620,Energy Efficiency,energy,energy,4620,". CURRENT ENERGY will be set by; energy(), etc.; 1; 2# never include; return returnvalue. Managed Methods¶; When functionality overlaps between modules, a pattern is needed to (1); access each route through the code without contrivances like ccsd2,; _ccsd, sdci and (2) apportion defaulting among the modules, taking; into account reference (RHF/UHF/ROHF) and calc type (CONV, DF, CD).; Managed methods handle both these cases through the addition of a new; keyword QC_MODULE and a set of type keywords analogous to; MP2_TYPE: MP_TYPE,; CI_TYPE, CC_TYPE, which can have values CONV,; DF, and CD. These are all global keywords, as their values are; shared among modules rather than (or in addition to) being used internally; by the module). We’re sticking with SCF_TYPE and; MP2_TYPE defaulting to DF, while everything higher defaults; to CONV. In psi4/share/python/driver.py, a managed method calls a; “select” function rather than a “run” function.; 1; 2; 3; 4; 5procedures = {; 'energy': {; 'scf' : run_scf,; 'mp3' : select_mp3,; 'dcft' : run_dcft,. Then in psi4/share/python/proc.py, the select function runs through; reference (always outer loop) and type (inner loop) to specify the proc; function to call for any able, non-default module (e.g., mtd_type ==; 'DETCI' ) or able, default module (e.g., mtd_typd == ['', 'FNOCC'] ).; Don’t worry about ‘else’ statements as anything that falls through will be; caught and a readable error generated.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35; 36; 37; 38; 39; 40; 41; 42; 43; 44def select_mp3(name, **kwargs):; """"""Function selecting the algorithm for a MP3 energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ/fnocc/detci. func = None; if reference == 'RHF':; if mt",MatchSource.WIKI,psi4manual/1.2.1/proc_py-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/proc_py-1.html
https://psicode.org/psi4manual/1.2.1/proc_py-1.html:5334,Energy Efficiency,energy,energy,5334,"global keywords, as their values are; shared among modules rather than (or in addition to) being used internally; by the module). We’re sticking with SCF_TYPE and; MP2_TYPE defaulting to DF, while everything higher defaults; to CONV. In psi4/share/python/driver.py, a managed method calls a; “select” function rather than a “run” function.; 1; 2; 3; 4; 5procedures = {; 'energy': {; 'scf' : run_scf,; 'mp3' : select_mp3,; 'dcft' : run_dcft,. Then in psi4/share/python/proc.py, the select function runs through; reference (always outer loop) and type (inner loop) to specify the proc; function to call for any able, non-default module (e.g., mtd_type ==; 'DETCI' ) or able, default module (e.g., mtd_typd == ['', 'FNOCC'] ).; Don’t worry about ‘else’ statements as anything that falls through will be; caught and a readable error generated.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35; 36; 37; 38; 39; 40; 41; 42; 43; 44def select_mp3(name, **kwargs):; """"""Function selecting the algorithm for a MP3 energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ/fnocc/detci. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['DETCI']:; func = run_detci.",MatchSource.WIKI,psi4manual/1.2.1/proc_py-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/proc_py-1.html
https://psicode.org/psi4manual/1.2.1/proc_py-1.html:6648,Energy Efficiency,energy,energy,6648," func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['DETCI']:; func = run_detci. if func is None:; raise ManagedMethodError(['select_mp3', name, 'MP_TYPE', mtd_type, reference, module]). return func(name, **kwargs). Naturally, in the run function, you must either use the type keyword for; type switching or translate it into whatever DO_CD-like keywords your; module uses. At run time with a closed-shell molecule,; 1energy('mp3'). will run OCC, while; 1; 2set qc_module fnocc; energy('mp3'). will run FNOCC mp3.; A special case is DETCI that can run mp3, but oughtn’t to be used for such. So above, ROHF CONV mp3 has no default, but can still access the detci code with; 1; 2; 3set reference rohf; set qc_module detci; energy('mp3'). While the below gives an error; 1; 2set reference rohf; energy('mp3'). Again, whenever a single method name needs to call multiple proc.py run; functions, it should be managed. In Overlapping capabilities of . “Y” is available; “D” is default. “Y” means method available in; module, “D” means module is default for that method, “” mean method not; available. table of contents. Adding Methods to Driver; proc.py; Managed Methods. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Programming: Using the Core Libraries. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/proc_py-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/proc_py-1.html
https://psicode.org/psi4manual/1.2.1/proc_py-1.html:6890,Energy Efficiency,energy,energy,6890," func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['DETCI']:; func = run_detci. if func is None:; raise ManagedMethodError(['select_mp3', name, 'MP_TYPE', mtd_type, reference, module]). return func(name, **kwargs). Naturally, in the run function, you must either use the type keyword for; type switching or translate it into whatever DO_CD-like keywords your; module uses. At run time with a closed-shell molecule,; 1energy('mp3'). will run OCC, while; 1; 2set qc_module fnocc; energy('mp3'). will run FNOCC mp3.; A special case is DETCI that can run mp3, but oughtn’t to be used for such. So above, ROHF CONV mp3 has no default, but can still access the detci code with; 1; 2; 3set reference rohf; set qc_module detci; energy('mp3'). While the below gives an error; 1; 2set reference rohf; energy('mp3'). Again, whenever a single method name needs to call multiple proc.py run; functions, it should be managed. In Overlapping capabilities of . “Y” is available; “D” is default. “Y” means method available in; module, “D” means module is default for that method, “” mean method not; available. table of contents. Adding Methods to Driver; proc.py; Managed Methods. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Programming: Using the Core Libraries. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/proc_py-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/proc_py-1.html
https://psicode.org/psi4manual/1.2.1/proc_py-1.html:6961,Energy Efficiency,energy,energy,6961," func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['DETCI']:; func = run_detci. if func is None:; raise ManagedMethodError(['select_mp3', name, 'MP_TYPE', mtd_type, reference, module]). return func(name, **kwargs). Naturally, in the run function, you must either use the type keyword for; type switching or translate it into whatever DO_CD-like keywords your; module uses. At run time with a closed-shell molecule,; 1energy('mp3'). will run OCC, while; 1; 2set qc_module fnocc; energy('mp3'). will run FNOCC mp3.; A special case is DETCI that can run mp3, but oughtn’t to be used for such. So above, ROHF CONV mp3 has no default, but can still access the detci code with; 1; 2; 3set reference rohf; set qc_module detci; energy('mp3'). While the below gives an error; 1; 2set reference rohf; energy('mp3'). Again, whenever a single method name needs to call multiple proc.py run; functions, it should be managed. In Overlapping capabilities of . “Y” is available; “D” is default. “Y” means method available in; module, “D” means module is default for that method, “” mean method not; available. table of contents. Adding Methods to Driver; proc.py; Managed Methods. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Programming: Using the Core Libraries. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/proc_py-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/proc_py-1.html
https://psicode.org/psi4manual/1.2.1/proc_py-1.html:3832,Integrability,rout,route,3832,"reviously.; 1; 2; 3; 4; 5; 6; 7; 8; 9# Bypass the scf call if a reference wavefunction is given. ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # If the scf type is DF/CD, then the AO integrals were never written to disk; if psi4.get_option('SCF', 'SCF_TYPE') in ['DF', 'CD']:; psi4.MintsHelper(ref_wfn.basisset()).integrals(). Direct any post-scf modules to be run.; 1; 2; 3; 4# include if further post-scf modules are needed; psi4.transqt2(); psi4.ccsort(); psi4.mp2(). If an OptionsState object was set up, those options; need to be returned to the original user state with the following.; 1; 2# include if optstash = OptionsState( was set up previously; optstash.restore(). No function should return anything. CURRENT ENERGY will be set by; energy(), etc.; 1; 2# never include; return returnvalue. Managed Methods¶; When functionality overlaps between modules, a pattern is needed to (1); access each route through the code without contrivances like ccsd2,; _ccsd, sdci and (2) apportion defaulting among the modules, taking; into account reference (RHF/UHF/ROHF) and calc type (CONV, DF, CD).; Managed methods handle both these cases through the addition of a new; keyword QC_MODULE and a set of type keywords analogous to; MP2_TYPE: MP_TYPE,; CI_TYPE, CC_TYPE, which can have values CONV,; DF, and CD. These are all global keywords, as their values are; shared among modules rather than (or in addition to) being used internally; by the module). We’re sticking with SCF_TYPE and; MP2_TYPE defaulting to DF, while everything higher defaults; to CONV. In psi4/share/python/driver.py, a managed method calls a; “select” function rather than a “run” function.; 1; 2; 3; 4; 5procedures = {; 'energy': {; 'scf' : run_scf,; 'mp3' : select_mp3,; 'dcft' : run_dcft,. Then in psi4/share/python/proc.py, the select function runs through; reference (always outer loop) and type (inner loop) to specify the proc; function to call for any able, non-default ",MatchSource.WIKI,psi4manual/1.2.1/proc_py-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/proc_py-1.html
https://psicode.org/psi4manual/1.2.1/proc_py-1.html:892,Modifiability,variab,variable,892,"﻿. Adding Methods to Driver. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Programming: Using the Core Libraries. Adding Methods to Driver¶. proc.py¶; This is concerned at present with normal methods added first to the; procedures table in driver.py that associates method names with functions; to run them located in proc.py .; The function should start with a declaration, as below. methodname is; never seen by users, so it’s good to be specific; if there’s lots of; modules that can run mp2, call methodname modulenamemethodname, perhaps.; The function must always take as arguments (name, **kwargs).; 1; 2; 3; 4; 5# energy method; def run_methodname(name, **kwargs):. # gradient method; def run_methodname_gradient(name, **kwargs):. If the function needs to test the identity of name several times, it; can be convenient to predefine the lowercase version of the variable. The; case of all other py-side options (in kwargs) has already been handled by; energy(), etc. in driver.py and need not be repeated here.; 1; 2; 3; 4; 5# include if convenient; lowername = name.lower(). # never include; kwargs = kwargs_lower(kwargs). It’s often necessary to The function often needs to set options for the; c-side modules it calls. In order that the state of the options set by the; user remains when control is returned to the user, an; OptionsState object is set up. See; LibOptions: globals, locals, has_changed and all that for details. All options set by the; function need to be included here, and only options set by the function; should be included. Most options should be associated with a particular; module, but a few (see below) are given without module.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13# include if any options set; optstash = OptionsState(; # these and other basis options should have no associated module; ['BASIS'],; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['PUREAM'],; ['FREEZE_CORE'],; # all others should have an associated module; ['SCF', 'SCF_TYPE'],; ",MatchSource.WIKI,psi4manual/1.2.1/proc_py-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/proc_py-1.html
https://psicode.org/psi4manual/1.2.1/proc_py-1.html:5382,Performance,perform,performance,5382,"global keywords, as their values are; shared among modules rather than (or in addition to) being used internally; by the module). We’re sticking with SCF_TYPE and; MP2_TYPE defaulting to DF, while everything higher defaults; to CONV. In psi4/share/python/driver.py, a managed method calls a; “select” function rather than a “run” function.; 1; 2; 3; 4; 5procedures = {; 'energy': {; 'scf' : run_scf,; 'mp3' : select_mp3,; 'dcft' : run_dcft,. Then in psi4/share/python/proc.py, the select function runs through; reference (always outer loop) and type (inner loop) to specify the proc; function to call for any able, non-default module (e.g., mtd_type ==; 'DETCI' ) or able, default module (e.g., mtd_typd == ['', 'FNOCC'] ).; Don’t worry about ‘else’ statements as anything that falls through will be; caught and a readable error generated.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35; 36; 37; 38; 39; 40; 41; 42; 43; 44def select_mp3(name, **kwargs):; """"""Function selecting the algorithm for a MP3 energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ/fnocc/detci. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['DETCI']:; func = run_detci.",MatchSource.WIKI,psi4manual/1.2.1/proc_py-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/proc_py-1.html
https://psicode.org/psi4manual/1.2.1/proc_py-1.html:3820,Security,access,access,3820,"reviously.; 1; 2; 3; 4; 5; 6; 7; 8; 9# Bypass the scf call if a reference wavefunction is given. ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # If the scf type is DF/CD, then the AO integrals were never written to disk; if psi4.get_option('SCF', 'SCF_TYPE') in ['DF', 'CD']:; psi4.MintsHelper(ref_wfn.basisset()).integrals(). Direct any post-scf modules to be run.; 1; 2; 3; 4# include if further post-scf modules are needed; psi4.transqt2(); psi4.ccsort(); psi4.mp2(). If an OptionsState object was set up, those options; need to be returned to the original user state with the following.; 1; 2# include if optstash = OptionsState( was set up previously; optstash.restore(). No function should return anything. CURRENT ENERGY will be set by; energy(), etc.; 1; 2# never include; return returnvalue. Managed Methods¶; When functionality overlaps between modules, a pattern is needed to (1); access each route through the code without contrivances like ccsd2,; _ccsd, sdci and (2) apportion defaulting among the modules, taking; into account reference (RHF/UHF/ROHF) and calc type (CONV, DF, CD).; Managed methods handle both these cases through the addition of a new; keyword QC_MODULE and a set of type keywords analogous to; MP2_TYPE: MP_TYPE,; CI_TYPE, CC_TYPE, which can have values CONV,; DF, and CD. These are all global keywords, as their values are; shared among modules rather than (or in addition to) being used internally; by the module). We’re sticking with SCF_TYPE and; MP2_TYPE defaulting to DF, while everything higher defaults; to CONV. In psi4/share/python/driver.py, a managed method calls a; “select” function rather than a “run” function.; 1; 2; 3; 4; 5procedures = {; 'energy': {; 'scf' : run_scf,; 'mp3' : select_mp3,; 'dcft' : run_dcft,. Then in psi4/share/python/proc.py, the select function runs through; reference (always outer loop) and type (inner loop) to specify the proc; function to call for any able, non-default ",MatchSource.WIKI,psi4manual/1.2.1/proc_py-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/proc_py-1.html
https://psicode.org/psi4manual/1.2.1/proc_py-1.html:6814,Security,access,access,6814," func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['DETCI']:; func = run_detci. if func is None:; raise ManagedMethodError(['select_mp3', name, 'MP_TYPE', mtd_type, reference, module]). return func(name, **kwargs). Naturally, in the run function, you must either use the type keyword for; type switching or translate it into whatever DO_CD-like keywords your; module uses. At run time with a closed-shell molecule,; 1energy('mp3'). will run OCC, while; 1; 2set qc_module fnocc; energy('mp3'). will run FNOCC mp3.; A special case is DETCI that can run mp3, but oughtn’t to be used for such. So above, ROHF CONV mp3 has no default, but can still access the detci code with; 1; 2; 3set reference rohf; set qc_module detci; energy('mp3'). While the below gives an error; 1; 2set reference rohf; energy('mp3'). Again, whenever a single method name needs to call multiple proc.py run; functions, it should be managed. In Overlapping capabilities of . “Y” is available; “D” is default. “Y” means method available in; module, “D” means module is default for that method, “” mean method not; available. table of contents. Adding Methods to Driver; proc.py; Managed Methods. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Programming: Using the Core Libraries. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/proc_py-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/proc_py-1.html
https://psicode.org/psi4manual/1.2.1/proc_py-1.html:787,Testability,test,test,787,"﻿. Adding Methods to Driver. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Programming: Using the Core Libraries. Adding Methods to Driver¶. proc.py¶; This is concerned at present with normal methods added first to the; procedures table in driver.py that associates method names with functions; to run them located in proc.py .; The function should start with a declaration, as below. methodname is; never seen by users, so it’s good to be specific; if there’s lots of; modules that can run mp2, call methodname modulenamemethodname, perhaps.; The function must always take as arguments (name, **kwargs).; 1; 2; 3; 4; 5# energy method; def run_methodname(name, **kwargs):. # gradient method; def run_methodname_gradient(name, **kwargs):. If the function needs to test the identity of name several times, it; can be convenient to predefine the lowercase version of the variable. The; case of all other py-side options (in kwargs) has already been handled by; energy(), etc. in driver.py and need not be repeated here.; 1; 2; 3; 4; 5# include if convenient; lowername = name.lower(). # never include; kwargs = kwargs_lower(kwargs). It’s often necessary to The function often needs to set options for the; c-side modules it calls. In order that the state of the options set by the; user remains when control is returned to the user, an; OptionsState object is set up. See; LibOptions: globals, locals, has_changed and all that for details. All options set by the; function need to be included here, and only options set by the function; should be included. Most options should be associated with a particular; module, but a few (see below) are given without module.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13# include if any options set; optstash = OptionsState(; # these and other basis options should have no associated module; ['BASIS'],; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['PUREAM'],; ['FREEZE_CORE'],; # all others should have an associated module; ['SCF', 'SCF_TYPE'],; ",MatchSource.WIKI,psi4manual/1.2.1/proc_py-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/proc_py-1.html
https://psicode.org/psi4manual/1.2.1/proc_py.html:5072,Availability,error,error,5072,"ged methods handle both these cases through the addition of a new; keyword QC_MODULE and a set of type keywords analogous to; MP2_TYPE: MP_TYPE,; CI_TYPE, CC_TYPE, which can have values CONV,; DF, and CD. These are all global keywords, as their values are; shared among modules rather than (or in addition to) being used internally; by the module). We’re sticking with SCF_TYPE and; MP2_TYPE defaulting to DF, while everything higher defaults; to CONV. In psi4/share/python/driver.py, a managed method calls a; “select” function rather than a “run” function.; 1; 2; 3; 4; 5procedures = {; 'energy': {; 'scf' : run_scf,; 'mp3' : select_mp3,; 'dcft' : run_dcft,. Then in psi4/share/python/proc.py, the select function runs through; reference (always outer loop) and type (inner loop) to specify the proc; function to call for any able, non-default module (e.g., mtd_type ==; 'DETCI' ) or able, default module (e.g., mtd_typd == ['', 'FNOCC'] ).; Don’t worry about ‘else’ statements as anything that falls through will be; caught and a readable error generated.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35; 36; 37; 38; 39; 40; 41; 42; 43; 44def select_mp3(name, **kwargs):; """"""Function selecting the algorithm for a MP3 energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ/fnocc/detci. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_typ",MatchSource.WIKI,psi4manual/1.2.1/proc_py.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/proc_py.html
https://psicode.org/psi4manual/1.2.1/proc_py.html:6930,Availability,error,error,6930," func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['DETCI']:; func = run_detci. if func is None:; raise ManagedMethodError(['select_mp3', name, 'MP_TYPE', mtd_type, reference, module]). return func(name, **kwargs). Naturally, in the run function, you must either use the type keyword for; type switching or translate it into whatever DO_CD-like keywords your; module uses. At run time with a closed-shell molecule,; 1energy('mp3'). will run OCC, while; 1; 2set qc_module fnocc; energy('mp3'). will run FNOCC mp3.; A special case is DETCI that can run mp3, but oughtn’t to be used for such. So above, ROHF CONV mp3 has no default, but can still access the detci code with; 1; 2; 3set reference rohf; set qc_module detci; energy('mp3'). While the below gives an error; 1; 2set reference rohf; energy('mp3'). Again, whenever a single method name needs to call multiple proc.py run; functions, it should be managed. In Overlapping capabilities of . “Y” is available; “D” is default. “Y” means method available in; module, “D” means module is default for that method, “” mean method not; available. table of contents. Adding Methods to Driver; proc.py; Managed Methods. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Programming: Using the Core Libraries. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/proc_py.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/proc_py.html
https://psicode.org/psi4manual/1.2.1/proc_py.html:7122,Availability,avail,available,7122," func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['DETCI']:; func = run_detci. if func is None:; raise ManagedMethodError(['select_mp3', name, 'MP_TYPE', mtd_type, reference, module]). return func(name, **kwargs). Naturally, in the run function, you must either use the type keyword for; type switching or translate it into whatever DO_CD-like keywords your; module uses. At run time with a closed-shell molecule,; 1energy('mp3'). will run OCC, while; 1; 2set qc_module fnocc; energy('mp3'). will run FNOCC mp3.; A special case is DETCI that can run mp3, but oughtn’t to be used for such. So above, ROHF CONV mp3 has no default, but can still access the detci code with; 1; 2; 3set reference rohf; set qc_module detci; energy('mp3'). While the below gives an error; 1; 2set reference rohf; energy('mp3'). Again, whenever a single method name needs to call multiple proc.py run; functions, it should be managed. In Overlapping capabilities of . “Y” is available; “D” is default. “Y” means method available in; module, “D” means module is default for that method, “” mean method not; available. table of contents. Adding Methods to Driver; proc.py; Managed Methods. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Programming: Using the Core Libraries. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/proc_py.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/proc_py.html
https://psicode.org/psi4manual/1.2.1/proc_py.html:7166,Availability,avail,available,7166," func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['DETCI']:; func = run_detci. if func is None:; raise ManagedMethodError(['select_mp3', name, 'MP_TYPE', mtd_type, reference, module]). return func(name, **kwargs). Naturally, in the run function, you must either use the type keyword for; type switching or translate it into whatever DO_CD-like keywords your; module uses. At run time with a closed-shell molecule,; 1energy('mp3'). will run OCC, while; 1; 2set qc_module fnocc; energy('mp3'). will run FNOCC mp3.; A special case is DETCI that can run mp3, but oughtn’t to be used for such. So above, ROHF CONV mp3 has no default, but can still access the detci code with; 1; 2; 3set reference rohf; set qc_module detci; energy('mp3'). While the below gives an error; 1; 2set reference rohf; energy('mp3'). Again, whenever a single method name needs to call multiple proc.py run; functions, it should be managed. In Overlapping capabilities of . “Y” is available; “D” is default. “Y” means method available in; module, “D” means module is default for that method, “” mean method not; available. table of contents. Adding Methods to Driver; proc.py; Managed Methods. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Programming: Using the Core Libraries. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/proc_py.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/proc_py.html
https://psicode.org/psi4manual/1.2.1/proc_py.html:7253,Availability,avail,available,7253," func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['DETCI']:; func = run_detci. if func is None:; raise ManagedMethodError(['select_mp3', name, 'MP_TYPE', mtd_type, reference, module]). return func(name, **kwargs). Naturally, in the run function, you must either use the type keyword for; type switching or translate it into whatever DO_CD-like keywords your; module uses. At run time with a closed-shell molecule,; 1energy('mp3'). will run OCC, while; 1; 2set qc_module fnocc; energy('mp3'). will run FNOCC mp3.; A special case is DETCI that can run mp3, but oughtn’t to be used for such. So above, ROHF CONV mp3 has no default, but can still access the detci code with; 1; 2; 3set reference rohf; set qc_module detci; energy('mp3'). While the below gives an error; 1; 2set reference rohf; energy('mp3'). Again, whenever a single method name needs to call multiple proc.py run; functions, it should be managed. In Overlapping capabilities of . “Y” is available; “D” is default. “Y” means method available in; module, “D” means module is default for that method, “” mean method not; available. table of contents. Adding Methods to Driver; proc.py; Managed Methods. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Programming: Using the Core Libraries. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/proc_py.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/proc_py.html
https://psicode.org/psi4manual/1.2.1/proc_py.html:7520,Deployability,update,updated,7520," func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['DETCI']:; func = run_detci. if func is None:; raise ManagedMethodError(['select_mp3', name, 'MP_TYPE', mtd_type, reference, module]). return func(name, **kwargs). Naturally, in the run function, you must either use the type keyword for; type switching or translate it into whatever DO_CD-like keywords your; module uses. At run time with a closed-shell molecule,; 1energy('mp3'). will run OCC, while; 1; 2set qc_module fnocc; energy('mp3'). will run FNOCC mp3.; A special case is DETCI that can run mp3, but oughtn’t to be used for such. So above, ROHF CONV mp3 has no default, but can still access the detci code with; 1; 2; 3set reference rohf; set qc_module detci; energy('mp3'). While the below gives an error; 1; 2set reference rohf; energy('mp3'). Again, whenever a single method name needs to call multiple proc.py run; functions, it should be managed. In Overlapping capabilities of . “Y” is available; “D” is default. “Y” means method available in; module, “D” means module is default for that method, “” mean method not; available. table of contents. Adding Methods to Driver; proc.py; Managed Methods. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Programming: Using the Core Libraries. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/proc_py.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/proc_py.html
https://psicode.org/psi4manual/1.2.1/proc_py.html:645,Energy Efficiency,energy,energy,645,"﻿. Adding Methods to Driver. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Programming: Using the Core Libraries. Adding Methods to Driver¶. proc.py¶; This is concerned at present with normal methods added first to the; procedures table in driver.py that associates method names with functions; to run them located in proc.py .; The function should start with a declaration, as below. methodname is; never seen by users, so it’s good to be specific; if there’s lots of; modules that can run mp2, call methodname modulenamemethodname, perhaps.; The function must always take as arguments (name, **kwargs).; 1; 2; 3; 4; 5# energy method; def run_methodname(name, **kwargs):. # gradient method; def run_methodname_gradient(name, **kwargs):. If the function needs to test the identity of name several times, it; can be convenient to predefine the lowercase version of the variable. The; case of all other py-side options (in kwargs) has already been handled by; energy(), etc. in driver.py and need not be repeated here.; 1; 2; 3; 4; 5# include if convenient; lowername = name.lower(). # never include; kwargs = kwargs_lower(kwargs). It’s often necessary to The function often needs to set options for the; c-side modules it calls. In order that the state of the options set by the; user remains when control is returned to the user, an; OptionsState object is set up. See; LibOptions: globals, locals, has_changed and all that for details. All options set by the; function need to be included here, and only options set by the function; should be included. Most options should be associated with a particular; module, but a few (see below) are given without module.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13# include if any options set; optstash = OptionsState(; # these and other basis options should have no associated module; ['BASIS'],; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['PUREAM'],; ['FREEZE_CORE'],; # all others should have an associated module; ['SCF', 'SCF_TYPE'],; ",MatchSource.WIKI,psi4manual/1.2.1/proc_py.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/proc_py.html
https://psicode.org/psi4manual/1.2.1/proc_py.html:982,Energy Efficiency,energy,energy,982,"﻿. Adding Methods to Driver. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Programming: Using the Core Libraries. Adding Methods to Driver¶. proc.py¶; This is concerned at present with normal methods added first to the; procedures table in driver.py that associates method names with functions; to run them located in proc.py .; The function should start with a declaration, as below. methodname is; never seen by users, so it’s good to be specific; if there’s lots of; modules that can run mp2, call methodname modulenamemethodname, perhaps.; The function must always take as arguments (name, **kwargs).; 1; 2; 3; 4; 5# energy method; def run_methodname(name, **kwargs):. # gradient method; def run_methodname_gradient(name, **kwargs):. If the function needs to test the identity of name several times, it; can be convenient to predefine the lowercase version of the variable. The; case of all other py-side options (in kwargs) has already been handled by; energy(), etc. in driver.py and need not be repeated here.; 1; 2; 3; 4; 5# include if convenient; lowername = name.lower(). # never include; kwargs = kwargs_lower(kwargs). It’s often necessary to The function often needs to set options for the; c-side modules it calls. In order that the state of the options set by the; user remains when control is returned to the user, an; OptionsState object is set up. See; LibOptions: globals, locals, has_changed and all that for details. All options set by the; function need to be included here, and only options set by the function; should be included. Most options should be associated with a particular; module, but a few (see below) are given without module.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13# include if any options set; optstash = OptionsState(; # these and other basis options should have no associated module; ['BASIS'],; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['PUREAM'],; ['FREEZE_CORE'],; # all others should have an associated module; ['SCF', 'SCF_TYPE'],; ",MatchSource.WIKI,psi4manual/1.2.1/proc_py.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/proc_py.html
https://psicode.org/psi4manual/1.2.1/proc_py.html:3672,Energy Efficiency,energy,energy,3672,"ference wavefunction by pre-running scf,; then running the module with the ref_wfn kwarg. Also, if the full; two-electron integrals are necessary for the post-scf, compute them if; only the df integrals were run previously.; 1; 2; 3; 4; 5; 6; 7; 8; 9# Bypass the scf call if a reference wavefunction is given. ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # If the scf type is DF/CD, then the AO integrals were never written to disk; if psi4.get_option('SCF', 'SCF_TYPE') in ['DF', 'CD']:; psi4.MintsHelper(ref_wfn.basisset()).integrals(). Direct any post-scf modules to be run.; 1; 2; 3; 4# include if further post-scf modules are needed; psi4.transqt2(); psi4.ccsort(); psi4.mp2(). If an OptionsState object was set up, those options; need to be returned to the original user state with the following.; 1; 2# include if optstash = OptionsState( was set up previously; optstash.restore(). No function should return anything. CURRENT ENERGY will be set by; energy(), etc.; 1; 2# never include; return returnvalue. Managed Methods¶; When functionality overlaps between modules, a pattern is needed to (1); access each route through the code without contrivances like ccsd2,; _ccsd, sdci and (2) apportion defaulting among the modules, taking; into account reference (RHF/UHF/ROHF) and calc type (CONV, DF, CD).; Managed methods handle both these cases through the addition of a new; keyword QC_MODULE and a set of type keywords analogous to; MP2_TYPE: MP_TYPE,; CI_TYPE, CC_TYPE, which can have values CONV,; DF, and CD. These are all global keywords, as their values are; shared among modules rather than (or in addition to) being used internally; by the module). We’re sticking with SCF_TYPE and; MP2_TYPE defaulting to DF, while everything higher defaults; to CONV. In psi4/share/python/driver.py, a managed method calls a; “select” function rather than a “run” function.; 1; 2; 3; 4; 5procedures = {; 'energy': {; 'scf' : run_scf,; 'mp3' : selec",MatchSource.WIKI,psi4manual/1.2.1/proc_py.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/proc_py.html
https://psicode.org/psi4manual/1.2.1/proc_py.html:4620,Energy Efficiency,energy,energy,4620,". CURRENT ENERGY will be set by; energy(), etc.; 1; 2# never include; return returnvalue. Managed Methods¶; When functionality overlaps between modules, a pattern is needed to (1); access each route through the code without contrivances like ccsd2,; _ccsd, sdci and (2) apportion defaulting among the modules, taking; into account reference (RHF/UHF/ROHF) and calc type (CONV, DF, CD).; Managed methods handle both these cases through the addition of a new; keyword QC_MODULE and a set of type keywords analogous to; MP2_TYPE: MP_TYPE,; CI_TYPE, CC_TYPE, which can have values CONV,; DF, and CD. These are all global keywords, as their values are; shared among modules rather than (or in addition to) being used internally; by the module). We’re sticking with SCF_TYPE and; MP2_TYPE defaulting to DF, while everything higher defaults; to CONV. In psi4/share/python/driver.py, a managed method calls a; “select” function rather than a “run” function.; 1; 2; 3; 4; 5procedures = {; 'energy': {; 'scf' : run_scf,; 'mp3' : select_mp3,; 'dcft' : run_dcft,. Then in psi4/share/python/proc.py, the select function runs through; reference (always outer loop) and type (inner loop) to specify the proc; function to call for any able, non-default module (e.g., mtd_type ==; 'DETCI' ) or able, default module (e.g., mtd_typd == ['', 'FNOCC'] ).; Don’t worry about ‘else’ statements as anything that falls through will be; caught and a readable error generated.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35; 36; 37; 38; 39; 40; 41; 42; 43; 44def select_mp3(name, **kwargs):; """"""Function selecting the algorithm for a MP3 energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ/fnocc/detci. func = None; if reference == 'RHF':; if mt",MatchSource.WIKI,psi4manual/1.2.1/proc_py.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/proc_py.html
https://psicode.org/psi4manual/1.2.1/proc_py.html:5334,Energy Efficiency,energy,energy,5334,"global keywords, as their values are; shared among modules rather than (or in addition to) being used internally; by the module). We’re sticking with SCF_TYPE and; MP2_TYPE defaulting to DF, while everything higher defaults; to CONV. In psi4/share/python/driver.py, a managed method calls a; “select” function rather than a “run” function.; 1; 2; 3; 4; 5procedures = {; 'energy': {; 'scf' : run_scf,; 'mp3' : select_mp3,; 'dcft' : run_dcft,. Then in psi4/share/python/proc.py, the select function runs through; reference (always outer loop) and type (inner loop) to specify the proc; function to call for any able, non-default module (e.g., mtd_type ==; 'DETCI' ) or able, default module (e.g., mtd_typd == ['', 'FNOCC'] ).; Don’t worry about ‘else’ statements as anything that falls through will be; caught and a readable error generated.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35; 36; 37; 38; 39; 40; 41; 42; 43; 44def select_mp3(name, **kwargs):; """"""Function selecting the algorithm for a MP3 energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ/fnocc/detci. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['DETCI']:; func = run_detci.",MatchSource.WIKI,psi4manual/1.2.1/proc_py.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/proc_py.html
https://psicode.org/psi4manual/1.2.1/proc_py.html:6648,Energy Efficiency,energy,energy,6648," func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['DETCI']:; func = run_detci. if func is None:; raise ManagedMethodError(['select_mp3', name, 'MP_TYPE', mtd_type, reference, module]). return func(name, **kwargs). Naturally, in the run function, you must either use the type keyword for; type switching or translate it into whatever DO_CD-like keywords your; module uses. At run time with a closed-shell molecule,; 1energy('mp3'). will run OCC, while; 1; 2set qc_module fnocc; energy('mp3'). will run FNOCC mp3.; A special case is DETCI that can run mp3, but oughtn’t to be used for such. So above, ROHF CONV mp3 has no default, but can still access the detci code with; 1; 2; 3set reference rohf; set qc_module detci; energy('mp3'). While the below gives an error; 1; 2set reference rohf; energy('mp3'). Again, whenever a single method name needs to call multiple proc.py run; functions, it should be managed. In Overlapping capabilities of . “Y” is available; “D” is default. “Y” means method available in; module, “D” means module is default for that method, “” mean method not; available. table of contents. Adding Methods to Driver; proc.py; Managed Methods. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Programming: Using the Core Libraries. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/proc_py.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/proc_py.html
https://psicode.org/psi4manual/1.2.1/proc_py.html:6890,Energy Efficiency,energy,energy,6890," func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['DETCI']:; func = run_detci. if func is None:; raise ManagedMethodError(['select_mp3', name, 'MP_TYPE', mtd_type, reference, module]). return func(name, **kwargs). Naturally, in the run function, you must either use the type keyword for; type switching or translate it into whatever DO_CD-like keywords your; module uses. At run time with a closed-shell molecule,; 1energy('mp3'). will run OCC, while; 1; 2set qc_module fnocc; energy('mp3'). will run FNOCC mp3.; A special case is DETCI that can run mp3, but oughtn’t to be used for such. So above, ROHF CONV mp3 has no default, but can still access the detci code with; 1; 2; 3set reference rohf; set qc_module detci; energy('mp3'). While the below gives an error; 1; 2set reference rohf; energy('mp3'). Again, whenever a single method name needs to call multiple proc.py run; functions, it should be managed. In Overlapping capabilities of . “Y” is available; “D” is default. “Y” means method available in; module, “D” means module is default for that method, “” mean method not; available. table of contents. Adding Methods to Driver; proc.py; Managed Methods. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Programming: Using the Core Libraries. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/proc_py.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/proc_py.html
https://psicode.org/psi4manual/1.2.1/proc_py.html:6961,Energy Efficiency,energy,energy,6961," func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['DETCI']:; func = run_detci. if func is None:; raise ManagedMethodError(['select_mp3', name, 'MP_TYPE', mtd_type, reference, module]). return func(name, **kwargs). Naturally, in the run function, you must either use the type keyword for; type switching or translate it into whatever DO_CD-like keywords your; module uses. At run time with a closed-shell molecule,; 1energy('mp3'). will run OCC, while; 1; 2set qc_module fnocc; energy('mp3'). will run FNOCC mp3.; A special case is DETCI that can run mp3, but oughtn’t to be used for such. So above, ROHF CONV mp3 has no default, but can still access the detci code with; 1; 2; 3set reference rohf; set qc_module detci; energy('mp3'). While the below gives an error; 1; 2set reference rohf; energy('mp3'). Again, whenever a single method name needs to call multiple proc.py run; functions, it should be managed. In Overlapping capabilities of . “Y” is available; “D” is default. “Y” means method available in; module, “D” means module is default for that method, “” mean method not; available. table of contents. Adding Methods to Driver; proc.py; Managed Methods. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Programming: Using the Core Libraries. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/proc_py.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/proc_py.html
https://psicode.org/psi4manual/1.2.1/proc_py.html:3832,Integrability,rout,route,3832,"reviously.; 1; 2; 3; 4; 5; 6; 7; 8; 9# Bypass the scf call if a reference wavefunction is given. ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # If the scf type is DF/CD, then the AO integrals were never written to disk; if psi4.get_option('SCF', 'SCF_TYPE') in ['DF', 'CD']:; psi4.MintsHelper(ref_wfn.basisset()).integrals(). Direct any post-scf modules to be run.; 1; 2; 3; 4# include if further post-scf modules are needed; psi4.transqt2(); psi4.ccsort(); psi4.mp2(). If an OptionsState object was set up, those options; need to be returned to the original user state with the following.; 1; 2# include if optstash = OptionsState( was set up previously; optstash.restore(). No function should return anything. CURRENT ENERGY will be set by; energy(), etc.; 1; 2# never include; return returnvalue. Managed Methods¶; When functionality overlaps between modules, a pattern is needed to (1); access each route through the code without contrivances like ccsd2,; _ccsd, sdci and (2) apportion defaulting among the modules, taking; into account reference (RHF/UHF/ROHF) and calc type (CONV, DF, CD).; Managed methods handle both these cases through the addition of a new; keyword QC_MODULE and a set of type keywords analogous to; MP2_TYPE: MP_TYPE,; CI_TYPE, CC_TYPE, which can have values CONV,; DF, and CD. These are all global keywords, as their values are; shared among modules rather than (or in addition to) being used internally; by the module). We’re sticking with SCF_TYPE and; MP2_TYPE defaulting to DF, while everything higher defaults; to CONV. In psi4/share/python/driver.py, a managed method calls a; “select” function rather than a “run” function.; 1; 2; 3; 4; 5procedures = {; 'energy': {; 'scf' : run_scf,; 'mp3' : select_mp3,; 'dcft' : run_dcft,. Then in psi4/share/python/proc.py, the select function runs through; reference (always outer loop) and type (inner loop) to specify the proc; function to call for any able, non-default ",MatchSource.WIKI,psi4manual/1.2.1/proc_py.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/proc_py.html
https://psicode.org/psi4manual/1.2.1/proc_py.html:892,Modifiability,variab,variable,892,"﻿. Adding Methods to Driver. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Programming: Using the Core Libraries. Adding Methods to Driver¶. proc.py¶; This is concerned at present with normal methods added first to the; procedures table in driver.py that associates method names with functions; to run them located in proc.py .; The function should start with a declaration, as below. methodname is; never seen by users, so it’s good to be specific; if there’s lots of; modules that can run mp2, call methodname modulenamemethodname, perhaps.; The function must always take as arguments (name, **kwargs).; 1; 2; 3; 4; 5# energy method; def run_methodname(name, **kwargs):. # gradient method; def run_methodname_gradient(name, **kwargs):. If the function needs to test the identity of name several times, it; can be convenient to predefine the lowercase version of the variable. The; case of all other py-side options (in kwargs) has already been handled by; energy(), etc. in driver.py and need not be repeated here.; 1; 2; 3; 4; 5# include if convenient; lowername = name.lower(). # never include; kwargs = kwargs_lower(kwargs). It’s often necessary to The function often needs to set options for the; c-side modules it calls. In order that the state of the options set by the; user remains when control is returned to the user, an; OptionsState object is set up. See; LibOptions: globals, locals, has_changed and all that for details. All options set by the; function need to be included here, and only options set by the function; should be included. Most options should be associated with a particular; module, but a few (see below) are given without module.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13# include if any options set; optstash = OptionsState(; # these and other basis options should have no associated module; ['BASIS'],; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['PUREAM'],; ['FREEZE_CORE'],; # all others should have an associated module; ['SCF', 'SCF_TYPE'],; ",MatchSource.WIKI,psi4manual/1.2.1/proc_py.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/proc_py.html
https://psicode.org/psi4manual/1.2.1/proc_py.html:5382,Performance,perform,performance,5382,"global keywords, as their values are; shared among modules rather than (or in addition to) being used internally; by the module). We’re sticking with SCF_TYPE and; MP2_TYPE defaulting to DF, while everything higher defaults; to CONV. In psi4/share/python/driver.py, a managed method calls a; “select” function rather than a “run” function.; 1; 2; 3; 4; 5procedures = {; 'energy': {; 'scf' : run_scf,; 'mp3' : select_mp3,; 'dcft' : run_dcft,. Then in psi4/share/python/proc.py, the select function runs through; reference (always outer loop) and type (inner loop) to specify the proc; function to call for any able, non-default module (e.g., mtd_type ==; 'DETCI' ) or able, default module (e.g., mtd_typd == ['', 'FNOCC'] ).; Don’t worry about ‘else’ statements as anything that falls through will be; caught and a readable error generated.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35; 36; 37; 38; 39; 40; 41; 42; 43; 44def select_mp3(name, **kwargs):; """"""Function selecting the algorithm for a MP3 energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ/fnocc/detci. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['DETCI']:; func = run_detci.",MatchSource.WIKI,psi4manual/1.2.1/proc_py.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/proc_py.html
https://psicode.org/psi4manual/1.2.1/proc_py.html:3820,Security,access,access,3820,"reviously.; 1; 2; 3; 4; 5; 6; 7; 8; 9# Bypass the scf call if a reference wavefunction is given. ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # If the scf type is DF/CD, then the AO integrals were never written to disk; if psi4.get_option('SCF', 'SCF_TYPE') in ['DF', 'CD']:; psi4.MintsHelper(ref_wfn.basisset()).integrals(). Direct any post-scf modules to be run.; 1; 2; 3; 4# include if further post-scf modules are needed; psi4.transqt2(); psi4.ccsort(); psi4.mp2(). If an OptionsState object was set up, those options; need to be returned to the original user state with the following.; 1; 2# include if optstash = OptionsState( was set up previously; optstash.restore(). No function should return anything. CURRENT ENERGY will be set by; energy(), etc.; 1; 2# never include; return returnvalue. Managed Methods¶; When functionality overlaps between modules, a pattern is needed to (1); access each route through the code without contrivances like ccsd2,; _ccsd, sdci and (2) apportion defaulting among the modules, taking; into account reference (RHF/UHF/ROHF) and calc type (CONV, DF, CD).; Managed methods handle both these cases through the addition of a new; keyword QC_MODULE and a set of type keywords analogous to; MP2_TYPE: MP_TYPE,; CI_TYPE, CC_TYPE, which can have values CONV,; DF, and CD. These are all global keywords, as their values are; shared among modules rather than (or in addition to) being used internally; by the module). We’re sticking with SCF_TYPE and; MP2_TYPE defaulting to DF, while everything higher defaults; to CONV. In psi4/share/python/driver.py, a managed method calls a; “select” function rather than a “run” function.; 1; 2; 3; 4; 5procedures = {; 'energy': {; 'scf' : run_scf,; 'mp3' : select_mp3,; 'dcft' : run_dcft,. Then in psi4/share/python/proc.py, the select function runs through; reference (always outer loop) and type (inner loop) to specify the proc; function to call for any able, non-default ",MatchSource.WIKI,psi4manual/1.2.1/proc_py.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/proc_py.html
https://psicode.org/psi4manual/1.2.1/proc_py.html:6814,Security,access,access,6814," func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['DETCI']:; func = run_detci. if func is None:; raise ManagedMethodError(['select_mp3', name, 'MP_TYPE', mtd_type, reference, module]). return func(name, **kwargs). Naturally, in the run function, you must either use the type keyword for; type switching or translate it into whatever DO_CD-like keywords your; module uses. At run time with a closed-shell molecule,; 1energy('mp3'). will run OCC, while; 1; 2set qc_module fnocc; energy('mp3'). will run FNOCC mp3.; A special case is DETCI that can run mp3, but oughtn’t to be used for such. So above, ROHF CONV mp3 has no default, but can still access the detci code with; 1; 2; 3set reference rohf; set qc_module detci; energy('mp3'). While the below gives an error; 1; 2set reference rohf; energy('mp3'). Again, whenever a single method name needs to call multiple proc.py run; functions, it should be managed. In Overlapping capabilities of . “Y” is available; “D” is default. “Y” means method available in; module, “D” means module is default for that method, “” mean method not; available. table of contents. Adding Methods to Driver; proc.py; Managed Methods. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Programming: Using the Core Libraries. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/proc_py.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/proc_py.html
https://psicode.org/psi4manual/1.2.1/proc_py.html:787,Testability,test,test,787,"﻿. Adding Methods to Driver. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Programming: Using the Core Libraries. Adding Methods to Driver¶. proc.py¶; This is concerned at present with normal methods added first to the; procedures table in driver.py that associates method names with functions; to run them located in proc.py .; The function should start with a declaration, as below. methodname is; never seen by users, so it’s good to be specific; if there’s lots of; modules that can run mp2, call methodname modulenamemethodname, perhaps.; The function must always take as arguments (name, **kwargs).; 1; 2; 3; 4; 5# energy method; def run_methodname(name, **kwargs):. # gradient method; def run_methodname_gradient(name, **kwargs):. If the function needs to test the identity of name several times, it; can be convenient to predefine the lowercase version of the variable. The; case of all other py-side options (in kwargs) has already been handled by; energy(), etc. in driver.py and need not be repeated here.; 1; 2; 3; 4; 5# include if convenient; lowername = name.lower(). # never include; kwargs = kwargs_lower(kwargs). It’s often necessary to The function often needs to set options for the; c-side modules it calls. In order that the state of the options set by the; user remains when control is returned to the user, an; OptionsState object is set up. See; LibOptions: globals, locals, has_changed and all that for details. All options set by the; function need to be included here, and only options set by the function; should be included. Most options should be associated with a particular; module, but a few (see below) are given without module.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13# include if any options set; optstash = OptionsState(; # these and other basis options should have no associated module; ['BASIS'],; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['PUREAM'],; ['FREEZE_CORE'],; # all others should have an associated module; ['SCF', 'SCF_TYPE'],; ",MatchSource.WIKI,psi4manual/1.2.1/proc_py.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/proc_py.html
https://psicode.org/psi4manual/1.2.1/programming-1.html:863,Deployability,update,updated,863,"﻿. Programming: Using the Core Libraries. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Programming: Using the Core Libraries¶. LibOptions: globals, locals, has_changed and all that; Declaring Options; What is has_changed ?; Reading Options in Module; Handling Options in Driver. Adding Methods to Driver; proc.py; Managed Methods. Linear Algebra in PSI4; How to call BLAS & LAPACK in PSI4; BLAS Wrappers; Important BLAS Routines; LAPACK Wrappers; Important Lapack Routines. How to use low-level BLAS/LAPACK with psi4.core.Matrix; How to name orbital bases (e.g., AO & SO); How to name orbital dimensions; How to name orbital spaces (e.g., docc); Multireference Dimensions. Adding Test Cases. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/programming-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/programming-1.html
https://psicode.org/psi4manual/1.2.1/programming.html:863,Deployability,update,updated,863,"﻿. Programming: Using the Core Libraries. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Programming: Using the Core Libraries¶. LibOptions: globals, locals, has_changed and all that; Declaring Options; What is has_changed ?; Reading Options in Module; Handling Options in Driver. Adding Methods to Driver; proc.py; Managed Methods. Linear Algebra in PSI4; How to call BLAS & LAPACK in PSI4; BLAS Wrappers; Important BLAS Routines; LAPACK Wrappers; Important Lapack Routines. How to use low-level BLAS/LAPACK with psi4.core.Matrix; How to name orbital bases (e.g., AO & SO); How to name orbital dimensions; How to name orbital spaces (e.g., docc); Multireference Dimensions. Adding Test Cases. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/programming.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/programming.html
https://psicode.org/psi4manual/1.2.1/prog_blas-1.html:4801,Availability,recover,recovery,4801,"ubstitution (just as fast as DTRMV); DGER: Rank-1 update (not wrapped yet). BLAS3; DGEMM: General Matrix-Matrix product; DTRMM: General Triangular Matrix-General Matrix product; DTRSM: Triangular Matrix-General Matrix solution via back substitution (just as fast as DTRMM); DSYMM/DSYMV calls are not appreciably faster than DGEMM calls, and should only be used in expert situations (like using the other half of the matrix for some form of other transformation).; DTRMM/DTRMV calls are 2x faster than DGEMM, and should be used where possible. LAPACK Wrappers¶; All standard LAPACK 3.2 double precision routines are provided.; LAPACK commands remain in Fortran’s “column-major” indexing, so all the; results will be transposed, and leading dimensions may have to be fiddled; with (using lda = n in both directions for square matrices is highly; recommended). An example of the former problem is a Cholesky; Decomposition: you expect to get back a lower triangular matrix L such; that L L^T = A, but this is returned in column-major order, so the actual; recovery of the matrix A with the row-major BLAS wrappers effectively; involves L^T L = A. On of the biggest consequences is in linear equations:; The input/output forcing/solution vector must be explicitly formed in; column-major indexing (each vector is placed in a C++ row, with its; entries along the C++ column). This is visualized in C++ as the transpose; of the forcing/solution vector. All routines are declared in qt.h. Each; routine is prefixed with a C_, followed by the standard Fortran name of; the routine, in capital letters. Input parameters of single primitives; (int, double, unsigned long int, char, …) are passed by value. Arrays,; including multidimensional arrays, are required to be in contiguous memory; (as provided by block_matrix, for example), and are passed by providing a; pointer to the first double or int element of the data (this is array[0]; if array is double**). All routines return an int INFO with error and;",MatchSource.WIKI,psi4manual/1.2.1/prog_blas-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_blas-1.html
https://psicode.org/psi4manual/1.2.1/prog_blas-1.html:5738,Availability,error,error,5738,"covery of the matrix A with the row-major BLAS wrappers effectively; involves L^T L = A. On of the biggest consequences is in linear equations:; The input/output forcing/solution vector must be explicitly formed in; column-major indexing (each vector is placed in a C++ row, with its; entries along the C++ column). This is visualized in C++ as the transpose; of the forcing/solution vector. All routines are declared in qt.h. Each; routine is prefixed with a C_, followed by the standard Fortran name of; the routine, in capital letters. Input parameters of single primitives; (int, double, unsigned long int, char, …) are passed by value. Arrays,; including multidimensional arrays, are required to be in contiguous memory; (as provided by block_matrix, for example), and are passed by providing a; pointer to the first double or int element of the data (this is array[0]; if array is double**). All routines return an int INFO with error and; calculation information specific to the routine, In Fortran, this is the; last argument in all LAPACK calls, but should not be provided as an; argument here. For char arguments, case is insensitive. A Cholesky; transform example is shown:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33// BLAS/LAPACK; #include ""psi4/libqt/qt.h""; // block_matrix, init_array; #include ""psi4/libciomr/libciomr.h"". using namespace psi;; ...; int n = 100;. // Allocate A matrix;; double** A = block_matrix(n,n);. // Call the LAPACK DPOTRF to get the Cholesky factor; // Note this works in column-major order; // The result fills like:; // * * * *; // * * *; // * *; // *; // instead of the expected:; // *; // * *; // * * *; // * * * *; //; int info = C_DPOTRF('L', n, A[0], n);. // A bit painful, see below; fprintf(outfile, ""A:\n"");; print_mat(A,n,n,outfile);. // Block matrix should be free_blocked; free_block(A);. Important Lapack Routines¶. DSYEV: Eigenvalues and, optionally eigenvectors of a",MatchSource.WIKI,psi4manual/1.2.1/prog_blas-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_blas-1.html
https://psicode.org/psi4manual/1.2.1/prog_blas-1.html:8210,Availability,error,errors,8210,"lver, given LU decomposition by DGETRF; DPOTRS: Solver, given Cholesky decomposition by DPOTRF; DGETRI: Inverse, given LU decomposition by DGETRF (Warning: it’s faster and more stable just to solve with DGETRS); DPOTRI: Inverse, given Cholesky decomposition by DPOTRF (Warning: it’s faster and more stable just to solve with DPOTRS). How to use low-level BLAS/LAPACK with psi4.core.Matrix¶; Jet’s awesome new Matrix object has a lot of simple BLAS/LAPACK built in,; but you can just as easily use the double*** array underneath if you are; careful (the outer index is the submatrix for each irrep). Here’s an; example:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33// BLAS/LAPACK; #include ""psi4/libqt/qt.h""; // Matrix; #include ""psi4/libmints/matrix.h"". using namespace psi;; ...; int n = 100;. // Allocate A Matrix (new C1 convenience constructor);; shared_ptr<Matrix> A(new Matrix(""Still A, but way cooler"", n,n));; // Get the pointer to the 0 irrep (C1 for now, it errors if you ask for too high of an index); double** A_pointer = A->get_pointer(0);. // Call the LAPACK DPOTRF to get the Cholesky factor; // Note this works in column-major order; // The result fills like:; // * * * *; // * * *; // * *; // *; // instead of the expected:; // *; // * *; // * * *; // * * * *; //; int info = C_DPOTRF('L', n, A_pointer[0], n);. // Wow that's a lot easier; A->print();. // Don't free, it's shared_ptr!. How to name orbital bases (e.g., AO & SO)¶; Many different working bases (the internal linear algebraic basis, not the; name of the Gaussian basis) are used within PSI4, each with a unique; and important purpose. It is critical to keep them all distinct to prevent; weird results from occurring. AO (Atomic Orbitals): Cartesian Gaussians (6D, 10F, etc.),; (L + 1)(L + 2)/2 functions per shell of angular momentum L. The; ordering of Cartesian exponents for a given L is given by the standard; ordering below (MATLAB code)",MatchSource.WIKI,psi4manual/1.2.1/prog_blas-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_blas-1.html
https://psicode.org/psi4manual/1.2.1/prog_blas-1.html:11822,Availability,redundant,redundant,11822,"ext specific. OSO (Orthogonal Symmetry-Adapted Orbitals): USOs orthogonalized by; Symmetric or Canonical Orthogonalization. The number of OSOs may be; slightly smaller than the total number of USOs, due to removal of linear; dependencies via Canonical Orthogonalization. The OSOs are rarely; encountered, as usually we go straight from USOs to MOs. MO (Molecular Orbitals): The combination of OSOs that diagonalizes; the Fock Matrix, so each basis function is a Hartree-Fock (or Kohn-Sham); molecular orbital. The number of OSOs and MOs is always the same. MOs are; orthonormal. LO (Localized Orbitals): Localized occupied orbitals, a different; combination of the occupied molecular orbitals which enhances spatial; locality. LOs do not diagonalize the occ-occ block of the Fock Matrix, but; remain orthonormal to each other and the virtual space. How to name orbital dimensions¶; There are a number of different names used to refer to the basis set size.; These may seem redundant, but they have subtly different meanings, as; detailed below.; A calculation can use either pure (5D, 7F, 9G, etc.) basis functions or; Cartesian (6D, 10F, 15G, etc.), as dictated by the input file / basis set; specification. Also, the basis can be represented in terms of atomic; orbitals (AO) or symmetry-adapted orbitals (SO). Further complications; come from the fact that a nearly linearly-dependent basis set will have; functions removed from it to prevent redundancies. With all of these; factors in mind, here are the conventions used internally:. nao — The number of atomic orbitals in Cartesian representation.; nso — The number of atomic orbitals but in the pure representation if the current basis uses pure functions, number of Cartesian AOs otherwise.; nbf — The number of basis functions, which is the same as nso.; nmo — The number of basis functions, after projecting out redundancies in the basis. When molecular symmetry is utilized, a small array of sizes per irrep is; usually allocated on the st",MatchSource.WIKI,psi4manual/1.2.1/prog_blas-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_blas-1.html
https://psicode.org/psi4manual/1.2.1/prog_blas-1.html:500,Deployability,update,update,500,"﻿. Linear Algebra in PSI4. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Programming: Using the Core Libraries. Linear Algebra in PSI4¶. How to call BLAS & LAPACK in PSI4¶; Computational chemistry is essentially linear algebra on molecular; systems, so using stable, portable, scalable, and efficient numerical; linear algebra methods in PSI4 is critical. To that end, we use BLAS1; (vector-vector operations, like dot products), BLAS2 (matrix-vector; operations, like rank-1 update), BLAS3 (matrix-matrix operations, like; matrix multiplication), and LAPACK (advanced matrix decompositions and; solutions). The methods provided by BLAS and LAPACK are standard, but the; performance of actual implementations differ greatly from one version to; another. Moreover, the standard interfaces to the libraries are Fortran,; so PSI4 provides a common set of wrappers in psi4/psi4/src/psi4/libqt/qt.h . Warning; Although block_matrix, init_array, and print_mat are still; around, their use is discouraged in favor of operations on; psi4.core.Matrix itself. The advice in these docs will catch up; shortly. BLAS Wrappers¶; BLAS wrappers are currently fully supported at double precision.; BLAS commands involving matrices are wrapped so as to be conventional; C-style “row-major” indexing, meaning that the column is the fast index; like normal. The calls to BLAS1 routines are wrapped so as to allow for operations on; vectors with more than 2^{31} elements (~16 GB, getting to be a problem).; So passing a signed or unsigned long works, though the stride arguments; must be integers. All routines are declared in qt.h. Each routine is prefixed with a; C_, followed by the standard Fortran name of the routine, in capital; letters. Input parameters of single primitives (int, double,; unsigned long int, char, …) are passed by value. Arrays,; including multidimensional arrays, are required to be in contiguous; memory (as provided by block_matrix, for example), and are passed by; pr",MatchSource.WIKI,psi4manual/1.2.1/prog_blas-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_blas-1.html
https://psicode.org/psi4manual/1.2.1/prog_blas-1.html:3798,Deployability,update,update,3798,"ix(n,n);; double** B = block_matrix(n,n);; double** C = block_matrix(n,n);. // Call the BLAS1 dot product between a and b; // n can be a ULI with the BLAS1 wrappers,; // All strides must be ints though; double dot = C_DDOT(n, a, 1, b, 1);. // Call the BLAS2 GEMV without transposition; // Note this works in row-major order; C_DGEMV('N', n, n, 1.0, A[0], n, a, 1, 0.0, b, 1);. // Call the BLAS3 GEMM without transposition; // Note this works in row-major order; C_DGEMM('N','N', n, n, n, 1.0, A[0], n, B[0], n, 0.0, C[0], n);. // Array's init'd with init_array must be free'd, not delete[]'d; free(a);; free(b);. // Block matrix should be free_blocked; free_block(A);; free_block(B);; free_block(C);. Important BLAS Routines¶. BLAS1; DDOT: dot product; DCOPY: efficient memory copy (with variable stride); DAXPY: y = y + alpha*x; DROT: Givens Rotation; DNRM2: Vector norm square. BLAS2; DGEMV: General Matrix-Vector product; DTRMV: Triangular Matrix-Vector product (2x faster, not wrapped yet); DTRSM: Triangular Matrix-Vector solution via back substitution (just as fast as DTRMV); DGER: Rank-1 update (not wrapped yet). BLAS3; DGEMM: General Matrix-Matrix product; DTRMM: General Triangular Matrix-General Matrix product; DTRSM: Triangular Matrix-General Matrix solution via back substitution (just as fast as DTRMM); DSYMM/DSYMV calls are not appreciably faster than DGEMM calls, and should only be used in expert situations (like using the other half of the matrix for some form of other transformation).; DTRMM/DTRMV calls are 2x faster than DGEMM, and should be used where possible. LAPACK Wrappers¶; All standard LAPACK 3.2 double precision routines are provided.; LAPACK commands remain in Fortran’s “column-major” indexing, so all the; results will be transposed, and leading dimensions may have to be fiddled; with (using lda = n in both directions for square matrices is highly; recommended). An example of the former problem is a Cholesky; Decomposition: you expect to get back a lower tr",MatchSource.WIKI,psi4manual/1.2.1/prog_blas-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_blas-1.html
https://psicode.org/psi4manual/1.2.1/prog_blas-1.html:15666,Deployability,update,updated,15666,"ference Dimensions¶; A orbital diagram of the nomenclature used for CI and MCSCF calculations.; Diagrammatically:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15-----------------------------------------------; CI | RAS | CAS; -----------------------------------------------; | frozen_uocc | frozen_uocc; dropped_uocc | rstr_uocc | rstr_uocc; -----------------------------------------------; | RAS IV |; | RAS III |; active | | active; | RAS II |; | RAS I |; -----------------------------------------------; dropped_docc | rstr_docc | rstr_docc; | frozen_docc | frozen_dcc; -----------------------------------------------. Notation:. uocc — Unoccupied orbitals.; active — Variable occupation orbitals.; socc — Singly occupied orbitals.; docc — Doubly occupied orbitals. Orbital spaces:. frozen_uocc — Absolutely frozen virtual orbital.; rstr_uocc — Can have rotations, no excitations into.; dropped_uocc — rstr_uocc + frozen_uocc. —– end CI active —–. RAS IV — uocc, limited number of excitations into.; RAS III — uocc, limited number of excitations into.; RAS II — docc/socc/uocc, equivalent to active in CAS.; RAS I — docc/socc/uocc, limited excitations out of. —– start CI active —–. dropped_docc — rstr_docc + frozen_docc; rstr_docc — Can have rotations, no excitations from.; frozen_docc — Absolutely frozen core orbital. Orbitals are sorted by space, irrep, eigenvalue. table of contents. Linear Algebra in PSI4; How to call BLAS & LAPACK in PSI4; BLAS Wrappers; Important BLAS Routines; LAPACK Wrappers; Important Lapack Routines. How to use low-level BLAS/LAPACK with psi4.core.Matrix; How to name orbital bases (e.g., AO & SO); How to name orbital dimensions; How to name orbital spaces (e.g., docc); Multireference Dimensions. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Programming: Using the Core Libraries. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/prog_blas-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_blas-1.html
https://psicode.org/psi4manual/1.2.1/prog_blas-1.html:315,Energy Efficiency,efficient,efficient,315,"﻿. Linear Algebra in PSI4. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Programming: Using the Core Libraries. Linear Algebra in PSI4¶. How to call BLAS & LAPACK in PSI4¶; Computational chemistry is essentially linear algebra on molecular; systems, so using stable, portable, scalable, and efficient numerical; linear algebra methods in PSI4 is critical. To that end, we use BLAS1; (vector-vector operations, like dot products), BLAS2 (matrix-vector; operations, like rank-1 update), BLAS3 (matrix-matrix operations, like; matrix multiplication), and LAPACK (advanced matrix decompositions and; solutions). The methods provided by BLAS and LAPACK are standard, but the; performance of actual implementations differ greatly from one version to; another. Moreover, the standard interfaces to the libraries are Fortran,; so PSI4 provides a common set of wrappers in psi4/psi4/src/psi4/libqt/qt.h . Warning; Although block_matrix, init_array, and print_mat are still; around, their use is discouraged in favor of operations on; psi4.core.Matrix itself. The advice in these docs will catch up; shortly. BLAS Wrappers¶; BLAS wrappers are currently fully supported at double precision.; BLAS commands involving matrices are wrapped so as to be conventional; C-style “row-major” indexing, meaning that the column is the fast index; like normal. The calls to BLAS1 routines are wrapped so as to allow for operations on; vectors with more than 2^{31} elements (~16 GB, getting to be a problem).; So passing a signed or unsigned long works, though the stride arguments; must be integers. All routines are declared in qt.h. Each routine is prefixed with a; C_, followed by the standard Fortran name of the routine, in capital; letters. Input parameters of single primitives (int, double,; unsigned long int, char, …) are passed by value. Arrays,; including multidimensional arrays, are required to be in contiguous; memory (as provided by block_matrix, for example), and are passed by; pr",MatchSource.WIKI,psi4manual/1.2.1/prog_blas-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_blas-1.html
https://psicode.org/psi4manual/1.2.1/prog_blas-1.html:3462,Energy Efficiency,efficient,efficient,3462,"de ""psi4/libciomr/libciomr.h"". using namespace psi;; ... // Allocate a,b vectors; int n = 100;; double* a = init_array(n);; double* b = init_array(n);. // Allocate A matrix;; double** A = block_matrix(n,n);; double** B = block_matrix(n,n);; double** C = block_matrix(n,n);. // Call the BLAS1 dot product between a and b; // n can be a ULI with the BLAS1 wrappers,; // All strides must be ints though; double dot = C_DDOT(n, a, 1, b, 1);. // Call the BLAS2 GEMV without transposition; // Note this works in row-major order; C_DGEMV('N', n, n, 1.0, A[0], n, a, 1, 0.0, b, 1);. // Call the BLAS3 GEMM without transposition; // Note this works in row-major order; C_DGEMM('N','N', n, n, n, 1.0, A[0], n, B[0], n, 0.0, C[0], n);. // Array's init'd with init_array must be free'd, not delete[]'d; free(a);; free(b);. // Block matrix should be free_blocked; free_block(A);; free_block(B);; free_block(C);. Important BLAS Routines¶. BLAS1; DDOT: dot product; DCOPY: efficient memory copy (with variable stride); DAXPY: y = y + alpha*x; DROT: Givens Rotation; DNRM2: Vector norm square. BLAS2; DGEMV: General Matrix-Vector product; DTRMV: Triangular Matrix-Vector product (2x faster, not wrapped yet); DTRSM: Triangular Matrix-Vector solution via back substitution (just as fast as DTRMV); DGER: Rank-1 update (not wrapped yet). BLAS3; DGEMM: General Matrix-Matrix product; DTRMM: General Triangular Matrix-General Matrix product; DTRSM: Triangular Matrix-General Matrix solution via back substitution (just as fast as DTRMM); DSYMM/DSYMV calls are not appreciably faster than DGEMM calls, and should only be used in expert situations (like using the other half of the matrix for some form of other transformation).; DTRMM/DTRMV calls are 2x faster than DGEMM, and should be used where possible. LAPACK Wrappers¶; All standard LAPACK 3.2 double precision routines are provided.; LAPACK commands remain in Fortran’s “column-major” indexing, so all the; results will be transposed, and leading dimensions may hav",MatchSource.WIKI,psi4manual/1.2.1/prog_blas-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_blas-1.html
https://psicode.org/psi4manual/1.2.1/prog_blas-1.html:10511,Energy Efficiency,adapt,adapted,10511,"is is typically the; first layer encountered, Libmints handles the transform from AO to SO; automatically. If Cartesian functions are used, the number of functions; per shell remains (L + 1)(L + 2)/2, and the ordering remains the same; as above. Note that the individual functions are not normalized for; angular momentum as in most codes: the self-overlap of a PSI4 Cartesian D; or higher function with more than one nonzero Cartesian exponent (e.g., lx; = 1, ly = 1, lz = 0) will be less than one. If Spherical Harmonics are; used, 2L + 1 real combinations of the spherical harmonics are built from; the (L+1)(L+2)/2 Cartesian Gaussians, according to H. Schlegel and M.; Frish, IJQC, 54, 83-87, 1995. Unlike Cartesian functions these functions; are all strictly normalized. Note that in PSI4, the real combinations of; spherical harmonic functions (see the paragraph below Eq. 15 in the; Schlegel paper) are ordered as: 0, 1+, 1-, 2+, 2-, …. USO (Unique Symmetry-Adapted Orbitals): Spatial symmetry-adapted; combinations of SOs, blocked according to irrep. The total number of USOs; is the same as the number of SOs, but the number of USOs within each irrep; is usually much smaller, which can lead to significant performance; improvements. Note that this basis is sometimes unfortunately referred to; as the SO basis, so it’s a bit context specific. OSO (Orthogonal Symmetry-Adapted Orbitals): USOs orthogonalized by; Symmetric or Canonical Orthogonalization. The number of OSOs may be; slightly smaller than the total number of USOs, due to removal of linear; dependencies via Canonical Orthogonalization. The OSOs are rarely; encountered, as usually we go straight from USOs to MOs. MO (Molecular Orbitals): The combination of OSOs that diagonalizes; the Fock Matrix, so each basis function is a Hartree-Fock (or Kohn-Sham); molecular orbital. The number of OSOs and MOs is always the same. MOs are; orthonormal. LO (Localized Orbitals): Localized occupied orbitals, a different; combination of t",MatchSource.WIKI,psi4manual/1.2.1/prog_blas-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_blas-1.html
https://psicode.org/psi4manual/1.2.1/prog_blas-1.html:12139,Energy Efficiency,adapt,adapted,12139,"alization. The OSOs are rarely; encountered, as usually we go straight from USOs to MOs. MO (Molecular Orbitals): The combination of OSOs that diagonalizes; the Fock Matrix, so each basis function is a Hartree-Fock (or Kohn-Sham); molecular orbital. The number of OSOs and MOs is always the same. MOs are; orthonormal. LO (Localized Orbitals): Localized occupied orbitals, a different; combination of the occupied molecular orbitals which enhances spatial; locality. LOs do not diagonalize the occ-occ block of the Fock Matrix, but; remain orthonormal to each other and the virtual space. How to name orbital dimensions¶; There are a number of different names used to refer to the basis set size.; These may seem redundant, but they have subtly different meanings, as; detailed below.; A calculation can use either pure (5D, 7F, 9G, etc.) basis functions or; Cartesian (6D, 10F, 15G, etc.), as dictated by the input file / basis set; specification. Also, the basis can be represented in terms of atomic; orbitals (AO) or symmetry-adapted orbitals (SO). Further complications; come from the fact that a nearly linearly-dependent basis set will have; functions removed from it to prevent redundancies. With all of these; factors in mind, here are the conventions used internally:. nao — The number of atomic orbitals in Cartesian representation.; nso — The number of atomic orbitals but in the pure representation if the current basis uses pure functions, number of Cartesian AOs otherwise.; nbf — The number of basis functions, which is the same as nso.; nmo — The number of basis functions, after projecting out redundancies in the basis. When molecular symmetry is utilized, a small array of sizes per irrep is; usually allocated on the stack, and is named by augmenting the name above; with a pi (per-irrep), e.g. nmopi. Note that the number of irreps is; always the singular nirrep, and that the index variable h is always used; in a for-loop traverse of irreps. How to name orbital spaces (e.g., ",MatchSource.WIKI,psi4manual/1.2.1/prog_blas-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_blas-1.html
https://psicode.org/psi4manual/1.2.1/prog_blas-1.html:12830,Energy Efficiency,allocate,allocated,12830,"ut they have subtly different meanings, as; detailed below.; A calculation can use either pure (5D, 7F, 9G, etc.) basis functions or; Cartesian (6D, 10F, 15G, etc.), as dictated by the input file / basis set; specification. Also, the basis can be represented in terms of atomic; orbitals (AO) or symmetry-adapted orbitals (SO). Further complications; come from the fact that a nearly linearly-dependent basis set will have; functions removed from it to prevent redundancies. With all of these; factors in mind, here are the conventions used internally:. nao — The number of atomic orbitals in Cartesian representation.; nso — The number of atomic orbitals but in the pure representation if the current basis uses pure functions, number of Cartesian AOs otherwise.; nbf — The number of basis functions, which is the same as nso.; nmo — The number of basis functions, after projecting out redundancies in the basis. When molecular symmetry is utilized, a small array of sizes per irrep is; usually allocated on the stack, and is named by augmenting the name above; with a pi (per-irrep), e.g. nmopi. Note that the number of irreps is; always the singular nirrep, and that the index variable h is always used; in a for-loop traverse of irreps. How to name orbital spaces (e.g., docc)¶; As with basis sets, a number of names are used to refer to refer to the; quantity of electrons, virtuals, and active sub-quantities of a PSI4; calculation. All of these can be defined per irrep as above. Some common; conventions are:. nelec — The number of electrons, rarely used due to specialization of alphas and betas or soccs and doccs.; nalpha — The number of alpha electrons.; nbeta — The number of beta electrons; docc — The number of doubly-occupied orbitals; socc — The number of singly-occupied orbitals (Almost always alpha, we don’t like open-shell singlets much).; nvir — The number of virtual orbitals. Multireference Dimensions¶; A orbital diagram of the nomenclature used for CI and MCSCF calculations",MatchSource.WIKI,psi4manual/1.2.1/prog_blas-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_blas-1.html
https://psicode.org/psi4manual/1.2.1/prog_blas-1.html:801,Integrability,interface,interfaces,801,"﻿. Linear Algebra in PSI4. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Programming: Using the Core Libraries. Linear Algebra in PSI4¶. How to call BLAS & LAPACK in PSI4¶; Computational chemistry is essentially linear algebra on molecular; systems, so using stable, portable, scalable, and efficient numerical; linear algebra methods in PSI4 is critical. To that end, we use BLAS1; (vector-vector operations, like dot products), BLAS2 (matrix-vector; operations, like rank-1 update), BLAS3 (matrix-matrix operations, like; matrix multiplication), and LAPACK (advanced matrix decompositions and; solutions). The methods provided by BLAS and LAPACK are standard, but the; performance of actual implementations differ greatly from one version to; another. Moreover, the standard interfaces to the libraries are Fortran,; so PSI4 provides a common set of wrappers in psi4/psi4/src/psi4/libqt/qt.h . Warning; Although block_matrix, init_array, and print_mat are still; around, their use is discouraged in favor of operations on; psi4.core.Matrix itself. The advice in these docs will catch up; shortly. BLAS Wrappers¶; BLAS wrappers are currently fully supported at double precision.; BLAS commands involving matrices are wrapped so as to be conventional; C-style “row-major” indexing, meaning that the column is the fast index; like normal. The calls to BLAS1 routines are wrapped so as to allow for operations on; vectors with more than 2^{31} elements (~16 GB, getting to be a problem).; So passing a signed or unsigned long works, though the stride arguments; must be integers. All routines are declared in qt.h. Each routine is prefixed with a; C_, followed by the standard Fortran name of the routine, in capital; letters. Input parameters of single primitives (int, double,; unsigned long int, char, …) are passed by value. Arrays,; including multidimensional arrays, are required to be in contiguous; memory (as provided by block_matrix, for example), and are passed by; pr",MatchSource.WIKI,psi4manual/1.2.1/prog_blas-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_blas-1.html
https://psicode.org/psi4manual/1.2.1/prog_blas-1.html:876,Integrability,wrap,wrappers,876,"﻿. Linear Algebra in PSI4. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Programming: Using the Core Libraries. Linear Algebra in PSI4¶. How to call BLAS & LAPACK in PSI4¶; Computational chemistry is essentially linear algebra on molecular; systems, so using stable, portable, scalable, and efficient numerical; linear algebra methods in PSI4 is critical. To that end, we use BLAS1; (vector-vector operations, like dot products), BLAS2 (matrix-vector; operations, like rank-1 update), BLAS3 (matrix-matrix operations, like; matrix multiplication), and LAPACK (advanced matrix decompositions and; solutions). The methods provided by BLAS and LAPACK are standard, but the; performance of actual implementations differ greatly from one version to; another. Moreover, the standard interfaces to the libraries are Fortran,; so PSI4 provides a common set of wrappers in psi4/psi4/src/psi4/libqt/qt.h . Warning; Although block_matrix, init_array, and print_mat are still; around, their use is discouraged in favor of operations on; psi4.core.Matrix itself. The advice in these docs will catch up; shortly. BLAS Wrappers¶; BLAS wrappers are currently fully supported at double precision.; BLAS commands involving matrices are wrapped so as to be conventional; C-style “row-major” indexing, meaning that the column is the fast index; like normal. The calls to BLAS1 routines are wrapped so as to allow for operations on; vectors with more than 2^{31} elements (~16 GB, getting to be a problem).; So passing a signed or unsigned long works, though the stride arguments; must be integers. All routines are declared in qt.h. Each routine is prefixed with a; C_, followed by the standard Fortran name of the routine, in capital; letters. Input parameters of single primitives (int, double,; unsigned long int, char, …) are passed by value. Arrays,; including multidimensional arrays, are required to be in contiguous; memory (as provided by block_matrix, for example), and are passed by; pr",MatchSource.WIKI,psi4manual/1.2.1/prog_blas-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_blas-1.html
https://psicode.org/psi4manual/1.2.1/prog_blas-1.html:1144,Integrability,wrap,wrappers,1144,"ow to call BLAS & LAPACK in PSI4¶; Computational chemistry is essentially linear algebra on molecular; systems, so using stable, portable, scalable, and efficient numerical; linear algebra methods in PSI4 is critical. To that end, we use BLAS1; (vector-vector operations, like dot products), BLAS2 (matrix-vector; operations, like rank-1 update), BLAS3 (matrix-matrix operations, like; matrix multiplication), and LAPACK (advanced matrix decompositions and; solutions). The methods provided by BLAS and LAPACK are standard, but the; performance of actual implementations differ greatly from one version to; another. Moreover, the standard interfaces to the libraries are Fortran,; so PSI4 provides a common set of wrappers in psi4/psi4/src/psi4/libqt/qt.h . Warning; Although block_matrix, init_array, and print_mat are still; around, their use is discouraged in favor of operations on; psi4.core.Matrix itself. The advice in these docs will catch up; shortly. BLAS Wrappers¶; BLAS wrappers are currently fully supported at double precision.; BLAS commands involving matrices are wrapped so as to be conventional; C-style “row-major” indexing, meaning that the column is the fast index; like normal. The calls to BLAS1 routines are wrapped so as to allow for operations on; vectors with more than 2^{31} elements (~16 GB, getting to be a problem).; So passing a signed or unsigned long works, though the stride arguments; must be integers. All routines are declared in qt.h. Each routine is prefixed with a; C_, followed by the standard Fortran name of the routine, in capital; letters. Input parameters of single primitives (int, double,; unsigned long int, char, …) are passed by value. Arrays,; including multidimensional arrays, are required to be in contiguous; memory (as provided by block_matrix, for example), and are passed by; providing a pointer to the first double or int element of the data (this; is array[0] if array is double**). BLAS1 routines occasionally; return values (DDOT for in",MatchSource.WIKI,psi4manual/1.2.1/prog_blas-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_blas-1.html
https://psicode.org/psi4manual/1.2.1/prog_blas-1.html:1242,Integrability,wrap,wrapped,1242," stable, portable, scalable, and efficient numerical; linear algebra methods in PSI4 is critical. To that end, we use BLAS1; (vector-vector operations, like dot products), BLAS2 (matrix-vector; operations, like rank-1 update), BLAS3 (matrix-matrix operations, like; matrix multiplication), and LAPACK (advanced matrix decompositions and; solutions). The methods provided by BLAS and LAPACK are standard, but the; performance of actual implementations differ greatly from one version to; another. Moreover, the standard interfaces to the libraries are Fortran,; so PSI4 provides a common set of wrappers in psi4/psi4/src/psi4/libqt/qt.h . Warning; Although block_matrix, init_array, and print_mat are still; around, their use is discouraged in favor of operations on; psi4.core.Matrix itself. The advice in these docs will catch up; shortly. BLAS Wrappers¶; BLAS wrappers are currently fully supported at double precision.; BLAS commands involving matrices are wrapped so as to be conventional; C-style “row-major” indexing, meaning that the column is the fast index; like normal. The calls to BLAS1 routines are wrapped so as to allow for operations on; vectors with more than 2^{31} elements (~16 GB, getting to be a problem).; So passing a signed or unsigned long works, though the stride arguments; must be integers. All routines are declared in qt.h. Each routine is prefixed with a; C_, followed by the standard Fortran name of the routine, in capital; letters. Input parameters of single primitives (int, double,; unsigned long int, char, …) are passed by value. Arrays,; including multidimensional arrays, are required to be in contiguous; memory (as provided by block_matrix, for example), and are passed by; providing a pointer to the first double or int element of the data (this; is array[0] if array is double**). BLAS1 routines occasionally; return values (DDOT for instance), BLAS2 and BLAS3 always return void.; For char arguments, case is insensitive. A few examples are provided:; 1;",MatchSource.WIKI,psi4manual/1.2.1/prog_blas-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_blas-1.html
https://psicode.org/psi4manual/1.2.1/prog_blas-1.html:1381,Integrability,rout,routines,1381,"ike dot products), BLAS2 (matrix-vector; operations, like rank-1 update), BLAS3 (matrix-matrix operations, like; matrix multiplication), and LAPACK (advanced matrix decompositions and; solutions). The methods provided by BLAS and LAPACK are standard, but the; performance of actual implementations differ greatly from one version to; another. Moreover, the standard interfaces to the libraries are Fortran,; so PSI4 provides a common set of wrappers in psi4/psi4/src/psi4/libqt/qt.h . Warning; Although block_matrix, init_array, and print_mat are still; around, their use is discouraged in favor of operations on; psi4.core.Matrix itself. The advice in these docs will catch up; shortly. BLAS Wrappers¶; BLAS wrappers are currently fully supported at double precision.; BLAS commands involving matrices are wrapped so as to be conventional; C-style “row-major” indexing, meaning that the column is the fast index; like normal. The calls to BLAS1 routines are wrapped so as to allow for operations on; vectors with more than 2^{31} elements (~16 GB, getting to be a problem).; So passing a signed or unsigned long works, though the stride arguments; must be integers. All routines are declared in qt.h. Each routine is prefixed with a; C_, followed by the standard Fortran name of the routine, in capital; letters. Input parameters of single primitives (int, double,; unsigned long int, char, …) are passed by value. Arrays,; including multidimensional arrays, are required to be in contiguous; memory (as provided by block_matrix, for example), and are passed by; providing a pointer to the first double or int element of the data (this; is array[0] if array is double**). BLAS1 routines occasionally; return values (DDOT for instance), BLAS2 and BLAS3 always return void.; For char arguments, case is insensitive. A few examples are provided:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35; 36; 37; 38; 39// BLAS/LA",MatchSource.WIKI,psi4manual/1.2.1/prog_blas-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_blas-1.html
https://psicode.org/psi4manual/1.2.1/prog_blas-1.html:1394,Integrability,wrap,wrapped,1394,"ike dot products), BLAS2 (matrix-vector; operations, like rank-1 update), BLAS3 (matrix-matrix operations, like; matrix multiplication), and LAPACK (advanced matrix decompositions and; solutions). The methods provided by BLAS and LAPACK are standard, but the; performance of actual implementations differ greatly from one version to; another. Moreover, the standard interfaces to the libraries are Fortran,; so PSI4 provides a common set of wrappers in psi4/psi4/src/psi4/libqt/qt.h . Warning; Although block_matrix, init_array, and print_mat are still; around, their use is discouraged in favor of operations on; psi4.core.Matrix itself. The advice in these docs will catch up; shortly. BLAS Wrappers¶; BLAS wrappers are currently fully supported at double precision.; BLAS commands involving matrices are wrapped so as to be conventional; C-style “row-major” indexing, meaning that the column is the fast index; like normal. The calls to BLAS1 routines are wrapped so as to allow for operations on; vectors with more than 2^{31} elements (~16 GB, getting to be a problem).; So passing a signed or unsigned long works, though the stride arguments; must be integers. All routines are declared in qt.h. Each routine is prefixed with a; C_, followed by the standard Fortran name of the routine, in capital; letters. Input parameters of single primitives (int, double,; unsigned long int, char, …) are passed by value. Arrays,; including multidimensional arrays, are required to be in contiguous; memory (as provided by block_matrix, for example), and are passed by; providing a pointer to the first double or int element of the data (this; is array[0] if array is double**). BLAS1 routines occasionally; return values (DDOT for instance), BLAS2 and BLAS3 always return void.; For char arguments, case is insensitive. A few examples are provided:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35; 36; 37; 38; 39// BLAS/LA",MatchSource.WIKI,psi4manual/1.2.1/prog_blas-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_blas-1.html
https://psicode.org/psi4manual/1.2.1/prog_blas-1.html:1606,Integrability,rout,routines,1606,"d; solutions). The methods provided by BLAS and LAPACK are standard, but the; performance of actual implementations differ greatly from one version to; another. Moreover, the standard interfaces to the libraries are Fortran,; so PSI4 provides a common set of wrappers in psi4/psi4/src/psi4/libqt/qt.h . Warning; Although block_matrix, init_array, and print_mat are still; around, their use is discouraged in favor of operations on; psi4.core.Matrix itself. The advice in these docs will catch up; shortly. BLAS Wrappers¶; BLAS wrappers are currently fully supported at double precision.; BLAS commands involving matrices are wrapped so as to be conventional; C-style “row-major” indexing, meaning that the column is the fast index; like normal. The calls to BLAS1 routines are wrapped so as to allow for operations on; vectors with more than 2^{31} elements (~16 GB, getting to be a problem).; So passing a signed or unsigned long works, though the stride arguments; must be integers. All routines are declared in qt.h. Each routine is prefixed with a; C_, followed by the standard Fortran name of the routine, in capital; letters. Input parameters of single primitives (int, double,; unsigned long int, char, …) are passed by value. Arrays,; including multidimensional arrays, are required to be in contiguous; memory (as provided by block_matrix, for example), and are passed by; providing a pointer to the first double or int element of the data (this; is array[0] if array is double**). BLAS1 routines occasionally; return values (DDOT for instance), BLAS2 and BLAS3 always return void.; For char arguments, case is insensitive. A few examples are provided:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35; 36; 37; 38; 39// BLAS/LAPACK; #include ""psi4/libqt/qt.h""; // block_matrix, init_array; #include ""psi4/libciomr/libciomr.h"". using namespace psi;; ... // Allocate a,b vectors; int n = 100;; double* a = init_a",MatchSource.WIKI,psi4manual/1.2.1/prog_blas-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_blas-1.html
https://psicode.org/psi4manual/1.2.1/prog_blas-1.html:1642,Integrability,rout,routine,1642,"e; performance of actual implementations differ greatly from one version to; another. Moreover, the standard interfaces to the libraries are Fortran,; so PSI4 provides a common set of wrappers in psi4/psi4/src/psi4/libqt/qt.h . Warning; Although block_matrix, init_array, and print_mat are still; around, their use is discouraged in favor of operations on; psi4.core.Matrix itself. The advice in these docs will catch up; shortly. BLAS Wrappers¶; BLAS wrappers are currently fully supported at double precision.; BLAS commands involving matrices are wrapped so as to be conventional; C-style “row-major” indexing, meaning that the column is the fast index; like normal. The calls to BLAS1 routines are wrapped so as to allow for operations on; vectors with more than 2^{31} elements (~16 GB, getting to be a problem).; So passing a signed or unsigned long works, though the stride arguments; must be integers. All routines are declared in qt.h. Each routine is prefixed with a; C_, followed by the standard Fortran name of the routine, in capital; letters. Input parameters of single primitives (int, double,; unsigned long int, char, …) are passed by value. Arrays,; including multidimensional arrays, are required to be in contiguous; memory (as provided by block_matrix, for example), and are passed by; providing a pointer to the first double or int element of the data (this; is array[0] if array is double**). BLAS1 routines occasionally; return values (DDOT for instance), BLAS2 and BLAS3 always return void.; For char arguments, case is insensitive. A few examples are provided:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35; 36; 37; 38; 39// BLAS/LAPACK; #include ""psi4/libqt/qt.h""; // block_matrix, init_array; #include ""psi4/libciomr/libciomr.h"". using namespace psi;; ... // Allocate a,b vectors; int n = 100;; double* a = init_array(n);; double* b = init_array(n);. // Allocate A matrix;; double** A = ",MatchSource.WIKI,psi4manual/1.2.1/prog_blas-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_blas-1.html
https://psicode.org/psi4manual/1.2.1/prog_blas-1.html:1719,Integrability,rout,routine,1719,"e; performance of actual implementations differ greatly from one version to; another. Moreover, the standard interfaces to the libraries are Fortran,; so PSI4 provides a common set of wrappers in psi4/psi4/src/psi4/libqt/qt.h . Warning; Although block_matrix, init_array, and print_mat are still; around, their use is discouraged in favor of operations on; psi4.core.Matrix itself. The advice in these docs will catch up; shortly. BLAS Wrappers¶; BLAS wrappers are currently fully supported at double precision.; BLAS commands involving matrices are wrapped so as to be conventional; C-style “row-major” indexing, meaning that the column is the fast index; like normal. The calls to BLAS1 routines are wrapped so as to allow for operations on; vectors with more than 2^{31} elements (~16 GB, getting to be a problem).; So passing a signed or unsigned long works, though the stride arguments; must be integers. All routines are declared in qt.h. Each routine is prefixed with a; C_, followed by the standard Fortran name of the routine, in capital; letters. Input parameters of single primitives (int, double,; unsigned long int, char, …) are passed by value. Arrays,; including multidimensional arrays, are required to be in contiguous; memory (as provided by block_matrix, for example), and are passed by; providing a pointer to the first double or int element of the data (this; is array[0] if array is double**). BLAS1 routines occasionally; return values (DDOT for instance), BLAS2 and BLAS3 always return void.; For char arguments, case is insensitive. A few examples are provided:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35; 36; 37; 38; 39// BLAS/LAPACK; #include ""psi4/libqt/qt.h""; // block_matrix, init_array; #include ""psi4/libciomr/libciomr.h"". using namespace psi;; ... // Allocate a,b vectors; int n = 100;; double* a = init_array(n);; double* b = init_array(n);. // Allocate A matrix;; double** A = ",MatchSource.WIKI,psi4manual/1.2.1/prog_blas-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_blas-1.html
https://psicode.org/psi4manual/1.2.1/prog_blas-1.html:2114,Integrability,rout,routines,2114,"currently fully supported at double precision.; BLAS commands involving matrices are wrapped so as to be conventional; C-style “row-major” indexing, meaning that the column is the fast index; like normal. The calls to BLAS1 routines are wrapped so as to allow for operations on; vectors with more than 2^{31} elements (~16 GB, getting to be a problem).; So passing a signed or unsigned long works, though the stride arguments; must be integers. All routines are declared in qt.h. Each routine is prefixed with a; C_, followed by the standard Fortran name of the routine, in capital; letters. Input parameters of single primitives (int, double,; unsigned long int, char, …) are passed by value. Arrays,; including multidimensional arrays, are required to be in contiguous; memory (as provided by block_matrix, for example), and are passed by; providing a pointer to the first double or int element of the data (this; is array[0] if array is double**). BLAS1 routines occasionally; return values (DDOT for instance), BLAS2 and BLAS3 always return void.; For char arguments, case is insensitive. A few examples are provided:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35; 36; 37; 38; 39// BLAS/LAPACK; #include ""psi4/libqt/qt.h""; // block_matrix, init_array; #include ""psi4/libciomr/libciomr.h"". using namespace psi;; ... // Allocate a,b vectors; int n = 100;; double* a = init_array(n);; double* b = init_array(n);. // Allocate A matrix;; double** A = block_matrix(n,n);; double** B = block_matrix(n,n);; double** C = block_matrix(n,n);. // Call the BLAS1 dot product between a and b; // n can be a ULI with the BLAS1 wrappers,; // All strides must be ints though; double dot = C_DDOT(n, a, 1, b, 1);. // Call the BLAS2 GEMV without transposition; // Note this works in row-major order; C_DGEMV('N', n, n, 1.0, A[0], n, a, 1, 0.0, b, 1);. // Call the BLAS3 GEMM without transposition; // Note this works in row-major ",MatchSource.WIKI,psi4manual/1.2.1/prog_blas-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_blas-1.html
https://psicode.org/psi4manual/1.2.1/prog_blas-1.html:2858,Integrability,wrap,wrappers,2858," including multidimensional arrays, are required to be in contiguous; memory (as provided by block_matrix, for example), and are passed by; providing a pointer to the first double or int element of the data (this; is array[0] if array is double**). BLAS1 routines occasionally; return values (DDOT for instance), BLAS2 and BLAS3 always return void.; For char arguments, case is insensitive. A few examples are provided:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35; 36; 37; 38; 39// BLAS/LAPACK; #include ""psi4/libqt/qt.h""; // block_matrix, init_array; #include ""psi4/libciomr/libciomr.h"". using namespace psi;; ... // Allocate a,b vectors; int n = 100;; double* a = init_array(n);; double* b = init_array(n);. // Allocate A matrix;; double** A = block_matrix(n,n);; double** B = block_matrix(n,n);; double** C = block_matrix(n,n);. // Call the BLAS1 dot product between a and b; // n can be a ULI with the BLAS1 wrappers,; // All strides must be ints though; double dot = C_DDOT(n, a, 1, b, 1);. // Call the BLAS2 GEMV without transposition; // Note this works in row-major order; C_DGEMV('N', n, n, 1.0, A[0], n, a, 1, 0.0, b, 1);. // Call the BLAS3 GEMM without transposition; // Note this works in row-major order; C_DGEMM('N','N', n, n, n, 1.0, A[0], n, B[0], n, 0.0, C[0], n);. // Array's init'd with init_array must be free'd, not delete[]'d; free(a);; free(b);. // Block matrix should be free_blocked; free_block(A);; free_block(B);; free_block(C);. Important BLAS Routines¶. BLAS1; DDOT: dot product; DCOPY: efficient memory copy (with variable stride); DAXPY: y = y + alpha*x; DROT: Givens Rotation; DNRM2: Vector norm square. BLAS2; DGEMV: General Matrix-Vector product; DTRMV: Triangular Matrix-Vector product (2x faster, not wrapped yet); DTRSM: Triangular Matrix-Vector solution via back substitution (just as fast as DTRMV); DGER: Rank-1 update (not wrapped yet). BLAS3; DGEMM: General Matrix-Matrix",MatchSource.WIKI,psi4manual/1.2.1/prog_blas-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_blas-1.html
https://psicode.org/psi4manual/1.2.1/prog_blas-1.html:3683,Integrability,wrap,wrapped,3683,"ix(n,n);; double** B = block_matrix(n,n);; double** C = block_matrix(n,n);. // Call the BLAS1 dot product between a and b; // n can be a ULI with the BLAS1 wrappers,; // All strides must be ints though; double dot = C_DDOT(n, a, 1, b, 1);. // Call the BLAS2 GEMV without transposition; // Note this works in row-major order; C_DGEMV('N', n, n, 1.0, A[0], n, a, 1, 0.0, b, 1);. // Call the BLAS3 GEMM without transposition; // Note this works in row-major order; C_DGEMM('N','N', n, n, n, 1.0, A[0], n, B[0], n, 0.0, C[0], n);. // Array's init'd with init_array must be free'd, not delete[]'d; free(a);; free(b);. // Block matrix should be free_blocked; free_block(A);; free_block(B);; free_block(C);. Important BLAS Routines¶. BLAS1; DDOT: dot product; DCOPY: efficient memory copy (with variable stride); DAXPY: y = y + alpha*x; DROT: Givens Rotation; DNRM2: Vector norm square. BLAS2; DGEMV: General Matrix-Vector product; DTRMV: Triangular Matrix-Vector product (2x faster, not wrapped yet); DTRSM: Triangular Matrix-Vector solution via back substitution (just as fast as DTRMV); DGER: Rank-1 update (not wrapped yet). BLAS3; DGEMM: General Matrix-Matrix product; DTRMM: General Triangular Matrix-General Matrix product; DTRSM: Triangular Matrix-General Matrix solution via back substitution (just as fast as DTRMM); DSYMM/DSYMV calls are not appreciably faster than DGEMM calls, and should only be used in expert situations (like using the other half of the matrix for some form of other transformation).; DTRMM/DTRMV calls are 2x faster than DGEMM, and should be used where possible. LAPACK Wrappers¶; All standard LAPACK 3.2 double precision routines are provided.; LAPACK commands remain in Fortran’s “column-major” indexing, so all the; results will be transposed, and leading dimensions may have to be fiddled; with (using lda = n in both directions for square matrices is highly; recommended). An example of the former problem is a Cholesky; Decomposition: you expect to get back a lower tr",MatchSource.WIKI,psi4manual/1.2.1/prog_blas-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_blas-1.html
https://psicode.org/psi4manual/1.2.1/prog_blas-1.html:3810,Integrability,wrap,wrapped,3810,"ix(n,n);; double** B = block_matrix(n,n);; double** C = block_matrix(n,n);. // Call the BLAS1 dot product between a and b; // n can be a ULI with the BLAS1 wrappers,; // All strides must be ints though; double dot = C_DDOT(n, a, 1, b, 1);. // Call the BLAS2 GEMV without transposition; // Note this works in row-major order; C_DGEMV('N', n, n, 1.0, A[0], n, a, 1, 0.0, b, 1);. // Call the BLAS3 GEMM without transposition; // Note this works in row-major order; C_DGEMM('N','N', n, n, n, 1.0, A[0], n, B[0], n, 0.0, C[0], n);. // Array's init'd with init_array must be free'd, not delete[]'d; free(a);; free(b);. // Block matrix should be free_blocked; free_block(A);; free_block(B);; free_block(C);. Important BLAS Routines¶. BLAS1; DDOT: dot product; DCOPY: efficient memory copy (with variable stride); DAXPY: y = y + alpha*x; DROT: Givens Rotation; DNRM2: Vector norm square. BLAS2; DGEMV: General Matrix-Vector product; DTRMV: Triangular Matrix-Vector product (2x faster, not wrapped yet); DTRSM: Triangular Matrix-Vector solution via back substitution (just as fast as DTRMV); DGER: Rank-1 update (not wrapped yet). BLAS3; DGEMM: General Matrix-Matrix product; DTRMM: General Triangular Matrix-General Matrix product; DTRSM: Triangular Matrix-General Matrix solution via back substitution (just as fast as DTRMM); DSYMM/DSYMV calls are not appreciably faster than DGEMM calls, and should only be used in expert situations (like using the other half of the matrix for some form of other transformation).; DTRMM/DTRMV calls are 2x faster than DGEMM, and should be used where possible. LAPACK Wrappers¶; All standard LAPACK 3.2 double precision routines are provided.; LAPACK commands remain in Fortran’s “column-major” indexing, so all the; results will be transposed, and leading dimensions may have to be fiddled; with (using lda = n in both directions for square matrices is highly; recommended). An example of the former problem is a Cholesky; Decomposition: you expect to get back a lower tr",MatchSource.WIKI,psi4manual/1.2.1/prog_blas-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_blas-1.html
https://psicode.org/psi4manual/1.2.1/prog_blas-1.html:4350,Integrability,rout,routines,4350,"ed; free_block(A);; free_block(B);; free_block(C);. Important BLAS Routines¶. BLAS1; DDOT: dot product; DCOPY: efficient memory copy (with variable stride); DAXPY: y = y + alpha*x; DROT: Givens Rotation; DNRM2: Vector norm square. BLAS2; DGEMV: General Matrix-Vector product; DTRMV: Triangular Matrix-Vector product (2x faster, not wrapped yet); DTRSM: Triangular Matrix-Vector solution via back substitution (just as fast as DTRMV); DGER: Rank-1 update (not wrapped yet). BLAS3; DGEMM: General Matrix-Matrix product; DTRMM: General Triangular Matrix-General Matrix product; DTRSM: Triangular Matrix-General Matrix solution via back substitution (just as fast as DTRMM); DSYMM/DSYMV calls are not appreciably faster than DGEMM calls, and should only be used in expert situations (like using the other half of the matrix for some form of other transformation).; DTRMM/DTRMV calls are 2x faster than DGEMM, and should be used where possible. LAPACK Wrappers¶; All standard LAPACK 3.2 double precision routines are provided.; LAPACK commands remain in Fortran’s “column-major” indexing, so all the; results will be transposed, and leading dimensions may have to be fiddled; with (using lda = n in both directions for square matrices is highly; recommended). An example of the former problem is a Cholesky; Decomposition: you expect to get back a lower triangular matrix L such; that L L^T = A, but this is returned in column-major order, so the actual; recovery of the matrix A with the row-major BLAS wrappers effectively; involves L^T L = A. On of the biggest consequences is in linear equations:; The input/output forcing/solution vector must be explicitly formed in; column-major indexing (each vector is placed in a C++ row, with its; entries along the C++ column). This is visualized in C++ as the transpose; of the forcing/solution vector. All routines are declared in qt.h. Each; routine is prefixed with a C_, followed by the standard Fortran name of; the routine, in capital letters. Input para",MatchSource.WIKI,psi4manual/1.2.1/prog_blas-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_blas-1.html
https://psicode.org/psi4manual/1.2.1/prog_blas-1.html:4850,Integrability,wrap,wrappers,4850,"ubstitution (just as fast as DTRMV); DGER: Rank-1 update (not wrapped yet). BLAS3; DGEMM: General Matrix-Matrix product; DTRMM: General Triangular Matrix-General Matrix product; DTRSM: Triangular Matrix-General Matrix solution via back substitution (just as fast as DTRMM); DSYMM/DSYMV calls are not appreciably faster than DGEMM calls, and should only be used in expert situations (like using the other half of the matrix for some form of other transformation).; DTRMM/DTRMV calls are 2x faster than DGEMM, and should be used where possible. LAPACK Wrappers¶; All standard LAPACK 3.2 double precision routines are provided.; LAPACK commands remain in Fortran’s “column-major” indexing, so all the; results will be transposed, and leading dimensions may have to be fiddled; with (using lda = n in both directions for square matrices is highly; recommended). An example of the former problem is a Cholesky; Decomposition: you expect to get back a lower triangular matrix L such; that L L^T = A, but this is returned in column-major order, so the actual; recovery of the matrix A with the row-major BLAS wrappers effectively; involves L^T L = A. On of the biggest consequences is in linear equations:; The input/output forcing/solution vector must be explicitly formed in; column-major indexing (each vector is placed in a C++ row, with its; entries along the C++ column). This is visualized in C++ as the transpose; of the forcing/solution vector. All routines are declared in qt.h. Each; routine is prefixed with a C_, followed by the standard Fortran name of; the routine, in capital letters. Input parameters of single primitives; (int, double, unsigned long int, char, …) are passed by value. Arrays,; including multidimensional arrays, are required to be in contiguous memory; (as provided by block_matrix, for example), and are passed by providing a; pointer to the first double or int element of the data (this is array[0]; if array is double**). All routines return an int INFO with error and;",MatchSource.WIKI,psi4manual/1.2.1/prog_blas-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_blas-1.html
https://psicode.org/psi4manual/1.2.1/prog_blas-1.html:5199,Integrability,rout,routines,5199,"; DTRMM/DTRMV calls are 2x faster than DGEMM, and should be used where possible. LAPACK Wrappers¶; All standard LAPACK 3.2 double precision routines are provided.; LAPACK commands remain in Fortran’s “column-major” indexing, so all the; results will be transposed, and leading dimensions may have to be fiddled; with (using lda = n in both directions for square matrices is highly; recommended). An example of the former problem is a Cholesky; Decomposition: you expect to get back a lower triangular matrix L such; that L L^T = A, but this is returned in column-major order, so the actual; recovery of the matrix A with the row-major BLAS wrappers effectively; involves L^T L = A. On of the biggest consequences is in linear equations:; The input/output forcing/solution vector must be explicitly formed in; column-major indexing (each vector is placed in a C++ row, with its; entries along the C++ column). This is visualized in C++ as the transpose; of the forcing/solution vector. All routines are declared in qt.h. Each; routine is prefixed with a C_, followed by the standard Fortran name of; the routine, in capital letters. Input parameters of single primitives; (int, double, unsigned long int, char, …) are passed by value. Arrays,; including multidimensional arrays, are required to be in contiguous memory; (as provided by block_matrix, for example), and are passed by providing a; pointer to the first double or int element of the data (this is array[0]; if array is double**). All routines return an int INFO with error and; calculation information specific to the routine, In Fortran, this is the; last argument in all LAPACK calls, but should not be provided as an; argument here. For char arguments, case is insensitive. A Cholesky; transform example is shown:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33// BLAS/LAPACK; #include ""psi4/libqt/qt.h""; // block_matrix, init_array; #include ""psi4/libciomr/libc",MatchSource.WIKI,psi4manual/1.2.1/prog_blas-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_blas-1.html
https://psicode.org/psi4manual/1.2.1/prog_blas-1.html:5236,Integrability,rout,routine,5236,"ible. LAPACK Wrappers¶; All standard LAPACK 3.2 double precision routines are provided.; LAPACK commands remain in Fortran’s “column-major” indexing, so all the; results will be transposed, and leading dimensions may have to be fiddled; with (using lda = n in both directions for square matrices is highly; recommended). An example of the former problem is a Cholesky; Decomposition: you expect to get back a lower triangular matrix L such; that L L^T = A, but this is returned in column-major order, so the actual; recovery of the matrix A with the row-major BLAS wrappers effectively; involves L^T L = A. On of the biggest consequences is in linear equations:; The input/output forcing/solution vector must be explicitly formed in; column-major indexing (each vector is placed in a C++ row, with its; entries along the C++ column). This is visualized in C++ as the transpose; of the forcing/solution vector. All routines are declared in qt.h. Each; routine is prefixed with a C_, followed by the standard Fortran name of; the routine, in capital letters. Input parameters of single primitives; (int, double, unsigned long int, char, …) are passed by value. Arrays,; including multidimensional arrays, are required to be in contiguous memory; (as provided by block_matrix, for example), and are passed by providing a; pointer to the first double or int element of the data (this is array[0]; if array is double**). All routines return an int INFO with error and; calculation information specific to the routine, In Fortran, this is the; last argument in all LAPACK calls, but should not be provided as an; argument here. For char arguments, case is insensitive. A Cholesky; transform example is shown:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33// BLAS/LAPACK; #include ""psi4/libqt/qt.h""; // block_matrix, init_array; #include ""psi4/libciomr/libciomr.h"". using namespace psi;; ...; int n = 100;. // Allocate A matrix;; d",MatchSource.WIKI,psi4manual/1.2.1/prog_blas-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_blas-1.html
https://psicode.org/psi4manual/1.2.1/prog_blas-1.html:5313,Integrability,rout,routine,5313,"ible. LAPACK Wrappers¶; All standard LAPACK 3.2 double precision routines are provided.; LAPACK commands remain in Fortran’s “column-major” indexing, so all the; results will be transposed, and leading dimensions may have to be fiddled; with (using lda = n in both directions for square matrices is highly; recommended). An example of the former problem is a Cholesky; Decomposition: you expect to get back a lower triangular matrix L such; that L L^T = A, but this is returned in column-major order, so the actual; recovery of the matrix A with the row-major BLAS wrappers effectively; involves L^T L = A. On of the biggest consequences is in linear equations:; The input/output forcing/solution vector must be explicitly formed in; column-major indexing (each vector is placed in a C++ row, with its; entries along the C++ column). This is visualized in C++ as the transpose; of the forcing/solution vector. All routines are declared in qt.h. Each; routine is prefixed with a C_, followed by the standard Fortran name of; the routine, in capital letters. Input parameters of single primitives; (int, double, unsigned long int, char, …) are passed by value. Arrays,; including multidimensional arrays, are required to be in contiguous memory; (as provided by block_matrix, for example), and are passed by providing a; pointer to the first double or int element of the data (this is array[0]; if array is double**). All routines return an int INFO with error and; calculation information specific to the routine, In Fortran, this is the; last argument in all LAPACK calls, but should not be provided as an; argument here. For char arguments, case is insensitive. A Cholesky; transform example is shown:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33// BLAS/LAPACK; #include ""psi4/libqt/qt.h""; // block_matrix, init_array; #include ""psi4/libciomr/libciomr.h"". using namespace psi;; ...; int n = 100;. // Allocate A matrix;; d",MatchSource.WIKI,psi4manual/1.2.1/prog_blas-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_blas-1.html
https://psicode.org/psi4manual/1.2.1/prog_blas-1.html:5705,Integrability,rout,routines,5705,"covery of the matrix A with the row-major BLAS wrappers effectively; involves L^T L = A. On of the biggest consequences is in linear equations:; The input/output forcing/solution vector must be explicitly formed in; column-major indexing (each vector is placed in a C++ row, with its; entries along the C++ column). This is visualized in C++ as the transpose; of the forcing/solution vector. All routines are declared in qt.h. Each; routine is prefixed with a C_, followed by the standard Fortran name of; the routine, in capital letters. Input parameters of single primitives; (int, double, unsigned long int, char, …) are passed by value. Arrays,; including multidimensional arrays, are required to be in contiguous memory; (as provided by block_matrix, for example), and are passed by providing a; pointer to the first double or int element of the data (this is array[0]; if array is double**). All routines return an int INFO with error and; calculation information specific to the routine, In Fortran, this is the; last argument in all LAPACK calls, but should not be provided as an; argument here. For char arguments, case is insensitive. A Cholesky; transform example is shown:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33// BLAS/LAPACK; #include ""psi4/libqt/qt.h""; // block_matrix, init_array; #include ""psi4/libciomr/libciomr.h"". using namespace psi;; ...; int n = 100;. // Allocate A matrix;; double** A = block_matrix(n,n);. // Call the LAPACK DPOTRF to get the Cholesky factor; // Note this works in column-major order; // The result fills like:; // * * * *; // * * *; // * *; // *; // instead of the expected:; // *; // * *; // * * *; // * * * *; //; int info = C_DPOTRF('L', n, A[0], n);. // A bit painful, see below; fprintf(outfile, ""A:\n"");; print_mat(A,n,n,outfile);. // Block matrix should be free_blocked; free_block(A);. Important Lapack Routines¶. DSYEV: Eigenvalues and, optionally eigenvectors of a",MatchSource.WIKI,psi4manual/1.2.1/prog_blas-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_blas-1.html
https://psicode.org/psi4manual/1.2.1/prog_blas-1.html:5789,Integrability,rout,routine,5789,"covery of the matrix A with the row-major BLAS wrappers effectively; involves L^T L = A. On of the biggest consequences is in linear equations:; The input/output forcing/solution vector must be explicitly formed in; column-major indexing (each vector is placed in a C++ row, with its; entries along the C++ column). This is visualized in C++ as the transpose; of the forcing/solution vector. All routines are declared in qt.h. Each; routine is prefixed with a C_, followed by the standard Fortran name of; the routine, in capital letters. Input parameters of single primitives; (int, double, unsigned long int, char, …) are passed by value. Arrays,; including multidimensional arrays, are required to be in contiguous memory; (as provided by block_matrix, for example), and are passed by providing a; pointer to the first double or int element of the data (this is array[0]; if array is double**). All routines return an int INFO with error and; calculation information specific to the routine, In Fortran, this is the; last argument in all LAPACK calls, but should not be provided as an; argument here. For char arguments, case is insensitive. A Cholesky; transform example is shown:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33// BLAS/LAPACK; #include ""psi4/libqt/qt.h""; // block_matrix, init_array; #include ""psi4/libciomr/libciomr.h"". using namespace psi;; ...; int n = 100;. // Allocate A matrix;; double** A = block_matrix(n,n);. // Call the LAPACK DPOTRF to get the Cholesky factor; // Note this works in column-major order; // The result fills like:; // * * * *; // * * *; // * *; // *; // instead of the expected:; // *; // * *; // * * *; // * * * *; //; int info = C_DPOTRF('L', n, A[0], n);. // A bit painful, see below; fprintf(outfile, ""A:\n"");; print_mat(A,n,n,outfile);. // Block matrix should be free_blocked; free_block(A);. Important Lapack Routines¶. DSYEV: Eigenvalues and, optionally eigenvectors of a",MatchSource.WIKI,psi4manual/1.2.1/prog_blas-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_blas-1.html
https://psicode.org/psi4manual/1.2.1/prog_blas-1.html:11074,Integrability,depend,dependencies,11074,"L + 1 real combinations of the spherical harmonics are built from; the (L+1)(L+2)/2 Cartesian Gaussians, according to H. Schlegel and M.; Frish, IJQC, 54, 83-87, 1995. Unlike Cartesian functions these functions; are all strictly normalized. Note that in PSI4, the real combinations of; spherical harmonic functions (see the paragraph below Eq. 15 in the; Schlegel paper) are ordered as: 0, 1+, 1-, 2+, 2-, …. USO (Unique Symmetry-Adapted Orbitals): Spatial symmetry-adapted; combinations of SOs, blocked according to irrep. The total number of USOs; is the same as the number of SOs, but the number of USOs within each irrep; is usually much smaller, which can lead to significant performance; improvements. Note that this basis is sometimes unfortunately referred to; as the SO basis, so it’s a bit context specific. OSO (Orthogonal Symmetry-Adapted Orbitals): USOs orthogonalized by; Symmetric or Canonical Orthogonalization. The number of OSOs may be; slightly smaller than the total number of USOs, due to removal of linear; dependencies via Canonical Orthogonalization. The OSOs are rarely; encountered, as usually we go straight from USOs to MOs. MO (Molecular Orbitals): The combination of OSOs that diagonalizes; the Fock Matrix, so each basis function is a Hartree-Fock (or Kohn-Sham); molecular orbital. The number of OSOs and MOs is always the same. MOs are; orthonormal. LO (Localized Orbitals): Localized occupied orbitals, a different; combination of the occupied molecular orbitals which enhances spatial; locality. LOs do not diagonalize the occ-occ block of the Fock Matrix, but; remain orthonormal to each other and the virtual space. How to name orbital dimensions¶; There are a number of different names used to refer to the basis set size.; These may seem redundant, but they have subtly different meanings, as; detailed below.; A calculation can use either pure (5D, 7F, 9G, etc.) basis functions or; Cartesian (6D, 10F, 15G, etc.), as dictated by the input file / basis set; spe",MatchSource.WIKI,psi4manual/1.2.1/prog_blas-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_blas-1.html
https://psicode.org/psi4manual/1.2.1/prog_blas-1.html:12227,Integrability,depend,dependent,12227,"tion of OSOs that diagonalizes; the Fock Matrix, so each basis function is a Hartree-Fock (or Kohn-Sham); molecular orbital. The number of OSOs and MOs is always the same. MOs are; orthonormal. LO (Localized Orbitals): Localized occupied orbitals, a different; combination of the occupied molecular orbitals which enhances spatial; locality. LOs do not diagonalize the occ-occ block of the Fock Matrix, but; remain orthonormal to each other and the virtual space. How to name orbital dimensions¶; There are a number of different names used to refer to the basis set size.; These may seem redundant, but they have subtly different meanings, as; detailed below.; A calculation can use either pure (5D, 7F, 9G, etc.) basis functions or; Cartesian (6D, 10F, 15G, etc.), as dictated by the input file / basis set; specification. Also, the basis can be represented in terms of atomic; orbitals (AO) or symmetry-adapted orbitals (SO). Further complications; come from the fact that a nearly linearly-dependent basis set will have; functions removed from it to prevent redundancies. With all of these; factors in mind, here are the conventions used internally:. nao — The number of atomic orbitals in Cartesian representation.; nso — The number of atomic orbitals but in the pure representation if the current basis uses pure functions, number of Cartesian AOs otherwise.; nbf — The number of basis functions, which is the same as nso.; nmo — The number of basis functions, after projecting out redundancies in the basis. When molecular symmetry is utilized, a small array of sizes per irrep is; usually allocated on the stack, and is named by augmenting the name above; with a pi (per-irrep), e.g. nmopi. Note that the number of irreps is; always the singular nirrep, and that the index variable h is always used; in a for-loop traverse of irreps. How to name orbital spaces (e.g., docc)¶; As with basis sets, a number of names are used to refer to refer to the; quantity of electrons, virtuals, and active s",MatchSource.WIKI,psi4manual/1.2.1/prog_blas-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_blas-1.html
https://psicode.org/psi4manual/1.2.1/prog_blas-1.html:291,Modifiability,portab,portable,291,"﻿. Linear Algebra in PSI4. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Programming: Using the Core Libraries. Linear Algebra in PSI4¶. How to call BLAS & LAPACK in PSI4¶; Computational chemistry is essentially linear algebra on molecular; systems, so using stable, portable, scalable, and efficient numerical; linear algebra methods in PSI4 is critical. To that end, we use BLAS1; (vector-vector operations, like dot products), BLAS2 (matrix-vector; operations, like rank-1 update), BLAS3 (matrix-matrix operations, like; matrix multiplication), and LAPACK (advanced matrix decompositions and; solutions). The methods provided by BLAS and LAPACK are standard, but the; performance of actual implementations differ greatly from one version to; another. Moreover, the standard interfaces to the libraries are Fortran,; so PSI4 provides a common set of wrappers in psi4/psi4/src/psi4/libqt/qt.h . Warning; Although block_matrix, init_array, and print_mat are still; around, their use is discouraged in favor of operations on; psi4.core.Matrix itself. The advice in these docs will catch up; shortly. BLAS Wrappers¶; BLAS wrappers are currently fully supported at double precision.; BLAS commands involving matrices are wrapped so as to be conventional; C-style “row-major” indexing, meaning that the column is the fast index; like normal. The calls to BLAS1 routines are wrapped so as to allow for operations on; vectors with more than 2^{31} elements (~16 GB, getting to be a problem).; So passing a signed or unsigned long works, though the stride arguments; must be integers. All routines are declared in qt.h. Each routine is prefixed with a; C_, followed by the standard Fortran name of the routine, in capital; letters. Input parameters of single primitives (int, double,; unsigned long int, char, …) are passed by value. Arrays,; including multidimensional arrays, are required to be in contiguous; memory (as provided by block_matrix, for example), and are passed by; pr",MatchSource.WIKI,psi4manual/1.2.1/prog_blas-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_blas-1.html
https://psicode.org/psi4manual/1.2.1/prog_blas-1.html:3490,Modifiability,variab,variable,3490,"de ""psi4/libciomr/libciomr.h"". using namespace psi;; ... // Allocate a,b vectors; int n = 100;; double* a = init_array(n);; double* b = init_array(n);. // Allocate A matrix;; double** A = block_matrix(n,n);; double** B = block_matrix(n,n);; double** C = block_matrix(n,n);. // Call the BLAS1 dot product between a and b; // n can be a ULI with the BLAS1 wrappers,; // All strides must be ints though; double dot = C_DDOT(n, a, 1, b, 1);. // Call the BLAS2 GEMV without transposition; // Note this works in row-major order; C_DGEMV('N', n, n, 1.0, A[0], n, a, 1, 0.0, b, 1);. // Call the BLAS3 GEMM without transposition; // Note this works in row-major order; C_DGEMM('N','N', n, n, n, 1.0, A[0], n, B[0], n, 0.0, C[0], n);. // Array's init'd with init_array must be free'd, not delete[]'d; free(a);; free(b);. // Block matrix should be free_blocked; free_block(A);; free_block(B);; free_block(C);. Important BLAS Routines¶. BLAS1; DDOT: dot product; DCOPY: efficient memory copy (with variable stride); DAXPY: y = y + alpha*x; DROT: Givens Rotation; DNRM2: Vector norm square. BLAS2; DGEMV: General Matrix-Vector product; DTRMV: Triangular Matrix-Vector product (2x faster, not wrapped yet); DTRSM: Triangular Matrix-Vector solution via back substitution (just as fast as DTRMV); DGER: Rank-1 update (not wrapped yet). BLAS3; DGEMM: General Matrix-Matrix product; DTRMM: General Triangular Matrix-General Matrix product; DTRSM: Triangular Matrix-General Matrix solution via back substitution (just as fast as DTRMM); DSYMM/DSYMV calls are not appreciably faster than DGEMM calls, and should only be used in expert situations (like using the other half of the matrix for some form of other transformation).; DTRMM/DTRMV calls are 2x faster than DGEMM, and should be used where possible. LAPACK Wrappers¶; All standard LAPACK 3.2 double precision routines are provided.; LAPACK commands remain in Fortran’s “column-major” indexing, so all the; results will be transposed, and leading dimensions may hav",MatchSource.WIKI,psi4manual/1.2.1/prog_blas-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_blas-1.html
https://psicode.org/psi4manual/1.2.1/prog_blas-1.html:10511,Modifiability,adapt,adapted,10511,"is is typically the; first layer encountered, Libmints handles the transform from AO to SO; automatically. If Cartesian functions are used, the number of functions; per shell remains (L + 1)(L + 2)/2, and the ordering remains the same; as above. Note that the individual functions are not normalized for; angular momentum as in most codes: the self-overlap of a PSI4 Cartesian D; or higher function with more than one nonzero Cartesian exponent (e.g., lx; = 1, ly = 1, lz = 0) will be less than one. If Spherical Harmonics are; used, 2L + 1 real combinations of the spherical harmonics are built from; the (L+1)(L+2)/2 Cartesian Gaussians, according to H. Schlegel and M.; Frish, IJQC, 54, 83-87, 1995. Unlike Cartesian functions these functions; are all strictly normalized. Note that in PSI4, the real combinations of; spherical harmonic functions (see the paragraph below Eq. 15 in the; Schlegel paper) are ordered as: 0, 1+, 1-, 2+, 2-, …. USO (Unique Symmetry-Adapted Orbitals): Spatial symmetry-adapted; combinations of SOs, blocked according to irrep. The total number of USOs; is the same as the number of SOs, but the number of USOs within each irrep; is usually much smaller, which can lead to significant performance; improvements. Note that this basis is sometimes unfortunately referred to; as the SO basis, so it’s a bit context specific. OSO (Orthogonal Symmetry-Adapted Orbitals): USOs orthogonalized by; Symmetric or Canonical Orthogonalization. The number of OSOs may be; slightly smaller than the total number of USOs, due to removal of linear; dependencies via Canonical Orthogonalization. The OSOs are rarely; encountered, as usually we go straight from USOs to MOs. MO (Molecular Orbitals): The combination of OSOs that diagonalizes; the Fock Matrix, so each basis function is a Hartree-Fock (or Kohn-Sham); molecular orbital. The number of OSOs and MOs is always the same. MOs are; orthonormal. LO (Localized Orbitals): Localized occupied orbitals, a different; combination of t",MatchSource.WIKI,psi4manual/1.2.1/prog_blas-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_blas-1.html
https://psicode.org/psi4manual/1.2.1/prog_blas-1.html:11548,Modifiability,enhance,enhances,11548," symmetry-adapted; combinations of SOs, blocked according to irrep. The total number of USOs; is the same as the number of SOs, but the number of USOs within each irrep; is usually much smaller, which can lead to significant performance; improvements. Note that this basis is sometimes unfortunately referred to; as the SO basis, so it’s a bit context specific. OSO (Orthogonal Symmetry-Adapted Orbitals): USOs orthogonalized by; Symmetric or Canonical Orthogonalization. The number of OSOs may be; slightly smaller than the total number of USOs, due to removal of linear; dependencies via Canonical Orthogonalization. The OSOs are rarely; encountered, as usually we go straight from USOs to MOs. MO (Molecular Orbitals): The combination of OSOs that diagonalizes; the Fock Matrix, so each basis function is a Hartree-Fock (or Kohn-Sham); molecular orbital. The number of OSOs and MOs is always the same. MOs are; orthonormal. LO (Localized Orbitals): Localized occupied orbitals, a different; combination of the occupied molecular orbitals which enhances spatial; locality. LOs do not diagonalize the occ-occ block of the Fock Matrix, but; remain orthonormal to each other and the virtual space. How to name orbital dimensions¶; There are a number of different names used to refer to the basis set size.; These may seem redundant, but they have subtly different meanings, as; detailed below.; A calculation can use either pure (5D, 7F, 9G, etc.) basis functions or; Cartesian (6D, 10F, 15G, etc.), as dictated by the input file / basis set; specification. Also, the basis can be represented in terms of atomic; orbitals (AO) or symmetry-adapted orbitals (SO). Further complications; come from the fact that a nearly linearly-dependent basis set will have; functions removed from it to prevent redundancies. With all of these; factors in mind, here are the conventions used internally:. nao — The number of atomic orbitals in Cartesian representation.; nso — The number of atomic orbitals but in the ",MatchSource.WIKI,psi4manual/1.2.1/prog_blas-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_blas-1.html
https://psicode.org/psi4manual/1.2.1/prog_blas-1.html:12139,Modifiability,adapt,adapted,12139,"alization. The OSOs are rarely; encountered, as usually we go straight from USOs to MOs. MO (Molecular Orbitals): The combination of OSOs that diagonalizes; the Fock Matrix, so each basis function is a Hartree-Fock (or Kohn-Sham); molecular orbital. The number of OSOs and MOs is always the same. MOs are; orthonormal. LO (Localized Orbitals): Localized occupied orbitals, a different; combination of the occupied molecular orbitals which enhances spatial; locality. LOs do not diagonalize the occ-occ block of the Fock Matrix, but; remain orthonormal to each other and the virtual space. How to name orbital dimensions¶; There are a number of different names used to refer to the basis set size.; These may seem redundant, but they have subtly different meanings, as; detailed below.; A calculation can use either pure (5D, 7F, 9G, etc.) basis functions or; Cartesian (6D, 10F, 15G, etc.), as dictated by the input file / basis set; specification. Also, the basis can be represented in terms of atomic; orbitals (AO) or symmetry-adapted orbitals (SO). Further complications; come from the fact that a nearly linearly-dependent basis set will have; functions removed from it to prevent redundancies. With all of these; factors in mind, here are the conventions used internally:. nao — The number of atomic orbitals in Cartesian representation.; nso — The number of atomic orbitals but in the pure representation if the current basis uses pure functions, number of Cartesian AOs otherwise.; nbf — The number of basis functions, which is the same as nso.; nmo — The number of basis functions, after projecting out redundancies in the basis. When molecular symmetry is utilized, a small array of sizes per irrep is; usually allocated on the stack, and is named by augmenting the name above; with a pi (per-irrep), e.g. nmopi. Note that the number of irreps is; always the singular nirrep, and that the index variable h is always used; in a for-loop traverse of irreps. How to name orbital spaces (e.g., ",MatchSource.WIKI,psi4manual/1.2.1/prog_blas-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_blas-1.html
https://psicode.org/psi4manual/1.2.1/prog_blas-1.html:13014,Modifiability,variab,variable,13014," dictated by the input file / basis set; specification. Also, the basis can be represented in terms of atomic; orbitals (AO) or symmetry-adapted orbitals (SO). Further complications; come from the fact that a nearly linearly-dependent basis set will have; functions removed from it to prevent redundancies. With all of these; factors in mind, here are the conventions used internally:. nao — The number of atomic orbitals in Cartesian representation.; nso — The number of atomic orbitals but in the pure representation if the current basis uses pure functions, number of Cartesian AOs otherwise.; nbf — The number of basis functions, which is the same as nso.; nmo — The number of basis functions, after projecting out redundancies in the basis. When molecular symmetry is utilized, a small array of sizes per irrep is; usually allocated on the stack, and is named by augmenting the name above; with a pi (per-irrep), e.g. nmopi. Note that the number of irreps is; always the singular nirrep, and that the index variable h is always used; in a for-loop traverse of irreps. How to name orbital spaces (e.g., docc)¶; As with basis sets, a number of names are used to refer to refer to the; quantity of electrons, virtuals, and active sub-quantities of a PSI4; calculation. All of these can be defined per irrep as above. Some common; conventions are:. nelec — The number of electrons, rarely used due to specialization of alphas and betas or soccs and doccs.; nalpha — The number of alpha electrons.; nbeta — The number of beta electrons; docc — The number of doubly-occupied orbitals; socc — The number of singly-occupied orbitals (Almost always alpha, we don’t like open-shell singlets much).; nvir — The number of virtual orbitals. Multireference Dimensions¶; A orbital diagram of the nomenclature used for CI and MCSCF calculations.; Diagrammatically:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15-----------------------------------------------; CI | RAS | CAS; --------------------------------",MatchSource.WIKI,psi4manual/1.2.1/prog_blas-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_blas-1.html
https://psicode.org/psi4manual/1.2.1/prog_blas-1.html:301,Performance,scalab,scalable,301,"﻿. Linear Algebra in PSI4. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Programming: Using the Core Libraries. Linear Algebra in PSI4¶. How to call BLAS & LAPACK in PSI4¶; Computational chemistry is essentially linear algebra on molecular; systems, so using stable, portable, scalable, and efficient numerical; linear algebra methods in PSI4 is critical. To that end, we use BLAS1; (vector-vector operations, like dot products), BLAS2 (matrix-vector; operations, like rank-1 update), BLAS3 (matrix-matrix operations, like; matrix multiplication), and LAPACK (advanced matrix decompositions and; solutions). The methods provided by BLAS and LAPACK are standard, but the; performance of actual implementations differ greatly from one version to; another. Moreover, the standard interfaces to the libraries are Fortran,; so PSI4 provides a common set of wrappers in psi4/psi4/src/psi4/libqt/qt.h . Warning; Although block_matrix, init_array, and print_mat are still; around, their use is discouraged in favor of operations on; psi4.core.Matrix itself. The advice in these docs will catch up; shortly. BLAS Wrappers¶; BLAS wrappers are currently fully supported at double precision.; BLAS commands involving matrices are wrapped so as to be conventional; C-style “row-major” indexing, meaning that the column is the fast index; like normal. The calls to BLAS1 routines are wrapped so as to allow for operations on; vectors with more than 2^{31} elements (~16 GB, getting to be a problem).; So passing a signed or unsigned long works, though the stride arguments; must be integers. All routines are declared in qt.h. Each routine is prefixed with a; C_, followed by the standard Fortran name of the routine, in capital; letters. Input parameters of single primitives (int, double,; unsigned long int, char, …) are passed by value. Arrays,; including multidimensional arrays, are required to be in contiguous; memory (as provided by block_matrix, for example), and are passed by; pr",MatchSource.WIKI,psi4manual/1.2.1/prog_blas-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_blas-1.html
https://psicode.org/psi4manual/1.2.1/prog_blas-1.html:695,Performance,perform,performance,695,"﻿. Linear Algebra in PSI4. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Programming: Using the Core Libraries. Linear Algebra in PSI4¶. How to call BLAS & LAPACK in PSI4¶; Computational chemistry is essentially linear algebra on molecular; systems, so using stable, portable, scalable, and efficient numerical; linear algebra methods in PSI4 is critical. To that end, we use BLAS1; (vector-vector operations, like dot products), BLAS2 (matrix-vector; operations, like rank-1 update), BLAS3 (matrix-matrix operations, like; matrix multiplication), and LAPACK (advanced matrix decompositions and; solutions). The methods provided by BLAS and LAPACK are standard, but the; performance of actual implementations differ greatly from one version to; another. Moreover, the standard interfaces to the libraries are Fortran,; so PSI4 provides a common set of wrappers in psi4/psi4/src/psi4/libqt/qt.h . Warning; Although block_matrix, init_array, and print_mat are still; around, their use is discouraged in favor of operations on; psi4.core.Matrix itself. The advice in these docs will catch up; shortly. BLAS Wrappers¶; BLAS wrappers are currently fully supported at double precision.; BLAS commands involving matrices are wrapped so as to be conventional; C-style “row-major” indexing, meaning that the column is the fast index; like normal. The calls to BLAS1 routines are wrapped so as to allow for operations on; vectors with more than 2^{31} elements (~16 GB, getting to be a problem).; So passing a signed or unsigned long works, though the stride arguments; must be integers. All routines are declared in qt.h. Each routine is prefixed with a; C_, followed by the standard Fortran name of the routine, in capital; letters. Input parameters of single primitives (int, double,; unsigned long int, char, …) are passed by value. Arrays,; including multidimensional arrays, are required to be in contiguous; memory (as provided by block_matrix, for example), and are passed by; pr",MatchSource.WIKI,psi4manual/1.2.1/prog_blas-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_blas-1.html
https://psicode.org/psi4manual/1.2.1/prog_blas-1.html:10726,Performance,perform,performance,10726," of functions; per shell remains (L + 1)(L + 2)/2, and the ordering remains the same; as above. Note that the individual functions are not normalized for; angular momentum as in most codes: the self-overlap of a PSI4 Cartesian D; or higher function with more than one nonzero Cartesian exponent (e.g., lx; = 1, ly = 1, lz = 0) will be less than one. If Spherical Harmonics are; used, 2L + 1 real combinations of the spherical harmonics are built from; the (L+1)(L+2)/2 Cartesian Gaussians, according to H. Schlegel and M.; Frish, IJQC, 54, 83-87, 1995. Unlike Cartesian functions these functions; are all strictly normalized. Note that in PSI4, the real combinations of; spherical harmonic functions (see the paragraph below Eq. 15 in the; Schlegel paper) are ordered as: 0, 1+, 1-, 2+, 2-, …. USO (Unique Symmetry-Adapted Orbitals): Spatial symmetry-adapted; combinations of SOs, blocked according to irrep. The total number of USOs; is the same as the number of SOs, but the number of USOs within each irrep; is usually much smaller, which can lead to significant performance; improvements. Note that this basis is sometimes unfortunately referred to; as the SO basis, so it’s a bit context specific. OSO (Orthogonal Symmetry-Adapted Orbitals): USOs orthogonalized by; Symmetric or Canonical Orthogonalization. The number of OSOs may be; slightly smaller than the total number of USOs, due to removal of linear; dependencies via Canonical Orthogonalization. The OSOs are rarely; encountered, as usually we go straight from USOs to MOs. MO (Molecular Orbitals): The combination of OSOs that diagonalizes; the Fock Matrix, so each basis function is a Hartree-Fock (or Kohn-Sham); molecular orbital. The number of OSOs and MOs is always the same. MOs are; orthonormal. LO (Localized Orbitals): Localized occupied orbitals, a different; combination of the occupied molecular orbitals which enhances spatial; locality. LOs do not diagonalize the occ-occ block of the Fock Matrix, but; remain orthonormal",MatchSource.WIKI,psi4manual/1.2.1/prog_blas-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_blas-1.html
https://psicode.org/psi4manual/1.2.1/prog_blas-1.html:4801,Safety,recover,recovery,4801,"ubstitution (just as fast as DTRMV); DGER: Rank-1 update (not wrapped yet). BLAS3; DGEMM: General Matrix-Matrix product; DTRMM: General Triangular Matrix-General Matrix product; DTRSM: Triangular Matrix-General Matrix solution via back substitution (just as fast as DTRMM); DSYMM/DSYMV calls are not appreciably faster than DGEMM calls, and should only be used in expert situations (like using the other half of the matrix for some form of other transformation).; DTRMM/DTRMV calls are 2x faster than DGEMM, and should be used where possible. LAPACK Wrappers¶; All standard LAPACK 3.2 double precision routines are provided.; LAPACK commands remain in Fortran’s “column-major” indexing, so all the; results will be transposed, and leading dimensions may have to be fiddled; with (using lda = n in both directions for square matrices is highly; recommended). An example of the former problem is a Cholesky; Decomposition: you expect to get back a lower triangular matrix L such; that L L^T = A, but this is returned in column-major order, so the actual; recovery of the matrix A with the row-major BLAS wrappers effectively; involves L^T L = A. On of the biggest consequences is in linear equations:; The input/output forcing/solution vector must be explicitly formed in; column-major indexing (each vector is placed in a C++ row, with its; entries along the C++ column). This is visualized in C++ as the transpose; of the forcing/solution vector. All routines are declared in qt.h. Each; routine is prefixed with a C_, followed by the standard Fortran name of; the routine, in capital letters. Input parameters of single primitives; (int, double, unsigned long int, char, …) are passed by value. Arrays,; including multidimensional arrays, are required to be in contiguous memory; (as provided by block_matrix, for example), and are passed by providing a; pointer to the first double or int element of the data (this is array[0]; if array is double**). All routines return an int INFO with error and;",MatchSource.WIKI,psi4manual/1.2.1/prog_blas-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_blas-1.html
https://psicode.org/psi4manual/1.2.1/prog_blas-1.html:11822,Safety,redund,redundant,11822,"ext specific. OSO (Orthogonal Symmetry-Adapted Orbitals): USOs orthogonalized by; Symmetric or Canonical Orthogonalization. The number of OSOs may be; slightly smaller than the total number of USOs, due to removal of linear; dependencies via Canonical Orthogonalization. The OSOs are rarely; encountered, as usually we go straight from USOs to MOs. MO (Molecular Orbitals): The combination of OSOs that diagonalizes; the Fock Matrix, so each basis function is a Hartree-Fock (or Kohn-Sham); molecular orbital. The number of OSOs and MOs is always the same. MOs are; orthonormal. LO (Localized Orbitals): Localized occupied orbitals, a different; combination of the occupied molecular orbitals which enhances spatial; locality. LOs do not diagonalize the occ-occ block of the Fock Matrix, but; remain orthonormal to each other and the virtual space. How to name orbital dimensions¶; There are a number of different names used to refer to the basis set size.; These may seem redundant, but they have subtly different meanings, as; detailed below.; A calculation can use either pure (5D, 7F, 9G, etc.) basis functions or; Cartesian (6D, 10F, 15G, etc.), as dictated by the input file / basis set; specification. Also, the basis can be represented in terms of atomic; orbitals (AO) or symmetry-adapted orbitals (SO). Further complications; come from the fact that a nearly linearly-dependent basis set will have; functions removed from it to prevent redundancies. With all of these; factors in mind, here are the conventions used internally:. nao — The number of atomic orbitals in Cartesian representation.; nso — The number of atomic orbitals but in the pure representation if the current basis uses pure functions, number of Cartesian AOs otherwise.; nbf — The number of basis functions, which is the same as nso.; nmo — The number of basis functions, after projecting out redundancies in the basis. When molecular symmetry is utilized, a small array of sizes per irrep is; usually allocated on the st",MatchSource.WIKI,psi4manual/1.2.1/prog_blas-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_blas-1.html
https://psicode.org/psi4manual/1.2.1/prog_blas-1.html:12295,Safety,redund,redundancies,12295,"tion of OSOs that diagonalizes; the Fock Matrix, so each basis function is a Hartree-Fock (or Kohn-Sham); molecular orbital. The number of OSOs and MOs is always the same. MOs are; orthonormal. LO (Localized Orbitals): Localized occupied orbitals, a different; combination of the occupied molecular orbitals which enhances spatial; locality. LOs do not diagonalize the occ-occ block of the Fock Matrix, but; remain orthonormal to each other and the virtual space. How to name orbital dimensions¶; There are a number of different names used to refer to the basis set size.; These may seem redundant, but they have subtly different meanings, as; detailed below.; A calculation can use either pure (5D, 7F, 9G, etc.) basis functions or; Cartesian (6D, 10F, 15G, etc.), as dictated by the input file / basis set; specification. Also, the basis can be represented in terms of atomic; orbitals (AO) or symmetry-adapted orbitals (SO). Further complications; come from the fact that a nearly linearly-dependent basis set will have; functions removed from it to prevent redundancies. With all of these; factors in mind, here are the conventions used internally:. nao — The number of atomic orbitals in Cartesian representation.; nso — The number of atomic orbitals but in the pure representation if the current basis uses pure functions, number of Cartesian AOs otherwise.; nbf — The number of basis functions, which is the same as nso.; nmo — The number of basis functions, after projecting out redundancies in the basis. When molecular symmetry is utilized, a small array of sizes per irrep is; usually allocated on the stack, and is named by augmenting the name above; with a pi (per-irrep), e.g. nmopi. Note that the number of irreps is; always the singular nirrep, and that the index variable h is always used; in a for-loop traverse of irreps. How to name orbital spaces (e.g., docc)¶; As with basis sets, a number of names are used to refer to refer to the; quantity of electrons, virtuals, and active s",MatchSource.WIKI,psi4manual/1.2.1/prog_blas-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_blas-1.html
https://psicode.org/psi4manual/1.2.1/prog_blas-1.html:12721,Safety,redund,redundancies,12721," name orbital dimensions¶; There are a number of different names used to refer to the basis set size.; These may seem redundant, but they have subtly different meanings, as; detailed below.; A calculation can use either pure (5D, 7F, 9G, etc.) basis functions or; Cartesian (6D, 10F, 15G, etc.), as dictated by the input file / basis set; specification. Also, the basis can be represented in terms of atomic; orbitals (AO) or symmetry-adapted orbitals (SO). Further complications; come from the fact that a nearly linearly-dependent basis set will have; functions removed from it to prevent redundancies. With all of these; factors in mind, here are the conventions used internally:. nao — The number of atomic orbitals in Cartesian representation.; nso — The number of atomic orbitals but in the pure representation if the current basis uses pure functions, number of Cartesian AOs otherwise.; nbf — The number of basis functions, which is the same as nso.; nmo — The number of basis functions, after projecting out redundancies in the basis. When molecular symmetry is utilized, a small array of sizes per irrep is; usually allocated on the stack, and is named by augmenting the name above; with a pi (per-irrep), e.g. nmopi. Note that the number of irreps is; always the singular nirrep, and that the index variable h is always used; in a for-loop traverse of irreps. How to name orbital spaces (e.g., docc)¶; As with basis sets, a number of names are used to refer to refer to the; quantity of electrons, virtuals, and active sub-quantities of a PSI4; calculation. All of these can be defined per irrep as above. Some common; conventions are:. nelec — The number of electrons, rarely used due to specialization of alphas and betas or soccs and doccs.; nalpha — The number of alpha electrons.; nbeta — The number of beta electrons; docc — The number of doubly-occupied orbitals; socc — The number of singly-occupied orbitals (Almost always alpha, we don’t like open-shell singlets much).; nvir — T",MatchSource.WIKI,psi4manual/1.2.1/prog_blas-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_blas-1.html
https://psicode.org/psi4manual/1.2.1/prog_blas-1.html:7601,Usability,simpl,simple,7601,",outfile);. // Block matrix should be free_blocked; free_block(A);. Important Lapack Routines¶. DSYEV: Eigenvalues and, optionally eigenvectors of a symmetric matrix. Eigenvectors take up to 10x longer than eigenvalues.; DGEEV: Eigenvalues and, optionally eigenvectors of a general matrix. Up to 10x slower than DSYEV.; DGESV: General solver (uses LU decomposition).; DGESVD: General singular value decomposition.; DGETRF: LU decomposition.; DPOTRF: Cholesky decomposition (much more stable/faster); DGETRS: Solver, given LU decomposition by DGETRF; DPOTRS: Solver, given Cholesky decomposition by DPOTRF; DGETRI: Inverse, given LU decomposition by DGETRF (Warning: it’s faster and more stable just to solve with DGETRS); DPOTRI: Inverse, given Cholesky decomposition by DPOTRF (Warning: it’s faster and more stable just to solve with DPOTRS). How to use low-level BLAS/LAPACK with psi4.core.Matrix¶; Jet’s awesome new Matrix object has a lot of simple BLAS/LAPACK built in,; but you can just as easily use the double*** array underneath if you are; careful (the outer index is the submatrix for each irrep). Here’s an; example:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33// BLAS/LAPACK; #include ""psi4/libqt/qt.h""; // Matrix; #include ""psi4/libmints/matrix.h"". using namespace psi;; ...; int n = 100;. // Allocate A Matrix (new C1 convenience constructor);; shared_ptr<Matrix> A(new Matrix(""Still A, but way cooler"", n,n));; // Get the pointer to the 0 irrep (C1 for now, it errors if you ask for too high of an index); double** A_pointer = A->get_pointer(0);. // Call the LAPACK DPOTRF to get the Cholesky factor; // Note this works in column-major order; // The result fills like:; // * * * *; // * * *; // * *; // *; // instead of the expected:; // *; // * *; // * * *; // * * * *; //; int info = C_DPOTRF('L', n, A_pointer[0], n);. // Wow that's a lot easier; A->print();. // Don't free, it's shared_ptr!. How to nam",MatchSource.WIKI,psi4manual/1.2.1/prog_blas-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_blas-1.html
https://psicode.org/psi4manual/1.2.1/prog_blas.html:4801,Availability,recover,recovery,4801,"ubstitution (just as fast as DTRMV); DGER: Rank-1 update (not wrapped yet). BLAS3; DGEMM: General Matrix-Matrix product; DTRMM: General Triangular Matrix-General Matrix product; DTRSM: Triangular Matrix-General Matrix solution via back substitution (just as fast as DTRMM); DSYMM/DSYMV calls are not appreciably faster than DGEMM calls, and should only be used in expert situations (like using the other half of the matrix for some form of other transformation).; DTRMM/DTRMV calls are 2x faster than DGEMM, and should be used where possible. LAPACK Wrappers¶; All standard LAPACK 3.2 double precision routines are provided.; LAPACK commands remain in Fortran’s “column-major” indexing, so all the; results will be transposed, and leading dimensions may have to be fiddled; with (using lda = n in both directions for square matrices is highly; recommended). An example of the former problem is a Cholesky; Decomposition: you expect to get back a lower triangular matrix L such; that L L^T = A, but this is returned in column-major order, so the actual; recovery of the matrix A with the row-major BLAS wrappers effectively; involves L^T L = A. On of the biggest consequences is in linear equations:; The input/output forcing/solution vector must be explicitly formed in; column-major indexing (each vector is placed in a C++ row, with its; entries along the C++ column). This is visualized in C++ as the transpose; of the forcing/solution vector. All routines are declared in qt.h. Each; routine is prefixed with a C_, followed by the standard Fortran name of; the routine, in capital letters. Input parameters of single primitives; (int, double, unsigned long int, char, …) are passed by value. Arrays,; including multidimensional arrays, are required to be in contiguous memory; (as provided by block_matrix, for example), and are passed by providing a; pointer to the first double or int element of the data (this is array[0]; if array is double**). All routines return an int INFO with error and;",MatchSource.WIKI,psi4manual/1.2.1/prog_blas.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_blas.html
https://psicode.org/psi4manual/1.2.1/prog_blas.html:5738,Availability,error,error,5738,"covery of the matrix A with the row-major BLAS wrappers effectively; involves L^T L = A. On of the biggest consequences is in linear equations:; The input/output forcing/solution vector must be explicitly formed in; column-major indexing (each vector is placed in a C++ row, with its; entries along the C++ column). This is visualized in C++ as the transpose; of the forcing/solution vector. All routines are declared in qt.h. Each; routine is prefixed with a C_, followed by the standard Fortran name of; the routine, in capital letters. Input parameters of single primitives; (int, double, unsigned long int, char, …) are passed by value. Arrays,; including multidimensional arrays, are required to be in contiguous memory; (as provided by block_matrix, for example), and are passed by providing a; pointer to the first double or int element of the data (this is array[0]; if array is double**). All routines return an int INFO with error and; calculation information specific to the routine, In Fortran, this is the; last argument in all LAPACK calls, but should not be provided as an; argument here. For char arguments, case is insensitive. A Cholesky; transform example is shown:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33// BLAS/LAPACK; #include ""psi4/libqt/qt.h""; // block_matrix, init_array; #include ""psi4/libciomr/libciomr.h"". using namespace psi;; ...; int n = 100;. // Allocate A matrix;; double** A = block_matrix(n,n);. // Call the LAPACK DPOTRF to get the Cholesky factor; // Note this works in column-major order; // The result fills like:; // * * * *; // * * *; // * *; // *; // instead of the expected:; // *; // * *; // * * *; // * * * *; //; int info = C_DPOTRF('L', n, A[0], n);. // A bit painful, see below; fprintf(outfile, ""A:\n"");; print_mat(A,n,n,outfile);. // Block matrix should be free_blocked; free_block(A);. Important Lapack Routines¶. DSYEV: Eigenvalues and, optionally eigenvectors of a",MatchSource.WIKI,psi4manual/1.2.1/prog_blas.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_blas.html
https://psicode.org/psi4manual/1.2.1/prog_blas.html:8210,Availability,error,errors,8210,"lver, given LU decomposition by DGETRF; DPOTRS: Solver, given Cholesky decomposition by DPOTRF; DGETRI: Inverse, given LU decomposition by DGETRF (Warning: it’s faster and more stable just to solve with DGETRS); DPOTRI: Inverse, given Cholesky decomposition by DPOTRF (Warning: it’s faster and more stable just to solve with DPOTRS). How to use low-level BLAS/LAPACK with psi4.core.Matrix¶; Jet’s awesome new Matrix object has a lot of simple BLAS/LAPACK built in,; but you can just as easily use the double*** array underneath if you are; careful (the outer index is the submatrix for each irrep). Here’s an; example:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33// BLAS/LAPACK; #include ""psi4/libqt/qt.h""; // Matrix; #include ""psi4/libmints/matrix.h"". using namespace psi;; ...; int n = 100;. // Allocate A Matrix (new C1 convenience constructor);; shared_ptr<Matrix> A(new Matrix(""Still A, but way cooler"", n,n));; // Get the pointer to the 0 irrep (C1 for now, it errors if you ask for too high of an index); double** A_pointer = A->get_pointer(0);. // Call the LAPACK DPOTRF to get the Cholesky factor; // Note this works in column-major order; // The result fills like:; // * * * *; // * * *; // * *; // *; // instead of the expected:; // *; // * *; // * * *; // * * * *; //; int info = C_DPOTRF('L', n, A_pointer[0], n);. // Wow that's a lot easier; A->print();. // Don't free, it's shared_ptr!. How to name orbital bases (e.g., AO & SO)¶; Many different working bases (the internal linear algebraic basis, not the; name of the Gaussian basis) are used within PSI4, each with a unique; and important purpose. It is critical to keep them all distinct to prevent; weird results from occurring. AO (Atomic Orbitals): Cartesian Gaussians (6D, 10F, etc.),; (L + 1)(L + 2)/2 functions per shell of angular momentum L. The; ordering of Cartesian exponents for a given L is given by the standard; ordering below (MATLAB code)",MatchSource.WIKI,psi4manual/1.2.1/prog_blas.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_blas.html
https://psicode.org/psi4manual/1.2.1/prog_blas.html:11822,Availability,redundant,redundant,11822,"ext specific. OSO (Orthogonal Symmetry-Adapted Orbitals): USOs orthogonalized by; Symmetric or Canonical Orthogonalization. The number of OSOs may be; slightly smaller than the total number of USOs, due to removal of linear; dependencies via Canonical Orthogonalization. The OSOs are rarely; encountered, as usually we go straight from USOs to MOs. MO (Molecular Orbitals): The combination of OSOs that diagonalizes; the Fock Matrix, so each basis function is a Hartree-Fock (or Kohn-Sham); molecular orbital. The number of OSOs and MOs is always the same. MOs are; orthonormal. LO (Localized Orbitals): Localized occupied orbitals, a different; combination of the occupied molecular orbitals which enhances spatial; locality. LOs do not diagonalize the occ-occ block of the Fock Matrix, but; remain orthonormal to each other and the virtual space. How to name orbital dimensions¶; There are a number of different names used to refer to the basis set size.; These may seem redundant, but they have subtly different meanings, as; detailed below.; A calculation can use either pure (5D, 7F, 9G, etc.) basis functions or; Cartesian (6D, 10F, 15G, etc.), as dictated by the input file / basis set; specification. Also, the basis can be represented in terms of atomic; orbitals (AO) or symmetry-adapted orbitals (SO). Further complications; come from the fact that a nearly linearly-dependent basis set will have; functions removed from it to prevent redundancies. With all of these; factors in mind, here are the conventions used internally:. nao — The number of atomic orbitals in Cartesian representation.; nso — The number of atomic orbitals but in the pure representation if the current basis uses pure functions, number of Cartesian AOs otherwise.; nbf — The number of basis functions, which is the same as nso.; nmo — The number of basis functions, after projecting out redundancies in the basis. When molecular symmetry is utilized, a small array of sizes per irrep is; usually allocated on the st",MatchSource.WIKI,psi4manual/1.2.1/prog_blas.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_blas.html
https://psicode.org/psi4manual/1.2.1/prog_blas.html:500,Deployability,update,update,500,"﻿. Linear Algebra in PSI4. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Programming: Using the Core Libraries. Linear Algebra in PSI4¶. How to call BLAS & LAPACK in PSI4¶; Computational chemistry is essentially linear algebra on molecular; systems, so using stable, portable, scalable, and efficient numerical; linear algebra methods in PSI4 is critical. To that end, we use BLAS1; (vector-vector operations, like dot products), BLAS2 (matrix-vector; operations, like rank-1 update), BLAS3 (matrix-matrix operations, like; matrix multiplication), and LAPACK (advanced matrix decompositions and; solutions). The methods provided by BLAS and LAPACK are standard, but the; performance of actual implementations differ greatly from one version to; another. Moreover, the standard interfaces to the libraries are Fortran,; so PSI4 provides a common set of wrappers in psi4/psi4/src/psi4/libqt/qt.h . Warning; Although block_matrix, init_array, and print_mat are still; around, their use is discouraged in favor of operations on; psi4.core.Matrix itself. The advice in these docs will catch up; shortly. BLAS Wrappers¶; BLAS wrappers are currently fully supported at double precision.; BLAS commands involving matrices are wrapped so as to be conventional; C-style “row-major” indexing, meaning that the column is the fast index; like normal. The calls to BLAS1 routines are wrapped so as to allow for operations on; vectors with more than 2^{31} elements (~16 GB, getting to be a problem).; So passing a signed or unsigned long works, though the stride arguments; must be integers. All routines are declared in qt.h. Each routine is prefixed with a; C_, followed by the standard Fortran name of the routine, in capital; letters. Input parameters of single primitives (int, double,; unsigned long int, char, …) are passed by value. Arrays,; including multidimensional arrays, are required to be in contiguous; memory (as provided by block_matrix, for example), and are passed by; pr",MatchSource.WIKI,psi4manual/1.2.1/prog_blas.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_blas.html
https://psicode.org/psi4manual/1.2.1/prog_blas.html:3798,Deployability,update,update,3798,"ix(n,n);; double** B = block_matrix(n,n);; double** C = block_matrix(n,n);. // Call the BLAS1 dot product between a and b; // n can be a ULI with the BLAS1 wrappers,; // All strides must be ints though; double dot = C_DDOT(n, a, 1, b, 1);. // Call the BLAS2 GEMV without transposition; // Note this works in row-major order; C_DGEMV('N', n, n, 1.0, A[0], n, a, 1, 0.0, b, 1);. // Call the BLAS3 GEMM without transposition; // Note this works in row-major order; C_DGEMM('N','N', n, n, n, 1.0, A[0], n, B[0], n, 0.0, C[0], n);. // Array's init'd with init_array must be free'd, not delete[]'d; free(a);; free(b);. // Block matrix should be free_blocked; free_block(A);; free_block(B);; free_block(C);. Important BLAS Routines¶. BLAS1; DDOT: dot product; DCOPY: efficient memory copy (with variable stride); DAXPY: y = y + alpha*x; DROT: Givens Rotation; DNRM2: Vector norm square. BLAS2; DGEMV: General Matrix-Vector product; DTRMV: Triangular Matrix-Vector product (2x faster, not wrapped yet); DTRSM: Triangular Matrix-Vector solution via back substitution (just as fast as DTRMV); DGER: Rank-1 update (not wrapped yet). BLAS3; DGEMM: General Matrix-Matrix product; DTRMM: General Triangular Matrix-General Matrix product; DTRSM: Triangular Matrix-General Matrix solution via back substitution (just as fast as DTRMM); DSYMM/DSYMV calls are not appreciably faster than DGEMM calls, and should only be used in expert situations (like using the other half of the matrix for some form of other transformation).; DTRMM/DTRMV calls are 2x faster than DGEMM, and should be used where possible. LAPACK Wrappers¶; All standard LAPACK 3.2 double precision routines are provided.; LAPACK commands remain in Fortran’s “column-major” indexing, so all the; results will be transposed, and leading dimensions may have to be fiddled; with (using lda = n in both directions for square matrices is highly; recommended). An example of the former problem is a Cholesky; Decomposition: you expect to get back a lower tr",MatchSource.WIKI,psi4manual/1.2.1/prog_blas.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_blas.html
https://psicode.org/psi4manual/1.2.1/prog_blas.html:15666,Deployability,update,updated,15666,"ference Dimensions¶; A orbital diagram of the nomenclature used for CI and MCSCF calculations.; Diagrammatically:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15-----------------------------------------------; CI | RAS | CAS; -----------------------------------------------; | frozen_uocc | frozen_uocc; dropped_uocc | rstr_uocc | rstr_uocc; -----------------------------------------------; | RAS IV |; | RAS III |; active | | active; | RAS II |; | RAS I |; -----------------------------------------------; dropped_docc | rstr_docc | rstr_docc; | frozen_docc | frozen_dcc; -----------------------------------------------. Notation:. uocc — Unoccupied orbitals.; active — Variable occupation orbitals.; socc — Singly occupied orbitals.; docc — Doubly occupied orbitals. Orbital spaces:. frozen_uocc — Absolutely frozen virtual orbital.; rstr_uocc — Can have rotations, no excitations into.; dropped_uocc — rstr_uocc + frozen_uocc. —– end CI active —–. RAS IV — uocc, limited number of excitations into.; RAS III — uocc, limited number of excitations into.; RAS II — docc/socc/uocc, equivalent to active in CAS.; RAS I — docc/socc/uocc, limited excitations out of. —– start CI active —–. dropped_docc — rstr_docc + frozen_docc; rstr_docc — Can have rotations, no excitations from.; frozen_docc — Absolutely frozen core orbital. Orbitals are sorted by space, irrep, eigenvalue. table of contents. Linear Algebra in PSI4; How to call BLAS & LAPACK in PSI4; BLAS Wrappers; Important BLAS Routines; LAPACK Wrappers; Important Lapack Routines. How to use low-level BLAS/LAPACK with psi4.core.Matrix; How to name orbital bases (e.g., AO & SO); How to name orbital dimensions; How to name orbital spaces (e.g., docc); Multireference Dimensions. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Programming: Using the Core Libraries. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/prog_blas.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_blas.html
https://psicode.org/psi4manual/1.2.1/prog_blas.html:315,Energy Efficiency,efficient,efficient,315,"﻿. Linear Algebra in PSI4. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Programming: Using the Core Libraries. Linear Algebra in PSI4¶. How to call BLAS & LAPACK in PSI4¶; Computational chemistry is essentially linear algebra on molecular; systems, so using stable, portable, scalable, and efficient numerical; linear algebra methods in PSI4 is critical. To that end, we use BLAS1; (vector-vector operations, like dot products), BLAS2 (matrix-vector; operations, like rank-1 update), BLAS3 (matrix-matrix operations, like; matrix multiplication), and LAPACK (advanced matrix decompositions and; solutions). The methods provided by BLAS and LAPACK are standard, but the; performance of actual implementations differ greatly from one version to; another. Moreover, the standard interfaces to the libraries are Fortran,; so PSI4 provides a common set of wrappers in psi4/psi4/src/psi4/libqt/qt.h . Warning; Although block_matrix, init_array, and print_mat are still; around, their use is discouraged in favor of operations on; psi4.core.Matrix itself. The advice in these docs will catch up; shortly. BLAS Wrappers¶; BLAS wrappers are currently fully supported at double precision.; BLAS commands involving matrices are wrapped so as to be conventional; C-style “row-major” indexing, meaning that the column is the fast index; like normal. The calls to BLAS1 routines are wrapped so as to allow for operations on; vectors with more than 2^{31} elements (~16 GB, getting to be a problem).; So passing a signed or unsigned long works, though the stride arguments; must be integers. All routines are declared in qt.h. Each routine is prefixed with a; C_, followed by the standard Fortran name of the routine, in capital; letters. Input parameters of single primitives (int, double,; unsigned long int, char, …) are passed by value. Arrays,; including multidimensional arrays, are required to be in contiguous; memory (as provided by block_matrix, for example), and are passed by; pr",MatchSource.WIKI,psi4manual/1.2.1/prog_blas.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_blas.html
https://psicode.org/psi4manual/1.2.1/prog_blas.html:3462,Energy Efficiency,efficient,efficient,3462,"de ""psi4/libciomr/libciomr.h"". using namespace psi;; ... // Allocate a,b vectors; int n = 100;; double* a = init_array(n);; double* b = init_array(n);. // Allocate A matrix;; double** A = block_matrix(n,n);; double** B = block_matrix(n,n);; double** C = block_matrix(n,n);. // Call the BLAS1 dot product between a and b; // n can be a ULI with the BLAS1 wrappers,; // All strides must be ints though; double dot = C_DDOT(n, a, 1, b, 1);. // Call the BLAS2 GEMV without transposition; // Note this works in row-major order; C_DGEMV('N', n, n, 1.0, A[0], n, a, 1, 0.0, b, 1);. // Call the BLAS3 GEMM without transposition; // Note this works in row-major order; C_DGEMM('N','N', n, n, n, 1.0, A[0], n, B[0], n, 0.0, C[0], n);. // Array's init'd with init_array must be free'd, not delete[]'d; free(a);; free(b);. // Block matrix should be free_blocked; free_block(A);; free_block(B);; free_block(C);. Important BLAS Routines¶. BLAS1; DDOT: dot product; DCOPY: efficient memory copy (with variable stride); DAXPY: y = y + alpha*x; DROT: Givens Rotation; DNRM2: Vector norm square. BLAS2; DGEMV: General Matrix-Vector product; DTRMV: Triangular Matrix-Vector product (2x faster, not wrapped yet); DTRSM: Triangular Matrix-Vector solution via back substitution (just as fast as DTRMV); DGER: Rank-1 update (not wrapped yet). BLAS3; DGEMM: General Matrix-Matrix product; DTRMM: General Triangular Matrix-General Matrix product; DTRSM: Triangular Matrix-General Matrix solution via back substitution (just as fast as DTRMM); DSYMM/DSYMV calls are not appreciably faster than DGEMM calls, and should only be used in expert situations (like using the other half of the matrix for some form of other transformation).; DTRMM/DTRMV calls are 2x faster than DGEMM, and should be used where possible. LAPACK Wrappers¶; All standard LAPACK 3.2 double precision routines are provided.; LAPACK commands remain in Fortran’s “column-major” indexing, so all the; results will be transposed, and leading dimensions may hav",MatchSource.WIKI,psi4manual/1.2.1/prog_blas.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_blas.html
https://psicode.org/psi4manual/1.2.1/prog_blas.html:10511,Energy Efficiency,adapt,adapted,10511,"is is typically the; first layer encountered, Libmints handles the transform from AO to SO; automatically. If Cartesian functions are used, the number of functions; per shell remains (L + 1)(L + 2)/2, and the ordering remains the same; as above. Note that the individual functions are not normalized for; angular momentum as in most codes: the self-overlap of a PSI4 Cartesian D; or higher function with more than one nonzero Cartesian exponent (e.g., lx; = 1, ly = 1, lz = 0) will be less than one. If Spherical Harmonics are; used, 2L + 1 real combinations of the spherical harmonics are built from; the (L+1)(L+2)/2 Cartesian Gaussians, according to H. Schlegel and M.; Frish, IJQC, 54, 83-87, 1995. Unlike Cartesian functions these functions; are all strictly normalized. Note that in PSI4, the real combinations of; spherical harmonic functions (see the paragraph below Eq. 15 in the; Schlegel paper) are ordered as: 0, 1+, 1-, 2+, 2-, …. USO (Unique Symmetry-Adapted Orbitals): Spatial symmetry-adapted; combinations of SOs, blocked according to irrep. The total number of USOs; is the same as the number of SOs, but the number of USOs within each irrep; is usually much smaller, which can lead to significant performance; improvements. Note that this basis is sometimes unfortunately referred to; as the SO basis, so it’s a bit context specific. OSO (Orthogonal Symmetry-Adapted Orbitals): USOs orthogonalized by; Symmetric or Canonical Orthogonalization. The number of OSOs may be; slightly smaller than the total number of USOs, due to removal of linear; dependencies via Canonical Orthogonalization. The OSOs are rarely; encountered, as usually we go straight from USOs to MOs. MO (Molecular Orbitals): The combination of OSOs that diagonalizes; the Fock Matrix, so each basis function is a Hartree-Fock (or Kohn-Sham); molecular orbital. The number of OSOs and MOs is always the same. MOs are; orthonormal. LO (Localized Orbitals): Localized occupied orbitals, a different; combination of t",MatchSource.WIKI,psi4manual/1.2.1/prog_blas.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_blas.html
https://psicode.org/psi4manual/1.2.1/prog_blas.html:12139,Energy Efficiency,adapt,adapted,12139,"alization. The OSOs are rarely; encountered, as usually we go straight from USOs to MOs. MO (Molecular Orbitals): The combination of OSOs that diagonalizes; the Fock Matrix, so each basis function is a Hartree-Fock (or Kohn-Sham); molecular orbital. The number of OSOs and MOs is always the same. MOs are; orthonormal. LO (Localized Orbitals): Localized occupied orbitals, a different; combination of the occupied molecular orbitals which enhances spatial; locality. LOs do not diagonalize the occ-occ block of the Fock Matrix, but; remain orthonormal to each other and the virtual space. How to name orbital dimensions¶; There are a number of different names used to refer to the basis set size.; These may seem redundant, but they have subtly different meanings, as; detailed below.; A calculation can use either pure (5D, 7F, 9G, etc.) basis functions or; Cartesian (6D, 10F, 15G, etc.), as dictated by the input file / basis set; specification. Also, the basis can be represented in terms of atomic; orbitals (AO) or symmetry-adapted orbitals (SO). Further complications; come from the fact that a nearly linearly-dependent basis set will have; functions removed from it to prevent redundancies. With all of these; factors in mind, here are the conventions used internally:. nao — The number of atomic orbitals in Cartesian representation.; nso — The number of atomic orbitals but in the pure representation if the current basis uses pure functions, number of Cartesian AOs otherwise.; nbf — The number of basis functions, which is the same as nso.; nmo — The number of basis functions, after projecting out redundancies in the basis. When molecular symmetry is utilized, a small array of sizes per irrep is; usually allocated on the stack, and is named by augmenting the name above; with a pi (per-irrep), e.g. nmopi. Note that the number of irreps is; always the singular nirrep, and that the index variable h is always used; in a for-loop traverse of irreps. How to name orbital spaces (e.g., ",MatchSource.WIKI,psi4manual/1.2.1/prog_blas.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_blas.html
https://psicode.org/psi4manual/1.2.1/prog_blas.html:12830,Energy Efficiency,allocate,allocated,12830,"ut they have subtly different meanings, as; detailed below.; A calculation can use either pure (5D, 7F, 9G, etc.) basis functions or; Cartesian (6D, 10F, 15G, etc.), as dictated by the input file / basis set; specification. Also, the basis can be represented in terms of atomic; orbitals (AO) or symmetry-adapted orbitals (SO). Further complications; come from the fact that a nearly linearly-dependent basis set will have; functions removed from it to prevent redundancies. With all of these; factors in mind, here are the conventions used internally:. nao — The number of atomic orbitals in Cartesian representation.; nso — The number of atomic orbitals but in the pure representation if the current basis uses pure functions, number of Cartesian AOs otherwise.; nbf — The number of basis functions, which is the same as nso.; nmo — The number of basis functions, after projecting out redundancies in the basis. When molecular symmetry is utilized, a small array of sizes per irrep is; usually allocated on the stack, and is named by augmenting the name above; with a pi (per-irrep), e.g. nmopi. Note that the number of irreps is; always the singular nirrep, and that the index variable h is always used; in a for-loop traverse of irreps. How to name orbital spaces (e.g., docc)¶; As with basis sets, a number of names are used to refer to refer to the; quantity of electrons, virtuals, and active sub-quantities of a PSI4; calculation. All of these can be defined per irrep as above. Some common; conventions are:. nelec — The number of electrons, rarely used due to specialization of alphas and betas or soccs and doccs.; nalpha — The number of alpha electrons.; nbeta — The number of beta electrons; docc — The number of doubly-occupied orbitals; socc — The number of singly-occupied orbitals (Almost always alpha, we don’t like open-shell singlets much).; nvir — The number of virtual orbitals. Multireference Dimensions¶; A orbital diagram of the nomenclature used for CI and MCSCF calculations",MatchSource.WIKI,psi4manual/1.2.1/prog_blas.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_blas.html
https://psicode.org/psi4manual/1.2.1/prog_blas.html:801,Integrability,interface,interfaces,801,"﻿. Linear Algebra in PSI4. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Programming: Using the Core Libraries. Linear Algebra in PSI4¶. How to call BLAS & LAPACK in PSI4¶; Computational chemistry is essentially linear algebra on molecular; systems, so using stable, portable, scalable, and efficient numerical; linear algebra methods in PSI4 is critical. To that end, we use BLAS1; (vector-vector operations, like dot products), BLAS2 (matrix-vector; operations, like rank-1 update), BLAS3 (matrix-matrix operations, like; matrix multiplication), and LAPACK (advanced matrix decompositions and; solutions). The methods provided by BLAS and LAPACK are standard, but the; performance of actual implementations differ greatly from one version to; another. Moreover, the standard interfaces to the libraries are Fortran,; so PSI4 provides a common set of wrappers in psi4/psi4/src/psi4/libqt/qt.h . Warning; Although block_matrix, init_array, and print_mat are still; around, their use is discouraged in favor of operations on; psi4.core.Matrix itself. The advice in these docs will catch up; shortly. BLAS Wrappers¶; BLAS wrappers are currently fully supported at double precision.; BLAS commands involving matrices are wrapped so as to be conventional; C-style “row-major” indexing, meaning that the column is the fast index; like normal. The calls to BLAS1 routines are wrapped so as to allow for operations on; vectors with more than 2^{31} elements (~16 GB, getting to be a problem).; So passing a signed or unsigned long works, though the stride arguments; must be integers. All routines are declared in qt.h. Each routine is prefixed with a; C_, followed by the standard Fortran name of the routine, in capital; letters. Input parameters of single primitives (int, double,; unsigned long int, char, …) are passed by value. Arrays,; including multidimensional arrays, are required to be in contiguous; memory (as provided by block_matrix, for example), and are passed by; pr",MatchSource.WIKI,psi4manual/1.2.1/prog_blas.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_blas.html
https://psicode.org/psi4manual/1.2.1/prog_blas.html:876,Integrability,wrap,wrappers,876,"﻿. Linear Algebra in PSI4. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Programming: Using the Core Libraries. Linear Algebra in PSI4¶. How to call BLAS & LAPACK in PSI4¶; Computational chemistry is essentially linear algebra on molecular; systems, so using stable, portable, scalable, and efficient numerical; linear algebra methods in PSI4 is critical. To that end, we use BLAS1; (vector-vector operations, like dot products), BLAS2 (matrix-vector; operations, like rank-1 update), BLAS3 (matrix-matrix operations, like; matrix multiplication), and LAPACK (advanced matrix decompositions and; solutions). The methods provided by BLAS and LAPACK are standard, but the; performance of actual implementations differ greatly from one version to; another. Moreover, the standard interfaces to the libraries are Fortran,; so PSI4 provides a common set of wrappers in psi4/psi4/src/psi4/libqt/qt.h . Warning; Although block_matrix, init_array, and print_mat are still; around, their use is discouraged in favor of operations on; psi4.core.Matrix itself. The advice in these docs will catch up; shortly. BLAS Wrappers¶; BLAS wrappers are currently fully supported at double precision.; BLAS commands involving matrices are wrapped so as to be conventional; C-style “row-major” indexing, meaning that the column is the fast index; like normal. The calls to BLAS1 routines are wrapped so as to allow for operations on; vectors with more than 2^{31} elements (~16 GB, getting to be a problem).; So passing a signed or unsigned long works, though the stride arguments; must be integers. All routines are declared in qt.h. Each routine is prefixed with a; C_, followed by the standard Fortran name of the routine, in capital; letters. Input parameters of single primitives (int, double,; unsigned long int, char, …) are passed by value. Arrays,; including multidimensional arrays, are required to be in contiguous; memory (as provided by block_matrix, for example), and are passed by; pr",MatchSource.WIKI,psi4manual/1.2.1/prog_blas.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_blas.html
https://psicode.org/psi4manual/1.2.1/prog_blas.html:1144,Integrability,wrap,wrappers,1144,"ow to call BLAS & LAPACK in PSI4¶; Computational chemistry is essentially linear algebra on molecular; systems, so using stable, portable, scalable, and efficient numerical; linear algebra methods in PSI4 is critical. To that end, we use BLAS1; (vector-vector operations, like dot products), BLAS2 (matrix-vector; operations, like rank-1 update), BLAS3 (matrix-matrix operations, like; matrix multiplication), and LAPACK (advanced matrix decompositions and; solutions). The methods provided by BLAS and LAPACK are standard, but the; performance of actual implementations differ greatly from one version to; another. Moreover, the standard interfaces to the libraries are Fortran,; so PSI4 provides a common set of wrappers in psi4/psi4/src/psi4/libqt/qt.h . Warning; Although block_matrix, init_array, and print_mat are still; around, their use is discouraged in favor of operations on; psi4.core.Matrix itself. The advice in these docs will catch up; shortly. BLAS Wrappers¶; BLAS wrappers are currently fully supported at double precision.; BLAS commands involving matrices are wrapped so as to be conventional; C-style “row-major” indexing, meaning that the column is the fast index; like normal. The calls to BLAS1 routines are wrapped so as to allow for operations on; vectors with more than 2^{31} elements (~16 GB, getting to be a problem).; So passing a signed or unsigned long works, though the stride arguments; must be integers. All routines are declared in qt.h. Each routine is prefixed with a; C_, followed by the standard Fortran name of the routine, in capital; letters. Input parameters of single primitives (int, double,; unsigned long int, char, …) are passed by value. Arrays,; including multidimensional arrays, are required to be in contiguous; memory (as provided by block_matrix, for example), and are passed by; providing a pointer to the first double or int element of the data (this; is array[0] if array is double**). BLAS1 routines occasionally; return values (DDOT for in",MatchSource.WIKI,psi4manual/1.2.1/prog_blas.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_blas.html
https://psicode.org/psi4manual/1.2.1/prog_blas.html:1242,Integrability,wrap,wrapped,1242," stable, portable, scalable, and efficient numerical; linear algebra methods in PSI4 is critical. To that end, we use BLAS1; (vector-vector operations, like dot products), BLAS2 (matrix-vector; operations, like rank-1 update), BLAS3 (matrix-matrix operations, like; matrix multiplication), and LAPACK (advanced matrix decompositions and; solutions). The methods provided by BLAS and LAPACK are standard, but the; performance of actual implementations differ greatly from one version to; another. Moreover, the standard interfaces to the libraries are Fortran,; so PSI4 provides a common set of wrappers in psi4/psi4/src/psi4/libqt/qt.h . Warning; Although block_matrix, init_array, and print_mat are still; around, their use is discouraged in favor of operations on; psi4.core.Matrix itself. The advice in these docs will catch up; shortly. BLAS Wrappers¶; BLAS wrappers are currently fully supported at double precision.; BLAS commands involving matrices are wrapped so as to be conventional; C-style “row-major” indexing, meaning that the column is the fast index; like normal. The calls to BLAS1 routines are wrapped so as to allow for operations on; vectors with more than 2^{31} elements (~16 GB, getting to be a problem).; So passing a signed or unsigned long works, though the stride arguments; must be integers. All routines are declared in qt.h. Each routine is prefixed with a; C_, followed by the standard Fortran name of the routine, in capital; letters. Input parameters of single primitives (int, double,; unsigned long int, char, …) are passed by value. Arrays,; including multidimensional arrays, are required to be in contiguous; memory (as provided by block_matrix, for example), and are passed by; providing a pointer to the first double or int element of the data (this; is array[0] if array is double**). BLAS1 routines occasionally; return values (DDOT for instance), BLAS2 and BLAS3 always return void.; For char arguments, case is insensitive. A few examples are provided:; 1;",MatchSource.WIKI,psi4manual/1.2.1/prog_blas.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_blas.html
https://psicode.org/psi4manual/1.2.1/prog_blas.html:1381,Integrability,rout,routines,1381,"ike dot products), BLAS2 (matrix-vector; operations, like rank-1 update), BLAS3 (matrix-matrix operations, like; matrix multiplication), and LAPACK (advanced matrix decompositions and; solutions). The methods provided by BLAS and LAPACK are standard, but the; performance of actual implementations differ greatly from one version to; another. Moreover, the standard interfaces to the libraries are Fortran,; so PSI4 provides a common set of wrappers in psi4/psi4/src/psi4/libqt/qt.h . Warning; Although block_matrix, init_array, and print_mat are still; around, their use is discouraged in favor of operations on; psi4.core.Matrix itself. The advice in these docs will catch up; shortly. BLAS Wrappers¶; BLAS wrappers are currently fully supported at double precision.; BLAS commands involving matrices are wrapped so as to be conventional; C-style “row-major” indexing, meaning that the column is the fast index; like normal. The calls to BLAS1 routines are wrapped so as to allow for operations on; vectors with more than 2^{31} elements (~16 GB, getting to be a problem).; So passing a signed or unsigned long works, though the stride arguments; must be integers. All routines are declared in qt.h. Each routine is prefixed with a; C_, followed by the standard Fortran name of the routine, in capital; letters. Input parameters of single primitives (int, double,; unsigned long int, char, …) are passed by value. Arrays,; including multidimensional arrays, are required to be in contiguous; memory (as provided by block_matrix, for example), and are passed by; providing a pointer to the first double or int element of the data (this; is array[0] if array is double**). BLAS1 routines occasionally; return values (DDOT for instance), BLAS2 and BLAS3 always return void.; For char arguments, case is insensitive. A few examples are provided:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35; 36; 37; 38; 39// BLAS/LA",MatchSource.WIKI,psi4manual/1.2.1/prog_blas.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_blas.html
https://psicode.org/psi4manual/1.2.1/prog_blas.html:1394,Integrability,wrap,wrapped,1394,"ike dot products), BLAS2 (matrix-vector; operations, like rank-1 update), BLAS3 (matrix-matrix operations, like; matrix multiplication), and LAPACK (advanced matrix decompositions and; solutions). The methods provided by BLAS and LAPACK are standard, but the; performance of actual implementations differ greatly from one version to; another. Moreover, the standard interfaces to the libraries are Fortran,; so PSI4 provides a common set of wrappers in psi4/psi4/src/psi4/libqt/qt.h . Warning; Although block_matrix, init_array, and print_mat are still; around, their use is discouraged in favor of operations on; psi4.core.Matrix itself. The advice in these docs will catch up; shortly. BLAS Wrappers¶; BLAS wrappers are currently fully supported at double precision.; BLAS commands involving matrices are wrapped so as to be conventional; C-style “row-major” indexing, meaning that the column is the fast index; like normal. The calls to BLAS1 routines are wrapped so as to allow for operations on; vectors with more than 2^{31} elements (~16 GB, getting to be a problem).; So passing a signed or unsigned long works, though the stride arguments; must be integers. All routines are declared in qt.h. Each routine is prefixed with a; C_, followed by the standard Fortran name of the routine, in capital; letters. Input parameters of single primitives (int, double,; unsigned long int, char, …) are passed by value. Arrays,; including multidimensional arrays, are required to be in contiguous; memory (as provided by block_matrix, for example), and are passed by; providing a pointer to the first double or int element of the data (this; is array[0] if array is double**). BLAS1 routines occasionally; return values (DDOT for instance), BLAS2 and BLAS3 always return void.; For char arguments, case is insensitive. A few examples are provided:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35; 36; 37; 38; 39// BLAS/LA",MatchSource.WIKI,psi4manual/1.2.1/prog_blas.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_blas.html
https://psicode.org/psi4manual/1.2.1/prog_blas.html:1606,Integrability,rout,routines,1606,"d; solutions). The methods provided by BLAS and LAPACK are standard, but the; performance of actual implementations differ greatly from one version to; another. Moreover, the standard interfaces to the libraries are Fortran,; so PSI4 provides a common set of wrappers in psi4/psi4/src/psi4/libqt/qt.h . Warning; Although block_matrix, init_array, and print_mat are still; around, their use is discouraged in favor of operations on; psi4.core.Matrix itself. The advice in these docs will catch up; shortly. BLAS Wrappers¶; BLAS wrappers are currently fully supported at double precision.; BLAS commands involving matrices are wrapped so as to be conventional; C-style “row-major” indexing, meaning that the column is the fast index; like normal. The calls to BLAS1 routines are wrapped so as to allow for operations on; vectors with more than 2^{31} elements (~16 GB, getting to be a problem).; So passing a signed or unsigned long works, though the stride arguments; must be integers. All routines are declared in qt.h. Each routine is prefixed with a; C_, followed by the standard Fortran name of the routine, in capital; letters. Input parameters of single primitives (int, double,; unsigned long int, char, …) are passed by value. Arrays,; including multidimensional arrays, are required to be in contiguous; memory (as provided by block_matrix, for example), and are passed by; providing a pointer to the first double or int element of the data (this; is array[0] if array is double**). BLAS1 routines occasionally; return values (DDOT for instance), BLAS2 and BLAS3 always return void.; For char arguments, case is insensitive. A few examples are provided:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35; 36; 37; 38; 39// BLAS/LAPACK; #include ""psi4/libqt/qt.h""; // block_matrix, init_array; #include ""psi4/libciomr/libciomr.h"". using namespace psi;; ... // Allocate a,b vectors; int n = 100;; double* a = init_a",MatchSource.WIKI,psi4manual/1.2.1/prog_blas.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_blas.html
https://psicode.org/psi4manual/1.2.1/prog_blas.html:1642,Integrability,rout,routine,1642,"e; performance of actual implementations differ greatly from one version to; another. Moreover, the standard interfaces to the libraries are Fortran,; so PSI4 provides a common set of wrappers in psi4/psi4/src/psi4/libqt/qt.h . Warning; Although block_matrix, init_array, and print_mat are still; around, their use is discouraged in favor of operations on; psi4.core.Matrix itself. The advice in these docs will catch up; shortly. BLAS Wrappers¶; BLAS wrappers are currently fully supported at double precision.; BLAS commands involving matrices are wrapped so as to be conventional; C-style “row-major” indexing, meaning that the column is the fast index; like normal. The calls to BLAS1 routines are wrapped so as to allow for operations on; vectors with more than 2^{31} elements (~16 GB, getting to be a problem).; So passing a signed or unsigned long works, though the stride arguments; must be integers. All routines are declared in qt.h. Each routine is prefixed with a; C_, followed by the standard Fortran name of the routine, in capital; letters. Input parameters of single primitives (int, double,; unsigned long int, char, …) are passed by value. Arrays,; including multidimensional arrays, are required to be in contiguous; memory (as provided by block_matrix, for example), and are passed by; providing a pointer to the first double or int element of the data (this; is array[0] if array is double**). BLAS1 routines occasionally; return values (DDOT for instance), BLAS2 and BLAS3 always return void.; For char arguments, case is insensitive. A few examples are provided:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35; 36; 37; 38; 39// BLAS/LAPACK; #include ""psi4/libqt/qt.h""; // block_matrix, init_array; #include ""psi4/libciomr/libciomr.h"". using namespace psi;; ... // Allocate a,b vectors; int n = 100;; double* a = init_array(n);; double* b = init_array(n);. // Allocate A matrix;; double** A = ",MatchSource.WIKI,psi4manual/1.2.1/prog_blas.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_blas.html
https://psicode.org/psi4manual/1.2.1/prog_blas.html:1719,Integrability,rout,routine,1719,"e; performance of actual implementations differ greatly from one version to; another. Moreover, the standard interfaces to the libraries are Fortran,; so PSI4 provides a common set of wrappers in psi4/psi4/src/psi4/libqt/qt.h . Warning; Although block_matrix, init_array, and print_mat are still; around, their use is discouraged in favor of operations on; psi4.core.Matrix itself. The advice in these docs will catch up; shortly. BLAS Wrappers¶; BLAS wrappers are currently fully supported at double precision.; BLAS commands involving matrices are wrapped so as to be conventional; C-style “row-major” indexing, meaning that the column is the fast index; like normal. The calls to BLAS1 routines are wrapped so as to allow for operations on; vectors with more than 2^{31} elements (~16 GB, getting to be a problem).; So passing a signed or unsigned long works, though the stride arguments; must be integers. All routines are declared in qt.h. Each routine is prefixed with a; C_, followed by the standard Fortran name of the routine, in capital; letters. Input parameters of single primitives (int, double,; unsigned long int, char, …) are passed by value. Arrays,; including multidimensional arrays, are required to be in contiguous; memory (as provided by block_matrix, for example), and are passed by; providing a pointer to the first double or int element of the data (this; is array[0] if array is double**). BLAS1 routines occasionally; return values (DDOT for instance), BLAS2 and BLAS3 always return void.; For char arguments, case is insensitive. A few examples are provided:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35; 36; 37; 38; 39// BLAS/LAPACK; #include ""psi4/libqt/qt.h""; // block_matrix, init_array; #include ""psi4/libciomr/libciomr.h"". using namespace psi;; ... // Allocate a,b vectors; int n = 100;; double* a = init_array(n);; double* b = init_array(n);. // Allocate A matrix;; double** A = ",MatchSource.WIKI,psi4manual/1.2.1/prog_blas.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_blas.html
https://psicode.org/psi4manual/1.2.1/prog_blas.html:2114,Integrability,rout,routines,2114,"currently fully supported at double precision.; BLAS commands involving matrices are wrapped so as to be conventional; C-style “row-major” indexing, meaning that the column is the fast index; like normal. The calls to BLAS1 routines are wrapped so as to allow for operations on; vectors with more than 2^{31} elements (~16 GB, getting to be a problem).; So passing a signed or unsigned long works, though the stride arguments; must be integers. All routines are declared in qt.h. Each routine is prefixed with a; C_, followed by the standard Fortran name of the routine, in capital; letters. Input parameters of single primitives (int, double,; unsigned long int, char, …) are passed by value. Arrays,; including multidimensional arrays, are required to be in contiguous; memory (as provided by block_matrix, for example), and are passed by; providing a pointer to the first double or int element of the data (this; is array[0] if array is double**). BLAS1 routines occasionally; return values (DDOT for instance), BLAS2 and BLAS3 always return void.; For char arguments, case is insensitive. A few examples are provided:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35; 36; 37; 38; 39// BLAS/LAPACK; #include ""psi4/libqt/qt.h""; // block_matrix, init_array; #include ""psi4/libciomr/libciomr.h"". using namespace psi;; ... // Allocate a,b vectors; int n = 100;; double* a = init_array(n);; double* b = init_array(n);. // Allocate A matrix;; double** A = block_matrix(n,n);; double** B = block_matrix(n,n);; double** C = block_matrix(n,n);. // Call the BLAS1 dot product between a and b; // n can be a ULI with the BLAS1 wrappers,; // All strides must be ints though; double dot = C_DDOT(n, a, 1, b, 1);. // Call the BLAS2 GEMV without transposition; // Note this works in row-major order; C_DGEMV('N', n, n, 1.0, A[0], n, a, 1, 0.0, b, 1);. // Call the BLAS3 GEMM without transposition; // Note this works in row-major ",MatchSource.WIKI,psi4manual/1.2.1/prog_blas.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_blas.html
https://psicode.org/psi4manual/1.2.1/prog_blas.html:2858,Integrability,wrap,wrappers,2858," including multidimensional arrays, are required to be in contiguous; memory (as provided by block_matrix, for example), and are passed by; providing a pointer to the first double or int element of the data (this; is array[0] if array is double**). BLAS1 routines occasionally; return values (DDOT for instance), BLAS2 and BLAS3 always return void.; For char arguments, case is insensitive. A few examples are provided:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35; 36; 37; 38; 39// BLAS/LAPACK; #include ""psi4/libqt/qt.h""; // block_matrix, init_array; #include ""psi4/libciomr/libciomr.h"". using namespace psi;; ... // Allocate a,b vectors; int n = 100;; double* a = init_array(n);; double* b = init_array(n);. // Allocate A matrix;; double** A = block_matrix(n,n);; double** B = block_matrix(n,n);; double** C = block_matrix(n,n);. // Call the BLAS1 dot product between a and b; // n can be a ULI with the BLAS1 wrappers,; // All strides must be ints though; double dot = C_DDOT(n, a, 1, b, 1);. // Call the BLAS2 GEMV without transposition; // Note this works in row-major order; C_DGEMV('N', n, n, 1.0, A[0], n, a, 1, 0.0, b, 1);. // Call the BLAS3 GEMM without transposition; // Note this works in row-major order; C_DGEMM('N','N', n, n, n, 1.0, A[0], n, B[0], n, 0.0, C[0], n);. // Array's init'd with init_array must be free'd, not delete[]'d; free(a);; free(b);. // Block matrix should be free_blocked; free_block(A);; free_block(B);; free_block(C);. Important BLAS Routines¶. BLAS1; DDOT: dot product; DCOPY: efficient memory copy (with variable stride); DAXPY: y = y + alpha*x; DROT: Givens Rotation; DNRM2: Vector norm square. BLAS2; DGEMV: General Matrix-Vector product; DTRMV: Triangular Matrix-Vector product (2x faster, not wrapped yet); DTRSM: Triangular Matrix-Vector solution via back substitution (just as fast as DTRMV); DGER: Rank-1 update (not wrapped yet). BLAS3; DGEMM: General Matrix-Matrix",MatchSource.WIKI,psi4manual/1.2.1/prog_blas.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_blas.html
https://psicode.org/psi4manual/1.2.1/prog_blas.html:3683,Integrability,wrap,wrapped,3683,"ix(n,n);; double** B = block_matrix(n,n);; double** C = block_matrix(n,n);. // Call the BLAS1 dot product between a and b; // n can be a ULI with the BLAS1 wrappers,; // All strides must be ints though; double dot = C_DDOT(n, a, 1, b, 1);. // Call the BLAS2 GEMV without transposition; // Note this works in row-major order; C_DGEMV('N', n, n, 1.0, A[0], n, a, 1, 0.0, b, 1);. // Call the BLAS3 GEMM without transposition; // Note this works in row-major order; C_DGEMM('N','N', n, n, n, 1.0, A[0], n, B[0], n, 0.0, C[0], n);. // Array's init'd with init_array must be free'd, not delete[]'d; free(a);; free(b);. // Block matrix should be free_blocked; free_block(A);; free_block(B);; free_block(C);. Important BLAS Routines¶. BLAS1; DDOT: dot product; DCOPY: efficient memory copy (with variable stride); DAXPY: y = y + alpha*x; DROT: Givens Rotation; DNRM2: Vector norm square. BLAS2; DGEMV: General Matrix-Vector product; DTRMV: Triangular Matrix-Vector product (2x faster, not wrapped yet); DTRSM: Triangular Matrix-Vector solution via back substitution (just as fast as DTRMV); DGER: Rank-1 update (not wrapped yet). BLAS3; DGEMM: General Matrix-Matrix product; DTRMM: General Triangular Matrix-General Matrix product; DTRSM: Triangular Matrix-General Matrix solution via back substitution (just as fast as DTRMM); DSYMM/DSYMV calls are not appreciably faster than DGEMM calls, and should only be used in expert situations (like using the other half of the matrix for some form of other transformation).; DTRMM/DTRMV calls are 2x faster than DGEMM, and should be used where possible. LAPACK Wrappers¶; All standard LAPACK 3.2 double precision routines are provided.; LAPACK commands remain in Fortran’s “column-major” indexing, so all the; results will be transposed, and leading dimensions may have to be fiddled; with (using lda = n in both directions for square matrices is highly; recommended). An example of the former problem is a Cholesky; Decomposition: you expect to get back a lower tr",MatchSource.WIKI,psi4manual/1.2.1/prog_blas.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_blas.html
https://psicode.org/psi4manual/1.2.1/prog_blas.html:3810,Integrability,wrap,wrapped,3810,"ix(n,n);; double** B = block_matrix(n,n);; double** C = block_matrix(n,n);. // Call the BLAS1 dot product between a and b; // n can be a ULI with the BLAS1 wrappers,; // All strides must be ints though; double dot = C_DDOT(n, a, 1, b, 1);. // Call the BLAS2 GEMV without transposition; // Note this works in row-major order; C_DGEMV('N', n, n, 1.0, A[0], n, a, 1, 0.0, b, 1);. // Call the BLAS3 GEMM without transposition; // Note this works in row-major order; C_DGEMM('N','N', n, n, n, 1.0, A[0], n, B[0], n, 0.0, C[0], n);. // Array's init'd with init_array must be free'd, not delete[]'d; free(a);; free(b);. // Block matrix should be free_blocked; free_block(A);; free_block(B);; free_block(C);. Important BLAS Routines¶. BLAS1; DDOT: dot product; DCOPY: efficient memory copy (with variable stride); DAXPY: y = y + alpha*x; DROT: Givens Rotation; DNRM2: Vector norm square. BLAS2; DGEMV: General Matrix-Vector product; DTRMV: Triangular Matrix-Vector product (2x faster, not wrapped yet); DTRSM: Triangular Matrix-Vector solution via back substitution (just as fast as DTRMV); DGER: Rank-1 update (not wrapped yet). BLAS3; DGEMM: General Matrix-Matrix product; DTRMM: General Triangular Matrix-General Matrix product; DTRSM: Triangular Matrix-General Matrix solution via back substitution (just as fast as DTRMM); DSYMM/DSYMV calls are not appreciably faster than DGEMM calls, and should only be used in expert situations (like using the other half of the matrix for some form of other transformation).; DTRMM/DTRMV calls are 2x faster than DGEMM, and should be used where possible. LAPACK Wrappers¶; All standard LAPACK 3.2 double precision routines are provided.; LAPACK commands remain in Fortran’s “column-major” indexing, so all the; results will be transposed, and leading dimensions may have to be fiddled; with (using lda = n in both directions for square matrices is highly; recommended). An example of the former problem is a Cholesky; Decomposition: you expect to get back a lower tr",MatchSource.WIKI,psi4manual/1.2.1/prog_blas.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_blas.html
https://psicode.org/psi4manual/1.2.1/prog_blas.html:4350,Integrability,rout,routines,4350,"ed; free_block(A);; free_block(B);; free_block(C);. Important BLAS Routines¶. BLAS1; DDOT: dot product; DCOPY: efficient memory copy (with variable stride); DAXPY: y = y + alpha*x; DROT: Givens Rotation; DNRM2: Vector norm square. BLAS2; DGEMV: General Matrix-Vector product; DTRMV: Triangular Matrix-Vector product (2x faster, not wrapped yet); DTRSM: Triangular Matrix-Vector solution via back substitution (just as fast as DTRMV); DGER: Rank-1 update (not wrapped yet). BLAS3; DGEMM: General Matrix-Matrix product; DTRMM: General Triangular Matrix-General Matrix product; DTRSM: Triangular Matrix-General Matrix solution via back substitution (just as fast as DTRMM); DSYMM/DSYMV calls are not appreciably faster than DGEMM calls, and should only be used in expert situations (like using the other half of the matrix for some form of other transformation).; DTRMM/DTRMV calls are 2x faster than DGEMM, and should be used where possible. LAPACK Wrappers¶; All standard LAPACK 3.2 double precision routines are provided.; LAPACK commands remain in Fortran’s “column-major” indexing, so all the; results will be transposed, and leading dimensions may have to be fiddled; with (using lda = n in both directions for square matrices is highly; recommended). An example of the former problem is a Cholesky; Decomposition: you expect to get back a lower triangular matrix L such; that L L^T = A, but this is returned in column-major order, so the actual; recovery of the matrix A with the row-major BLAS wrappers effectively; involves L^T L = A. On of the biggest consequences is in linear equations:; The input/output forcing/solution vector must be explicitly formed in; column-major indexing (each vector is placed in a C++ row, with its; entries along the C++ column). This is visualized in C++ as the transpose; of the forcing/solution vector. All routines are declared in qt.h. Each; routine is prefixed with a C_, followed by the standard Fortran name of; the routine, in capital letters. Input para",MatchSource.WIKI,psi4manual/1.2.1/prog_blas.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_blas.html
https://psicode.org/psi4manual/1.2.1/prog_blas.html:4850,Integrability,wrap,wrappers,4850,"ubstitution (just as fast as DTRMV); DGER: Rank-1 update (not wrapped yet). BLAS3; DGEMM: General Matrix-Matrix product; DTRMM: General Triangular Matrix-General Matrix product; DTRSM: Triangular Matrix-General Matrix solution via back substitution (just as fast as DTRMM); DSYMM/DSYMV calls are not appreciably faster than DGEMM calls, and should only be used in expert situations (like using the other half of the matrix for some form of other transformation).; DTRMM/DTRMV calls are 2x faster than DGEMM, and should be used where possible. LAPACK Wrappers¶; All standard LAPACK 3.2 double precision routines are provided.; LAPACK commands remain in Fortran’s “column-major” indexing, so all the; results will be transposed, and leading dimensions may have to be fiddled; with (using lda = n in both directions for square matrices is highly; recommended). An example of the former problem is a Cholesky; Decomposition: you expect to get back a lower triangular matrix L such; that L L^T = A, but this is returned in column-major order, so the actual; recovery of the matrix A with the row-major BLAS wrappers effectively; involves L^T L = A. On of the biggest consequences is in linear equations:; The input/output forcing/solution vector must be explicitly formed in; column-major indexing (each vector is placed in a C++ row, with its; entries along the C++ column). This is visualized in C++ as the transpose; of the forcing/solution vector. All routines are declared in qt.h. Each; routine is prefixed with a C_, followed by the standard Fortran name of; the routine, in capital letters. Input parameters of single primitives; (int, double, unsigned long int, char, …) are passed by value. Arrays,; including multidimensional arrays, are required to be in contiguous memory; (as provided by block_matrix, for example), and are passed by providing a; pointer to the first double or int element of the data (this is array[0]; if array is double**). All routines return an int INFO with error and;",MatchSource.WIKI,psi4manual/1.2.1/prog_blas.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_blas.html
https://psicode.org/psi4manual/1.2.1/prog_blas.html:5199,Integrability,rout,routines,5199,"; DTRMM/DTRMV calls are 2x faster than DGEMM, and should be used where possible. LAPACK Wrappers¶; All standard LAPACK 3.2 double precision routines are provided.; LAPACK commands remain in Fortran’s “column-major” indexing, so all the; results will be transposed, and leading dimensions may have to be fiddled; with (using lda = n in both directions for square matrices is highly; recommended). An example of the former problem is a Cholesky; Decomposition: you expect to get back a lower triangular matrix L such; that L L^T = A, but this is returned in column-major order, so the actual; recovery of the matrix A with the row-major BLAS wrappers effectively; involves L^T L = A. On of the biggest consequences is in linear equations:; The input/output forcing/solution vector must be explicitly formed in; column-major indexing (each vector is placed in a C++ row, with its; entries along the C++ column). This is visualized in C++ as the transpose; of the forcing/solution vector. All routines are declared in qt.h. Each; routine is prefixed with a C_, followed by the standard Fortran name of; the routine, in capital letters. Input parameters of single primitives; (int, double, unsigned long int, char, …) are passed by value. Arrays,; including multidimensional arrays, are required to be in contiguous memory; (as provided by block_matrix, for example), and are passed by providing a; pointer to the first double or int element of the data (this is array[0]; if array is double**). All routines return an int INFO with error and; calculation information specific to the routine, In Fortran, this is the; last argument in all LAPACK calls, but should not be provided as an; argument here. For char arguments, case is insensitive. A Cholesky; transform example is shown:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33// BLAS/LAPACK; #include ""psi4/libqt/qt.h""; // block_matrix, init_array; #include ""psi4/libciomr/libc",MatchSource.WIKI,psi4manual/1.2.1/prog_blas.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_blas.html
https://psicode.org/psi4manual/1.2.1/prog_blas.html:5236,Integrability,rout,routine,5236,"ible. LAPACK Wrappers¶; All standard LAPACK 3.2 double precision routines are provided.; LAPACK commands remain in Fortran’s “column-major” indexing, so all the; results will be transposed, and leading dimensions may have to be fiddled; with (using lda = n in both directions for square matrices is highly; recommended). An example of the former problem is a Cholesky; Decomposition: you expect to get back a lower triangular matrix L such; that L L^T = A, but this is returned in column-major order, so the actual; recovery of the matrix A with the row-major BLAS wrappers effectively; involves L^T L = A. On of the biggest consequences is in linear equations:; The input/output forcing/solution vector must be explicitly formed in; column-major indexing (each vector is placed in a C++ row, with its; entries along the C++ column). This is visualized in C++ as the transpose; of the forcing/solution vector. All routines are declared in qt.h. Each; routine is prefixed with a C_, followed by the standard Fortran name of; the routine, in capital letters. Input parameters of single primitives; (int, double, unsigned long int, char, …) are passed by value. Arrays,; including multidimensional arrays, are required to be in contiguous memory; (as provided by block_matrix, for example), and are passed by providing a; pointer to the first double or int element of the data (this is array[0]; if array is double**). All routines return an int INFO with error and; calculation information specific to the routine, In Fortran, this is the; last argument in all LAPACK calls, but should not be provided as an; argument here. For char arguments, case is insensitive. A Cholesky; transform example is shown:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33// BLAS/LAPACK; #include ""psi4/libqt/qt.h""; // block_matrix, init_array; #include ""psi4/libciomr/libciomr.h"". using namespace psi;; ...; int n = 100;. // Allocate A matrix;; d",MatchSource.WIKI,psi4manual/1.2.1/prog_blas.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_blas.html
https://psicode.org/psi4manual/1.2.1/prog_blas.html:5313,Integrability,rout,routine,5313,"ible. LAPACK Wrappers¶; All standard LAPACK 3.2 double precision routines are provided.; LAPACK commands remain in Fortran’s “column-major” indexing, so all the; results will be transposed, and leading dimensions may have to be fiddled; with (using lda = n in both directions for square matrices is highly; recommended). An example of the former problem is a Cholesky; Decomposition: you expect to get back a lower triangular matrix L such; that L L^T = A, but this is returned in column-major order, so the actual; recovery of the matrix A with the row-major BLAS wrappers effectively; involves L^T L = A. On of the biggest consequences is in linear equations:; The input/output forcing/solution vector must be explicitly formed in; column-major indexing (each vector is placed in a C++ row, with its; entries along the C++ column). This is visualized in C++ as the transpose; of the forcing/solution vector. All routines are declared in qt.h. Each; routine is prefixed with a C_, followed by the standard Fortran name of; the routine, in capital letters. Input parameters of single primitives; (int, double, unsigned long int, char, …) are passed by value. Arrays,; including multidimensional arrays, are required to be in contiguous memory; (as provided by block_matrix, for example), and are passed by providing a; pointer to the first double or int element of the data (this is array[0]; if array is double**). All routines return an int INFO with error and; calculation information specific to the routine, In Fortran, this is the; last argument in all LAPACK calls, but should not be provided as an; argument here. For char arguments, case is insensitive. A Cholesky; transform example is shown:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33// BLAS/LAPACK; #include ""psi4/libqt/qt.h""; // block_matrix, init_array; #include ""psi4/libciomr/libciomr.h"". using namespace psi;; ...; int n = 100;. // Allocate A matrix;; d",MatchSource.WIKI,psi4manual/1.2.1/prog_blas.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_blas.html
https://psicode.org/psi4manual/1.2.1/prog_blas.html:5705,Integrability,rout,routines,5705,"covery of the matrix A with the row-major BLAS wrappers effectively; involves L^T L = A. On of the biggest consequences is in linear equations:; The input/output forcing/solution vector must be explicitly formed in; column-major indexing (each vector is placed in a C++ row, with its; entries along the C++ column). This is visualized in C++ as the transpose; of the forcing/solution vector. All routines are declared in qt.h. Each; routine is prefixed with a C_, followed by the standard Fortran name of; the routine, in capital letters. Input parameters of single primitives; (int, double, unsigned long int, char, …) are passed by value. Arrays,; including multidimensional arrays, are required to be in contiguous memory; (as provided by block_matrix, for example), and are passed by providing a; pointer to the first double or int element of the data (this is array[0]; if array is double**). All routines return an int INFO with error and; calculation information specific to the routine, In Fortran, this is the; last argument in all LAPACK calls, but should not be provided as an; argument here. For char arguments, case is insensitive. A Cholesky; transform example is shown:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33// BLAS/LAPACK; #include ""psi4/libqt/qt.h""; // block_matrix, init_array; #include ""psi4/libciomr/libciomr.h"". using namespace psi;; ...; int n = 100;. // Allocate A matrix;; double** A = block_matrix(n,n);. // Call the LAPACK DPOTRF to get the Cholesky factor; // Note this works in column-major order; // The result fills like:; // * * * *; // * * *; // * *; // *; // instead of the expected:; // *; // * *; // * * *; // * * * *; //; int info = C_DPOTRF('L', n, A[0], n);. // A bit painful, see below; fprintf(outfile, ""A:\n"");; print_mat(A,n,n,outfile);. // Block matrix should be free_blocked; free_block(A);. Important Lapack Routines¶. DSYEV: Eigenvalues and, optionally eigenvectors of a",MatchSource.WIKI,psi4manual/1.2.1/prog_blas.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_blas.html
https://psicode.org/psi4manual/1.2.1/prog_blas.html:5789,Integrability,rout,routine,5789,"covery of the matrix A with the row-major BLAS wrappers effectively; involves L^T L = A. On of the biggest consequences is in linear equations:; The input/output forcing/solution vector must be explicitly formed in; column-major indexing (each vector is placed in a C++ row, with its; entries along the C++ column). This is visualized in C++ as the transpose; of the forcing/solution vector. All routines are declared in qt.h. Each; routine is prefixed with a C_, followed by the standard Fortran name of; the routine, in capital letters. Input parameters of single primitives; (int, double, unsigned long int, char, …) are passed by value. Arrays,; including multidimensional arrays, are required to be in contiguous memory; (as provided by block_matrix, for example), and are passed by providing a; pointer to the first double or int element of the data (this is array[0]; if array is double**). All routines return an int INFO with error and; calculation information specific to the routine, In Fortran, this is the; last argument in all LAPACK calls, but should not be provided as an; argument here. For char arguments, case is insensitive. A Cholesky; transform example is shown:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33// BLAS/LAPACK; #include ""psi4/libqt/qt.h""; // block_matrix, init_array; #include ""psi4/libciomr/libciomr.h"". using namespace psi;; ...; int n = 100;. // Allocate A matrix;; double** A = block_matrix(n,n);. // Call the LAPACK DPOTRF to get the Cholesky factor; // Note this works in column-major order; // The result fills like:; // * * * *; // * * *; // * *; // *; // instead of the expected:; // *; // * *; // * * *; // * * * *; //; int info = C_DPOTRF('L', n, A[0], n);. // A bit painful, see below; fprintf(outfile, ""A:\n"");; print_mat(A,n,n,outfile);. // Block matrix should be free_blocked; free_block(A);. Important Lapack Routines¶. DSYEV: Eigenvalues and, optionally eigenvectors of a",MatchSource.WIKI,psi4manual/1.2.1/prog_blas.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_blas.html
https://psicode.org/psi4manual/1.2.1/prog_blas.html:11074,Integrability,depend,dependencies,11074,"L + 1 real combinations of the spherical harmonics are built from; the (L+1)(L+2)/2 Cartesian Gaussians, according to H. Schlegel and M.; Frish, IJQC, 54, 83-87, 1995. Unlike Cartesian functions these functions; are all strictly normalized. Note that in PSI4, the real combinations of; spherical harmonic functions (see the paragraph below Eq. 15 in the; Schlegel paper) are ordered as: 0, 1+, 1-, 2+, 2-, …. USO (Unique Symmetry-Adapted Orbitals): Spatial symmetry-adapted; combinations of SOs, blocked according to irrep. The total number of USOs; is the same as the number of SOs, but the number of USOs within each irrep; is usually much smaller, which can lead to significant performance; improvements. Note that this basis is sometimes unfortunately referred to; as the SO basis, so it’s a bit context specific. OSO (Orthogonal Symmetry-Adapted Orbitals): USOs orthogonalized by; Symmetric or Canonical Orthogonalization. The number of OSOs may be; slightly smaller than the total number of USOs, due to removal of linear; dependencies via Canonical Orthogonalization. The OSOs are rarely; encountered, as usually we go straight from USOs to MOs. MO (Molecular Orbitals): The combination of OSOs that diagonalizes; the Fock Matrix, so each basis function is a Hartree-Fock (or Kohn-Sham); molecular orbital. The number of OSOs and MOs is always the same. MOs are; orthonormal. LO (Localized Orbitals): Localized occupied orbitals, a different; combination of the occupied molecular orbitals which enhances spatial; locality. LOs do not diagonalize the occ-occ block of the Fock Matrix, but; remain orthonormal to each other and the virtual space. How to name orbital dimensions¶; There are a number of different names used to refer to the basis set size.; These may seem redundant, but they have subtly different meanings, as; detailed below.; A calculation can use either pure (5D, 7F, 9G, etc.) basis functions or; Cartesian (6D, 10F, 15G, etc.), as dictated by the input file / basis set; spe",MatchSource.WIKI,psi4manual/1.2.1/prog_blas.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_blas.html
https://psicode.org/psi4manual/1.2.1/prog_blas.html:12227,Integrability,depend,dependent,12227,"tion of OSOs that diagonalizes; the Fock Matrix, so each basis function is a Hartree-Fock (or Kohn-Sham); molecular orbital. The number of OSOs and MOs is always the same. MOs are; orthonormal. LO (Localized Orbitals): Localized occupied orbitals, a different; combination of the occupied molecular orbitals which enhances spatial; locality. LOs do not diagonalize the occ-occ block of the Fock Matrix, but; remain orthonormal to each other and the virtual space. How to name orbital dimensions¶; There are a number of different names used to refer to the basis set size.; These may seem redundant, but they have subtly different meanings, as; detailed below.; A calculation can use either pure (5D, 7F, 9G, etc.) basis functions or; Cartesian (6D, 10F, 15G, etc.), as dictated by the input file / basis set; specification. Also, the basis can be represented in terms of atomic; orbitals (AO) or symmetry-adapted orbitals (SO). Further complications; come from the fact that a nearly linearly-dependent basis set will have; functions removed from it to prevent redundancies. With all of these; factors in mind, here are the conventions used internally:. nao — The number of atomic orbitals in Cartesian representation.; nso — The number of atomic orbitals but in the pure representation if the current basis uses pure functions, number of Cartesian AOs otherwise.; nbf — The number of basis functions, which is the same as nso.; nmo — The number of basis functions, after projecting out redundancies in the basis. When molecular symmetry is utilized, a small array of sizes per irrep is; usually allocated on the stack, and is named by augmenting the name above; with a pi (per-irrep), e.g. nmopi. Note that the number of irreps is; always the singular nirrep, and that the index variable h is always used; in a for-loop traverse of irreps. How to name orbital spaces (e.g., docc)¶; As with basis sets, a number of names are used to refer to refer to the; quantity of electrons, virtuals, and active s",MatchSource.WIKI,psi4manual/1.2.1/prog_blas.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_blas.html
https://psicode.org/psi4manual/1.2.1/prog_blas.html:291,Modifiability,portab,portable,291,"﻿. Linear Algebra in PSI4. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Programming: Using the Core Libraries. Linear Algebra in PSI4¶. How to call BLAS & LAPACK in PSI4¶; Computational chemistry is essentially linear algebra on molecular; systems, so using stable, portable, scalable, and efficient numerical; linear algebra methods in PSI4 is critical. To that end, we use BLAS1; (vector-vector operations, like dot products), BLAS2 (matrix-vector; operations, like rank-1 update), BLAS3 (matrix-matrix operations, like; matrix multiplication), and LAPACK (advanced matrix decompositions and; solutions). The methods provided by BLAS and LAPACK are standard, but the; performance of actual implementations differ greatly from one version to; another. Moreover, the standard interfaces to the libraries are Fortran,; so PSI4 provides a common set of wrappers in psi4/psi4/src/psi4/libqt/qt.h . Warning; Although block_matrix, init_array, and print_mat are still; around, their use is discouraged in favor of operations on; psi4.core.Matrix itself. The advice in these docs will catch up; shortly. BLAS Wrappers¶; BLAS wrappers are currently fully supported at double precision.; BLAS commands involving matrices are wrapped so as to be conventional; C-style “row-major” indexing, meaning that the column is the fast index; like normal. The calls to BLAS1 routines are wrapped so as to allow for operations on; vectors with more than 2^{31} elements (~16 GB, getting to be a problem).; So passing a signed or unsigned long works, though the stride arguments; must be integers. All routines are declared in qt.h. Each routine is prefixed with a; C_, followed by the standard Fortran name of the routine, in capital; letters. Input parameters of single primitives (int, double,; unsigned long int, char, …) are passed by value. Arrays,; including multidimensional arrays, are required to be in contiguous; memory (as provided by block_matrix, for example), and are passed by; pr",MatchSource.WIKI,psi4manual/1.2.1/prog_blas.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_blas.html
https://psicode.org/psi4manual/1.2.1/prog_blas.html:3490,Modifiability,variab,variable,3490,"de ""psi4/libciomr/libciomr.h"". using namespace psi;; ... // Allocate a,b vectors; int n = 100;; double* a = init_array(n);; double* b = init_array(n);. // Allocate A matrix;; double** A = block_matrix(n,n);; double** B = block_matrix(n,n);; double** C = block_matrix(n,n);. // Call the BLAS1 dot product between a and b; // n can be a ULI with the BLAS1 wrappers,; // All strides must be ints though; double dot = C_DDOT(n, a, 1, b, 1);. // Call the BLAS2 GEMV without transposition; // Note this works in row-major order; C_DGEMV('N', n, n, 1.0, A[0], n, a, 1, 0.0, b, 1);. // Call the BLAS3 GEMM without transposition; // Note this works in row-major order; C_DGEMM('N','N', n, n, n, 1.0, A[0], n, B[0], n, 0.0, C[0], n);. // Array's init'd with init_array must be free'd, not delete[]'d; free(a);; free(b);. // Block matrix should be free_blocked; free_block(A);; free_block(B);; free_block(C);. Important BLAS Routines¶. BLAS1; DDOT: dot product; DCOPY: efficient memory copy (with variable stride); DAXPY: y = y + alpha*x; DROT: Givens Rotation; DNRM2: Vector norm square. BLAS2; DGEMV: General Matrix-Vector product; DTRMV: Triangular Matrix-Vector product (2x faster, not wrapped yet); DTRSM: Triangular Matrix-Vector solution via back substitution (just as fast as DTRMV); DGER: Rank-1 update (not wrapped yet). BLAS3; DGEMM: General Matrix-Matrix product; DTRMM: General Triangular Matrix-General Matrix product; DTRSM: Triangular Matrix-General Matrix solution via back substitution (just as fast as DTRMM); DSYMM/DSYMV calls are not appreciably faster than DGEMM calls, and should only be used in expert situations (like using the other half of the matrix for some form of other transformation).; DTRMM/DTRMV calls are 2x faster than DGEMM, and should be used where possible. LAPACK Wrappers¶; All standard LAPACK 3.2 double precision routines are provided.; LAPACK commands remain in Fortran’s “column-major” indexing, so all the; results will be transposed, and leading dimensions may hav",MatchSource.WIKI,psi4manual/1.2.1/prog_blas.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_blas.html
https://psicode.org/psi4manual/1.2.1/prog_blas.html:10511,Modifiability,adapt,adapted,10511,"is is typically the; first layer encountered, Libmints handles the transform from AO to SO; automatically. If Cartesian functions are used, the number of functions; per shell remains (L + 1)(L + 2)/2, and the ordering remains the same; as above. Note that the individual functions are not normalized for; angular momentum as in most codes: the self-overlap of a PSI4 Cartesian D; or higher function with more than one nonzero Cartesian exponent (e.g., lx; = 1, ly = 1, lz = 0) will be less than one. If Spherical Harmonics are; used, 2L + 1 real combinations of the spherical harmonics are built from; the (L+1)(L+2)/2 Cartesian Gaussians, according to H. Schlegel and M.; Frish, IJQC, 54, 83-87, 1995. Unlike Cartesian functions these functions; are all strictly normalized. Note that in PSI4, the real combinations of; spherical harmonic functions (see the paragraph below Eq. 15 in the; Schlegel paper) are ordered as: 0, 1+, 1-, 2+, 2-, …. USO (Unique Symmetry-Adapted Orbitals): Spatial symmetry-adapted; combinations of SOs, blocked according to irrep. The total number of USOs; is the same as the number of SOs, but the number of USOs within each irrep; is usually much smaller, which can lead to significant performance; improvements. Note that this basis is sometimes unfortunately referred to; as the SO basis, so it’s a bit context specific. OSO (Orthogonal Symmetry-Adapted Orbitals): USOs orthogonalized by; Symmetric or Canonical Orthogonalization. The number of OSOs may be; slightly smaller than the total number of USOs, due to removal of linear; dependencies via Canonical Orthogonalization. The OSOs are rarely; encountered, as usually we go straight from USOs to MOs. MO (Molecular Orbitals): The combination of OSOs that diagonalizes; the Fock Matrix, so each basis function is a Hartree-Fock (or Kohn-Sham); molecular orbital. The number of OSOs and MOs is always the same. MOs are; orthonormal. LO (Localized Orbitals): Localized occupied orbitals, a different; combination of t",MatchSource.WIKI,psi4manual/1.2.1/prog_blas.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_blas.html
https://psicode.org/psi4manual/1.2.1/prog_blas.html:11548,Modifiability,enhance,enhances,11548," symmetry-adapted; combinations of SOs, blocked according to irrep. The total number of USOs; is the same as the number of SOs, but the number of USOs within each irrep; is usually much smaller, which can lead to significant performance; improvements. Note that this basis is sometimes unfortunately referred to; as the SO basis, so it’s a bit context specific. OSO (Orthogonal Symmetry-Adapted Orbitals): USOs orthogonalized by; Symmetric or Canonical Orthogonalization. The number of OSOs may be; slightly smaller than the total number of USOs, due to removal of linear; dependencies via Canonical Orthogonalization. The OSOs are rarely; encountered, as usually we go straight from USOs to MOs. MO (Molecular Orbitals): The combination of OSOs that diagonalizes; the Fock Matrix, so each basis function is a Hartree-Fock (or Kohn-Sham); molecular orbital. The number of OSOs and MOs is always the same. MOs are; orthonormal. LO (Localized Orbitals): Localized occupied orbitals, a different; combination of the occupied molecular orbitals which enhances spatial; locality. LOs do not diagonalize the occ-occ block of the Fock Matrix, but; remain orthonormal to each other and the virtual space. How to name orbital dimensions¶; There are a number of different names used to refer to the basis set size.; These may seem redundant, but they have subtly different meanings, as; detailed below.; A calculation can use either pure (5D, 7F, 9G, etc.) basis functions or; Cartesian (6D, 10F, 15G, etc.), as dictated by the input file / basis set; specification. Also, the basis can be represented in terms of atomic; orbitals (AO) or symmetry-adapted orbitals (SO). Further complications; come from the fact that a nearly linearly-dependent basis set will have; functions removed from it to prevent redundancies. With all of these; factors in mind, here are the conventions used internally:. nao — The number of atomic orbitals in Cartesian representation.; nso — The number of atomic orbitals but in the ",MatchSource.WIKI,psi4manual/1.2.1/prog_blas.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_blas.html
https://psicode.org/psi4manual/1.2.1/prog_blas.html:12139,Modifiability,adapt,adapted,12139,"alization. The OSOs are rarely; encountered, as usually we go straight from USOs to MOs. MO (Molecular Orbitals): The combination of OSOs that diagonalizes; the Fock Matrix, so each basis function is a Hartree-Fock (or Kohn-Sham); molecular orbital. The number of OSOs and MOs is always the same. MOs are; orthonormal. LO (Localized Orbitals): Localized occupied orbitals, a different; combination of the occupied molecular orbitals which enhances spatial; locality. LOs do not diagonalize the occ-occ block of the Fock Matrix, but; remain orthonormal to each other and the virtual space. How to name orbital dimensions¶; There are a number of different names used to refer to the basis set size.; These may seem redundant, but they have subtly different meanings, as; detailed below.; A calculation can use either pure (5D, 7F, 9G, etc.) basis functions or; Cartesian (6D, 10F, 15G, etc.), as dictated by the input file / basis set; specification. Also, the basis can be represented in terms of atomic; orbitals (AO) or symmetry-adapted orbitals (SO). Further complications; come from the fact that a nearly linearly-dependent basis set will have; functions removed from it to prevent redundancies. With all of these; factors in mind, here are the conventions used internally:. nao — The number of atomic orbitals in Cartesian representation.; nso — The number of atomic orbitals but in the pure representation if the current basis uses pure functions, number of Cartesian AOs otherwise.; nbf — The number of basis functions, which is the same as nso.; nmo — The number of basis functions, after projecting out redundancies in the basis. When molecular symmetry is utilized, a small array of sizes per irrep is; usually allocated on the stack, and is named by augmenting the name above; with a pi (per-irrep), e.g. nmopi. Note that the number of irreps is; always the singular nirrep, and that the index variable h is always used; in a for-loop traverse of irreps. How to name orbital spaces (e.g., ",MatchSource.WIKI,psi4manual/1.2.1/prog_blas.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_blas.html
https://psicode.org/psi4manual/1.2.1/prog_blas.html:13014,Modifiability,variab,variable,13014," dictated by the input file / basis set; specification. Also, the basis can be represented in terms of atomic; orbitals (AO) or symmetry-adapted orbitals (SO). Further complications; come from the fact that a nearly linearly-dependent basis set will have; functions removed from it to prevent redundancies. With all of these; factors in mind, here are the conventions used internally:. nao — The number of atomic orbitals in Cartesian representation.; nso — The number of atomic orbitals but in the pure representation if the current basis uses pure functions, number of Cartesian AOs otherwise.; nbf — The number of basis functions, which is the same as nso.; nmo — The number of basis functions, after projecting out redundancies in the basis. When molecular symmetry is utilized, a small array of sizes per irrep is; usually allocated on the stack, and is named by augmenting the name above; with a pi (per-irrep), e.g. nmopi. Note that the number of irreps is; always the singular nirrep, and that the index variable h is always used; in a for-loop traverse of irreps. How to name orbital spaces (e.g., docc)¶; As with basis sets, a number of names are used to refer to refer to the; quantity of electrons, virtuals, and active sub-quantities of a PSI4; calculation. All of these can be defined per irrep as above. Some common; conventions are:. nelec — The number of electrons, rarely used due to specialization of alphas and betas or soccs and doccs.; nalpha — The number of alpha electrons.; nbeta — The number of beta electrons; docc — The number of doubly-occupied orbitals; socc — The number of singly-occupied orbitals (Almost always alpha, we don’t like open-shell singlets much).; nvir — The number of virtual orbitals. Multireference Dimensions¶; A orbital diagram of the nomenclature used for CI and MCSCF calculations.; Diagrammatically:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15-----------------------------------------------; CI | RAS | CAS; --------------------------------",MatchSource.WIKI,psi4manual/1.2.1/prog_blas.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_blas.html
https://psicode.org/psi4manual/1.2.1/prog_blas.html:301,Performance,scalab,scalable,301,"﻿. Linear Algebra in PSI4. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Programming: Using the Core Libraries. Linear Algebra in PSI4¶. How to call BLAS & LAPACK in PSI4¶; Computational chemistry is essentially linear algebra on molecular; systems, so using stable, portable, scalable, and efficient numerical; linear algebra methods in PSI4 is critical. To that end, we use BLAS1; (vector-vector operations, like dot products), BLAS2 (matrix-vector; operations, like rank-1 update), BLAS3 (matrix-matrix operations, like; matrix multiplication), and LAPACK (advanced matrix decompositions and; solutions). The methods provided by BLAS and LAPACK are standard, but the; performance of actual implementations differ greatly from one version to; another. Moreover, the standard interfaces to the libraries are Fortran,; so PSI4 provides a common set of wrappers in psi4/psi4/src/psi4/libqt/qt.h . Warning; Although block_matrix, init_array, and print_mat are still; around, their use is discouraged in favor of operations on; psi4.core.Matrix itself. The advice in these docs will catch up; shortly. BLAS Wrappers¶; BLAS wrappers are currently fully supported at double precision.; BLAS commands involving matrices are wrapped so as to be conventional; C-style “row-major” indexing, meaning that the column is the fast index; like normal. The calls to BLAS1 routines are wrapped so as to allow for operations on; vectors with more than 2^{31} elements (~16 GB, getting to be a problem).; So passing a signed or unsigned long works, though the stride arguments; must be integers. All routines are declared in qt.h. Each routine is prefixed with a; C_, followed by the standard Fortran name of the routine, in capital; letters. Input parameters of single primitives (int, double,; unsigned long int, char, …) are passed by value. Arrays,; including multidimensional arrays, are required to be in contiguous; memory (as provided by block_matrix, for example), and are passed by; pr",MatchSource.WIKI,psi4manual/1.2.1/prog_blas.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_blas.html
https://psicode.org/psi4manual/1.2.1/prog_blas.html:695,Performance,perform,performance,695,"﻿. Linear Algebra in PSI4. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Programming: Using the Core Libraries. Linear Algebra in PSI4¶. How to call BLAS & LAPACK in PSI4¶; Computational chemistry is essentially linear algebra on molecular; systems, so using stable, portable, scalable, and efficient numerical; linear algebra methods in PSI4 is critical. To that end, we use BLAS1; (vector-vector operations, like dot products), BLAS2 (matrix-vector; operations, like rank-1 update), BLAS3 (matrix-matrix operations, like; matrix multiplication), and LAPACK (advanced matrix decompositions and; solutions). The methods provided by BLAS and LAPACK are standard, but the; performance of actual implementations differ greatly from one version to; another. Moreover, the standard interfaces to the libraries are Fortran,; so PSI4 provides a common set of wrappers in psi4/psi4/src/psi4/libqt/qt.h . Warning; Although block_matrix, init_array, and print_mat are still; around, their use is discouraged in favor of operations on; psi4.core.Matrix itself. The advice in these docs will catch up; shortly. BLAS Wrappers¶; BLAS wrappers are currently fully supported at double precision.; BLAS commands involving matrices are wrapped so as to be conventional; C-style “row-major” indexing, meaning that the column is the fast index; like normal. The calls to BLAS1 routines are wrapped so as to allow for operations on; vectors with more than 2^{31} elements (~16 GB, getting to be a problem).; So passing a signed or unsigned long works, though the stride arguments; must be integers. All routines are declared in qt.h. Each routine is prefixed with a; C_, followed by the standard Fortran name of the routine, in capital; letters. Input parameters of single primitives (int, double,; unsigned long int, char, …) are passed by value. Arrays,; including multidimensional arrays, are required to be in contiguous; memory (as provided by block_matrix, for example), and are passed by; pr",MatchSource.WIKI,psi4manual/1.2.1/prog_blas.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_blas.html
https://psicode.org/psi4manual/1.2.1/prog_blas.html:10726,Performance,perform,performance,10726," of functions; per shell remains (L + 1)(L + 2)/2, and the ordering remains the same; as above. Note that the individual functions are not normalized for; angular momentum as in most codes: the self-overlap of a PSI4 Cartesian D; or higher function with more than one nonzero Cartesian exponent (e.g., lx; = 1, ly = 1, lz = 0) will be less than one. If Spherical Harmonics are; used, 2L + 1 real combinations of the spherical harmonics are built from; the (L+1)(L+2)/2 Cartesian Gaussians, according to H. Schlegel and M.; Frish, IJQC, 54, 83-87, 1995. Unlike Cartesian functions these functions; are all strictly normalized. Note that in PSI4, the real combinations of; spherical harmonic functions (see the paragraph below Eq. 15 in the; Schlegel paper) are ordered as: 0, 1+, 1-, 2+, 2-, …. USO (Unique Symmetry-Adapted Orbitals): Spatial symmetry-adapted; combinations of SOs, blocked according to irrep. The total number of USOs; is the same as the number of SOs, but the number of USOs within each irrep; is usually much smaller, which can lead to significant performance; improvements. Note that this basis is sometimes unfortunately referred to; as the SO basis, so it’s a bit context specific. OSO (Orthogonal Symmetry-Adapted Orbitals): USOs orthogonalized by; Symmetric or Canonical Orthogonalization. The number of OSOs may be; slightly smaller than the total number of USOs, due to removal of linear; dependencies via Canonical Orthogonalization. The OSOs are rarely; encountered, as usually we go straight from USOs to MOs. MO (Molecular Orbitals): The combination of OSOs that diagonalizes; the Fock Matrix, so each basis function is a Hartree-Fock (or Kohn-Sham); molecular orbital. The number of OSOs and MOs is always the same. MOs are; orthonormal. LO (Localized Orbitals): Localized occupied orbitals, a different; combination of the occupied molecular orbitals which enhances spatial; locality. LOs do not diagonalize the occ-occ block of the Fock Matrix, but; remain orthonormal",MatchSource.WIKI,psi4manual/1.2.1/prog_blas.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_blas.html
https://psicode.org/psi4manual/1.2.1/prog_blas.html:4801,Safety,recover,recovery,4801,"ubstitution (just as fast as DTRMV); DGER: Rank-1 update (not wrapped yet). BLAS3; DGEMM: General Matrix-Matrix product; DTRMM: General Triangular Matrix-General Matrix product; DTRSM: Triangular Matrix-General Matrix solution via back substitution (just as fast as DTRMM); DSYMM/DSYMV calls are not appreciably faster than DGEMM calls, and should only be used in expert situations (like using the other half of the matrix for some form of other transformation).; DTRMM/DTRMV calls are 2x faster than DGEMM, and should be used where possible. LAPACK Wrappers¶; All standard LAPACK 3.2 double precision routines are provided.; LAPACK commands remain in Fortran’s “column-major” indexing, so all the; results will be transposed, and leading dimensions may have to be fiddled; with (using lda = n in both directions for square matrices is highly; recommended). An example of the former problem is a Cholesky; Decomposition: you expect to get back a lower triangular matrix L such; that L L^T = A, but this is returned in column-major order, so the actual; recovery of the matrix A with the row-major BLAS wrappers effectively; involves L^T L = A. On of the biggest consequences is in linear equations:; The input/output forcing/solution vector must be explicitly formed in; column-major indexing (each vector is placed in a C++ row, with its; entries along the C++ column). This is visualized in C++ as the transpose; of the forcing/solution vector. All routines are declared in qt.h. Each; routine is prefixed with a C_, followed by the standard Fortran name of; the routine, in capital letters. Input parameters of single primitives; (int, double, unsigned long int, char, …) are passed by value. Arrays,; including multidimensional arrays, are required to be in contiguous memory; (as provided by block_matrix, for example), and are passed by providing a; pointer to the first double or int element of the data (this is array[0]; if array is double**). All routines return an int INFO with error and;",MatchSource.WIKI,psi4manual/1.2.1/prog_blas.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_blas.html
https://psicode.org/psi4manual/1.2.1/prog_blas.html:11822,Safety,redund,redundant,11822,"ext specific. OSO (Orthogonal Symmetry-Adapted Orbitals): USOs orthogonalized by; Symmetric or Canonical Orthogonalization. The number of OSOs may be; slightly smaller than the total number of USOs, due to removal of linear; dependencies via Canonical Orthogonalization. The OSOs are rarely; encountered, as usually we go straight from USOs to MOs. MO (Molecular Orbitals): The combination of OSOs that diagonalizes; the Fock Matrix, so each basis function is a Hartree-Fock (or Kohn-Sham); molecular orbital. The number of OSOs and MOs is always the same. MOs are; orthonormal. LO (Localized Orbitals): Localized occupied orbitals, a different; combination of the occupied molecular orbitals which enhances spatial; locality. LOs do not diagonalize the occ-occ block of the Fock Matrix, but; remain orthonormal to each other and the virtual space. How to name orbital dimensions¶; There are a number of different names used to refer to the basis set size.; These may seem redundant, but they have subtly different meanings, as; detailed below.; A calculation can use either pure (5D, 7F, 9G, etc.) basis functions or; Cartesian (6D, 10F, 15G, etc.), as dictated by the input file / basis set; specification. Also, the basis can be represented in terms of atomic; orbitals (AO) or symmetry-adapted orbitals (SO). Further complications; come from the fact that a nearly linearly-dependent basis set will have; functions removed from it to prevent redundancies. With all of these; factors in mind, here are the conventions used internally:. nao — The number of atomic orbitals in Cartesian representation.; nso — The number of atomic orbitals but in the pure representation if the current basis uses pure functions, number of Cartesian AOs otherwise.; nbf — The number of basis functions, which is the same as nso.; nmo — The number of basis functions, after projecting out redundancies in the basis. When molecular symmetry is utilized, a small array of sizes per irrep is; usually allocated on the st",MatchSource.WIKI,psi4manual/1.2.1/prog_blas.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_blas.html
https://psicode.org/psi4manual/1.2.1/prog_blas.html:12295,Safety,redund,redundancies,12295,"tion of OSOs that diagonalizes; the Fock Matrix, so each basis function is a Hartree-Fock (or Kohn-Sham); molecular orbital. The number of OSOs and MOs is always the same. MOs are; orthonormal. LO (Localized Orbitals): Localized occupied orbitals, a different; combination of the occupied molecular orbitals which enhances spatial; locality. LOs do not diagonalize the occ-occ block of the Fock Matrix, but; remain orthonormal to each other and the virtual space. How to name orbital dimensions¶; There are a number of different names used to refer to the basis set size.; These may seem redundant, but they have subtly different meanings, as; detailed below.; A calculation can use either pure (5D, 7F, 9G, etc.) basis functions or; Cartesian (6D, 10F, 15G, etc.), as dictated by the input file / basis set; specification. Also, the basis can be represented in terms of atomic; orbitals (AO) or symmetry-adapted orbitals (SO). Further complications; come from the fact that a nearly linearly-dependent basis set will have; functions removed from it to prevent redundancies. With all of these; factors in mind, here are the conventions used internally:. nao — The number of atomic orbitals in Cartesian representation.; nso — The number of atomic orbitals but in the pure representation if the current basis uses pure functions, number of Cartesian AOs otherwise.; nbf — The number of basis functions, which is the same as nso.; nmo — The number of basis functions, after projecting out redundancies in the basis. When molecular symmetry is utilized, a small array of sizes per irrep is; usually allocated on the stack, and is named by augmenting the name above; with a pi (per-irrep), e.g. nmopi. Note that the number of irreps is; always the singular nirrep, and that the index variable h is always used; in a for-loop traverse of irreps. How to name orbital spaces (e.g., docc)¶; As with basis sets, a number of names are used to refer to refer to the; quantity of electrons, virtuals, and active s",MatchSource.WIKI,psi4manual/1.2.1/prog_blas.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_blas.html
https://psicode.org/psi4manual/1.2.1/prog_blas.html:12721,Safety,redund,redundancies,12721," name orbital dimensions¶; There are a number of different names used to refer to the basis set size.; These may seem redundant, but they have subtly different meanings, as; detailed below.; A calculation can use either pure (5D, 7F, 9G, etc.) basis functions or; Cartesian (6D, 10F, 15G, etc.), as dictated by the input file / basis set; specification. Also, the basis can be represented in terms of atomic; orbitals (AO) or symmetry-adapted orbitals (SO). Further complications; come from the fact that a nearly linearly-dependent basis set will have; functions removed from it to prevent redundancies. With all of these; factors in mind, here are the conventions used internally:. nao — The number of atomic orbitals in Cartesian representation.; nso — The number of atomic orbitals but in the pure representation if the current basis uses pure functions, number of Cartesian AOs otherwise.; nbf — The number of basis functions, which is the same as nso.; nmo — The number of basis functions, after projecting out redundancies in the basis. When molecular symmetry is utilized, a small array of sizes per irrep is; usually allocated on the stack, and is named by augmenting the name above; with a pi (per-irrep), e.g. nmopi. Note that the number of irreps is; always the singular nirrep, and that the index variable h is always used; in a for-loop traverse of irreps. How to name orbital spaces (e.g., docc)¶; As with basis sets, a number of names are used to refer to refer to the; quantity of electrons, virtuals, and active sub-quantities of a PSI4; calculation. All of these can be defined per irrep as above. Some common; conventions are:. nelec — The number of electrons, rarely used due to specialization of alphas and betas or soccs and doccs.; nalpha — The number of alpha electrons.; nbeta — The number of beta electrons; docc — The number of doubly-occupied orbitals; socc — The number of singly-occupied orbitals (Almost always alpha, we don’t like open-shell singlets much).; nvir — T",MatchSource.WIKI,psi4manual/1.2.1/prog_blas.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_blas.html
https://psicode.org/psi4manual/1.2.1/prog_blas.html:7601,Usability,simpl,simple,7601,",outfile);. // Block matrix should be free_blocked; free_block(A);. Important Lapack Routines¶. DSYEV: Eigenvalues and, optionally eigenvectors of a symmetric matrix. Eigenvectors take up to 10x longer than eigenvalues.; DGEEV: Eigenvalues and, optionally eigenvectors of a general matrix. Up to 10x slower than DSYEV.; DGESV: General solver (uses LU decomposition).; DGESVD: General singular value decomposition.; DGETRF: LU decomposition.; DPOTRF: Cholesky decomposition (much more stable/faster); DGETRS: Solver, given LU decomposition by DGETRF; DPOTRS: Solver, given Cholesky decomposition by DPOTRF; DGETRI: Inverse, given LU decomposition by DGETRF (Warning: it’s faster and more stable just to solve with DGETRS); DPOTRI: Inverse, given Cholesky decomposition by DPOTRF (Warning: it’s faster and more stable just to solve with DPOTRS). How to use low-level BLAS/LAPACK with psi4.core.Matrix¶; Jet’s awesome new Matrix object has a lot of simple BLAS/LAPACK built in,; but you can just as easily use the double*** array underneath if you are; careful (the outer index is the submatrix for each irrep). Here’s an; example:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33// BLAS/LAPACK; #include ""psi4/libqt/qt.h""; // Matrix; #include ""psi4/libmints/matrix.h"". using namespace psi;; ...; int n = 100;. // Allocate A Matrix (new C1 convenience constructor);; shared_ptr<Matrix> A(new Matrix(""Still A, but way cooler"", n,n));; // Get the pointer to the 0 irrep (C1 for now, it errors if you ask for too high of an index); double** A_pointer = A->get_pointer(0);. // Call the LAPACK DPOTRF to get the Cholesky factor; // Note this works in column-major order; // The result fills like:; // * * * *; // * * *; // * *; // *; // instead of the expected:; // *; // * *; // * * *; // * * * *; //; int info = C_DPOTRF('L', n, A_pointer[0], n);. // Wow that's a lot easier; A->print();. // Don't free, it's shared_ptr!. How to nam",MatchSource.WIKI,psi4manual/1.2.1/prog_blas.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_blas.html
https://psicode.org/psi4manual/1.2.1/prog_faq-1.html:670,Deployability,integrat,integrate,670,"﻿. Programmers FAQ. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Contributions: Intro to Programming in PSI4. Programmers FAQ¶. C++ Style in PSI4¶. Prefer nullptr to 0 or NULL; Prefer std::make_shared to direct use of new; Prefer auto to explicit type declarations. Modules in PSI4¶. How to name keywords in psi4/src/read_options.cc; How to call BLAS & LAPACK in ; How to use low-level BLAS/LAPACK with psi4.core.Matrix; How to name orbital bases (e.g., AO & SO); How to name orbital dimensions; How to name orbital spaces (e.g., docc). Interfacing with PSI4¶. How to use an Add-On’s name in directory structure, build, and distribution; How to integrate an Add-On into build, testing, and docs. Versioning PSI4¶. How to bump a version; How to create and remove an annotated Git tag on a remote; What is the suggested GitHub workflow; What Psi4 version is running. Workflow¶. How to use a local Add-On repository in the Psi4 build; What is the directory layout of the installed or staged Psi4; What is the suggested GitHub workflow; How to highlight git merge conflicts in vi; How to use gdb and lldb with Psi4; How to locate non-ascii characters in the codebase. Miscellaneous¶. Adding Test Cases. table of contents. Programmers FAQ; C++ Style in PSI4; Modules in PSI4; Interfacing with PSI4; Versioning PSI4; Workflow; Miscellaneous. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Contributions: Intro to Programming in PSI4. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/prog_faq-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_faq-1.html
https://psicode.org/psi4manual/1.2.1/prog_faq-1.html:993,Deployability,install,installed,993,"﻿. Programmers FAQ. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Contributions: Intro to Programming in PSI4. Programmers FAQ¶. C++ Style in PSI4¶. Prefer nullptr to 0 or NULL; Prefer std::make_shared to direct use of new; Prefer auto to explicit type declarations. Modules in PSI4¶. How to name keywords in psi4/src/read_options.cc; How to call BLAS & LAPACK in ; How to use low-level BLAS/LAPACK with psi4.core.Matrix; How to name orbital bases (e.g., AO & SO); How to name orbital dimensions; How to name orbital spaces (e.g., docc). Interfacing with PSI4¶. How to use an Add-On’s name in directory structure, build, and distribution; How to integrate an Add-On into build, testing, and docs. Versioning PSI4¶. How to bump a version; How to create and remove an annotated Git tag on a remote; What is the suggested GitHub workflow; What Psi4 version is running. Workflow¶. How to use a local Add-On repository in the Psi4 build; What is the directory layout of the installed or staged Psi4; What is the suggested GitHub workflow; How to highlight git merge conflicts in vi; How to use gdb and lldb with Psi4; How to locate non-ascii characters in the codebase. Miscellaneous¶. Adding Test Cases. table of contents. Programmers FAQ; C++ Style in PSI4; Modules in PSI4; Interfacing with PSI4; Versioning PSI4; Workflow; Miscellaneous. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Contributions: Intro to Programming in PSI4. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/prog_faq-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_faq-1.html
https://psicode.org/psi4manual/1.2.1/prog_faq-1.html:1552,Deployability,update,updated,1552,"﻿. Programmers FAQ. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Contributions: Intro to Programming in PSI4. Programmers FAQ¶. C++ Style in PSI4¶. Prefer nullptr to 0 or NULL; Prefer std::make_shared to direct use of new; Prefer auto to explicit type declarations. Modules in PSI4¶. How to name keywords in psi4/src/read_options.cc; How to call BLAS & LAPACK in ; How to use low-level BLAS/LAPACK with psi4.core.Matrix; How to name orbital bases (e.g., AO & SO); How to name orbital dimensions; How to name orbital spaces (e.g., docc). Interfacing with PSI4¶. How to use an Add-On’s name in directory structure, build, and distribution; How to integrate an Add-On into build, testing, and docs. Versioning PSI4¶. How to bump a version; How to create and remove an annotated Git tag on a remote; What is the suggested GitHub workflow; What Psi4 version is running. Workflow¶. How to use a local Add-On repository in the Psi4 build; What is the directory layout of the installed or staged Psi4; What is the suggested GitHub workflow; How to highlight git merge conflicts in vi; How to use gdb and lldb with Psi4; How to locate non-ascii characters in the codebase. Miscellaneous¶. Adding Test Cases. table of contents. Programmers FAQ; C++ Style in PSI4; Modules in PSI4; Interfacing with PSI4; Versioning PSI4; Workflow; Miscellaneous. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Contributions: Intro to Programming in PSI4. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/prog_faq-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_faq-1.html
https://psicode.org/psi4manual/1.2.1/prog_faq-1.html:670,Integrability,integrat,integrate,670,"﻿. Programmers FAQ. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Contributions: Intro to Programming in PSI4. Programmers FAQ¶. C++ Style in PSI4¶. Prefer nullptr to 0 or NULL; Prefer std::make_shared to direct use of new; Prefer auto to explicit type declarations. Modules in PSI4¶. How to name keywords in psi4/src/read_options.cc; How to call BLAS & LAPACK in ; How to use low-level BLAS/LAPACK with psi4.core.Matrix; How to name orbital bases (e.g., AO & SO); How to name orbital dimensions; How to name orbital spaces (e.g., docc). Interfacing with PSI4¶. How to use an Add-On’s name in directory structure, build, and distribution; How to integrate an Add-On into build, testing, and docs. Versioning PSI4¶. How to bump a version; How to create and remove an annotated Git tag on a remote; What is the suggested GitHub workflow; What Psi4 version is running. Workflow¶. How to use a local Add-On repository in the Psi4 build; What is the directory layout of the installed or staged Psi4; What is the suggested GitHub workflow; How to highlight git merge conflicts in vi; How to use gdb and lldb with Psi4; How to locate non-ascii characters in the codebase. Miscellaneous¶. Adding Test Cases. table of contents. Programmers FAQ; C++ Style in PSI4; Modules in PSI4; Interfacing with PSI4; Versioning PSI4; Workflow; Miscellaneous. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Contributions: Intro to Programming in PSI4. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/prog_faq-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_faq-1.html
https://psicode.org/psi4manual/1.2.1/prog_faq-1.html:702,Testability,test,testing,702,"﻿. Programmers FAQ. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Contributions: Intro to Programming in PSI4. Programmers FAQ¶. C++ Style in PSI4¶. Prefer nullptr to 0 or NULL; Prefer std::make_shared to direct use of new; Prefer auto to explicit type declarations. Modules in PSI4¶. How to name keywords in psi4/src/read_options.cc; How to call BLAS & LAPACK in ; How to use low-level BLAS/LAPACK with psi4.core.Matrix; How to name orbital bases (e.g., AO & SO); How to name orbital dimensions; How to name orbital spaces (e.g., docc). Interfacing with PSI4¶. How to use an Add-On’s name in directory structure, build, and distribution; How to integrate an Add-On into build, testing, and docs. Versioning PSI4¶. How to bump a version; How to create and remove an annotated Git tag on a remote; What is the suggested GitHub workflow; What Psi4 version is running. Workflow¶. How to use a local Add-On repository in the Psi4 build; What is the directory layout of the installed or staged Psi4; What is the suggested GitHub workflow; How to highlight git merge conflicts in vi; How to use gdb and lldb with Psi4; How to locate non-ascii characters in the codebase. Miscellaneous¶. Adding Test Cases. table of contents. Programmers FAQ; C++ Style in PSI4; Modules in PSI4; Interfacing with PSI4; Versioning PSI4; Workflow; Miscellaneous. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Contributions: Intro to Programming in PSI4. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/prog_faq-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_faq-1.html
https://psicode.org/psi4manual/1.2.1/prog_faq.html:670,Deployability,integrat,integrate,670,"﻿. Programmers FAQ. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Contributions: Intro to Programming in PSI4. Programmers FAQ¶. C++ Style in PSI4¶. Prefer nullptr to 0 or NULL; Prefer std::make_shared to direct use of new; Prefer auto to explicit type declarations. Modules in PSI4¶. How to name keywords in psi4/src/read_options.cc; How to call BLAS & LAPACK in ; How to use low-level BLAS/LAPACK with psi4.core.Matrix; How to name orbital bases (e.g., AO & SO); How to name orbital dimensions; How to name orbital spaces (e.g., docc). Interfacing with PSI4¶. How to use an Add-On’s name in directory structure, build, and distribution; How to integrate an Add-On into build, testing, and docs. Versioning PSI4¶. How to bump a version; How to create and remove an annotated Git tag on a remote; What is the suggested GitHub workflow; What Psi4 version is running. Workflow¶. How to use a local Add-On repository in the Psi4 build; What is the directory layout of the installed or staged Psi4; What is the suggested GitHub workflow; How to highlight git merge conflicts in vi; How to use gdb and lldb with Psi4; How to locate non-ascii characters in the codebase. Miscellaneous¶. Adding Test Cases. table of contents. Programmers FAQ; C++ Style in PSI4; Modules in PSI4; Interfacing with PSI4; Versioning PSI4; Workflow; Miscellaneous. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Contributions: Intro to Programming in PSI4. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/prog_faq.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_faq.html
https://psicode.org/psi4manual/1.2.1/prog_faq.html:993,Deployability,install,installed,993,"﻿. Programmers FAQ. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Contributions: Intro to Programming in PSI4. Programmers FAQ¶. C++ Style in PSI4¶. Prefer nullptr to 0 or NULL; Prefer std::make_shared to direct use of new; Prefer auto to explicit type declarations. Modules in PSI4¶. How to name keywords in psi4/src/read_options.cc; How to call BLAS & LAPACK in ; How to use low-level BLAS/LAPACK with psi4.core.Matrix; How to name orbital bases (e.g., AO & SO); How to name orbital dimensions; How to name orbital spaces (e.g., docc). Interfacing with PSI4¶. How to use an Add-On’s name in directory structure, build, and distribution; How to integrate an Add-On into build, testing, and docs. Versioning PSI4¶. How to bump a version; How to create and remove an annotated Git tag on a remote; What is the suggested GitHub workflow; What Psi4 version is running. Workflow¶. How to use a local Add-On repository in the Psi4 build; What is the directory layout of the installed or staged Psi4; What is the suggested GitHub workflow; How to highlight git merge conflicts in vi; How to use gdb and lldb with Psi4; How to locate non-ascii characters in the codebase. Miscellaneous¶. Adding Test Cases. table of contents. Programmers FAQ; C++ Style in PSI4; Modules in PSI4; Interfacing with PSI4; Versioning PSI4; Workflow; Miscellaneous. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Contributions: Intro to Programming in PSI4. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/prog_faq.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_faq.html
https://psicode.org/psi4manual/1.2.1/prog_faq.html:1552,Deployability,update,updated,1552,"﻿. Programmers FAQ. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Contributions: Intro to Programming in PSI4. Programmers FAQ¶. C++ Style in PSI4¶. Prefer nullptr to 0 or NULL; Prefer std::make_shared to direct use of new; Prefer auto to explicit type declarations. Modules in PSI4¶. How to name keywords in psi4/src/read_options.cc; How to call BLAS & LAPACK in ; How to use low-level BLAS/LAPACK with psi4.core.Matrix; How to name orbital bases (e.g., AO & SO); How to name orbital dimensions; How to name orbital spaces (e.g., docc). Interfacing with PSI4¶. How to use an Add-On’s name in directory structure, build, and distribution; How to integrate an Add-On into build, testing, and docs. Versioning PSI4¶. How to bump a version; How to create and remove an annotated Git tag on a remote; What is the suggested GitHub workflow; What Psi4 version is running. Workflow¶. How to use a local Add-On repository in the Psi4 build; What is the directory layout of the installed or staged Psi4; What is the suggested GitHub workflow; How to highlight git merge conflicts in vi; How to use gdb and lldb with Psi4; How to locate non-ascii characters in the codebase. Miscellaneous¶. Adding Test Cases. table of contents. Programmers FAQ; C++ Style in PSI4; Modules in PSI4; Interfacing with PSI4; Versioning PSI4; Workflow; Miscellaneous. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Contributions: Intro to Programming in PSI4. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/prog_faq.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_faq.html
https://psicode.org/psi4manual/1.2.1/prog_faq.html:670,Integrability,integrat,integrate,670,"﻿. Programmers FAQ. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Contributions: Intro to Programming in PSI4. Programmers FAQ¶. C++ Style in PSI4¶. Prefer nullptr to 0 or NULL; Prefer std::make_shared to direct use of new; Prefer auto to explicit type declarations. Modules in PSI4¶. How to name keywords in psi4/src/read_options.cc; How to call BLAS & LAPACK in ; How to use low-level BLAS/LAPACK with psi4.core.Matrix; How to name orbital bases (e.g., AO & SO); How to name orbital dimensions; How to name orbital spaces (e.g., docc). Interfacing with PSI4¶. How to use an Add-On’s name in directory structure, build, and distribution; How to integrate an Add-On into build, testing, and docs. Versioning PSI4¶. How to bump a version; How to create and remove an annotated Git tag on a remote; What is the suggested GitHub workflow; What Psi4 version is running. Workflow¶. How to use a local Add-On repository in the Psi4 build; What is the directory layout of the installed or staged Psi4; What is the suggested GitHub workflow; How to highlight git merge conflicts in vi; How to use gdb and lldb with Psi4; How to locate non-ascii characters in the codebase. Miscellaneous¶. Adding Test Cases. table of contents. Programmers FAQ; C++ Style in PSI4; Modules in PSI4; Interfacing with PSI4; Versioning PSI4; Workflow; Miscellaneous. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Contributions: Intro to Programming in PSI4. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/prog_faq.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_faq.html
https://psicode.org/psi4manual/1.2.1/prog_faq.html:702,Testability,test,testing,702,"﻿. Programmers FAQ. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Contributions: Intro to Programming in PSI4. Programmers FAQ¶. C++ Style in PSI4¶. Prefer nullptr to 0 or NULL; Prefer std::make_shared to direct use of new; Prefer auto to explicit type declarations. Modules in PSI4¶. How to name keywords in psi4/src/read_options.cc; How to call BLAS & LAPACK in ; How to use low-level BLAS/LAPACK with psi4.core.Matrix; How to name orbital bases (e.g., AO & SO); How to name orbital dimensions; How to name orbital spaces (e.g., docc). Interfacing with PSI4¶. How to use an Add-On’s name in directory structure, build, and distribution; How to integrate an Add-On into build, testing, and docs. Versioning PSI4¶. How to bump a version; How to create and remove an annotated Git tag on a remote; What is the suggested GitHub workflow; What Psi4 version is running. Workflow¶. How to use a local Add-On repository in the Psi4 build; What is the directory layout of the installed or staged Psi4; What is the suggested GitHub workflow; How to highlight git merge conflicts in vi; How to use gdb and lldb with Psi4; How to locate non-ascii characters in the codebase. Miscellaneous¶. Adding Test Cases. table of contents. Programmers FAQ; C++ Style in PSI4; Modules in PSI4; Interfacing with PSI4; Versioning PSI4; Workflow; Miscellaneous. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Contributions: Intro to Programming in PSI4. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/prog_faq.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_faq.html
https://psicode.org/psi4manual/1.2.1/prop-1.html:1275,Deployability,configurat,configurational,1275,"rce]¶; Function to compute various properties. Aliases:prop(). Returns:none. Caution; Some features are not yet implemented. Buy a developer a coffee. This function at present has a limited functionality.; Consult the keywords sections of other modules for further property capabilities. Name; Calls Method; Reference; Supported Properties. scf; Self-consistent field method(s); RHF/ROHF/UHF; Listed here. hf; HF Self-consistent field method(s); RHF/ROHF/UHF; Listed here. mp2; MP2 with density fitting only (mp2_type df); RHF; Listed here. cc2; 2nd-order approximate CCSD; RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. ccsd; Coupled cluster singles and doubles (CCSD); RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. eom-cc2; 2nd-order approximate EOM-CCSD; RHF; oscillator_strength, rotational_strength. eom-ccsd; Equation-of-motion CCSD (EOM-CCSD); RHF; oscillator_strength, rotational_strength. cisd, cisdt,; cisdt, cisdtq,; ci5, …, fci; Configuration interaction; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. casscf, rasscf; Multi-configurational SCF; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. Parameters:; name (string) – 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. properties (array of strings) – \(\Rightarrow\) [] \(\Leftarrow\) || ['rotation', 'polarizability', 'oscillator_strength', 'roa'] || etc.; Indicates which properties should be computed. Defaults to dipole and quadrupole. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples:. 1; 2>>> # [1] Optical rotation calculation; >>> properties('cc2', properties=['rotation']). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Psithon Functions: Invoking a Calculation. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/prop-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prop-1.html
https://psicode.org/psi4manual/1.2.1/prop-1.html:2110,Deployability,update,updated,2110,"rce]¶; Function to compute various properties. Aliases:prop(). Returns:none. Caution; Some features are not yet implemented. Buy a developer a coffee. This function at present has a limited functionality.; Consult the keywords sections of other modules for further property capabilities. Name; Calls Method; Reference; Supported Properties. scf; Self-consistent field method(s); RHF/ROHF/UHF; Listed here. hf; HF Self-consistent field method(s); RHF/ROHF/UHF; Listed here. mp2; MP2 with density fitting only (mp2_type df); RHF; Listed here. cc2; 2nd-order approximate CCSD; RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. ccsd; Coupled cluster singles and doubles (CCSD); RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. eom-cc2; 2nd-order approximate EOM-CCSD; RHF; oscillator_strength, rotational_strength. eom-ccsd; Equation-of-motion CCSD (EOM-CCSD); RHF; oscillator_strength, rotational_strength. cisd, cisdt,; cisdt, cisdtq,; ci5, …, fci; Configuration interaction; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. casscf, rasscf; Multi-configurational SCF; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. Parameters:; name (string) – 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. properties (array of strings) – \(\Rightarrow\) [] \(\Leftarrow\) || ['rotation', 'polarizability', 'oscillator_strength', 'roa'] || etc.; Indicates which properties should be computed. Defaults to dipole and quadrupole. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples:. 1; 2>>> # [1] Optical rotation calculation; >>> properties('cc2', properties=['rotation']). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Psithon Functions: Invoking a Calculation. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/prop-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prop-1.html
https://psicode.org/psi4manual/1.2.1/prop-1.html:1275,Modifiability,config,configurational,1275,"rce]¶; Function to compute various properties. Aliases:prop(). Returns:none. Caution; Some features are not yet implemented. Buy a developer a coffee. This function at present has a limited functionality.; Consult the keywords sections of other modules for further property capabilities. Name; Calls Method; Reference; Supported Properties. scf; Self-consistent field method(s); RHF/ROHF/UHF; Listed here. hf; HF Self-consistent field method(s); RHF/ROHF/UHF; Listed here. mp2; MP2 with density fitting only (mp2_type df); RHF; Listed here. cc2; 2nd-order approximate CCSD; RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. ccsd; Coupled cluster singles and doubles (CCSD); RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. eom-cc2; 2nd-order approximate EOM-CCSD; RHF; oscillator_strength, rotational_strength. eom-ccsd; Equation-of-motion CCSD (EOM-CCSD); RHF; oscillator_strength, rotational_strength. cisd, cisdt,; cisdt, cisdtq,; ci5, …, fci; Configuration interaction; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. casscf, rasscf; Multi-configurational SCF; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. Parameters:; name (string) – 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. properties (array of strings) – \(\Rightarrow\) [] \(\Leftarrow\) || ['rotation', 'polarizability', 'oscillator_strength', 'roa'] || etc.; Indicates which properties should be computed. Defaults to dipole and quadrupole. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples:. 1; 2>>> # [1] Optical rotation calculation; >>> properties('cc2', properties=['rotation']). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Psithon Functions: Invoking a Calculation. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/prop-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prop-1.html
https://psicode.org/psi4manual/1.2.1/prop.html:1275,Deployability,configurat,configurational,1275,"rce]¶; Function to compute various properties. Aliases:prop(). Returns:none. Caution; Some features are not yet implemented. Buy a developer a coffee. This function at present has a limited functionality.; Consult the keywords sections of other modules for further property capabilities. Name; Calls Method; Reference; Supported Properties. scf; Self-consistent field method(s); RHF/ROHF/UHF; Listed here. hf; HF Self-consistent field method(s); RHF/ROHF/UHF; Listed here. mp2; MP2 with density fitting only (mp2_type df); RHF; Listed here. cc2; 2nd-order approximate CCSD; RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. ccsd; Coupled cluster singles and doubles (CCSD); RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. eom-cc2; 2nd-order approximate EOM-CCSD; RHF; oscillator_strength, rotational_strength. eom-ccsd; Equation-of-motion CCSD (EOM-CCSD); RHF; oscillator_strength, rotational_strength. cisd, cisdt,; cisdt, cisdtq,; ci5, …, fci; Configuration interaction; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. casscf, rasscf; Multi-configurational SCF; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. Parameters:; name (string) – 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. properties (array of strings) – \(\Rightarrow\) [] \(\Leftarrow\) || ['rotation', 'polarizability', 'oscillator_strength', 'roa'] || etc.; Indicates which properties should be computed. Defaults to dipole and quadrupole. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples:. 1; 2>>> # [1] Optical rotation calculation; >>> properties('cc2', properties=['rotation']). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Psithon Functions: Invoking a Calculation. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/prop.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prop.html
https://psicode.org/psi4manual/1.2.1/prop.html:2110,Deployability,update,updated,2110,"rce]¶; Function to compute various properties. Aliases:prop(). Returns:none. Caution; Some features are not yet implemented. Buy a developer a coffee. This function at present has a limited functionality.; Consult the keywords sections of other modules for further property capabilities. Name; Calls Method; Reference; Supported Properties. scf; Self-consistent field method(s); RHF/ROHF/UHF; Listed here. hf; HF Self-consistent field method(s); RHF/ROHF/UHF; Listed here. mp2; MP2 with density fitting only (mp2_type df); RHF; Listed here. cc2; 2nd-order approximate CCSD; RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. ccsd; Coupled cluster singles and doubles (CCSD); RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. eom-cc2; 2nd-order approximate EOM-CCSD; RHF; oscillator_strength, rotational_strength. eom-ccsd; Equation-of-motion CCSD (EOM-CCSD); RHF; oscillator_strength, rotational_strength. cisd, cisdt,; cisdt, cisdtq,; ci5, …, fci; Configuration interaction; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. casscf, rasscf; Multi-configurational SCF; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. Parameters:; name (string) – 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. properties (array of strings) – \(\Rightarrow\) [] \(\Leftarrow\) || ['rotation', 'polarizability', 'oscillator_strength', 'roa'] || etc.; Indicates which properties should be computed. Defaults to dipole and quadrupole. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples:. 1; 2>>> # [1] Optical rotation calculation; >>> properties('cc2', properties=['rotation']). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Psithon Functions: Invoking a Calculation. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/prop.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prop.html
https://psicode.org/psi4manual/1.2.1/prop.html:1275,Modifiability,config,configurational,1275,"rce]¶; Function to compute various properties. Aliases:prop(). Returns:none. Caution; Some features are not yet implemented. Buy a developer a coffee. This function at present has a limited functionality.; Consult the keywords sections of other modules for further property capabilities. Name; Calls Method; Reference; Supported Properties. scf; Self-consistent field method(s); RHF/ROHF/UHF; Listed here. hf; HF Self-consistent field method(s); RHF/ROHF/UHF; Listed here. mp2; MP2 with density fitting only (mp2_type df); RHF; Listed here. cc2; 2nd-order approximate CCSD; RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. ccsd; Coupled cluster singles and doubles (CCSD); RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. eom-cc2; 2nd-order approximate EOM-CCSD; RHF; oscillator_strength, rotational_strength. eom-ccsd; Equation-of-motion CCSD (EOM-CCSD); RHF; oscillator_strength, rotational_strength. cisd, cisdt,; cisdt, cisdtq,; ci5, …, fci; Configuration interaction; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. casscf, rasscf; Multi-configurational SCF; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. Parameters:; name (string) – 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. properties (array of strings) – \(\Rightarrow\) [] \(\Leftarrow\) || ['rotation', 'polarizability', 'oscillator_strength', 'roa'] || etc.; Indicates which properties should be computed. Defaults to dipole and quadrupole. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples:. 1; 2>>> # [1] Optical rotation calculation; >>> properties('cc2', properties=['rotation']). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Psithon Functions: Invoking a Calculation. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/prop.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prop.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:1997,Availability,error,error,1997,"gin about which the one body ints are being computed. class psi4.core.BSVec¶; Bases: pybind11_builtins.pybind11_object. append(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo) → None¶; Add an item to the end of the list. count(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo) → int¶; Return the number of times x appears in the list. extend(self: List[psi4.core.ShellInfo], L: List[psi4.core.ShellInfo]) → None¶; Extend the list by appending all the items in the given list. insert(self: List[psi4.core.ShellInfo], i: int, x: psi4.core.ShellInfo) → None¶; Insert an item at a given position. pop(*args, **kwargs)¶; Overloaded function. pop(self: List[psi4.core.ShellInfo]) -> psi4.core.ShellInfo. Remove and return the last item. pop(self: List[psi4.core.ShellInfo], i: int) -> psi4.core.ShellInfo. Remove and return the item at index i. remove(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo) → None¶; Remove the first item from the list whose value is x. It is an error if there is no such item. class psi4.core.BasisExtents¶; Bases: pybind11_builtins.pybind11_object; docstring. basis(self: psi4.core.BasisExtents) → psi4.core.BasisSet¶; docstring. delta(self: psi4.core.BasisExtents) → float¶; docstring. maxR(self: psi4.core.BasisExtents) → float¶; docstring. set_delta(self: psi4.core.BasisExtents, arg0: float) → None¶; docstring. shell_extents(self: psi4.core.BasisExtents) → psi4.core.Vector¶; docstring. class psi4.core.BasisFunctions¶; Bases: pybind11_builtins.pybind11_object; docstring. basis_values(self: psi4.core.BasisFunctions) → Dict[str, psi4.core.Matrix]¶; docstring. compute_functions(self: psi4.core.BasisFunctions, arg0: psi::BlockOPoints) → None¶; docstring. deriv(self: psi4.core.BasisFunctions) → int¶; docstring. max_functions(self: psi4.core.BasisFunctions) → int¶; docstring. max_points(self: psi4.core.BasisFunctions) → int¶; docstring. set_deriv(self: psi4.core.BasisFunctions, arg0: int) → None¶; docstring. class psi4.core.BasisSet¶; Bases: pyb",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:127900,Availability,fault,faulty,127900,"ncoded. Returns:; bfs_map (list of lists) – Array of atom indices (0-indexed) of detected fragments.; bfs_arrays (tuple of lists of ndarray, optional) – geom, mass, elem info per-fragment.; Only provided if return_arrays is True.; bfs_molecules (list of qcdb.Molecule or psi4.core.Molecule, optional) – List of molecules, each built from one fragment. Center and; orientation of fragments is fixed so orientation info from self is; not lost. Loses chgmult and ghost/dummy info from self and contains; default chgmult.; Only provided if return_molecules is True.; Returned are of same type as self.; bfs_molecule (qcdb.Molecule or psi4.core.Molecule, optional) – Single molecule with same number of real atoms as self with atoms; reordered into adjacent fragments and fragment markers inserted.; Loses ghost/dummy info from self; keeps total charge but not total mult.; Only provided if return_molecule is True.; Returned is of same type as self. Notes. Relies upon van der Waals radii and so faulty for close (especially; hydrogen-bonded) fragments. See seed_atoms. Any existing fragmentation info/chgmult encoded in self is lost.; Original code from Michael S. Marshall, linear-scaling algorithm from; Trent M. Parker, revamped by Lori A. Burns. Z(self: psi4.core.Molecule, arg0: int) → float¶; Nuclear charge of atom. activate_all_fragments(self: psi4.core.Molecule) → None¶; Sets all fragments in the molecule to be active. add_atom(self: psi4.core.Molecule, arg0: float, arg1: float, arg2: float, arg3: float, arg4: str, arg5: float, arg6: float, arg7: str, arg8: int) → None¶; Adds to Molecule arg1 an atom with atomic number arg2, Cartesian coordinates in Bohr (arg3, arg4, arg5), atomic symbol arg6, mass arg7, charge arg8 (optional), and lineno arg9 (optional). atom_at_position(self: psi4.core.Molecule, arg0: float, arg1: float) → int¶; Tests to see if an atom is at the position arg2 with a given tolerance arg3. basis_on_atom(self: psi4.core.Molecule, arg0: int) → str¶; Gets the label of ",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:128816,Availability,toler,tolerance,128816,"ult.; Only provided if return_molecule is True.; Returned is of same type as self. Notes. Relies upon van der Waals radii and so faulty for close (especially; hydrogen-bonded) fragments. See seed_atoms. Any existing fragmentation info/chgmult encoded in self is lost.; Original code from Michael S. Marshall, linear-scaling algorithm from; Trent M. Parker, revamped by Lori A. Burns. Z(self: psi4.core.Molecule, arg0: int) → float¶; Nuclear charge of atom. activate_all_fragments(self: psi4.core.Molecule) → None¶; Sets all fragments in the molecule to be active. add_atom(self: psi4.core.Molecule, arg0: float, arg1: float, arg2: float, arg3: float, arg4: str, arg5: float, arg6: float, arg7: str, arg8: int) → None¶; Adds to Molecule arg1 an atom with atomic number arg2, Cartesian coordinates in Bohr (arg3, arg4, arg5), atomic symbol arg6, mass arg7, charge arg8 (optional), and lineno arg9 (optional). atom_at_position(self: psi4.core.Molecule, arg0: float, arg1: float) → int¶; Tests to see if an atom is at the position arg2 with a given tolerance arg3. basis_on_atom(self: psi4.core.Molecule, arg0: int) → str¶; Gets the label of the orbital basis set on a given atom. center_of_mass(self: psi4.core.Molecule) → psi4.core.Vector3¶; Computes center of mass of molecule (does not translate molecule). charge(self: psi4.core.Molecule, arg0: int) → float¶; Gets charge of atom. clone(self: psi4.core.Molecule) → psi4.core.Molecule¶; Returns a new Molecule identical to arg1. com_fixed(self: psi4.core.Molecule) → bool¶; Get whether or not COM is fixed. create_molecule_from_string(arg0: str) → psi4.core.Molecule¶; Returns a new Molecule with member data from the geometry string arg1 in psi4 format. create_psi4_string_from_molecule(self: psi4.core.Molecule) → str¶; Gets a string reexpressing in input format the current states of the molecule. deactivate_all_fragments(self: psi4.core.Molecule) → None¶; Sets all fragments in the molecule to be inactive. distance_matrix(self: psi4.core.Molecu",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:131809,Availability,error,error,131809," copy of arg1 with arg2 fragments Real. extract_subsets(self: psi4.core.Molecule, arg0: int) -> psi4.core.Molecule. Returns copy of arg1 with arg2 fragment Real. fZ(self: psi4.core.Molecule, arg0: int) → float¶; Nuclear charge of atom arg1 (0-indexed including dummies). find_point_group(self: psi4.core.Molecule, arg0: float) → psi4.core.PointGroup¶; Finds computational molecular point group, user can override this with the symmetry keyword. fix_com(self: psi4.core.Molecule, arg0: bool) → None¶; Whether to fix the Cartesian position, or to translate to the C.O.M. fix_orientation(self: psi4.core.Molecule, arg0: bool) → None¶; Fix the orientation at its current frame. form_symmetry_information(self: psi4.core.Molecule, arg0: float) → None¶; Uses the point group object obtain by calling point_group(). classmethod from_arrays(geom=None, elea=None, elez=None, elem=None, mass=None, real=None, elbl=None, name=None, units='Angstrom', input_units_to_au=None, fix_com=None, fix_orientation=None, fix_symmetry=None, fragment_separators=None, fragment_charges=None, fragment_multiplicities=None, molecular_charge=None, molecular_multiplicity=None, missing_enabled_return='error', tooclose=0.1, zero_ghost_fragments=False, nonphysical=False, mtol=0.001, verbose=1, return_dict=False)¶; Construct Molecule from unvalidated arrays and variables.; Light wrapper around from_arrays(); that is a full-featured constructor to dictionary representa-; tion of Molecule. This follows one step further to return; Molecule instance.; :param See from_arrays().:. Returns:. Return type:psi4.core.Molecule. from_dict(arg0: dict) → psi4.core.Molecule¶; Returns a new Molecule constructed from python dictionary. In progress: name and capabilities should not be relied upon. classmethod from_schema(molschema, return_dict=False, verbose=1)¶; Construct Molecule from non-Psi4 schema.; Light wrapper around from_arrays(). Parameters:; molschema (dict) – Dictionary form of Molecule following known schema.; return_dict",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:146103,Availability,toler,tolerance,146103,"ge. set_multiplicity(self: psi4.core.Molecule, arg0: int) → None¶; Sets the multiplicity (defined as 2Ms + 1). set_name(self: psi4.core.Molecule, arg0: str) → None¶; Sets molecule name. set_nuclear_charge(self: psi4.core.Molecule, arg0: int, arg1: float) → None¶; Set the nuclear charge of the given atom to the value provided. set_point_group(self: psi4.core.Molecule, arg0: psi4.core.PointGroup) → None¶; Sets the molecular point group to the point group object arg2. set_units(self: psi4.core.Molecule, arg0: psi4.core.GeometryUnits) → None¶; Sets units (Angstrom or Bohr) used to define the geometry. set_variable(self: psi4.core.Molecule, arg0: str, arg1: float) → None¶; Assigns the value arg3 to the variable arg2 in the list of geometry variables, then calls update_geometry(). symbol(self: psi4.core.Molecule, arg0: int) → str¶; Gets the cleaned up label of atom arg2 (C2 => C, H4 = H). symmetrize(self: psi4.core.Molecule, arg0: float) → None¶; Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. symmetry_from_input(self: psi4.core.Molecule) → str¶; Returns the symmetry specified in the input. to_arrays()¶; Exports coordinate info into NumPy arrays. Returns:; geom, mass, elem, elez, uniq (ndarray, ndarray, ndarray, ndarray, ndarray) – (nat, 3) geometry [a0].; (nat,) mass [u].; (nat,) element symbol.; (nat,) atomic number.; (nat,) hash of element symbol and mass.; Note that coordinate, orientation, and element information is; preserved but fragmentation, chgmult, and dummy/ghost is lost.; Usage; —–; geom, mass, elem, elez, uniq = molinstance.to_arrays(). to_dict(force_c1=False, force_units=False, np_out=True)¶; Serializes instance into Molecule dictionary. to_schema(dtype, units='Angstrom', return_type='json')¶; Serializes instance into JSON or YAML according to schema dtype. to_string(dtype, units='Angstrom', atom_format=None, ghost_format=None, width=17, prec=12)¶; Format a string representation of Q",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:153509,Availability,toler,tolerance,153509,"arg1: str, arg2: str) → None¶; set string option. set_str_i(self: psi4.core.Options, arg0: str, arg1: str, arg2: str) → None¶; set string option. validate_options(self: psi4.core.Options) → None¶; validate options for arg0 module. class psi4.core.OrbitalSpace¶; Bases: pybind11_builtins.pybind11_object; Contains information about the orbitals. C(self: psi4.core.OrbitalSpace) → psi4.core.Matrix¶; MO coefficient matrix, AO->MO or SO->MO transformation matrix. basisset(self: psi4.core.OrbitalSpace) → psi::BasisSet¶; The AO basis set used to create C. build_cabs_space(orb_space: psi4.core.OrbitalSpace, ri_space: psi4.core.OrbitalSpace, linear_tol: float) → psi4.core.OrbitalSpace¶; Given two spaces, it projects out one space from the other and returns the new spaces The first argument (orb_space) is the space to project out. The returned space will be orthogonal to this The second argument (ri_space) is the space that is being projected on. The returned space = this space - orb_space The third argument is the tolerance for linear dependencies. build_ri_space(molecule: psi::Molecule, obs_key: str, aux_key: str, lindep_tol: float) → psi4.core.OrbitalSpace¶; Given two basis sets, it merges the basis sets and then constructs an orthogonalized space with the same span. Linearly dependent orbitals are thrown out. The first argument, molecule, is the molecule to construct the basis for The second argument, obs_key, is the option keyword for orbital basis set ‘BASIS’ The third argument, aux_key, is the option keyword for auxiliery basis set ‘DF_BASIS_MP2’ The fourth argument, lindep_tol, is the tolerance for linear dependencies. dim(self: psi4.core.OrbitalSpace) → psi4.core.Dimension¶; MO dimensions. evals(self: psi4.core.OrbitalSpace) → psi4.core.Vector¶; Corresponding eigenvalues of the C matrix. id(self: psi4.core.OrbitalSpace) → str¶; Unique identifier. integral(self: psi4.core.OrbitalSpace) → psi4.core.IntegralFactory¶; The integral factory used to create C. name(self: psi4.c",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:154098,Availability,toler,tolerance,154098,"ore.OrbitalSpace) → psi::BasisSet¶; The AO basis set used to create C. build_cabs_space(orb_space: psi4.core.OrbitalSpace, ri_space: psi4.core.OrbitalSpace, linear_tol: float) → psi4.core.OrbitalSpace¶; Given two spaces, it projects out one space from the other and returns the new spaces The first argument (orb_space) is the space to project out. The returned space will be orthogonal to this The second argument (ri_space) is the space that is being projected on. The returned space = this space - orb_space The third argument is the tolerance for linear dependencies. build_ri_space(molecule: psi::Molecule, obs_key: str, aux_key: str, lindep_tol: float) → psi4.core.OrbitalSpace¶; Given two basis sets, it merges the basis sets and then constructs an orthogonalized space with the same span. Linearly dependent orbitals are thrown out. The first argument, molecule, is the molecule to construct the basis for The second argument, obs_key, is the option keyword for orbital basis set ‘BASIS’ The third argument, aux_key, is the option keyword for auxiliery basis set ‘DF_BASIS_MP2’ The fourth argument, lindep_tol, is the tolerance for linear dependencies. dim(self: psi4.core.OrbitalSpace) → psi4.core.Dimension¶; MO dimensions. evals(self: psi4.core.OrbitalSpace) → psi4.core.Vector¶; Corresponding eigenvalues of the C matrix. id(self: psi4.core.OrbitalSpace) → str¶; Unique identifier. integral(self: psi4.core.OrbitalSpace) → psi4.core.IntegralFactory¶; The integral factory used to create C. name(self: psi4.core.OrbitalSpace) → str¶; Name of the orbital space. nirrep(self: psi4.core.OrbitalSpace) → int¶; Returns number of irreps. print_out(self: psi4.core.OrbitalSpace) → None¶; Print information about the orbital space to the output file. class psi4.core.OverlapInt¶; Bases: psi4.core.OneBodyAOInt; Computes overlap integrals. basis¶; The basis set on center one. basis1¶; The basis set on center one. basis2¶; The basis set on center two. compute_shell(self: psi4.core.OneBodyAOInt, a",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:215151,Availability,error,error,215151,"lf: psi4.core.Vector3) → float¶; Returns Euclidean norm of arg1. normalize(self: psi4.core.Vector3) → None¶; Returns vector of unit length and arg1 direction. class psi4.core.VectorMatrix¶; Bases: pybind11_builtins.pybind11_object. append(self: List[psi::Matrix], x: psi::Matrix) → None¶; Add an item to the end of the list. count(self: List[psi::Matrix], x: psi::Matrix) → int¶; Return the number of times x appears in the list. extend(self: List[psi::Matrix], L: List[psi::Matrix]) → None¶; Extend the list by appending all the items in the given list. insert(self: List[psi::Matrix], i: int, x: psi::Matrix) → None¶; Insert an item at a given position. pop(*args, **kwargs)¶; Overloaded function. pop(self: List[psi::Matrix]) -> psi::Matrix. Remove and return the last item. pop(self: List[psi::Matrix], i: int) -> psi::Matrix. Remove and return the item at index i. remove(self: List[psi::Matrix], x: psi::Matrix) → None¶; Remove the first item from the list whose value is x. It is an error if there is no such item. class psi4.core.Wavefunction¶; Bases: pybind11_builtins.pybind11_object; docstring. Ca(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Alpha Orbitals. Ca_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Matrix¶; Returns the requested Alpha Orbital subset. Cb(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Beta Orbitals. Cb_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Matrix¶; Returns the requested Beta Orbital subset. Da(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Alpha Density Matrix. Da_subset(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Returns the requested Alpha Density subset. Db(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Beta Density Matrix. Db_subset(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Returns the requested Beta Density subset. Fa(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Alpha F",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:228450,Availability,avail,available,228450,"st[psi::Matrix]¶; Gets list of displacements needed for a finite difference gradient computation, from energy points. psi4.core.fd_geoms_freq_0(arg0: psi::Molecule, arg1: int) → List[psi::Matrix]¶; Gets list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep. psi4.core.fd_geoms_freq_1(arg0: psi::Molecule, arg1: int) → List[psi::Matrix]¶; Gets list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep. psi4.core.finalize() → None¶. psi4.core.flush_outfile() → None¶; Flushes the output file. psi4.core.fnocc(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the fno-ccsd(t)/qcisd(t)/mp4/cepa energy code. psi4.core.get_active_efp() → psi4.core.EFP¶; Returns the currently active EFP object. psi4.core.get_active_molecule() → psi::Molecule¶; Returns the currently active molecule object. psi4.core.get_array_variable(arg0: str) → psi::Matrix¶; Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available). psi4.core.get_array_variables() → Dict[str, psi::Matrix]¶; Returns dictionary of the PSI variables set internally by the modules or python driver. psi4.core.get_atomic_point_charges() → psi::Vector¶; Returns the most recently computed atomic point charges, as a double * object. psi4.core.get_datadir() → str¶; Sets the path to shared text resources, PSIDATADIR. psi4.core.get_efp_torque() → psi::Matrix¶; Returns the most recently computed gradient for the EFP portion, as a Nefp by 6 Matrix object. psi4.core.get_frequencies() → psi::Vector¶; Returns the most recently computed frequencies, as a 3N-6 Vector object. psi4.core.get_global_option(arg0: str) → object¶; Given a string of a keyword name arg1, returns the value associated with the keyword from the global options. Returns error if keyword is not recognized. psi4.core.get_global_option_list() → List[str]¶; Returns a list of all global options. p",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:229248,Availability,error,error,229248,"le object. psi4.core.get_array_variable(arg0: str) → psi::Matrix¶; Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available). psi4.core.get_array_variables() → Dict[str, psi::Matrix]¶; Returns dictionary of the PSI variables set internally by the modules or python driver. psi4.core.get_atomic_point_charges() → psi::Vector¶; Returns the most recently computed atomic point charges, as a double * object. psi4.core.get_datadir() → str¶; Sets the path to shared text resources, PSIDATADIR. psi4.core.get_efp_torque() → psi::Matrix¶; Returns the most recently computed gradient for the EFP portion, as a Nefp by 6 Matrix object. psi4.core.get_frequencies() → psi::Vector¶; Returns the most recently computed frequencies, as a 3N-6 Vector object. psi4.core.get_global_option(arg0: str) → object¶; Given a string of a keyword name arg1, returns the value associated with the keyword from the global options. Returns error if keyword is not recognized. psi4.core.get_global_option_list() → List[str]¶; Returns a list of all global options. psi4.core.get_gradient() → psi::Matrix¶; Returns the most recently computed gradient, as a N by 3 Matrix object. psi4.core.get_legacy_molecule() → psi::Molecule¶; Returns the currently active molecule object. psi4.core.get_local_option(arg0: str, arg1: str) → object¶; Given a string of a keyword name arg2 and a particular module arg1, returns the value associated with the keyword in the module options scope. Returns error if keyword is not recognized for the module. psi4.core.get_memory() → int¶; Returns the amount of memory available to Psi (in bytes). psi4.core.get_num_threads() → int¶; Returns the number of threads to use in SMP parallel computations. psi4.core.get_option(arg0: str, arg1: str) → object¶; Given a string of a keyword name arg2 and a particular module arg1, returns the local value associated with the keyword if it’s been set, else the global value if it’s been ",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:229791,Availability,error,error,229791,", PSIDATADIR. psi4.core.get_efp_torque() → psi::Matrix¶; Returns the most recently computed gradient for the EFP portion, as a Nefp by 6 Matrix object. psi4.core.get_frequencies() → psi::Vector¶; Returns the most recently computed frequencies, as a 3N-6 Vector object. psi4.core.get_global_option(arg0: str) → object¶; Given a string of a keyword name arg1, returns the value associated with the keyword from the global options. Returns error if keyword is not recognized. psi4.core.get_global_option_list() → List[str]¶; Returns a list of all global options. psi4.core.get_gradient() → psi::Matrix¶; Returns the most recently computed gradient, as a N by 3 Matrix object. psi4.core.get_legacy_molecule() → psi::Molecule¶; Returns the currently active molecule object. psi4.core.get_local_option(arg0: str, arg1: str) → object¶; Given a string of a keyword name arg2 and a particular module arg1, returns the value associated with the keyword in the module options scope. Returns error if keyword is not recognized for the module. psi4.core.get_memory() → int¶; Returns the amount of memory available to Psi (in bytes). psi4.core.get_num_threads() → int¶; Returns the number of threads to use in SMP parallel computations. psi4.core.get_option(arg0: str, arg1: str) → object¶; Given a string of a keyword name arg2 and a particular module arg1, returns the local value associated with the keyword if it’s been set, else the global value if it’s been set, else the local core.default value. Returns error if keyword is not recognized globally or if keyword is not recognized for the module. psi4.core.get_options() → psi::Options¶; Get options. psi4.core.get_output_file() → str¶. psi4.core.get_variable(arg0: str) → float¶; Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available). psi4.core.get_variables() → Dict[str, float]¶; Returns dictionary of the PSI variables set internally by the modules or python driver. psi4.cor",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:229902,Availability,avail,available,229902,"ly computed gradient for the EFP portion, as a Nefp by 6 Matrix object. psi4.core.get_frequencies() → psi::Vector¶; Returns the most recently computed frequencies, as a 3N-6 Vector object. psi4.core.get_global_option(arg0: str) → object¶; Given a string of a keyword name arg1, returns the value associated with the keyword from the global options. Returns error if keyword is not recognized. psi4.core.get_global_option_list() → List[str]¶; Returns a list of all global options. psi4.core.get_gradient() → psi::Matrix¶; Returns the most recently computed gradient, as a N by 3 Matrix object. psi4.core.get_legacy_molecule() → psi::Molecule¶; Returns the currently active molecule object. psi4.core.get_local_option(arg0: str, arg1: str) → object¶; Given a string of a keyword name arg2 and a particular module arg1, returns the value associated with the keyword in the module options scope. Returns error if keyword is not recognized for the module. psi4.core.get_memory() → int¶; Returns the amount of memory available to Psi (in bytes). psi4.core.get_num_threads() → int¶; Returns the number of threads to use in SMP parallel computations. psi4.core.get_option(arg0: str, arg1: str) → object¶; Given a string of a keyword name arg2 and a particular module arg1, returns the local value associated with the keyword if it’s been set, else the global value if it’s been set, else the local core.default value. Returns error if keyword is not recognized globally or if keyword is not recognized for the module. psi4.core.get_options() → psi::Options¶; Get options. psi4.core.get_output_file() → str¶. psi4.core.get_variable(arg0: str) → float¶; Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available). psi4.core.get_variables() → Dict[str, float]¶; Returns dictionary of the PSI variables set internally by the modules or python driver. psi4.core.get_writer_file_prefix(arg0: str) → str¶; Returns the prefix to use for writi",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:230309,Availability,error,error,230309," all global options. psi4.core.get_gradient() → psi::Matrix¶; Returns the most recently computed gradient, as a N by 3 Matrix object. psi4.core.get_legacy_molecule() → psi::Molecule¶; Returns the currently active molecule object. psi4.core.get_local_option(arg0: str, arg1: str) → object¶; Given a string of a keyword name arg2 and a particular module arg1, returns the value associated with the keyword in the module options scope. Returns error if keyword is not recognized for the module. psi4.core.get_memory() → int¶; Returns the amount of memory available to Psi (in bytes). psi4.core.get_num_threads() → int¶; Returns the number of threads to use in SMP parallel computations. psi4.core.get_option(arg0: str, arg1: str) → object¶; Given a string of a keyword name arg2 and a particular module arg1, returns the local value associated with the keyword if it’s been set, else the global value if it’s been set, else the local core.default value. Returns error if keyword is not recognized globally or if keyword is not recognized for the module. psi4.core.get_options() → psi::Options¶; Get options. psi4.core.get_output_file() → str¶. psi4.core.get_variable(arg0: str) → float¶; Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available). psi4.core.get_variables() → Dict[str, float]¶; Returns dictionary of the PSI variables set internally by the modules or python driver. psi4.core.get_writer_file_prefix(arg0: str) → str¶; Returns the prefix to use for writing files for external programs. psi4.core.git_version() → str¶; Returns the git version of this copy of Psi. psi4.core.has_global_option_changed(arg0: str) → bool¶; Returns boolean for whether the keyword arg1 has been touched in the global scope, by either user or code. Notwithstanding, code is written such that in practice, this returns whether the option has been touched in the global scope by the user. psi4.core.has_local_option_changed(arg0: str, arg",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:230657,Availability,avail,available,230657,".core.get_local_option(arg0: str, arg1: str) → object¶; Given a string of a keyword name arg2 and a particular module arg1, returns the value associated with the keyword in the module options scope. Returns error if keyword is not recognized for the module. psi4.core.get_memory() → int¶; Returns the amount of memory available to Psi (in bytes). psi4.core.get_num_threads() → int¶; Returns the number of threads to use in SMP parallel computations. psi4.core.get_option(arg0: str, arg1: str) → object¶; Given a string of a keyword name arg2 and a particular module arg1, returns the local value associated with the keyword if it’s been set, else the global value if it’s been set, else the local core.default value. Returns error if keyword is not recognized globally or if keyword is not recognized for the module. psi4.core.get_options() → psi::Options¶; Get options. psi4.core.get_output_file() → str¶. psi4.core.get_variable(arg0: str) → float¶; Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available). psi4.core.get_variables() → Dict[str, float]¶; Returns dictionary of the PSI variables set internally by the modules or python driver. psi4.core.get_writer_file_prefix(arg0: str) → str¶; Returns the prefix to use for writing files for external programs. psi4.core.git_version() → str¶; Returns the git version of this copy of Psi. psi4.core.has_global_option_changed(arg0: str) → bool¶; Returns boolean for whether the keyword arg1 has been touched in the global scope, by either user or code. Notwithstanding, code is written such that in practice, this returns whether the option has been touched in the global scope by the user. psi4.core.has_local_option_changed(arg0: str, arg1: str) → bool¶; Returns boolean for whether the keyword arg2 has been touched in the scope of the specified module arg1, by either user or code. Notwithstanding, code is written such that in practice, this returns whether the option h",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:236155,Availability,avail,available,236155,"s, this command is called on the option so that has_changed reflects whether the user (not the program) has touched the option. psi4.core.run_gdma(arg0: psi::Wavefunction, arg1: str) → float¶; Runs the GDMA code. psi4.core.sapt(arg0: psi::Wavefunction, arg1: psi::Wavefunction, arg2: psi::Wavefunction) → float¶; Runs the symmetry adapted perturbation theory code. psi4.core.scatter(arg0: psi::Molecule, arg1: float, arg2: list, arg3: list, arg4: list) → None¶; New Scatter function. psi4.core.scfgrad(arg0: psi::Wavefunction) → psi::Matrix¶; Run scfgrad, which is a specialized DF-SCF gradient program. psi4.core.scfhess(arg0: psi::Wavefunction) → psi::Matrix¶; Run scfhess, which is a specialized DF-SCF hessian program. psi4.core.set_active_molecule(arg0: psi::Molecule) → None¶; Activates a previously defined (in the input) molecule, by name. psi4.core.set_array_variable(arg0: str, arg1: psi::Matrix) → None¶; Sets a PSI variable, by name. psi4.core.set_datadir(arg0: str) → None¶; Returns the amount of memory available to Psi (in bytes). psi4.core.set_efp_torque(arg0: psi::Matrix) → None¶; Assigns the global EFP gradient to the values stored in the Nefp by 6 Matrix argument. psi4.core.set_frequencies(arg0: psi::Vector) → None¶; Assigns the global frequencies to the values stored in the 3N-6 Vector argument. psi4.core.set_global_option(*args, **kwargs)¶; Overloaded function. set_global_option(arg0: str, arg1: list) -> bool. Sets value arg2 to array keyword arg1 for all modules. set_global_option(arg0: str, arg1: int) -> bool. Sets value arg2 to integer keyword arg1 for all modules. set_global_option(arg0: str, arg1: float) -> bool. Sets value arg2 to double keyword arg1 for all modules. set_global_option(arg0: str, arg1: str) -> bool. Sets value arg2 to string keyword arg1 for all modules. psi4.core.set_gradient(arg0: psi::Matrix) → None¶; Assigns the global gradient to the values stored in the N by 3 Matrix argument. psi4.core.set_legacy_molecule(arg0: psi::Molecule) → None¶",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:238196,Availability,avail,available,238196,"in the input) molecule, by name. psi4.core.set_legacy_wavefunction(arg0: psi::Wavefunction) → None¶; Returns the current legacy_wavefunction object from the most recent computation. psi4.core.set_local_option(*args, **kwargs)¶; Overloaded function. set_local_option(arg0: str, arg1: str, arg2: list) -> bool. Sets value arg3 to array keyword arg2 scoped only to a specific module arg1. set_local_option(arg0: str, arg1: str, arg2: int) -> bool. Sets value arg3 to integer keyword arg2 scoped only to a specific module arg1. set_local_option(arg0: str, arg1: str, arg2: float) -> bool. Sets value arg3 to double keyword arg2 scoped only to a specific module arg1. set_local_option(arg0: str, arg1: str, arg2: str) -> bool. Sets value arg3 to string keyword arg2 scoped only to a specific module arg1. psi4.core.set_local_option_python(arg0: str, arg1: object) → None¶; Sets an option to a Python object, but scoped only to a single module. psi4.core.set_memory_bytes(memory: int, quiet: bool=False) → None¶; Sets the memory available to Psi (in bytes). psi4.core.set_num_threads(nthread: int, quiet: bool=False) → None¶; Sets the number of threads to use in SMP parallel computations. psi4.core.set_output_file(*args, **kwargs)¶; Overloaded function. set_output_file(arg0: str) -> None; set_output_file(arg0: str, arg1: bool) -> None. psi4.core.set_parent_symmetry(arg0: str) → None¶; Sets the symmetry of the ‘parent’ (undisplaced) geometry, by Schoenflies symbol, at the beginning of a finite difference computation. psi4.core.set_psi_file_prefix(arg0: str) → None¶. psi4.core.set_variable(arg0: str, arg1: float) → None¶; Sets a PSI variable, by name. psi4.core.tstart() → None¶; docstring. psi4.core.tstop() → None¶; docstring. psi4.core.version() → str¶; Returns the version ID of this copy of Psi. Functions¶. DASUM(arg0, arg1, arg2, arg3); docstring. DAXPY(arg0, arg1, arg2, arg3, arg4, arg5, arg6); docstring. DCOPY(arg0, arg1, arg2, arg3, arg4, arg5); docstring. DDOT(arg0, arg1, arg2, arg3, ",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:243895,Availability,avail,available,243895,"on, from energy points. fd_freq_0(arg0, arg1, arg2); Performs a finite difference frequency computation, from energy points, for a given irrep. fd_freq_1(arg0, arg1, arg2); Performs a finite difference frequency computation, from gradients, for a given irrep. fd_geoms_1_0(arg0); Gets list of displacements needed for a finite difference gradient computation, from energy points. fd_geoms_freq_0(arg0, arg1); Gets list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep. fd_geoms_freq_1(arg0, arg1); Gets list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep. finalize(). flush_outfile(); Flushes the output file. fnocc(arg0); Runs the fno-ccsd(t)/qcisd(t)/mp4/cepa energy code. get_active_efp(); Returns the currently active EFP object. get_active_molecule(); Returns the currently active molecule object. get_array_variable(arg0); Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available). get_array_variables(); Returns dictionary of the PSI variables set internally by the modules or python driver. get_atomic_point_charges(); Returns the most recently computed atomic point charges, as a double * object. get_datadir(); Sets the path to shared text resources, PSIDATADIR. get_efp_torque(); Returns the most recently computed gradient for the EFP portion, as a Nefp by 6 Matrix object. get_frequencies(); Returns the most recently computed frequencies, as a 3N-6 Vector object. get_global_option(arg0); Given a string of a keyword name arg1, returns the value associated with the keyword from the global options. get_global_option_list(); Returns a list of all global options. get_gradient(); Returns the most recently computed gradient, as a N by 3 Matrix object. get_legacy_molecule(); Returns the currently active molecule object. get_local_option(arg0, arg1); Given a string of a keyword name arg2 and a",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:244969,Availability,avail,available,244969,"ariables set internally by the modules or python driver. get_atomic_point_charges(); Returns the most recently computed atomic point charges, as a double * object. get_datadir(); Sets the path to shared text resources, PSIDATADIR. get_efp_torque(); Returns the most recently computed gradient for the EFP portion, as a Nefp by 6 Matrix object. get_frequencies(); Returns the most recently computed frequencies, as a 3N-6 Vector object. get_global_option(arg0); Given a string of a keyword name arg1, returns the value associated with the keyword from the global options. get_global_option_list(); Returns a list of all global options. get_gradient(); Returns the most recently computed gradient, as a N by 3 Matrix object. get_legacy_molecule(); Returns the currently active molecule object. get_local_option(arg0, arg1); Given a string of a keyword name arg2 and a particular module arg1, returns the value associated with the keyword in the module options scope. get_memory(); Returns the amount of memory available to Psi (in bytes). get_num_threads(); Returns the number of threads to use in SMP parallel computations. get_option(arg0, arg1); Given a string of a keyword name arg2 and a particular module arg1, returns the local value associated with the keyword if it’s been set, else the global value if it’s been set, else the local core.default value. get_options(); Get options. get_output_file(). get_variable(arg0); Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available). get_variables(); Returns dictionary of the PSI variables set internally by the modules or python driver. get_writer_file_prefix(arg0); Returns the prefix to use for writing files for external programs. git_version(); Returns the git version of this copy of Psi. has_global_option_changed(arg0); Returns boolean for whether the keyword arg1 has been touched in the global scope, by either user or code. has_local_option_changed(arg0, arg1);",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:245510,Availability,avail,available,245510,"yword name arg1, returns the value associated with the keyword from the global options. get_global_option_list(); Returns a list of all global options. get_gradient(); Returns the most recently computed gradient, as a N by 3 Matrix object. get_legacy_molecule(); Returns the currently active molecule object. get_local_option(arg0, arg1); Given a string of a keyword name arg2 and a particular module arg1, returns the value associated with the keyword in the module options scope. get_memory(); Returns the amount of memory available to Psi (in bytes). get_num_threads(); Returns the number of threads to use in SMP parallel computations. get_option(arg0, arg1); Given a string of a keyword name arg2 and a particular module arg1, returns the local value associated with the keyword if it’s been set, else the global value if it’s been set, else the local core.default value. get_options(); Get options. get_output_file(). get_variable(arg0); Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available). get_variables(); Returns dictionary of the PSI variables set internally by the modules or python driver. get_writer_file_prefix(arg0); Returns the prefix to use for writing files for external programs. git_version(); Returns the git version of this copy of Psi. has_global_option_changed(arg0); Returns boolean for whether the keyword arg1 has been touched in the global scope, by either user or code. has_local_option_changed(arg0, arg1); Returns boolean for whether the keyword arg2 has been touched in the scope of the specified module arg1, by either user or code. has_option_changed(arg0, arg1); Returns boolean for whether the option arg2 has been touched either locally to the specified module arg1 or globally, by either user or code. has_variable(arg0); Returns true if the PSI variable exists/is set. initialize(). legacy_wavefunction(); Returns the current legacy_wavefunction object from the most recent comput",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:248768,Availability,avail,available,248768,"p_srcdir(); Returns the location of the source code. psimrcc(arg0); Runs the multireference coupled cluster code. reopen_outfile(); Reopens the output file. revoke_global_option_changed(arg0); Given a string of a keyword name arg1, sets the has_changed attribute in the global options scope to false. revoke_local_option_changed(arg0, arg1); Given a string of a keyword name arg2 and a particular module arg1, sets the has_changed attribute in the module options scope to false. run_gdma(arg0, arg1); Runs the GDMA code. sapt(arg0, arg1, arg2); Runs the symmetry adapted perturbation theory code. scatter(arg0, arg1, arg2, arg3, arg4); New Scatter function. scfgrad(arg0); Run scfgrad, which is a specialized DF-SCF gradient program. scfhess(arg0); Run scfhess, which is a specialized DF-SCF hessian program. set_active_molecule(arg0); Activates a previously defined (in the input) molecule, by name. set_array_variable(arg0, arg1); Sets a PSI variable, by name. set_datadir(arg0); Returns the amount of memory available to Psi (in bytes). set_efp_torque(arg0); Assigns the global EFP gradient to the values stored in the Nefp by 6 Matrix argument. set_frequencies(arg0); Assigns the global frequencies to the values stored in the 3N-6 Vector argument. set_global_option(*args, **kwargs); Overloaded function. set_global_option_python(key, EXTERN); This is a fairly hacky way to get around EXTERN issues. set_gradient(arg0); Assigns the global gradient to the values stored in the N by 3 Matrix argument. set_legacy_molecule(arg0); Activates a previously defined (in the input) molecule, by name. set_legacy_wavefunction(arg0); Returns the current legacy_wavefunction object from the most recent computation. set_local_option(*args, **kwargs); Overloaded function. set_local_option_python(arg0, arg1); Sets an option to a Python object, but scoped only to a single module. set_memory_bytes(memory, quiet); Sets the memory available to Psi (in bytes). set_num_threads(nthread, quiet); Sets the number o",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:249679,Availability,avail,available,249679,"variable(arg0, arg1); Sets a PSI variable, by name. set_datadir(arg0); Returns the amount of memory available to Psi (in bytes). set_efp_torque(arg0); Assigns the global EFP gradient to the values stored in the Nefp by 6 Matrix argument. set_frequencies(arg0); Assigns the global frequencies to the values stored in the 3N-6 Vector argument. set_global_option(*args, **kwargs); Overloaded function. set_global_option_python(key, EXTERN); This is a fairly hacky way to get around EXTERN issues. set_gradient(arg0); Assigns the global gradient to the values stored in the N by 3 Matrix argument. set_legacy_molecule(arg0); Activates a previously defined (in the input) molecule, by name. set_legacy_wavefunction(arg0); Returns the current legacy_wavefunction object from the most recent computation. set_local_option(*args, **kwargs); Overloaded function. set_local_option_python(arg0, arg1); Sets an option to a Python object, but scoped only to a single module. set_memory_bytes(memory, quiet); Sets the memory available to Psi (in bytes). set_num_threads(nthread, quiet); Sets the number of threads to use in SMP parallel computations. set_output_file(*args, **kwargs); Overloaded function. set_parent_symmetry(arg0); Sets the symmetry of the ‘parent’ (undisplaced) geometry, by Schoenflies symbol, at the beginning of a finite difference computation. set_psi_file_prefix(arg0). set_variable(arg0, arg1); Sets a PSI variable, by name. tstart(); docstring. tstop(); docstring. version(); Returns the version ID of this copy of Psi. Classes¶. AOShellCombinationsIterator. AngularMomentumInt; Computes angular momentum integrals. BSVec. BasisExtents; docstring. BasisFunctions; docstring. BasisSet; Contains basis set information. BlockOPoints; docstring. BoysLocalizer; Performs Boys orbital localization. CIVector; docstring. CIWavefunction; docstring. CUHF; docstring. CdSalcList; Class for generating symmetry adapted linear combinations of Cartesian displacements. CorrelationFactor; docstring. Co",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:259097,Availability,avail,available,259097,"es against PSIvariables. compare_cubes(expected, computed, label); Function to compare two cube files. compare_fcidumps(expected, computed, label); Function to compare two FCIDUMP files. compare_integers(expected, computed, label); Function to compare two integers. compare_matrices(expected, computed, digits, …); Function to compare two matrices. compare_strings(expected, computed, label); Function to compare two strings. compare_values(expected, computed, digits, label); Function to compare two values. compare_vectors(expected, computed, digits, …); Function to compare two vectors. copy_file_from_scratch(filename, prefix, …); Function to move file out of scratch with correct naming convention. copy_file_to_scratch(filename, prefix, …); Function to move file into scratch with correct naming convention. create_plugin(name, template); Generate plugin in directory with sanitized name based upon template. csx2endict(); Grabs the CSX file as a dictionary, encodes translation of PSI variables to XML blocks, gathers all available energies from CSX file into returned dictionary. cubeprop(wfn, **kwargs); Evaluate properties on a grid and generate cube files. dynamic_variable_bind(cls); Function to dynamically add extra members to the core.Molecule class. energy(name, **kwargs); Function to compute the single-point electronic energy. fchk(wfn, filename); Function to write wavefunction information in wfn to filename in Gaussian FCHK format. fcidump(wfn[, fname, oe_ints]); Save integrals to file in FCIDUMP format as defined in Comp. fcidump_from_file(fname); Function to read in a FCIDUMP file. filter_comments(string); Remove from string any Python-style comments (‘#’ to end of line). find_approximate_string_matches(seq1, …); Function to compute approximate string matches from a list of options. freq(name, **kwargs); Function to compute harmonic vibrational frequencies. frequencies(name, **kwargs); Function to compute harmonic vibrational frequencies. frequency(name, **kwargs); F",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:261529,Availability,error,error,261529,"plementary to :py:func:~driver.optimize(). hessian(name, **kwargs); Function complementary to frequency(). join_path(prefix, *args). levenshtein(seq1, seq2); Function to compute the Levenshtein distance between two strings. molden(wfn[, filename, density_a, …]); Function to write wavefunction information in wfn to filename in molden format. molecule_from_arrays; classmethod(function) -> method. molecule_from_schema; classmethod(function) -> method. molecule_from_string; classmethod(function) -> method. molecule_get_attr(self, name); Function to redefine __getattr__ method of molecule class. molecule_set_attr(self, name, value); Function to redefine __setattr__ method of molecule class. oeprop(wfn, *args, **kwargs); Evaluate one-electron properties. opt(name, **kwargs); Function to perform a geometry optimization. optimize(name, **kwargs); Function to perform a geometry optimization. pcm_helper(block); Passes multiline string block to PCMSolver parser. print_stderr(stuff); Function to print stuff to standard error stream. print_stdout(stuff); Function to print stuff to standard output stream. process_input(raw_input[, print_level]); Function to preprocess raw input, the text of the input file, then parse it, validate it for format, and convert it into legitimate Python. process_pubchem_command(matchobj); Function to process match of pubchem in molecule block. prop(*args, **kwargs); Function to compute various properties. properties(*args, **kwargs); Function to compute various properties. sanitize_name(name); Function to return name in coded form, stripped of characters that confuse filenames, characters into lowercase, + into p, * into s, and (, ), -, & , into _. scf_helper(name[, post_scf]); Function serving as helper to SCF, choosing whether to cast up or just run SCF with a standard guess. scf_wavefunction_factory(name, ref_wfn, …); Builds the correct wavefunction from the provided information. set_memory(inputval[, execute]); Function to reset the total memory al",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:46795,Deployability,update,update,46795,".SOMCSCF, arg0: psi4.core.Matrix) → psi4.core.Matrix¶. compute_Hk(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix) → psi4.core.Matrix¶. compute_Q(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix) → psi4.core.Matrix¶. compute_Qk(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix, arg2: psi4.core.Matrix) → psi4.core.Matrix¶. current_AFock(self: psi4.core.SOMCSCF) → psi4.core.Matrix¶. current_IFock(self: psi4.core.SOMCSCF) → psi4.core.Matrix¶. current_ci_energy(self: psi4.core.SOMCSCF) → float¶. current_docc_energy(self: psi4.core.SOMCSCF) → float¶. current_total_energy(self: psi4.core.SOMCSCF) → float¶. form_rotation_matrix(self: psi4.core.SOMCSCF, x: psi4.core.Matrix, order: int=2) → psi4.core.Matrix¶. gradient(self: psi4.core.SOMCSCF) → psi4.core.Matrix¶. gradient_rms(self: psi4.core.SOMCSCF) → float¶. rhf_energy(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix) → float¶. solve(self: psi4.core.SOMCSCF, arg0: int, arg1: float, arg2: bool) → psi4.core.Matrix¶. update(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix, arg2: psi4.core.Matrix, arg3: psi4.core.Matrix, arg4: psi4.core.Matrix) → None¶. zero_redundant(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix) → None¶. class psi4.core.DFTGrid¶; Bases: psi4.core.MolecularGrid; docstring. blocks(self: psi4.core.MolecularGrid) → List[psi4.core.BlockOPoints]¶; Returns a list of blocks. build(*args, **kwargs)¶; Overloaded function. build(arg0: psi4.core.Molecule, arg1: psi4.core.BasisSet) -> psi4.core.DFTGrid; build(arg0: psi4.core.Molecule, arg1: psi4.core.BasisSet, arg2: Dict[str, int], arg3: Dict[str, str]) -> psi4.core.DFTGrid. max_functions(self: psi4.core.MolecularGrid) → int¶; Returns the maximum number of functions in a block. max_points(self: psi4.core.MolecularGrid) → int¶; Returns the maximum number of points in a block. npoints(self: psi4.core.MolecularGrid) → int¶; Returns the number of grid points. orientation(self: psi4.core.MolecularGrid) → psi4.core.Matrix¶; Returns t",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:57209,Deployability,update,update,57209,".SOMCSCF, arg0: psi4.core.Matrix) → psi4.core.Matrix¶. compute_Hk(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix) → psi4.core.Matrix¶. compute_Q(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix) → psi4.core.Matrix¶. compute_Qk(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix, arg2: psi4.core.Matrix) → psi4.core.Matrix¶. current_AFock(self: psi4.core.SOMCSCF) → psi4.core.Matrix¶. current_IFock(self: psi4.core.SOMCSCF) → psi4.core.Matrix¶. current_ci_energy(self: psi4.core.SOMCSCF) → float¶. current_docc_energy(self: psi4.core.SOMCSCF) → float¶. current_total_energy(self: psi4.core.SOMCSCF) → float¶. form_rotation_matrix(self: psi4.core.SOMCSCF, x: psi4.core.Matrix, order: int=2) → psi4.core.Matrix¶. gradient(self: psi4.core.SOMCSCF) → psi4.core.Matrix¶. gradient_rms(self: psi4.core.SOMCSCF) → float¶. rhf_energy(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix) → float¶. solve(self: psi4.core.SOMCSCF, arg0: int, arg1: float, arg2: bool) → psi4.core.Matrix¶. update(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix, arg2: psi4.core.Matrix, arg3: psi4.core.Matrix, arg4: psi4.core.Matrix) → None¶. zero_redundant(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix) → None¶. class psi4.core.Dispersion¶; Bases: pybind11_builtins.pybind11_object; docstring. a1(self: psi4.core.Dispersion) → float¶; docstring. a2(self: psi4.core.Dispersion) → float¶; docstring. bibtex(self: psi4.core.Dispersion) → str¶; Get the BibTeX key for the literature reference. build(type: str, s6: float=0.0, p1: float=0.0, p2: float=0.0, p3: float=0.0) → psi4.core.Dispersion¶; docstring. citation(self: psi4.core.Dispersion) → str¶; docstring. compute_energy(self: psi4.core.Dispersion, arg0: psi4.core.Molecule) → float¶; docstring. compute_gradient(self: psi4.core.Dispersion, arg0: psi4.core.Molecule) → psi4.core.Matrix¶; docstring. compute_hessian(self: psi4.core.Dispersion, arg0: psi4.core.Molecule) → psi4.core.Matrix¶; docstring. d(self: psi4.core.Dispersion) → f",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:185559,Deployability,update,update,185559,".SOMCSCF, arg0: psi4.core.Matrix) → psi4.core.Matrix¶. compute_Hk(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix) → psi4.core.Matrix¶. compute_Q(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix) → psi4.core.Matrix¶. compute_Qk(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix, arg2: psi4.core.Matrix) → psi4.core.Matrix¶. current_AFock(self: psi4.core.SOMCSCF) → psi4.core.Matrix¶. current_IFock(self: psi4.core.SOMCSCF) → psi4.core.Matrix¶. current_ci_energy(self: psi4.core.SOMCSCF) → float¶. current_docc_energy(self: psi4.core.SOMCSCF) → float¶. current_total_energy(self: psi4.core.SOMCSCF) → float¶. form_rotation_matrix(self: psi4.core.SOMCSCF, x: psi4.core.Matrix, order: int=2) → psi4.core.Matrix¶. gradient(self: psi4.core.SOMCSCF) → psi4.core.Matrix¶. gradient_rms(self: psi4.core.SOMCSCF) → float¶. rhf_energy(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix) → float¶. solve(self: psi4.core.SOMCSCF, arg0: int, arg1: float, arg2: bool) → psi4.core.Matrix¶. update(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix, arg2: psi4.core.Matrix, arg3: psi4.core.Matrix, arg4: psi4.core.Matrix) → None¶. zero_redundant(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix) → None¶. class psi4.core.SaveType¶; Bases: pybind11_builtins.pybind11_object; The layout of the matrix for saving. Full = SaveType.Full¶. LowerTriangle = SaveType.LowerTriangle¶. SubBlocks = SaveType.SubBlocks¶. class psi4.core.ShellInfo¶; Bases: pybind11_builtins.pybind11_object. class psi4.core.Slice¶; Bases: pybind11_builtins.pybind11_object; Slicing for Matrix and Vector objects. begin(self: psi4.core.Slice) → psi4.core.Dimension¶; Get the first element of this slice. end(self: psi4.core.Slice) → psi4.core.Dimension¶; Get the past-the-end element of this slice. class psi4.core.SuperFunctional¶; Bases: pybind11_builtins.pybind11_object; docstring. XC_build(arg0: str, arg1: bool) → psi4.core.SuperFunctional¶; Builds a SuperFunctional from a XC string. add_c_functional(sel",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:226044,Deployability,configurat,configuration,226044,"e the similarity transformed Hamiltonian. psi4.core.cclambda(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the coupled cluster lambda equations code. psi4.core.ccresponse(arg0: psi::Wavefunction) → float¶; Runs the coupled cluster response theory code. psi4.core.cctransort(arg0: psi::Wavefunction) → None¶; Runs CCTRANSORT, which transforms and reorders integrals for use in the coupled cluster codes. psi4.core.cctriples(arg0: psi::Wavefunction) → float¶; Runs the coupled cluster (T) energy code. psi4.core.clean() → None¶; Function to remove scratch files. Call between independent jobs. psi4.core.clean_options() → None¶; Function to reset options to clean state. psi4.core.clean_variables() → None¶; Empties all PSI variables that have set internally. psi4.core.close_outfile() → None¶; Closes the output file. psi4.core.dcft(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the density cumulant functional theory code. psi4.core.detci(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the determinant-based configuration interaction code. psi4.core.dfmp2(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the DF-MP2 code. psi4.core.dfocc(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the density-fitted orbital optimized CC codes. psi4.core.displace_atom(arg0: psi::Matrix, arg1: int, arg2: int, arg3: int, arg4: float) → None¶; Displaces one coordinate of single atom. psi4.core.dmrg(arg0: psi::Wavefunction) → float¶; Runs the DMRG code. psi4.core.efp_init() → psi4.core.EFP¶; Initializes the EFP library and returns an EFP object. psi4.core.efp_set_options() → None¶; Set EFP options from environment options object. psi4.core.fcidump_tei_helper(nirrep: int, restricted: bool, DPD_info: Dict[str, int], ints_tolerance: float, fname: str='INTDUMP') → None¶; Write integrals to file in FCIDUMP format. psi4.core.fd_1_0(arg0: psi::Molecule, arg1: list) → psi::Matrix¶; Performs a finite difference gradient computation, from energy points. psi4.core.fd_freq_0(arg0: psi::Mole",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:242288,Deployability,configurat,configuration,242288,"arg1); docstring. benchmark_integrals(arg0, arg1); docstring. benchmark_math(arg0); docstring. ccdensity(arg0); Runs the code to compute coupled cluster density matrices. ccenergy(arg0); Runs the coupled cluster energy code. cceom(arg0); Runs the equation of motion coupled cluster code, for excited states. cchbar(arg0); Runs the code to generate the similarity transformed Hamiltonian. cclambda(arg0); Runs the coupled cluster lambda equations code. ccresponse(arg0); Runs the coupled cluster response theory code. cctransort(arg0); Runs CCTRANSORT, which transforms and reorders integrals for use in the coupled cluster codes. cctriples(arg0); Runs the coupled cluster (T) energy code. clean(); Function to remove scratch files. clean_options(); Function to reset options to clean state. clean_variables(); Empties all PSI variables that have set internally. close_outfile(); Closes the output file. dcft(arg0); Runs the density cumulant functional theory code. detci(arg0); Runs the determinant-based configuration interaction code. dfmp2(arg0); Runs the DF-MP2 code. dfocc(arg0); Runs the density-fitted orbital optimized CC codes. displace_atom(arg0, arg1, arg2, arg3, arg4); Displaces one coordinate of single atom. dmrg(arg0); Runs the DMRG code. efp_init(); Initializes the EFP library and returns an EFP object. efp_set_options(); Set EFP options from environment options object. fcidump_tei_helper(nirrep, restricted, …); Write integrals to file in FCIDUMP format. fd_1_0(arg0, arg1); Performs a finite difference gradient computation, from energy points. fd_freq_0(arg0, arg1, arg2); Performs a finite difference frequency computation, from energy points, for a given irrep. fd_freq_1(arg0, arg1, arg2); Performs a finite difference frequency computation, from gradients, for a given irrep. fd_geoms_1_0(arg0); Gets list of displacements needed for a finite difference gradient computation, from energy points. fd_geoms_freq_0(arg0, arg1); Gets list of displacements needed for a finite d",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:264409,Deployability,update,updated,264409,"et the total memory allocation. set_module_options(module, options_dict); Sets Psi4 module options from a module specification and input dictionary. set_options(options_dict); Sets Psi4 global options from an input dictionary. success(label); Function to print a ‘label…PASSED’ line to screen. vibanal_wfn(wfn[, hess, irrep, molecule, …]). write_eigenvalues(eigs, mo_idx); Prepare multi-line string with one-particle eigenvalues to be written to the FCIDUMP file. xml2dict([filename]); Read XML filename into nested OrderedDict-s. Classes¶. CSXError(msg); Error called when CSX generation fails. ConvergenceError(eqn_description, maxit); Error called for problems with converging and iterative method. Dftd3Error(msg). EmpericalDispersion(alias, dtype, **kwargs). ManagedMethodError(circs). OptimizationConvergenceError(…); Error called for problems with geometry optimizer. ParsingError(msg); Error called for problems parsing a text file. PastureRequiredError(option); Error called when the specified value of option requires some module(s) from Psi4Pasture, but could not be imported. PsiException; Error class for Psi. PsiImportError(msg); Error called for problems import python dependencies. QMMM(). Table([rows, row_label_width, …]); Class defining a flexible Table object for storing data. TestComparisonError(msg); Error called when a test case fails due to a failed compare_values() call. ValidationError(msg); Error called for problems with the input file. datetime(year, month, day[, hour[, minute[, …); The year, month and day arguments are required. Class Inheritance Diagram¶. table of contents. PSI4 API: Linking C++ and Python; psi4.core Module; Functions; Classes; Class Inheritance Diagram. psi4.driver Package; Functions; Classes; Class Inheritance Diagram. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:11318,Energy Efficiency,charge,charges,11318,"eta Density subset. Fa(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Alpha Fock Matrix. Fb(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Beta Fock Matrix. H(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the ‘Core’ Matrix (Potential + Kinetic) Integrals. Hd_vector(self: psi4.core.CIWavefunction, arg0: int) → psi::detci::CIvect¶; docstring. S(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the One-electron Overlap Matrix. X(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Lagrangian Matrix. alpha_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. aotoso(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Atomic Orbital to Symmetry Orbital transformer. arrays(self: psi4.core.Wavefunction) → Dict[str, psi4.core.Matrix]¶; Returns the map of all internal arrays. atomic_point_charges(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.Wavefunction, basis: psi4.core.BasisSet) → psi4.core.Wavefunction¶; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet *basis. ci_nat_orbs(self: psi4.core.CIWavefunction) → None¶; docstring. cleanup_ci(self: psi4.core.CIWavefunction) → None¶; docstring. cleanup_dpd(self: psi4.core.CIWavefunction) → None¶; docstring. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. comp",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:12271,Energy Efficiency,energy,energy,12271,") → psi4.core.Vector¶; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.Wavefunction, basis: psi4.core.BasisSet) → psi4.core.Wavefunction¶; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet *basis. ci_nat_orbs(self: psi4.core.CIWavefunction) → None¶; docstring. cleanup_ci(self: psi4.core.CIWavefunction) → None¶; docstring. cleanup_dpd(self: psi4.core.CIWavefunction) → None¶; docstring. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. compute_state_transfer(self: psi4.core.CIWavefunction, arg0: psi::detci::CIvect, arg1: int, arg2: psi4.core.Matrix, arg3: psi::detci::CIvect) → None¶; docstring. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. diag_h(self: psi4.core.CIWavefunction, arg0: float, arg1: float) → int¶; docstring. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns t",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:12994,Energy Efficiency,energy,energy,12994,"t *basis. ci_nat_orbs(self: psi4.core.CIWavefunction) → None¶; docstring. cleanup_ci(self: psi4.core.CIWavefunction) → None¶; docstring. cleanup_dpd(self: psi4.core.CIWavefunction) → None¶; docstring. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. compute_state_transfer(self: psi4.core.CIWavefunction, arg0: psi::detci::CIvect, arg1: int, arg2: psi4.core.Matrix, arg3: psi::detci::CIvect) → None¶; docstring. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. diag_h(self: psi4.core.CIWavefunction, arg0: float, arg1: float) → int¶; docstring. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Beta Eigenvalues subset. esp_at_nuclei(self: psi4.core.Wavefunction) → psi4.core.Vector¶; returns electrostatic potentials at nuclei. force_doccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only. Sets the number of doubly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. force_soccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:13067,Energy Efficiency,energy,energy,13067,"efunction) → None¶; docstring. cleanup_ci(self: psi4.core.CIWavefunction) → None¶; docstring. cleanup_dpd(self: psi4.core.CIWavefunction) → None¶; docstring. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. compute_state_transfer(self: psi4.core.CIWavefunction, arg0: psi::detci::CIvect, arg1: int, arg2: psi4.core.Matrix, arg3: psi::detci::CIvect) → None¶; docstring. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. diag_h(self: psi4.core.CIWavefunction, arg0: float, arg1: float) → int¶; docstring. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Beta Eigenvalues subset. esp_at_nuclei(self: psi4.core.Wavefunction) → psi4.core.Vector¶; returns electrostatic potentials at nuclei. force_doccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only. Sets the number of doubly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. force_soccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only. Sets the number of singly occupied oribta",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:23023,Energy Efficiency,charge,charges,23023,"atrix. H(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the ‘Core’ Matrix (Potential + Kinetic) Integrals. S(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the One-electron Overlap Matrix. V_potential(self: psi4.core.HF) → psi4.core.VBase¶; Returns the internal DFT V object. Va(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Alpha Kohn-Shame Potential Matrix. Vb(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Alpha Kohn-Shame Potential Matrix. X(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Lagrangian Matrix. alpha_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. aotoso(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Atomic Orbital to Symmetry Orbital transformer. arrays(self: psi4.core.Wavefunction) → Dict[str, psi4.core.Matrix]¶; Returns the map of all internal arrays. atomic_point_charges(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.CUHF, basis: psi4.core.BasisSet) → psi4.core.CUHF¶; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefu",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:23768,Energy Efficiency,energy,energy,23768,"e Atomic Orbital to Symmetry Orbital transformer. arrays(self: psi4.core.Wavefunction) → Dict[str, psi4.core.Matrix]¶; Returns the map of all internal arrays. atomic_point_charges(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.CUHF, basis: psi4.core.BasisSet) → psi4.core.CUHF¶; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix]) → List[psi4.core.Matrix]¶; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF) → bool¶; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int=2) → List[psi4.core.Matrix]¶; Solves the CPHF equations for a given set of x vectors. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wav",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:24653,Energy Efficiency,energy,energy,24653,"ing pre-c1-constructed BasisSet basis. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix]) → List[psi4.core.Matrix]¶; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF) → bool¶; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int=2) → List[psi4.core.Matrix]¶; Solves the CPHF equations for a given set of x vectors. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Beta Eigenvalues subset. esp_at_nuclei(self: psi4.core.Wavefunction) → psi4.core.Vector¶; returns electrostatic potentials at nuclei. finalize_E(self: psi4.core.HF) → float¶; Computes the final SCF energy. force_doccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only. Sets the number of doubly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. force_soccpi(self: psi4.core.Wavef",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:24726,Energy Efficiency,energy,energy,24726,"ute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix]) → List[psi4.core.Matrix]¶; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF) → bool¶; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int=2) → List[psi4.core.Matrix]¶; Solves the CPHF equations for a given set of x vectors. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Beta Eigenvalues subset. esp_at_nuclei(self: psi4.core.Wavefunction) → psi4.core.Vector¶; returns electrostatic potentials at nuclei. finalize_E(self: psi4.core.HF) → float¶; Computes the final SCF energy. force_doccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only. Sets the number of doubly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. force_soccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:25365,Energy Efficiency,energy,energy,25365,"i4.core.Matrix]¶; Solves the CPHF equations for a given set of x vectors. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Beta Eigenvalues subset. esp_at_nuclei(self: psi4.core.Wavefunction) → psi4.core.Vector¶; returns electrostatic potentials at nuclei. finalize_E(self: psi4.core.HF) → float¶; Computes the final SCF energy. force_doccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only. Sets the number of doubly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. force_soccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only. Sets the number of singly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. form_C(self: psi4.core.HF) → None¶; Forms the Orbital Matrices from the current Fock Matrices. form_D(self: psi4.core.HF) → None¶; Forms the Density Matrices from the current Orbitals Matrices. form_F(self: psi4.core.HF) → None¶; Forms the F matrix. form_G(self: psi4.core.HF) → None¶; Forms the G matrix. form_V(self: psi4.core.HF) → None¶; Form the Kohn-Sham Potential Matrices from the current Density Matrices. frequencies(self: psi4.core.Wavefunction) → psi4.cor",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:32387,Energy Efficiency,adapt,adapted,32387,"f Atomic Densities basisset. set_sad_fitting_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities density-fitted basisset. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. twoel_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix], arg1: bool, arg2: str) → List[psi4.core.Matrix]¶; Two-electron Hessian-vector products. variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the map of all internal variables. class psi4.core.CdSalcList¶; Bases: pybind11_builtins.pybind11_object; Class for generating symmetry adapted linear combinations of Cartesian displacements. create_matrices(self: psi4.core.CdSalcList, basename: str, factory: psi4.core.MatrixFactory) → List[psi4.core.Matrix]¶; Return a vector of matrices with the SALC symmetries. Dimensions determined by factory. matrix(self: psi4.core.CdSalcList) → psi4.core.Matrix¶; Return the SALCs. matrix_irrep(self: psi4.core.CdSalcList, h: int) → psi4.core.Matrix¶; Return only the SALCS in irrep h. ncd(self: psi4.core.CdSalcList) → int¶; Return the number of cartesian displacements SALCs. print_out(self: psi4.core.CdSalcList) → None¶; Print the SALC to the output file. salc_name(self: psi4.core.CdSalcList, i: int) → str¶; Return the name of SALC #i. class psi4.core.CorrelationFactor¶; Bases: pybind11_builtins.pybind11_object; docstring. set_params(self: psi4.core.CorrelationFactor, coeff: psi4.core.Vector, exponent: psi4.core.Vector) → None¶; Set coefficient and exponent. class psi4.core.CorrelationTable¶; Bases: pybind11_builtins.pybind11_object; Pr",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:34045,Energy Efficiency,reduce,reduced,34045," to the output file. salc_name(self: psi4.core.CdSalcList, i: int) → str¶; Return the name of SALC #i. class psi4.core.CorrelationFactor¶; Bases: pybind11_builtins.pybind11_object; docstring. set_params(self: psi4.core.CorrelationFactor, coeff: psi4.core.Vector, exponent: psi4.core.Vector) → None¶; Set coefficient and exponent. class psi4.core.CorrelationTable¶; Bases: pybind11_builtins.pybind11_object; Provides a correlation table between two point groups. degen(self: psi4.core.CorrelationTable, arg0: int) → int¶; Returns the degenercy of the irrep. group(*args, **kwargs)¶; Overloaded function. group(self: psi4.core.CorrelationTable) -> psi4.core.PointGroup. Returns higher order point group. group(self: psi4.core.CorrelationTable, arg0: int, arg1: int) -> int. Returns the higher order point group. n(self: psi4.core.CorrelationTable) → int¶; Returns the number of irreps in high order group. ngamma(self: psi4.core.CorrelationTable, arg0: int) → int¶; Returns the number of irreps in the low order group that an irrep from the high order group can be reduced to. subdegen(self: psi4.core.CorrelationTable, arg0: int) → int¶; Returns the degeneracy of the subgroup irrep. subgroup(self: psi4.core.CorrelationTable) → psi4.core.PointGroup¶; Returns lower order pointgroup. subn(self: psi4.core.CorrelationTable) → int¶; Returns number of irreps in subgroup. class psi4.core.CubeProperties¶; Bases: pybind11_builtins.pybind11_object; docstring. compute_properties(self: psi4.core.CubeProperties) → None¶; docstring. psi4.core.DASUM(arg0: int, arg1: int, arg2: psi::Vector, arg3: int) → float¶; docstring. psi4.core.DAXPY(arg0: int, arg1: int, arg2: float, arg3: psi::Vector, arg4: int, arg5: psi::Vector, arg6: int) → None¶; docstring. psi4.core.DCOPY(arg0: int, arg1: int, arg2: psi::Vector, arg3: int, arg4: psi::Vector, arg5: int) → None¶; docstring. psi4.core.DDOT(arg0: int, arg1: int, arg2: psi::Vector, arg3: int, arg4: psi::Vector, arg5: int) → float¶; docstring. class psi4.core.DFEP",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:36824,Energy Efficiency,charge,charges,36824,"t(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Returns the requested Beta Density subset. Fa(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Alpha Fock Matrix. Fb(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Beta Fock Matrix. H(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the ‘Core’ Matrix (Potential + Kinetic) Integrals. S(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the One-electron Overlap Matrix. X(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Lagrangian Matrix. alpha_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. aotoso(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Atomic Orbital to Symmetry Orbital transformer. arrays(self: psi4.core.Wavefunction) → Dict[str, psi4.core.Matrix]¶; Returns the map of all internal arrays. atomic_point_charges(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.Wavefunction, basis: psi4.core.BasisSet) → psi4.core.Wavefunction¶; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet *basis. compute(self: psi4.core.DFEP2Wavefunction, arg0: List[List[int]]) → List[List[Tuple[float, float]]]¶; Computes the density-fitted EP2 energy for the input orbitals. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.co",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:37652,Energy Efficiency,energy,energy,37652,". arrays(self: psi4.core.Wavefunction) → Dict[str, psi4.core.Matrix]¶; Returns the map of all internal arrays. atomic_point_charges(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.Wavefunction, basis: psi4.core.BasisSet) → psi4.core.Wavefunction¶; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet *basis. compute(self: psi4.core.DFEP2Wavefunction, arg0: List[List[int]]) → List[List[Tuple[float, float]]]¶; Computes the density-fitted EP2 energy for the input orbitals. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the ",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:37751,Energy Efficiency,energy,energy,37751,"lf: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.Wavefunction, basis: psi4.core.BasisSet) → psi4.core.Wavefunction¶; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet *basis. compute(self: psi4.core.DFEP2Wavefunction, arg0: List[List[int]]) → List[List[Tuple[float, float]]]¶; Computes the density-fitted EP2 energy for the input orbitals. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Beta",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:38228,Energy Efficiency,energy,energy,38228,"→ psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.Wavefunction, basis: psi4.core.BasisSet) → psi4.core.Wavefunction¶; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet *basis. compute(self: psi4.core.DFEP2Wavefunction, arg0: List[List[int]]) → List[List[Tuple[float, float]]]¶; Computes the density-fitted EP2 energy for the input orbitals. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Beta Eigenvalues subset. esp_at_nuclei(self: psi4.core.Wavefunction) → psi4.core.Vector¶; returns electrostatic potentials at nuclei. force_doccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only. Sets the number of doubly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. force_soccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:38301,Energy Efficiency,energy,energy,38301,"c build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.Wavefunction, basis: psi4.core.BasisSet) → psi4.core.Wavefunction¶; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet *basis. compute(self: psi4.core.DFEP2Wavefunction, arg0: List[List[int]]) → List[List[Tuple[float, float]]]¶; Computes the density-fitted EP2 energy for the input orbitals. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Beta Eigenvalues subset. esp_at_nuclei(self: psi4.core.Wavefunction) → psi4.core.Vector¶; returns electrostatic potentials at nuclei. force_doccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only. Sets the number of doubly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. force_soccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only. Sets the number of singly occupied oribta",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:61566,Energy Efficiency,charge,charge,61566,"one¶; Compute integrals between basis functions in the given shell pair. origin¶; The origin about which the one body ints are being computed. class psi4.core.ErfComplementERI¶; Bases: psi4.core.TwoBodyAOInt; Computes ERF complement electron repulsion integrals. compute_shell(self: psi4.core.TwoBodyAOInt, arg0: int, arg1: int, arg2: int, arg3: int) → int¶; Compute ERIs between 4 shells. class psi4.core.ErfERI¶; Bases: psi4.core.TwoBodyAOInt; Computes ERF electron repulsion integrals. compute_shell(self: psi4.core.TwoBodyAOInt, arg0: int, arg1: int, arg2: int, arg3: int) → int¶; Compute ERIs between 4 shells. class psi4.core.ExternalPotential¶; Bases: pybind11_builtins.pybind11_object; Stores external potential field, computes external potential matrix. addBasis(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet, coefs: psi4.core.Vector) → None¶; Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self: psi4.core.ExternalPotential, Z: float, x: float, y: float, z: float) → None¶; Add a charge Z at (x,y,z). clear(self: psi4.core.ExternalPotential) → None¶; Reset the field to zero (eliminates all entries). computePotentialMatrix(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet) → psi4.core.Matrix¶; Compute the external potential matrix in the given basis set. print_out(self: psi4.core.ExternalPotential) → None¶; Print python print helper to the outfile. setName(self: psi4.core.ExternalPotential, arg0: str) → None¶; Sets the name. class psi4.core.F12¶; Bases: psi4.core.TwoBodyAOInt; Computes F12 electron repulsion integrals. compute_shell(self: psi4.core.TwoBodyAOInt, arg0: int, arg1: int, arg2: int, arg3: int) → int¶; Compute ERIs between 4 shells. class psi4.core.F12DoubleCommutator¶; Bases: psi4.core.TwoBodyAOInt; Computes F12 Double Commutator electron repulsion integrals. compute_shell(self: psi4.core.TwoBodyAOInt, arg0: int, arg1: int, arg2: int, arg3: int) → int¶; Compute ERIs between 4 shells. class psi4.core.F12G12¶; Bases",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:64070,Energy Efficiency,energy,energy,64070," information from a wavefunction object, and writes it to an FCHK file. write(self: psi4.core.FCHKWriter, filename: str) → None¶; Write wavefunction information to file. class psi4.core.FDDS_Dispersion¶; Bases: pybind11_builtins.pybind11_object; docstring. aux_overlap(self: psi4.core.FDDS_Dispersion) → psi4.core.Matrix¶; Obtains the FDDS aux_overlap. form_unc_amplitude(self: psi4.core.FDDS_Dispersion, arg0: str, arg1: float) → psi4.core.Matrix¶; Forms the uncoupled amplitudes for either monomer. metric(self: psi4.core.FDDS_Dispersion) → psi4.core.Matrix¶; Obtains the FDDS metric. metric_inv(self: psi4.core.FDDS_Dispersion) → psi4.core.Matrix¶; Obtains the FDDS metric_inv. project_densities(self: psi4.core.FDDS_Dispersion, arg0: List[psi4.core.Matrix]) → List[psi4.core.Matrix]¶; Projects a density from the primary AO to auxiliary AO space. class psi4.core.FISAPT¶; Bases: pybind11_builtins.pybind11_object; A Fragment-SAPT Wavefunction. compute_energy(self: psi4.core.FISAPT) → None¶; Computes the FSAPT energy. disp(self: psi4.core.FISAPT, arg0: Dict[str, psi4.core.Matrix], arg1: Dict[str, psi4.core.Vector], arg2: bool) → None¶; Computes the MP2-based DispE20 and Exch-DispE20 energy. scalars(self: psi4.core.FISAPT) → Dict[str, float]¶; Return the interally computed scalars. class psi4.core.FittedSlaterCorrelationFactor¶; Bases: psi4.core.CorrelationFactor; docstring. exponent(self: psi4.core.FittedSlaterCorrelationFactor) → float¶. set_params(self: psi4.core.CorrelationFactor, coeff: psi4.core.Vector, exponent: psi4.core.Vector) → None¶; Set coefficient and exponent. class psi4.core.FittingMetric¶; Bases: pybind11_builtins.pybind11_object; docstring. form_QR_inverse(self: psi4.core.FittingMetric, arg0: float) → None¶; docstring. form_cholesky_inverse(self: psi4.core.FittingMetric) → None¶; docstring. form_eig_inverse(self: psi4.core.FittingMetric, arg0: float) → None¶; docstring. form_fitting_metric(self: psi4.core.FittingMetric) → None¶; docstring. form_full_inverse(sel",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:64246,Energy Efficiency,energy,energy,64246,"ation to file. class psi4.core.FDDS_Dispersion¶; Bases: pybind11_builtins.pybind11_object; docstring. aux_overlap(self: psi4.core.FDDS_Dispersion) → psi4.core.Matrix¶; Obtains the FDDS aux_overlap. form_unc_amplitude(self: psi4.core.FDDS_Dispersion, arg0: str, arg1: float) → psi4.core.Matrix¶; Forms the uncoupled amplitudes for either monomer. metric(self: psi4.core.FDDS_Dispersion) → psi4.core.Matrix¶; Obtains the FDDS metric. metric_inv(self: psi4.core.FDDS_Dispersion) → psi4.core.Matrix¶; Obtains the FDDS metric_inv. project_densities(self: psi4.core.FDDS_Dispersion, arg0: List[psi4.core.Matrix]) → List[psi4.core.Matrix]¶; Projects a density from the primary AO to auxiliary AO space. class psi4.core.FISAPT¶; Bases: pybind11_builtins.pybind11_object; A Fragment-SAPT Wavefunction. compute_energy(self: psi4.core.FISAPT) → None¶; Computes the FSAPT energy. disp(self: psi4.core.FISAPT, arg0: Dict[str, psi4.core.Matrix], arg1: Dict[str, psi4.core.Vector], arg2: bool) → None¶; Computes the MP2-based DispE20 and Exch-DispE20 energy. scalars(self: psi4.core.FISAPT) → Dict[str, float]¶; Return the interally computed scalars. class psi4.core.FittedSlaterCorrelationFactor¶; Bases: psi4.core.CorrelationFactor; docstring. exponent(self: psi4.core.FittedSlaterCorrelationFactor) → float¶. set_params(self: psi4.core.CorrelationFactor, coeff: psi4.core.Vector, exponent: psi4.core.Vector) → None¶; Set coefficient and exponent. class psi4.core.FittingMetric¶; Bases: pybind11_builtins.pybind11_object; docstring. form_QR_inverse(self: psi4.core.FittingMetric, arg0: float) → None¶; docstring. form_cholesky_inverse(self: psi4.core.FittingMetric) → None¶; docstring. form_eig_inverse(self: psi4.core.FittingMetric, arg0: float) → None¶; docstring. form_fitting_metric(self: psi4.core.FittingMetric) → None¶; docstring. form_full_inverse(self: psi4.core.FittingMetric) → None¶; docstring. get_algorithm(self: psi4.core.FittingMetric) → str¶; docstring. get_metric(self: psi4.core.FittingMetric) →",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:71140,Energy Efficiency,charge,charges,71140,"atrix. H(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the ‘Core’ Matrix (Potential + Kinetic) Integrals. S(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the One-electron Overlap Matrix. V_potential(self: psi4.core.HF) → psi4.core.VBase¶; Returns the internal DFT V object. Va(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Alpha Kohn-Shame Potential Matrix. Vb(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Alpha Kohn-Shame Potential Matrix. X(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Lagrangian Matrix. alpha_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. aotoso(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Atomic Orbital to Symmetry Orbital transformer. arrays(self: psi4.core.Wavefunction) → Dict[str, psi4.core.Matrix]¶; Returns the map of all internal arrays. atomic_point_charges(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.Wavefunction, basis: psi4.core.BasisSet) → psi4.core.Wavefunction¶; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet *basis. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hess",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:71902,Energy Efficiency,energy,energy,71902,"to Symmetry Orbital transformer. arrays(self: psi4.core.Wavefunction) → Dict[str, psi4.core.Matrix]¶; Returns the map of all internal arrays. atomic_point_charges(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.Wavefunction, basis: psi4.core.BasisSet) → psi4.core.Wavefunction¶; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet *basis. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix]) → List[psi4.core.Matrix]¶; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF) → bool¶; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int=2) → List[psi4.core.Matrix]¶; Solves the CPHF equations for a given set of x vectors. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wav",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:72787,Energy Efficiency,energy,energy,72787,"ng pre-c1-constructed BasisSet *basis. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix]) → List[psi4.core.Matrix]¶; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF) → bool¶; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int=2) → List[psi4.core.Matrix]¶; Solves the CPHF equations for a given set of x vectors. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Beta Eigenvalues subset. esp_at_nuclei(self: psi4.core.Wavefunction) → psi4.core.Vector¶; returns electrostatic potentials at nuclei. finalize_E(self: psi4.core.HF) → float¶; Computes the final SCF energy. force_doccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only. Sets the number of doubly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. force_soccpi(self: psi4.core.Wavef",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:72860,Energy Efficiency,energy,energy,72860,"ute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix]) → List[psi4.core.Matrix]¶; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF) → bool¶; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int=2) → List[psi4.core.Matrix]¶; Solves the CPHF equations for a given set of x vectors. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Beta Eigenvalues subset. esp_at_nuclei(self: psi4.core.Wavefunction) → psi4.core.Vector¶; returns electrostatic potentials at nuclei. finalize_E(self: psi4.core.HF) → float¶; Computes the final SCF energy. force_doccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only. Sets the number of doubly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. force_soccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:73499,Energy Efficiency,energy,energy,73499,"i4.core.Matrix]¶; Solves the CPHF equations for a given set of x vectors. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Beta Eigenvalues subset. esp_at_nuclei(self: psi4.core.Wavefunction) → psi4.core.Vector¶; returns electrostatic potentials at nuclei. finalize_E(self: psi4.core.HF) → float¶; Computes the final SCF energy. force_doccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only. Sets the number of doubly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. force_soccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only. Sets the number of singly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. form_C(self: psi4.core.HF) → None¶; Forms the Orbital Matrices from the current Fock Matrices. form_D(self: psi4.core.HF) → None¶; Forms the Density Matrices from the current Orbitals Matrices. form_F(self: psi4.core.HF) → None¶; Forms the F matrix. form_G(self: psi4.core.HF) → None¶; Forms the G matrix. form_V(self: psi4.core.HF) → None¶; Form the Kohn-Sham Potential Matrices from the current Density Matrices. frequencies(self: psi4.core.Wavefunction) → psi4.cor",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:106435,Energy Efficiency,power,power,106435,".core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType=SaveType.LowerTriangle) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str) → None¶; Loads a matrix from an ASCII file in MPQC format. name¶; The name of the Matrix. Used in printing. nirrep(self: psi4.core.Matrix) → int¶; Returns the number of irreps. np¶; View without only one irrep. classmethod np_read(filename, prefix='')¶; Reads the data from a NumPy compress file. np_write(filename=None, prefix='')¶; Writes the irreped matrix to a NumPy zipped file.; Can return the packed data for saving many matrices into the same file. nph¶; View with irreps. partial_cholesky_factorize(self: psi4.core.Matrix, delta: float=0.0, throw_if_negative: bool=False) → psi4.core.Matrix¶; Computes the fully pivoted partial Cholesky factorization of a real symmetric positive semidefinite matrix, to numerical precision delta. power(self: psi4.core.Matrix, alpha: float, cutoff: float=1e-12) → psi4.core.Dimension¶; Takes the matrix to the alpha power with precision cutoff. print_atom_vector(self: psi4.core.Matrix, RMRoutfile: str='outfile') → None¶; Print the matrix with atom labels, assuming it is an natom X 3 tensor. print_out(self: psi4.core.Matrix) → None¶; Prints the matrix to the output file. pseudoinverse(self: psi4.core.Matrix, condition: float, nremoved: int) → psi4.core.Matrix¶; Computes the matrix which is the conditioned pseudoinverse of this matrix. remove_symmetry(self: psi4.core.Matrix, a: psi4.core.Matrix, transformer: psi4.core.Matrix) → None¶; Remove symmetry from a matrix A with PetiteList::sotoao(). rms(self: psi4.core.Matrix) → float¶; Returns the rms of this matrix. rotate_columns(self: psi4.core.Matrix, h: int, i: int, j: int, theta: float) → None¶; Rotates columns i and j in irrep h by angle theta. rowdim(self: psi4.core.Matrix) → psi4.core.Dimension¶; Returns the rows per irrep array. rows(se",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:106554,Energy Efficiency,power,power,106554,"one. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str) → None¶; Loads a matrix from an ASCII file in MPQC format. name¶; The name of the Matrix. Used in printing. nirrep(self: psi4.core.Matrix) → int¶; Returns the number of irreps. np¶; View without only one irrep. classmethod np_read(filename, prefix='')¶; Reads the data from a NumPy compress file. np_write(filename=None, prefix='')¶; Writes the irreped matrix to a NumPy zipped file.; Can return the packed data for saving many matrices into the same file. nph¶; View with irreps. partial_cholesky_factorize(self: psi4.core.Matrix, delta: float=0.0, throw_if_negative: bool=False) → psi4.core.Matrix¶; Computes the fully pivoted partial Cholesky factorization of a real symmetric positive semidefinite matrix, to numerical precision delta. power(self: psi4.core.Matrix, alpha: float, cutoff: float=1e-12) → psi4.core.Dimension¶; Takes the matrix to the alpha power with precision cutoff. print_atom_vector(self: psi4.core.Matrix, RMRoutfile: str='outfile') → None¶; Print the matrix with atom labels, assuming it is an natom X 3 tensor. print_out(self: psi4.core.Matrix) → None¶; Prints the matrix to the output file. pseudoinverse(self: psi4.core.Matrix, condition: float, nremoved: int) → psi4.core.Matrix¶; Computes the matrix which is the conditioned pseudoinverse of this matrix. remove_symmetry(self: psi4.core.Matrix, a: psi4.core.Matrix, transformer: psi4.core.Matrix) → None¶; Remove symmetry from a matrix A with PetiteList::sotoao(). rms(self: psi4.core.Matrix) → float¶; Returns the rms of this matrix. rotate_columns(self: psi4.core.Matrix, h: int, i: int, j: int, theta: float) → None¶; Rotates columns i and j in irrep h by angle theta. rowdim(self: psi4.core.Matrix) → psi4.core.Dimension¶; Returns the rows per irrep array. rows(self: psi4.core.Matrix, h: int=0) → int¶; Returns the rows in irrep h. save(self: psi4.core.Matrix, filena",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:123862,Energy Efficiency,charge,charge,123862,"ilename: str, Ca: psi4.core.Matrix, Cb: psi4.core.Matrix, Ea: psi4.core.Vector, Eb: psi4.core.Vector, OccA: psi4.core.Vector, OccB: psi4.core.Vector, dovirtual: bool) → None¶; Writes wavefunction information in molden format. class psi4.core.MolecularGrid¶; Bases: pybind11_builtins.pybind11_object; docstring. blocks(self: psi4.core.MolecularGrid) → List[psi4.core.BlockOPoints]¶; Returns a list of blocks. max_functions(self: psi4.core.MolecularGrid) → int¶; Returns the maximum number of functions in a block. max_points(self: psi4.core.MolecularGrid) → int¶; Returns the maximum number of points in a block. npoints(self: psi4.core.MolecularGrid) → int¶; Returns the number of grid points. orientation(self: psi4.core.MolecularGrid) → psi4.core.Matrix¶; Returns the orientation of the grid. print(self: psi4.core.MolecularGrid, arg0: str, arg1: int) → None¶; Prints grid information. class psi4.core.Molecule¶; Bases: pybind11_builtins.pybind11_object; Class to store the elements, coordinates, fragmentation pattern, basis sets, charge, multiplicity, etc. of a molecule. B787(ref_mol, do_plot=False, verbose=1, atoms_map=False, run_resorting=False, mols_align=False, run_to_completion=False, uno_cutoff=0.001, run_mirror=False)¶; Finds shift, rotation, and atom reordering of concern_mol that best; aligns with ref_mol.; Wraps qcdb.align.B787() for qcdb.Molecule or; psi4.core.Molecule. Employs the Kabsch, Hungarian, and; Uno algorithms to exhaustively locate the best alignment for; non-oriented, non-ordered structures. Parameters:; concern_mol (qcdb.Molecule or psi4.core.Molecule) – Molecule of concern, to be shifted, rotated, and reordered into; best coincidence with ref_mol.; ref_mol (qcdb.Molecule or psi4.core.Molecule) – Molecule to match.; atoms_map (bool, optional) – Whether atom1 of ref_mol corresponds to atom1 of concern_mol, etc.; If true, specifying True can save much time.; mols_align (bool, optional) – Whether ref_mol and concern_mol have identical geometries by eye; (ba",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:125866,Energy Efficiency,charge,charge,125866,"procedure is truncated when RMSD condition met, saving time.; do_plot (bool, optional) – Pops up a mpl plot showing before, after, and ref geometries.; run_to_completion (bool, optional) – Run reorderings to completion (past RMSD = 0) even if unnecessary because; mols_align=True. Used to test worst-case timings.; run_resorting (bool, optional) – Run the resorting machinery even if unnecessary because atoms_map=True.; uno_cutoff (float, optional) – TODO; run_mirror (bool, optional) – Run alternate geometries potentially allowing best match to ref_mol; from mirror image of concern_mol. Only run if system confirmed to; be nonsuperimposable upon mirror reflection. Returns:First item is RMSD [A] between ref_mol and the optimally aligned; geometry computed.; Second item is a AlignmentMill namedtuple with fields; (shift, rotation, atommap, mirror) that prescribe the transformation; from concern_mol and the optimally aligned geometry.; Third item is a crude charge-, multiplicity-, fragment-less Molecule; at optimally aligned (and atom-ordered) geometry. Return type; determined by concern_mol type. Return type:float, tuple, qcdb.Molecule or psi4.core.Molecule. BFS(seed_atoms=None, bond_threshold=1.2, return_arrays=False, return_molecules=False, return_molecule=False)¶; Detect fragments among real atoms through a breadth-first search (BFS) algorithm. Parameters:; self (qcdb.Molecule or psi4.core.Molecule) – ; seed_atoms (list, optional) – List of lists of atoms (0-indexed) belonging to independent fragments.; Useful to prompt algorithm or to define intramolecular fragments through; border atoms. Example: [[1, 0], [2]]; bond_threshold (float, optional) – Factor beyond average of covalent radii to determine bond cutoff.; return_arrays (bool, optional) – If True, also return fragments as list of arrays.; return_molecules (bool, optional) – If True, also return fragments as list of Molecules.; return_molecule (bool, optional) – If True, also return one big Molecule with fragmentat",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:127749,Energy Efficiency,charge,charge,127749,"les (bool, optional) – If True, also return fragments as list of Molecules.; return_molecule (bool, optional) – If True, also return one big Molecule with fragmentation encoded. Returns:; bfs_map (list of lists) – Array of atom indices (0-indexed) of detected fragments.; bfs_arrays (tuple of lists of ndarray, optional) – geom, mass, elem info per-fragment.; Only provided if return_arrays is True.; bfs_molecules (list of qcdb.Molecule or psi4.core.Molecule, optional) – List of molecules, each built from one fragment. Center and; orientation of fragments is fixed so orientation info from self is; not lost. Loses chgmult and ghost/dummy info from self and contains; default chgmult.; Only provided if return_molecules is True.; Returned are of same type as self.; bfs_molecule (qcdb.Molecule or psi4.core.Molecule, optional) – Single molecule with same number of real atoms as self with atoms; reordered into adjacent fragments and fragment markers inserted.; Loses ghost/dummy info from self; keeps total charge but not total mult.; Only provided if return_molecule is True.; Returned is of same type as self. Notes. Relies upon van der Waals radii and so faulty for close (especially; hydrogen-bonded) fragments. See seed_atoms. Any existing fragmentation info/chgmult encoded in self is lost.; Original code from Michael S. Marshall, linear-scaling algorithm from; Trent M. Parker, revamped by Lori A. Burns. Z(self: psi4.core.Molecule, arg0: int) → float¶; Nuclear charge of atom. activate_all_fragments(self: psi4.core.Molecule) → None¶; Sets all fragments in the molecule to be active. add_atom(self: psi4.core.Molecule, arg0: float, arg1: float, arg2: float, arg3: float, arg4: str, arg5: float, arg6: float, arg7: str, arg8: int) → None¶; Adds to Molecule arg1 an atom with atomic number arg2, Cartesian coordinates in Bohr (arg3, arg4, arg5), atomic symbol arg6, mass arg7, charge arg8 (optional), and lineno arg9 (optional). atom_at_position(self: psi4.core.Molecule, arg0: float, arg1",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:128212,Energy Efficiency,charge,charge,128212,"ptional) – List of molecules, each built from one fragment. Center and; orientation of fragments is fixed so orientation info from self is; not lost. Loses chgmult and ghost/dummy info from self and contains; default chgmult.; Only provided if return_molecules is True.; Returned are of same type as self.; bfs_molecule (qcdb.Molecule or psi4.core.Molecule, optional) – Single molecule with same number of real atoms as self with atoms; reordered into adjacent fragments and fragment markers inserted.; Loses ghost/dummy info from self; keeps total charge but not total mult.; Only provided if return_molecule is True.; Returned is of same type as self. Notes. Relies upon van der Waals radii and so faulty for close (especially; hydrogen-bonded) fragments. See seed_atoms. Any existing fragmentation info/chgmult encoded in self is lost.; Original code from Michael S. Marshall, linear-scaling algorithm from; Trent M. Parker, revamped by Lori A. Burns. Z(self: psi4.core.Molecule, arg0: int) → float¶; Nuclear charge of atom. activate_all_fragments(self: psi4.core.Molecule) → None¶; Sets all fragments in the molecule to be active. add_atom(self: psi4.core.Molecule, arg0: float, arg1: float, arg2: float, arg3: float, arg4: str, arg5: float, arg6: float, arg7: str, arg8: int) → None¶; Adds to Molecule arg1 an atom with atomic number arg2, Cartesian coordinates in Bohr (arg3, arg4, arg5), atomic symbol arg6, mass arg7, charge arg8 (optional), and lineno arg9 (optional). atom_at_position(self: psi4.core.Molecule, arg0: float, arg1: float) → int¶; Tests to see if an atom is at the position arg2 with a given tolerance arg3. basis_on_atom(self: psi4.core.Molecule, arg0: int) → str¶; Gets the label of the orbital basis set on a given atom. center_of_mass(self: psi4.core.Molecule) → psi4.core.Vector3¶; Computes center of mass of molecule (does not translate molecule). charge(self: psi4.core.Molecule, arg0: int) → float¶; Gets charge of atom. clone(self: psi4.core.Molecule) → psi4.core.Mol",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:128626,Energy Efficiency,charge,charge,128626,"e (qcdb.Molecule or psi4.core.Molecule, optional) – Single molecule with same number of real atoms as self with atoms; reordered into adjacent fragments and fragment markers inserted.; Loses ghost/dummy info from self; keeps total charge but not total mult.; Only provided if return_molecule is True.; Returned is of same type as self. Notes. Relies upon van der Waals radii and so faulty for close (especially; hydrogen-bonded) fragments. See seed_atoms. Any existing fragmentation info/chgmult encoded in self is lost.; Original code from Michael S. Marshall, linear-scaling algorithm from; Trent M. Parker, revamped by Lori A. Burns. Z(self: psi4.core.Molecule, arg0: int) → float¶; Nuclear charge of atom. activate_all_fragments(self: psi4.core.Molecule) → None¶; Sets all fragments in the molecule to be active. add_atom(self: psi4.core.Molecule, arg0: float, arg1: float, arg2: float, arg3: float, arg4: str, arg5: float, arg6: float, arg7: str, arg8: int) → None¶; Adds to Molecule arg1 an atom with atomic number arg2, Cartesian coordinates in Bohr (arg3, arg4, arg5), atomic symbol arg6, mass arg7, charge arg8 (optional), and lineno arg9 (optional). atom_at_position(self: psi4.core.Molecule, arg0: float, arg1: float) → int¶; Tests to see if an atom is at the position arg2 with a given tolerance arg3. basis_on_atom(self: psi4.core.Molecule, arg0: int) → str¶; Gets the label of the orbital basis set on a given atom. center_of_mass(self: psi4.core.Molecule) → psi4.core.Vector3¶; Computes center of mass of molecule (does not translate molecule). charge(self: psi4.core.Molecule, arg0: int) → float¶; Gets charge of atom. clone(self: psi4.core.Molecule) → psi4.core.Molecule¶; Returns a new Molecule identical to arg1. com_fixed(self: psi4.core.Molecule) → bool¶; Get whether or not COM is fixed. create_molecule_from_string(arg0: str) → psi4.core.Molecule¶; Returns a new Molecule with member data from the geometry string arg1 in psi4 format. create_psi4_string_from_molecule(self: psi4",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:129078,Energy Efficiency,charge,charge,129078,"-scaling algorithm from; Trent M. Parker, revamped by Lori A. Burns. Z(self: psi4.core.Molecule, arg0: int) → float¶; Nuclear charge of atom. activate_all_fragments(self: psi4.core.Molecule) → None¶; Sets all fragments in the molecule to be active. add_atom(self: psi4.core.Molecule, arg0: float, arg1: float, arg2: float, arg3: float, arg4: str, arg5: float, arg6: float, arg7: str, arg8: int) → None¶; Adds to Molecule arg1 an atom with atomic number arg2, Cartesian coordinates in Bohr (arg3, arg4, arg5), atomic symbol arg6, mass arg7, charge arg8 (optional), and lineno arg9 (optional). atom_at_position(self: psi4.core.Molecule, arg0: float, arg1: float) → int¶; Tests to see if an atom is at the position arg2 with a given tolerance arg3. basis_on_atom(self: psi4.core.Molecule, arg0: int) → str¶; Gets the label of the orbital basis set on a given atom. center_of_mass(self: psi4.core.Molecule) → psi4.core.Vector3¶; Computes center of mass of molecule (does not translate molecule). charge(self: psi4.core.Molecule, arg0: int) → float¶; Gets charge of atom. clone(self: psi4.core.Molecule) → psi4.core.Molecule¶; Returns a new Molecule identical to arg1. com_fixed(self: psi4.core.Molecule) → bool¶; Get whether or not COM is fixed. create_molecule_from_string(arg0: str) → psi4.core.Molecule¶; Returns a new Molecule with member data from the geometry string arg1 in psi4 format. create_psi4_string_from_molecule(self: psi4.core.Molecule) → str¶; Gets a string reexpressing in input format the current states of the molecule. deactivate_all_fragments(self: psi4.core.Molecule) → None¶; Sets all fragments in the molecule to be inactive. distance_matrix(self: psi4.core.Molecule) → psi4.core.Matrix¶; Returns Matrix of interatom distances. extract_subsets(*args, **kwargs)¶; Overloaded function. extract_subsets(self: psi4.core.Molecule, arg0: List[int], arg1: List[int]) -> psi4.core.Molecule. Returns copy of arg1 with arg2 fragments Real and arg3 fragments Ghost. extract_subsets(self: psi",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:129137,Energy Efficiency,charge,charge,129137,", revamped by Lori A. Burns. Z(self: psi4.core.Molecule, arg0: int) → float¶; Nuclear charge of atom. activate_all_fragments(self: psi4.core.Molecule) → None¶; Sets all fragments in the molecule to be active. add_atom(self: psi4.core.Molecule, arg0: float, arg1: float, arg2: float, arg3: float, arg4: str, arg5: float, arg6: float, arg7: str, arg8: int) → None¶; Adds to Molecule arg1 an atom with atomic number arg2, Cartesian coordinates in Bohr (arg3, arg4, arg5), atomic symbol arg6, mass arg7, charge arg8 (optional), and lineno arg9 (optional). atom_at_position(self: psi4.core.Molecule, arg0: float, arg1: float) → int¶; Tests to see if an atom is at the position arg2 with a given tolerance arg3. basis_on_atom(self: psi4.core.Molecule, arg0: int) → str¶; Gets the label of the orbital basis set on a given atom. center_of_mass(self: psi4.core.Molecule) → psi4.core.Vector3¶; Computes center of mass of molecule (does not translate molecule). charge(self: psi4.core.Molecule, arg0: int) → float¶; Gets charge of atom. clone(self: psi4.core.Molecule) → psi4.core.Molecule¶; Returns a new Molecule identical to arg1. com_fixed(self: psi4.core.Molecule) → bool¶; Get whether or not COM is fixed. create_molecule_from_string(arg0: str) → psi4.core.Molecule¶; Returns a new Molecule with member data from the geometry string arg1 in psi4 format. create_psi4_string_from_molecule(self: psi4.core.Molecule) → str¶; Gets a string reexpressing in input format the current states of the molecule. deactivate_all_fragments(self: psi4.core.Molecule) → None¶; Sets all fragments in the molecule to be inactive. distance_matrix(self: psi4.core.Molecule) → psi4.core.Matrix¶; Returns Matrix of interatom distances. extract_subsets(*args, **kwargs)¶; Overloaded function. extract_subsets(self: psi4.core.Molecule, arg0: List[int], arg1: List[int]) -> psi4.core.Molecule. Returns copy of arg1 with arg2 fragments Real and arg3 fragments Ghost. extract_subsets(self: psi4.core.Molecule, arg0: List[int], arg1: ",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:130856,Energy Efficiency,charge,charge,130856,"wargs)¶; Overloaded function. extract_subsets(self: psi4.core.Molecule, arg0: List[int], arg1: List[int]) -> psi4.core.Molecule. Returns copy of arg1 with arg2 fragments Real and arg3 fragments Ghost. extract_subsets(self: psi4.core.Molecule, arg0: List[int], arg1: int) -> psi4.core.Molecule. Returns copy of arg1 with arg2 fragments Real and arg3 fragment Ghost. extract_subsets(self: psi4.core.Molecule, arg0: int, arg1: List[int]) -> psi4.core.Molecule. Returns copy of arg1 with arg2 fragment Real and arg3 fragments Ghost. extract_subsets(self: psi4.core.Molecule, arg0: int, arg1: int) -> psi4.core.Molecule. Returns copy of arg1 with arg2 fragment Real and arg3 fragment Ghost. extract_subsets(self: psi4.core.Molecule, arg0: List[int]) -> psi4.core.Molecule. Returns copy of arg1 with arg2 fragments Real. extract_subsets(self: psi4.core.Molecule, arg0: int) -> psi4.core.Molecule. Returns copy of arg1 with arg2 fragment Real. fZ(self: psi4.core.Molecule, arg0: int) → float¶; Nuclear charge of atom arg1 (0-indexed including dummies). find_point_group(self: psi4.core.Molecule, arg0: float) → psi4.core.PointGroup¶; Finds computational molecular point group, user can override this with the symmetry keyword. fix_com(self: psi4.core.Molecule, arg0: bool) → None¶; Whether to fix the Cartesian position, or to translate to the C.O.M. fix_orientation(self: psi4.core.Molecule, arg0: bool) → None¶; Fix the orientation at its current frame. form_symmetry_information(self: psi4.core.Molecule, arg0: float) → None¶; Uses the point group object obtain by calling point_group(). classmethod from_arrays(geom=None, elea=None, elez=None, elem=None, mass=None, real=None, elbl=None, name=None, units='Angstrom', input_units_to_au=None, fix_com=None, fix_orientation=None, fix_symmetry=None, fragment_separators=None, fragment_charges=None, fragment_multiplicities=None, molecular_charge=None, molecular_multiplicity=None, missing_enabled_return='error', tooclose=0.1, zero_ghost_fragments=False, non",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:133674,Energy Efficiency,charge,charge,133674,"return Molecule dictionary intermediate.; verbose (int, optional) – Amount of printing. Returns:; mol (psi4.core.Molecule); molrec (dict, optional) – Dictionary representation of instance.; Only provided if return_dict is True. classmethod from_string(molstr, dtype=None, name=None, fix_com=None, fix_orientation=None, fix_symmetry=None, return_dict=False, enable_qm=True, enable_efp=True, missing_enabled_return_qm='none', missing_enabled_return_efp='none', verbose=1)¶. fx(self: psi4.core.Molecule, arg0: int) → float¶; x position of atom arg1 (0-indexed including dummies in Bohr). fy(self: psi4.core.Molecule, arg0: int) → float¶; y position of atom arg1 (0-indexed including dummies in Bohr). fz(self: psi4.core.Molecule, arg0: int) → float¶; z position of atom arg1 (0-indexed including dummies in Bohr). geometry(self: psi4.core.Molecule) → psi4.core.Matrix¶; Gets the geometry as a (Natom X 3) matrix of coordinates (in Bohr). get_fragment_charges(self: psi4.core.Molecule) → List[int]¶; Gets the charge of each fragment. get_fragment_multiplicities(self: psi4.core.Molecule) → List[int]¶; Gets the multiplicity of each fragment. get_fragment_types(self: psi4.core.Molecule) → List[str]¶; Returns a list describing how to handle each fragment {Real, Ghost, Absent}. get_fragments(self: psi4.core.Molecule) → List[Tuple[int, int]]¶; Returns list of pairs of atom ranges defining each fragment from parent molecule(fragments[frag_ind] = <Afirst,Alast+1>). get_full_point_group(self: psi4.core.Molecule) → str¶; Gets point group name such as C3v or S8. get_variable(self: psi4.core.Molecule, arg0: str) → float¶; Checks if variable arg2 is in the list, sets it to val and returns true if it is, and returns false if not. inertia_tensor(self: psi4.core.Molecule) → psi4.core.Matrix¶; Returns intertial tensor. input_units_to_au(self: psi4.core.Molecule) → float¶; Returns unit conversion to [a0] for geometry. irrep_labels(self: psi4.core.Molecule) → List[str]¶; Returns Irreducible Representation",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:135215,Energy Efficiency,charge,charge,135215,"up name such as C3v or S8. get_variable(self: psi4.core.Molecule, arg0: str) → float¶; Checks if variable arg2 is in the list, sets it to val and returns true if it is, and returns false if not. inertia_tensor(self: psi4.core.Molecule) → psi4.core.Matrix¶; Returns intertial tensor. input_units_to_au(self: psi4.core.Molecule) → float¶; Returns unit conversion to [a0] for geometry. irrep_labels(self: psi4.core.Molecule) → List[str]¶; Returns Irreducible Representation symmetry labels. is_variable(self: psi4.core.Molecule, arg0: str) → bool¶; Checks if variable arg2 is in the list, returns true if it is, and returns false if not. label(self: psi4.core.Molecule, arg0: int) → str¶; Gets the original label of the atom as given in the input file (C2, H4). mass(self: psi4.core.Molecule, atom: int) → float¶; Returns mass of atom (0-indexed). mass_number(self: psi4.core.Molecule, arg0: int) → int¶; Mass number (A) of atom if known, else -1. molecular_charge(self: psi4.core.Molecule) → int¶; Gets the molecular charge. move_to_com(self: psi4.core.Molecule) → None¶; Moves molecule to center of mass. multiplicity(self: psi4.core.Molecule) → int¶; Gets the multiplicity (defined as 2Ms + 1). nallatom(self: psi4.core.Molecule) → int¶; Number of real and dummy atoms. name(self: psi4.core.Molecule) → str¶; Gets molecule name. natom(self: psi4.core.Molecule) → int¶; Number of real atoms. nfragments(self: psi4.core.Molecule) → int¶; Gets the number of fragments in the molecule. nuclear_dipole(*args, **kwargs)¶; Overloaded function. nuclear_dipole(self: psi4.core.Molecule, arg0: psi4.core.Vector3) -> psi4.core.Vector3. Gets the nuclear contribution to the dipole, withe respect to a specified origin. nuclear_dipole(self: psi4.core.Molecule) -> psi4.core.Vector3. Gets the nuclear contribution to the dipole, withe respect to the origin. nuclear_repulsion_energy(self: psi4.core.Molecule, dipole_field: List[float[3]]=[0.0, 0.0, 0.0]) → float¶; Computes nuclear repulsion energy. nuclear_repuls",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:136178,Energy Efficiency,energy,energy,136178,"(self: psi4.core.Molecule) → int¶; Gets the molecular charge. move_to_com(self: psi4.core.Molecule) → None¶; Moves molecule to center of mass. multiplicity(self: psi4.core.Molecule) → int¶; Gets the multiplicity (defined as 2Ms + 1). nallatom(self: psi4.core.Molecule) → int¶; Number of real and dummy atoms. name(self: psi4.core.Molecule) → str¶; Gets molecule name. natom(self: psi4.core.Molecule) → int¶; Number of real atoms. nfragments(self: psi4.core.Molecule) → int¶; Gets the number of fragments in the molecule. nuclear_dipole(*args, **kwargs)¶; Overloaded function. nuclear_dipole(self: psi4.core.Molecule, arg0: psi4.core.Vector3) -> psi4.core.Vector3. Gets the nuclear contribution to the dipole, withe respect to a specified origin. nuclear_dipole(self: psi4.core.Molecule) -> psi4.core.Vector3. Gets the nuclear contribution to the dipole, withe respect to the origin. nuclear_repulsion_energy(self: psi4.core.Molecule, dipole_field: List[float[3]]=[0.0, 0.0, 0.0]) → float¶; Computes nuclear repulsion energy. nuclear_repulsion_energy_deriv1(self: psi4.core.Molecule, arg0: List[float[3]]) → psi4.core.Matrix¶; Returns first derivative of nuclear repulsion energy as a matrix (natom, 3). nuclear_repulsion_energy_deriv2(self: psi4.core.Molecule) → psi4.core.Matrix¶; Returns second derivative of nuclear repulsion energy as a matrix (natom X 3, natom X 3). orientation_fixed(self: psi4.core.Molecule) → bool¶; Get whether or not orientation is fixed. point_group(self: psi4.core.Molecule) → psi4.core.PointGroup¶; Returns the current point group object. print_bond_angles(self: psi4.core.Molecule) → None¶; Print the bond angle geometrical parameters. print_cluster(self: psi4.core.Molecule) → None¶; Prints the molecule in Cartesians in input units adding fragment separators. print_distances(self: psi4.core.Molecule) → None¶; Print the interatomic distance geometrical parameters. print_in_input_format(self: psi4.core.Molecule) → None¶; Prints the molecule as Cartesian or ZMatrix ",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:136333,Energy Efficiency,energy,energy,136333,"f: psi4.core.Molecule) → int¶; Gets the multiplicity (defined as 2Ms + 1). nallatom(self: psi4.core.Molecule) → int¶; Number of real and dummy atoms. name(self: psi4.core.Molecule) → str¶; Gets molecule name. natom(self: psi4.core.Molecule) → int¶; Number of real atoms. nfragments(self: psi4.core.Molecule) → int¶; Gets the number of fragments in the molecule. nuclear_dipole(*args, **kwargs)¶; Overloaded function. nuclear_dipole(self: psi4.core.Molecule, arg0: psi4.core.Vector3) -> psi4.core.Vector3. Gets the nuclear contribution to the dipole, withe respect to a specified origin. nuclear_dipole(self: psi4.core.Molecule) -> psi4.core.Vector3. Gets the nuclear contribution to the dipole, withe respect to the origin. nuclear_repulsion_energy(self: psi4.core.Molecule, dipole_field: List[float[3]]=[0.0, 0.0, 0.0]) → float¶; Computes nuclear repulsion energy. nuclear_repulsion_energy_deriv1(self: psi4.core.Molecule, arg0: List[float[3]]) → psi4.core.Matrix¶; Returns first derivative of nuclear repulsion energy as a matrix (natom, 3). nuclear_repulsion_energy_deriv2(self: psi4.core.Molecule) → psi4.core.Matrix¶; Returns second derivative of nuclear repulsion energy as a matrix (natom X 3, natom X 3). orientation_fixed(self: psi4.core.Molecule) → bool¶; Get whether or not orientation is fixed. point_group(self: psi4.core.Molecule) → psi4.core.PointGroup¶; Returns the current point group object. print_bond_angles(self: psi4.core.Molecule) → None¶; Print the bond angle geometrical parameters. print_cluster(self: psi4.core.Molecule) → None¶; Prints the molecule in Cartesians in input units adding fragment separators. print_distances(self: psi4.core.Molecule) → None¶; Print the interatomic distance geometrical parameters. print_in_input_format(self: psi4.core.Molecule) → None¶; Prints the molecule as Cartesian or ZMatrix entries, just as inputted. print_out(self: psi4.core.Molecule) → None¶; Prints the molecule in Cartesians in input units to output file. print_out_in_angstrom(s",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:136490,Energy Efficiency,energy,energy,136490,"i4.core.Molecule) → str¶; Gets molecule name. natom(self: psi4.core.Molecule) → int¶; Number of real atoms. nfragments(self: psi4.core.Molecule) → int¶; Gets the number of fragments in the molecule. nuclear_dipole(*args, **kwargs)¶; Overloaded function. nuclear_dipole(self: psi4.core.Molecule, arg0: psi4.core.Vector3) -> psi4.core.Vector3. Gets the nuclear contribution to the dipole, withe respect to a specified origin. nuclear_dipole(self: psi4.core.Molecule) -> psi4.core.Vector3. Gets the nuclear contribution to the dipole, withe respect to the origin. nuclear_repulsion_energy(self: psi4.core.Molecule, dipole_field: List[float[3]]=[0.0, 0.0, 0.0]) → float¶; Computes nuclear repulsion energy. nuclear_repulsion_energy_deriv1(self: psi4.core.Molecule, arg0: List[float[3]]) → psi4.core.Matrix¶; Returns first derivative of nuclear repulsion energy as a matrix (natom, 3). nuclear_repulsion_energy_deriv2(self: psi4.core.Molecule) → psi4.core.Matrix¶; Returns second derivative of nuclear repulsion energy as a matrix (natom X 3, natom X 3). orientation_fixed(self: psi4.core.Molecule) → bool¶; Get whether or not orientation is fixed. point_group(self: psi4.core.Molecule) → psi4.core.PointGroup¶; Returns the current point group object. print_bond_angles(self: psi4.core.Molecule) → None¶; Print the bond angle geometrical parameters. print_cluster(self: psi4.core.Molecule) → None¶; Prints the molecule in Cartesians in input units adding fragment separators. print_distances(self: psi4.core.Molecule) → None¶; Print the interatomic distance geometrical parameters. print_in_input_format(self: psi4.core.Molecule) → None¶; Prints the molecule as Cartesian or ZMatrix entries, just as inputted. print_out(self: psi4.core.Molecule) → None¶; Prints the molecule in Cartesians in input units to output file. print_out_in_angstrom(self: psi4.core.Molecule) → None¶; Prints the molecule in Cartesians in Angstroms to output file. print_out_in_bohr(self: psi4.core.Molecule) → None¶; Prints the m",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:139773,Energy Efficiency,energy,energy,139773,"psi4.core.Molecule or str) – Molecule on which to run dispersion calculation. Both qcdb and; psi4.core Molecule classes have been extended by this method, so; either allowed. Alternately, a string that can be instantiated; into a qcdb.Molecule.; func (str or None) – Density functional (Psi4, not Turbomole, names) for which to; load parameters from dashcoeff[dashlvl][func]. This is not; passed to DFTD3 and thus may be a dummy or None. Any or all; parameters initialized can be overwritten via dashparam.; dashlvl ({'d2p4', 'd2gr', 'd3zero', 'd3bj', 'd3mzero', d3mbj', 'd', 'd2', 'd3', 'd3m'}) – Flavor of a posteriori dispersion correction for which to load; parameters and call procedure in DFTD3. Must be a keys in; dashcoeff dict (or a key in dashalias that resolves to one).; dashparam (dict, optional) – Dictionary of the same keys as dashcoeff[dashlvl] used to; override any or all values initialized by; dashcoeff[dashlvl][func].; dertype ({None, 0, 'none', 'energy', 1, 'first', 'gradient'}, optional) – Maximum derivative level at which to run DFTD3. For large; mol, energy-only calculations can be significantly more; efficient. Also controls return values, see below.; verbose (bool, optional) – When True, additionally include DFTD3 output in output. Returns:; energy (float, optional) – When dertype is 0, energy [Eh].; gradient (list of lists of floats or psi4.core.Matrix, optional) – When dertype is 1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (float and list of lists of floats or psi4.core.Matrix, optional) – When dertype is unspecified, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; research site: https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/dft-d3; Psi4 mode: When psi4 the python module is importable at import qcdb. time, Psi4 mode is activated, with the following alterations:; * output goes to output file; * gradient returned as psi4.core.Matrix, not list o’lists; * scratch is written to randomly named subdirectory of psi scratch; * psiva",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:139883,Energy Efficiency,energy,energy-only,139883,"e Molecule classes have been extended by this method, so; either allowed. Alternately, a string that can be instantiated; into a qcdb.Molecule.; func (str or None) – Density functional (Psi4, not Turbomole, names) for which to; load parameters from dashcoeff[dashlvl][func]. This is not; passed to DFTD3 and thus may be a dummy or None. Any or all; parameters initialized can be overwritten via dashparam.; dashlvl ({'d2p4', 'd2gr', 'd3zero', 'd3bj', 'd3mzero', d3mbj', 'd', 'd2', 'd3', 'd3m'}) – Flavor of a posteriori dispersion correction for which to load; parameters and call procedure in DFTD3. Must be a keys in; dashcoeff dict (or a key in dashalias that resolves to one).; dashparam (dict, optional) – Dictionary of the same keys as dashcoeff[dashlvl] used to; override any or all values initialized by; dashcoeff[dashlvl][func].; dertype ({None, 0, 'none', 'energy', 1, 'first', 'gradient'}, optional) – Maximum derivative level at which to run DFTD3. For large; mol, energy-only calculations can be significantly more; efficient. Also controls return values, see below.; verbose (bool, optional) – When True, additionally include DFTD3 output in output. Returns:; energy (float, optional) – When dertype is 0, energy [Eh].; gradient (list of lists of floats or psi4.core.Matrix, optional) – When dertype is 1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (float and list of lists of floats or psi4.core.Matrix, optional) – When dertype is unspecified, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; research site: https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/dft-d3; Psi4 mode: When psi4 the python module is importable at import qcdb. time, Psi4 mode is activated, with the following alterations:; * output goes to output file; * gradient returned as psi4.core.Matrix, not list o’lists; * scratch is written to randomly named subdirectory of psi scratch; * psivar “DISPERSION CORRECTION ENERGY” is set; * verbose triggered when PRINT keywork of SCF module >=3. ru",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:139935,Energy Efficiency,efficient,efficient,139935,"e Molecule classes have been extended by this method, so; either allowed. Alternately, a string that can be instantiated; into a qcdb.Molecule.; func (str or None) – Density functional (Psi4, not Turbomole, names) for which to; load parameters from dashcoeff[dashlvl][func]. This is not; passed to DFTD3 and thus may be a dummy or None. Any or all; parameters initialized can be overwritten via dashparam.; dashlvl ({'d2p4', 'd2gr', 'd3zero', 'd3bj', 'd3mzero', d3mbj', 'd', 'd2', 'd3', 'd3m'}) – Flavor of a posteriori dispersion correction for which to load; parameters and call procedure in DFTD3. Must be a keys in; dashcoeff dict (or a key in dashalias that resolves to one).; dashparam (dict, optional) – Dictionary of the same keys as dashcoeff[dashlvl] used to; override any or all values initialized by; dashcoeff[dashlvl][func].; dertype ({None, 0, 'none', 'energy', 1, 'first', 'gradient'}, optional) – Maximum derivative level at which to run DFTD3. For large; mol, energy-only calculations can be significantly more; efficient. Also controls return values, see below.; verbose (bool, optional) – When True, additionally include DFTD3 output in output. Returns:; energy (float, optional) – When dertype is 0, energy [Eh].; gradient (list of lists of floats or psi4.core.Matrix, optional) – When dertype is 1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (float and list of lists of floats or psi4.core.Matrix, optional) – When dertype is unspecified, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; research site: https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/dft-d3; Psi4 mode: When psi4 the python module is importable at import qcdb. time, Psi4 mode is activated, with the following alterations:; * output goes to output file; * gradient returned as psi4.core.Matrix, not list o’lists; * scratch is written to randomly named subdirectory of psi scratch; * psivar “DISPERSION CORRECTION ENERGY” is set; * verbose triggered when PRINT keywork of SCF module >=3. ru",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:140080,Energy Efficiency,energy,energy,140080,"rbomole, names) for which to; load parameters from dashcoeff[dashlvl][func]. This is not; passed to DFTD3 and thus may be a dummy or None. Any or all; parameters initialized can be overwritten via dashparam.; dashlvl ({'d2p4', 'd2gr', 'd3zero', 'd3bj', 'd3mzero', d3mbj', 'd', 'd2', 'd3', 'd3m'}) – Flavor of a posteriori dispersion correction for which to load; parameters and call procedure in DFTD3. Must be a keys in; dashcoeff dict (or a key in dashalias that resolves to one).; dashparam (dict, optional) – Dictionary of the same keys as dashcoeff[dashlvl] used to; override any or all values initialized by; dashcoeff[dashlvl][func].; dertype ({None, 0, 'none', 'energy', 1, 'first', 'gradient'}, optional) – Maximum derivative level at which to run DFTD3. For large; mol, energy-only calculations can be significantly more; efficient. Also controls return values, see below.; verbose (bool, optional) – When True, additionally include DFTD3 output in output. Returns:; energy (float, optional) – When dertype is 0, energy [Eh].; gradient (list of lists of floats or psi4.core.Matrix, optional) – When dertype is 1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (float and list of lists of floats or psi4.core.Matrix, optional) – When dertype is unspecified, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; research site: https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/dft-d3; Psi4 mode: When psi4 the python module is importable at import qcdb. time, Psi4 mode is activated, with the following alterations:; * output goes to output file; * gradient returned as psi4.core.Matrix, not list o’lists; * scratch is written to randomly named subdirectory of psi scratch; * psivar “DISPERSION CORRECTION ENERGY” is set; * verbose triggered when PRINT keywork of SCF module >=3. run_gcp(func=None, dertype=None, verbose=False)¶; Function to call Grimme’s dftd3 program (http://toc.uni-muenster.de/DFTD3/); to compute the -D correction of level dashlvl using parameters for; the f",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:140126,Energy Efficiency,energy,energy,140126,"rbomole, names) for which to; load parameters from dashcoeff[dashlvl][func]. This is not; passed to DFTD3 and thus may be a dummy or None. Any or all; parameters initialized can be overwritten via dashparam.; dashlvl ({'d2p4', 'd2gr', 'd3zero', 'd3bj', 'd3mzero', d3mbj', 'd', 'd2', 'd3', 'd3m'}) – Flavor of a posteriori dispersion correction for which to load; parameters and call procedure in DFTD3. Must be a keys in; dashcoeff dict (or a key in dashalias that resolves to one).; dashparam (dict, optional) – Dictionary of the same keys as dashcoeff[dashlvl] used to; override any or all values initialized by; dashcoeff[dashlvl][func].; dertype ({None, 0, 'none', 'energy', 1, 'first', 'gradient'}, optional) – Maximum derivative level at which to run DFTD3. For large; mol, energy-only calculations can be significantly more; efficient. Also controls return values, see below.; verbose (bool, optional) – When True, additionally include DFTD3 output in output. Returns:; energy (float, optional) – When dertype is 0, energy [Eh].; gradient (list of lists of floats or psi4.core.Matrix, optional) – When dertype is 1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (float and list of lists of floats or psi4.core.Matrix, optional) – When dertype is unspecified, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; research site: https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/dft-d3; Psi4 mode: When psi4 the python module is importable at import qcdb. time, Psi4 mode is activated, with the following alterations:; * output goes to output file; * gradient returned as psi4.core.Matrix, not list o’lists; * scratch is written to randomly named subdirectory of psi scratch; * psivar “DISPERSION CORRECTION ENERGY” is set; * verbose triggered when PRINT keywork of SCF module >=3. run_gcp(func=None, dertype=None, verbose=False)¶; Function to call Grimme’s dftd3 program (http://toc.uni-muenster.de/DFTD3/); to compute the -D correction of level dashlvl using parameters for; the f",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:140255,Energy Efficiency,energy,energy,140255,"overwritten via dashparam.; dashlvl ({'d2p4', 'd2gr', 'd3zero', 'd3bj', 'd3mzero', d3mbj', 'd', 'd2', 'd3', 'd3m'}) – Flavor of a posteriori dispersion correction for which to load; parameters and call procedure in DFTD3. Must be a keys in; dashcoeff dict (or a key in dashalias that resolves to one).; dashparam (dict, optional) – Dictionary of the same keys as dashcoeff[dashlvl] used to; override any or all values initialized by; dashcoeff[dashlvl][func].; dertype ({None, 0, 'none', 'energy', 1, 'first', 'gradient'}, optional) – Maximum derivative level at which to run DFTD3. For large; mol, energy-only calculations can be significantly more; efficient. Also controls return values, see below.; verbose (bool, optional) – When True, additionally include DFTD3 output in output. Returns:; energy (float, optional) – When dertype is 0, energy [Eh].; gradient (list of lists of floats or psi4.core.Matrix, optional) – When dertype is 1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (float and list of lists of floats or psi4.core.Matrix, optional) – When dertype is unspecified, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; research site: https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/dft-d3; Psi4 mode: When psi4 the python module is importable at import qcdb. time, Psi4 mode is activated, with the following alterations:; * output goes to output file; * gradient returned as psi4.core.Matrix, not list o’lists; * scratch is written to randomly named subdirectory of psi scratch; * psivar “DISPERSION CORRECTION ENERGY” is set; * verbose triggered when PRINT keywork of SCF module >=3. run_gcp(func=None, dertype=None, verbose=False)¶; Function to call Grimme’s dftd3 program (http://toc.uni-muenster.de/DFTD3/); to compute the -D correction of level dashlvl using parameters for; the functional func. The dictionary dashparam can be used to supply; a full set of dispersion parameters in the absense of func or to supply; individual overrides in the presence of fun",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:140375,Energy Efficiency,energy,energy,140375,"mbj', 'd', 'd2', 'd3', 'd3m'}) – Flavor of a posteriori dispersion correction for which to load; parameters and call procedure in DFTD3. Must be a keys in; dashcoeff dict (or a key in dashalias that resolves to one).; dashparam (dict, optional) – Dictionary of the same keys as dashcoeff[dashlvl] used to; override any or all values initialized by; dashcoeff[dashlvl][func].; dertype ({None, 0, 'none', 'energy', 1, 'first', 'gradient'}, optional) – Maximum derivative level at which to run DFTD3. For large; mol, energy-only calculations can be significantly more; efficient. Also controls return values, see below.; verbose (bool, optional) – When True, additionally include DFTD3 output in output. Returns:; energy (float, optional) – When dertype is 0, energy [Eh].; gradient (list of lists of floats or psi4.core.Matrix, optional) – When dertype is 1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (float and list of lists of floats or psi4.core.Matrix, optional) – When dertype is unspecified, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; research site: https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/dft-d3; Psi4 mode: When psi4 the python module is importable at import qcdb. time, Psi4 mode is activated, with the following alterations:; * output goes to output file; * gradient returned as psi4.core.Matrix, not list o’lists; * scratch is written to randomly named subdirectory of psi scratch; * psivar “DISPERSION CORRECTION ENERGY” is set; * verbose triggered when PRINT keywork of SCF module >=3. run_gcp(func=None, dertype=None, verbose=False)¶; Function to call Grimme’s dftd3 program (http://toc.uni-muenster.de/DFTD3/); to compute the -D correction of level dashlvl using parameters for; the functional func. The dictionary dashparam can be used to supply; a full set of dispersion parameters in the absense of func or to supply; individual overrides in the presence of func. Returns energy if dertype is 0,; gradient if dertype is 1, else tuple of energy an",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:141295,Energy Efficiency,energy,energy,141295," dertype is unspecified, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; research site: https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/dft-d3; Psi4 mode: When psi4 the python module is importable at import qcdb. time, Psi4 mode is activated, with the following alterations:; * output goes to output file; * gradient returned as psi4.core.Matrix, not list o’lists; * scratch is written to randomly named subdirectory of psi scratch; * psivar “DISPERSION CORRECTION ENERGY” is set; * verbose triggered when PRINT keywork of SCF module >=3. run_gcp(func=None, dertype=None, verbose=False)¶; Function to call Grimme’s dftd3 program (http://toc.uni-muenster.de/DFTD3/); to compute the -D correction of level dashlvl using parameters for; the functional func. The dictionary dashparam can be used to supply; a full set of dispersion parameters in the absense of func or to supply; individual overrides in the presence of func. Returns energy if dertype is 0,; gradient if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The dftd3 executable must be independently compiled and found in; PATH or PSIPATH.; self may be either a qcdb.Molecule (sensibly) or a psi4.Molecule; (works b/c psi4.Molecule has been extended by this method py-side and; only public interface fns used) or a string that can be instantiated; into a qcdb.Molecule. save_string_xyz(self: psi4.core.Molecule) → str¶; Saves the string of an XYZ file to arg2. save_string_xyz_file(self: psi4.core.Molecule) → str¶; Saves an XYZ file to arg2. save_xyz_file(self: psi4.core.Molecule, arg0: str, arg1: bool) → None¶; Saves an XYZ file to arg2. schoenflies_symbol(self: psi4.core.Molecule) → str¶; Returns the Schoenflies symbol. scramble(do_shift=True, do_rotate=True, do_resort=True, deflection=1.0, do_mirror=False, do_plot=False, run_to_completion=False, run_resorting=False, verbose=1)¶; Tester for B787 by shifting, rotating, and atom shuffling ref_mol and; checking that the aligner returns th",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:141360,Energy Efficiency,energy,energy,141360," dertype is unspecified, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; research site: https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/dft-d3; Psi4 mode: When psi4 the python module is importable at import qcdb. time, Psi4 mode is activated, with the following alterations:; * output goes to output file; * gradient returned as psi4.core.Matrix, not list o’lists; * scratch is written to randomly named subdirectory of psi scratch; * psivar “DISPERSION CORRECTION ENERGY” is set; * verbose triggered when PRINT keywork of SCF module >=3. run_gcp(func=None, dertype=None, verbose=False)¶; Function to call Grimme’s dftd3 program (http://toc.uni-muenster.de/DFTD3/); to compute the -D correction of level dashlvl using parameters for; the functional func. The dictionary dashparam can be used to supply; a full set of dispersion parameters in the absense of func or to supply; individual overrides in the presence of func. Returns energy if dertype is 0,; gradient if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The dftd3 executable must be independently compiled and found in; PATH or PSIPATH.; self may be either a qcdb.Molecule (sensibly) or a psi4.Molecule; (works b/c psi4.Molecule has been extended by this method py-side and; only public interface fns used) or a string that can be instantiated; into a qcdb.Molecule. save_string_xyz(self: psi4.core.Molecule) → str¶; Saves the string of an XYZ file to arg2. save_string_xyz_file(self: psi4.core.Molecule) → str¶; Saves an XYZ file to arg2. save_xyz_file(self: psi4.core.Molecule, arg0: str, arg1: bool) → None¶; Saves an XYZ file to arg2. schoenflies_symbol(self: psi4.core.Molecule) → str¶; Returns the Schoenflies symbol. scramble(do_shift=True, do_rotate=True, do_resort=True, deflection=1.0, do_mirror=False, do_plot=False, run_to_completion=False, run_resorting=False, verbose=1)¶; Tester for B787 by shifting, rotating, and atom shuffling ref_mol and; checking that the aligner returns th",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:145079,Energy Efficiency,charge,charge,145079,"s basis set arg2 to all atoms. set_basis_by_label(self: psi4.core.Molecule, arg0: str, arg1: str, arg2: str) → None¶; Sets basis set arg3 to all atoms with label (e.g., H4) arg2. set_basis_by_symbol(self: psi4.core.Molecule, arg0: str, arg1: str, arg2: str) → None¶; Sets basis set arg3 to all atoms with symbol (e.g., H) arg2. set_geometry(self: psi4.core.Molecule, arg0: psi4.core.Matrix) → None¶; Sets the geometry, given a (Natom X 3) matrix arg2 of coordinates (in Bohr). set_ghost_fragment(self: psi4.core.Molecule, arg0: int) → None¶; Sets the specified fragment arg2 to be Ghost. set_ghost_fragments(self: psi4.core.Molecule, arg0: List[int]) → None¶; Sets the specified list arg2 of fragments to be Ghost. set_input_units_to_au(self: psi4.core.Molecule, arg0: float) → None¶; Sets unit conversion to [a0] for geometry. set_mass(self: psi4.core.Molecule, atom: int, mass: float) → None¶; Sets mass of atom (0-indexed) to mass. set_molecular_charge(self: psi4.core.Molecule, arg0: int) → None¶; Sets the molecular charge. set_multiplicity(self: psi4.core.Molecule, arg0: int) → None¶; Sets the multiplicity (defined as 2Ms + 1). set_name(self: psi4.core.Molecule, arg0: str) → None¶; Sets molecule name. set_nuclear_charge(self: psi4.core.Molecule, arg0: int, arg1: float) → None¶; Set the nuclear charge of the given atom to the value provided. set_point_group(self: psi4.core.Molecule, arg0: psi4.core.PointGroup) → None¶; Sets the molecular point group to the point group object arg2. set_units(self: psi4.core.Molecule, arg0: psi4.core.GeometryUnits) → None¶; Sets units (Angstrom or Bohr) used to define the geometry. set_variable(self: psi4.core.Molecule, arg0: str, arg1: float) → None¶; Assigns the value arg3 to the variable arg2 in the list of geometry variables, then calls update_geometry(). symbol(self: psi4.core.Molecule, arg0: int) → str¶; Gets the cleaned up label of atom arg2 (C2 => C, H4 = H). symmetrize(self: psi4.core.Molecule, arg0: float) → None¶; Finds the highest po",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:145363,Energy Efficiency,charge,charge,145363," with symbol (e.g., H) arg2. set_geometry(self: psi4.core.Molecule, arg0: psi4.core.Matrix) → None¶; Sets the geometry, given a (Natom X 3) matrix arg2 of coordinates (in Bohr). set_ghost_fragment(self: psi4.core.Molecule, arg0: int) → None¶; Sets the specified fragment arg2 to be Ghost. set_ghost_fragments(self: psi4.core.Molecule, arg0: List[int]) → None¶; Sets the specified list arg2 of fragments to be Ghost. set_input_units_to_au(self: psi4.core.Molecule, arg0: float) → None¶; Sets unit conversion to [a0] for geometry. set_mass(self: psi4.core.Molecule, atom: int, mass: float) → None¶; Sets mass of atom (0-indexed) to mass. set_molecular_charge(self: psi4.core.Molecule, arg0: int) → None¶; Sets the molecular charge. set_multiplicity(self: psi4.core.Molecule, arg0: int) → None¶; Sets the multiplicity (defined as 2Ms + 1). set_name(self: psi4.core.Molecule, arg0: str) → None¶; Sets molecule name. set_nuclear_charge(self: psi4.core.Molecule, arg0: int, arg1: float) → None¶; Set the nuclear charge of the given atom to the value provided. set_point_group(self: psi4.core.Molecule, arg0: psi4.core.PointGroup) → None¶; Sets the molecular point group to the point group object arg2. set_units(self: psi4.core.Molecule, arg0: psi4.core.GeometryUnits) → None¶; Sets units (Angstrom or Bohr) used to define the geometry. set_variable(self: psi4.core.Molecule, arg0: str, arg1: float) → None¶; Assigns the value arg3 to the variable arg2 in the list of geometry variables, then calls update_geometry(). symbol(self: psi4.core.Molecule, arg0: int) → str¶; Gets the cleaned up label of atom arg2 (C2 => C, H4 = H). symmetrize(self: psi4.core.Molecule, arg0: float) → None¶; Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. symmetry_from_input(self: psi4.core.Molecule) → str¶; Returns the symmetry specified in the input. to_arrays()¶; Exports coordinate info into NumPy arrays. Returns:; geom, mass, elem, elez, uniq (",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:161268,Energy Efficiency,charge,charges,161268,"atrix. H(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the ‘Core’ Matrix (Potential + Kinetic) Integrals. S(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the One-electron Overlap Matrix. V_potential(self: psi4.core.HF) → psi4.core.VBase¶; Returns the internal DFT V object. Va(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Alpha Kohn-Shame Potential Matrix. Vb(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Alpha Kohn-Shame Potential Matrix. X(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Lagrangian Matrix. alpha_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. aotoso(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Atomic Orbital to Symmetry Orbital transformer. arrays(self: psi4.core.Wavefunction) → Dict[str, psi4.core.Matrix]¶; Returns the map of all internal arrays. atomic_point_charges(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.RHF, basis: psi4.core.BasisSet) → psi4.core.RHF¶; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunc",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:162011,Energy Efficiency,energy,energy,162011,"the Atomic Orbital to Symmetry Orbital transformer. arrays(self: psi4.core.Wavefunction) → Dict[str, psi4.core.Matrix]¶; Returns the map of all internal arrays. atomic_point_charges(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.RHF, basis: psi4.core.BasisSet) → psi4.core.RHF¶; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix]) → List[psi4.core.Matrix]¶; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF) → bool¶; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int=2) → List[psi4.core.Matrix]¶; Solves the CPHF equations for a given set of x vectors. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wav",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:162896,Energy Efficiency,energy,energy,162896,"ing pre-c1-constructed BasisSet basis. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix]) → List[psi4.core.Matrix]¶; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF) → bool¶; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int=2) → List[psi4.core.Matrix]¶; Solves the CPHF equations for a given set of x vectors. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Beta Eigenvalues subset. esp_at_nuclei(self: psi4.core.Wavefunction) → psi4.core.Vector¶; returns electrostatic potentials at nuclei. finalize_E(self: psi4.core.HF) → float¶; Computes the final SCF energy. force_doccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only. Sets the number of doubly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. force_soccpi(self: psi4.core.Wavef",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:162969,Energy Efficiency,energy,energy,162969,"ute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix]) → List[psi4.core.Matrix]¶; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF) → bool¶; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int=2) → List[psi4.core.Matrix]¶; Solves the CPHF equations for a given set of x vectors. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Beta Eigenvalues subset. esp_at_nuclei(self: psi4.core.Wavefunction) → psi4.core.Vector¶; returns electrostatic potentials at nuclei. finalize_E(self: psi4.core.HF) → float¶; Computes the final SCF energy. force_doccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only. Sets the number of doubly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. force_soccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:163608,Energy Efficiency,energy,energy,163608,"i4.core.Matrix]¶; Solves the CPHF equations for a given set of x vectors. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Beta Eigenvalues subset. esp_at_nuclei(self: psi4.core.Wavefunction) → psi4.core.Vector¶; returns electrostatic potentials at nuclei. finalize_E(self: psi4.core.HF) → float¶; Computes the final SCF energy. force_doccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only. Sets the number of doubly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. force_soccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only. Sets the number of singly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. form_C(self: psi4.core.HF) → None¶; Forms the Orbital Matrices from the current Fock Matrices. form_D(self: psi4.core.HF) → None¶; Forms the Density Matrices from the current Orbitals Matrices. form_F(self: psi4.core.HF) → None¶; Forms the F matrix. form_G(self: psi4.core.HF) → None¶; Forms the G matrix. form_V(self: psi4.core.HF) → None¶; Form the Kohn-Sham Potential Matrices from the current Density Matrices. frequencies(self: psi4.core.Wavefunction) → psi4.cor",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:173857,Energy Efficiency,charge,charges,173857,"atrix. H(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the ‘Core’ Matrix (Potential + Kinetic) Integrals. S(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the One-electron Overlap Matrix. V_potential(self: psi4.core.HF) → psi4.core.VBase¶; Returns the internal DFT V object. Va(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Alpha Kohn-Shame Potential Matrix. Vb(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Alpha Kohn-Shame Potential Matrix. X(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Lagrangian Matrix. alpha_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. aotoso(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Atomic Orbital to Symmetry Orbital transformer. arrays(self: psi4.core.Wavefunction) → Dict[str, psi4.core.Matrix]¶; Returns the map of all internal arrays. atomic_point_charges(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.ROHF, basis: psi4.core.BasisSet) → psi4.core.ROHF¶; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefu",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:174602,Energy Efficiency,energy,energy,174602,"e Atomic Orbital to Symmetry Orbital transformer. arrays(self: psi4.core.Wavefunction) → Dict[str, psi4.core.Matrix]¶; Returns the map of all internal arrays. atomic_point_charges(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.ROHF, basis: psi4.core.BasisSet) → psi4.core.ROHF¶; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix]) → List[psi4.core.Matrix]¶; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF) → bool¶; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int=2) → List[psi4.core.Matrix]¶; Solves the CPHF equations for a given set of x vectors. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wav",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:175487,Energy Efficiency,energy,energy,175487,"ing pre-c1-constructed BasisSet basis. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix]) → List[psi4.core.Matrix]¶; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF) → bool¶; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int=2) → List[psi4.core.Matrix]¶; Solves the CPHF equations for a given set of x vectors. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Beta Eigenvalues subset. esp_at_nuclei(self: psi4.core.Wavefunction) → psi4.core.Vector¶; returns electrostatic potentials at nuclei. finalize_E(self: psi4.core.HF) → float¶; Computes the final SCF energy. force_doccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only. Sets the number of doubly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. force_soccpi(self: psi4.core.Wavef",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:175560,Energy Efficiency,energy,energy,175560,"ute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix]) → List[psi4.core.Matrix]¶; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF) → bool¶; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int=2) → List[psi4.core.Matrix]¶; Solves the CPHF equations for a given set of x vectors. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Beta Eigenvalues subset. esp_at_nuclei(self: psi4.core.Wavefunction) → psi4.core.Vector¶; returns electrostatic potentials at nuclei. finalize_E(self: psi4.core.HF) → float¶; Computes the final SCF energy. force_doccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only. Sets the number of doubly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. force_soccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:176199,Energy Efficiency,energy,energy,176199,"i4.core.Matrix]¶; Solves the CPHF equations for a given set of x vectors. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Beta Eigenvalues subset. esp_at_nuclei(self: psi4.core.Wavefunction) → psi4.core.Vector¶; returns electrostatic potentials at nuclei. finalize_E(self: psi4.core.HF) → float¶; Computes the final SCF energy. force_doccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only. Sets the number of doubly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. force_soccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only. Sets the number of singly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. form_C(self: psi4.core.HF) → None¶; Forms the Orbital Matrices from the current Fock Matrices. form_D(self: psi4.core.HF) → None¶; Forms the Density Matrices from the current Orbitals Matrices. form_F(self: psi4.core.HF) → None¶; Forms the F matrix. form_G(self: psi4.core.HF) → None¶; Forms the G matrix. form_V(self: psi4.core.HF) → None¶; Form the Kohn-Sham Potential Matrices from the current Density Matrices. frequencies(self: psi4.core.Wavefunction) → psi4.cor",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:186769,Energy Efficiency,allocate,allocate,186769,"trix) → None¶. class psi4.core.SaveType¶; Bases: pybind11_builtins.pybind11_object; The layout of the matrix for saving. Full = SaveType.Full¶. LowerTriangle = SaveType.LowerTriangle¶. SubBlocks = SaveType.SubBlocks¶. class psi4.core.ShellInfo¶; Bases: pybind11_builtins.pybind11_object. class psi4.core.Slice¶; Bases: pybind11_builtins.pybind11_object; Slicing for Matrix and Vector objects. begin(self: psi4.core.Slice) → psi4.core.Dimension¶; Get the first element of this slice. end(self: psi4.core.Slice) → psi4.core.Dimension¶; Get the past-the-end element of this slice. class psi4.core.SuperFunctional¶; Bases: pybind11_builtins.pybind11_object; docstring. XC_build(arg0: str, arg1: bool) → psi4.core.SuperFunctional¶; Builds a SuperFunctional from a XC string. add_c_functional(self: psi4.core.SuperFunctional, arg0: psi::Functional) → None¶; Add a correlation Functional. add_x_functional(self: psi4.core.SuperFunctional, arg0: psi::Functional) → None¶; Add a exchange Functional. allocate(self: psi4.core.SuperFunctional) → None¶; Allocates the vectors, should be called after ansatz or npoint changes. ansatz(self: psi4.core.SuperFunctional) → int¶; SuperFunctional rung. blank() → psi4.core.SuperFunctional¶; Initialize a blank SuperFunctional. c_alpha(self: psi4.core.SuperFunctional) → float¶; Amount of MP2 correlation. c_functional(self: psi4.core.SuperFunctional, arg0: str) → psi::Functional¶; Returns the desired C Functional. c_functionals(self: psi4.core.SuperFunctional) → List[psi::Functional]¶; Returns all C Functionals. c_omega(self: psi4.core.SuperFunctional) → float¶; Range-seperated correlation parameter. c_os_alpha(self: psi4.core.SuperFunctional) → float¶; Amount of SS MP2 correlation. c_ss_alpha(self: psi4.core.SuperFunctional) → float¶; Amount of OS MP2 correlation. citation(self: psi4.core.SuperFunctional) → str¶; SuperFunctional citation. compute_functional(self: psi4.core.SuperFunctional, arg0: Dict[str, psi4.core.Vector], arg1: int) → Dict[str, psi4.core.",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:197342,Energy Efficiency,charge,charges,197342,"atrix. H(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the ‘Core’ Matrix (Potential + Kinetic) Integrals. S(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the One-electron Overlap Matrix. V_potential(self: psi4.core.HF) → psi4.core.VBase¶; Returns the internal DFT V object. Va(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Alpha Kohn-Shame Potential Matrix. Vb(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Alpha Kohn-Shame Potential Matrix. X(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Lagrangian Matrix. alpha_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. aotoso(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Atomic Orbital to Symmetry Orbital transformer. arrays(self: psi4.core.Wavefunction) → Dict[str, psi4.core.Matrix]¶; Returns the map of all internal arrays. atomic_point_charges(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.UHF, basis: psi4.core.BasisSet) → psi4.core.UHF¶; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunc",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:198085,Energy Efficiency,energy,energy,198085,"the Atomic Orbital to Symmetry Orbital transformer. arrays(self: psi4.core.Wavefunction) → Dict[str, psi4.core.Matrix]¶; Returns the map of all internal arrays. atomic_point_charges(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.UHF, basis: psi4.core.BasisSet) → psi4.core.UHF¶; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix]) → List[psi4.core.Matrix]¶; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF) → bool¶; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int=2) → List[psi4.core.Matrix]¶; Solves the CPHF equations for a given set of x vectors. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wav",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:198970,Energy Efficiency,energy,energy,198970,"ing pre-c1-constructed BasisSet basis. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix]) → List[psi4.core.Matrix]¶; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF) → bool¶; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int=2) → List[psi4.core.Matrix]¶; Solves the CPHF equations for a given set of x vectors. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Beta Eigenvalues subset. esp_at_nuclei(self: psi4.core.Wavefunction) → psi4.core.Vector¶; returns electrostatic potentials at nuclei. finalize_E(self: psi4.core.HF) → float¶; Computes the final SCF energy. force_doccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only. Sets the number of doubly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. force_soccpi(self: psi4.core.Wavef",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:199043,Energy Efficiency,energy,energy,199043,"ute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix]) → List[psi4.core.Matrix]¶; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF) → bool¶; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int=2) → List[psi4.core.Matrix]¶; Solves the CPHF equations for a given set of x vectors. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Beta Eigenvalues subset. esp_at_nuclei(self: psi4.core.Wavefunction) → psi4.core.Vector¶; returns electrostatic potentials at nuclei. finalize_E(self: psi4.core.HF) → float¶; Computes the final SCF energy. force_doccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only. Sets the number of doubly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. force_soccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:199682,Energy Efficiency,energy,energy,199682,"i4.core.Matrix]¶; Solves the CPHF equations for a given set of x vectors. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Beta Eigenvalues subset. esp_at_nuclei(self: psi4.core.Wavefunction) → psi4.core.Vector¶; returns electrostatic potentials at nuclei. finalize_E(self: psi4.core.HF) → float¶; Computes the final SCF energy. force_doccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only. Sets the number of doubly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. force_soccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only. Sets the number of singly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. form_C(self: psi4.core.HF) → None¶; Forms the Orbital Matrices from the current Fock Matrices. form_D(self: psi4.core.HF) → None¶; Forms the Density Matrices from the current Orbitals Matrices. form_F(self: psi4.core.HF) → None¶; Forms the F matrix. form_G(self: psi4.core.HF) → None¶; Forms the G matrix. form_V(self: psi4.core.HF) → None¶; Form the Kohn-Sham Potential Matrices from the current Density Matrices. frequencies(self: psi4.core.Wavefunction) → psi4.cor",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:216997,Energy Efficiency,charge,charges,216997,"t(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Returns the requested Beta Density subset. Fa(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Alpha Fock Matrix. Fb(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Beta Fock Matrix. H(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the ‘Core’ Matrix (Potential + Kinetic) Integrals. S(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the One-electron Overlap Matrix. X(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Lagrangian Matrix. alpha_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. aotoso(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Atomic Orbital to Symmetry Orbital transformer. arrays(self: psi4.core.Wavefunction) → Dict[str, psi4.core.Matrix]¶; Returns the map of all internal arrays. atomic_point_charges(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.Wavefunction, basis: psi4.core.BasisSet) → psi4.core.Wavefunction¶; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet *basis. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hess",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:217759,Energy Efficiency,energy,energy,217759,"to Symmetry Orbital transformer. arrays(self: psi4.core.Wavefunction) → Dict[str, psi4.core.Matrix]¶; Returns the map of all internal arrays. atomic_point_charges(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.Wavefunction, basis: psi4.core.BasisSet) → psi4.core.Wavefunction¶; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet *basis. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Beta",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:218236,Energy Efficiency,energy,energy,218236," psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.Wavefunction, basis: psi4.core.BasisSet) → psi4.core.Wavefunction¶; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet *basis. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Beta Eigenvalues subset. esp_at_nuclei(self: psi4.core.Wavefunction) → psi4.core.Vector¶; returns electrostatic potentials at nuclei. force_doccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only. Sets the number of doubly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. force_soccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:218309,Energy Efficiency,energy,energy,218309,"et¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.Wavefunction, basis: psi4.core.BasisSet) → psi4.core.Wavefunction¶; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet *basis. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Beta Eigenvalues subset. esp_at_nuclei(self: psi4.core.Wavefunction) → psi4.core.Vector¶; returns electrostatic potentials at nuclei. force_doccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only. Sets the number of doubly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. force_soccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only. Sets the number of singly occupied oribta",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:224810,Energy Efficiency,energy,energy,224810,"bles. psi4.core.adc(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the ADC propagator code, for excited states. psi4.core.atomic_displacements(arg0: psi::Molecule) → List[psi::Matrix]¶; Returns list of displacements generated by displacing each atom in the +/- x, y, z directions. psi4.core.be_quiet() → None¶; Redirects output to /dev/null. To switch back to regular output mode, use reopen_outfile(). psi4.core.benchmark_blas1(arg0: int, arg1: float) → None¶; docstring. psi4.core.benchmark_blas2(arg0: int, arg1: float) → None¶; docstring. psi4.core.benchmark_blas3(arg0: int, arg1: float, arg2: int) → None¶; docstring. psi4.core.benchmark_disk(arg0: int, arg1: float) → None¶; docstring. psi4.core.benchmark_integrals(arg0: int, arg1: float) → None¶; docstring. psi4.core.benchmark_math(arg0: float) → None¶; docstring. psi4.core.ccdensity(arg0: psi::Wavefunction) → float¶; Runs the code to compute coupled cluster density matrices. psi4.core.ccenergy(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the coupled cluster energy code. psi4.core.cceom(arg0: psi::Wavefunction) → float¶; Runs the equation of motion coupled cluster code, for excited states. psi4.core.cchbar(arg0: psi::Wavefunction) → None¶; Runs the code to generate the similarity transformed Hamiltonian. psi4.core.cclambda(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the coupled cluster lambda equations code. psi4.core.ccresponse(arg0: psi::Wavefunction) → float¶; Runs the coupled cluster response theory code. psi4.core.cctransort(arg0: psi::Wavefunction) → None¶; Runs CCTRANSORT, which transforms and reorders integrals for use in the coupled cluster codes. psi4.core.cctriples(arg0: psi::Wavefunction) → float¶; Runs the coupled cluster (T) energy code. psi4.core.clean() → None¶; Function to remove scratch files. Call between independent jobs. psi4.core.clean_options() → None¶; Function to reset options to clean state. psi4.core.clean_variables() → None¶; Empties all PSI variables that have set inter",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:225512,Energy Efficiency,energy,energy,225512,"e.benchmark_integrals(arg0: int, arg1: float) → None¶; docstring. psi4.core.benchmark_math(arg0: float) → None¶; docstring. psi4.core.ccdensity(arg0: psi::Wavefunction) → float¶; Runs the code to compute coupled cluster density matrices. psi4.core.ccenergy(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the coupled cluster energy code. psi4.core.cceom(arg0: psi::Wavefunction) → float¶; Runs the equation of motion coupled cluster code, for excited states. psi4.core.cchbar(arg0: psi::Wavefunction) → None¶; Runs the code to generate the similarity transformed Hamiltonian. psi4.core.cclambda(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the coupled cluster lambda equations code. psi4.core.ccresponse(arg0: psi::Wavefunction) → float¶; Runs the coupled cluster response theory code. psi4.core.cctransort(arg0: psi::Wavefunction) → None¶; Runs CCTRANSORT, which transforms and reorders integrals for use in the coupled cluster codes. psi4.core.cctriples(arg0: psi::Wavefunction) → float¶; Runs the coupled cluster (T) energy code. psi4.core.clean() → None¶; Function to remove scratch files. Call between independent jobs. psi4.core.clean_options() → None¶; Function to reset options to clean state. psi4.core.clean_variables() → None¶; Empties all PSI variables that have set internally. psi4.core.close_outfile() → None¶; Closes the output file. psi4.core.dcft(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the density cumulant functional theory code. psi4.core.detci(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the determinant-based configuration interaction code. psi4.core.dfmp2(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the DF-MP2 code. psi4.core.dfocc(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the density-fitted orbital optimized CC codes. psi4.core.displace_atom(arg0: psi::Matrix, arg1: int, arg2: int, arg3: int, arg4: float) → None¶; Displaces one coordinate of single atom. psi4.core.dmrg(arg0: psi::Wavefunction) → float¶; Runs the DMRG co",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:226970,Energy Efficiency,energy,energy,226970,"cumulant functional theory code. psi4.core.detci(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the determinant-based configuration interaction code. psi4.core.dfmp2(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the DF-MP2 code. psi4.core.dfocc(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the density-fitted orbital optimized CC codes. psi4.core.displace_atom(arg0: psi::Matrix, arg1: int, arg2: int, arg3: int, arg4: float) → None¶; Displaces one coordinate of single atom. psi4.core.dmrg(arg0: psi::Wavefunction) → float¶; Runs the DMRG code. psi4.core.efp_init() → psi4.core.EFP¶; Initializes the EFP library and returns an EFP object. psi4.core.efp_set_options() → None¶; Set EFP options from environment options object. psi4.core.fcidump_tei_helper(nirrep: int, restricted: bool, DPD_info: Dict[str, int], ints_tolerance: float, fname: str='INTDUMP') → None¶; Write integrals to file in FCIDUMP format. psi4.core.fd_1_0(arg0: psi::Molecule, arg1: list) → psi::Matrix¶; Performs a finite difference gradient computation, from energy points. psi4.core.fd_freq_0(arg0: psi::Molecule, arg1: list, arg2: int) → psi::Matrix¶; Performs a finite difference frequency computation, from energy points, for a given irrep. psi4.core.fd_freq_1(arg0: psi::Molecule, arg1: list, arg2: int) → psi::Matrix¶; Performs a finite difference frequency computation, from gradients, for a given irrep. psi4.core.fd_geoms_1_0(arg0: psi::Molecule) → List[psi::Matrix]¶; Gets list of displacements needed for a finite difference gradient computation, from energy points. psi4.core.fd_geoms_freq_0(arg0: psi::Molecule, arg1: int) → List[psi::Matrix]¶; Gets list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep. psi4.core.fd_geoms_freq_1(arg0: psi::Molecule, arg1: int) → List[psi::Matrix]¶; Gets list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep. psi4.core.finalize() → None¶. psi4.c",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:227122,Energy Efficiency,energy,energy,227122," psi4.core.dfmp2(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the DF-MP2 code. psi4.core.dfocc(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the density-fitted orbital optimized CC codes. psi4.core.displace_atom(arg0: psi::Matrix, arg1: int, arg2: int, arg3: int, arg4: float) → None¶; Displaces one coordinate of single atom. psi4.core.dmrg(arg0: psi::Wavefunction) → float¶; Runs the DMRG code. psi4.core.efp_init() → psi4.core.EFP¶; Initializes the EFP library and returns an EFP object. psi4.core.efp_set_options() → None¶; Set EFP options from environment options object. psi4.core.fcidump_tei_helper(nirrep: int, restricted: bool, DPD_info: Dict[str, int], ints_tolerance: float, fname: str='INTDUMP') → None¶; Write integrals to file in FCIDUMP format. psi4.core.fd_1_0(arg0: psi::Molecule, arg1: list) → psi::Matrix¶; Performs a finite difference gradient computation, from energy points. psi4.core.fd_freq_0(arg0: psi::Molecule, arg1: list, arg2: int) → psi::Matrix¶; Performs a finite difference frequency computation, from energy points, for a given irrep. psi4.core.fd_freq_1(arg0: psi::Molecule, arg1: list, arg2: int) → psi::Matrix¶; Performs a finite difference frequency computation, from gradients, for a given irrep. psi4.core.fd_geoms_1_0(arg0: psi::Molecule) → List[psi::Matrix]¶; Gets list of displacements needed for a finite difference gradient computation, from energy points. psi4.core.fd_geoms_freq_0(arg0: psi::Molecule, arg1: int) → List[psi::Matrix]¶; Gets list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep. psi4.core.fd_geoms_freq_1(arg0: psi::Molecule, arg1: int) → List[psi::Matrix]¶; Gets list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep. psi4.core.finalize() → None¶. psi4.core.flush_outfile() → None¶; Flushes the output file. psi4.core.fnocc(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the fno-ccsd(t)/qcisd(t)/mp4/cep",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:227474,Energy Efficiency,energy,energy,227474,"tom. psi4.core.dmrg(arg0: psi::Wavefunction) → float¶; Runs the DMRG code. psi4.core.efp_init() → psi4.core.EFP¶; Initializes the EFP library and returns an EFP object. psi4.core.efp_set_options() → None¶; Set EFP options from environment options object. psi4.core.fcidump_tei_helper(nirrep: int, restricted: bool, DPD_info: Dict[str, int], ints_tolerance: float, fname: str='INTDUMP') → None¶; Write integrals to file in FCIDUMP format. psi4.core.fd_1_0(arg0: psi::Molecule, arg1: list) → psi::Matrix¶; Performs a finite difference gradient computation, from energy points. psi4.core.fd_freq_0(arg0: psi::Molecule, arg1: list, arg2: int) → psi::Matrix¶; Performs a finite difference frequency computation, from energy points, for a given irrep. psi4.core.fd_freq_1(arg0: psi::Molecule, arg1: list, arg2: int) → psi::Matrix¶; Performs a finite difference frequency computation, from gradients, for a given irrep. psi4.core.fd_geoms_1_0(arg0: psi::Molecule) → List[psi::Matrix]¶; Gets list of displacements needed for a finite difference gradient computation, from energy points. psi4.core.fd_geoms_freq_0(arg0: psi::Molecule, arg1: int) → List[psi::Matrix]¶; Gets list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep. psi4.core.fd_geoms_freq_1(arg0: psi::Molecule, arg1: int) → List[psi::Matrix]¶; Gets list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep. psi4.core.finalize() → None¶. psi4.core.flush_outfile() → None¶; Flushes the output file. psi4.core.fnocc(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the fno-ccsd(t)/qcisd(t)/mp4/cepa energy code. psi4.core.get_active_efp() → psi4.core.EFP¶; Returns the currently active EFP object. psi4.core.get_active_molecule() → psi::Molecule¶; Returns the currently active molecule object. psi4.core.get_array_variable(arg0: str) → psi::Matrix¶; Returns one of the PSI variables set internally by the modules or python driver (se",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:227655,Energy Efficiency,energy,energy,227655,"set_options() → None¶; Set EFP options from environment options object. psi4.core.fcidump_tei_helper(nirrep: int, restricted: bool, DPD_info: Dict[str, int], ints_tolerance: float, fname: str='INTDUMP') → None¶; Write integrals to file in FCIDUMP format. psi4.core.fd_1_0(arg0: psi::Molecule, arg1: list) → psi::Matrix¶; Performs a finite difference gradient computation, from energy points. psi4.core.fd_freq_0(arg0: psi::Molecule, arg1: list, arg2: int) → psi::Matrix¶; Performs a finite difference frequency computation, from energy points, for a given irrep. psi4.core.fd_freq_1(arg0: psi::Molecule, arg1: list, arg2: int) → psi::Matrix¶; Performs a finite difference frequency computation, from gradients, for a given irrep. psi4.core.fd_geoms_1_0(arg0: psi::Molecule) → List[psi::Matrix]¶; Gets list of displacements needed for a finite difference gradient computation, from energy points. psi4.core.fd_geoms_freq_0(arg0: psi::Molecule, arg1: int) → List[psi::Matrix]¶; Gets list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep. psi4.core.fd_geoms_freq_1(arg0: psi::Molecule, arg1: int) → List[psi::Matrix]¶; Gets list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep. psi4.core.finalize() → None¶. psi4.core.flush_outfile() → None¶; Flushes the output file. psi4.core.fnocc(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the fno-ccsd(t)/qcisd(t)/mp4/cepa energy code. psi4.core.get_active_efp() → psi4.core.EFP¶; Returns the currently active EFP object. psi4.core.get_active_molecule() → psi::Molecule¶; Returns the currently active molecule object. psi4.core.get_array_variable(arg0: str) → psi::Matrix¶; Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available). psi4.core.get_array_variables() → Dict[str, psi::Matrix]¶; Returns dictionary of the PSI variables set internally by the modules or ",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:228077,Energy Efficiency,energy,energy,228077," arg2: int) → psi::Matrix¶; Performs a finite difference frequency computation, from energy points, for a given irrep. psi4.core.fd_freq_1(arg0: psi::Molecule, arg1: list, arg2: int) → psi::Matrix¶; Performs a finite difference frequency computation, from gradients, for a given irrep. psi4.core.fd_geoms_1_0(arg0: psi::Molecule) → List[psi::Matrix]¶; Gets list of displacements needed for a finite difference gradient computation, from energy points. psi4.core.fd_geoms_freq_0(arg0: psi::Molecule, arg1: int) → List[psi::Matrix]¶; Gets list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep. psi4.core.fd_geoms_freq_1(arg0: psi::Molecule, arg1: int) → List[psi::Matrix]¶; Gets list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep. psi4.core.finalize() → None¶. psi4.core.flush_outfile() → None¶; Flushes the output file. psi4.core.fnocc(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the fno-ccsd(t)/qcisd(t)/mp4/cepa energy code. psi4.core.get_active_efp() → psi4.core.EFP¶; Returns the currently active EFP object. psi4.core.get_active_molecule() → psi::Molecule¶; Returns the currently active molecule object. psi4.core.get_array_variable(arg0: str) → psi::Matrix¶; Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available). psi4.core.get_array_variables() → Dict[str, psi::Matrix]¶; Returns dictionary of the PSI variables set internally by the modules or python driver. psi4.core.get_atomic_point_charges() → psi::Vector¶; Returns the most recently computed atomic point charges, as a double * object. psi4.core.get_datadir() → str¶; Sets the path to shared text resources, PSIDATADIR. psi4.core.get_efp_torque() → psi::Matrix¶; Returns the most recently computed gradient for the EFP portion, as a Nefp by 6 Matrix object. psi4.core.get_frequencies() → psi::Vector¶; Returns the most recently comp",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:228710,Energy Efficiency,charge,charges,228710,"en irrep. psi4.core.fd_geoms_freq_1(arg0: psi::Molecule, arg1: int) → List[psi::Matrix]¶; Gets list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep. psi4.core.finalize() → None¶. psi4.core.flush_outfile() → None¶; Flushes the output file. psi4.core.fnocc(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the fno-ccsd(t)/qcisd(t)/mp4/cepa energy code. psi4.core.get_active_efp() → psi4.core.EFP¶; Returns the currently active EFP object. psi4.core.get_active_molecule() → psi::Molecule¶; Returns the currently active molecule object. psi4.core.get_array_variable(arg0: str) → psi::Matrix¶; Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available). psi4.core.get_array_variables() → Dict[str, psi::Matrix]¶; Returns dictionary of the PSI variables set internally by the modules or python driver. psi4.core.get_atomic_point_charges() → psi::Vector¶; Returns the most recently computed atomic point charges, as a double * object. psi4.core.get_datadir() → str¶; Sets the path to shared text resources, PSIDATADIR. psi4.core.get_efp_torque() → psi::Matrix¶; Returns the most recently computed gradient for the EFP portion, as a Nefp by 6 Matrix object. psi4.core.get_frequencies() → psi::Vector¶; Returns the most recently computed frequencies, as a 3N-6 Vector object. psi4.core.get_global_option(arg0: str) → object¶; Given a string of a keyword name arg1, returns the value associated with the keyword from the global options. Returns error if keyword is not recognized. psi4.core.get_global_option_list() → List[str]¶; Returns a list of all global options. psi4.core.get_gradient() → psi::Matrix¶; Returns the most recently computed gradient, as a N by 3 Matrix object. psi4.core.get_legacy_molecule() → psi::Molecule¶; Returns the currently active molecule object. psi4.core.get_local_option(arg0: str, arg1: str) → object¶; Given a string of a keyword name arg2 an",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:235469,Energy Efficiency,adapt,adapted,235469,"eopens the output file. psi4.core.revoke_global_option_changed(arg0: str) → None¶; Given a string of a keyword name arg1, sets the has_changed attribute in the global options scope to false. Used in python driver when a function sets the value of an option. Before the function exits, this command is called on the option so that has_changed reflects whether the user (not the program) has touched the option. psi4.core.revoke_local_option_changed(arg0: str, arg1: str) → None¶; Given a string of a keyword name arg2 and a particular module arg1, sets the has_changed attribute in the module options scope to false. Used in python driver when a function sets the value of an option. Before the function exits, this command is called on the option so that has_changed reflects whether the user (not the program) has touched the option. psi4.core.run_gdma(arg0: psi::Wavefunction, arg1: str) → float¶; Runs the GDMA code. psi4.core.sapt(arg0: psi::Wavefunction, arg1: psi::Wavefunction, arg2: psi::Wavefunction) → float¶; Runs the symmetry adapted perturbation theory code. psi4.core.scatter(arg0: psi::Molecule, arg1: float, arg2: list, arg3: list, arg4: list) → None¶; New Scatter function. psi4.core.scfgrad(arg0: psi::Wavefunction) → psi::Matrix¶; Run scfgrad, which is a specialized DF-SCF gradient program. psi4.core.scfhess(arg0: psi::Wavefunction) → psi::Matrix¶; Run scfhess, which is a specialized DF-SCF hessian program. psi4.core.set_active_molecule(arg0: psi::Molecule) → None¶; Activates a previously defined (in the input) molecule, by name. psi4.core.set_array_variable(arg0: str, arg1: psi::Matrix) → None¶; Sets a PSI variable, by name. psi4.core.set_datadir(arg0: str) → None¶; Returns the amount of memory available to Psi (in bytes). psi4.core.set_efp_torque(arg0: psi::Matrix) → None¶; Assigns the global EFP gradient to the values stored in the Nefp by 6 Matrix argument. psi4.core.set_frequencies(arg0: psi::Vector) → None¶; Assigns the global frequencies to the values stored in",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:241495,Energy Efficiency,energy,energy,241495,"rg1, arg2, arg3, arg4, arg5, …); docstring. DTBMV(arg0, arg1, arg2, arg3, arg4, arg5, …); docstring. DTBSV(arg0, arg1, arg2, arg3, arg4, arg5, …); docstring. DTRMM(arg0, arg1, arg2, arg3, arg4, arg5, …); docstring. DTRMV(arg0, arg1, arg2, arg3, arg4, arg5, …); docstring. DTRSM(arg0, arg1, arg2, arg3, arg4, arg5, …); docstring. DTRSV(arg0, arg1, arg2, arg3, arg4, arg5, …); docstring. IDAMAX(arg0, arg1, arg2, arg3); docstring. adc(arg0); Runs the ADC propagator code, for excited states. atomic_displacements(arg0); Returns list of displacements generated by displacing each atom in the +/- x, y, z directions. be_quiet(); Redirects output to /dev/null. benchmark_blas1(arg0, arg1); docstring. benchmark_blas2(arg0, arg1); docstring. benchmark_blas3(arg0, arg1, arg2); docstring. benchmark_disk(arg0, arg1); docstring. benchmark_integrals(arg0, arg1); docstring. benchmark_math(arg0); docstring. ccdensity(arg0); Runs the code to compute coupled cluster density matrices. ccenergy(arg0); Runs the coupled cluster energy code. cceom(arg0); Runs the equation of motion coupled cluster code, for excited states. cchbar(arg0); Runs the code to generate the similarity transformed Hamiltonian. cclambda(arg0); Runs the coupled cluster lambda equations code. ccresponse(arg0); Runs the coupled cluster response theory code. cctransort(arg0); Runs CCTRANSORT, which transforms and reorders integrals for use in the coupled cluster codes. cctriples(arg0); Runs the coupled cluster (T) energy code. clean(); Function to remove scratch files. clean_options(); Function to reset options to clean state. clean_variables(); Empties all PSI variables that have set internally. close_outfile(); Closes the output file. dcft(arg0); Runs the density cumulant functional theory code. detci(arg0); Runs the determinant-based configuration interaction code. dfmp2(arg0); Runs the DF-MP2 code. dfocc(arg0); Runs the density-fitted orbital optimized CC codes. displace_atom(arg0, arg1, arg2, arg3, arg4); Displaces one c",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:241959,Energy Efficiency,energy,energy,241959,"or code, for excited states. atomic_displacements(arg0); Returns list of displacements generated by displacing each atom in the +/- x, y, z directions. be_quiet(); Redirects output to /dev/null. benchmark_blas1(arg0, arg1); docstring. benchmark_blas2(arg0, arg1); docstring. benchmark_blas3(arg0, arg1, arg2); docstring. benchmark_disk(arg0, arg1); docstring. benchmark_integrals(arg0, arg1); docstring. benchmark_math(arg0); docstring. ccdensity(arg0); Runs the code to compute coupled cluster density matrices. ccenergy(arg0); Runs the coupled cluster energy code. cceom(arg0); Runs the equation of motion coupled cluster code, for excited states. cchbar(arg0); Runs the code to generate the similarity transformed Hamiltonian. cclambda(arg0); Runs the coupled cluster lambda equations code. ccresponse(arg0); Runs the coupled cluster response theory code. cctransort(arg0); Runs CCTRANSORT, which transforms and reorders integrals for use in the coupled cluster codes. cctriples(arg0); Runs the coupled cluster (T) energy code. clean(); Function to remove scratch files. clean_options(); Function to reset options to clean state. clean_variables(); Empties all PSI variables that have set internally. close_outfile(); Closes the output file. dcft(arg0); Runs the density cumulant functional theory code. detci(arg0); Runs the determinant-based configuration interaction code. dfmp2(arg0); Runs the DF-MP2 code. dfocc(arg0); Runs the density-fitted orbital optimized CC codes. displace_atom(arg0, arg1, arg2, arg3, arg4); Displaces one coordinate of single atom. dmrg(arg0); Runs the DMRG code. efp_init(); Initializes the EFP library and returns an EFP object. efp_set_options(); Set EFP options from environment options object. fcidump_tei_helper(nirrep, restricted, …); Write integrals to file in FCIDUMP format. fd_1_0(arg0, arg1); Performs a finite difference gradient computation, from energy points. fd_freq_0(arg0, arg1, arg2); Performs a finite difference frequency computation, from energy",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:242835,Energy Efficiency,energy,energy,242835,"ransort(arg0); Runs CCTRANSORT, which transforms and reorders integrals for use in the coupled cluster codes. cctriples(arg0); Runs the coupled cluster (T) energy code. clean(); Function to remove scratch files. clean_options(); Function to reset options to clean state. clean_variables(); Empties all PSI variables that have set internally. close_outfile(); Closes the output file. dcft(arg0); Runs the density cumulant functional theory code. detci(arg0); Runs the determinant-based configuration interaction code. dfmp2(arg0); Runs the DF-MP2 code. dfocc(arg0); Runs the density-fitted orbital optimized CC codes. displace_atom(arg0, arg1, arg2, arg3, arg4); Displaces one coordinate of single atom. dmrg(arg0); Runs the DMRG code. efp_init(); Initializes the EFP library and returns an EFP object. efp_set_options(); Set EFP options from environment options object. fcidump_tei_helper(nirrep, restricted, …); Write integrals to file in FCIDUMP format. fd_1_0(arg0, arg1); Performs a finite difference gradient computation, from energy points. fd_freq_0(arg0, arg1, arg2); Performs a finite difference frequency computation, from energy points, for a given irrep. fd_freq_1(arg0, arg1, arg2); Performs a finite difference frequency computation, from gradients, for a given irrep. fd_geoms_1_0(arg0); Gets list of displacements needed for a finite difference gradient computation, from energy points. fd_geoms_freq_0(arg0, arg1); Gets list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep. fd_geoms_freq_1(arg0, arg1); Gets list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep. finalize(). flush_outfile(); Flushes the output file. fnocc(arg0); Runs the fno-ccsd(t)/qcisd(t)/mp4/cepa energy code. get_active_efp(); Returns the currently active EFP object. get_active_molecule(); Returns the currently active molecule object. get_array_variable(arg0); Returns one of the PSI variable",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:242936,Energy Efficiency,energy,energy,242936,"es. cctriples(arg0); Runs the coupled cluster (T) energy code. clean(); Function to remove scratch files. clean_options(); Function to reset options to clean state. clean_variables(); Empties all PSI variables that have set internally. close_outfile(); Closes the output file. dcft(arg0); Runs the density cumulant functional theory code. detci(arg0); Runs the determinant-based configuration interaction code. dfmp2(arg0); Runs the DF-MP2 code. dfocc(arg0); Runs the density-fitted orbital optimized CC codes. displace_atom(arg0, arg1, arg2, arg3, arg4); Displaces one coordinate of single atom. dmrg(arg0); Runs the DMRG code. efp_init(); Initializes the EFP library and returns an EFP object. efp_set_options(); Set EFP options from environment options object. fcidump_tei_helper(nirrep, restricted, …); Write integrals to file in FCIDUMP format. fd_1_0(arg0, arg1); Performs a finite difference gradient computation, from energy points. fd_freq_0(arg0, arg1, arg2); Performs a finite difference frequency computation, from energy points, for a given irrep. fd_freq_1(arg0, arg1, arg2); Performs a finite difference frequency computation, from gradients, for a given irrep. fd_geoms_1_0(arg0); Gets list of displacements needed for a finite difference gradient computation, from energy points. fd_geoms_freq_0(arg0, arg1); Gets list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep. fd_geoms_freq_1(arg0, arg1); Gets list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep. finalize(). flush_outfile(); Flushes the output file. fnocc(arg0); Runs the fno-ccsd(t)/qcisd(t)/mp4/cepa energy code. get_active_efp(); Returns the currently active EFP object. get_active_molecule(); Returns the currently active molecule object. get_array_variable(arg0); Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available). ge",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:243191,Energy Efficiency,energy,energy,243191,"close_outfile(); Closes the output file. dcft(arg0); Runs the density cumulant functional theory code. detci(arg0); Runs the determinant-based configuration interaction code. dfmp2(arg0); Runs the DF-MP2 code. dfocc(arg0); Runs the density-fitted orbital optimized CC codes. displace_atom(arg0, arg1, arg2, arg3, arg4); Displaces one coordinate of single atom. dmrg(arg0); Runs the DMRG code. efp_init(); Initializes the EFP library and returns an EFP object. efp_set_options(); Set EFP options from environment options object. fcidump_tei_helper(nirrep, restricted, …); Write integrals to file in FCIDUMP format. fd_1_0(arg0, arg1); Performs a finite difference gradient computation, from energy points. fd_freq_0(arg0, arg1, arg2); Performs a finite difference frequency computation, from energy points, for a given irrep. fd_freq_1(arg0, arg1, arg2); Performs a finite difference frequency computation, from gradients, for a given irrep. fd_geoms_1_0(arg0); Gets list of displacements needed for a finite difference gradient computation, from energy points. fd_geoms_freq_0(arg0, arg1); Gets list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep. fd_geoms_freq_1(arg0, arg1); Gets list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep. finalize(). flush_outfile(); Flushes the output file. fnocc(arg0); Runs the fno-ccsd(t)/qcisd(t)/mp4/cepa energy code. get_active_efp(); Returns the currently active EFP object. get_active_molecule(); Returns the currently active molecule object. get_array_variable(arg0); Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available). get_array_variables(); Returns dictionary of the PSI variables set internally by the modules or python driver. get_atomic_point_charges(); Returns the most recently computed atomic point charges, as a double * object. get_datadir(); Sets ",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:243321,Energy Efficiency,energy,energy,243321,"nt-based configuration interaction code. dfmp2(arg0); Runs the DF-MP2 code. dfocc(arg0); Runs the density-fitted orbital optimized CC codes. displace_atom(arg0, arg1, arg2, arg3, arg4); Displaces one coordinate of single atom. dmrg(arg0); Runs the DMRG code. efp_init(); Initializes the EFP library and returns an EFP object. efp_set_options(); Set EFP options from environment options object. fcidump_tei_helper(nirrep, restricted, …); Write integrals to file in FCIDUMP format. fd_1_0(arg0, arg1); Performs a finite difference gradient computation, from energy points. fd_freq_0(arg0, arg1, arg2); Performs a finite difference frequency computation, from energy points, for a given irrep. fd_freq_1(arg0, arg1, arg2); Performs a finite difference frequency computation, from gradients, for a given irrep. fd_geoms_1_0(arg0); Gets list of displacements needed for a finite difference gradient computation, from energy points. fd_geoms_freq_0(arg0, arg1); Gets list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep. fd_geoms_freq_1(arg0, arg1); Gets list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep. finalize(). flush_outfile(); Flushes the output file. fnocc(arg0); Runs the fno-ccsd(t)/qcisd(t)/mp4/cepa energy code. get_active_efp(); Returns the currently active EFP object. get_active_molecule(); Returns the currently active molecule object. get_array_variable(arg0); Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available). get_array_variables(); Returns dictionary of the PSI variables set internally by the modules or python driver. get_atomic_point_charges(); Returns the most recently computed atomic point charges, as a double * object. get_datadir(); Sets the path to shared text resources, PSIDATADIR. get_efp_torque(); Returns the most recently computed gradient for the EFP portion, as a ",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:243606,Energy Efficiency,energy,energy,243606,"urns an EFP object. efp_set_options(); Set EFP options from environment options object. fcidump_tei_helper(nirrep, restricted, …); Write integrals to file in FCIDUMP format. fd_1_0(arg0, arg1); Performs a finite difference gradient computation, from energy points. fd_freq_0(arg0, arg1, arg2); Performs a finite difference frequency computation, from energy points, for a given irrep. fd_freq_1(arg0, arg1, arg2); Performs a finite difference frequency computation, from gradients, for a given irrep. fd_geoms_1_0(arg0); Gets list of displacements needed for a finite difference gradient computation, from energy points. fd_geoms_freq_0(arg0, arg1); Gets list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep. fd_geoms_freq_1(arg0, arg1); Gets list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep. finalize(). flush_outfile(); Flushes the output file. fnocc(arg0); Runs the fno-ccsd(t)/qcisd(t)/mp4/cepa energy code. get_active_efp(); Returns the currently active EFP object. get_active_molecule(); Returns the currently active molecule object. get_array_variable(arg0); Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available). get_array_variables(); Returns dictionary of the PSI variables set internally by the modules or python driver. get_atomic_point_charges(); Returns the most recently computed atomic point charges, as a double * object. get_datadir(); Sets the path to shared text resources, PSIDATADIR. get_efp_torque(); Returns the most recently computed gradient for the EFP portion, as a Nefp by 6 Matrix object. get_frequencies(); Returns the most recently computed frequencies, as a 3N-6 Vector object. get_global_option(arg0); Given a string of a keyword name arg1, returns the value associated with the keyword from the global options. get_global_option_list(); Returns a list of all global",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:244094,Energy Efficiency,charge,charges,244094," a given irrep. fd_geoms_1_0(arg0); Gets list of displacements needed for a finite difference gradient computation, from energy points. fd_geoms_freq_0(arg0, arg1); Gets list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep. fd_geoms_freq_1(arg0, arg1); Gets list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep. finalize(). flush_outfile(); Flushes the output file. fnocc(arg0); Runs the fno-ccsd(t)/qcisd(t)/mp4/cepa energy code. get_active_efp(); Returns the currently active EFP object. get_active_molecule(); Returns the currently active molecule object. get_array_variable(arg0); Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available). get_array_variables(); Returns dictionary of the PSI variables set internally by the modules or python driver. get_atomic_point_charges(); Returns the most recently computed atomic point charges, as a double * object. get_datadir(); Sets the path to shared text resources, PSIDATADIR. get_efp_torque(); Returns the most recently computed gradient for the EFP portion, as a Nefp by 6 Matrix object. get_frequencies(); Returns the most recently computed frequencies, as a 3N-6 Vector object. get_global_option(arg0); Given a string of a keyword name arg1, returns the value associated with the keyword from the global options. get_global_option_list(); Returns a list of all global options. get_gradient(); Returns the most recently computed gradient, as a N by 3 Matrix object. get_legacy_molecule(); Returns the currently active molecule object. get_local_option(arg0, arg1); Given a string of a keyword name arg2 and a particular module arg1, returns the value associated with the keyword in the module options scope. get_memory(); Returns the amount of memory available to Psi (in bytes). get_num_threads(); Returns the number of threads to use in SMP parallel c",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:248320,Energy Efficiency,adapt,adapted,248320," Sets the options module up to return options pertaining to the named argument (e.g. print_global_options(); Prints the currently set global (all modules) options to the output file. print_options(); Prints the currently set options (to the output file) for the current module. print_out(arg0); Prints a string (using sprintf-like notation) to the output file. print_variables(); Prints all PSI variables that have been set internally. psi_top_srcdir(); Returns the location of the source code. psimrcc(arg0); Runs the multireference coupled cluster code. reopen_outfile(); Reopens the output file. revoke_global_option_changed(arg0); Given a string of a keyword name arg1, sets the has_changed attribute in the global options scope to false. revoke_local_option_changed(arg0, arg1); Given a string of a keyword name arg2 and a particular module arg1, sets the has_changed attribute in the module options scope to false. run_gdma(arg0, arg1); Runs the GDMA code. sapt(arg0, arg1, arg2); Runs the symmetry adapted perturbation theory code. scatter(arg0, arg1, arg2, arg3, arg4); New Scatter function. scfgrad(arg0); Run scfgrad, which is a specialized DF-SCF gradient program. scfhess(arg0); Run scfhess, which is a specialized DF-SCF hessian program. set_active_molecule(arg0); Activates a previously defined (in the input) molecule, by name. set_array_variable(arg0, arg1); Sets a PSI variable, by name. set_datadir(arg0); Returns the amount of memory available to Psi (in bytes). set_efp_torque(arg0); Assigns the global EFP gradient to the values stored in the Nefp by 6 Matrix argument. set_frequencies(arg0); Assigns the global frequencies to the values stored in the 3N-6 Vector argument. set_global_option(*args, **kwargs); Overloaded function. set_global_option_python(key, EXTERN); This is a fairly hacky way to get around EXTERN issues. set_gradient(arg0); Assigns the global gradient to the values stored in the N by 3 Matrix argument. set_legacy_molecule(arg0); Activates a previously def",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:250580,Energy Efficiency,adapt,adapted,250580,"object, but scoped only to a single module. set_memory_bytes(memory, quiet); Sets the memory available to Psi (in bytes). set_num_threads(nthread, quiet); Sets the number of threads to use in SMP parallel computations. set_output_file(*args, **kwargs); Overloaded function. set_parent_symmetry(arg0); Sets the symmetry of the ‘parent’ (undisplaced) geometry, by Schoenflies symbol, at the beginning of a finite difference computation. set_psi_file_prefix(arg0). set_variable(arg0, arg1); Sets a PSI variable, by name. tstart(); docstring. tstop(); docstring. version(); Returns the version ID of this copy of Psi. Classes¶. AOShellCombinationsIterator. AngularMomentumInt; Computes angular momentum integrals. BSVec. BasisExtents; docstring. BasisFunctions; docstring. BasisSet; Contains basis set information. BlockOPoints; docstring. BoysLocalizer; Performs Boys orbital localization. CIVector; docstring. CIWavefunction; docstring. CUHF; docstring. CdSalcList; Class for generating symmetry adapted linear combinations of Cartesian displacements. CorrelationFactor; docstring. CorrelationTable; Provides a correlation table between two point groups. CubeProperties; docstring. DFEP2Wavefunction; A density-fitted second-order Electron Propagator Wavefunction. DFHelper; docstring. DFSOMCSCF; docstring. DFTGrid; docstring. DFTensor; docstring. Deriv; Computes gradients of wavefunctions. DiagonalizeOrder; Defines ordering of eigenvalues after diagonalization. Dimension; Initializes and defines Dimension Objects. DipoleInt; Computes dipole integrals. DiskSOMCSCF; docstring. Dispersion; docstring. EFP; Class interfacing with libefp. ERI; Computes normal two electron reuplsion integrals. ElectricFieldInt; Computes electric field integrals. ElectrostaticInt; Computes electrostatic integrals. ErfComplementERI; Computes ERF complement electron repulsion integrals. ErfERI; Computes ERF electron repulsion integrals. ExternalPotential; Stores external potential field, computes external potentia",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:253221,Energy Efficiency,charge,charge,253221,"functions. GaussianType; 0 if Cartesian, 1 if Pure. GeometryUnits; The units used to define the geometry. HF; docstring. IO; docstring. IOManager; PSIOManager is a class designed to be used as a static object to track all PSIO operations in a given PSI4 computation. IntVector; Class handling vectors with integer values. IntegralFactory; Computes integrals. IntegralTransform; IntegralTransform transforms one- and two-electron integrals within general spaces. JK; docstring. KineticInt; Computes kinetic integrals. LaplaceDenominator; docstring. LibXCFunctional; docstring. Localizer; Class containing orbital localization procedures. MOSpace; Defines orbital spaces in which to transform integrals. MOWriter; Writes the MOs. Matrix; Class for creating and manipulating matrices. MatrixFactory; Creates Matrix objects. MintsHelper; Computes integrals. MoldenWriter; Writes wavefunction information in molden format. MolecularGrid; docstring. Molecule; Class to store the elements, coordinates, fragmentation pattern, basis sets, charge, multiplicity, etc. MultipoleInt; Computes arbitrary-order multipole integrals. MultipoleSymmetry; docstring. NBOWriter; The Natural Bond Orbital Writer. NablaInt; Computes nabla integrals. OEProp; docstring. OneBodyAOInt; Basis class for all one-electron integrals. Options; docstring. OrbitalSpace; Contains information about the orbitals. OverlapInt; Computes overlap integrals. PMLocalizer; Performs Pipek-Mezey orbital localization. PetiteList; Handles symmetry transformations. PointFunctions; docstring. PointGroup; Contains information about the point group. PotentialInt; Computes potential integrals. PrimitiveType; May be Normalized or Unnormalized. Prop; docstring. PseudospectralInt; Computes pseudospectral integrals. PsiReturnType; docstring. QuadrupoleInt; Computes quadrupole integrals. RHF; docstring. RKSFunctions; docstring. ROHF; docstring. SADGuess; docstring. SOBasisSet; An SOBasis object describes the transformation from an atomic orbit",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:257664,Energy Efficiency,energy,energy,257664,"f(cls, arg1, arg2, …):. …. It can be called either on the class (e.g. C.f()) or on an instance; (e.g. C().f()). The instance is ignored except for its class.; If a class method is called for a derived class, the derived class; object is passed as the implied first argument.; Class methods are different than C++ or Java static methods.; If you want those, see the staticmethod builtin. Functions¶. activate(mol); Function to set molecule object mol as the current active molecule. ancestor(dir[, n]); Get the nth ancestor of a directory. banner(text[, type, width, strNotOutfile]); Function to print text to output file in a banner of minimum width width and minimum three-line height for type = 1 or one-line height for type = 2. basis_helper(block[, name, key, set_option]); For PsiAPI mode, forms a basis specification function from block and associates it with keyword key under handle name. cbs(func, label, **kwargs); Function to define a multistage energy method from combinations of basis set extrapolations and delta corrections and condense the components into a minimum number of calculations. check_iwl_file_from_scf_type(scf_type, wfn); Ensures that a IWL file has been written based on input SCF type. compare_arrays(expected, computed, digits, label); Function to compare two numpy arrays. compare_csx(); Function to validate energies in CSX files against PSIvariables. compare_cubes(expected, computed, label); Function to compare two cube files. compare_fcidumps(expected, computed, label); Function to compare two FCIDUMP files. compare_integers(expected, computed, label); Function to compare two integers. compare_matrices(expected, computed, digits, …); Function to compare two matrices. compare_strings(expected, computed, label); Function to compare two strings. compare_values(expected, computed, digits, label); Function to compare two values. compare_vectors(expected, computed, digits, …); Function to compare two vectors. copy_file_from_scratch(filename, prefix, …); Funct",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:259334,Energy Efficiency,energy,energy,259334,"gits, …); Function to compare two matrices. compare_strings(expected, computed, label); Function to compare two strings. compare_values(expected, computed, digits, label); Function to compare two values. compare_vectors(expected, computed, digits, …); Function to compare two vectors. copy_file_from_scratch(filename, prefix, …); Function to move file out of scratch with correct naming convention. copy_file_to_scratch(filename, prefix, …); Function to move file into scratch with correct naming convention. create_plugin(name, template); Generate plugin in directory with sanitized name based upon template. csx2endict(); Grabs the CSX file as a dictionary, encodes translation of PSI variables to XML blocks, gathers all available energies from CSX file into returned dictionary. cubeprop(wfn, **kwargs); Evaluate properties on a grid and generate cube files. dynamic_variable_bind(cls); Function to dynamically add extra members to the core.Molecule class. energy(name, **kwargs); Function to compute the single-point electronic energy. fchk(wfn, filename); Function to write wavefunction information in wfn to filename in Gaussian FCHK format. fcidump(wfn[, fname, oe_ints]); Save integrals to file in FCIDUMP format as defined in Comp. fcidump_from_file(fname); Function to read in a FCIDUMP file. filter_comments(string); Remove from string any Python-style comments (‘#’ to end of line). find_approximate_string_matches(seq1, …); Function to compute approximate string matches from a list of options. freq(name, **kwargs); Function to compute harmonic vibrational frequencies. frequencies(name, **kwargs); Function to compute harmonic vibrational frequencies. frequency(name, **kwargs); Function to compute harmonic vibrational frequencies. gdma(wfn[, datafile]); Function to use wavefunction information in wfn and, if specified, additional commands in filename to run GDMA analysis. geometry(geom[, name]); Function to create a molecule object of name name from the geometry in string geom.",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:259406,Energy Efficiency,energy,energy,259406,"gits, …); Function to compare two matrices. compare_strings(expected, computed, label); Function to compare two strings. compare_values(expected, computed, digits, label); Function to compare two values. compare_vectors(expected, computed, digits, …); Function to compare two vectors. copy_file_from_scratch(filename, prefix, …); Function to move file out of scratch with correct naming convention. copy_file_to_scratch(filename, prefix, …); Function to move file into scratch with correct naming convention. create_plugin(name, template); Generate plugin in directory with sanitized name based upon template. csx2endict(); Grabs the CSX file as a dictionary, encodes translation of PSI variables to XML blocks, gathers all available energies from CSX file into returned dictionary. cubeprop(wfn, **kwargs); Evaluate properties on a grid and generate cube files. dynamic_variable_bind(cls); Function to dynamically add extra members to the core.Molecule class. energy(name, **kwargs); Function to compute the single-point electronic energy. fchk(wfn, filename); Function to write wavefunction information in wfn to filename in Gaussian FCHK format. fcidump(wfn[, fname, oe_ints]); Save integrals to file in FCIDUMP format as defined in Comp. fcidump_from_file(fname); Function to read in a FCIDUMP file. filter_comments(string); Remove from string any Python-style comments (‘#’ to end of line). find_approximate_string_matches(seq1, …); Function to compute approximate string matches from a list of options. freq(name, **kwargs); Function to compute harmonic vibrational frequencies. frequencies(name, **kwargs); Function to compute harmonic vibrational frequencies. frequency(name, **kwargs); Function to compute harmonic vibrational frequencies. gdma(wfn[, datafile]); Function to use wavefunction information in wfn and, if specified, additional commands in filename to run GDMA analysis. geometry(geom[, name]); Function to create a molecule object of name name from the geometry in string geom.",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:5480,Integrability,depend,depending,5480,"object. move_atom(self: psi4.core.BasisSet, arg0: int, arg1: psi4.core.Vector3) → None¶; Translate a given atom by a given amount. Does not affect the underlying molecule object. n_ecp_core(*args, **kwargs)¶; Overloaded function. n_ecp_core(self: psi4.core.BasisSet) -> int. Returns the total number of core electrons associated with all ECPs in this basis. n_ecp_core(self: psi4.core.BasisSet, arg0: str) -> int. Returns the number of core electrons associated with any ECP on the specified atom type for this basis set. n_frozen_core(self: psi4.core.BasisSet, arg0: str, arg1: psi4.core.Molecule) → int¶; Returns the number of orbital (non-ECP) frozen core electrons. For a given molecule and FREEZE_CORE, (n_ecp_core()/2 + n_frozen_core()) = constant. name(self: psi4.core.BasisSet) → str¶; Callback handle, may represent string or function. nao(self: psi4.core.BasisSet) → int¶; Returns number of atomic orbitals (Cartesian). nbf(self: psi4.core.BasisSet) → int¶; Returns number of basis functions (Cartesian or spherical depending on has_puream). nprimitive(self: psi4.core.BasisSet) → int¶; Returns total number of primitives in all contractions. nshell(self: psi4.core.BasisSet) → int¶; Returns number of shells. nshell_on_center(self: psi4.core.BasisSet, i: int) → int¶; Return the number of shells on a given center. print_detail_out(self: psi4.core.BasisSet) → None¶; Prints detailed basis set info to outfile. print_out(self: psi4.core.BasisSet) → None¶; Prints basis set info to outfile. shell(*args, **kwargs)¶; Overloaded function. shell(self: psi4.core.BasisSet, si: int) -> psi4.core.GaussianShell. Return the si’th Gaussian shell. shell(self: psi4.core.BasisSet, center: int, si: int) -> psi4.core.GaussianShell. Return the si’th Gaussian shell on center. shell_to_ao_function(self: psi4.core.BasisSet, i: int) → int¶; Return the function number for the first function for the i’th shell. shell_to_basis_function(self: psi4.core.BasisSet, i: int) → int¶; Given a shell return its firs",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:5593,Integrability,contract,contractions,5593,"a given amount. Does not affect the underlying molecule object. n_ecp_core(*args, **kwargs)¶; Overloaded function. n_ecp_core(self: psi4.core.BasisSet) -> int. Returns the total number of core electrons associated with all ECPs in this basis. n_ecp_core(self: psi4.core.BasisSet, arg0: str) -> int. Returns the number of core electrons associated with any ECP on the specified atom type for this basis set. n_frozen_core(self: psi4.core.BasisSet, arg0: str, arg1: psi4.core.Molecule) → int¶; Returns the number of orbital (non-ECP) frozen core electrons. For a given molecule and FREEZE_CORE, (n_ecp_core()/2 + n_frozen_core()) = constant. name(self: psi4.core.BasisSet) → str¶; Callback handle, may represent string or function. nao(self: psi4.core.BasisSet) → int¶; Returns number of atomic orbitals (Cartesian). nbf(self: psi4.core.BasisSet) → int¶; Returns number of basis functions (Cartesian or spherical depending on has_puream). nprimitive(self: psi4.core.BasisSet) → int¶; Returns total number of primitives in all contractions. nshell(self: psi4.core.BasisSet) → int¶; Returns number of shells. nshell_on_center(self: psi4.core.BasisSet, i: int) → int¶; Return the number of shells on a given center. print_detail_out(self: psi4.core.BasisSet) → None¶; Prints detailed basis set info to outfile. print_out(self: psi4.core.BasisSet) → None¶; Prints basis set info to outfile. shell(*args, **kwargs)¶; Overloaded function. shell(self: psi4.core.BasisSet, si: int) -> psi4.core.GaussianShell. Return the si’th Gaussian shell. shell(self: psi4.core.BasisSet, center: int, si: int) -> psi4.core.GaussianShell. Return the si’th Gaussian shell on center. shell_to_ao_function(self: psi4.core.BasisSet, i: int) → int¶; Return the function number for the first function for the i’th shell. shell_to_basis_function(self: psi4.core.BasisSet, i: int) → int¶; Given a shell return its first basis function. shell_to_center(self: psi4.core.BasisSet, i: int) → int¶; Return the atomic center for the i’th s",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:6725,Integrability,contract,contraction,6725,"¶; Return the number of shells on a given center. print_detail_out(self: psi4.core.BasisSet) → None¶; Prints detailed basis set info to outfile. print_out(self: psi4.core.BasisSet) → None¶; Prints basis set info to outfile. shell(*args, **kwargs)¶; Overloaded function. shell(self: psi4.core.BasisSet, si: int) -> psi4.core.GaussianShell. Return the si’th Gaussian shell. shell(self: psi4.core.BasisSet, center: int, si: int) -> psi4.core.GaussianShell. Return the si’th Gaussian shell on center. shell_to_ao_function(self: psi4.core.BasisSet, i: int) → int¶; Return the function number for the first function for the i’th shell. shell_to_basis_function(self: psi4.core.BasisSet, i: int) → int¶; Given a shell return its first basis function. shell_to_center(self: psi4.core.BasisSet, i: int) → int¶; Return the atomic center for the i’th shell. zero_ao_basis_set() → psi4.core.BasisSet¶; Returns a BasisSet object that actually has a single s-function at the origin with an exponent of 0.0 and contraction of 1.0. class psi4.core.BlockOPoints¶; Bases: pybind11_builtins.pybind11_object; docstring. functions_local_to_global(self: psi4.core.BlockOPoints) → List[int]¶; docstring. npoints(self: psi4.core.BlockOPoints) → int¶; docstring. print_out(self: psi4.core.BlockOPoints, out_fname: str='outfile', print: int=2) → None¶; docstring. refresh(self: psi4.core.BlockOPoints) → None¶; docstring. shells_local_to_global(self: psi4.core.BlockOPoints) → List[int]¶; docstring. w(self: psi4.core.BlockOPoints) → psi4.core.Vector¶. x(self: psi4.core.BlockOPoints) → psi4.core.Vector¶. y(self: psi4.core.BlockOPoints) → psi4.core.Vector¶. z(self: psi4.core.BlockOPoints) → psi4.core.Vector¶. class psi4.core.BoysLocalizer¶; Bases: psi4.core.Localizer; Performs Boys orbital localization. L¶; Localized orbital coefficients. U¶; Orbital rotation matrix. build(arg0: str, arg1: psi4.core.BasisSet, arg2: psi4.core.Matrix) → psi4.core.Localizer¶; Build the localization scheme. converged¶; Did the localization ",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:67651,Integrability,contract,contraction,67651,"onal, arg0: int) → None¶; docstring. print_out(self: psi4.core.Functional) → None¶; docstring. set_alpha(self: psi4.core.Functional, arg0: float) → None¶; docstring. set_citation(self: psi4.core.Functional, arg0: str) → None¶; docstring. set_description(self: psi4.core.Functional, arg0: str) → None¶; docstring. set_gga(self: psi4.core.Functional, arg0: bool) → None¶; docstring. set_lsda_cutoff(self: psi4.core.Functional, arg0: float) → None¶; docstring. set_meta(self: psi4.core.Functional, arg0: bool) → None¶; docstring. set_meta_cutoff(self: psi4.core.Functional, arg0: float) → None¶; docstring. set_name(self: psi4.core.Functional, arg0: str) → None¶; docstring. set_omega(self: psi4.core.Functional, arg0: float) → None¶; docstring. set_parameter(self: psi4.core.Functional, arg0: str, arg1: float) → None¶; docstring. class psi4.core.GaussianShell¶; Bases: pybind11_builtins.pybind11_object; Class containing information about basis functions. AMCHAR¶; The upper-case character symbol for the angular momentum of the given contraction. am¶; The angular momentum of the given contraction. amchar¶; The character symbol for the angular momentum of the given contraction. coef(self: psi4.core.GaussianShell, pi: int) → float¶; Return coefficient of the pi’th primitive. erd_coef(self: psi4.core.GaussianShell, pi: int) → float¶; Return ERD normalized coefficient of pi’th primitive. exp(self: psi4.core.GaussianShell, prim: int) → float¶; Returns the exponent of the given primitive. function_index¶; Basis function index where this shell starts. is_cartesian(self: psi4.core.GaussianShell) → bool¶; Returns true if the contraction is Cartesian. is_pure(self: psi4.core.GaussianShell) → bool¶; Returns true if the contraction is pure, i.e. a spherical harmonic basis function. ncartesian¶; Total number of basis functions if this shell was Cartesian. ncenter¶; Returns atom number this shell is on. nfunction¶; Total number of basis functions. nprimitive¶; The number of primitive gaussians. ",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:67703,Integrability,contract,contraction,67703,"l) → None¶; docstring. set_alpha(self: psi4.core.Functional, arg0: float) → None¶; docstring. set_citation(self: psi4.core.Functional, arg0: str) → None¶; docstring. set_description(self: psi4.core.Functional, arg0: str) → None¶; docstring. set_gga(self: psi4.core.Functional, arg0: bool) → None¶; docstring. set_lsda_cutoff(self: psi4.core.Functional, arg0: float) → None¶; docstring. set_meta(self: psi4.core.Functional, arg0: bool) → None¶; docstring. set_meta_cutoff(self: psi4.core.Functional, arg0: float) → None¶; docstring. set_name(self: psi4.core.Functional, arg0: str) → None¶; docstring. set_omega(self: psi4.core.Functional, arg0: float) → None¶; docstring. set_parameter(self: psi4.core.Functional, arg0: str, arg1: float) → None¶; docstring. class psi4.core.GaussianShell¶; Bases: pybind11_builtins.pybind11_object; Class containing information about basis functions. AMCHAR¶; The upper-case character symbol for the angular momentum of the given contraction. am¶; The angular momentum of the given contraction. amchar¶; The character symbol for the angular momentum of the given contraction. coef(self: psi4.core.GaussianShell, pi: int) → float¶; Return coefficient of the pi’th primitive. erd_coef(self: psi4.core.GaussianShell, pi: int) → float¶; Return ERD normalized coefficient of pi’th primitive. exp(self: psi4.core.GaussianShell, prim: int) → float¶; Returns the exponent of the given primitive. function_index¶; Basis function index where this shell starts. is_cartesian(self: psi4.core.GaussianShell) → bool¶; Returns true if the contraction is Cartesian. is_pure(self: psi4.core.GaussianShell) → bool¶; Returns true if the contraction is pure, i.e. a spherical harmonic basis function. ncartesian¶; Total number of basis functions if this shell was Cartesian. ncenter¶; Returns atom number this shell is on. nfunction¶; Total number of basis functions. nprimitive¶; The number of primitive gaussians. original_coef(self: psi4.core.GaussianShell, pi: int) → float¶; Return u",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:67784,Integrability,contract,contraction,67784," float) → None¶; docstring. set_citation(self: psi4.core.Functional, arg0: str) → None¶; docstring. set_description(self: psi4.core.Functional, arg0: str) → None¶; docstring. set_gga(self: psi4.core.Functional, arg0: bool) → None¶; docstring. set_lsda_cutoff(self: psi4.core.Functional, arg0: float) → None¶; docstring. set_meta(self: psi4.core.Functional, arg0: bool) → None¶; docstring. set_meta_cutoff(self: psi4.core.Functional, arg0: float) → None¶; docstring. set_name(self: psi4.core.Functional, arg0: str) → None¶; docstring. set_omega(self: psi4.core.Functional, arg0: float) → None¶; docstring. set_parameter(self: psi4.core.Functional, arg0: str, arg1: float) → None¶; docstring. class psi4.core.GaussianShell¶; Bases: pybind11_builtins.pybind11_object; Class containing information about basis functions. AMCHAR¶; The upper-case character symbol for the angular momentum of the given contraction. am¶; The angular momentum of the given contraction. amchar¶; The character symbol for the angular momentum of the given contraction. coef(self: psi4.core.GaussianShell, pi: int) → float¶; Return coefficient of the pi’th primitive. erd_coef(self: psi4.core.GaussianShell, pi: int) → float¶; Return ERD normalized coefficient of pi’th primitive. exp(self: psi4.core.GaussianShell, prim: int) → float¶; Returns the exponent of the given primitive. function_index¶; Basis function index where this shell starts. is_cartesian(self: psi4.core.GaussianShell) → bool¶; Returns true if the contraction is Cartesian. is_pure(self: psi4.core.GaussianShell) → bool¶; Returns true if the contraction is pure, i.e. a spherical harmonic basis function. ncartesian¶; Total number of basis functions if this shell was Cartesian. ncenter¶; Returns atom number this shell is on. nfunction¶; Total number of basis functions. nprimitive¶; The number of primitive gaussians. original_coef(self: psi4.core.GaussianShell, pi: int) → float¶; Return unnormalized coefficient of the pi’th primitive. class psi4.core.Gau",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:68245,Integrability,contract,contraction,68245," psi4.core.Functional, arg0: str) → None¶; docstring. set_omega(self: psi4.core.Functional, arg0: float) → None¶; docstring. set_parameter(self: psi4.core.Functional, arg0: str, arg1: float) → None¶; docstring. class psi4.core.GaussianShell¶; Bases: pybind11_builtins.pybind11_object; Class containing information about basis functions. AMCHAR¶; The upper-case character symbol for the angular momentum of the given contraction. am¶; The angular momentum of the given contraction. amchar¶; The character symbol for the angular momentum of the given contraction. coef(self: psi4.core.GaussianShell, pi: int) → float¶; Return coefficient of the pi’th primitive. erd_coef(self: psi4.core.GaussianShell, pi: int) → float¶; Return ERD normalized coefficient of pi’th primitive. exp(self: psi4.core.GaussianShell, prim: int) → float¶; Returns the exponent of the given primitive. function_index¶; Basis function index where this shell starts. is_cartesian(self: psi4.core.GaussianShell) → bool¶; Returns true if the contraction is Cartesian. is_pure(self: psi4.core.GaussianShell) → bool¶; Returns true if the contraction is pure, i.e. a spherical harmonic basis function. ncartesian¶; Total number of basis functions if this shell was Cartesian. ncenter¶; Returns atom number this shell is on. nfunction¶; Total number of basis functions. nprimitive¶; The number of primitive gaussians. original_coef(self: psi4.core.GaussianShell, pi: int) → float¶; Return unnormalized coefficient of the pi’th primitive. class psi4.core.GaussianType¶; Bases: pybind11_builtins.pybind11_object; 0 if Cartesian, 1 if Pure. Cartesian = GaussianType.Cartesian¶. Pure = GaussianType.Pure¶. class psi4.core.GeometryUnits¶; Bases: pybind11_builtins.pybind11_object; The units used to define the geometry. Angstrom = GeometryUnits.Angstrom¶. Bohr = GeometryUnits.Bohr¶. class psi4.core.HF¶; Bases: psi4.core.Wavefunction; docstring. Ca(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Alpha Orbitals. Ca_subset(sel",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:68339,Integrability,contract,contraction,68339,"rg0: float) → None¶; docstring. set_parameter(self: psi4.core.Functional, arg0: str, arg1: float) → None¶; docstring. class psi4.core.GaussianShell¶; Bases: pybind11_builtins.pybind11_object; Class containing information about basis functions. AMCHAR¶; The upper-case character symbol for the angular momentum of the given contraction. am¶; The angular momentum of the given contraction. amchar¶; The character symbol for the angular momentum of the given contraction. coef(self: psi4.core.GaussianShell, pi: int) → float¶; Return coefficient of the pi’th primitive. erd_coef(self: psi4.core.GaussianShell, pi: int) → float¶; Return ERD normalized coefficient of pi’th primitive. exp(self: psi4.core.GaussianShell, prim: int) → float¶; Returns the exponent of the given primitive. function_index¶; Basis function index where this shell starts. is_cartesian(self: psi4.core.GaussianShell) → bool¶; Returns true if the contraction is Cartesian. is_pure(self: psi4.core.GaussianShell) → bool¶; Returns true if the contraction is pure, i.e. a spherical harmonic basis function. ncartesian¶; Total number of basis functions if this shell was Cartesian. ncenter¶; Returns atom number this shell is on. nfunction¶; Total number of basis functions. nprimitive¶; The number of primitive gaussians. original_coef(self: psi4.core.GaussianShell, pi: int) → float¶; Return unnormalized coefficient of the pi’th primitive. class psi4.core.GaussianType¶; Bases: pybind11_builtins.pybind11_object; 0 if Cartesian, 1 if Pure. Cartesian = GaussianType.Cartesian¶. Pure = GaussianType.Pure¶. class psi4.core.GeometryUnits¶; Bases: pybind11_builtins.pybind11_object; The units used to define the geometry. Angstrom = GeometryUnits.Angstrom¶. Bohr = GeometryUnits.Bohr¶. class psi4.core.HF¶; Bases: psi4.core.Wavefunction; docstring. Ca(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Alpha Orbitals. Ca_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Matrix¶; Returns the requested A",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:82983,Integrability,protocol,protocol,82983,"e table of contents for the given unit. tocwrite(self: psi4.core.IO, arg0: int) → None¶; Write the table of contents for passed file number. class psi4.core.IOManager¶; Bases: pybind11_builtins.pybind11_object; PSIOManager is a class designed to be used as a static object to track all PSIO operations in a given PSI4 computation. crashclean(self: psi4.core.IOManager) → None¶; Clean from disk-mirrored image after crash. NOT to be called during regular computation. get_default_path(self: psi4.core.IOManager) → str¶; Return the default path. get_file_path(self: psi4.core.IOManager, fileno: int) → str¶; Get the path for a specific file number. mark_file_for_retention(self: psi4.core.IOManager, full_path: str, retain: bool) → None¶; Mark a file to be retained after a psiclean operation, ie for use in a later computation. print_out(self: psi4.core.IOManager) → None¶; Print the current status of PSI4 files. psiclean(self: psi4.core.IOManager) → None¶; Execute the psiclean protocol, deleting all recorded files, except those currently marked for retention. set_default_path(self: psi4.core.IOManager, path: str) → None¶; Set the default path for files to be stored. set_specific_path(self: psi4.core.IOManager, fileno: int, path: str) → None¶; Set the path for specific file numbers. set_specific_retention(self: psi4.core.IOManager, fileno: int, retain: bool) → None¶; Set the specific file number to be retained. shared_object() → psi4.core.IOManager¶; The one and (should be) only instance of PSIOManager for a PSI4 instance. write_scratch_file(self: psi4.core.IOManager, full_path: str, text: str) → None¶; Write a string to a temporary file. The scratch file is opened and closed by this function. class psi4.core.IntVector¶; Bases: pybind11_builtins.pybind11_object; Class handling vectors with integer values. dim(self: psi4.core.IntVector, h: int) → int¶; Returns the number of dimensions per irrep h. get(self: psi4.core.IntVector, h: int, m: int) → int¶; Returns a single element valu",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:109644,Integrability,depend,depending,109644,"pe¶; Shape of the Psi4 data object. subtract(self: psi4.core.Matrix, arg0: psi4.core.Matrix) → None¶; Substract a matrix from this matrix. sum_of_squares(self: psi4.core.Matrix) → float¶; Returns the sum of the squares of this matrix. symmetrize_gradient(self: psi4.core.Matrix, mol: psi::Molecule) → None¶; Symmetrizes a gradient-like matrix (N,3) using information from a given molecule. symmetry(self: psi4.core.Matrix) → int¶; Returns the overall symmetry of the matrix. to_array(copy=True, dense=False)¶; Converts a Psi4 Matrix or Vector to a numpy array. Either copies the data or simply; constructs a view. Parameters:; matrix (Matrix or Vector) – Pointers to which Psi4 core class should be used in the construction.; copy (bool, optional) – Copy the data if True, return a view otherwise; dense (bool, optional) – Converts irreped Psi4 objects to diagonally blocked dense arrays if True. Returns a list of arrays otherwise. Returns:array – Returns either a list of np.array’s or the base array depending on options. Return type:ndarray or list of ndarray. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; 1; 2; 3; 4; 5>>> data = psi4.Matrix(3, 3); >>> data.to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. to_serial()¶; Converts an object with a .nph accessor to a serialized dictionary. trace(self: psi4.core.Matrix) → float¶; Returns the trace of the matrix. transform(*args, **kwargs)¶; Overloaded function. transform(self: psi4.core.Matrix, transformer: psi4.core.Matrix) -> None. Transform this matrix with transformer. transform(self: psi4.core.Matrix, a: psi4.core.Matrix, transformer: psi4.core.Matrix) -> None. Transform A with transformer. transpose(self: psi4.core.Matrix) → psi4.core.Matrix¶; Creates a new matrix that is the transpose of this matrix. transpose_this(self: psi4.core.Matrix) → None¶; Transpose the matrix in-place. triplet(A: psi4.core.Matrix, B: psi4.core.Matrix, C: psi4.core.Matrix, transA: bool=False, transB: bool",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:131987,Integrability,wrap,wrapper,131987,"n override this with the symmetry keyword. fix_com(self: psi4.core.Molecule, arg0: bool) → None¶; Whether to fix the Cartesian position, or to translate to the C.O.M. fix_orientation(self: psi4.core.Molecule, arg0: bool) → None¶; Fix the orientation at its current frame. form_symmetry_information(self: psi4.core.Molecule, arg0: float) → None¶; Uses the point group object obtain by calling point_group(). classmethod from_arrays(geom=None, elea=None, elez=None, elem=None, mass=None, real=None, elbl=None, name=None, units='Angstrom', input_units_to_au=None, fix_com=None, fix_orientation=None, fix_symmetry=None, fragment_separators=None, fragment_charges=None, fragment_multiplicities=None, molecular_charge=None, molecular_multiplicity=None, missing_enabled_return='error', tooclose=0.1, zero_ghost_fragments=False, nonphysical=False, mtol=0.001, verbose=1, return_dict=False)¶; Construct Molecule from unvalidated arrays and variables.; Light wrapper around from_arrays(); that is a full-featured constructor to dictionary representa-; tion of Molecule. This follows one step further to return; Molecule instance.; :param See from_arrays().:. Returns:. Return type:psi4.core.Molecule. from_dict(arg0: dict) → psi4.core.Molecule¶; Returns a new Molecule constructed from python dictionary. In progress: name and capabilities should not be relied upon. classmethod from_schema(molschema, return_dict=False, verbose=1)¶; Construct Molecule from non-Psi4 schema.; Light wrapper around from_arrays(). Parameters:; molschema (dict) – Dictionary form of Molecule following known schema.; return_dict (bool, optional) – Additionally return Molecule dictionary intermediate.; verbose (int, optional) – Amount of printing. Returns:; mol (psi4.core.Molecule); molrec (dict, optional) – Dictionary representation of instance.; Only provided if return_dict is True. classmethod from_string(molstr, dtype=None, name=None, fix_com=None, fix_orientation=None, fix_symmetry=None, return_dict=False, enable_qm=Tr",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:132510,Integrability,wrap,wrapper,132510,"ne, real=None, elbl=None, name=None, units='Angstrom', input_units_to_au=None, fix_com=None, fix_orientation=None, fix_symmetry=None, fragment_separators=None, fragment_charges=None, fragment_multiplicities=None, molecular_charge=None, molecular_multiplicity=None, missing_enabled_return='error', tooclose=0.1, zero_ghost_fragments=False, nonphysical=False, mtol=0.001, verbose=1, return_dict=False)¶; Construct Molecule from unvalidated arrays and variables.; Light wrapper around from_arrays(); that is a full-featured constructor to dictionary representa-; tion of Molecule. This follows one step further to return; Molecule instance.; :param See from_arrays().:. Returns:. Return type:psi4.core.Molecule. from_dict(arg0: dict) → psi4.core.Molecule¶; Returns a new Molecule constructed from python dictionary. In progress: name and capabilities should not be relied upon. classmethod from_schema(molschema, return_dict=False, verbose=1)¶; Construct Molecule from non-Psi4 schema.; Light wrapper around from_arrays(). Parameters:; molschema (dict) – Dictionary form of Molecule following known schema.; return_dict (bool, optional) – Additionally return Molecule dictionary intermediate.; verbose (int, optional) – Amount of printing. Returns:; mol (psi4.core.Molecule); molrec (dict, optional) – Dictionary representation of instance.; Only provided if return_dict is True. classmethod from_string(molstr, dtype=None, name=None, fix_com=None, fix_orientation=None, fix_symmetry=None, return_dict=False, enable_qm=True, enable_efp=True, missing_enabled_return_qm='none', missing_enabled_return_efp='none', verbose=1)¶. fx(self: psi4.core.Molecule, arg0: int) → float¶; x position of atom arg1 (0-indexed including dummies in Bohr). fy(self: psi4.core.Molecule, arg0: int) → float¶; y position of atom arg1 (0-indexed including dummies in Bohr). fz(self: psi4.core.Molecule, arg0: int) → float¶; z position of atom arg1 (0-indexed including dummies in Bohr). geometry(self: psi4.core.Molecule) → psi4",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:141638,Integrability,interface,interface,141638,"; * output goes to output file; * gradient returned as psi4.core.Matrix, not list o’lists; * scratch is written to randomly named subdirectory of psi scratch; * psivar “DISPERSION CORRECTION ENERGY” is set; * verbose triggered when PRINT keywork of SCF module >=3. run_gcp(func=None, dertype=None, verbose=False)¶; Function to call Grimme’s dftd3 program (http://toc.uni-muenster.de/DFTD3/); to compute the -D correction of level dashlvl using parameters for; the functional func. The dictionary dashparam can be used to supply; a full set of dispersion parameters in the absense of func or to supply; individual overrides in the presence of func. Returns energy if dertype is 0,; gradient if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The dftd3 executable must be independently compiled and found in; PATH or PSIPATH.; self may be either a qcdb.Molecule (sensibly) or a psi4.Molecule; (works b/c psi4.Molecule has been extended by this method py-side and; only public interface fns used) or a string that can be instantiated; into a qcdb.Molecule. save_string_xyz(self: psi4.core.Molecule) → str¶; Saves the string of an XYZ file to arg2. save_string_xyz_file(self: psi4.core.Molecule) → str¶; Saves an XYZ file to arg2. save_xyz_file(self: psi4.core.Molecule, arg0: str, arg1: bool) → None¶; Saves an XYZ file to arg2. schoenflies_symbol(self: psi4.core.Molecule) → str¶; Returns the Schoenflies symbol. scramble(do_shift=True, do_rotate=True, do_resort=True, deflection=1.0, do_mirror=False, do_plot=False, run_to_completion=False, run_resorting=False, verbose=1)¶; Tester for B787 by shifting, rotating, and atom shuffling ref_mol and; checking that the aligner returns the opposite transformation. Parameters:; ref_mol (qcdb.Molecule or psi4.core.Molecule) – Molecule to perturb.; do_shift (bool or array-like, optional) – Whether to generate a random atom shift on interval [-3, 3) in each; dimension (True) or leave at current origin. To shift by a specified; vect",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:153530,Integrability,depend,dependencies,153530,"arg1: str, arg2: str) → None¶; set string option. set_str_i(self: psi4.core.Options, arg0: str, arg1: str, arg2: str) → None¶; set string option. validate_options(self: psi4.core.Options) → None¶; validate options for arg0 module. class psi4.core.OrbitalSpace¶; Bases: pybind11_builtins.pybind11_object; Contains information about the orbitals. C(self: psi4.core.OrbitalSpace) → psi4.core.Matrix¶; MO coefficient matrix, AO->MO or SO->MO transformation matrix. basisset(self: psi4.core.OrbitalSpace) → psi::BasisSet¶; The AO basis set used to create C. build_cabs_space(orb_space: psi4.core.OrbitalSpace, ri_space: psi4.core.OrbitalSpace, linear_tol: float) → psi4.core.OrbitalSpace¶; Given two spaces, it projects out one space from the other and returns the new spaces The first argument (orb_space) is the space to project out. The returned space will be orthogonal to this The second argument (ri_space) is the space that is being projected on. The returned space = this space - orb_space The third argument is the tolerance for linear dependencies. build_ri_space(molecule: psi::Molecule, obs_key: str, aux_key: str, lindep_tol: float) → psi4.core.OrbitalSpace¶; Given two basis sets, it merges the basis sets and then constructs an orthogonalized space with the same span. Linearly dependent orbitals are thrown out. The first argument, molecule, is the molecule to construct the basis for The second argument, obs_key, is the option keyword for orbital basis set ‘BASIS’ The third argument, aux_key, is the option keyword for auxiliery basis set ‘DF_BASIS_MP2’ The fourth argument, lindep_tol, is the tolerance for linear dependencies. dim(self: psi4.core.OrbitalSpace) → psi4.core.Dimension¶; MO dimensions. evals(self: psi4.core.OrbitalSpace) → psi4.core.Vector¶; Corresponding eigenvalues of the C matrix. id(self: psi4.core.OrbitalSpace) → str¶; Unique identifier. integral(self: psi4.core.OrbitalSpace) → psi4.core.IntegralFactory¶; The integral factory used to create C. name(self: psi4.c",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:153778,Integrability,depend,dependent,153778,"ct; Contains information about the orbitals. C(self: psi4.core.OrbitalSpace) → psi4.core.Matrix¶; MO coefficient matrix, AO->MO or SO->MO transformation matrix. basisset(self: psi4.core.OrbitalSpace) → psi::BasisSet¶; The AO basis set used to create C. build_cabs_space(orb_space: psi4.core.OrbitalSpace, ri_space: psi4.core.OrbitalSpace, linear_tol: float) → psi4.core.OrbitalSpace¶; Given two spaces, it projects out one space from the other and returns the new spaces The first argument (orb_space) is the space to project out. The returned space will be orthogonal to this The second argument (ri_space) is the space that is being projected on. The returned space = this space - orb_space The third argument is the tolerance for linear dependencies. build_ri_space(molecule: psi::Molecule, obs_key: str, aux_key: str, lindep_tol: float) → psi4.core.OrbitalSpace¶; Given two basis sets, it merges the basis sets and then constructs an orthogonalized space with the same span. Linearly dependent orbitals are thrown out. The first argument, molecule, is the molecule to construct the basis for The second argument, obs_key, is the option keyword for orbital basis set ‘BASIS’ The third argument, aux_key, is the option keyword for auxiliery basis set ‘DF_BASIS_MP2’ The fourth argument, lindep_tol, is the tolerance for linear dependencies. dim(self: psi4.core.OrbitalSpace) → psi4.core.Dimension¶; MO dimensions. evals(self: psi4.core.OrbitalSpace) → psi4.core.Vector¶; Corresponding eigenvalues of the C matrix. id(self: psi4.core.OrbitalSpace) → str¶; Unique identifier. integral(self: psi4.core.OrbitalSpace) → psi4.core.IntegralFactory¶; The integral factory used to create C. name(self: psi4.core.OrbitalSpace) → str¶; Name of the orbital space. nirrep(self: psi4.core.OrbitalSpace) → int¶; Returns number of irreps. print_out(self: psi4.core.OrbitalSpace) → None¶; Print information about the orbital space to the output file. class psi4.core.OverlapInt¶; Bases: psi4.core.OneBodyAOInt; Comp",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:154119,Integrability,depend,dependencies,154119,"ore.OrbitalSpace) → psi::BasisSet¶; The AO basis set used to create C. build_cabs_space(orb_space: psi4.core.OrbitalSpace, ri_space: psi4.core.OrbitalSpace, linear_tol: float) → psi4.core.OrbitalSpace¶; Given two spaces, it projects out one space from the other and returns the new spaces The first argument (orb_space) is the space to project out. The returned space will be orthogonal to this The second argument (ri_space) is the space that is being projected on. The returned space = this space - orb_space The third argument is the tolerance for linear dependencies. build_ri_space(molecule: psi::Molecule, obs_key: str, aux_key: str, lindep_tol: float) → psi4.core.OrbitalSpace¶; Given two basis sets, it merges the basis sets and then constructs an orthogonalized space with the same span. Linearly dependent orbitals are thrown out. The first argument, molecule, is the molecule to construct the basis for The second argument, obs_key, is the option keyword for orbital basis set ‘BASIS’ The third argument, aux_key, is the option keyword for auxiliery basis set ‘DF_BASIS_MP2’ The fourth argument, lindep_tol, is the tolerance for linear dependencies. dim(self: psi4.core.OrbitalSpace) → psi4.core.Dimension¶; MO dimensions. evals(self: psi4.core.OrbitalSpace) → psi4.core.Vector¶; Corresponding eigenvalues of the C matrix. id(self: psi4.core.OrbitalSpace) → str¶; Unique identifier. integral(self: psi4.core.OrbitalSpace) → psi4.core.IntegralFactory¶; The integral factory used to create C. name(self: psi4.core.OrbitalSpace) → str¶; Name of the orbital space. nirrep(self: psi4.core.OrbitalSpace) → int¶; Returns number of irreps. print_out(self: psi4.core.OrbitalSpace) → None¶; Print information about the orbital space to the output file. class psi4.core.OverlapInt¶; Bases: psi4.core.OneBodyAOInt; Computes overlap integrals. basis¶; The basis set on center one. basis1¶; The basis set on center one. basis2¶; The basis set on center two. compute_shell(self: psi4.core.OneBodyAOInt, a",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:213291,Integrability,depend,depending,213291,"or, sc: float) → None¶; Scales the elements of a vector by sc. set(*args, **kwargs)¶; Overloaded function. set(self: psi4.core.Vector, m: int, val: float) -> None. Sets a single element value located at m. set(self: psi4.core.Vector, h: int, m: int, val: float) -> None. Sets a single element value located at m in irrep h. set_block(self: psi4.core.Vector, slice: psi4.core.Slice, block: psi4.core.Vector) → None¶; Set a vector block. shape¶; Shape of the Psi4 data object. to_array(copy=True, dense=False)¶; Converts a Psi4 Matrix or Vector to a numpy array. Either copies the data or simply; constructs a view. Parameters:; matrix (Matrix or Vector) – Pointers to which Psi4 core class should be used in the construction.; copy (bool, optional) – Copy the data if True, return a view otherwise; dense (bool, optional) – Converts irreped Psi4 objects to diagonally blocked dense arrays if True. Returns a list of arrays otherwise. Returns:array – Returns either a list of np.array’s or the base array depending on options. Return type:ndarray or list of ndarray. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; 1; 2; 3; 4; 5>>> data = psi4.Matrix(3, 3); >>> data.to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. to_serial()¶; Converts an object with a .nph accessor to a serialized dictionary. class psi4.core.Vector3¶; Bases: pybind11_builtins.pybind11_object; Class for vectors of length three, often Cartesian coordinate vectors, and their common operations. cross(self: psi4.core.Vector3, arg0: psi4.core.Vector3) → psi4.core.Vector3¶; Returns cross product of arg1 and arg2. distance(self: psi4.core.Vector3, arg0: psi4.core.Vector3) → float¶; Returns distance between two points represented by arg1 and arg2. dot(self: psi4.core.Vector3, arg0: psi4.core.Vector3) → float¶; Returns dot product of arg1 and arg2. norm(self: psi4.core.Vector3) → float¶; Returns Euclidean norm of arg1. normalize(self: psi4.core.Vector3) → None¶; Returns vector of u",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:263669,Integrability,depend,dependencies,263669,"et the total memory allocation. set_module_options(module, options_dict); Sets Psi4 module options from a module specification and input dictionary. set_options(options_dict); Sets Psi4 global options from an input dictionary. success(label); Function to print a ‘label…PASSED’ line to screen. vibanal_wfn(wfn[, hess, irrep, molecule, …]). write_eigenvalues(eigs, mo_idx); Prepare multi-line string with one-particle eigenvalues to be written to the FCIDUMP file. xml2dict([filename]); Read XML filename into nested OrderedDict-s. Classes¶. CSXError(msg); Error called when CSX generation fails. ConvergenceError(eqn_description, maxit); Error called for problems with converging and iterative method. Dftd3Error(msg). EmpericalDispersion(alias, dtype, **kwargs). ManagedMethodError(circs). OptimizationConvergenceError(…); Error called for problems with geometry optimizer. ParsingError(msg); Error called for problems parsing a text file. PastureRequiredError(option); Error called when the specified value of option requires some module(s) from Psi4Pasture, but could not be imported. PsiException; Error class for Psi. PsiImportError(msg); Error called for problems import python dependencies. QMMM(). Table([rows, row_label_width, …]); Class defining a flexible Table object for storing data. TestComparisonError(msg); Error called when a test case fails due to a failed compare_values() call. ValidationError(msg); Error called for problems with the input file. datetime(year, month, day[, hour[, minute[, …); The year, month and day arguments are required. Class Inheritance Diagram¶. table of contents. PSI4 API: Linking C++ and Python; psi4.core Module; Functions; Classes; Class Inheritance Diagram. psi4.driver Package; Functions; Classes; Class Inheritance Diagram. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:1357,Modifiability,extend,extend,1357,"ng. is_done(self: psi4.core.AOShellCombinationsIterator) → bool¶; docstring. next(self: psi4.core.AOShellCombinationsIterator) → None¶; docstring. p¶; Returns current P index. q¶; Returns current Q index. r¶; Returns current R index. s¶; Returns current S index. class psi4.core.AngularMomentumInt¶; Bases: psi4.core.OneBodyAOInt; Computes angular momentum integrals. basis¶; The basis set on center one. basis1¶; The basis set on center one. basis2¶; The basis set on center two. compute_shell(self: psi4.core.OneBodyAOInt, arg0: int, arg1: int) → None¶; Compute integrals between basis functions in the given shell pair. origin¶; The origin about which the one body ints are being computed. class psi4.core.BSVec¶; Bases: pybind11_builtins.pybind11_object. append(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo) → None¶; Add an item to the end of the list. count(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo) → int¶; Return the number of times x appears in the list. extend(self: List[psi4.core.ShellInfo], L: List[psi4.core.ShellInfo]) → None¶; Extend the list by appending all the items in the given list. insert(self: List[psi4.core.ShellInfo], i: int, x: psi4.core.ShellInfo) → None¶; Insert an item at a given position. pop(*args, **kwargs)¶; Overloaded function. pop(self: List[psi4.core.ShellInfo]) -> psi4.core.ShellInfo. Remove and return the last item. pop(self: List[psi4.core.ShellInfo], i: int) -> psi4.core.ShellInfo. Remove and return the item at index i. remove(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo) → None¶; Remove the first item from the list whose value is x. It is an error if there is no such item. class psi4.core.BasisExtents¶; Bases: pybind11_builtins.pybind11_object; docstring. basis(self: psi4.core.BasisExtents) → psi4.core.BasisSet¶; docstring. delta(self: psi4.core.BasisExtents) → float¶; docstring. maxR(self: psi4.core.BasisExtents) → float¶; docstring. set_delta(self: psi4.core.BasisExtents, arg0: float) → None¶; docstring.",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:15568,Modifiability,variab,variable,15568,"ore.Dimension¶; Returns the number of frozen virtual orbitals per irrep. get_array(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Sets the requested internal array. get_basisset(self: psi4.core.Wavefunction, arg0: str) → psi4.core.BasisSet¶; Returns the requested auxiliary basis. get_dimension(self: psi4.core.CIWavefunction, arg0: str) → psi4.core.Dimension¶; docstring. get_dipole_field_strength(self: psi4.core.Wavefunction) → List[float[3]]¶; Returns a vector of length 3, containing the x,y, and z dipole field strengths. get_opdm(self: psi4.core.CIWavefunction, arg0: int, arg1: int, arg2: str, arg3: bool) → psi4.core.Matrix¶; docstring. get_orbitals(self: psi4.core.CIWavefunction, arg0: str) → psi4.core.Matrix¶; docstring. get_print(self: psi4.core.Wavefunction) → int¶; Get the print level of the Wavefunction. get_tpdm(self: psi4.core.CIWavefunction, arg0: str, arg1: bool) → psi4.core.Matrix¶; docstring. get_variable(self: psi4.core.Wavefunction, arg0: str) → float¶; Returns the requested internal variable. gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunctions gradient. hamiltonian(self: psi4.core.CIWavefunction, arg0: int) → psi4.core.Matrix¶; docstring. hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunctions Hessian. mcscf_object(self: psi4.core.CIWavefunction) → psi4.core.SOMCSCF¶; docstring. mo_extents(self: psi4.core.Wavefunction) → List[psi4.core.Vector]¶; returns the wavefunction’s electronic orbital extents. molecule(self: psi4.core.Wavefunction) → psi4.core.Molecule¶; Returns the Wavefunctions molecule. nalpha(self: psi4.core.Wavefunction) → int¶; Number of Alpha electrons. nalphapi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of alpha orbitals per irrep. name(self: psi4.core.Wavefunction) → str¶; The level of theory this wavefunction corresponds to. nbeta(self: psi4.core.Wavefunction) → int¶; Number of Beta electrons. nbetapi(self: psi4.core.Wavefunction",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:19837,Modifiability,variab,variable,19837,"n, arg0: str) → None¶; docstring. set_external_potential(self: psi4.core.Wavefunction, arg0: psi4.core.ExternalPotential) → None¶; Sets the requested external potential. set_frequencies(self: psi4.core.Wavefunction, arg0: psi4.core.Vector) → None¶; Sets the frequencies of the Hessian. set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunctions gradient. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunctions Hessian. set_name(self: psi4.core.Wavefunction, arg0: str) → None¶; Sets the level of theory this wavefunction corresponds to. set_orbitals(self: psi4.core.CIWavefunction, arg0: str, arg1: psi4.core.Matrix) → None¶; docstring. set_print(self: psi4.core.Wavefunction, arg0: int) → None¶; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; docstring. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sigma(*args, **kwargs)¶; Overloaded function. sigma(self: psi4.core.CIWavefunction, arg0: psi::detci::CIvect, arg1: psi::detci::CIvect, arg2: int, arg3: int) -> None. docstring. sigma(self: psi4.core.CIWavefunction, arg0: psi::detci::CIvect, arg1: psi::detci::CIvect, arg2: int, arg3: int, arg4: psi4.core.Vector, arg5: psi4.core.Vector) -> None. docstring. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. tpdm(self: psi4.core.CIWavefunction, arg0: psi::detci::CIvect, arg1: psi::detci::CIvect, arg2: int, arg3: int) → List[psi4.core.Matrix]¶; docstring. transform_ci_integrals(self: psi4.core.CIWavefunction) → None¶; docstring. transform_mcscf_integrals(sel",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:20865,Modifiability,variab,variables,20865,".Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sigma(*args, **kwargs)¶; Overloaded function. sigma(self: psi4.core.CIWavefunction, arg0: psi::detci::CIvect, arg1: psi::detci::CIvect, arg2: int, arg3: int) -> None. docstring. sigma(self: psi4.core.CIWavefunction, arg0: psi::detci::CIvect, arg1: psi::detci::CIvect, arg2: int, arg3: int, arg4: psi4.core.Vector, arg5: psi4.core.Vector) -> None. docstring. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. tpdm(self: psi4.core.CIWavefunction, arg0: psi::detci::CIvect, arg1: psi::detci::CIvect, arg2: int, arg3: int) → List[psi4.core.Matrix]¶; docstring. transform_ci_integrals(self: psi4.core.CIWavefunction) → None¶; docstring. transform_mcscf_integrals(self: psi4.core.CIWavefunction, arg0: bool) → None¶; docstring. variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the map of all internal variables. class psi4.core.CUHF¶; Bases: psi4.core.HF; docstring. Ca(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Alpha Orbitals. Ca_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Matrix¶; Returns the requested Alpha Orbital subset. Cb(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Beta Orbitals. Cb_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Matrix¶; Returns the requested Beta Orbital subset. Da(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Alpha Density Matrix. Da_subset(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Returns the requested Alpha Density subset. Db(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Beta Density Matrix. Db_subset(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Returns the requested Beta Density subset. Fa(self: psi4.core.Wavefuncti",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:20958,Modifiability,variab,variables,20958,"Copies the pointers to the internal data. sigma(*args, **kwargs)¶; Overloaded function. sigma(self: psi4.core.CIWavefunction, arg0: psi::detci::CIvect, arg1: psi::detci::CIvect, arg2: int, arg3: int) -> None. docstring. sigma(self: psi4.core.CIWavefunction, arg0: psi::detci::CIvect, arg1: psi::detci::CIvect, arg2: int, arg3: int, arg4: psi4.core.Vector, arg5: psi4.core.Vector) -> None. docstring. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. tpdm(self: psi4.core.CIWavefunction, arg0: psi::detci::CIvect, arg1: psi::detci::CIvect, arg2: int, arg3: int) → List[psi4.core.Matrix]¶; docstring. transform_ci_integrals(self: psi4.core.CIWavefunction) → None¶; docstring. transform_mcscf_integrals(self: psi4.core.CIWavefunction, arg0: bool) → None¶; docstring. variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the map of all internal variables. class psi4.core.CUHF¶; Bases: psi4.core.HF; docstring. Ca(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Alpha Orbitals. Ca_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Matrix¶; Returns the requested Alpha Orbital subset. Cb(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Beta Orbitals. Cb_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Matrix¶; Returns the requested Beta Orbital subset. Da(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Alpha Density Matrix. Da_subset(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Returns the requested Alpha Density subset. Db(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Beta Density Matrix. Db_subset(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Returns the requested Beta Density subset. Fa(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Alpha Fock Matrix.",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:27299,Modifiability,variab,variable,27299,"e current Density Matrices. frequencies(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the frequencies of the Hessian. frzcpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of frozen core orbitals per irrep. frzvpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of frozen virtual orbitals per irrep. functional(self: psi4.core.HF) → psi4.core.SuperFunctional¶; Returns the internal DFT Superfunctional. get_array(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Sets the requested internal array. get_basisset(self: psi4.core.Wavefunction, arg0: str) → psi4.core.BasisSet¶; Returns the requested auxiliary basis. get_dipole_field_strength(self: psi4.core.Wavefunction) → List[float[3]]¶; Returns a vector of length 3, containing the x,y, and z dipole field strengths. get_print(self: psi4.core.Wavefunction) → int¶; Get the print level of the Wavefunction. get_variable(self: psi4.core.Wavefunction, arg0: str) → float¶; Returns the requested internal variable. gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunctions gradient. guess_Ca(self: psi4.core.HF, arg0: psi4.core.Matrix) → None¶; Sets the guess Alpha Orbital Matrix. guess_Cb(self: psi4.core.HF, arg0: psi4.core.Matrix) → None¶; Sets the guess Beta Orbital Matrix. hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunctions Hessian. initialize(self: psi4.core.HF) → None¶; Initializes the Wavefunction. iterations(self: psi4.core.HF) → None¶; Iterates the Wavefunction until convergence criteria have been met. jk(self: psi4.core.HF) → psi4.core.JK¶; Returns the internal JK object. mo_extents(self: psi4.core.Wavefunction) → List[psi4.core.Vector]¶; returns the wavefunction’s electronic orbital extents. molecule(self: psi4.core.Wavefunction) → psi4.core.Molecule¶; Returns the Wavefunctions molecule. nalpha(self: psi4.core.Wavefunction) → int¶; Number of Alpha electrons. nalphapi(self: psi4.core.Wavefun",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:31679,Modifiability,variab,variable,31679,"sian. set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunctions gradient. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunctions Hessian. set_jk(self: psi4.core.HF, arg0: psi4.core.JK) → None¶; Sets the internal JK object !expert. set_name(self: psi4.core.Wavefunction, arg0: str) → None¶; Sets the level of theory this wavefunction corresponds to. set_print(self: psi4.core.Wavefunction, arg0: int) → None¶; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; docstring. set_sad_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities density-fitted basisset. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. twoel_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix], arg1: bool, arg2: str) → List[psi4.core.Matrix]¶; Two-electron Hessian-vector products. variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the map of all internal variables. class psi4.core.CdSalcList¶; Bases: pybind11_builtins.pybind11_object; Class for generating symmetry adapted linear combinations of Cartesian displacements. create_matrices(self: psi4.core.CdSalcList, basename: str, factory: psi4.core.MatrixFactory) → List[psi4.core.Matrix]¶; Return a vector of matrices with the SALC symmetries. Dimensions determined by fact",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:32182,Modifiability,variab,variables,32182,"ce_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; docstring. set_sad_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities density-fitted basisset. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. twoel_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix], arg1: bool, arg2: str) → List[psi4.core.Matrix]¶; Two-electron Hessian-vector products. variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the map of all internal variables. class psi4.core.CdSalcList¶; Bases: pybind11_builtins.pybind11_object; Class for generating symmetry adapted linear combinations of Cartesian displacements. create_matrices(self: psi4.core.CdSalcList, basename: str, factory: psi4.core.MatrixFactory) → List[psi4.core.Matrix]¶; Return a vector of matrices with the SALC symmetries. Dimensions determined by factory. matrix(self: psi4.core.CdSalcList) → psi4.core.Matrix¶; Return the SALCs. matrix_irrep(self: psi4.core.CdSalcList, h: int) → psi4.core.Matrix¶; Return only the SALCS in irrep h. ncd(self: psi4.core.CdSalcList) → int¶; Return the number of cartesian displacements SALCs. print_out(self: psi4.core.CdSalcList) → None¶; Print the SALC to the output file. salc_name(self: psi4.core.CdSalcList, i: int) → str¶; Return the name of SALC #i. class psi4.core.CorrelationFactor¶; Bases: pybind11_builtins.pybind11_object; docstring. set_params(self: p",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:32275,Modifiability,variab,variables,32275,"i4.core.Wavefunction) → None¶; docstring. set_sad_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities density-fitted basisset. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. twoel_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix], arg1: bool, arg2: str) → List[psi4.core.Matrix]¶; Two-electron Hessian-vector products. variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the map of all internal variables. class psi4.core.CdSalcList¶; Bases: pybind11_builtins.pybind11_object; Class for generating symmetry adapted linear combinations of Cartesian displacements. create_matrices(self: psi4.core.CdSalcList, basename: str, factory: psi4.core.MatrixFactory) → List[psi4.core.Matrix]¶; Return a vector of matrices with the SALC symmetries. Dimensions determined by factory. matrix(self: psi4.core.CdSalcList) → psi4.core.Matrix¶; Return the SALCs. matrix_irrep(self: psi4.core.CdSalcList, h: int) → psi4.core.Matrix¶; Return only the SALCS in irrep h. ncd(self: psi4.core.CdSalcList) → int¶; Return the number of cartesian displacements SALCs. print_out(self: psi4.core.CdSalcList) → None¶; Print the SALC to the output file. salc_name(self: psi4.core.CdSalcList, i: int) → str¶; Return the name of SALC #i. class psi4.core.CorrelationFactor¶; Bases: pybind11_builtins.pybind11_object; docstring. set_params(self: psi4.core.CorrelationFactor, coeff: psi4.core.Vector, ex",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:32387,Modifiability,adapt,adapted,32387,"f Atomic Densities basisset. set_sad_fitting_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities density-fitted basisset. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. twoel_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix], arg1: bool, arg2: str) → List[psi4.core.Matrix]¶; Two-electron Hessian-vector products. variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the map of all internal variables. class psi4.core.CdSalcList¶; Bases: pybind11_builtins.pybind11_object; Class for generating symmetry adapted linear combinations of Cartesian displacements. create_matrices(self: psi4.core.CdSalcList, basename: str, factory: psi4.core.MatrixFactory) → List[psi4.core.Matrix]¶; Return a vector of matrices with the SALC symmetries. Dimensions determined by factory. matrix(self: psi4.core.CdSalcList) → psi4.core.Matrix¶; Return the SALCs. matrix_irrep(self: psi4.core.CdSalcList, h: int) → psi4.core.Matrix¶; Return only the SALCS in irrep h. ncd(self: psi4.core.CdSalcList) → int¶; Return the number of cartesian displacements SALCs. print_out(self: psi4.core.CdSalcList) → None¶; Print the SALC to the output file. salc_name(self: psi4.core.CdSalcList, i: int) → str¶; Return the name of SALC #i. class psi4.core.CorrelationFactor¶; Bases: pybind11_builtins.pybind11_object; docstring. set_params(self: psi4.core.CorrelationFactor, coeff: psi4.core.Vector, exponent: psi4.core.Vector) → None¶; Set coefficient and exponent. class psi4.core.CorrelationTable¶; Bases: pybind11_builtins.pybind11_object; Pr",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:40284,Modifiability,variab,variable,40284,"of singly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. frequencies(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the frequencies of the Hessian. frzcpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of frozen core orbitals per irrep. frzvpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of frozen virtual orbitals per irrep. get_array(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Sets the requested internal array. get_basisset(self: psi4.core.Wavefunction, arg0: str) → psi4.core.BasisSet¶; Returns the requested auxiliary basis. get_dipole_field_strength(self: psi4.core.Wavefunction) → List[float[3]]¶; Returns a vector of length 3, containing the x,y, and z dipole field strengths. get_print(self: psi4.core.Wavefunction) → int¶; Get the print level of the Wavefunction. get_variable(self: psi4.core.Wavefunction, arg0: str) → float¶; Returns the requested internal variable. gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunctions gradient. hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunctions Hessian. mo_extents(self: psi4.core.Wavefunction) → List[psi4.core.Vector]¶; returns the wavefunction’s electronic orbital extents. molecule(self: psi4.core.Wavefunction) → psi4.core.Molecule¶; Returns the Wavefunctions molecule. nalpha(self: psi4.core.Wavefunction) → int¶; Number of Alpha electrons. nalphapi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of alpha orbitals per irrep. name(self: psi4.core.Wavefunction) → str¶; The level of theory this wavefunction corresponds to. nbeta(self: psi4.core.Wavefunction) → int¶; Number of Beta electrons. nbetapi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of beta orbitals per irrep. nfrzc(self: psi4.core.Wavefunction) → int¶; Number of frozen core electrons. nirrep(self: ps",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:43313,Modifiability,variab,variable,43313,"l array. set_basisset(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.BasisSet) → None¶; Sets the requested auxiliary basis. set_external_potential(self: psi4.core.Wavefunction, arg0: psi4.core.ExternalPotential) → None¶; Sets the requested external potential. set_frequencies(self: psi4.core.Wavefunction, arg0: psi4.core.Vector) → None¶; Sets the frequencies of the Hessian. set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunctions gradient. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunctions Hessian. set_name(self: psi4.core.Wavefunction, arg0: str) → None¶; Sets the level of theory this wavefunction corresponds to. set_print(self: psi4.core.Wavefunction, arg0: int) → None¶; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; docstring. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the map of all internal variables. class psi4.core.DFHelper¶; Bases: pybind11_builtins.pybind11_object; docstring. add_space(self: psi4.core.DFHelper, arg0: str, arg1: psi4.core.Matrix) → None¶. add_transformation(self: psi4.core.DFHelper, name: str, key1: str, key2: str, order: str='Qpq') → None¶. clear_all(self: psi4.core.DFHelper) → None¶. clear_spaces(self: psi4.core.DFHelper) → None¶. get_AO_core(self: psi4.core.DFHelper) → bool¶. get_AO_size(self: psi4.core.DFHelper) → int¶. get_MO_core(self: psi4.core.DFHelper) → bool¶. get_memor",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:43669,Modifiability,variab,variables,43669,"self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunctions gradient. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunctions Hessian. set_name(self: psi4.core.Wavefunction, arg0: str) → None¶; Sets the level of theory this wavefunction corresponds to. set_print(self: psi4.core.Wavefunction, arg0: int) → None¶; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; docstring. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the map of all internal variables. class psi4.core.DFHelper¶; Bases: pybind11_builtins.pybind11_object; docstring. add_space(self: psi4.core.DFHelper, arg0: str, arg1: psi4.core.Matrix) → None¶. add_transformation(self: psi4.core.DFHelper, name: str, key1: str, key2: str, order: str='Qpq') → None¶. clear_all(self: psi4.core.DFHelper) → None¶. clear_spaces(self: psi4.core.DFHelper) → None¶. get_AO_core(self: psi4.core.DFHelper) → bool¶. get_AO_size(self: psi4.core.DFHelper) → int¶. get_MO_core(self: psi4.core.DFHelper) → bool¶. get_memory(self: psi4.core.DFHelper) → int¶. get_method(self: psi4.core.DFHelper) → str¶. get_schwarz_cutoff(self: psi4.core.DFHelper) → float¶. get_space_size(self: psi4.core.DFHelper, arg0: str) → int¶. get_tensor(*args, **kwargs)¶; Overloaded function. get_tensor(self: psi4.core.DFHelper, arg0: str) -> psi4.core.Matrix; get_tensor(self: psi4.core.DFHelper, arg0: str, arg1: List[int], arg2: List[int], a",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:43762,Modifiability,variab,variables,43762,"→ None¶; Sets the Wavefunctions gradient. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunctions Hessian. set_name(self: psi4.core.Wavefunction, arg0: str) → None¶; Sets the level of theory this wavefunction corresponds to. set_print(self: psi4.core.Wavefunction, arg0: int) → None¶; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; docstring. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the map of all internal variables. class psi4.core.DFHelper¶; Bases: pybind11_builtins.pybind11_object; docstring. add_space(self: psi4.core.DFHelper, arg0: str, arg1: psi4.core.Matrix) → None¶. add_transformation(self: psi4.core.DFHelper, name: str, key1: str, key2: str, order: str='Qpq') → None¶. clear_all(self: psi4.core.DFHelper) → None¶. clear_spaces(self: psi4.core.DFHelper) → None¶. get_AO_core(self: psi4.core.DFHelper) → bool¶. get_AO_size(self: psi4.core.DFHelper) → int¶. get_MO_core(self: psi4.core.DFHelper) → bool¶. get_memory(self: psi4.core.DFHelper) → int¶. get_method(self: psi4.core.DFHelper) → str¶. get_schwarz_cutoff(self: psi4.core.DFHelper) → float¶. get_space_size(self: psi4.core.DFHelper, arg0: str) → int¶. get_tensor(*args, **kwargs)¶; Overloaded function. get_tensor(self: psi4.core.DFHelper, arg0: str) -> psi4.core.Matrix; get_tensor(self: psi4.core.DFHelper, arg0: str, arg1: List[int], arg2: List[int], arg3: List[int]) -> psi4.core.Matrix. get_tensor_shape(s",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:75433,Modifiability,variab,variable,75433,"e current Density Matrices. frequencies(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the frequencies of the Hessian. frzcpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of frozen core orbitals per irrep. frzvpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of frozen virtual orbitals per irrep. functional(self: psi4.core.HF) → psi4.core.SuperFunctional¶; Returns the internal DFT Superfunctional. get_array(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Sets the requested internal array. get_basisset(self: psi4.core.Wavefunction, arg0: str) → psi4.core.BasisSet¶; Returns the requested auxiliary basis. get_dipole_field_strength(self: psi4.core.Wavefunction) → List[float[3]]¶; Returns a vector of length 3, containing the x,y, and z dipole field strengths. get_print(self: psi4.core.Wavefunction) → int¶; Get the print level of the Wavefunction. get_variable(self: psi4.core.Wavefunction, arg0: str) → float¶; Returns the requested internal variable. gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunctions gradient. guess_Ca(self: psi4.core.HF, arg0: psi4.core.Matrix) → None¶; Sets the guess Alpha Orbital Matrix. guess_Cb(self: psi4.core.HF, arg0: psi4.core.Matrix) → None¶; Sets the guess Beta Orbital Matrix. hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunctions Hessian. initialize(self: psi4.core.HF) → None¶; Initializes the Wavefunction. iterations(self: psi4.core.HF) → None¶; Iterates the Wavefunction until convergence criteria have been met. jk(self: psi4.core.HF) → psi4.core.JK¶; Returns the internal JK object. mo_extents(self: psi4.core.Wavefunction) → List[psi4.core.Vector]¶; returns the wavefunction’s electronic orbital extents. molecule(self: psi4.core.Wavefunction) → psi4.core.Molecule¶; Returns the Wavefunctions molecule. nalpha(self: psi4.core.Wavefunction) → int¶; Number of Alpha electrons. nalphapi(self: psi4.core.Wavefun",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:79813,Modifiability,variab,variable,79813,"sian. set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunctions gradient. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunctions Hessian. set_jk(self: psi4.core.HF, arg0: psi4.core.JK) → None¶; Sets the internal JK object !expert. set_name(self: psi4.core.Wavefunction, arg0: str) → None¶; Sets the level of theory this wavefunction corresponds to. set_print(self: psi4.core.Wavefunction, arg0: int) → None¶; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; docstring. set_sad_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities density-fitted basisset. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. twoel_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix], arg1: bool, arg2: str) → List[psi4.core.Matrix]¶; Two-electron Hessian-vector products. variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the map of all internal variables. psi4.core.IDAMAX(arg0: int, arg1: int, arg2: psi::Vector, arg3: int) → int¶; docstring. class psi4.core.IO¶; Bases: pybind11_builtins.pybind11_object; docstring. change_file_namespace(fileno: int, ns1: str, ns2: str) → None¶; Change file number from ns1 to ns2. close(self: psi4.core.IO, unit: int, keep: int) → None¶; Close unit. If keep == 0, will remove the",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:80316,Modifiability,variab,variables,80316,"ce_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; docstring. set_sad_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities density-fitted basisset. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. twoel_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix], arg1: bool, arg2: str) → List[psi4.core.Matrix]¶; Two-electron Hessian-vector products. variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the map of all internal variables. psi4.core.IDAMAX(arg0: int, arg1: int, arg2: psi::Vector, arg3: int) → int¶; docstring. class psi4.core.IO¶; Bases: pybind11_builtins.pybind11_object; docstring. change_file_namespace(fileno: int, ns1: str, ns2: str) → None¶; Change file number from ns1 to ns2. close(self: psi4.core.IO, unit: int, keep: int) → None¶; Close unit. If keep == 0, will remove the file, else keep it. get_default_namespace() → str¶; Get the default namespace (for PREFIX.NAMESPACE.UNIT file numbering). getpid(self: psi4.core.IO) → str¶; Lookup process id. open(self: psi4.core.IO, unit: int, status: int) → None¶; Open unit. Status can be PSIO_OPEN_OLD (if existing file is to be opened) or PSIO_OPEN_NEW if new file should be open. open_check(self: psi4.core.IO, unit: int) → int¶; Return 1 if unit is open. rehash(self: psi4.core.IO, unit: int) → None¶; Sync up the object to the file on disk by closing and opening the fil",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:80409,Modifiability,variab,variables,80409,"i4.core.Wavefunction) → None¶; docstring. set_sad_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities density-fitted basisset. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. twoel_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix], arg1: bool, arg2: str) → List[psi4.core.Matrix]¶; Two-electron Hessian-vector products. variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the map of all internal variables. psi4.core.IDAMAX(arg0: int, arg1: int, arg2: psi::Vector, arg3: int) → int¶; docstring. class psi4.core.IO¶; Bases: pybind11_builtins.pybind11_object; docstring. change_file_namespace(fileno: int, ns1: str, ns2: str) → None¶; Change file number from ns1 to ns2. close(self: psi4.core.IO, unit: int, keep: int) → None¶; Close unit. If keep == 0, will remove the file, else keep it. get_default_namespace() → str¶; Get the default namespace (for PREFIX.NAMESPACE.UNIT file numbering). getpid(self: psi4.core.IO) → str¶; Lookup process id. open(self: psi4.core.IO, unit: int, status: int) → None¶; Open unit. Status can be PSIO_OPEN_OLD (if existing file is to be opened) or PSIO_OPEN_NEW if new file should be open. open_check(self: psi4.core.IO, unit: int) → int¶; Return 1 if unit is open. rehash(self: psi4.core.IO, unit: int) → None¶; Sync up the object to the file on disk by closing and opening the file, if necessary. set_default_namespace(ns: str) → None¶",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:131969,Modifiability,variab,variables,131969,"i4.core.Molecule, arg0: float) → psi4.core.PointGroup¶; Finds computational molecular point group, user can override this with the symmetry keyword. fix_com(self: psi4.core.Molecule, arg0: bool) → None¶; Whether to fix the Cartesian position, or to translate to the C.O.M. fix_orientation(self: psi4.core.Molecule, arg0: bool) → None¶; Fix the orientation at its current frame. form_symmetry_information(self: psi4.core.Molecule, arg0: float) → None¶; Uses the point group object obtain by calling point_group(). classmethod from_arrays(geom=None, elea=None, elez=None, elem=None, mass=None, real=None, elbl=None, name=None, units='Angstrom', input_units_to_au=None, fix_com=None, fix_orientation=None, fix_symmetry=None, fragment_separators=None, fragment_charges=None, fragment_multiplicities=None, molecular_charge=None, molecular_multiplicity=None, missing_enabled_return='error', tooclose=0.1, zero_ghost_fragments=False, nonphysical=False, mtol=0.001, verbose=1, return_dict=False)¶; Construct Molecule from unvalidated arrays and variables.; Light wrapper around from_arrays(); that is a full-featured constructor to dictionary representa-; tion of Molecule. This follows one step further to return; Molecule instance.; :param See from_arrays().:. Returns:. Return type:psi4.core.Molecule. from_dict(arg0: dict) → psi4.core.Molecule¶; Returns a new Molecule constructed from python dictionary. In progress: name and capabilities should not be relied upon. classmethod from_schema(molschema, return_dict=False, verbose=1)¶; Construct Molecule from non-Psi4 schema.; Light wrapper around from_arrays(). Parameters:; molschema (dict) – Dictionary form of Molecule following known schema.; return_dict (bool, optional) – Additionally return Molecule dictionary intermediate.; verbose (int, optional) – Amount of printing. Returns:; mol (psi4.core.Molecule); molrec (dict, optional) – Dictionary representation of instance.; Only provided if return_dict is True. classmethod from_string(molstr, dty",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:134297,Modifiability,variab,variable,134297,"g1 (0-indexed including dummies in Bohr). fz(self: psi4.core.Molecule, arg0: int) → float¶; z position of atom arg1 (0-indexed including dummies in Bohr). geometry(self: psi4.core.Molecule) → psi4.core.Matrix¶; Gets the geometry as a (Natom X 3) matrix of coordinates (in Bohr). get_fragment_charges(self: psi4.core.Molecule) → List[int]¶; Gets the charge of each fragment. get_fragment_multiplicities(self: psi4.core.Molecule) → List[int]¶; Gets the multiplicity of each fragment. get_fragment_types(self: psi4.core.Molecule) → List[str]¶; Returns a list describing how to handle each fragment {Real, Ghost, Absent}. get_fragments(self: psi4.core.Molecule) → List[Tuple[int, int]]¶; Returns list of pairs of atom ranges defining each fragment from parent molecule(fragments[frag_ind] = <Afirst,Alast+1>). get_full_point_group(self: psi4.core.Molecule) → str¶; Gets point group name such as C3v or S8. get_variable(self: psi4.core.Molecule, arg0: str) → float¶; Checks if variable arg2 is in the list, sets it to val and returns true if it is, and returns false if not. inertia_tensor(self: psi4.core.Molecule) → psi4.core.Matrix¶; Returns intertial tensor. input_units_to_au(self: psi4.core.Molecule) → float¶; Returns unit conversion to [a0] for geometry. irrep_labels(self: psi4.core.Molecule) → List[str]¶; Returns Irreducible Representation symmetry labels. is_variable(self: psi4.core.Molecule, arg0: str) → bool¶; Checks if variable arg2 is in the list, returns true if it is, and returns false if not. label(self: psi4.core.Molecule, arg0: int) → str¶; Gets the original label of the atom as given in the input file (C2, H4). mass(self: psi4.core.Molecule, atom: int) → float¶; Returns mass of atom (0-indexed). mass_number(self: psi4.core.Molecule, arg0: int) → int¶; Mass number (A) of atom if known, else -1. molecular_charge(self: psi4.core.Molecule) → int¶; Gets the molecular charge. move_to_com(self: psi4.core.Molecule) → None¶; Moves molecule to center of mass. multiplicity(self: ps",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:134756,Modifiability,variab,variable,134756," multiplicity of each fragment. get_fragment_types(self: psi4.core.Molecule) → List[str]¶; Returns a list describing how to handle each fragment {Real, Ghost, Absent}. get_fragments(self: psi4.core.Molecule) → List[Tuple[int, int]]¶; Returns list of pairs of atom ranges defining each fragment from parent molecule(fragments[frag_ind] = <Afirst,Alast+1>). get_full_point_group(self: psi4.core.Molecule) → str¶; Gets point group name such as C3v or S8. get_variable(self: psi4.core.Molecule, arg0: str) → float¶; Checks if variable arg2 is in the list, sets it to val and returns true if it is, and returns false if not. inertia_tensor(self: psi4.core.Molecule) → psi4.core.Matrix¶; Returns intertial tensor. input_units_to_au(self: psi4.core.Molecule) → float¶; Returns unit conversion to [a0] for geometry. irrep_labels(self: psi4.core.Molecule) → List[str]¶; Returns Irreducible Representation symmetry labels. is_variable(self: psi4.core.Molecule, arg0: str) → bool¶; Checks if variable arg2 is in the list, returns true if it is, and returns false if not. label(self: psi4.core.Molecule, arg0: int) → str¶; Gets the original label of the atom as given in the input file (C2, H4). mass(self: psi4.core.Molecule, atom: int) → float¶; Returns mass of atom (0-indexed). mass_number(self: psi4.core.Molecule, arg0: int) → int¶; Mass number (A) of atom if known, else -1. molecular_charge(self: psi4.core.Molecule) → int¶; Gets the molecular charge. move_to_com(self: psi4.core.Molecule) → None¶; Moves molecule to center of mass. multiplicity(self: psi4.core.Molecule) → int¶; Gets the multiplicity (defined as 2Ms + 1). nallatom(self: psi4.core.Molecule) → int¶; Number of real and dummy atoms. name(self: psi4.core.Molecule) → str¶; Gets molecule name. natom(self: psi4.core.Molecule) → int¶; Number of real atoms. nfragments(self: psi4.core.Molecule) → int¶; Gets the number of fragments in the molecule. nuclear_dipole(*args, **kwargs)¶; Overloaded function. nuclear_dipole(self: psi4.core.Molecul",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:138934,Modifiability,extend,extended,138934,"cule) → psi4.core.Vector¶; Prints the rotational constants of the molecule. rotational_symmetry_number(self: psi4.core.Molecule) → int¶; Returns number of unique orientations of the rigid molecule that only interchange identical atoms. rotor_type(self: psi4.core.Molecule) → str¶; Returns rotor type, e.g. ‘RT_ATOM’ or ‘RT_SYMMETRIC_TOP’. run_dftd3(func=None, dashlvl=None, dashparam=None, dertype=None, verbose=False)¶; Compute dispersion correction using Grimme’s DFTD3 executable.; Function to call Grimme’s dftd3 program to compute the -D correction; of level dashlvl using parameters for the functional func.; dashparam can supply a full set of dispersion parameters in the; absence of func or individual overrides in the presence of func.; The DFTD3 executable must be independently compiled and found in; PATH or PSIPATH. Parameters:; mol (qcdb.Molecule or psi4.core.Molecule or str) – Molecule on which to run dispersion calculation. Both qcdb and; psi4.core Molecule classes have been extended by this method, so; either allowed. Alternately, a string that can be instantiated; into a qcdb.Molecule.; func (str or None) – Density functional (Psi4, not Turbomole, names) for which to; load parameters from dashcoeff[dashlvl][func]. This is not; passed to DFTD3 and thus may be a dummy or None. Any or all; parameters initialized can be overwritten via dashparam.; dashlvl ({'d2p4', 'd2gr', 'd3zero', 'd3bj', 'd3mzero', d3mbj', 'd', 'd2', 'd3', 'd3m'}) – Flavor of a posteriori dispersion correction for which to load; parameters and call procedure in DFTD3. Must be a keys in; dashcoeff dict (or a key in dashalias that resolves to one).; dashparam (dict, optional) – Dictionary of the same keys as dashcoeff[dashlvl] used to; override any or all values initialized by; dashcoeff[dashlvl][func].; dertype ({None, 0, 'none', 'energy', 1, 'first', 'gradient'}, optional) – Maximum derivative level at which to run DFTD3. For large; mol, energy-only calculations can be significantly more; effic",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:141589,Modifiability,extend,extended,141589,"; * output goes to output file; * gradient returned as psi4.core.Matrix, not list o’lists; * scratch is written to randomly named subdirectory of psi scratch; * psivar “DISPERSION CORRECTION ENERGY” is set; * verbose triggered when PRINT keywork of SCF module >=3. run_gcp(func=None, dertype=None, verbose=False)¶; Function to call Grimme’s dftd3 program (http://toc.uni-muenster.de/DFTD3/); to compute the -D correction of level dashlvl using parameters for; the functional func. The dictionary dashparam can be used to supply; a full set of dispersion parameters in the absense of func or to supply; individual overrides in the presence of func. Returns energy if dertype is 0,; gradient if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The dftd3 executable must be independently compiled and found in; PATH or PSIPATH.; self may be either a qcdb.Molecule (sensibly) or a psi4.Molecule; (works b/c psi4.Molecule has been extended by this method py-side and; only public interface fns used) or a string that can be instantiated; into a qcdb.Molecule. save_string_xyz(self: psi4.core.Molecule) → str¶; Saves the string of an XYZ file to arg2. save_string_xyz_file(self: psi4.core.Molecule) → str¶; Saves an XYZ file to arg2. save_xyz_file(self: psi4.core.Molecule, arg0: str, arg1: bool) → None¶; Saves an XYZ file to arg2. schoenflies_symbol(self: psi4.core.Molecule) → str¶; Returns the Schoenflies symbol. scramble(do_shift=True, do_rotate=True, do_resort=True, deflection=1.0, do_mirror=False, do_plot=False, run_to_completion=False, run_resorting=False, verbose=1)¶; Tester for B787 by shifting, rotating, and atom shuffling ref_mol and; checking that the aligner returns the opposite transformation. Parameters:; ref_mol (qcdb.Molecule or psi4.core.Molecule) – Molecule to perturb.; do_shift (bool or array-like, optional) – Whether to generate a random atom shift on interval [-3, 3) in each; dimension (True) or leave at current origin. To shift by a specified; vect",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:145790,Modifiability,variab,variable,145790,"au(self: psi4.core.Molecule, arg0: float) → None¶; Sets unit conversion to [a0] for geometry. set_mass(self: psi4.core.Molecule, atom: int, mass: float) → None¶; Sets mass of atom (0-indexed) to mass. set_molecular_charge(self: psi4.core.Molecule, arg0: int) → None¶; Sets the molecular charge. set_multiplicity(self: psi4.core.Molecule, arg0: int) → None¶; Sets the multiplicity (defined as 2Ms + 1). set_name(self: psi4.core.Molecule, arg0: str) → None¶; Sets molecule name. set_nuclear_charge(self: psi4.core.Molecule, arg0: int, arg1: float) → None¶; Set the nuclear charge of the given atom to the value provided. set_point_group(self: psi4.core.Molecule, arg0: psi4.core.PointGroup) → None¶; Sets the molecular point group to the point group object arg2. set_units(self: psi4.core.Molecule, arg0: psi4.core.GeometryUnits) → None¶; Sets units (Angstrom or Bohr) used to define the geometry. set_variable(self: psi4.core.Molecule, arg0: str, arg1: float) → None¶; Assigns the value arg3 to the variable arg2 in the list of geometry variables, then calls update_geometry(). symbol(self: psi4.core.Molecule, arg0: int) → str¶; Gets the cleaned up label of atom arg2 (C2 => C, H4 = H). symmetrize(self: psi4.core.Molecule, arg0: float) → None¶; Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. symmetry_from_input(self: psi4.core.Molecule) → str¶; Returns the symmetry specified in the input. to_arrays()¶; Exports coordinate info into NumPy arrays. Returns:; geom, mass, elem, elez, uniq (ndarray, ndarray, ndarray, ndarray, ndarray) – (nat, 3) geometry [a0].; (nat,) mass [u].; (nat,) element symbol.; (nat,) atomic number.; (nat,) hash of element symbol and mass.; Note that coordinate, orientation, and element information is; preserved but fragmentation, chgmult, and dummy/ghost is lost.; Usage; —–; geom, mass, elem, elez, uniq = molinstance.to_arrays(). to_dict(force_c1=False, force_units=False, np_out=True)¶; Serial",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:145828,Modifiability,variab,variables,145828,"au(self: psi4.core.Molecule, arg0: float) → None¶; Sets unit conversion to [a0] for geometry. set_mass(self: psi4.core.Molecule, atom: int, mass: float) → None¶; Sets mass of atom (0-indexed) to mass. set_molecular_charge(self: psi4.core.Molecule, arg0: int) → None¶; Sets the molecular charge. set_multiplicity(self: psi4.core.Molecule, arg0: int) → None¶; Sets the multiplicity (defined as 2Ms + 1). set_name(self: psi4.core.Molecule, arg0: str) → None¶; Sets molecule name. set_nuclear_charge(self: psi4.core.Molecule, arg0: int, arg1: float) → None¶; Set the nuclear charge of the given atom to the value provided. set_point_group(self: psi4.core.Molecule, arg0: psi4.core.PointGroup) → None¶; Sets the molecular point group to the point group object arg2. set_units(self: psi4.core.Molecule, arg0: psi4.core.GeometryUnits) → None¶; Sets units (Angstrom or Bohr) used to define the geometry. set_variable(self: psi4.core.Molecule, arg0: str, arg1: float) → None¶; Assigns the value arg3 to the variable arg2 in the list of geometry variables, then calls update_geometry(). symbol(self: psi4.core.Molecule, arg0: int) → str¶; Gets the cleaned up label of atom arg2 (C2 => C, H4 = H). symmetrize(self: psi4.core.Molecule, arg0: float) → None¶; Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. symmetry_from_input(self: psi4.core.Molecule) → str¶; Returns the symmetry specified in the input. to_arrays()¶; Exports coordinate info into NumPy arrays. Returns:; geom, mass, elem, elez, uniq (ndarray, ndarray, ndarray, ndarray, ndarray) – (nat, 3) geometry [a0].; (nat,) mass [u].; (nat,) element symbol.; (nat,) atomic number.; (nat,) hash of element symbol and mass.; Note that coordinate, orientation, and element information is; preserved but fragmentation, chgmult, and dummy/ghost is lost.; Usage; —–; geom, mass, elem, elez, uniq = molinstance.to_arrays(). to_dict(force_c1=False, force_units=False, np_out=True)¶; Serial",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:147393,Modifiability,variab,variable,147393,"rray, ndarray) – (nat, 3) geometry [a0].; (nat,) mass [u].; (nat,) element symbol.; (nat,) atomic number.; (nat,) hash of element symbol and mass.; Note that coordinate, orientation, and element information is; preserved but fragmentation, chgmult, and dummy/ghost is lost.; Usage; —–; geom, mass, elem, elez, uniq = molinstance.to_arrays(). to_dict(force_c1=False, force_units=False, np_out=True)¶; Serializes instance into Molecule dictionary. to_schema(dtype, units='Angstrom', return_type='json')¶; Serializes instance into JSON or YAML according to schema dtype. to_string(dtype, units='Angstrom', atom_format=None, ghost_format=None, width=17, prec=12)¶; Format a string representation of QM molecule. translate(self: psi4.core.Molecule, arg0: psi4.core.Vector3) → None¶; Translates molecule by arg2. units(self: psi4.core.Molecule) → str¶; Returns units used to define the geometry, i.e. ‘Angstrom’ or ‘Bohr’. update_geometry(self: psi4.core.Molecule) → None¶; Reevaluates the geometry with current variable values, orientation directives, etc. Must be called after initial Molecule definition by string. x(self: psi4.core.Molecule, arg0: int) → float¶; x position of atom. y(self: psi4.core.Molecule, arg0: int) → float¶; y position of atom. z(self: psi4.core.Molecule, arg0: int) → float¶; z position of atom. class psi4.core.MultipoleInt¶; Bases: psi4.core.OneBodyAOInt; Computes arbitrary-order multipole integrals. basis¶; The basis set on center one. basis1¶; The basis set on center one. basis2¶; The basis set on center two. compute_shell(self: psi4.core.OneBodyAOInt, arg0: int, arg1: int) → None¶; Compute integrals between basis functions in the given shell pair. origin¶; The origin about which the one body ints are being computed. class psi4.core.MultipoleSymmetry¶; Bases: pybind11_builtins.pybind11_object; docstring. create_matrices(self: psi4.core.MultipoleSymmetry, arg0: str) → List[psi4.core.Matrix]¶; docstring. class psi4.core.NBOWriter¶; Bases: pybind11_builtins.pybind",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:165542,Modifiability,variab,variable,165542,"e current Density Matrices. frequencies(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the frequencies of the Hessian. frzcpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of frozen core orbitals per irrep. frzvpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of frozen virtual orbitals per irrep. functional(self: psi4.core.HF) → psi4.core.SuperFunctional¶; Returns the internal DFT Superfunctional. get_array(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Sets the requested internal array. get_basisset(self: psi4.core.Wavefunction, arg0: str) → psi4.core.BasisSet¶; Returns the requested auxiliary basis. get_dipole_field_strength(self: psi4.core.Wavefunction) → List[float[3]]¶; Returns a vector of length 3, containing the x,y, and z dipole field strengths. get_print(self: psi4.core.Wavefunction) → int¶; Get the print level of the Wavefunction. get_variable(self: psi4.core.Wavefunction, arg0: str) → float¶; Returns the requested internal variable. gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunctions gradient. guess_Ca(self: psi4.core.HF, arg0: psi4.core.Matrix) → None¶; Sets the guess Alpha Orbital Matrix. guess_Cb(self: psi4.core.HF, arg0: psi4.core.Matrix) → None¶; Sets the guess Beta Orbital Matrix. hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunctions Hessian. initialize(self: psi4.core.HF) → None¶; Initializes the Wavefunction. iterations(self: psi4.core.HF) → None¶; Iterates the Wavefunction until convergence criteria have been met. jk(self: psi4.core.HF) → psi4.core.JK¶; Returns the internal JK object. mo_extents(self: psi4.core.Wavefunction) → List[psi4.core.Vector]¶; returns the wavefunction’s electronic orbital extents. molecule(self: psi4.core.Wavefunction) → psi4.core.Molecule¶; Returns the Wavefunctions molecule. nalpha(self: psi4.core.Wavefunction) → int¶; Number of Alpha electrons. nalphapi(self: psi4.core.Wavefun",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:169922,Modifiability,variab,variable,169922,"sian. set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunctions gradient. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunctions Hessian. set_jk(self: psi4.core.HF, arg0: psi4.core.JK) → None¶; Sets the internal JK object !expert. set_name(self: psi4.core.Wavefunction, arg0: str) → None¶; Sets the level of theory this wavefunction corresponds to. set_print(self: psi4.core.Wavefunction, arg0: int) → None¶; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; docstring. set_sad_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities density-fitted basisset. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. twoel_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix], arg1: bool, arg2: str) → List[psi4.core.Matrix]¶; Two-electron Hessian-vector products. variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the map of all internal variables. class psi4.core.RKSFunctions¶; Bases: psi4.core.PointFunctions; docstring. ansatz(self: psi4.core.PointFunctions) → int¶; docstring. basis_values(self: psi4.core.BasisFunctions) → Dict[str, psi4.core.Matrix]¶; docstring. compute_functions(self: psi4.core.BasisFunctions, arg0: psi::BlockOPoints) → None¶; docstring. compute_points(self: psi4.core.PointFunction",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:170425,Modifiability,variab,variables,170425,"ce_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; docstring. set_sad_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities density-fitted basisset. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. twoel_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix], arg1: bool, arg2: str) → List[psi4.core.Matrix]¶; Two-electron Hessian-vector products. variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the map of all internal variables. class psi4.core.RKSFunctions¶; Bases: psi4.core.PointFunctions; docstring. ansatz(self: psi4.core.PointFunctions) → int¶; docstring. basis_values(self: psi4.core.BasisFunctions) → Dict[str, psi4.core.Matrix]¶; docstring. compute_functions(self: psi4.core.BasisFunctions, arg0: psi::BlockOPoints) → None¶; docstring. compute_points(self: psi4.core.PointFunctions, arg0: psi::BlockOPoints) → None¶; docstring. deriv(self: psi4.core.BasisFunctions) → int¶; docstring. max_functions(self: psi4.core.BasisFunctions) → int¶; docstring. max_points(self: psi4.core.BasisFunctions) → int¶; docstring. orbital_values(self: psi4.core.PointFunctions) → Dict[str, psi4.core.Matrix]¶; docstring. point_values(self: psi4.core.PointFunctions) → Dict[str, psi4.core.Vector]¶; docstring. print_out(self: psi4.core.PointFunctions, out_fname: str='outfile', print: int=2) → None¶; docstring. set_ansatz(self: psi4.core.PointFu",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:170518,Modifiability,variab,variables,170518,"i4.core.Wavefunction) → None¶; docstring. set_sad_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities density-fitted basisset. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. twoel_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix], arg1: bool, arg2: str) → List[psi4.core.Matrix]¶; Two-electron Hessian-vector products. variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the map of all internal variables. class psi4.core.RKSFunctions¶; Bases: psi4.core.PointFunctions; docstring. ansatz(self: psi4.core.PointFunctions) → int¶; docstring. basis_values(self: psi4.core.BasisFunctions) → Dict[str, psi4.core.Matrix]¶; docstring. compute_functions(self: psi4.core.BasisFunctions, arg0: psi::BlockOPoints) → None¶; docstring. compute_points(self: psi4.core.PointFunctions, arg0: psi::BlockOPoints) → None¶; docstring. deriv(self: psi4.core.BasisFunctions) → int¶; docstring. max_functions(self: psi4.core.BasisFunctions) → int¶; docstring. max_points(self: psi4.core.BasisFunctions) → int¶; docstring. orbital_values(self: psi4.core.PointFunctions) → Dict[str, psi4.core.Matrix]¶; docstring. point_values(self: psi4.core.PointFunctions) → Dict[str, psi4.core.Vector]¶; docstring. print_out(self: psi4.core.PointFunctions, out_fname: str='outfile', print: int=2) → None¶; docstring. set_ansatz(self: psi4.core.PointFunctions, arg0: int) → None¶; docstring. set_deriv(self:",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:178133,Modifiability,variab,variable,178133,"e current Density Matrices. frequencies(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the frequencies of the Hessian. frzcpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of frozen core orbitals per irrep. frzvpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of frozen virtual orbitals per irrep. functional(self: psi4.core.HF) → psi4.core.SuperFunctional¶; Returns the internal DFT Superfunctional. get_array(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Sets the requested internal array. get_basisset(self: psi4.core.Wavefunction, arg0: str) → psi4.core.BasisSet¶; Returns the requested auxiliary basis. get_dipole_field_strength(self: psi4.core.Wavefunction) → List[float[3]]¶; Returns a vector of length 3, containing the x,y, and z dipole field strengths. get_print(self: psi4.core.Wavefunction) → int¶; Get the print level of the Wavefunction. get_variable(self: psi4.core.Wavefunction, arg0: str) → float¶; Returns the requested internal variable. gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunctions gradient. guess_Ca(self: psi4.core.HF, arg0: psi4.core.Matrix) → None¶; Sets the guess Alpha Orbital Matrix. guess_Cb(self: psi4.core.HF, arg0: psi4.core.Matrix) → None¶; Sets the guess Beta Orbital Matrix. hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunctions Hessian. initialize(self: psi4.core.HF) → None¶; Initializes the Wavefunction. iterations(self: psi4.core.HF) → None¶; Iterates the Wavefunction until convergence criteria have been met. jk(self: psi4.core.HF) → psi4.core.JK¶; Returns the internal JK object. moFa(self: psi4.core.ROHF) → psi4.core.Matrix¶; docstring. moFb(self: psi4.core.ROHF) → psi4.core.Matrix¶; docstring. moFeff(self: psi4.core.ROHF) → psi4.core.Matrix¶; docstring. mo_extents(self: psi4.core.Wavefunction) → List[psi4.core.Vector]¶; returns the wavefunction’s electronic orbital extents. molecule(self: psi4.cor",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:182692,Modifiability,variab,variable,182692,"sian. set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunctions gradient. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunctions Hessian. set_jk(self: psi4.core.HF, arg0: psi4.core.JK) → None¶; Sets the internal JK object !expert. set_name(self: psi4.core.Wavefunction, arg0: str) → None¶; Sets the level of theory this wavefunction corresponds to. set_print(self: psi4.core.Wavefunction, arg0: int) → None¶; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; docstring. set_sad_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities density-fitted basisset. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. twoel_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix], arg1: bool, arg2: str) → List[psi4.core.Matrix]¶; Two-electron Hessian-vector products. variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the map of all internal variables. class psi4.core.SADGuess¶; Bases: pybind11_builtins.pybind11_object; docstring. Ca(self: psi4.core.SADGuess) → psi4.core.Matrix¶. Cb(self: psi4.core.SADGuess) → psi4.core.Matrix¶. Da(self: psi4.core.SADGuess) → psi4.core.Matrix¶. Db(self: psi4.core.SADGuess) → psi4.core.Matrix¶. build_SAD(arg0: psi4.core.BasisSet, arg1: List[psi4.core.BasisSet], arg2: int, a",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:183195,Modifiability,variab,variables,183195,"ce_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; docstring. set_sad_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities density-fitted basisset. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. twoel_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix], arg1: bool, arg2: str) → List[psi4.core.Matrix]¶; Two-electron Hessian-vector products. variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the map of all internal variables. class psi4.core.SADGuess¶; Bases: pybind11_builtins.pybind11_object; docstring. Ca(self: psi4.core.SADGuess) → psi4.core.Matrix¶. Cb(self: psi4.core.SADGuess) → psi4.core.Matrix¶. Da(self: psi4.core.SADGuess) → psi4.core.Matrix¶. Db(self: psi4.core.SADGuess) → psi4.core.Matrix¶. build_SAD(arg0: psi4.core.BasisSet, arg1: List[psi4.core.BasisSet], arg2: int, arg3: int) → psi4.core.SADGuess¶. compute_guess(self: psi4.core.SADGuess) → None¶. set_atomic_fit_bases(self: psi4.core.SADGuess, arg0: List[psi4.core.BasisSet]) → None¶. set_debug(self: psi4.core.SADGuess, arg0: int) → None¶. set_print(self: psi4.core.SADGuess, arg0: int) → None¶. class psi4.core.SOBasisSet¶; Bases: pybind11_builtins.pybind11_object; An SOBasis object describes the transformation from an atomic orbital basis to a symmetry orbital basis. petite_list(self: psi4.core.SOBasisSet) → psi4.core.PetiteList¶; Return the PetiteList o",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:183288,Modifiability,variab,variables,183288,"i4.core.Wavefunction) → None¶; docstring. set_sad_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities density-fitted basisset. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. twoel_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix], arg1: bool, arg2: str) → List[psi4.core.Matrix]¶; Two-electron Hessian-vector products. variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the map of all internal variables. class psi4.core.SADGuess¶; Bases: pybind11_builtins.pybind11_object; docstring. Ca(self: psi4.core.SADGuess) → psi4.core.Matrix¶. Cb(self: psi4.core.SADGuess) → psi4.core.Matrix¶. Da(self: psi4.core.SADGuess) → psi4.core.Matrix¶. Db(self: psi4.core.SADGuess) → psi4.core.Matrix¶. build_SAD(arg0: psi4.core.BasisSet, arg1: List[psi4.core.BasisSet], arg2: int, arg3: int) → psi4.core.SADGuess¶. compute_guess(self: psi4.core.SADGuess) → None¶. set_atomic_fit_bases(self: psi4.core.SADGuess, arg0: List[psi4.core.BasisSet]) → None¶. set_debug(self: psi4.core.SADGuess, arg0: int) → None¶. set_print(self: psi4.core.SADGuess, arg0: int) → None¶. class psi4.core.SOBasisSet¶; Bases: pybind11_builtins.pybind11_object; An SOBasis object describes the transformation from an atomic orbital basis to a symmetry orbital basis. petite_list(self: psi4.core.SOBasisSet) → psi4.core.PetiteList¶; Return the PetiteList object used in creating this SO basis. class psi4.core.S",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:201616,Modifiability,variab,variable,201616,"e current Density Matrices. frequencies(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the frequencies of the Hessian. frzcpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of frozen core orbitals per irrep. frzvpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of frozen virtual orbitals per irrep. functional(self: psi4.core.HF) → psi4.core.SuperFunctional¶; Returns the internal DFT Superfunctional. get_array(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Sets the requested internal array. get_basisset(self: psi4.core.Wavefunction, arg0: str) → psi4.core.BasisSet¶; Returns the requested auxiliary basis. get_dipole_field_strength(self: psi4.core.Wavefunction) → List[float[3]]¶; Returns a vector of length 3, containing the x,y, and z dipole field strengths. get_print(self: psi4.core.Wavefunction) → int¶; Get the print level of the Wavefunction. get_variable(self: psi4.core.Wavefunction, arg0: str) → float¶; Returns the requested internal variable. gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunctions gradient. guess_Ca(self: psi4.core.HF, arg0: psi4.core.Matrix) → None¶; Sets the guess Alpha Orbital Matrix. guess_Cb(self: psi4.core.HF, arg0: psi4.core.Matrix) → None¶; Sets the guess Beta Orbital Matrix. hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunctions Hessian. initialize(self: psi4.core.HF) → None¶; Initializes the Wavefunction. iterations(self: psi4.core.HF) → None¶; Iterates the Wavefunction until convergence criteria have been met. jk(self: psi4.core.HF) → psi4.core.JK¶; Returns the internal JK object. mo_extents(self: psi4.core.Wavefunction) → List[psi4.core.Vector]¶; returns the wavefunction’s electronic orbital extents. molecule(self: psi4.core.Wavefunction) → psi4.core.Molecule¶; Returns the Wavefunctions molecule. nalpha(self: psi4.core.Wavefunction) → int¶; Number of Alpha electrons. nalphapi(self: psi4.core.Wavefun",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:205996,Modifiability,variab,variable,205996,"sian. set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunctions gradient. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunctions Hessian. set_jk(self: psi4.core.HF, arg0: psi4.core.JK) → None¶; Sets the internal JK object !expert. set_name(self: psi4.core.Wavefunction, arg0: str) → None¶; Sets the level of theory this wavefunction corresponds to. set_print(self: psi4.core.Wavefunction, arg0: int) → None¶; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; docstring. set_sad_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities density-fitted basisset. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. twoel_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix], arg1: bool, arg2: str) → List[psi4.core.Matrix]¶; Two-electron Hessian-vector products. variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the map of all internal variables. class psi4.core.UKSFunctions¶; Bases: psi4.core.PointFunctions; docstring. ansatz(self: psi4.core.PointFunctions) → int¶; docstring. basis_values(self: psi4.core.BasisFunctions) → Dict[str, psi4.core.Matrix]¶; docstring. compute_functions(self: psi4.core.BasisFunctions, arg0: psi::BlockOPoints) → None¶; docstring. compute_points(self: psi4.core.PointFunction",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:206499,Modifiability,variab,variables,206499,"ce_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; docstring. set_sad_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities density-fitted basisset. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. twoel_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix], arg1: bool, arg2: str) → List[psi4.core.Matrix]¶; Two-electron Hessian-vector products. variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the map of all internal variables. class psi4.core.UKSFunctions¶; Bases: psi4.core.PointFunctions; docstring. ansatz(self: psi4.core.PointFunctions) → int¶; docstring. basis_values(self: psi4.core.BasisFunctions) → Dict[str, psi4.core.Matrix]¶; docstring. compute_functions(self: psi4.core.BasisFunctions, arg0: psi::BlockOPoints) → None¶; docstring. compute_points(self: psi4.core.PointFunctions, arg0: psi::BlockOPoints) → None¶; docstring. deriv(self: psi4.core.BasisFunctions) → int¶; docstring. max_functions(self: psi4.core.BasisFunctions) → int¶; docstring. max_points(self: psi4.core.BasisFunctions) → int¶; docstring. orbital_values(self: psi4.core.PointFunctions) → Dict[str, psi4.core.Matrix]¶; docstring. point_values(self: psi4.core.PointFunctions) → Dict[str, psi4.core.Vector]¶; docstring. print_out(self: psi4.core.PointFunctions, out_fname: str='outfile', print: int=2) → None¶; docstring. set_ansatz(self: psi4.core.PointFu",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:206592,Modifiability,variab,variables,206592,"i4.core.Wavefunction) → None¶; docstring. set_sad_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities density-fitted basisset. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. twoel_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix], arg1: bool, arg2: str) → List[psi4.core.Matrix]¶; Two-electron Hessian-vector products. variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the map of all internal variables. class psi4.core.UKSFunctions¶; Bases: psi4.core.PointFunctions; docstring. ansatz(self: psi4.core.PointFunctions) → int¶; docstring. basis_values(self: psi4.core.BasisFunctions) → Dict[str, psi4.core.Matrix]¶; docstring. compute_functions(self: psi4.core.BasisFunctions, arg0: psi::BlockOPoints) → None¶; docstring. compute_points(self: psi4.core.PointFunctions, arg0: psi::BlockOPoints) → None¶; docstring. deriv(self: psi4.core.BasisFunctions) → int¶; docstring. max_functions(self: psi4.core.BasisFunctions) → int¶; docstring. max_points(self: psi4.core.BasisFunctions) → int¶; docstring. orbital_values(self: psi4.core.PointFunctions) → Dict[str, psi4.core.Matrix]¶; docstring. point_values(self: psi4.core.PointFunctions) → Dict[str, psi4.core.Vector]¶; docstring. print_out(self: psi4.core.PointFunctions, out_fname: str='outfile', print: int=2) → None¶; docstring. set_ansatz(self: psi4.core.PointFunctions, arg0: int) → None¶; docstring. set_deriv(self:",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:214591,Modifiability,extend,extend,214591,"r3¶; Bases: pybind11_builtins.pybind11_object; Class for vectors of length three, often Cartesian coordinate vectors, and their common operations. cross(self: psi4.core.Vector3, arg0: psi4.core.Vector3) → psi4.core.Vector3¶; Returns cross product of arg1 and arg2. distance(self: psi4.core.Vector3, arg0: psi4.core.Vector3) → float¶; Returns distance between two points represented by arg1 and arg2. dot(self: psi4.core.Vector3, arg0: psi4.core.Vector3) → float¶; Returns dot product of arg1 and arg2. norm(self: psi4.core.Vector3) → float¶; Returns Euclidean norm of arg1. normalize(self: psi4.core.Vector3) → None¶; Returns vector of unit length and arg1 direction. class psi4.core.VectorMatrix¶; Bases: pybind11_builtins.pybind11_object. append(self: List[psi::Matrix], x: psi::Matrix) → None¶; Add an item to the end of the list. count(self: List[psi::Matrix], x: psi::Matrix) → int¶; Return the number of times x appears in the list. extend(self: List[psi::Matrix], L: List[psi::Matrix]) → None¶; Extend the list by appending all the items in the given list. insert(self: List[psi::Matrix], i: int, x: psi::Matrix) → None¶; Insert an item at a given position. pop(*args, **kwargs)¶; Overloaded function. pop(self: List[psi::Matrix]) -> psi::Matrix. Remove and return the last item. pop(self: List[psi::Matrix], i: int) -> psi::Matrix. Remove and return the item at index i. remove(self: List[psi::Matrix], x: psi::Matrix) → None¶; Remove the first item from the list whose value is x. It is an error if there is no such item. class psi4.core.Wavefunction¶; Bases: pybind11_builtins.pybind11_object; docstring. Ca(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Alpha Orbitals. Ca_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Matrix¶; Returns the requested Alpha Orbital subset. Cb(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Beta Orbitals. Cb_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Matrix¶; Returns the r",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:220292,Modifiability,variab,variable,220292,"of singly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. frequencies(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the frequencies of the Hessian. frzcpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of frozen core orbitals per irrep. frzvpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of frozen virtual orbitals per irrep. get_array(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Sets the requested internal array. get_basisset(self: psi4.core.Wavefunction, arg0: str) → psi4.core.BasisSet¶; Returns the requested auxiliary basis. get_dipole_field_strength(self: psi4.core.Wavefunction) → List[float[3]]¶; Returns a vector of length 3, containing the x,y, and z dipole field strengths. get_print(self: psi4.core.Wavefunction) → int¶; Get the print level of the Wavefunction. get_variable(self: psi4.core.Wavefunction, arg0: str) → float¶; Returns the requested internal variable. gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunctions gradient. hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunctions Hessian. mo_extents(self: psi4.core.Wavefunction) → List[psi4.core.Vector]¶; returns the wavefunction’s electronic orbital extents. molecule(self: psi4.core.Wavefunction) → psi4.core.Molecule¶; Returns the Wavefunctions molecule. nalpha(self: psi4.core.Wavefunction) → int¶; Number of Alpha electrons. nalphapi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of alpha orbitals per irrep. name(self: psi4.core.Wavefunction) → str¶; The level of theory this wavefunction corresponds to. nbeta(self: psi4.core.Wavefunction) → int¶; Number of Beta electrons. nbetapi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of beta orbitals per irrep. nfrzc(self: psi4.core.Wavefunction) → int¶; Number of frozen core electrons. nirrep(self: ps",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:223321,Modifiability,variab,variable,223321,"l array. set_basisset(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.BasisSet) → None¶; Sets the requested auxiliary basis. set_external_potential(self: psi4.core.Wavefunction, arg0: psi4.core.ExternalPotential) → None¶; Sets the requested external potential. set_frequencies(self: psi4.core.Wavefunction, arg0: psi4.core.Vector) → None¶; Sets the frequencies of the Hessian. set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunctions gradient. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunctions Hessian. set_name(self: psi4.core.Wavefunction, arg0: str) → None¶; Sets the level of theory this wavefunction corresponds to. set_print(self: psi4.core.Wavefunction, arg0: int) → None¶; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; docstring. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the map of all internal variables. psi4.core.adc(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the ADC propagator code, for excited states. psi4.core.atomic_displacements(arg0: psi::Molecule) → List[psi::Matrix]¶; Returns list of displacements generated by displacing each atom in the +/- x, y, z directions. psi4.core.be_quiet() → None¶; Redirects output to /dev/null. To switch back to regular output mode, use reopen_outfile(). psi4.core.benchmark_blas1(arg0: int, arg1: float) → None¶; docstring. psi4.core.benchmark_blas2(arg0: int",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:223677,Modifiability,variab,variables,223677,"self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunctions gradient. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunctions Hessian. set_name(self: psi4.core.Wavefunction, arg0: str) → None¶; Sets the level of theory this wavefunction corresponds to. set_print(self: psi4.core.Wavefunction, arg0: int) → None¶; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; docstring. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the map of all internal variables. psi4.core.adc(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the ADC propagator code, for excited states. psi4.core.atomic_displacements(arg0: psi::Molecule) → List[psi::Matrix]¶; Returns list of displacements generated by displacing each atom in the +/- x, y, z directions. psi4.core.be_quiet() → None¶; Redirects output to /dev/null. To switch back to regular output mode, use reopen_outfile(). psi4.core.benchmark_blas1(arg0: int, arg1: float) → None¶; docstring. psi4.core.benchmark_blas2(arg0: int, arg1: float) → None¶; docstring. psi4.core.benchmark_blas3(arg0: int, arg1: float, arg2: int) → None¶; docstring. psi4.core.benchmark_disk(arg0: int, arg1: float) → None¶; docstring. psi4.core.benchmark_integrals(arg0: int, arg1: float) → None¶; docstring. psi4.core.benchmark_math(arg0: float) → None¶; docstring. psi4.core.ccdensity(arg0: psi::Wavefunction) → float¶; Runs the code to compute co",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:223770,Modifiability,variab,variables,223770,"→ None¶; Sets the Wavefunctions gradient. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunctions Hessian. set_name(self: psi4.core.Wavefunction, arg0: str) → None¶; Sets the level of theory this wavefunction corresponds to. set_print(self: psi4.core.Wavefunction, arg0: int) → None¶; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; docstring. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the map of all internal variables. psi4.core.adc(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the ADC propagator code, for excited states. psi4.core.atomic_displacements(arg0: psi::Molecule) → List[psi::Matrix]¶; Returns list of displacements generated by displacing each atom in the +/- x, y, z directions. psi4.core.be_quiet() → None¶; Redirects output to /dev/null. To switch back to regular output mode, use reopen_outfile(). psi4.core.benchmark_blas1(arg0: int, arg1: float) → None¶; docstring. psi4.core.benchmark_blas2(arg0: int, arg1: float) → None¶; docstring. psi4.core.benchmark_blas3(arg0: int, arg1: float, arg2: int) → None¶; docstring. psi4.core.benchmark_disk(arg0: int, arg1: float) → None¶; docstring. psi4.core.benchmark_integrals(arg0: int, arg1: float) → None¶; docstring. psi4.core.benchmark_math(arg0: float) → None¶; docstring. psi4.core.ccdensity(arg0: psi::Wavefunction) → float¶; Runs the code to compute coupled cluster density matrices. psi4.core.ccenergy(arg0",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:225747,Modifiability,variab,variables,225747," psi::Wavefunction) → psi::Wavefunction¶; Runs the coupled cluster energy code. psi4.core.cceom(arg0: psi::Wavefunction) → float¶; Runs the equation of motion coupled cluster code, for excited states. psi4.core.cchbar(arg0: psi::Wavefunction) → None¶; Runs the code to generate the similarity transformed Hamiltonian. psi4.core.cclambda(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the coupled cluster lambda equations code. psi4.core.ccresponse(arg0: psi::Wavefunction) → float¶; Runs the coupled cluster response theory code. psi4.core.cctransort(arg0: psi::Wavefunction) → None¶; Runs CCTRANSORT, which transforms and reorders integrals for use in the coupled cluster codes. psi4.core.cctriples(arg0: psi::Wavefunction) → float¶; Runs the coupled cluster (T) energy code. psi4.core.clean() → None¶; Function to remove scratch files. Call between independent jobs. psi4.core.clean_options() → None¶; Function to reset options to clean state. psi4.core.clean_variables() → None¶; Empties all PSI variables that have set internally. psi4.core.close_outfile() → None¶; Closes the output file. psi4.core.dcft(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the density cumulant functional theory code. psi4.core.detci(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the determinant-based configuration interaction code. psi4.core.dfmp2(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the DF-MP2 code. psi4.core.dfocc(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the density-fitted orbital optimized CC codes. psi4.core.displace_atom(arg0: psi::Matrix, arg1: int, arg2: int, arg3: int, arg4: float) → None¶; Displaces one coordinate of single atom. psi4.core.dmrg(arg0: psi::Wavefunction) → float¶; Runs the DMRG code. psi4.core.efp_init() → psi4.core.EFP¶; Initializes the EFP library and returns an EFP object. psi4.core.efp_set_options() → None¶; Set EFP options from environment options object. psi4.core.fcidump_tei_helper(nirrep: int, restricted: bool, DPD_info: Dict[str",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:226044,Modifiability,config,configuration,226044,"e the similarity transformed Hamiltonian. psi4.core.cclambda(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the coupled cluster lambda equations code. psi4.core.ccresponse(arg0: psi::Wavefunction) → float¶; Runs the coupled cluster response theory code. psi4.core.cctransort(arg0: psi::Wavefunction) → None¶; Runs CCTRANSORT, which transforms and reorders integrals for use in the coupled cluster codes. psi4.core.cctriples(arg0: psi::Wavefunction) → float¶; Runs the coupled cluster (T) energy code. psi4.core.clean() → None¶; Function to remove scratch files. Call between independent jobs. psi4.core.clean_options() → None¶; Function to reset options to clean state. psi4.core.clean_variables() → None¶; Empties all PSI variables that have set internally. psi4.core.close_outfile() → None¶; Closes the output file. psi4.core.dcft(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the density cumulant functional theory code. psi4.core.detci(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the determinant-based configuration interaction code. psi4.core.dfmp2(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the DF-MP2 code. psi4.core.dfocc(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the density-fitted orbital optimized CC codes. psi4.core.displace_atom(arg0: psi::Matrix, arg1: int, arg2: int, arg3: int, arg4: float) → None¶; Displaces one coordinate of single atom. psi4.core.dmrg(arg0: psi::Wavefunction) → float¶; Runs the DMRG code. psi4.core.efp_init() → psi4.core.EFP¶; Initializes the EFP library and returns an EFP object. psi4.core.efp_set_options() → None¶; Set EFP options from environment options object. psi4.core.fcidump_tei_helper(nirrep: int, restricted: bool, DPD_info: Dict[str, int], ints_tolerance: float, fname: str='INTDUMP') → None¶; Write integrals to file in FCIDUMP format. psi4.core.fd_1_0(arg0: psi::Molecule, arg1: list) → psi::Matrix¶; Performs a finite difference gradient computation, from energy points. psi4.core.fd_freq_0(arg0: psi::Mole",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:228351,Modifiability,variab,variables,228351,"st[psi::Matrix]¶; Gets list of displacements needed for a finite difference gradient computation, from energy points. psi4.core.fd_geoms_freq_0(arg0: psi::Molecule, arg1: int) → List[psi::Matrix]¶; Gets list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep. psi4.core.fd_geoms_freq_1(arg0: psi::Molecule, arg1: int) → List[psi::Matrix]¶; Gets list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep. psi4.core.finalize() → None¶. psi4.core.flush_outfile() → None¶; Flushes the output file. psi4.core.fnocc(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the fno-ccsd(t)/qcisd(t)/mp4/cepa energy code. psi4.core.get_active_efp() → psi4.core.EFP¶; Returns the currently active EFP object. psi4.core.get_active_molecule() → psi::Molecule¶; Returns the currently active molecule object. psi4.core.get_array_variable(arg0: str) → psi::Matrix¶; Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available). psi4.core.get_array_variables() → Dict[str, psi::Matrix]¶; Returns dictionary of the PSI variables set internally by the modules or python driver. psi4.core.get_atomic_point_charges() → psi::Vector¶; Returns the most recently computed atomic point charges, as a double * object. psi4.core.get_datadir() → str¶; Sets the path to shared text resources, PSIDATADIR. psi4.core.get_efp_torque() → psi::Matrix¶; Returns the most recently computed gradient for the EFP portion, as a Nefp by 6 Matrix object. psi4.core.get_frequencies() → psi::Vector¶; Returns the most recently computed frequencies, as a 3N-6 Vector object. psi4.core.get_global_option(arg0: str) → object¶; Given a string of a keyword name arg1, returns the value associated with the keyword from the global options. Returns error if keyword is not recognized. psi4.core.get_global_option_list() → List[str]¶; Returns a list of all global options. p",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:228440,Modifiability,variab,variables,228440,"st[psi::Matrix]¶; Gets list of displacements needed for a finite difference gradient computation, from energy points. psi4.core.fd_geoms_freq_0(arg0: psi::Molecule, arg1: int) → List[psi::Matrix]¶; Gets list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep. psi4.core.fd_geoms_freq_1(arg0: psi::Molecule, arg1: int) → List[psi::Matrix]¶; Gets list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep. psi4.core.finalize() → None¶. psi4.core.flush_outfile() → None¶; Flushes the output file. psi4.core.fnocc(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the fno-ccsd(t)/qcisd(t)/mp4/cepa energy code. psi4.core.get_active_efp() → psi4.core.EFP¶; Returns the currently active EFP object. psi4.core.get_active_molecule() → psi::Molecule¶; Returns the currently active molecule object. psi4.core.get_array_variable(arg0: str) → psi::Matrix¶; Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available). psi4.core.get_array_variables() → Dict[str, psi::Matrix]¶; Returns dictionary of the PSI variables set internally by the modules or python driver. psi4.core.get_atomic_point_charges() → psi::Vector¶; Returns the most recently computed atomic point charges, as a double * object. psi4.core.get_datadir() → str¶; Sets the path to shared text resources, PSIDATADIR. psi4.core.get_efp_torque() → psi::Matrix¶; Returns the most recently computed gradient for the EFP portion, as a Nefp by 6 Matrix object. psi4.core.get_frequencies() → psi::Vector¶; Returns the most recently computed frequencies, as a 3N-6 Vector object. psi4.core.get_global_option(arg0: str) → object¶; Given a string of a keyword name arg1, returns the value associated with the keyword from the global options. Returns error if keyword is not recognized. psi4.core.get_global_option_list() → List[str]¶; Returns a list of all global options. p",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:228551,Modifiability,variab,variables,228551,": int) → List[psi::Matrix]¶; Gets list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep. psi4.core.fd_geoms_freq_1(arg0: psi::Molecule, arg1: int) → List[psi::Matrix]¶; Gets list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep. psi4.core.finalize() → None¶. psi4.core.flush_outfile() → None¶; Flushes the output file. psi4.core.fnocc(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the fno-ccsd(t)/qcisd(t)/mp4/cepa energy code. psi4.core.get_active_efp() → psi4.core.EFP¶; Returns the currently active EFP object. psi4.core.get_active_molecule() → psi::Molecule¶; Returns the currently active molecule object. psi4.core.get_array_variable(arg0: str) → psi::Matrix¶; Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available). psi4.core.get_array_variables() → Dict[str, psi::Matrix]¶; Returns dictionary of the PSI variables set internally by the modules or python driver. psi4.core.get_atomic_point_charges() → psi::Vector¶; Returns the most recently computed atomic point charges, as a double * object. psi4.core.get_datadir() → str¶; Sets the path to shared text resources, PSIDATADIR. psi4.core.get_efp_torque() → psi::Matrix¶; Returns the most recently computed gradient for the EFP portion, as a Nefp by 6 Matrix object. psi4.core.get_frequencies() → psi::Vector¶; Returns the most recently computed frequencies, as a 3N-6 Vector object. psi4.core.get_global_option(arg0: str) → object¶; Given a string of a keyword name arg1, returns the value associated with the keyword from the global options. Returns error if keyword is not recognized. psi4.core.get_global_option_list() → List[str]¶; Returns a list of all global options. psi4.core.get_gradient() → psi::Matrix¶; Returns the most recently computed gradient, as a N by 3 Matrix object. psi4.core.get_legacy_molecule() → psi::Molecule¶; Return",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:230558,Modifiability,variab,variables,230558,".core.get_local_option(arg0: str, arg1: str) → object¶; Given a string of a keyword name arg2 and a particular module arg1, returns the value associated with the keyword in the module options scope. Returns error if keyword is not recognized for the module. psi4.core.get_memory() → int¶; Returns the amount of memory available to Psi (in bytes). psi4.core.get_num_threads() → int¶; Returns the number of threads to use in SMP parallel computations. psi4.core.get_option(arg0: str, arg1: str) → object¶; Given a string of a keyword name arg2 and a particular module arg1, returns the local value associated with the keyword if it’s been set, else the global value if it’s been set, else the local core.default value. Returns error if keyword is not recognized globally or if keyword is not recognized for the module. psi4.core.get_options() → psi::Options¶; Get options. psi4.core.get_output_file() → str¶. psi4.core.get_variable(arg0: str) → float¶; Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available). psi4.core.get_variables() → Dict[str, float]¶; Returns dictionary of the PSI variables set internally by the modules or python driver. psi4.core.get_writer_file_prefix(arg0: str) → str¶; Returns the prefix to use for writing files for external programs. psi4.core.git_version() → str¶; Returns the git version of this copy of Psi. psi4.core.has_global_option_changed(arg0: str) → bool¶; Returns boolean for whether the keyword arg1 has been touched in the global scope, by either user or code. Notwithstanding, code is written such that in practice, this returns whether the option has been touched in the global scope by the user. psi4.core.has_local_option_changed(arg0: str, arg1: str) → bool¶; Returns boolean for whether the keyword arg2 has been touched in the scope of the specified module arg1, by either user or code. Notwithstanding, code is written such that in practice, this returns whether the option h",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:230647,Modifiability,variab,variables,230647,".core.get_local_option(arg0: str, arg1: str) → object¶; Given a string of a keyword name arg2 and a particular module arg1, returns the value associated with the keyword in the module options scope. Returns error if keyword is not recognized for the module. psi4.core.get_memory() → int¶; Returns the amount of memory available to Psi (in bytes). psi4.core.get_num_threads() → int¶; Returns the number of threads to use in SMP parallel computations. psi4.core.get_option(arg0: str, arg1: str) → object¶; Given a string of a keyword name arg2 and a particular module arg1, returns the local value associated with the keyword if it’s been set, else the global value if it’s been set, else the local core.default value. Returns error if keyword is not recognized globally or if keyword is not recognized for the module. psi4.core.get_options() → psi::Options¶; Get options. psi4.core.get_output_file() → str¶. psi4.core.get_variable(arg0: str) → float¶; Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available). psi4.core.get_variables() → Dict[str, float]¶; Returns dictionary of the PSI variables set internally by the modules or python driver. psi4.core.get_writer_file_prefix(arg0: str) → str¶; Returns the prefix to use for writing files for external programs. psi4.core.git_version() → str¶; Returns the git version of this copy of Psi. psi4.core.has_global_option_changed(arg0: str) → bool¶; Returns boolean for whether the keyword arg1 has been touched in the global scope, by either user or code. Notwithstanding, code is written such that in practice, this returns whether the option has been touched in the global scope by the user. psi4.core.has_local_option_changed(arg0: str, arg1: str) → bool¶; Returns boolean for whether the keyword arg2 has been touched in the scope of the specified module arg1, by either user or code. Notwithstanding, code is written such that in practice, this returns whether the option h",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:230746,Modifiability,variab,variables,230746," the keyword in the module options scope. Returns error if keyword is not recognized for the module. psi4.core.get_memory() → int¶; Returns the amount of memory available to Psi (in bytes). psi4.core.get_num_threads() → int¶; Returns the number of threads to use in SMP parallel computations. psi4.core.get_option(arg0: str, arg1: str) → object¶; Given a string of a keyword name arg2 and a particular module arg1, returns the local value associated with the keyword if it’s been set, else the global value if it’s been set, else the local core.default value. Returns error if keyword is not recognized globally or if keyword is not recognized for the module. psi4.core.get_options() → psi::Options¶; Get options. psi4.core.get_output_file() → str¶. psi4.core.get_variable(arg0: str) → float¶; Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available). psi4.core.get_variables() → Dict[str, float]¶; Returns dictionary of the PSI variables set internally by the modules or python driver. psi4.core.get_writer_file_prefix(arg0: str) → str¶; Returns the prefix to use for writing files for external programs. psi4.core.git_version() → str¶; Returns the git version of this copy of Psi. psi4.core.has_global_option_changed(arg0: str) → bool¶; Returns boolean for whether the keyword arg1 has been touched in the global scope, by either user or code. Notwithstanding, code is written such that in practice, this returns whether the option has been touched in the global scope by the user. psi4.core.has_local_option_changed(arg0: str, arg1: str) → bool¶; Returns boolean for whether the keyword arg2 has been touched in the scope of the specified module arg1, by either user or code. Notwithstanding, code is written such that in practice, this returns whether the option has been touched in the module scope by the user. psi4.core.has_option_changed(arg0: str, arg1: str) → bool¶; Returns boolean for whether the option arg2 has",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:232021,Modifiability,variab,variable,232021,".core.has_global_option_changed(arg0: str) → bool¶; Returns boolean for whether the keyword arg1 has been touched in the global scope, by either user or code. Notwithstanding, code is written such that in practice, this returns whether the option has been touched in the global scope by the user. psi4.core.has_local_option_changed(arg0: str, arg1: str) → bool¶; Returns boolean for whether the keyword arg2 has been touched in the scope of the specified module arg1, by either user or code. Notwithstanding, code is written such that in practice, this returns whether the option has been touched in the module scope by the user. psi4.core.has_option_changed(arg0: str, arg1: str) → bool¶; Returns boolean for whether the option arg2 has been touched either locally to the specified module arg1 or globally, by either user or code. Notwithstanding, code is written such that in practice, this returns whether the option has been touched by the user. psi4.core.has_variable(arg0: str) → bool¶; Returns true if the PSI variable exists/is set. psi4.core.initialize() → bool¶. psi4.core.legacy_wavefunction() → psi::Wavefunction¶; Returns the current legacy_wavefunction object from the most recent computation. psi4.core.libfock(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs a CPHF calculation, using libfock. psi4.core.mcscf(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the MCSCF code, (N.B. restricted to certain active spaces). psi4.core.mrcc_generate_input(arg0: psi::Wavefunction, arg1: dict) → psi4.core.PsiReturnType¶; Generates an input for Kallay’s MRCC code. psi4.core.mrcc_load_densities(arg0: psi::Wavefunction, arg1: dict) → psi4.core.PsiReturnType¶; Reads in the density matrices from Kallay’s MRCC code. psi4.core.occ(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the orbital optimized CC codes. psi4.core.opt_clean() → None¶; Cleans up the optimizer’s scratch files. psi4.core.option_exists_in_module(arg0: str, arg1: str) → bool¶; Given a string of a keyword name arg",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:233251,Modifiability,plugin,plugin,233251,"on, using libfock. psi4.core.mcscf(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the MCSCF code, (N.B. restricted to certain active spaces). psi4.core.mrcc_generate_input(arg0: psi::Wavefunction, arg1: dict) → psi4.core.PsiReturnType¶; Generates an input for Kallay’s MRCC code. psi4.core.mrcc_load_densities(arg0: psi::Wavefunction, arg1: dict) → psi4.core.PsiReturnType¶; Reads in the density matrices from Kallay’s MRCC code. psi4.core.occ(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the orbital optimized CC codes. psi4.core.opt_clean() → None¶; Cleans up the optimizer’s scratch files. psi4.core.option_exists_in_module(arg0: str, arg1: str) → bool¶; Given a string of a keyword name arg1 and a particular module arg0, returns whether arg1 is a valid option for arg0. psi4.core.optking() → int¶; Runs the geometry optimization / frequency analysis code. psi4.core.outfile_name() → str¶; Returns the name of the output file. psi4.core.plugin(arg0: str, arg1: psi::Wavefunction) → psi::Wavefunction¶; Call the plugin of name arg0. Returns the plugin code result. psi4.core.plugin_close(arg0: str) → None¶; Close the plugin of name arg0. psi4.core.plugin_close_all() → None¶; Close all open plugins. psi4.core.plugin_load(arg0: str) → int¶; Load the plugin of name arg0. Returns 0 if not loaded, 1 if loaded, 2 if already loaded. psi4.core.prepare_options_for_module(arg0: str) → None¶; Sets the options module up to return options pertaining to the named argument (e.g. SCF). psi4.core.print_global_options() → None¶; Prints the currently set global (all modules) options to the output file. psi4.core.print_options() → None¶; Prints the currently set options (to the output file) for the current module. psi4.core.print_out(arg0: str) → None¶; Prints a string (using sprintf-like notation) to the output file. psi4.core.print_variables() → None¶; Prints all PSI variables that have been set internally. psi4.core.psi_top_srcdir() → str¶; Returns the location of the source code. psi",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:233325,Modifiability,plugin,plugin,233325,"on, using libfock. psi4.core.mcscf(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the MCSCF code, (N.B. restricted to certain active spaces). psi4.core.mrcc_generate_input(arg0: psi::Wavefunction, arg1: dict) → psi4.core.PsiReturnType¶; Generates an input for Kallay’s MRCC code. psi4.core.mrcc_load_densities(arg0: psi::Wavefunction, arg1: dict) → psi4.core.PsiReturnType¶; Reads in the density matrices from Kallay’s MRCC code. psi4.core.occ(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the orbital optimized CC codes. psi4.core.opt_clean() → None¶; Cleans up the optimizer’s scratch files. psi4.core.option_exists_in_module(arg0: str, arg1: str) → bool¶; Given a string of a keyword name arg1 and a particular module arg0, returns whether arg1 is a valid option for arg0. psi4.core.optking() → int¶; Runs the geometry optimization / frequency analysis code. psi4.core.outfile_name() → str¶; Returns the name of the output file. psi4.core.plugin(arg0: str, arg1: psi::Wavefunction) → psi::Wavefunction¶; Call the plugin of name arg0. Returns the plugin code result. psi4.core.plugin_close(arg0: str) → None¶; Close the plugin of name arg0. psi4.core.plugin_close_all() → None¶; Close all open plugins. psi4.core.plugin_load(arg0: str) → int¶; Load the plugin of name arg0. Returns 0 if not loaded, 1 if loaded, 2 if already loaded. psi4.core.prepare_options_for_module(arg0: str) → None¶; Sets the options module up to return options pertaining to the named argument (e.g. SCF). psi4.core.print_global_options() → None¶; Prints the currently set global (all modules) options to the output file. psi4.core.print_options() → None¶; Prints the currently set options (to the output file) for the current module. psi4.core.print_out(arg0: str) → None¶; Prints a string (using sprintf-like notation) to the output file. psi4.core.print_variables() → None¶; Prints all PSI variables that have been set internally. psi4.core.psi_top_srcdir() → str¶; Returns the location of the source code. psi",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:233358,Modifiability,plugin,plugin,233358,"si::Wavefunction¶; Runs the MCSCF code, (N.B. restricted to certain active spaces). psi4.core.mrcc_generate_input(arg0: psi::Wavefunction, arg1: dict) → psi4.core.PsiReturnType¶; Generates an input for Kallay’s MRCC code. psi4.core.mrcc_load_densities(arg0: psi::Wavefunction, arg1: dict) → psi4.core.PsiReturnType¶; Reads in the density matrices from Kallay’s MRCC code. psi4.core.occ(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the orbital optimized CC codes. psi4.core.opt_clean() → None¶; Cleans up the optimizer’s scratch files. psi4.core.option_exists_in_module(arg0: str, arg1: str) → bool¶; Given a string of a keyword name arg1 and a particular module arg0, returns whether arg1 is a valid option for arg0. psi4.core.optking() → int¶; Runs the geometry optimization / frequency analysis code. psi4.core.outfile_name() → str¶; Returns the name of the output file. psi4.core.plugin(arg0: str, arg1: psi::Wavefunction) → psi::Wavefunction¶; Call the plugin of name arg0. Returns the plugin code result. psi4.core.plugin_close(arg0: str) → None¶; Close the plugin of name arg0. psi4.core.plugin_close_all() → None¶; Close all open plugins. psi4.core.plugin_load(arg0: str) → int¶; Load the plugin of name arg0. Returns 0 if not loaded, 1 if loaded, 2 if already loaded. psi4.core.prepare_options_for_module(arg0: str) → None¶; Sets the options module up to return options pertaining to the named argument (e.g. SCF). psi4.core.print_global_options() → None¶; Prints the currently set global (all modules) options to the output file. psi4.core.print_options() → None¶; Prints the currently set options (to the output file) for the current module. psi4.core.print_out(arg0: str) → None¶; Prints a string (using sprintf-like notation) to the output file. psi4.core.print_variables() → None¶; Prints all PSI variables that have been set internally. psi4.core.psi_top_srcdir() → str¶; Returns the location of the source code. psi4.core.psimrcc(arg0: psi::Wavefunction) → float¶; Runs the mult",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:233431,Modifiability,plugin,plugin,233431,"o certain active spaces). psi4.core.mrcc_generate_input(arg0: psi::Wavefunction, arg1: dict) → psi4.core.PsiReturnType¶; Generates an input for Kallay’s MRCC code. psi4.core.mrcc_load_densities(arg0: psi::Wavefunction, arg1: dict) → psi4.core.PsiReturnType¶; Reads in the density matrices from Kallay’s MRCC code. psi4.core.occ(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the orbital optimized CC codes. psi4.core.opt_clean() → None¶; Cleans up the optimizer’s scratch files. psi4.core.option_exists_in_module(arg0: str, arg1: str) → bool¶; Given a string of a keyword name arg1 and a particular module arg0, returns whether arg1 is a valid option for arg0. psi4.core.optking() → int¶; Runs the geometry optimization / frequency analysis code. psi4.core.outfile_name() → str¶; Returns the name of the output file. psi4.core.plugin(arg0: str, arg1: psi::Wavefunction) → psi::Wavefunction¶; Call the plugin of name arg0. Returns the plugin code result. psi4.core.plugin_close(arg0: str) → None¶; Close the plugin of name arg0. psi4.core.plugin_close_all() → None¶; Close all open plugins. psi4.core.plugin_load(arg0: str) → int¶; Load the plugin of name arg0. Returns 0 if not loaded, 1 if loaded, 2 if already loaded. psi4.core.prepare_options_for_module(arg0: str) → None¶; Sets the options module up to return options pertaining to the named argument (e.g. SCF). psi4.core.print_global_options() → None¶; Prints the currently set global (all modules) options to the output file. psi4.core.print_options() → None¶; Prints the currently set options (to the output file) for the current module. psi4.core.print_out(arg0: str) → None¶; Prints a string (using sprintf-like notation) to the output file. psi4.core.print_variables() → None¶; Prints all PSI variables that have been set internally. psi4.core.psi_top_srcdir() → str¶; Returns the location of the source code. psi4.core.psimrcc(arg0: psi::Wavefunction) → float¶; Runs the multireference coupled cluster code. psi4.core.reopen_outfile()",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:233505,Modifiability,plugin,plugins,233505,"avefunction, arg1: dict) → psi4.core.PsiReturnType¶; Generates an input for Kallay’s MRCC code. psi4.core.mrcc_load_densities(arg0: psi::Wavefunction, arg1: dict) → psi4.core.PsiReturnType¶; Reads in the density matrices from Kallay’s MRCC code. psi4.core.occ(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the orbital optimized CC codes. psi4.core.opt_clean() → None¶; Cleans up the optimizer’s scratch files. psi4.core.option_exists_in_module(arg0: str, arg1: str) → bool¶; Given a string of a keyword name arg1 and a particular module arg0, returns whether arg1 is a valid option for arg0. psi4.core.optking() → int¶; Runs the geometry optimization / frequency analysis code. psi4.core.outfile_name() → str¶; Returns the name of the output file. psi4.core.plugin(arg0: str, arg1: psi::Wavefunction) → psi::Wavefunction¶; Call the plugin of name arg0. Returns the plugin code result. psi4.core.plugin_close(arg0: str) → None¶; Close the plugin of name arg0. psi4.core.plugin_close_all() → None¶; Close all open plugins. psi4.core.plugin_load(arg0: str) → int¶; Load the plugin of name arg0. Returns 0 if not loaded, 1 if loaded, 2 if already loaded. psi4.core.prepare_options_for_module(arg0: str) → None¶; Sets the options module up to return options pertaining to the named argument (e.g. SCF). psi4.core.print_global_options() → None¶; Prints the currently set global (all modules) options to the output file. psi4.core.print_options() → None¶; Prints the currently set options (to the output file) for the current module. psi4.core.print_out(arg0: str) → None¶; Prints a string (using sprintf-like notation) to the output file. psi4.core.print_variables() → None¶; Prints all PSI variables that have been set internally. psi4.core.psi_top_srcdir() → str¶; Returns the location of the source code. psi4.core.psimrcc(arg0: psi::Wavefunction) → float¶; Runs the multireference coupled cluster code. psi4.core.reopen_outfile() → None¶; Reopens the output file. psi4.core.revoke_global_option_ch",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:233564,Modifiability,plugin,plugin,233564,"nput for Kallay’s MRCC code. psi4.core.mrcc_load_densities(arg0: psi::Wavefunction, arg1: dict) → psi4.core.PsiReturnType¶; Reads in the density matrices from Kallay’s MRCC code. psi4.core.occ(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the orbital optimized CC codes. psi4.core.opt_clean() → None¶; Cleans up the optimizer’s scratch files. psi4.core.option_exists_in_module(arg0: str, arg1: str) → bool¶; Given a string of a keyword name arg1 and a particular module arg0, returns whether arg1 is a valid option for arg0. psi4.core.optking() → int¶; Runs the geometry optimization / frequency analysis code. psi4.core.outfile_name() → str¶; Returns the name of the output file. psi4.core.plugin(arg0: str, arg1: psi::Wavefunction) → psi::Wavefunction¶; Call the plugin of name arg0. Returns the plugin code result. psi4.core.plugin_close(arg0: str) → None¶; Close the plugin of name arg0. psi4.core.plugin_close_all() → None¶; Close all open plugins. psi4.core.plugin_load(arg0: str) → int¶; Load the plugin of name arg0. Returns 0 if not loaded, 1 if loaded, 2 if already loaded. psi4.core.prepare_options_for_module(arg0: str) → None¶; Sets the options module up to return options pertaining to the named argument (e.g. SCF). psi4.core.print_global_options() → None¶; Prints the currently set global (all modules) options to the output file. psi4.core.print_options() → None¶; Prints the currently set options (to the output file) for the current module. psi4.core.print_out(arg0: str) → None¶; Prints a string (using sprintf-like notation) to the output file. psi4.core.print_variables() → None¶; Prints all PSI variables that have been set internally. psi4.core.psi_top_srcdir() → str¶; Returns the location of the source code. psi4.core.psimrcc(arg0: psi::Wavefunction) → float¶; Runs the multireference coupled cluster code. psi4.core.reopen_outfile() → None¶; Reopens the output file. psi4.core.revoke_global_option_changed(arg0: str) → None¶; Given a string of a keyword name arg1, s",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:234178,Modifiability,variab,variables,234178,"ore.outfile_name() → str¶; Returns the name of the output file. psi4.core.plugin(arg0: str, arg1: psi::Wavefunction) → psi::Wavefunction¶; Call the plugin of name arg0. Returns the plugin code result. psi4.core.plugin_close(arg0: str) → None¶; Close the plugin of name arg0. psi4.core.plugin_close_all() → None¶; Close all open plugins. psi4.core.plugin_load(arg0: str) → int¶; Load the plugin of name arg0. Returns 0 if not loaded, 1 if loaded, 2 if already loaded. psi4.core.prepare_options_for_module(arg0: str) → None¶; Sets the options module up to return options pertaining to the named argument (e.g. SCF). psi4.core.print_global_options() → None¶; Prints the currently set global (all modules) options to the output file. psi4.core.print_options() → None¶; Prints the currently set options (to the output file) for the current module. psi4.core.print_out(arg0: str) → None¶; Prints a string (using sprintf-like notation) to the output file. psi4.core.print_variables() → None¶; Prints all PSI variables that have been set internally. psi4.core.psi_top_srcdir() → str¶; Returns the location of the source code. psi4.core.psimrcc(arg0: psi::Wavefunction) → float¶; Runs the multireference coupled cluster code. psi4.core.reopen_outfile() → None¶; Reopens the output file. psi4.core.revoke_global_option_changed(arg0: str) → None¶; Given a string of a keyword name arg1, sets the has_changed attribute in the global options scope to false. Used in python driver when a function sets the value of an option. Before the function exits, this command is called on the option so that has_changed reflects whether the user (not the program) has touched the option. psi4.core.revoke_local_option_changed(arg0: str, arg1: str) → None¶; Given a string of a keyword name arg2 and a particular module arg1, sets the has_changed attribute in the module options scope to false. Used in python driver when a function sets the value of an option. Before the function exits, this command is called on the option",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:235469,Modifiability,adapt,adapted,235469,"eopens the output file. psi4.core.revoke_global_option_changed(arg0: str) → None¶; Given a string of a keyword name arg1, sets the has_changed attribute in the global options scope to false. Used in python driver when a function sets the value of an option. Before the function exits, this command is called on the option so that has_changed reflects whether the user (not the program) has touched the option. psi4.core.revoke_local_option_changed(arg0: str, arg1: str) → None¶; Given a string of a keyword name arg2 and a particular module arg1, sets the has_changed attribute in the module options scope to false. Used in python driver when a function sets the value of an option. Before the function exits, this command is called on the option so that has_changed reflects whether the user (not the program) has touched the option. psi4.core.run_gdma(arg0: psi::Wavefunction, arg1: str) → float¶; Runs the GDMA code. psi4.core.sapt(arg0: psi::Wavefunction, arg1: psi::Wavefunction, arg2: psi::Wavefunction) → float¶; Runs the symmetry adapted perturbation theory code. psi4.core.scatter(arg0: psi::Molecule, arg1: float, arg2: list, arg3: list, arg4: list) → None¶; New Scatter function. psi4.core.scfgrad(arg0: psi::Wavefunction) → psi::Matrix¶; Run scfgrad, which is a specialized DF-SCF gradient program. psi4.core.scfhess(arg0: psi::Wavefunction) → psi::Matrix¶; Run scfhess, which is a specialized DF-SCF hessian program. psi4.core.set_active_molecule(arg0: psi::Molecule) → None¶; Activates a previously defined (in the input) molecule, by name. psi4.core.set_array_variable(arg0: str, arg1: psi::Matrix) → None¶; Sets a PSI variable, by name. psi4.core.set_datadir(arg0: str) → None¶; Returns the amount of memory available to Psi (in bytes). psi4.core.set_efp_torque(arg0: psi::Matrix) → None¶; Assigns the global EFP gradient to the values stored in the Nefp by 6 Matrix argument. psi4.core.set_frequencies(arg0: psi::Vector) → None¶; Assigns the global frequencies to the values stored in",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:236065,Modifiability,variab,variable,236065," false. Used in python driver when a function sets the value of an option. Before the function exits, this command is called on the option so that has_changed reflects whether the user (not the program) has touched the option. psi4.core.run_gdma(arg0: psi::Wavefunction, arg1: str) → float¶; Runs the GDMA code. psi4.core.sapt(arg0: psi::Wavefunction, arg1: psi::Wavefunction, arg2: psi::Wavefunction) → float¶; Runs the symmetry adapted perturbation theory code. psi4.core.scatter(arg0: psi::Molecule, arg1: float, arg2: list, arg3: list, arg4: list) → None¶; New Scatter function. psi4.core.scfgrad(arg0: psi::Wavefunction) → psi::Matrix¶; Run scfgrad, which is a specialized DF-SCF gradient program. psi4.core.scfhess(arg0: psi::Wavefunction) → psi::Matrix¶; Run scfhess, which is a specialized DF-SCF hessian program. psi4.core.set_active_molecule(arg0: psi::Molecule) → None¶; Activates a previously defined (in the input) molecule, by name. psi4.core.set_array_variable(arg0: str, arg1: psi::Matrix) → None¶; Sets a PSI variable, by name. psi4.core.set_datadir(arg0: str) → None¶; Returns the amount of memory available to Psi (in bytes). psi4.core.set_efp_torque(arg0: psi::Matrix) → None¶; Assigns the global EFP gradient to the values stored in the Nefp by 6 Matrix argument. psi4.core.set_frequencies(arg0: psi::Vector) → None¶; Assigns the global frequencies to the values stored in the 3N-6 Vector argument. psi4.core.set_global_option(*args, **kwargs)¶; Overloaded function. set_global_option(arg0: str, arg1: list) -> bool. Sets value arg2 to array keyword arg1 for all modules. set_global_option(arg0: str, arg1: int) -> bool. Sets value arg2 to integer keyword arg1 for all modules. set_global_option(arg0: str, arg1: float) -> bool. Sets value arg2 to double keyword arg1 for all modules. set_global_option(arg0: str, arg1: str) -> bool. Sets value arg2 to string keyword arg1 for all modules. psi4.core.set_gradient(arg0: psi::Matrix) → None¶; Assigns the global gradient to the valu",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:238808,Modifiability,variab,variable,238808,"ord arg2 scoped only to a specific module arg1. set_local_option(arg0: str, arg1: str, arg2: str) -> bool. Sets value arg3 to string keyword arg2 scoped only to a specific module arg1. psi4.core.set_local_option_python(arg0: str, arg1: object) → None¶; Sets an option to a Python object, but scoped only to a single module. psi4.core.set_memory_bytes(memory: int, quiet: bool=False) → None¶; Sets the memory available to Psi (in bytes). psi4.core.set_num_threads(nthread: int, quiet: bool=False) → None¶; Sets the number of threads to use in SMP parallel computations. psi4.core.set_output_file(*args, **kwargs)¶; Overloaded function. set_output_file(arg0: str) -> None; set_output_file(arg0: str, arg1: bool) -> None. psi4.core.set_parent_symmetry(arg0: str) → None¶; Sets the symmetry of the ‘parent’ (undisplaced) geometry, by Schoenflies symbol, at the beginning of a finite difference computation. psi4.core.set_psi_file_prefix(arg0: str) → None¶. psi4.core.set_variable(arg0: str, arg1: float) → None¶; Sets a PSI variable, by name. psi4.core.tstart() → None¶; docstring. psi4.core.tstop() → None¶; docstring. psi4.core.version() → str¶; Returns the version ID of this copy of Psi. Functions¶. DASUM(arg0, arg1, arg2, arg3); docstring. DAXPY(arg0, arg1, arg2, arg3, arg4, arg5, arg6); docstring. DCOPY(arg0, arg1, arg2, arg3, arg4, arg5); docstring. DDOT(arg0, arg1, arg2, arg3, arg4, arg5); docstring. DGBMV(arg0, arg1, arg2, arg3, arg4, arg5, …); docstring. DGEEV(arg0, arg1, arg2, arg3, arg4, arg5, …); docstring. DGEMM(arg0, arg1, arg2, arg3, arg4, arg5, …); docstring. DGEMV(arg0, arg1, arg2, arg3, arg4, arg5, …); docstring. DGER(arg0, arg1, arg2, arg3, arg4, arg5, …); docstring. DGETRF(arg0, arg1, arg2, arg3, arg4, arg5); docstring. DGETRI(arg0, arg1, arg2, arg3, arg4, arg5, arg6); docstring. DGETRS(arg0, arg1, arg2, arg3, arg4, arg5, …); docstring. DNRM2(arg0, arg1, arg2, arg3); docstring. DPOTRF(arg0, arg1, arg2, arg3, arg4); docstring. DPOTRI(arg0, arg1, arg2, arg3, arg4); docst",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:242109,Modifiability,variab,variables,242109,"irects output to /dev/null. benchmark_blas1(arg0, arg1); docstring. benchmark_blas2(arg0, arg1); docstring. benchmark_blas3(arg0, arg1, arg2); docstring. benchmark_disk(arg0, arg1); docstring. benchmark_integrals(arg0, arg1); docstring. benchmark_math(arg0); docstring. ccdensity(arg0); Runs the code to compute coupled cluster density matrices. ccenergy(arg0); Runs the coupled cluster energy code. cceom(arg0); Runs the equation of motion coupled cluster code, for excited states. cchbar(arg0); Runs the code to generate the similarity transformed Hamiltonian. cclambda(arg0); Runs the coupled cluster lambda equations code. ccresponse(arg0); Runs the coupled cluster response theory code. cctransort(arg0); Runs CCTRANSORT, which transforms and reorders integrals for use in the coupled cluster codes. cctriples(arg0); Runs the coupled cluster (T) energy code. clean(); Function to remove scratch files. clean_options(); Function to reset options to clean state. clean_variables(); Empties all PSI variables that have set internally. close_outfile(); Closes the output file. dcft(arg0); Runs the density cumulant functional theory code. detci(arg0); Runs the determinant-based configuration interaction code. dfmp2(arg0); Runs the DF-MP2 code. dfocc(arg0); Runs the density-fitted orbital optimized CC codes. displace_atom(arg0, arg1, arg2, arg3, arg4); Displaces one coordinate of single atom. dmrg(arg0); Runs the DMRG code. efp_init(); Initializes the EFP library and returns an EFP object. efp_set_options(); Set EFP options from environment options object. fcidump_tei_helper(nirrep, restricted, …); Write integrals to file in FCIDUMP format. fd_1_0(arg0, arg1); Performs a finite difference gradient computation, from energy points. fd_freq_0(arg0, arg1, arg2); Performs a finite difference frequency computation, from energy points, for a given irrep. fd_freq_1(arg0, arg1, arg2); Performs a finite difference frequency computation, from gradients, for a given irrep. fd_geoms_1_0(arg0); Get",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:242288,Modifiability,config,configuration,242288,"arg1); docstring. benchmark_integrals(arg0, arg1); docstring. benchmark_math(arg0); docstring. ccdensity(arg0); Runs the code to compute coupled cluster density matrices. ccenergy(arg0); Runs the coupled cluster energy code. cceom(arg0); Runs the equation of motion coupled cluster code, for excited states. cchbar(arg0); Runs the code to generate the similarity transformed Hamiltonian. cclambda(arg0); Runs the coupled cluster lambda equations code. ccresponse(arg0); Runs the coupled cluster response theory code. cctransort(arg0); Runs CCTRANSORT, which transforms and reorders integrals for use in the coupled cluster codes. cctriples(arg0); Runs the coupled cluster (T) energy code. clean(); Function to remove scratch files. clean_options(); Function to reset options to clean state. clean_variables(); Empties all PSI variables that have set internally. close_outfile(); Closes the output file. dcft(arg0); Runs the density cumulant functional theory code. detci(arg0); Runs the determinant-based configuration interaction code. dfmp2(arg0); Runs the DF-MP2 code. dfocc(arg0); Runs the density-fitted orbital optimized CC codes. displace_atom(arg0, arg1, arg2, arg3, arg4); Displaces one coordinate of single atom. dmrg(arg0); Runs the DMRG code. efp_init(); Initializes the EFP library and returns an EFP object. efp_set_options(); Set EFP options from environment options object. fcidump_tei_helper(nirrep, restricted, …); Write integrals to file in FCIDUMP format. fd_1_0(arg0, arg1); Performs a finite difference gradient computation, from energy points. fd_freq_0(arg0, arg1, arg2); Performs a finite difference frequency computation, from energy points, for a given irrep. fd_freq_1(arg0, arg1, arg2); Performs a finite difference frequency computation, from gradients, for a given irrep. fd_geoms_1_0(arg0); Gets list of displacements needed for a finite difference gradient computation, from energy points. fd_geoms_freq_0(arg0, arg1); Gets list of displacements needed for a finite d",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:243796,Modifiability,variab,variables,243796,"on, from energy points. fd_freq_0(arg0, arg1, arg2); Performs a finite difference frequency computation, from energy points, for a given irrep. fd_freq_1(arg0, arg1, arg2); Performs a finite difference frequency computation, from gradients, for a given irrep. fd_geoms_1_0(arg0); Gets list of displacements needed for a finite difference gradient computation, from energy points. fd_geoms_freq_0(arg0, arg1); Gets list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep. fd_geoms_freq_1(arg0, arg1); Gets list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep. finalize(). flush_outfile(); Flushes the output file. fnocc(arg0); Runs the fno-ccsd(t)/qcisd(t)/mp4/cepa energy code. get_active_efp(); Returns the currently active EFP object. get_active_molecule(); Returns the currently active molecule object. get_array_variable(arg0); Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available). get_array_variables(); Returns dictionary of the PSI variables set internally by the modules or python driver. get_atomic_point_charges(); Returns the most recently computed atomic point charges, as a double * object. get_datadir(); Sets the path to shared text resources, PSIDATADIR. get_efp_torque(); Returns the most recently computed gradient for the EFP portion, as a Nefp by 6 Matrix object. get_frequencies(); Returns the most recently computed frequencies, as a 3N-6 Vector object. get_global_option(arg0); Given a string of a keyword name arg1, returns the value associated with the keyword from the global options. get_global_option_list(); Returns a list of all global options. get_gradient(); Returns the most recently computed gradient, as a N by 3 Matrix object. get_legacy_molecule(); Returns the currently active molecule object. get_local_option(arg0, arg1); Given a string of a keyword name arg2 and a",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:243885,Modifiability,variab,variables,243885,"on, from energy points. fd_freq_0(arg0, arg1, arg2); Performs a finite difference frequency computation, from energy points, for a given irrep. fd_freq_1(arg0, arg1, arg2); Performs a finite difference frequency computation, from gradients, for a given irrep. fd_geoms_1_0(arg0); Gets list of displacements needed for a finite difference gradient computation, from energy points. fd_geoms_freq_0(arg0, arg1); Gets list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep. fd_geoms_freq_1(arg0, arg1); Gets list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep. finalize(). flush_outfile(); Flushes the output file. fnocc(arg0); Runs the fno-ccsd(t)/qcisd(t)/mp4/cepa energy code. get_active_efp(); Returns the currently active EFP object. get_active_molecule(); Returns the currently active molecule object. get_array_variable(arg0); Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available). get_array_variables(); Returns dictionary of the PSI variables set internally by the modules or python driver. get_atomic_point_charges(); Returns the most recently computed atomic point charges, as a double * object. get_datadir(); Sets the path to shared text resources, PSIDATADIR. get_efp_torque(); Returns the most recently computed gradient for the EFP portion, as a Nefp by 6 Matrix object. get_frequencies(); Returns the most recently computed frequencies, as a 3N-6 Vector object. get_global_option(arg0); Given a string of a keyword name arg1, returns the value associated with the keyword from the global options. get_global_option_list(); Returns a list of all global options. get_gradient(); Returns the most recently computed gradient, as a N by 3 Matrix object. get_legacy_molecule(); Returns the currently active molecule object. get_local_option(arg0, arg1); Given a string of a keyword name arg2 and a",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:243960,Modifiability,variab,variables,243960,"n irrep. fd_freq_1(arg0, arg1, arg2); Performs a finite difference frequency computation, from gradients, for a given irrep. fd_geoms_1_0(arg0); Gets list of displacements needed for a finite difference gradient computation, from energy points. fd_geoms_freq_0(arg0, arg1); Gets list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep. fd_geoms_freq_1(arg0, arg1); Gets list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep. finalize(). flush_outfile(); Flushes the output file. fnocc(arg0); Runs the fno-ccsd(t)/qcisd(t)/mp4/cepa energy code. get_active_efp(); Returns the currently active EFP object. get_active_molecule(); Returns the currently active molecule object. get_array_variable(arg0); Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available). get_array_variables(); Returns dictionary of the PSI variables set internally by the modules or python driver. get_atomic_point_charges(); Returns the most recently computed atomic point charges, as a double * object. get_datadir(); Sets the path to shared text resources, PSIDATADIR. get_efp_torque(); Returns the most recently computed gradient for the EFP portion, as a Nefp by 6 Matrix object. get_frequencies(); Returns the most recently computed frequencies, as a 3N-6 Vector object. get_global_option(arg0); Given a string of a keyword name arg1, returns the value associated with the keyword from the global options. get_global_option_list(); Returns a list of all global options. get_gradient(); Returns the most recently computed gradient, as a N by 3 Matrix object. get_legacy_molecule(); Returns the currently active molecule object. get_local_option(arg0, arg1); Given a string of a keyword name arg2 and a particular module arg1, returns the value associated with the keyword in the module options scope. get_memory(); Returns the amount of ",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:245411,Modifiability,variab,variables,245411,"yword name arg1, returns the value associated with the keyword from the global options. get_global_option_list(); Returns a list of all global options. get_gradient(); Returns the most recently computed gradient, as a N by 3 Matrix object. get_legacy_molecule(); Returns the currently active molecule object. get_local_option(arg0, arg1); Given a string of a keyword name arg2 and a particular module arg1, returns the value associated with the keyword in the module options scope. get_memory(); Returns the amount of memory available to Psi (in bytes). get_num_threads(); Returns the number of threads to use in SMP parallel computations. get_option(arg0, arg1); Given a string of a keyword name arg2 and a particular module arg1, returns the local value associated with the keyword if it’s been set, else the global value if it’s been set, else the local core.default value. get_options(); Get options. get_output_file(). get_variable(arg0); Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available). get_variables(); Returns dictionary of the PSI variables set internally by the modules or python driver. get_writer_file_prefix(arg0); Returns the prefix to use for writing files for external programs. git_version(); Returns the git version of this copy of Psi. has_global_option_changed(arg0); Returns boolean for whether the keyword arg1 has been touched in the global scope, by either user or code. has_local_option_changed(arg0, arg1); Returns boolean for whether the keyword arg2 has been touched in the scope of the specified module arg1, by either user or code. has_option_changed(arg0, arg1); Returns boolean for whether the option arg2 has been touched either locally to the specified module arg1 or globally, by either user or code. has_variable(arg0); Returns true if the PSI variable exists/is set. initialize(). legacy_wavefunction(); Returns the current legacy_wavefunction object from the most recent comput",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:245500,Modifiability,variab,variables,245500,"yword name arg1, returns the value associated with the keyword from the global options. get_global_option_list(); Returns a list of all global options. get_gradient(); Returns the most recently computed gradient, as a N by 3 Matrix object. get_legacy_molecule(); Returns the currently active molecule object. get_local_option(arg0, arg1); Given a string of a keyword name arg2 and a particular module arg1, returns the value associated with the keyword in the module options scope. get_memory(); Returns the amount of memory available to Psi (in bytes). get_num_threads(); Returns the number of threads to use in SMP parallel computations. get_option(arg0, arg1); Given a string of a keyword name arg2 and a particular module arg1, returns the local value associated with the keyword if it’s been set, else the global value if it’s been set, else the local core.default value. get_options(); Get options. get_output_file(). get_variable(arg0); Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available). get_variables(); Returns dictionary of the PSI variables set internally by the modules or python driver. get_writer_file_prefix(arg0); Returns the prefix to use for writing files for external programs. git_version(); Returns the git version of this copy of Psi. has_global_option_changed(arg0); Returns boolean for whether the keyword arg1 has been touched in the global scope, by either user or code. has_local_option_changed(arg0, arg1); Returns boolean for whether the keyword arg2 has been touched in the scope of the specified module arg1, by either user or code. has_option_changed(arg0, arg1); Returns boolean for whether the option arg2 has been touched either locally to the specified module arg1 or globally, by either user or code. has_variable(arg0); Returns true if the PSI variable exists/is set. initialize(). legacy_wavefunction(); Returns the current legacy_wavefunction object from the most recent comput",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:245569,Modifiability,variab,variables,245569,"of all global options. get_gradient(); Returns the most recently computed gradient, as a N by 3 Matrix object. get_legacy_molecule(); Returns the currently active molecule object. get_local_option(arg0, arg1); Given a string of a keyword name arg2 and a particular module arg1, returns the value associated with the keyword in the module options scope. get_memory(); Returns the amount of memory available to Psi (in bytes). get_num_threads(); Returns the number of threads to use in SMP parallel computations. get_option(arg0, arg1); Given a string of a keyword name arg2 and a particular module arg1, returns the local value associated with the keyword if it’s been set, else the global value if it’s been set, else the local core.default value. get_options(); Get options. get_output_file(). get_variable(arg0); Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available). get_variables(); Returns dictionary of the PSI variables set internally by the modules or python driver. get_writer_file_prefix(arg0); Returns the prefix to use for writing files for external programs. git_version(); Returns the git version of this copy of Psi. has_global_option_changed(arg0); Returns boolean for whether the keyword arg1 has been touched in the global scope, by either user or code. has_local_option_changed(arg0, arg1); Returns boolean for whether the keyword arg2 has been touched in the scope of the specified module arg1, by either user or code. has_option_changed(arg0, arg1); Returns boolean for whether the option arg2 has been touched either locally to the specified module arg1 or globally, by either user or code. has_variable(arg0); Returns true if the PSI variable exists/is set. initialize(). legacy_wavefunction(); Returns the current legacy_wavefunction object from the most recent computation. libfock(arg0); Runs a CPHF calculation, using libfock. mcscf(arg0); Runs the MCSCF code, (N.B. mrcc_generate_input(arg0, ar",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:246309,Modifiability,variab,variable,246309,"al core.default value. get_options(); Get options. get_output_file(). get_variable(arg0); Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available). get_variables(); Returns dictionary of the PSI variables set internally by the modules or python driver. get_writer_file_prefix(arg0); Returns the prefix to use for writing files for external programs. git_version(); Returns the git version of this copy of Psi. has_global_option_changed(arg0); Returns boolean for whether the keyword arg1 has been touched in the global scope, by either user or code. has_local_option_changed(arg0, arg1); Returns boolean for whether the keyword arg2 has been touched in the scope of the specified module arg1, by either user or code. has_option_changed(arg0, arg1); Returns boolean for whether the option arg2 has been touched either locally to the specified module arg1 or globally, by either user or code. has_variable(arg0); Returns true if the PSI variable exists/is set. initialize(). legacy_wavefunction(); Returns the current legacy_wavefunction object from the most recent computation. libfock(arg0); Runs a CPHF calculation, using libfock. mcscf(arg0); Runs the MCSCF code, (N.B. mrcc_generate_input(arg0, arg1); Generates an input for Kallay’s MRCC code. mrcc_load_densities(arg0, arg1); Reads in the density matrices from Kallay’s MRCC code. occ(arg0); Runs the orbital optimized CC codes. opt_clean(); Cleans up the optimizer’s scratch files. option_exists_in_module(arg0, arg1); Given a string of a keyword name arg1 and a particular module arg0, returns whether arg1 is a valid option for arg0. optking(); Runs the geometry optimization / frequency analysis code. outfile_name(); Returns the name of the output file. plugin(arg0, arg1); Call the plugin of name arg0. plugin_close(arg0); Close the plugin of name arg0. plugin_close_all(); Close all open plugins. plugin_load(arg0); Load the plugin of name arg0. prepare_options_",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:247088,Modifiability,plugin,plugin,247088,"g0, arg1); Returns boolean for whether the option arg2 has been touched either locally to the specified module arg1 or globally, by either user or code. has_variable(arg0); Returns true if the PSI variable exists/is set. initialize(). legacy_wavefunction(); Returns the current legacy_wavefunction object from the most recent computation. libfock(arg0); Runs a CPHF calculation, using libfock. mcscf(arg0); Runs the MCSCF code, (N.B. mrcc_generate_input(arg0, arg1); Generates an input for Kallay’s MRCC code. mrcc_load_densities(arg0, arg1); Reads in the density matrices from Kallay’s MRCC code. occ(arg0); Runs the orbital optimized CC codes. opt_clean(); Cleans up the optimizer’s scratch files. option_exists_in_module(arg0, arg1); Given a string of a keyword name arg1 and a particular module arg0, returns whether arg1 is a valid option for arg0. optking(); Runs the geometry optimization / frequency analysis code. outfile_name(); Returns the name of the output file. plugin(arg0, arg1); Call the plugin of name arg0. plugin_close(arg0); Close the plugin of name arg0. plugin_close_all(); Close all open plugins. plugin_load(arg0); Load the plugin of name arg0. prepare_options_for_module(arg0); Sets the options module up to return options pertaining to the named argument (e.g. print_global_options(); Prints the currently set global (all modules) options to the output file. print_options(); Prints the currently set options (to the output file) for the current module. print_out(arg0); Prints a string (using sprintf-like notation) to the output file. print_variables(); Prints all PSI variables that have been set internally. psi_top_srcdir(); Returns the location of the source code. psimrcc(arg0); Runs the multireference coupled cluster code. reopen_outfile(); Reopens the output file. revoke_global_option_changed(arg0); Given a string of a keyword name arg1, sets the has_changed attribute in the global options scope to false. revoke_local_option_changed(arg0, arg1); Given a strin",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:247117,Modifiability,plugin,plugin,247117,"g0, arg1); Returns boolean for whether the option arg2 has been touched either locally to the specified module arg1 or globally, by either user or code. has_variable(arg0); Returns true if the PSI variable exists/is set. initialize(). legacy_wavefunction(); Returns the current legacy_wavefunction object from the most recent computation. libfock(arg0); Runs a CPHF calculation, using libfock. mcscf(arg0); Runs the MCSCF code, (N.B. mrcc_generate_input(arg0, arg1); Generates an input for Kallay’s MRCC code. mrcc_load_densities(arg0, arg1); Reads in the density matrices from Kallay’s MRCC code. occ(arg0); Runs the orbital optimized CC codes. opt_clean(); Cleans up the optimizer’s scratch files. option_exists_in_module(arg0, arg1); Given a string of a keyword name arg1 and a particular module arg0, returns whether arg1 is a valid option for arg0. optking(); Runs the geometry optimization / frequency analysis code. outfile_name(); Returns the name of the output file. plugin(arg0, arg1); Call the plugin of name arg0. plugin_close(arg0); Close the plugin of name arg0. plugin_close_all(); Close all open plugins. plugin_load(arg0); Load the plugin of name arg0. prepare_options_for_module(arg0); Sets the options module up to return options pertaining to the named argument (e.g. print_global_options(); Prints the currently set global (all modules) options to the output file. print_options(); Prints the currently set options (to the output file) for the current module. print_out(arg0); Prints a string (using sprintf-like notation) to the output file. print_variables(); Prints all PSI variables that have been set internally. psi_top_srcdir(); Returns the location of the source code. psimrcc(arg0); Runs the multireference coupled cluster code. reopen_outfile(); Reopens the output file. revoke_global_option_changed(arg0); Given a string of a keyword name arg1, sets the has_changed attribute in the global options scope to false. revoke_local_option_changed(arg0, arg1); Given a strin",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:247168,Modifiability,plugin,plugin,247168,"arg2 has been touched either locally to the specified module arg1 or globally, by either user or code. has_variable(arg0); Returns true if the PSI variable exists/is set. initialize(). legacy_wavefunction(); Returns the current legacy_wavefunction object from the most recent computation. libfock(arg0); Runs a CPHF calculation, using libfock. mcscf(arg0); Runs the MCSCF code, (N.B. mrcc_generate_input(arg0, arg1); Generates an input for Kallay’s MRCC code. mrcc_load_densities(arg0, arg1); Reads in the density matrices from Kallay’s MRCC code. occ(arg0); Runs the orbital optimized CC codes. opt_clean(); Cleans up the optimizer’s scratch files. option_exists_in_module(arg0, arg1); Given a string of a keyword name arg1 and a particular module arg0, returns whether arg1 is a valid option for arg0. optking(); Runs the geometry optimization / frequency analysis code. outfile_name(); Returns the name of the output file. plugin(arg0, arg1); Call the plugin of name arg0. plugin_close(arg0); Close the plugin of name arg0. plugin_close_all(); Close all open plugins. plugin_load(arg0); Load the plugin of name arg0. prepare_options_for_module(arg0); Sets the options module up to return options pertaining to the named argument (e.g. print_global_options(); Prints the currently set global (all modules) options to the output file. print_options(); Prints the currently set options (to the output file) for the current module. print_out(arg0); Prints a string (using sprintf-like notation) to the output file. print_variables(); Prints all PSI variables that have been set internally. psi_top_srcdir(); Returns the location of the source code. psimrcc(arg0); Runs the multireference coupled cluster code. reopen_outfile(); Reopens the output file. revoke_global_option_changed(arg0); Given a string of a keyword name arg1, sets the has_changed attribute in the global options scope to false. revoke_local_option_changed(arg0, arg1); Given a string of a keyword name arg2 and a particular module ar",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:247224,Modifiability,plugin,plugins,247224,"ified module arg1 or globally, by either user or code. has_variable(arg0); Returns true if the PSI variable exists/is set. initialize(). legacy_wavefunction(); Returns the current legacy_wavefunction object from the most recent computation. libfock(arg0); Runs a CPHF calculation, using libfock. mcscf(arg0); Runs the MCSCF code, (N.B. mrcc_generate_input(arg0, arg1); Generates an input for Kallay’s MRCC code. mrcc_load_densities(arg0, arg1); Reads in the density matrices from Kallay’s MRCC code. occ(arg0); Runs the orbital optimized CC codes. opt_clean(); Cleans up the optimizer’s scratch files. option_exists_in_module(arg0, arg1); Given a string of a keyword name arg1 and a particular module arg0, returns whether arg1 is a valid option for arg0. optking(); Runs the geometry optimization / frequency analysis code. outfile_name(); Returns the name of the output file. plugin(arg0, arg1); Call the plugin of name arg0. plugin_close(arg0); Close the plugin of name arg0. plugin_close_all(); Close all open plugins. plugin_load(arg0); Load the plugin of name arg0. prepare_options_for_module(arg0); Sets the options module up to return options pertaining to the named argument (e.g. print_global_options(); Prints the currently set global (all modules) options to the output file. print_options(); Prints the currently set options (to the output file) for the current module. print_out(arg0); Prints a string (using sprintf-like notation) to the output file. print_variables(); Prints all PSI variables that have been set internally. psi_top_srcdir(); Returns the location of the source code. psimrcc(arg0); Runs the multireference coupled cluster code. reopen_outfile(); Reopens the output file. revoke_global_option_changed(arg0); Given a string of a keyword name arg1, sets the has_changed attribute in the global options scope to false. revoke_local_option_changed(arg0, arg1); Given a string of a keyword name arg2 and a particular module arg1, sets the has_changed attribute in the modul",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:247261,Modifiability,plugin,plugin,247261,"or code. has_variable(arg0); Returns true if the PSI variable exists/is set. initialize(). legacy_wavefunction(); Returns the current legacy_wavefunction object from the most recent computation. libfock(arg0); Runs a CPHF calculation, using libfock. mcscf(arg0); Runs the MCSCF code, (N.B. mrcc_generate_input(arg0, arg1); Generates an input for Kallay’s MRCC code. mrcc_load_densities(arg0, arg1); Reads in the density matrices from Kallay’s MRCC code. occ(arg0); Runs the orbital optimized CC codes. opt_clean(); Cleans up the optimizer’s scratch files. option_exists_in_module(arg0, arg1); Given a string of a keyword name arg1 and a particular module arg0, returns whether arg1 is a valid option for arg0. optking(); Runs the geometry optimization / frequency analysis code. outfile_name(); Returns the name of the output file. plugin(arg0, arg1); Call the plugin of name arg0. plugin_close(arg0); Close the plugin of name arg0. plugin_close_all(); Close all open plugins. plugin_load(arg0); Load the plugin of name arg0. prepare_options_for_module(arg0); Sets the options module up to return options pertaining to the named argument (e.g. print_global_options(); Prints the currently set global (all modules) options to the output file. print_options(); Prints the currently set options (to the output file) for the current module. print_out(arg0); Prints a string (using sprintf-like notation) to the output file. print_variables(); Prints all PSI variables that have been set internally. psi_top_srcdir(); Returns the location of the source code. psimrcc(arg0); Runs the multireference coupled cluster code. reopen_outfile(); Reopens the output file. revoke_global_option_changed(arg0); Given a string of a keyword name arg1, sets the has_changed attribute in the global options scope to false. revoke_local_option_changed(arg0, arg1); Given a string of a keyword name arg2 and a particular module arg1, sets the has_changed attribute in the module options scope to false. run_gdma(arg0, arg1);",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:247710,Modifiability,variab,variables,247710,"c(arg0); Runs the orbital optimized CC codes. opt_clean(); Cleans up the optimizer’s scratch files. option_exists_in_module(arg0, arg1); Given a string of a keyword name arg1 and a particular module arg0, returns whether arg1 is a valid option for arg0. optking(); Runs the geometry optimization / frequency analysis code. outfile_name(); Returns the name of the output file. plugin(arg0, arg1); Call the plugin of name arg0. plugin_close(arg0); Close the plugin of name arg0. plugin_close_all(); Close all open plugins. plugin_load(arg0); Load the plugin of name arg0. prepare_options_for_module(arg0); Sets the options module up to return options pertaining to the named argument (e.g. print_global_options(); Prints the currently set global (all modules) options to the output file. print_options(); Prints the currently set options (to the output file) for the current module. print_out(arg0); Prints a string (using sprintf-like notation) to the output file. print_variables(); Prints all PSI variables that have been set internally. psi_top_srcdir(); Returns the location of the source code. psimrcc(arg0); Runs the multireference coupled cluster code. reopen_outfile(); Reopens the output file. revoke_global_option_changed(arg0); Given a string of a keyword name arg1, sets the has_changed attribute in the global options scope to false. revoke_local_option_changed(arg0, arg1); Given a string of a keyword name arg2 and a particular module arg1, sets the has_changed attribute in the module options scope to false. run_gdma(arg0, arg1); Runs the GDMA code. sapt(arg0, arg1, arg2); Runs the symmetry adapted perturbation theory code. scatter(arg0, arg1, arg2, arg3, arg4); New Scatter function. scfgrad(arg0); Run scfgrad, which is a specialized DF-SCF gradient program. scfhess(arg0); Run scfhess, which is a specialized DF-SCF hessian program. set_active_molecule(arg0); Activates a previously defined (in the input) molecule, by name. set_array_variable(arg0, arg1); Sets a PSI variable, by",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:248320,Modifiability,adapt,adapted,248320," Sets the options module up to return options pertaining to the named argument (e.g. print_global_options(); Prints the currently set global (all modules) options to the output file. print_options(); Prints the currently set options (to the output file) for the current module. print_out(arg0); Prints a string (using sprintf-like notation) to the output file. print_variables(); Prints all PSI variables that have been set internally. psi_top_srcdir(); Returns the location of the source code. psimrcc(arg0); Runs the multireference coupled cluster code. reopen_outfile(); Reopens the output file. revoke_global_option_changed(arg0); Given a string of a keyword name arg1, sets the has_changed attribute in the global options scope to false. revoke_local_option_changed(arg0, arg1); Given a string of a keyword name arg2 and a particular module arg1, sets the has_changed attribute in the module options scope to false. run_gdma(arg0, arg1); Runs the GDMA code. sapt(arg0, arg1, arg2); Runs the symmetry adapted perturbation theory code. scatter(arg0, arg1, arg2, arg3, arg4); New Scatter function. scfgrad(arg0); Run scfgrad, which is a specialized DF-SCF gradient program. scfhess(arg0); Run scfhess, which is a specialized DF-SCF hessian program. set_active_molecule(arg0); Activates a previously defined (in the input) molecule, by name. set_array_variable(arg0, arg1); Sets a PSI variable, by name. set_datadir(arg0); Returns the amount of memory available to Psi (in bytes). set_efp_torque(arg0); Assigns the global EFP gradient to the values stored in the Nefp by 6 Matrix argument. set_frequencies(arg0); Assigns the global frequencies to the values stored in the 3N-6 Vector argument. set_global_option(*args, **kwargs); Overloaded function. set_global_option_python(key, EXTERN); This is a fairly hacky way to get around EXTERN issues. set_gradient(arg0); Assigns the global gradient to the values stored in the N by 3 Matrix argument. set_legacy_molecule(arg0); Activates a previously def",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:248701,Modifiability,variab,variable,248701,"les(); Prints all PSI variables that have been set internally. psi_top_srcdir(); Returns the location of the source code. psimrcc(arg0); Runs the multireference coupled cluster code. reopen_outfile(); Reopens the output file. revoke_global_option_changed(arg0); Given a string of a keyword name arg1, sets the has_changed attribute in the global options scope to false. revoke_local_option_changed(arg0, arg1); Given a string of a keyword name arg2 and a particular module arg1, sets the has_changed attribute in the module options scope to false. run_gdma(arg0, arg1); Runs the GDMA code. sapt(arg0, arg1, arg2); Runs the symmetry adapted perturbation theory code. scatter(arg0, arg1, arg2, arg3, arg4); New Scatter function. scfgrad(arg0); Run scfgrad, which is a specialized DF-SCF gradient program. scfhess(arg0); Run scfhess, which is a specialized DF-SCF hessian program. set_active_molecule(arg0); Activates a previously defined (in the input) molecule, by name. set_array_variable(arg0, arg1); Sets a PSI variable, by name. set_datadir(arg0); Returns the amount of memory available to Psi (in bytes). set_efp_torque(arg0); Assigns the global EFP gradient to the values stored in the Nefp by 6 Matrix argument. set_frequencies(arg0); Assigns the global frequencies to the values stored in the 3N-6 Vector argument. set_global_option(*args, **kwargs); Overloaded function. set_global_option_python(key, EXTERN); This is a fairly hacky way to get around EXTERN issues. set_gradient(arg0); Assigns the global gradient to the values stored in the N by 3 Matrix argument. set_legacy_molecule(arg0); Activates a previously defined (in the input) molecule, by name. set_legacy_wavefunction(arg0); Returns the current legacy_wavefunction object from the most recent computation. set_local_option(*args, **kwargs); Overloaded function. set_local_option_python(arg0, arg1); Sets an option to a Python object, but scoped only to a single module. set_memory_bytes(memory, quiet); Sets the memory available",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:250085,Modifiability,variab,variable,250085,"al_option_python(key, EXTERN); This is a fairly hacky way to get around EXTERN issues. set_gradient(arg0); Assigns the global gradient to the values stored in the N by 3 Matrix argument. set_legacy_molecule(arg0); Activates a previously defined (in the input) molecule, by name. set_legacy_wavefunction(arg0); Returns the current legacy_wavefunction object from the most recent computation. set_local_option(*args, **kwargs); Overloaded function. set_local_option_python(arg0, arg1); Sets an option to a Python object, but scoped only to a single module. set_memory_bytes(memory, quiet); Sets the memory available to Psi (in bytes). set_num_threads(nthread, quiet); Sets the number of threads to use in SMP parallel computations. set_output_file(*args, **kwargs); Overloaded function. set_parent_symmetry(arg0); Sets the symmetry of the ‘parent’ (undisplaced) geometry, by Schoenflies symbol, at the beginning of a finite difference computation. set_psi_file_prefix(arg0). set_variable(arg0, arg1); Sets a PSI variable, by name. tstart(); docstring. tstop(); docstring. version(); Returns the version ID of this copy of Psi. Classes¶. AOShellCombinationsIterator. AngularMomentumInt; Computes angular momentum integrals. BSVec. BasisExtents; docstring. BasisFunctions; docstring. BasisSet; Contains basis set information. BlockOPoints; docstring. BoysLocalizer; Performs Boys orbital localization. CIVector; docstring. CIWavefunction; docstring. CUHF; docstring. CdSalcList; Class for generating symmetry adapted linear combinations of Cartesian displacements. CorrelationFactor; docstring. CorrelationTable; Provides a correlation table between two point groups. CubeProperties; docstring. DFEP2Wavefunction; A density-fitted second-order Electron Propagator Wavefunction. DFHelper; docstring. DFSOMCSCF; docstring. DFTGrid; docstring. DFTensor; docstring. Deriv; Computes gradients of wavefunctions. DiagonalizeOrder; Defines ordering of eigenvalues after diagonalization. Dimension; Initializes an",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:250580,Modifiability,adapt,adapted,250580,"object, but scoped only to a single module. set_memory_bytes(memory, quiet); Sets the memory available to Psi (in bytes). set_num_threads(nthread, quiet); Sets the number of threads to use in SMP parallel computations. set_output_file(*args, **kwargs); Overloaded function. set_parent_symmetry(arg0); Sets the symmetry of the ‘parent’ (undisplaced) geometry, by Schoenflies symbol, at the beginning of a finite difference computation. set_psi_file_prefix(arg0). set_variable(arg0, arg1); Sets a PSI variable, by name. tstart(); docstring. tstop(); docstring. version(); Returns the version ID of this copy of Psi. Classes¶. AOShellCombinationsIterator. AngularMomentumInt; Computes angular momentum integrals. BSVec. BasisExtents; docstring. BasisFunctions; docstring. BasisSet; Contains basis set information. BlockOPoints; docstring. BoysLocalizer; Performs Boys orbital localization. CIVector; docstring. CIWavefunction; docstring. CUHF; docstring. CdSalcList; Class for generating symmetry adapted linear combinations of Cartesian displacements. CorrelationFactor; docstring. CorrelationTable; Provides a correlation table between two point groups. CubeProperties; docstring. DFEP2Wavefunction; A density-fitted second-order Electron Propagator Wavefunction. DFHelper; docstring. DFSOMCSCF; docstring. DFTGrid; docstring. DFTensor; docstring. Deriv; Computes gradients of wavefunctions. DiagonalizeOrder; Defines ordering of eigenvalues after diagonalization. Dimension; Initializes and defines Dimension Objects. DipoleInt; Computes dipole integrals. DiskSOMCSCF; docstring. Dispersion; docstring. EFP; Class interfacing with libefp. ERI; Computes normal two electron reuplsion integrals. ElectricFieldInt; Computes electric field integrals. ElectrostaticInt; Computes electrostatic integrals. ErfComplementERI; Computes ERF complement electron repulsion integrals. ErfERI; Computes ERF electron repulsion integrals. ExternalPotential; Stores external potential field, computes external potentia",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:258922,Modifiability,plugin,plugin,258922,"_arrays(expected, computed, digits, label); Function to compare two numpy arrays. compare_csx(); Function to validate energies in CSX files against PSIvariables. compare_cubes(expected, computed, label); Function to compare two cube files. compare_fcidumps(expected, computed, label); Function to compare two FCIDUMP files. compare_integers(expected, computed, label); Function to compare two integers. compare_matrices(expected, computed, digits, …); Function to compare two matrices. compare_strings(expected, computed, label); Function to compare two strings. compare_values(expected, computed, digits, label); Function to compare two values. compare_vectors(expected, computed, digits, …); Function to compare two vectors. copy_file_from_scratch(filename, prefix, …); Function to move file out of scratch with correct naming convention. copy_file_to_scratch(filename, prefix, …); Function to move file into scratch with correct naming convention. create_plugin(name, template); Generate plugin in directory with sanitized name based upon template. csx2endict(); Grabs the CSX file as a dictionary, encodes translation of PSI variables to XML blocks, gathers all available energies from CSX file into returned dictionary. cubeprop(wfn, **kwargs); Evaluate properties on a grid and generate cube files. dynamic_variable_bind(cls); Function to dynamically add extra members to the core.Molecule class. energy(name, **kwargs); Function to compute the single-point electronic energy. fchk(wfn, filename); Function to write wavefunction information in wfn to filename in Gaussian FCHK format. fcidump(wfn[, fname, oe_ints]); Save integrals to file in FCIDUMP format as defined in Comp. fcidump_from_file(fname); Function to read in a FCIDUMP file. filter_comments(string); Remove from string any Python-style comments (‘#’ to end of line). find_approximate_string_matches(seq1, …); Function to compute approximate string matches from a list of options. freq(name, **kwargs); Function to compute harmonic",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:259060,Modifiability,variab,variables,259060,"es against PSIvariables. compare_cubes(expected, computed, label); Function to compare two cube files. compare_fcidumps(expected, computed, label); Function to compare two FCIDUMP files. compare_integers(expected, computed, label); Function to compare two integers. compare_matrices(expected, computed, digits, …); Function to compare two matrices. compare_strings(expected, computed, label); Function to compare two strings. compare_values(expected, computed, digits, label); Function to compare two values. compare_vectors(expected, computed, digits, …); Function to compare two vectors. copy_file_from_scratch(filename, prefix, …); Function to move file out of scratch with correct naming convention. copy_file_to_scratch(filename, prefix, …); Function to move file into scratch with correct naming convention. create_plugin(name, template); Generate plugin in directory with sanitized name based upon template. csx2endict(); Grabs the CSX file as a dictionary, encodes translation of PSI variables to XML blocks, gathers all available energies from CSX file into returned dictionary. cubeprop(wfn, **kwargs); Evaluate properties on a grid and generate cube files. dynamic_variable_bind(cls); Function to dynamically add extra members to the core.Molecule class. energy(name, **kwargs); Function to compute the single-point electronic energy. fchk(wfn, filename); Function to write wavefunction information in wfn to filename in Gaussian FCHK format. fcidump(wfn[, fname, oe_ints]); Save integrals to file in FCIDUMP format as defined in Comp. fcidump_from_file(fname); Function to read in a FCIDUMP file. filter_comments(string); Remove from string any Python-style comments (‘#’ to end of line). find_approximate_string_matches(seq1, …); Function to compute approximate string matches from a list of options. freq(name, **kwargs); Function to compute harmonic vibrational frequencies. frequencies(name, **kwargs); Function to compute harmonic vibrational frequencies. frequency(name, **kwargs); F",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:263743,Modifiability,flexible,flexible,263743,"et the total memory allocation. set_module_options(module, options_dict); Sets Psi4 module options from a module specification and input dictionary. set_options(options_dict); Sets Psi4 global options from an input dictionary. success(label); Function to print a ‘label…PASSED’ line to screen. vibanal_wfn(wfn[, hess, irrep, molecule, …]). write_eigenvalues(eigs, mo_idx); Prepare multi-line string with one-particle eigenvalues to be written to the FCIDUMP file. xml2dict([filename]); Read XML filename into nested OrderedDict-s. Classes¶. CSXError(msg); Error called when CSX generation fails. ConvergenceError(eqn_description, maxit); Error called for problems with converging and iterative method. Dftd3Error(msg). EmpericalDispersion(alias, dtype, **kwargs). ManagedMethodError(circs). OptimizationConvergenceError(…); Error called for problems with geometry optimizer. ParsingError(msg); Error called for problems parsing a text file. PastureRequiredError(option); Error called when the specified value of option requires some module(s) from Psi4Pasture, but could not be imported. PsiException; Error class for Psi. PsiImportError(msg); Error called for problems import python dependencies. QMMM(). Table([rows, row_label_width, …]); Class defining a flexible Table object for storing data. TestComparisonError(msg); Error called when a test case fails due to a failed compare_values() call. ValidationError(msg); Error called for problems with the input file. datetime(year, month, day[, hour[, minute[, …); The year, month and day arguments are required. Class Inheritance Diagram¶. table of contents. PSI4 API: Linking C++ and Python; psi4.core Module; Functions; Classes; Class Inheritance Diagram. psi4.driver Package; Functions; Classes; Class Inheritance Diagram. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:105091,Performance,load,load,105091,"ument transb Transpose the right matrix? argument alpha Prefactor for the matrix multiplication argument A Left matrix argument B Right matrix argument beta Prefactor for the resulting matrix. general_invert(self: psi4.core.Matrix) → None¶; Computes the inverse of any nonsingular matrix using LU factorization. get(*args, **kwargs)¶; Overloaded function. get(self: psi4.core.Matrix, h: int, m: int, n: int) -> float. Returns a single element of a matrix in subblock h, row m, col n. get(self: psi4.core.Matrix, m: int, n: int) -> float. Returns a single element of a matrix, row m, col n. get_block(self: psi4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice) → psi4.core.Matrix¶; Get a matrix block. hermitivitize(self: psi4.core.Matrix) → None¶; Average off-diagonal element in-place. identity(self: psi4.core.Matrix) → None¶; Sets the matrix to the identity. invert(self: psi4.core.Matrix) → None¶; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs)¶; Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType=SaveType.LowerTriangle) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str) → None¶; Loads a matrix from an ASCII file in MPQC format. name¶; The name of the Matrix. Used in printing. nirrep(self: psi4.core.Matrix) → int¶; Returns the number of irreps. np¶; View without only one irrep. classmethod np_read(filename, prefix='')¶; Reads the data from a NumPy compress file. np_write(filename=None, prefix='')¶; Writes the irreped matrix to a NumPy zipped file.; Can return the packed data for sa",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:105136,Performance,load,load,105136,"t matrix? argument alpha Prefactor for the matrix multiplication argument A Left matrix argument B Right matrix argument beta Prefactor for the resulting matrix. general_invert(self: psi4.core.Matrix) → None¶; Computes the inverse of any nonsingular matrix using LU factorization. get(*args, **kwargs)¶; Overloaded function. get(self: psi4.core.Matrix, h: int, m: int, n: int) -> float. Returns a single element of a matrix in subblock h, row m, col n. get(self: psi4.core.Matrix, m: int, n: int) -> float. Returns a single element of a matrix, row m, col n. get_block(self: psi4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice) → psi4.core.Matrix¶; Get a matrix block. hermitivitize(self: psi4.core.Matrix) → None¶; Average off-diagonal element in-place. identity(self: psi4.core.Matrix) → None¶; Sets the matrix to the identity. invert(self: psi4.core.Matrix) → None¶; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs)¶; Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType=SaveType.LowerTriangle) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str) → None¶; Loads a matrix from an ASCII file in MPQC format. name¶; The name of the Matrix. Used in printing. nirrep(self: psi4.core.Matrix) → int¶; Returns the number of irreps. np¶; View without only one irrep. classmethod np_read(filename, prefix='')¶; Reads the data from a NumPy compress file. np_write(filename=None, prefix='')¶; Writes the irreped matrix to a NumPy zipped file.; Can return the packed data for saving many matrices into the sam",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:105260,Performance,load,load,105260,"a Prefactor for the resulting matrix. general_invert(self: psi4.core.Matrix) → None¶; Computes the inverse of any nonsingular matrix using LU factorization. get(*args, **kwargs)¶; Overloaded function. get(self: psi4.core.Matrix, h: int, m: int, n: int) -> float. Returns a single element of a matrix in subblock h, row m, col n. get(self: psi4.core.Matrix, m: int, n: int) -> float. Returns a single element of a matrix, row m, col n. get_block(self: psi4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice) → psi4.core.Matrix¶; Get a matrix block. hermitivitize(self: psi4.core.Matrix) → None¶; Average off-diagonal element in-place. identity(self: psi4.core.Matrix) → None¶; Sets the matrix to the identity. invert(self: psi4.core.Matrix) → None¶; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs)¶; Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType=SaveType.LowerTriangle) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str) → None¶; Loads a matrix from an ASCII file in MPQC format. name¶; The name of the Matrix. Used in printing. nirrep(self: psi4.core.Matrix) → int¶; Returns the number of irreps. np¶; View without only one irrep. classmethod np_read(filename, prefix='')¶; Reads the data from a NumPy compress file. np_write(filename=None, prefix='')¶; Writes the irreped matrix to a NumPy zipped file.; Can return the packed data for saving many matrices into the same file. nph¶; View with irreps. partial_cholesky_factorize(self: psi4.core.Matrix, delta: float=0.0, throw_if_negative: bool",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:105428,Performance,load,load,105428,"**kwargs)¶; Overloaded function. get(self: psi4.core.Matrix, h: int, m: int, n: int) -> float. Returns a single element of a matrix in subblock h, row m, col n. get(self: psi4.core.Matrix, m: int, n: int) -> float. Returns a single element of a matrix, row m, col n. get_block(self: psi4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice) → psi4.core.Matrix¶; Get a matrix block. hermitivitize(self: psi4.core.Matrix) → None¶; Average off-diagonal element in-place. identity(self: psi4.core.Matrix) → None¶; Sets the matrix to the identity. invert(self: psi4.core.Matrix) → None¶; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs)¶; Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType=SaveType.LowerTriangle) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str) → None¶; Loads a matrix from an ASCII file in MPQC format. name¶; The name of the Matrix. Used in printing. nirrep(self: psi4.core.Matrix) → int¶; Returns the number of irreps. np¶; View without only one irrep. classmethod np_read(filename, prefix='')¶; Reads the data from a NumPy compress file. np_write(filename=None, prefix='')¶; Writes the irreped matrix to a NumPy zipped file.; Can return the packed data for saving many matrices into the same file. nph¶; View with irreps. partial_cholesky_factorize(self: psi4.core.Matrix, delta: float=0.0, throw_if_negative: bool=False) → psi4.core.Matrix¶; Computes the fully pivoted partial Cholesky factorization of a real symmetric positive semidefinite matrix, to numerical precision delta. p",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:139133,Performance,load,load,139133,"s of the rigid molecule that only interchange identical atoms. rotor_type(self: psi4.core.Molecule) → str¶; Returns rotor type, e.g. ‘RT_ATOM’ or ‘RT_SYMMETRIC_TOP’. run_dftd3(func=None, dashlvl=None, dashparam=None, dertype=None, verbose=False)¶; Compute dispersion correction using Grimme’s DFTD3 executable.; Function to call Grimme’s dftd3 program to compute the -D correction; of level dashlvl using parameters for the functional func.; dashparam can supply a full set of dispersion parameters in the; absence of func or individual overrides in the presence of func.; The DFTD3 executable must be independently compiled and found in; PATH or PSIPATH. Parameters:; mol (qcdb.Molecule or psi4.core.Molecule or str) – Molecule on which to run dispersion calculation. Both qcdb and; psi4.core Molecule classes have been extended by this method, so; either allowed. Alternately, a string that can be instantiated; into a qcdb.Molecule.; func (str or None) – Density functional (Psi4, not Turbomole, names) for which to; load parameters from dashcoeff[dashlvl][func]. This is not; passed to DFTD3 and thus may be a dummy or None. Any or all; parameters initialized can be overwritten via dashparam.; dashlvl ({'d2p4', 'd2gr', 'd3zero', 'd3bj', 'd3mzero', d3mbj', 'd', 'd2', 'd3', 'd3m'}) – Flavor of a posteriori dispersion correction for which to load; parameters and call procedure in DFTD3. Must be a keys in; dashcoeff dict (or a key in dashalias that resolves to one).; dashparam (dict, optional) – Dictionary of the same keys as dashcoeff[dashlvl] used to; override any or all values initialized by; dashcoeff[dashlvl][func].; dertype ({None, 0, 'none', 'energy', 1, 'first', 'gradient'}, optional) – Maximum derivative level at which to run DFTD3. For large; mol, energy-only calculations can be significantly more; efficient. Also controls return values, see below.; verbose (bool, optional) – When True, additionally include DFTD3 output in output. Returns:; energy (float, optional) – When de",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:139460,Performance,load,load,139460,"FTD3 executable.; Function to call Grimme’s dftd3 program to compute the -D correction; of level dashlvl using parameters for the functional func.; dashparam can supply a full set of dispersion parameters in the; absence of func or individual overrides in the presence of func.; The DFTD3 executable must be independently compiled and found in; PATH or PSIPATH. Parameters:; mol (qcdb.Molecule or psi4.core.Molecule or str) – Molecule on which to run dispersion calculation. Both qcdb and; psi4.core Molecule classes have been extended by this method, so; either allowed. Alternately, a string that can be instantiated; into a qcdb.Molecule.; func (str or None) – Density functional (Psi4, not Turbomole, names) for which to; load parameters from dashcoeff[dashlvl][func]. This is not; passed to DFTD3 and thus may be a dummy or None. Any or all; parameters initialized can be overwritten via dashparam.; dashlvl ({'d2p4', 'd2gr', 'd3zero', 'd3bj', 'd3mzero', d3mbj', 'd', 'd2', 'd3', 'd3m'}) – Flavor of a posteriori dispersion correction for which to load; parameters and call procedure in DFTD3. Must be a keys in; dashcoeff dict (or a key in dashalias that resolves to one).; dashparam (dict, optional) – Dictionary of the same keys as dashcoeff[dashlvl] used to; override any or all values initialized by; dashcoeff[dashlvl][func].; dertype ({None, 0, 'none', 'energy', 1, 'first', 'gradient'}, optional) – Maximum derivative level at which to run DFTD3. For large; mol, energy-only calculations can be significantly more; efficient. Also controls return values, see below.; verbose (bool, optional) – When True, additionally include DFTD3 output in output. Returns:; energy (float, optional) – When dertype is 0, energy [Eh].; gradient (list of lists of floats or psi4.core.Matrix, optional) – When dertype is 1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (float and list of lists of floats or psi4.core.Matrix, optional) – When dertype is unspecified, both energy [Eh] and (nat, 3) gradient",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:226256,Performance,optimiz,optimized,226256,"float¶; Runs the coupled cluster response theory code. psi4.core.cctransort(arg0: psi::Wavefunction) → None¶; Runs CCTRANSORT, which transforms and reorders integrals for use in the coupled cluster codes. psi4.core.cctriples(arg0: psi::Wavefunction) → float¶; Runs the coupled cluster (T) energy code. psi4.core.clean() → None¶; Function to remove scratch files. Call between independent jobs. psi4.core.clean_options() → None¶; Function to reset options to clean state. psi4.core.clean_variables() → None¶; Empties all PSI variables that have set internally. psi4.core.close_outfile() → None¶; Closes the output file. psi4.core.dcft(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the density cumulant functional theory code. psi4.core.detci(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the determinant-based configuration interaction code. psi4.core.dfmp2(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the DF-MP2 code. psi4.core.dfocc(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the density-fitted orbital optimized CC codes. psi4.core.displace_atom(arg0: psi::Matrix, arg1: int, arg2: int, arg3: int, arg4: float) → None¶; Displaces one coordinate of single atom. psi4.core.dmrg(arg0: psi::Wavefunction) → float¶; Runs the DMRG code. psi4.core.efp_init() → psi4.core.EFP¶; Initializes the EFP library and returns an EFP object. psi4.core.efp_set_options() → None¶; Set EFP options from environment options object. psi4.core.fcidump_tei_helper(nirrep: int, restricted: bool, DPD_info: Dict[str, int], ints_tolerance: float, fname: str='INTDUMP') → None¶; Write integrals to file in FCIDUMP format. psi4.core.fd_1_0(arg0: psi::Molecule, arg1: list) → psi::Matrix¶; Performs a finite difference gradient computation, from energy points. psi4.core.fd_freq_0(arg0: psi::Molecule, arg1: list, arg2: int) → psi::Matrix¶; Performs a finite difference frequency computation, from energy points, for a given irrep. psi4.core.fd_freq_1(arg0: psi::Molecule, arg1: list, arg2: int) → p",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:232811,Performance,optimiz,optimized,232811," module arg1 or globally, by either user or code. Notwithstanding, code is written such that in practice, this returns whether the option has been touched by the user. psi4.core.has_variable(arg0: str) → bool¶; Returns true if the PSI variable exists/is set. psi4.core.initialize() → bool¶. psi4.core.legacy_wavefunction() → psi::Wavefunction¶; Returns the current legacy_wavefunction object from the most recent computation. psi4.core.libfock(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs a CPHF calculation, using libfock. psi4.core.mcscf(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the MCSCF code, (N.B. restricted to certain active spaces). psi4.core.mrcc_generate_input(arg0: psi::Wavefunction, arg1: dict) → psi4.core.PsiReturnType¶; Generates an input for Kallay’s MRCC code. psi4.core.mrcc_load_densities(arg0: psi::Wavefunction, arg1: dict) → psi4.core.PsiReturnType¶; Reads in the density matrices from Kallay’s MRCC code. psi4.core.occ(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the orbital optimized CC codes. psi4.core.opt_clean() → None¶; Cleans up the optimizer’s scratch files. psi4.core.option_exists_in_module(arg0: str, arg1: str) → bool¶; Given a string of a keyword name arg1 and a particular module arg0, returns whether arg1 is a valid option for arg0. psi4.core.optking() → int¶; Runs the geometry optimization / frequency analysis code. psi4.core.outfile_name() → str¶; Returns the name of the output file. psi4.core.plugin(arg0: str, arg1: psi::Wavefunction) → psi::Wavefunction¶; Call the plugin of name arg0. Returns the plugin code result. psi4.core.plugin_close(arg0: str) → None¶; Close the plugin of name arg0. psi4.core.plugin_close_all() → None¶; Close all open plugins. psi4.core.plugin_load(arg0: str) → int¶; Load the plugin of name arg0. Returns 0 if not loaded, 1 if loaded, 2 if already loaded. psi4.core.prepare_options_for_module(arg0: str) → None¶; Sets the options module up to return options pertaining to the named argument (e.g. SC",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:232876,Performance,optimiz,optimizer,232876,"ch that in practice, this returns whether the option has been touched by the user. psi4.core.has_variable(arg0: str) → bool¶; Returns true if the PSI variable exists/is set. psi4.core.initialize() → bool¶. psi4.core.legacy_wavefunction() → psi::Wavefunction¶; Returns the current legacy_wavefunction object from the most recent computation. psi4.core.libfock(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs a CPHF calculation, using libfock. psi4.core.mcscf(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the MCSCF code, (N.B. restricted to certain active spaces). psi4.core.mrcc_generate_input(arg0: psi::Wavefunction, arg1: dict) → psi4.core.PsiReturnType¶; Generates an input for Kallay’s MRCC code. psi4.core.mrcc_load_densities(arg0: psi::Wavefunction, arg1: dict) → psi4.core.PsiReturnType¶; Reads in the density matrices from Kallay’s MRCC code. psi4.core.occ(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the orbital optimized CC codes. psi4.core.opt_clean() → None¶; Cleans up the optimizer’s scratch files. psi4.core.option_exists_in_module(arg0: str, arg1: str) → bool¶; Given a string of a keyword name arg1 and a particular module arg0, returns whether arg1 is a valid option for arg0. psi4.core.optking() → int¶; Runs the geometry optimization / frequency analysis code. psi4.core.outfile_name() → str¶; Returns the name of the output file. psi4.core.plugin(arg0: str, arg1: psi::Wavefunction) → psi::Wavefunction¶; Call the plugin of name arg0. Returns the plugin code result. psi4.core.plugin_close(arg0: str) → None¶; Close the plugin of name arg0. psi4.core.plugin_close_all() → None¶; Close all open plugins. psi4.core.plugin_load(arg0: str) → int¶; Load the plugin of name arg0. Returns 0 if not loaded, 1 if loaded, 2 if already loaded. psi4.core.prepare_options_for_module(arg0: str) → None¶; Sets the options module up to return options pertaining to the named argument (e.g. SCF). psi4.core.print_global_options() → None¶; Prints the currently set global (all mo",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:233131,Performance,optimiz,optimization,233131,"eturns the current legacy_wavefunction object from the most recent computation. psi4.core.libfock(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs a CPHF calculation, using libfock. psi4.core.mcscf(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the MCSCF code, (N.B. restricted to certain active spaces). psi4.core.mrcc_generate_input(arg0: psi::Wavefunction, arg1: dict) → psi4.core.PsiReturnType¶; Generates an input for Kallay’s MRCC code. psi4.core.mrcc_load_densities(arg0: psi::Wavefunction, arg1: dict) → psi4.core.PsiReturnType¶; Reads in the density matrices from Kallay’s MRCC code. psi4.core.occ(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the orbital optimized CC codes. psi4.core.opt_clean() → None¶; Cleans up the optimizer’s scratch files. psi4.core.option_exists_in_module(arg0: str, arg1: str) → bool¶; Given a string of a keyword name arg1 and a particular module arg0, returns whether arg1 is a valid option for arg0. psi4.core.optking() → int¶; Runs the geometry optimization / frequency analysis code. psi4.core.outfile_name() → str¶; Returns the name of the output file. psi4.core.plugin(arg0: str, arg1: psi::Wavefunction) → psi::Wavefunction¶; Call the plugin of name arg0. Returns the plugin code result. psi4.core.plugin_close(arg0: str) → None¶; Close the plugin of name arg0. psi4.core.plugin_close_all() → None¶; Close all open plugins. psi4.core.plugin_load(arg0: str) → int¶; Load the plugin of name arg0. Returns 0 if not loaded, 1 if loaded, 2 if already loaded. psi4.core.prepare_options_for_module(arg0: str) → None¶; Sets the options module up to return options pertaining to the named argument (e.g. SCF). psi4.core.print_global_options() → None¶; Prints the currently set global (all modules) options to the output file. psi4.core.print_options() → None¶; Prints the currently set options (to the output file) for the current module. psi4.core.print_out(arg0: str) → None¶; Prints a string (using sprintf-like notation) to the output file. psi4.co",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:233602,Performance,load,loaded,233602,"arg0: psi::Wavefunction, arg1: dict) → psi4.core.PsiReturnType¶; Reads in the density matrices from Kallay’s MRCC code. psi4.core.occ(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the orbital optimized CC codes. psi4.core.opt_clean() → None¶; Cleans up the optimizer’s scratch files. psi4.core.option_exists_in_module(arg0: str, arg1: str) → bool¶; Given a string of a keyword name arg1 and a particular module arg0, returns whether arg1 is a valid option for arg0. psi4.core.optking() → int¶; Runs the geometry optimization / frequency analysis code. psi4.core.outfile_name() → str¶; Returns the name of the output file. psi4.core.plugin(arg0: str, arg1: psi::Wavefunction) → psi::Wavefunction¶; Call the plugin of name arg0. Returns the plugin code result. psi4.core.plugin_close(arg0: str) → None¶; Close the plugin of name arg0. psi4.core.plugin_close_all() → None¶; Close all open plugins. psi4.core.plugin_load(arg0: str) → int¶; Load the plugin of name arg0. Returns 0 if not loaded, 1 if loaded, 2 if already loaded. psi4.core.prepare_options_for_module(arg0: str) → None¶; Sets the options module up to return options pertaining to the named argument (e.g. SCF). psi4.core.print_global_options() → None¶; Prints the currently set global (all modules) options to the output file. psi4.core.print_options() → None¶; Prints the currently set options (to the output file) for the current module. psi4.core.print_out(arg0: str) → None¶; Prints a string (using sprintf-like notation) to the output file. psi4.core.print_variables() → None¶; Prints all PSI variables that have been set internally. psi4.core.psi_top_srcdir() → str¶; Returns the location of the source code. psi4.core.psimrcc(arg0: psi::Wavefunction) → float¶; Runs the multireference coupled cluster code. psi4.core.reopen_outfile() → None¶; Reopens the output file. psi4.core.revoke_global_option_changed(arg0: str) → None¶; Given a string of a keyword name arg1, sets the has_changed attribute in the global options scope to",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:233615,Performance,load,loaded,233615,"arg0: psi::Wavefunction, arg1: dict) → psi4.core.PsiReturnType¶; Reads in the density matrices from Kallay’s MRCC code. psi4.core.occ(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the orbital optimized CC codes. psi4.core.opt_clean() → None¶; Cleans up the optimizer’s scratch files. psi4.core.option_exists_in_module(arg0: str, arg1: str) → bool¶; Given a string of a keyword name arg1 and a particular module arg0, returns whether arg1 is a valid option for arg0. psi4.core.optking() → int¶; Runs the geometry optimization / frequency analysis code. psi4.core.outfile_name() → str¶; Returns the name of the output file. psi4.core.plugin(arg0: str, arg1: psi::Wavefunction) → psi::Wavefunction¶; Call the plugin of name arg0. Returns the plugin code result. psi4.core.plugin_close(arg0: str) → None¶; Close the plugin of name arg0. psi4.core.plugin_close_all() → None¶; Close all open plugins. psi4.core.plugin_load(arg0: str) → int¶; Load the plugin of name arg0. Returns 0 if not loaded, 1 if loaded, 2 if already loaded. psi4.core.prepare_options_for_module(arg0: str) → None¶; Sets the options module up to return options pertaining to the named argument (e.g. SCF). psi4.core.print_global_options() → None¶; Prints the currently set global (all modules) options to the output file. psi4.core.print_options() → None¶; Prints the currently set options (to the output file) for the current module. psi4.core.print_out(arg0: str) → None¶; Prints a string (using sprintf-like notation) to the output file. psi4.core.print_variables() → None¶; Prints all PSI variables that have been set internally. psi4.core.psi_top_srcdir() → str¶; Returns the location of the source code. psi4.core.psimrcc(arg0: psi::Wavefunction) → float¶; Runs the multireference coupled cluster code. psi4.core.reopen_outfile() → None¶; Reopens the output file. psi4.core.revoke_global_option_changed(arg0: str) → None¶; Given a string of a keyword name arg1, sets the has_changed attribute in the global options scope to",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:233636,Performance,load,loaded,233636,"arg0: psi::Wavefunction, arg1: dict) → psi4.core.PsiReturnType¶; Reads in the density matrices from Kallay’s MRCC code. psi4.core.occ(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the orbital optimized CC codes. psi4.core.opt_clean() → None¶; Cleans up the optimizer’s scratch files. psi4.core.option_exists_in_module(arg0: str, arg1: str) → bool¶; Given a string of a keyword name arg1 and a particular module arg0, returns whether arg1 is a valid option for arg0. psi4.core.optking() → int¶; Runs the geometry optimization / frequency analysis code. psi4.core.outfile_name() → str¶; Returns the name of the output file. psi4.core.plugin(arg0: str, arg1: psi::Wavefunction) → psi::Wavefunction¶; Call the plugin of name arg0. Returns the plugin code result. psi4.core.plugin_close(arg0: str) → None¶; Close the plugin of name arg0. psi4.core.plugin_close_all() → None¶; Close all open plugins. psi4.core.plugin_load(arg0: str) → int¶; Load the plugin of name arg0. Returns 0 if not loaded, 1 if loaded, 2 if already loaded. psi4.core.prepare_options_for_module(arg0: str) → None¶; Sets the options module up to return options pertaining to the named argument (e.g. SCF). psi4.core.print_global_options() → None¶; Prints the currently set global (all modules) options to the output file. psi4.core.print_options() → None¶; Prints the currently set options (to the output file) for the current module. psi4.core.print_out(arg0: str) → None¶; Prints a string (using sprintf-like notation) to the output file. psi4.core.print_variables() → None¶; Prints all PSI variables that have been set internally. psi4.core.psi_top_srcdir() → str¶; Returns the location of the source code. psi4.core.psimrcc(arg0: psi::Wavefunction) → float¶; Runs the multireference coupled cluster code. psi4.core.reopen_outfile() → None¶; Reopens the output file. psi4.core.revoke_global_option_changed(arg0: str) → None¶; Given a string of a keyword name arg1, sets the has_changed attribute in the global options scope to",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:242400,Performance,optimiz,optimized,242400,"y(arg0); Runs the code to compute coupled cluster density matrices. ccenergy(arg0); Runs the coupled cluster energy code. cceom(arg0); Runs the equation of motion coupled cluster code, for excited states. cchbar(arg0); Runs the code to generate the similarity transformed Hamiltonian. cclambda(arg0); Runs the coupled cluster lambda equations code. ccresponse(arg0); Runs the coupled cluster response theory code. cctransort(arg0); Runs CCTRANSORT, which transforms and reorders integrals for use in the coupled cluster codes. cctriples(arg0); Runs the coupled cluster (T) energy code. clean(); Function to remove scratch files. clean_options(); Function to reset options to clean state. clean_variables(); Empties all PSI variables that have set internally. close_outfile(); Closes the output file. dcft(arg0); Runs the density cumulant functional theory code. detci(arg0); Runs the determinant-based configuration interaction code. dfmp2(arg0); Runs the DF-MP2 code. dfocc(arg0); Runs the density-fitted orbital optimized CC codes. displace_atom(arg0, arg1, arg2, arg3, arg4); Displaces one coordinate of single atom. dmrg(arg0); Runs the DMRG code. efp_init(); Initializes the EFP library and returns an EFP object. efp_set_options(); Set EFP options from environment options object. fcidump_tei_helper(nirrep, restricted, …); Write integrals to file in FCIDUMP format. fd_1_0(arg0, arg1); Performs a finite difference gradient computation, from energy points. fd_freq_0(arg0, arg1, arg2); Performs a finite difference frequency computation, from energy points, for a given irrep. fd_freq_1(arg0, arg1, arg2); Performs a finite difference frequency computation, from gradients, for a given irrep. fd_geoms_1_0(arg0); Gets list of displacements needed for a finite difference gradient computation, from energy points. fd_geoms_freq_0(arg0, arg1); Gets list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep. fd_geoms_freq_1(arg0, arg1); Get",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:246738,Performance,optimiz,optimized,246738,"on(); Returns the git version of this copy of Psi. has_global_option_changed(arg0); Returns boolean for whether the keyword arg1 has been touched in the global scope, by either user or code. has_local_option_changed(arg0, arg1); Returns boolean for whether the keyword arg2 has been touched in the scope of the specified module arg1, by either user or code. has_option_changed(arg0, arg1); Returns boolean for whether the option arg2 has been touched either locally to the specified module arg1 or globally, by either user or code. has_variable(arg0); Returns true if the PSI variable exists/is set. initialize(). legacy_wavefunction(); Returns the current legacy_wavefunction object from the most recent computation. libfock(arg0); Runs a CPHF calculation, using libfock. mcscf(arg0); Runs the MCSCF code, (N.B. mrcc_generate_input(arg0, arg1); Generates an input for Kallay’s MRCC code. mrcc_load_densities(arg0, arg1); Reads in the density matrices from Kallay’s MRCC code. occ(arg0); Runs the orbital optimized CC codes. opt_clean(); Cleans up the optimizer’s scratch files. option_exists_in_module(arg0, arg1); Given a string of a keyword name arg1 and a particular module arg0, returns whether arg1 is a valid option for arg0. optking(); Runs the geometry optimization / frequency analysis code. outfile_name(); Returns the name of the output file. plugin(arg0, arg1); Call the plugin of name arg0. plugin_close(arg0); Close the plugin of name arg0. plugin_close_all(); Close all open plugins. plugin_load(arg0); Load the plugin of name arg0. prepare_options_for_module(arg0); Sets the options module up to return options pertaining to the named argument (e.g. print_global_options(); Prints the currently set global (all modules) options to the output file. print_options(); Prints the currently set options (to the output file) for the current module. print_out(arg0); Prints a string (using sprintf-like notation) to the output file. print_variables(); Prints all PSI variables that have bee",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:246785,Performance,optimiz,optimizer,246785,"has_global_option_changed(arg0); Returns boolean for whether the keyword arg1 has been touched in the global scope, by either user or code. has_local_option_changed(arg0, arg1); Returns boolean for whether the keyword arg2 has been touched in the scope of the specified module arg1, by either user or code. has_option_changed(arg0, arg1); Returns boolean for whether the option arg2 has been touched either locally to the specified module arg1 or globally, by either user or code. has_variable(arg0); Returns true if the PSI variable exists/is set. initialize(). legacy_wavefunction(); Returns the current legacy_wavefunction object from the most recent computation. libfock(arg0); Runs a CPHF calculation, using libfock. mcscf(arg0); Runs the MCSCF code, (N.B. mrcc_generate_input(arg0, arg1); Generates an input for Kallay’s MRCC code. mrcc_load_densities(arg0, arg1); Reads in the density matrices from Kallay’s MRCC code. occ(arg0); Runs the orbital optimized CC codes. opt_clean(); Cleans up the optimizer’s scratch files. option_exists_in_module(arg0, arg1); Given a string of a keyword name arg1 and a particular module arg0, returns whether arg1 is a valid option for arg0. optking(); Runs the geometry optimization / frequency analysis code. outfile_name(); Returns the name of the output file. plugin(arg0, arg1); Call the plugin of name arg0. plugin_close(arg0); Close the plugin of name arg0. plugin_close_all(); Close all open plugins. plugin_load(arg0); Load the plugin of name arg0. prepare_options_for_module(arg0); Sets the options module up to return options pertaining to the named argument (e.g. print_global_options(); Prints the currently set global (all modules) options to the output file. print_options(); Prints the currently set options (to the output file) for the current module. print_out(arg0); Prints a string (using sprintf-like notation) to the output file. print_variables(); Prints all PSI variables that have been set internally. psi_top_srcdir(); Returns the loc",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:246995,Performance,optimiz,optimization,246995,"rd arg2 has been touched in the scope of the specified module arg1, by either user or code. has_option_changed(arg0, arg1); Returns boolean for whether the option arg2 has been touched either locally to the specified module arg1 or globally, by either user or code. has_variable(arg0); Returns true if the PSI variable exists/is set. initialize(). legacy_wavefunction(); Returns the current legacy_wavefunction object from the most recent computation. libfock(arg0); Runs a CPHF calculation, using libfock. mcscf(arg0); Runs the MCSCF code, (N.B. mrcc_generate_input(arg0, arg1); Generates an input for Kallay’s MRCC code. mrcc_load_densities(arg0, arg1); Reads in the density matrices from Kallay’s MRCC code. occ(arg0); Runs the orbital optimized CC codes. opt_clean(); Cleans up the optimizer’s scratch files. option_exists_in_module(arg0, arg1); Given a string of a keyword name arg1 and a particular module arg0, returns whether arg1 is a valid option for arg0. optking(); Runs the geometry optimization / frequency analysis code. outfile_name(); Returns the name of the output file. plugin(arg0, arg1); Call the plugin of name arg0. plugin_close(arg0); Close the plugin of name arg0. plugin_close_all(); Close all open plugins. plugin_load(arg0); Load the plugin of name arg0. prepare_options_for_module(arg0); Sets the options module up to return options pertaining to the named argument (e.g. print_global_options(); Prints the currently set global (all modules) options to the output file. print_options(); Prints the currently set options (to the output file) for the current module. print_out(arg0); Prints a string (using sprintf-like notation) to the output file. print_variables(); Prints all PSI variables that have been set internally. psi_top_srcdir(); Returns the location of the source code. psimrcc(arg0); Runs the multireference coupled cluster code. reopen_outfile(); Reopens the output file. revoke_global_option_changed(arg0); Given a string of a keyword name arg1, sets the ha",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:260537,Performance,optimiz,optimize,260537," oe_ints]); Save integrals to file in FCIDUMP format as defined in Comp. fcidump_from_file(fname); Function to read in a FCIDUMP file. filter_comments(string); Remove from string any Python-style comments (‘#’ to end of line). find_approximate_string_matches(seq1, …); Function to compute approximate string matches from a list of options. freq(name, **kwargs); Function to compute harmonic vibrational frequencies. frequencies(name, **kwargs); Function to compute harmonic vibrational frequencies. frequency(name, **kwargs); Function to compute harmonic vibrational frequencies. gdma(wfn[, datafile]); Function to use wavefunction information in wfn and, if specified, additional commands in filename to run GDMA analysis. geometry(geom[, name]); Function to create a molecule object of name name from the geometry in string geom. getFromDict(dataDict, mapList). get_memory(); Function to return the total memory allocation. gradient(name, **kwargs); Function complementary to :py:func:~driver.optimize(). hessian(name, **kwargs); Function complementary to frequency(). join_path(prefix, *args). levenshtein(seq1, seq2); Function to compute the Levenshtein distance between two strings. molden(wfn[, filename, density_a, …]); Function to write wavefunction information in wfn to filename in molden format. molecule_from_arrays; classmethod(function) -> method. molecule_from_schema; classmethod(function) -> method. molecule_from_string; classmethod(function) -> method. molecule_get_attr(self, name); Function to redefine __getattr__ method of molecule class. molecule_set_attr(self, name, value); Function to redefine __setattr__ method of molecule class. oeprop(wfn, *args, **kwargs); Evaluate one-electron properties. opt(name, **kwargs); Function to perform a geometry optimization. optimize(name, **kwargs); Function to perform a geometry optimization. pcm_helper(block); Passes multiline string block to PCMSolver parser. print_stderr(stuff); Function to print stuff to standard error stream. ",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:261298,Performance,perform,perform,261298,"n to create a molecule object of name name from the geometry in string geom. getFromDict(dataDict, mapList). get_memory(); Function to return the total memory allocation. gradient(name, **kwargs); Function complementary to :py:func:~driver.optimize(). hessian(name, **kwargs); Function complementary to frequency(). join_path(prefix, *args). levenshtein(seq1, seq2); Function to compute the Levenshtein distance between two strings. molden(wfn[, filename, density_a, …]); Function to write wavefunction information in wfn to filename in molden format. molecule_from_arrays; classmethod(function) -> method. molecule_from_schema; classmethod(function) -> method. molecule_from_string; classmethod(function) -> method. molecule_get_attr(self, name); Function to redefine __getattr__ method of molecule class. molecule_set_attr(self, name, value); Function to redefine __setattr__ method of molecule class. oeprop(wfn, *args, **kwargs); Evaluate one-electron properties. opt(name, **kwargs); Function to perform a geometry optimization. optimize(name, **kwargs); Function to perform a geometry optimization. pcm_helper(block); Passes multiline string block to PCMSolver parser. print_stderr(stuff); Function to print stuff to standard error stream. print_stdout(stuff); Function to print stuff to standard output stream. process_input(raw_input[, print_level]); Function to preprocess raw input, the text of the input file, then parse it, validate it for format, and convert it into legitimate Python. process_pubchem_command(matchobj); Function to process match of pubchem in molecule block. prop(*args, **kwargs); Function to compute various properties. properties(*args, **kwargs); Function to compute various properties. sanitize_name(name); Function to return name in coded form, stripped of characters that confuse filenames, characters into lowercase, + into p, * into s, and (, ), -, & , into _. scf_helper(name[, post_scf]); Function serving as helper to SCF, choosing whether to cast up or jus",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:261317,Performance,optimiz,optimization,261317,"n to create a molecule object of name name from the geometry in string geom. getFromDict(dataDict, mapList). get_memory(); Function to return the total memory allocation. gradient(name, **kwargs); Function complementary to :py:func:~driver.optimize(). hessian(name, **kwargs); Function complementary to frequency(). join_path(prefix, *args). levenshtein(seq1, seq2); Function to compute the Levenshtein distance between two strings. molden(wfn[, filename, density_a, …]); Function to write wavefunction information in wfn to filename in molden format. molecule_from_arrays; classmethod(function) -> method. molecule_from_schema; classmethod(function) -> method. molecule_from_string; classmethod(function) -> method. molecule_get_attr(self, name); Function to redefine __getattr__ method of molecule class. molecule_set_attr(self, name, value); Function to redefine __setattr__ method of molecule class. oeprop(wfn, *args, **kwargs); Evaluate one-electron properties. opt(name, **kwargs); Function to perform a geometry optimization. optimize(name, **kwargs); Function to perform a geometry optimization. pcm_helper(block); Passes multiline string block to PCMSolver parser. print_stderr(stuff); Function to print stuff to standard error stream. print_stdout(stuff); Function to print stuff to standard output stream. process_input(raw_input[, print_level]); Function to preprocess raw input, the text of the input file, then parse it, validate it for format, and convert it into legitimate Python. process_pubchem_command(matchobj); Function to process match of pubchem in molecule block. prop(*args, **kwargs); Function to compute various properties. properties(*args, **kwargs); Function to compute various properties. sanitize_name(name); Function to return name in coded form, stripped of characters that confuse filenames, characters into lowercase, + into p, * into s, and (, ), -, & , into _. scf_helper(name[, post_scf]); Function serving as helper to SCF, choosing whether to cast up or jus",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:261331,Performance,optimiz,optimize,261331,"ng geom. getFromDict(dataDict, mapList). get_memory(); Function to return the total memory allocation. gradient(name, **kwargs); Function complementary to :py:func:~driver.optimize(). hessian(name, **kwargs); Function complementary to frequency(). join_path(prefix, *args). levenshtein(seq1, seq2); Function to compute the Levenshtein distance between two strings. molden(wfn[, filename, density_a, …]); Function to write wavefunction information in wfn to filename in molden format. molecule_from_arrays; classmethod(function) -> method. molecule_from_schema; classmethod(function) -> method. molecule_from_string; classmethod(function) -> method. molecule_get_attr(self, name); Function to redefine __getattr__ method of molecule class. molecule_set_attr(self, name, value); Function to redefine __setattr__ method of molecule class. oeprop(wfn, *args, **kwargs); Evaluate one-electron properties. opt(name, **kwargs); Function to perform a geometry optimization. optimize(name, **kwargs); Function to perform a geometry optimization. pcm_helper(block); Passes multiline string block to PCMSolver parser. print_stderr(stuff); Function to print stuff to standard error stream. print_stdout(stuff); Function to print stuff to standard output stream. process_input(raw_input[, print_level]); Function to preprocess raw input, the text of the input file, then parse it, validate it for format, and convert it into legitimate Python. process_pubchem_command(matchobj); Function to process match of pubchem in molecule block. prop(*args, **kwargs); Function to compute various properties. properties(*args, **kwargs); Function to compute various properties. sanitize_name(name); Function to return name in coded form, stripped of characters that confuse filenames, characters into lowercase, + into p, * into s, and (, ), -, & , into _. scf_helper(name[, post_scf]); Function serving as helper to SCF, choosing whether to cast up or just run SCF with a standard guess. scf_wavefunction_factory(name, ref_w",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:261369,Performance,perform,perform,261369,"ng geom. getFromDict(dataDict, mapList). get_memory(); Function to return the total memory allocation. gradient(name, **kwargs); Function complementary to :py:func:~driver.optimize(). hessian(name, **kwargs); Function complementary to frequency(). join_path(prefix, *args). levenshtein(seq1, seq2); Function to compute the Levenshtein distance between two strings. molden(wfn[, filename, density_a, …]); Function to write wavefunction information in wfn to filename in molden format. molecule_from_arrays; classmethod(function) -> method. molecule_from_schema; classmethod(function) -> method. molecule_from_string; classmethod(function) -> method. molecule_get_attr(self, name); Function to redefine __getattr__ method of molecule class. molecule_set_attr(self, name, value); Function to redefine __setattr__ method of molecule class. oeprop(wfn, *args, **kwargs); Evaluate one-electron properties. opt(name, **kwargs); Function to perform a geometry optimization. optimize(name, **kwargs); Function to perform a geometry optimization. pcm_helper(block); Passes multiline string block to PCMSolver parser. print_stderr(stuff); Function to print stuff to standard error stream. print_stdout(stuff); Function to print stuff to standard output stream. process_input(raw_input[, print_level]); Function to preprocess raw input, the text of the input file, then parse it, validate it for format, and convert it into legitimate Python. process_pubchem_command(matchobj); Function to process match of pubchem in molecule block. prop(*args, **kwargs); Function to compute various properties. properties(*args, **kwargs); Function to compute various properties. sanitize_name(name); Function to return name in coded form, stripped of characters that confuse filenames, characters into lowercase, + into p, * into s, and (, ), -, & , into _. scf_helper(name[, post_scf]); Function serving as helper to SCF, choosing whether to cast up or just run SCF with a standard guess. scf_wavefunction_factory(name, ref_w",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:261388,Performance,optimiz,optimization,261388,"ng geom. getFromDict(dataDict, mapList). get_memory(); Function to return the total memory allocation. gradient(name, **kwargs); Function complementary to :py:func:~driver.optimize(). hessian(name, **kwargs); Function complementary to frequency(). join_path(prefix, *args). levenshtein(seq1, seq2); Function to compute the Levenshtein distance between two strings. molden(wfn[, filename, density_a, …]); Function to write wavefunction information in wfn to filename in molden format. molecule_from_arrays; classmethod(function) -> method. molecule_from_schema; classmethod(function) -> method. molecule_from_string; classmethod(function) -> method. molecule_get_attr(self, name); Function to redefine __getattr__ method of molecule class. molecule_set_attr(self, name, value); Function to redefine __setattr__ method of molecule class. oeprop(wfn, *args, **kwargs); Evaluate one-electron properties. opt(name, **kwargs); Function to perform a geometry optimization. optimize(name, **kwargs); Function to perform a geometry optimization. pcm_helper(block); Passes multiline string block to PCMSolver parser. print_stderr(stuff); Function to print stuff to standard error stream. print_stdout(stuff); Function to print stuff to standard output stream. process_input(raw_input[, print_level]); Function to preprocess raw input, the text of the input file, then parse it, validate it for format, and convert it into legitimate Python. process_pubchem_command(matchobj); Function to process match of pubchem in molecule block. prop(*args, **kwargs); Function to compute various properties. properties(*args, **kwargs); Function to compute various properties. sanitize_name(name); Function to return name in coded form, stripped of characters that confuse filenames, characters into lowercase, + into p, * into s, and (, ), -, & , into _. scf_helper(name[, post_scf]); Function serving as helper to SCF, choosing whether to cast up or just run SCF with a standard guess. scf_wavefunction_factory(name, ref_w",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:263349,Performance,optimiz,optimizer,263349,"ndard guess. scf_wavefunction_factory(name, ref_wfn, …); Builds the correct wavefunction from the provided information. set_memory(inputval[, execute]); Function to reset the total memory allocation. set_module_options(module, options_dict); Sets Psi4 module options from a module specification and input dictionary. set_options(options_dict); Sets Psi4 global options from an input dictionary. success(label); Function to print a ‘label…PASSED’ line to screen. vibanal_wfn(wfn[, hess, irrep, molecule, …]). write_eigenvalues(eigs, mo_idx); Prepare multi-line string with one-particle eigenvalues to be written to the FCIDUMP file. xml2dict([filename]); Read XML filename into nested OrderedDict-s. Classes¶. CSXError(msg); Error called when CSX generation fails. ConvergenceError(eqn_description, maxit); Error called for problems with converging and iterative method. Dftd3Error(msg). EmpericalDispersion(alias, dtype, **kwargs). ManagedMethodError(circs). OptimizationConvergenceError(…); Error called for problems with geometry optimizer. ParsingError(msg); Error called for problems parsing a text file. PastureRequiredError(option); Error called when the specified value of option requires some module(s) from Psi4Pasture, but could not be imported. PsiException; Error class for Psi. PsiImportError(msg); Error called for problems import python dependencies. QMMM(). Table([rows, row_label_width, …]); Class defining a flexible Table object for storing data. TestComparisonError(msg); Error called when a test case fails due to a failed compare_values() call. ValidationError(msg); Error called for problems with the input file. datetime(year, month, day[, hour[, minute[, …); The year, month and day arguments are required. Class Inheritance Diagram¶. table of contents. PSI4 API: Linking C++ and Python; psi4.core Module; Functions; Classes; Class Inheritance Diagram. psi4.driver Package; Functions; Classes; Class Inheritance Diagram. «; hide menu. menu; sidebar; »; . Navigation. Index. m",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:126989,Safety,detect,detected,126989,"y. Return type; determined by concern_mol type. Return type:float, tuple, qcdb.Molecule or psi4.core.Molecule. BFS(seed_atoms=None, bond_threshold=1.2, return_arrays=False, return_molecules=False, return_molecule=False)¶; Detect fragments among real atoms through a breadth-first search (BFS) algorithm. Parameters:; self (qcdb.Molecule or psi4.core.Molecule) – ; seed_atoms (list, optional) – List of lists of atoms (0-indexed) belonging to independent fragments.; Useful to prompt algorithm or to define intramolecular fragments through; border atoms. Example: [[1, 0], [2]]; bond_threshold (float, optional) – Factor beyond average of covalent radii to determine bond cutoff.; return_arrays (bool, optional) – If True, also return fragments as list of arrays.; return_molecules (bool, optional) – If True, also return fragments as list of Molecules.; return_molecule (bool, optional) – If True, also return one big Molecule with fragmentation encoded. Returns:; bfs_map (list of lists) – Array of atom indices (0-indexed) of detected fragments.; bfs_arrays (tuple of lists of ndarray, optional) – geom, mass, elem info per-fragment.; Only provided if return_arrays is True.; bfs_molecules (list of qcdb.Molecule or psi4.core.Molecule, optional) – List of molecules, each built from one fragment. Center and; orientation of fragments is fixed so orientation info from self is; not lost. Loses chgmult and ghost/dummy info from self and contains; default chgmult.; Only provided if return_molecules is True.; Returned are of same type as self.; bfs_molecule (qcdb.Molecule or psi4.core.Molecule, optional) – Single molecule with same number of real atoms as self with atoms; reordered into adjacent fragments and fragment markers inserted.; Loses ghost/dummy info from self; keeps total charge but not total mult.; Only provided if return_molecule is True.; Returned is of same type as self. Notes. Relies upon van der Waals radii and so faulty for close (especially; hydrogen-bonded) fragments. See ",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:109947,Security,access,accessor,109947,"gradient-like matrix (N,3) using information from a given molecule. symmetry(self: psi4.core.Matrix) → int¶; Returns the overall symmetry of the matrix. to_array(copy=True, dense=False)¶; Converts a Psi4 Matrix or Vector to a numpy array. Either copies the data or simply; constructs a view. Parameters:; matrix (Matrix or Vector) – Pointers to which Psi4 core class should be used in the construction.; copy (bool, optional) – Copy the data if True, return a view otherwise; dense (bool, optional) – Converts irreped Psi4 objects to diagonally blocked dense arrays if True. Returns a list of arrays otherwise. Returns:array – Returns either a list of np.array’s or the base array depending on options. Return type:ndarray or list of ndarray. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; 1; 2; 3; 4; 5>>> data = psi4.Matrix(3, 3); >>> data.to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. to_serial()¶; Converts an object with a .nph accessor to a serialized dictionary. trace(self: psi4.core.Matrix) → float¶; Returns the trace of the matrix. transform(*args, **kwargs)¶; Overloaded function. transform(self: psi4.core.Matrix, transformer: psi4.core.Matrix) -> None. Transform this matrix with transformer. transform(self: psi4.core.Matrix, a: psi4.core.Matrix, transformer: psi4.core.Matrix) -> None. Transform A with transformer. transpose(self: psi4.core.Matrix) → psi4.core.Matrix¶; Creates a new matrix that is the transpose of this matrix. transpose_this(self: psi4.core.Matrix) → None¶; Transpose the matrix in-place. triplet(A: psi4.core.Matrix, B: psi4.core.Matrix, C: psi4.core.Matrix, transA: bool=False, transB: bool=False, transC: bool=False) → psi4.core.Matrix¶; Returns the multiplication of three matrics A, B, and C, with options to transpose each beforehand. vector_dot(self: psi4.core.Matrix, rhs: psi4.core.Matrix) → float¶; Returns the vector dot product of this with rhs. zero(self: psi4.core.Matrix) → None¶; Zero all elements",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:146501,Security,hash,hash,146501,"nt group to the point group object arg2. set_units(self: psi4.core.Molecule, arg0: psi4.core.GeometryUnits) → None¶; Sets units (Angstrom or Bohr) used to define the geometry. set_variable(self: psi4.core.Molecule, arg0: str, arg1: float) → None¶; Assigns the value arg3 to the variable arg2 in the list of geometry variables, then calls update_geometry(). symbol(self: psi4.core.Molecule, arg0: int) → str¶; Gets the cleaned up label of atom arg2 (C2 => C, H4 = H). symmetrize(self: psi4.core.Molecule, arg0: float) → None¶; Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. symmetry_from_input(self: psi4.core.Molecule) → str¶; Returns the symmetry specified in the input. to_arrays()¶; Exports coordinate info into NumPy arrays. Returns:; geom, mass, elem, elez, uniq (ndarray, ndarray, ndarray, ndarray, ndarray) – (nat, 3) geometry [a0].; (nat,) mass [u].; (nat,) element symbol.; (nat,) atomic number.; (nat,) hash of element symbol and mass.; Note that coordinate, orientation, and element information is; preserved but fragmentation, chgmult, and dummy/ghost is lost.; Usage; —–; geom, mass, elem, elez, uniq = molinstance.to_arrays(). to_dict(force_c1=False, force_units=False, np_out=True)¶; Serializes instance into Molecule dictionary. to_schema(dtype, units='Angstrom', return_type='json')¶; Serializes instance into JSON or YAML according to schema dtype. to_string(dtype, units='Angstrom', atom_format=None, ghost_format=None, width=17, prec=12)¶; Format a string representation of QM molecule. translate(self: psi4.core.Molecule, arg0: psi4.core.Vector3) → None¶; Translates molecule by arg2. units(self: psi4.core.Molecule) → str¶; Returns units used to define the geometry, i.e. ‘Angstrom’ or ‘Bohr’. update_geometry(self: psi4.core.Molecule) → None¶; Reevaluates the geometry with current variable values, orientation directives, etc. Must be called after initial Molecule definition by string. x(self: psi4.c",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:152687,Security,validat,validate,152687,"d function. get_str(self: psi4.core.Options, arg0: str) -> str. get string option. get_str(self: psi4.core.Options, arg0: str) -> str. get string option. read_globals(self: psi4.core.Options) → bool¶; expert. set_array(self: psi4.core.Options, arg0: str, arg1: str) → None¶; set array option. set_bool(self: psi4.core.Options, arg0: str, arg1: str, arg2: bool) → None¶; set bool option. set_current_module(self: psi4.core.Options, arg0: str) → None¶; sets arg0 (all CAPS) as current module. set_double(self: psi4.core.Options, arg0: str, arg1: str, arg2: float) → None¶; set double option. set_int(self: psi4.core.Options, arg0: str, arg1: str, arg2: int) → None¶; set int option. set_read_globals(self: psi4.core.Options, arg0: bool) → None¶; expert. set_str(self: psi4.core.Options, arg0: str, arg1: str, arg2: str) → None¶; set string option. set_str_i(self: psi4.core.Options, arg0: str, arg1: str, arg2: str) → None¶; set string option. validate_options(self: psi4.core.Options) → None¶; validate options for arg0 module. class psi4.core.OrbitalSpace¶; Bases: pybind11_builtins.pybind11_object; Contains information about the orbitals. C(self: psi4.core.OrbitalSpace) → psi4.core.Matrix¶; MO coefficient matrix, AO->MO or SO->MO transformation matrix. basisset(self: psi4.core.OrbitalSpace) → psi::BasisSet¶; The AO basis set used to create C. build_cabs_space(orb_space: psi4.core.OrbitalSpace, ri_space: psi4.core.OrbitalSpace, linear_tol: float) → psi4.core.OrbitalSpace¶; Given two spaces, it projects out one space from the other and returns the new spaces The first argument (orb_space) is the space to project out. The returned space will be orthogonal to this The second argument (ri_space) is the space that is being projected on. The returned space = this space - orb_space The third argument is the tolerance for linear dependencies. build_ri_space(molecule: psi::Molecule, obs_key: str, aux_key: str, lindep_tol: float) → psi4.core.OrbitalSpace¶; Given two basis sets, it merges the b",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:213594,Security,access,accessor,213594,". set_block(self: psi4.core.Vector, slice: psi4.core.Slice, block: psi4.core.Vector) → None¶; Set a vector block. shape¶; Shape of the Psi4 data object. to_array(copy=True, dense=False)¶; Converts a Psi4 Matrix or Vector to a numpy array. Either copies the data or simply; constructs a view. Parameters:; matrix (Matrix or Vector) – Pointers to which Psi4 core class should be used in the construction.; copy (bool, optional) – Copy the data if True, return a view otherwise; dense (bool, optional) – Converts irreped Psi4 objects to diagonally blocked dense arrays if True. Returns a list of arrays otherwise. Returns:array – Returns either a list of np.array’s or the base array depending on options. Return type:ndarray or list of ndarray. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; 1; 2; 3; 4; 5>>> data = psi4.Matrix(3, 3); >>> data.to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. to_serial()¶; Converts an object with a .nph accessor to a serialized dictionary. class psi4.core.Vector3¶; Bases: pybind11_builtins.pybind11_object; Class for vectors of length three, often Cartesian coordinate vectors, and their common operations. cross(self: psi4.core.Vector3, arg0: psi4.core.Vector3) → psi4.core.Vector3¶; Returns cross product of arg1 and arg2. distance(self: psi4.core.Vector3, arg0: psi4.core.Vector3) → float¶; Returns distance between two points represented by arg1 and arg2. dot(self: psi4.core.Vector3, arg0: psi4.core.Vector3) → float¶; Returns dot product of arg1 and arg2. norm(self: psi4.core.Vector3) → float¶; Returns Euclidean norm of arg1. normalize(self: psi4.core.Vector3) → None¶; Returns vector of unit length and arg1 direction. class psi4.core.VectorMatrix¶; Bases: pybind11_builtins.pybind11_object. append(self: List[psi::Matrix], x: psi::Matrix) → None¶; Add an item to the end of the list. count(self: List[psi::Matrix], x: psi::Matrix) → int¶; Return the number of times x appears in the list. extend(self: List[p",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:258040,Security,validat,validate,258040,"want those, see the staticmethod builtin. Functions¶. activate(mol); Function to set molecule object mol as the current active molecule. ancestor(dir[, n]); Get the nth ancestor of a directory. banner(text[, type, width, strNotOutfile]); Function to print text to output file in a banner of minimum width width and minimum three-line height for type = 1 or one-line height for type = 2. basis_helper(block[, name, key, set_option]); For PsiAPI mode, forms a basis specification function from block and associates it with keyword key under handle name. cbs(func, label, **kwargs); Function to define a multistage energy method from combinations of basis set extrapolations and delta corrections and condense the components into a minimum number of calculations. check_iwl_file_from_scf_type(scf_type, wfn); Ensures that a IWL file has been written based on input SCF type. compare_arrays(expected, computed, digits, label); Function to compare two numpy arrays. compare_csx(); Function to validate energies in CSX files against PSIvariables. compare_cubes(expected, computed, label); Function to compare two cube files. compare_fcidumps(expected, computed, label); Function to compare two FCIDUMP files. compare_integers(expected, computed, label); Function to compare two integers. compare_matrices(expected, computed, digits, …); Function to compare two matrices. compare_strings(expected, computed, label); Function to compare two strings. compare_values(expected, computed, digits, label); Function to compare two values. compare_vectors(expected, computed, digits, …); Function to compare two vectors. copy_file_from_scratch(filename, prefix, …); Function to move file out of scratch with correct naming convention. copy_file_to_scratch(filename, prefix, …); Function to move file into scratch with correct naming convention. create_plugin(name, template); Generate plugin in directory with sanitized name based upon template. csx2endict(); Grabs the CSX file as a dictionary, encodes translation",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:258947,Security,sanitiz,sanitized,258947,"_arrays(expected, computed, digits, label); Function to compare two numpy arrays. compare_csx(); Function to validate energies in CSX files against PSIvariables. compare_cubes(expected, computed, label); Function to compare two cube files. compare_fcidumps(expected, computed, label); Function to compare two FCIDUMP files. compare_integers(expected, computed, label); Function to compare two integers. compare_matrices(expected, computed, digits, …); Function to compare two matrices. compare_strings(expected, computed, label); Function to compare two strings. compare_values(expected, computed, digits, label); Function to compare two values. compare_vectors(expected, computed, digits, …); Function to compare two vectors. copy_file_from_scratch(filename, prefix, …); Function to move file out of scratch with correct naming convention. copy_file_to_scratch(filename, prefix, …); Function to move file into scratch with correct naming convention. create_plugin(name, template); Generate plugin in directory with sanitized name based upon template. csx2endict(); Grabs the CSX file as a dictionary, encodes translation of PSI variables to XML blocks, gathers all available energies from CSX file into returned dictionary. cubeprop(wfn, **kwargs); Evaluate properties on a grid and generate cube files. dynamic_variable_bind(cls); Function to dynamically add extra members to the core.Molecule class. energy(name, **kwargs); Function to compute the single-point electronic energy. fchk(wfn, filename); Function to write wavefunction information in wfn to filename in Gaussian FCHK format. fcidump(wfn[, fname, oe_ints]); Save integrals to file in FCIDUMP format as defined in Comp. fcidump_from_file(fname); Function to read in a FCIDUMP file. filter_comments(string); Remove from string any Python-style comments (‘#’ to end of line). find_approximate_string_matches(seq1, …); Function to compute approximate string matches from a list of options. freq(name, **kwargs); Function to compute harmonic",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:261733,Security,validat,validate,261733,"ance between two strings. molden(wfn[, filename, density_a, …]); Function to write wavefunction information in wfn to filename in molden format. molecule_from_arrays; classmethod(function) -> method. molecule_from_schema; classmethod(function) -> method. molecule_from_string; classmethod(function) -> method. molecule_get_attr(self, name); Function to redefine __getattr__ method of molecule class. molecule_set_attr(self, name, value); Function to redefine __setattr__ method of molecule class. oeprop(wfn, *args, **kwargs); Evaluate one-electron properties. opt(name, **kwargs); Function to perform a geometry optimization. optimize(name, **kwargs); Function to perform a geometry optimization. pcm_helper(block); Passes multiline string block to PCMSolver parser. print_stderr(stuff); Function to print stuff to standard error stream. print_stdout(stuff); Function to print stuff to standard output stream. process_input(raw_input[, print_level]); Function to preprocess raw input, the text of the input file, then parse it, validate it for format, and convert it into legitimate Python. process_pubchem_command(matchobj); Function to process match of pubchem in molecule block. prop(*args, **kwargs); Function to compute various properties. properties(*args, **kwargs); Function to compute various properties. sanitize_name(name); Function to return name in coded form, stripped of characters that confuse filenames, characters into lowercase, + into p, * into s, and (, ), -, & , into _. scf_helper(name[, post_scf]); Function serving as helper to SCF, choosing whether to cast up or just run SCF with a standard guess. scf_wavefunction_factory(name, ref_wfn, …); Builds the correct wavefunction from the provided information. set_memory(inputval[, execute]); Function to reset the total memory allocation. set_module_options(module, options_dict); Sets Psi4 module options from a module specification and input dictionary. set_options(options_dict); Sets Psi4 global options from an input dicti",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:105234,Testability,test,tests,105234," matrix argument B Right matrix argument beta Prefactor for the resulting matrix. general_invert(self: psi4.core.Matrix) → None¶; Computes the inverse of any nonsingular matrix using LU factorization. get(*args, **kwargs)¶; Overloaded function. get(self: psi4.core.Matrix, h: int, m: int, n: int) -> float. Returns a single element of a matrix in subblock h, row m, col n. get(self: psi4.core.Matrix, m: int, n: int) -> float. Returns a single element of a matrix, row m, col n. get_block(self: psi4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice) → psi4.core.Matrix¶; Get a matrix block. hermitivitize(self: psi4.core.Matrix) → None¶; Average off-diagonal element in-place. identity(self: psi4.core.Matrix) → None¶; Sets the matrix to the identity. invert(self: psi4.core.Matrix) → None¶; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs)¶; Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType=SaveType.LowerTriangle) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str) → None¶; Loads a matrix from an ASCII file in MPQC format. name¶; The name of the Matrix. Used in printing. nirrep(self: psi4.core.Matrix) → int¶; Returns the number of irreps. np¶; View without only one irrep. classmethod np_read(filename, prefix='')¶; Reads the data from a NumPy compress file. np_write(filename=None, prefix='')¶; Writes the irreped matrix to a NumPy zipped file.; Can return the packed data for saving many matrices into the same file. nph¶; View with irreps. partial_cholesky_factorize(self: psi4.core.Matri",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:125191,Testability,test,test,125191,"; psi4.core.Molecule. Employs the Kabsch, Hungarian, and; Uno algorithms to exhaustively locate the best alignment for; non-oriented, non-ordered structures. Parameters:; concern_mol (qcdb.Molecule or psi4.core.Molecule) – Molecule of concern, to be shifted, rotated, and reordered into; best coincidence with ref_mol.; ref_mol (qcdb.Molecule or psi4.core.Molecule) – Molecule to match.; atoms_map (bool, optional) – Whether atom1 of ref_mol corresponds to atom1 of concern_mol, etc.; If true, specifying True can save much time.; mols_align (bool, optional) – Whether ref_mol and concern_mol have identical geometries by eye; (barring orientation or atom mapping) and expected final RMSD = 0.; If True, procedure is truncated when RMSD condition met, saving time.; do_plot (bool, optional) – Pops up a mpl plot showing before, after, and ref geometries.; run_to_completion (bool, optional) – Run reorderings to completion (past RMSD = 0) even if unnecessary because; mols_align=True. Used to test worst-case timings.; run_resorting (bool, optional) – Run the resorting machinery even if unnecessary because atoms_map=True.; uno_cutoff (float, optional) – TODO; run_mirror (bool, optional) – Run alternate geometries potentially allowing best match to ref_mol; from mirror image of concern_mol. Only run if system confirmed to; be nonsuperimposable upon mirror reflection. Returns:First item is RMSD [A] between ref_mol and the optimally aligned; geometry computed.; Second item is a AlignmentMill namedtuple with fields; (shift, rotation, atommap, mirror) that prescribe the transformation; from concern_mol and the optimally aligned geometry.; Third item is a crude charge-, multiplicity-, fragment-less Molecule; at optimally aligned (and atom-ordered) geometry. Return type; determined by concern_mol type. Return type:float, tuple, qcdb.Molecule or psi4.core.Molecule. BFS(seed_atoms=None, bond_threshold=1.2, return_arrays=False, return_molecules=False, return_molecule=False)¶; Detect fragments",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:143642,Testability,test,test,143642,"specified; vector, supply a 3-element list.; do_rotate (bool or array-like, optional) – Whether to generate a random 3D rotation according to algorithm of Arvo.; To rotate by a specified matrix, supply a 9-element list of lists.; do_resort (bool or array-like, optional) – Whether to shuffle atoms (True) or leave 1st atom 1st, etc. (False).; To specify shuffle, supply a nat-element list of indices.; deflection (float, optional) – If do_rotate, how random a rotation: 0.0 is no change, 0.1 is small; perturbation, 1.0 is completely random.; do_mirror (bool, optional) – Whether to construct the mirror image structure by inverting y-axis.; do_plot (bool, optional) – Pops up a mpl plot showing before, after, and ref geometries.; run_to_completion (bool, optional) – By construction, scrambled systems are fully alignable (final RMSD=0).; Even so, True turns off the mechanism to stop when RMSD reaches zero; and instead proceed to worst possible time.; run_resorting (bool, optional) – Even if atoms not shuffled, test the resorting machinery.; verbose (int, optional) – Print level. Returns:. Return type:None. set_active_fragment(self: psi4.core.Molecule, arg0: int) → None¶; Sets the specified fragment arg2 to be Real. set_active_fragments(self: psi4.core.Molecule, arg0: List[int]) → None¶; Sets the specified list arg2 of fragments to be Real. set_basis_all_atoms(self: psi4.core.Molecule, arg0: str, arg1: str) → None¶; Sets basis set arg2 to all atoms. set_basis_by_label(self: psi4.core.Molecule, arg0: str, arg1: str, arg2: str) → None¶; Sets basis set arg3 to all atoms with label (e.g., H4) arg2. set_basis_by_symbol(self: psi4.core.Molecule, arg0: str, arg1: str, arg2: str) → None¶; Sets basis set arg3 to all atoms with symbol (e.g., H) arg2. set_geometry(self: psi4.core.Molecule, arg0: psi4.core.Matrix) → None¶; Sets the geometry, given a (Natom X 3) matrix arg2 of coordinates (in Bohr). set_ghost_fragment(self: psi4.core.Molecule, arg0: int) → None¶; Sets the specified fragme",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:191596,Testability,test,testing,191596,"¶; Locks the functional to prevent changes. set_max_points(self: psi4.core.SuperFunctional, arg0: int) → None¶; Sets the maximum number of points. set_name(self: psi4.core.SuperFunctional, arg0: str) → None¶; Sets the SuperFunctional name. set_vv10_b(self: psi4.core.SuperFunctional, arg0: float) → None¶; Sets the VV10 b parameter. set_vv10_c(self: psi4.core.SuperFunctional, arg0: float) → None¶; Sets the VV10 c parameter. set_x_alpha(self: psi4.core.SuperFunctional, arg0: float) → None¶; Sets the amount of exact global HF exchange. set_x_beta(self: psi4.core.SuperFunctional, arg0: float) → None¶; Sets the amount of exact HF exchange at long range. set_x_omega(self: psi4.core.SuperFunctional, arg0: float) → None¶; Sets the range-seperation exchange parameter. test_functional(self: psi4.core.SuperFunctional, arg0: psi4.core.Vector, arg1: psi4.core.Vector, arg2: psi4.core.Vector, arg3: psi4.core.Vector, arg4: psi4.core.Vector, arg5: psi4.core.Vector, arg6: psi4.core.Vector) → None¶; Quick testing capabilities. value(self: psi4.core.SuperFunctional, arg0: str) → psi4.core.Vector¶; Returns a given internal value. values(self: psi4.core.SuperFunctional) → Dict[str, psi4.core.Vector]¶; Return all internal values. vv10_b(self: psi4.core.SuperFunctional) → float¶; The VV10 b parameter. vv10_c(self: psi4.core.SuperFunctional) → float¶; The VV10 c parameter. x_alpha(self: psi4.core.SuperFunctional) → float¶; Amount of exact HF exchange. x_beta(self: psi4.core.SuperFunctional) → float¶; Amount of exact HF exchange. x_functional(self: psi4.core.SuperFunctional, arg0: str) → psi::Functional¶; Returns the desired X Functional. x_functionals(self: psi4.core.SuperFunctional) → List[psi::Functional]¶; Returns all X Functionals. x_omega(self: psi4.core.SuperFunctional) → float¶; Range-seperated exchange parameter. class psi4.core.SymmetryOperation¶; Bases: pybind11_builtins.pybind11_object; Class to provide a 3 by 3 matrix representation of a symmetry operation, such as a rotation or ",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:263829,Testability,test,test,263829,"et the total memory allocation. set_module_options(module, options_dict); Sets Psi4 module options from a module specification and input dictionary. set_options(options_dict); Sets Psi4 global options from an input dictionary. success(label); Function to print a ‘label…PASSED’ line to screen. vibanal_wfn(wfn[, hess, irrep, molecule, …]). write_eigenvalues(eigs, mo_idx); Prepare multi-line string with one-particle eigenvalues to be written to the FCIDUMP file. xml2dict([filename]); Read XML filename into nested OrderedDict-s. Classes¶. CSXError(msg); Error called when CSX generation fails. ConvergenceError(eqn_description, maxit); Error called for problems with converging and iterative method. Dftd3Error(msg). EmpericalDispersion(alias, dtype, **kwargs). ManagedMethodError(circs). OptimizationConvergenceError(…); Error called for problems with geometry optimizer. ParsingError(msg); Error called for problems parsing a text file. PastureRequiredError(option); Error called when the specified value of option requires some module(s) from Psi4Pasture, but could not be imported. PsiException; Error class for Psi. PsiImportError(msg); Error called for problems import python dependencies. QMMM(). Table([rows, row_label_width, …]); Class defining a flexible Table object for storing data. TestComparisonError(msg); Error called when a test case fails due to a failed compare_values() call. ValidationError(msg); Error called for problems with the input file. datetime(year, month, day[, hour[, minute[, …); The year, month and day arguments are required. Class Inheritance Diagram¶. table of contents. PSI4 API: Linking C++ and Python; psi4.core Module; Functions; Classes; Class Inheritance Diagram. psi4.driver Package; Functions; Classes; Class Inheritance Diagram. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:61587,Usability,clear,clear,61587,"iven shell pair. origin¶; The origin about which the one body ints are being computed. class psi4.core.ErfComplementERI¶; Bases: psi4.core.TwoBodyAOInt; Computes ERF complement electron repulsion integrals. compute_shell(self: psi4.core.TwoBodyAOInt, arg0: int, arg1: int, arg2: int, arg3: int) → int¶; Compute ERIs between 4 shells. class psi4.core.ErfERI¶; Bases: psi4.core.TwoBodyAOInt; Computes ERF electron repulsion integrals. compute_shell(self: psi4.core.TwoBodyAOInt, arg0: int, arg1: int, arg2: int, arg3: int) → int¶; Compute ERIs between 4 shells. class psi4.core.ExternalPotential¶; Bases: pybind11_builtins.pybind11_object; Stores external potential field, computes external potential matrix. addBasis(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet, coefs: psi4.core.Vector) → None¶; Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self: psi4.core.ExternalPotential, Z: float, x: float, y: float, z: float) → None¶; Add a charge Z at (x,y,z). clear(self: psi4.core.ExternalPotential) → None¶; Reset the field to zero (eliminates all entries). computePotentialMatrix(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet) → psi4.core.Matrix¶; Compute the external potential matrix in the given basis set. print_out(self: psi4.core.ExternalPotential) → None¶; Print python print helper to the outfile. setName(self: psi4.core.ExternalPotential, arg0: str) → None¶; Sets the name. class psi4.core.F12¶; Bases: psi4.core.TwoBodyAOInt; Computes F12 electron repulsion integrals. compute_shell(self: psi4.core.TwoBodyAOInt, arg0: int, arg1: int, arg2: int, arg3: int) → int¶; Compute ERIs between 4 shells. class psi4.core.F12DoubleCommutator¶; Bases: psi4.core.TwoBodyAOInt; Computes F12 Double Commutator electron repulsion integrals. compute_shell(self: psi4.core.TwoBodyAOInt, arg0: int, arg1: int, arg2: int, arg3: int) → int¶; Compute ERIs between 4 shells. class psi4.core.F12G12¶; Bases: psi4.core.TwoBodyAOInt; Computes F12G12 electron repul",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:109228,Usability,simpl,simply,109228,"al. set(self: psi4.core.Matrix, m: int, n: int, val: float) -> None. Sets a single element of a matrix to val at row m, col n. set(self: psi4.core.Matrix, h: int, m: int, n: int, val: float) -> None. Sets a single element of a matrix, subblock h, row m, col n, with value val. set_block(self: psi4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice, block: psi4.core.Matrix) → None¶; Set a matrix block. shape¶; Shape of the Psi4 data object. subtract(self: psi4.core.Matrix, arg0: psi4.core.Matrix) → None¶; Substract a matrix from this matrix. sum_of_squares(self: psi4.core.Matrix) → float¶; Returns the sum of the squares of this matrix. symmetrize_gradient(self: psi4.core.Matrix, mol: psi::Molecule) → None¶; Symmetrizes a gradient-like matrix (N,3) using information from a given molecule. symmetry(self: psi4.core.Matrix) → int¶; Returns the overall symmetry of the matrix. to_array(copy=True, dense=False)¶; Converts a Psi4 Matrix or Vector to a numpy array. Either copies the data or simply; constructs a view. Parameters:; matrix (Matrix or Vector) – Pointers to which Psi4 core class should be used in the construction.; copy (bool, optional) – Copy the data if True, return a view otherwise; dense (bool, optional) – Converts irreped Psi4 objects to diagonally blocked dense arrays if True. Returns a list of arrays otherwise. Returns:array – Returns either a list of np.array’s or the base array depending on options. Return type:ndarray or list of ndarray. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; 1; 2; 3; 4; 5>>> data = psi4.Matrix(3, 3); >>> data.to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. to_serial()¶; Converts an object with a .nph accessor to a serialized dictionary. trace(self: psi4.core.Matrix) → float¶; Returns the trace of the matrix. transform(*args, **kwargs)¶; Overloaded function. transform(self: psi4.core.Matrix, transformer: psi4.core.Matrix) -> None. Transform this matrix with transformer. transfo",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:149480,Usability,clear,clear,149480,"Write the natural bond orbitals to a file. class psi4.core.NablaInt¶; Bases: psi4.core.OneBodyAOInt; Computes nabla integrals. basis¶; The basis set on center one. basis1¶; The basis set on center one. basis2¶; The basis set on center two. compute_shell(self: psi4.core.OneBodyAOInt, arg0: int, arg1: int) → None¶; Compute integrals between basis functions in the given shell pair. origin¶; The origin about which the one body ints are being computed. class psi4.core.OEProp¶; Bases: psi4.core.Prop; docstring. Exvals(self: psi4.core.OEProp) → List[float]¶; The x component of the field (in a.u.) at each grid point. Eyvals(self: psi4.core.OEProp) → List[float]¶; The y component of the field (in a.u.) at each grid point. Ezvals(self: psi4.core.OEProp) → List[float]¶; The z component of the field (in a.u.) at each grid point. Vvals(self: psi4.core.OEProp) → List[float]¶; The electrostatic potential (in a.u.) at each grid point. add(self: psi4.core.OEProp, arg0: str) → None¶; docstring. clear(self: psi4.core.OEProp) → None¶; docstring. compute(self: psi4.core.OEProp) → None¶; docstring. set_Da_ao(self: psi4.core.OEProp, Da: psi::Matrix, symmetry: int=0) → None¶; docstring. set_Da_mo(self: psi4.core.OEProp, arg0: psi::Matrix) → None¶; docstring. set_Da_so(self: psi4.core.OEProp, arg0: psi::Matrix) → None¶; docstring. set_Db_ao(self: psi4.core.OEProp, Db: psi::Matrix, symmetry: int=0) → None¶; docstring. set_Db_mo(self: psi4.core.OEProp, arg0: psi::Matrix) → None¶; docstring. set_Db_so(self: psi4.core.OEProp, arg0: psi::Matrix) → None¶; docstring. set_title(self: psi4.core.Prop, arg0: str) → None¶; docstring. valid_methods = ['DIPOLE', 'QUADRUPOLE', 'MULLIKEN_CHARGES', 'LOWDIN_CHARGES', 'WIBERG_LOWDIN_INDICES', 'MAYER_INDICES', 'MAYER_INDICES', 'MO_EXTENTS', 'GRID_FIELD', 'GRID_ESP', 'ESP_AT_NUCLEI', 'NO_OCCUPATIONS']¶. class psi4.core.OneBodyAOInt¶; Bases: pybind11_builtins.pybind11_object; Basis class for all one-electron integrals. basis¶; The basis set on center one. basis1",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api-1.html:212875,Usability,simpl,simply,212875,"s. np¶; View without only one irrep. classmethod np_read(filename, prefix='')¶; Reads the data from a NumPy compress file. np_write(filename=None, prefix='')¶; Writes the irreped matrix to a NumPy zipped file.; Can return the packed data for saving many matrices into the same file. nph¶; View with irreps. print_out(self: psi4.core.Vector) → None¶; Prints the vector to the output file. scale(self: psi4.core.Vector, sc: float) → None¶; Scales the elements of a vector by sc. set(*args, **kwargs)¶; Overloaded function. set(self: psi4.core.Vector, m: int, val: float) -> None. Sets a single element value located at m. set(self: psi4.core.Vector, h: int, m: int, val: float) -> None. Sets a single element value located at m in irrep h. set_block(self: psi4.core.Vector, slice: psi4.core.Slice, block: psi4.core.Vector) → None¶; Set a vector block. shape¶; Shape of the Psi4 data object. to_array(copy=True, dense=False)¶; Converts a Psi4 Matrix or Vector to a numpy array. Either copies the data or simply; constructs a view. Parameters:; matrix (Matrix or Vector) – Pointers to which Psi4 core class should be used in the construction.; copy (bool, optional) – Copy the data if True, return a view otherwise; dense (bool, optional) – Converts irreped Psi4 objects to diagonally blocked dense arrays if True. Returns a list of arrays otherwise. Returns:array – Returns either a list of np.array’s or the base array depending on options. Return type:ndarray or list of ndarray. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; 1; 2; 3; 4; 5>>> data = psi4.Matrix(3, 3); >>> data.to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. to_serial()¶; Converts an object with a .nph accessor to a serialized dictionary. class psi4.core.Vector3¶; Bases: pybind11_builtins.pybind11_object; Class for vectors of length three, often Cartesian coordinate vectors, and their common operations. cross(self: psi4.core.Vector3, arg0: psi4.core.Vector3) → psi4.core.Vector3¶",MatchSource.WIKI,psi4manual/1.2.1/psi4api-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:1997,Availability,error,error,1997,"gin about which the one body ints are being computed. class psi4.core.BSVec¶; Bases: pybind11_builtins.pybind11_object. append(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo) → None¶; Add an item to the end of the list. count(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo) → int¶; Return the number of times x appears in the list. extend(self: List[psi4.core.ShellInfo], L: List[psi4.core.ShellInfo]) → None¶; Extend the list by appending all the items in the given list. insert(self: List[psi4.core.ShellInfo], i: int, x: psi4.core.ShellInfo) → None¶; Insert an item at a given position. pop(*args, **kwargs)¶; Overloaded function. pop(self: List[psi4.core.ShellInfo]) -> psi4.core.ShellInfo. Remove and return the last item. pop(self: List[psi4.core.ShellInfo], i: int) -> psi4.core.ShellInfo. Remove and return the item at index i. remove(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo) → None¶; Remove the first item from the list whose value is x. It is an error if there is no such item. class psi4.core.BasisExtents¶; Bases: pybind11_builtins.pybind11_object; docstring. basis(self: psi4.core.BasisExtents) → psi4.core.BasisSet¶; docstring. delta(self: psi4.core.BasisExtents) → float¶; docstring. maxR(self: psi4.core.BasisExtents) → float¶; docstring. set_delta(self: psi4.core.BasisExtents, arg0: float) → None¶; docstring. shell_extents(self: psi4.core.BasisExtents) → psi4.core.Vector¶; docstring. class psi4.core.BasisFunctions¶; Bases: pybind11_builtins.pybind11_object; docstring. basis_values(self: psi4.core.BasisFunctions) → Dict[str, psi4.core.Matrix]¶; docstring. compute_functions(self: psi4.core.BasisFunctions, arg0: psi::BlockOPoints) → None¶; docstring. deriv(self: psi4.core.BasisFunctions) → int¶; docstring. max_functions(self: psi4.core.BasisFunctions) → int¶; docstring. max_points(self: psi4.core.BasisFunctions) → int¶; docstring. set_deriv(self: psi4.core.BasisFunctions, arg0: int) → None¶; docstring. class psi4.core.BasisSet¶; Bases: pyb",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:127900,Availability,fault,faulty,127900,"ncoded. Returns:; bfs_map (list of lists) – Array of atom indices (0-indexed) of detected fragments.; bfs_arrays (tuple of lists of ndarray, optional) – geom, mass, elem info per-fragment.; Only provided if return_arrays is True.; bfs_molecules (list of qcdb.Molecule or psi4.core.Molecule, optional) – List of molecules, each built from one fragment. Center and; orientation of fragments is fixed so orientation info from self is; not lost. Loses chgmult and ghost/dummy info from self and contains; default chgmult.; Only provided if return_molecules is True.; Returned are of same type as self.; bfs_molecule (qcdb.Molecule or psi4.core.Molecule, optional) – Single molecule with same number of real atoms as self with atoms; reordered into adjacent fragments and fragment markers inserted.; Loses ghost/dummy info from self; keeps total charge but not total mult.; Only provided if return_molecule is True.; Returned is of same type as self. Notes. Relies upon van der Waals radii and so faulty for close (especially; hydrogen-bonded) fragments. See seed_atoms. Any existing fragmentation info/chgmult encoded in self is lost.; Original code from Michael S. Marshall, linear-scaling algorithm from; Trent M. Parker, revamped by Lori A. Burns. Z(self: psi4.core.Molecule, arg0: int) → float¶; Nuclear charge of atom. activate_all_fragments(self: psi4.core.Molecule) → None¶; Sets all fragments in the molecule to be active. add_atom(self: psi4.core.Molecule, arg0: float, arg1: float, arg2: float, arg3: float, arg4: str, arg5: float, arg6: float, arg7: str, arg8: int) → None¶; Adds to Molecule arg1 an atom with atomic number arg2, Cartesian coordinates in Bohr (arg3, arg4, arg5), atomic symbol arg6, mass arg7, charge arg8 (optional), and lineno arg9 (optional). atom_at_position(self: psi4.core.Molecule, arg0: float, arg1: float) → int¶; Tests to see if an atom is at the position arg2 with a given tolerance arg3. basis_on_atom(self: psi4.core.Molecule, arg0: int) → str¶; Gets the label of ",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:128816,Availability,toler,tolerance,128816,"ult.; Only provided if return_molecule is True.; Returned is of same type as self. Notes. Relies upon van der Waals radii and so faulty for close (especially; hydrogen-bonded) fragments. See seed_atoms. Any existing fragmentation info/chgmult encoded in self is lost.; Original code from Michael S. Marshall, linear-scaling algorithm from; Trent M. Parker, revamped by Lori A. Burns. Z(self: psi4.core.Molecule, arg0: int) → float¶; Nuclear charge of atom. activate_all_fragments(self: psi4.core.Molecule) → None¶; Sets all fragments in the molecule to be active. add_atom(self: psi4.core.Molecule, arg0: float, arg1: float, arg2: float, arg3: float, arg4: str, arg5: float, arg6: float, arg7: str, arg8: int) → None¶; Adds to Molecule arg1 an atom with atomic number arg2, Cartesian coordinates in Bohr (arg3, arg4, arg5), atomic symbol arg6, mass arg7, charge arg8 (optional), and lineno arg9 (optional). atom_at_position(self: psi4.core.Molecule, arg0: float, arg1: float) → int¶; Tests to see if an atom is at the position arg2 with a given tolerance arg3. basis_on_atom(self: psi4.core.Molecule, arg0: int) → str¶; Gets the label of the orbital basis set on a given atom. center_of_mass(self: psi4.core.Molecule) → psi4.core.Vector3¶; Computes center of mass of molecule (does not translate molecule). charge(self: psi4.core.Molecule, arg0: int) → float¶; Gets charge of atom. clone(self: psi4.core.Molecule) → psi4.core.Molecule¶; Returns a new Molecule identical to arg1. com_fixed(self: psi4.core.Molecule) → bool¶; Get whether or not COM is fixed. create_molecule_from_string(arg0: str) → psi4.core.Molecule¶; Returns a new Molecule with member data from the geometry string arg1 in psi4 format. create_psi4_string_from_molecule(self: psi4.core.Molecule) → str¶; Gets a string reexpressing in input format the current states of the molecule. deactivate_all_fragments(self: psi4.core.Molecule) → None¶; Sets all fragments in the molecule to be inactive. distance_matrix(self: psi4.core.Molecu",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:131809,Availability,error,error,131809," copy of arg1 with arg2 fragments Real. extract_subsets(self: psi4.core.Molecule, arg0: int) -> psi4.core.Molecule. Returns copy of arg1 with arg2 fragment Real. fZ(self: psi4.core.Molecule, arg0: int) → float¶; Nuclear charge of atom arg1 (0-indexed including dummies). find_point_group(self: psi4.core.Molecule, arg0: float) → psi4.core.PointGroup¶; Finds computational molecular point group, user can override this with the symmetry keyword. fix_com(self: psi4.core.Molecule, arg0: bool) → None¶; Whether to fix the Cartesian position, or to translate to the C.O.M. fix_orientation(self: psi4.core.Molecule, arg0: bool) → None¶; Fix the orientation at its current frame. form_symmetry_information(self: psi4.core.Molecule, arg0: float) → None¶; Uses the point group object obtain by calling point_group(). classmethod from_arrays(geom=None, elea=None, elez=None, elem=None, mass=None, real=None, elbl=None, name=None, units='Angstrom', input_units_to_au=None, fix_com=None, fix_orientation=None, fix_symmetry=None, fragment_separators=None, fragment_charges=None, fragment_multiplicities=None, molecular_charge=None, molecular_multiplicity=None, missing_enabled_return='error', tooclose=0.1, zero_ghost_fragments=False, nonphysical=False, mtol=0.001, verbose=1, return_dict=False)¶; Construct Molecule from unvalidated arrays and variables.; Light wrapper around from_arrays(); that is a full-featured constructor to dictionary representa-; tion of Molecule. This follows one step further to return; Molecule instance.; :param See from_arrays().:. Returns:. Return type:psi4.core.Molecule. from_dict(arg0: dict) → psi4.core.Molecule¶; Returns a new Molecule constructed from python dictionary. In progress: name and capabilities should not be relied upon. classmethod from_schema(molschema, return_dict=False, verbose=1)¶; Construct Molecule from non-Psi4 schema.; Light wrapper around from_arrays(). Parameters:; molschema (dict) – Dictionary form of Molecule following known schema.; return_dict",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:146103,Availability,toler,tolerance,146103,"ge. set_multiplicity(self: psi4.core.Molecule, arg0: int) → None¶; Sets the multiplicity (defined as 2Ms + 1). set_name(self: psi4.core.Molecule, arg0: str) → None¶; Sets molecule name. set_nuclear_charge(self: psi4.core.Molecule, arg0: int, arg1: float) → None¶; Set the nuclear charge of the given atom to the value provided. set_point_group(self: psi4.core.Molecule, arg0: psi4.core.PointGroup) → None¶; Sets the molecular point group to the point group object arg2. set_units(self: psi4.core.Molecule, arg0: psi4.core.GeometryUnits) → None¶; Sets units (Angstrom or Bohr) used to define the geometry. set_variable(self: psi4.core.Molecule, arg0: str, arg1: float) → None¶; Assigns the value arg3 to the variable arg2 in the list of geometry variables, then calls update_geometry(). symbol(self: psi4.core.Molecule, arg0: int) → str¶; Gets the cleaned up label of atom arg2 (C2 => C, H4 = H). symmetrize(self: psi4.core.Molecule, arg0: float) → None¶; Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. symmetry_from_input(self: psi4.core.Molecule) → str¶; Returns the symmetry specified in the input. to_arrays()¶; Exports coordinate info into NumPy arrays. Returns:; geom, mass, elem, elez, uniq (ndarray, ndarray, ndarray, ndarray, ndarray) – (nat, 3) geometry [a0].; (nat,) mass [u].; (nat,) element symbol.; (nat,) atomic number.; (nat,) hash of element symbol and mass.; Note that coordinate, orientation, and element information is; preserved but fragmentation, chgmult, and dummy/ghost is lost.; Usage; —–; geom, mass, elem, elez, uniq = molinstance.to_arrays(). to_dict(force_c1=False, force_units=False, np_out=True)¶; Serializes instance into Molecule dictionary. to_schema(dtype, units='Angstrom', return_type='json')¶; Serializes instance into JSON or YAML according to schema dtype. to_string(dtype, units='Angstrom', atom_format=None, ghost_format=None, width=17, prec=12)¶; Format a string representation of Q",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:153509,Availability,toler,tolerance,153509,"arg1: str, arg2: str) → None¶; set string option. set_str_i(self: psi4.core.Options, arg0: str, arg1: str, arg2: str) → None¶; set string option. validate_options(self: psi4.core.Options) → None¶; validate options for arg0 module. class psi4.core.OrbitalSpace¶; Bases: pybind11_builtins.pybind11_object; Contains information about the orbitals. C(self: psi4.core.OrbitalSpace) → psi4.core.Matrix¶; MO coefficient matrix, AO->MO or SO->MO transformation matrix. basisset(self: psi4.core.OrbitalSpace) → psi::BasisSet¶; The AO basis set used to create C. build_cabs_space(orb_space: psi4.core.OrbitalSpace, ri_space: psi4.core.OrbitalSpace, linear_tol: float) → psi4.core.OrbitalSpace¶; Given two spaces, it projects out one space from the other and returns the new spaces The first argument (orb_space) is the space to project out. The returned space will be orthogonal to this The second argument (ri_space) is the space that is being projected on. The returned space = this space - orb_space The third argument is the tolerance for linear dependencies. build_ri_space(molecule: psi::Molecule, obs_key: str, aux_key: str, lindep_tol: float) → psi4.core.OrbitalSpace¶; Given two basis sets, it merges the basis sets and then constructs an orthogonalized space with the same span. Linearly dependent orbitals are thrown out. The first argument, molecule, is the molecule to construct the basis for The second argument, obs_key, is the option keyword for orbital basis set ‘BASIS’ The third argument, aux_key, is the option keyword for auxiliery basis set ‘DF_BASIS_MP2’ The fourth argument, lindep_tol, is the tolerance for linear dependencies. dim(self: psi4.core.OrbitalSpace) → psi4.core.Dimension¶; MO dimensions. evals(self: psi4.core.OrbitalSpace) → psi4.core.Vector¶; Corresponding eigenvalues of the C matrix. id(self: psi4.core.OrbitalSpace) → str¶; Unique identifier. integral(self: psi4.core.OrbitalSpace) → psi4.core.IntegralFactory¶; The integral factory used to create C. name(self: psi4.c",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:154098,Availability,toler,tolerance,154098,"ore.OrbitalSpace) → psi::BasisSet¶; The AO basis set used to create C. build_cabs_space(orb_space: psi4.core.OrbitalSpace, ri_space: psi4.core.OrbitalSpace, linear_tol: float) → psi4.core.OrbitalSpace¶; Given two spaces, it projects out one space from the other and returns the new spaces The first argument (orb_space) is the space to project out. The returned space will be orthogonal to this The second argument (ri_space) is the space that is being projected on. The returned space = this space - orb_space The third argument is the tolerance for linear dependencies. build_ri_space(molecule: psi::Molecule, obs_key: str, aux_key: str, lindep_tol: float) → psi4.core.OrbitalSpace¶; Given two basis sets, it merges the basis sets and then constructs an orthogonalized space with the same span. Linearly dependent orbitals are thrown out. The first argument, molecule, is the molecule to construct the basis for The second argument, obs_key, is the option keyword for orbital basis set ‘BASIS’ The third argument, aux_key, is the option keyword for auxiliery basis set ‘DF_BASIS_MP2’ The fourth argument, lindep_tol, is the tolerance for linear dependencies. dim(self: psi4.core.OrbitalSpace) → psi4.core.Dimension¶; MO dimensions. evals(self: psi4.core.OrbitalSpace) → psi4.core.Vector¶; Corresponding eigenvalues of the C matrix. id(self: psi4.core.OrbitalSpace) → str¶; Unique identifier. integral(self: psi4.core.OrbitalSpace) → psi4.core.IntegralFactory¶; The integral factory used to create C. name(self: psi4.core.OrbitalSpace) → str¶; Name of the orbital space. nirrep(self: psi4.core.OrbitalSpace) → int¶; Returns number of irreps. print_out(self: psi4.core.OrbitalSpace) → None¶; Print information about the orbital space to the output file. class psi4.core.OverlapInt¶; Bases: psi4.core.OneBodyAOInt; Computes overlap integrals. basis¶; The basis set on center one. basis1¶; The basis set on center one. basis2¶; The basis set on center two. compute_shell(self: psi4.core.OneBodyAOInt, a",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:215151,Availability,error,error,215151,"lf: psi4.core.Vector3) → float¶; Returns Euclidean norm of arg1. normalize(self: psi4.core.Vector3) → None¶; Returns vector of unit length and arg1 direction. class psi4.core.VectorMatrix¶; Bases: pybind11_builtins.pybind11_object. append(self: List[psi::Matrix], x: psi::Matrix) → None¶; Add an item to the end of the list. count(self: List[psi::Matrix], x: psi::Matrix) → int¶; Return the number of times x appears in the list. extend(self: List[psi::Matrix], L: List[psi::Matrix]) → None¶; Extend the list by appending all the items in the given list. insert(self: List[psi::Matrix], i: int, x: psi::Matrix) → None¶; Insert an item at a given position. pop(*args, **kwargs)¶; Overloaded function. pop(self: List[psi::Matrix]) -> psi::Matrix. Remove and return the last item. pop(self: List[psi::Matrix], i: int) -> psi::Matrix. Remove and return the item at index i. remove(self: List[psi::Matrix], x: psi::Matrix) → None¶; Remove the first item from the list whose value is x. It is an error if there is no such item. class psi4.core.Wavefunction¶; Bases: pybind11_builtins.pybind11_object; docstring. Ca(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Alpha Orbitals. Ca_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Matrix¶; Returns the requested Alpha Orbital subset. Cb(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Beta Orbitals. Cb_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Matrix¶; Returns the requested Beta Orbital subset. Da(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Alpha Density Matrix. Da_subset(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Returns the requested Alpha Density subset. Db(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Beta Density Matrix. Db_subset(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Returns the requested Beta Density subset. Fa(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Alpha F",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:228450,Availability,avail,available,228450,"st[psi::Matrix]¶; Gets list of displacements needed for a finite difference gradient computation, from energy points. psi4.core.fd_geoms_freq_0(arg0: psi::Molecule, arg1: int) → List[psi::Matrix]¶; Gets list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep. psi4.core.fd_geoms_freq_1(arg0: psi::Molecule, arg1: int) → List[psi::Matrix]¶; Gets list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep. psi4.core.finalize() → None¶. psi4.core.flush_outfile() → None¶; Flushes the output file. psi4.core.fnocc(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the fno-ccsd(t)/qcisd(t)/mp4/cepa energy code. psi4.core.get_active_efp() → psi4.core.EFP¶; Returns the currently active EFP object. psi4.core.get_active_molecule() → psi::Molecule¶; Returns the currently active molecule object. psi4.core.get_array_variable(arg0: str) → psi::Matrix¶; Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available). psi4.core.get_array_variables() → Dict[str, psi::Matrix]¶; Returns dictionary of the PSI variables set internally by the modules or python driver. psi4.core.get_atomic_point_charges() → psi::Vector¶; Returns the most recently computed atomic point charges, as a double * object. psi4.core.get_datadir() → str¶; Sets the path to shared text resources, PSIDATADIR. psi4.core.get_efp_torque() → psi::Matrix¶; Returns the most recently computed gradient for the EFP portion, as a Nefp by 6 Matrix object. psi4.core.get_frequencies() → psi::Vector¶; Returns the most recently computed frequencies, as a 3N-6 Vector object. psi4.core.get_global_option(arg0: str) → object¶; Given a string of a keyword name arg1, returns the value associated with the keyword from the global options. Returns error if keyword is not recognized. psi4.core.get_global_option_list() → List[str]¶; Returns a list of all global options. p",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:229248,Availability,error,error,229248,"le object. psi4.core.get_array_variable(arg0: str) → psi::Matrix¶; Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available). psi4.core.get_array_variables() → Dict[str, psi::Matrix]¶; Returns dictionary of the PSI variables set internally by the modules or python driver. psi4.core.get_atomic_point_charges() → psi::Vector¶; Returns the most recently computed atomic point charges, as a double * object. psi4.core.get_datadir() → str¶; Sets the path to shared text resources, PSIDATADIR. psi4.core.get_efp_torque() → psi::Matrix¶; Returns the most recently computed gradient for the EFP portion, as a Nefp by 6 Matrix object. psi4.core.get_frequencies() → psi::Vector¶; Returns the most recently computed frequencies, as a 3N-6 Vector object. psi4.core.get_global_option(arg0: str) → object¶; Given a string of a keyword name arg1, returns the value associated with the keyword from the global options. Returns error if keyword is not recognized. psi4.core.get_global_option_list() → List[str]¶; Returns a list of all global options. psi4.core.get_gradient() → psi::Matrix¶; Returns the most recently computed gradient, as a N by 3 Matrix object. psi4.core.get_legacy_molecule() → psi::Molecule¶; Returns the currently active molecule object. psi4.core.get_local_option(arg0: str, arg1: str) → object¶; Given a string of a keyword name arg2 and a particular module arg1, returns the value associated with the keyword in the module options scope. Returns error if keyword is not recognized for the module. psi4.core.get_memory() → int¶; Returns the amount of memory available to Psi (in bytes). psi4.core.get_num_threads() → int¶; Returns the number of threads to use in SMP parallel computations. psi4.core.get_option(arg0: str, arg1: str) → object¶; Given a string of a keyword name arg2 and a particular module arg1, returns the local value associated with the keyword if it’s been set, else the global value if it’s been ",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:229791,Availability,error,error,229791,", PSIDATADIR. psi4.core.get_efp_torque() → psi::Matrix¶; Returns the most recently computed gradient for the EFP portion, as a Nefp by 6 Matrix object. psi4.core.get_frequencies() → psi::Vector¶; Returns the most recently computed frequencies, as a 3N-6 Vector object. psi4.core.get_global_option(arg0: str) → object¶; Given a string of a keyword name arg1, returns the value associated with the keyword from the global options. Returns error if keyword is not recognized. psi4.core.get_global_option_list() → List[str]¶; Returns a list of all global options. psi4.core.get_gradient() → psi::Matrix¶; Returns the most recently computed gradient, as a N by 3 Matrix object. psi4.core.get_legacy_molecule() → psi::Molecule¶; Returns the currently active molecule object. psi4.core.get_local_option(arg0: str, arg1: str) → object¶; Given a string of a keyword name arg2 and a particular module arg1, returns the value associated with the keyword in the module options scope. Returns error if keyword is not recognized for the module. psi4.core.get_memory() → int¶; Returns the amount of memory available to Psi (in bytes). psi4.core.get_num_threads() → int¶; Returns the number of threads to use in SMP parallel computations. psi4.core.get_option(arg0: str, arg1: str) → object¶; Given a string of a keyword name arg2 and a particular module arg1, returns the local value associated with the keyword if it’s been set, else the global value if it’s been set, else the local core.default value. Returns error if keyword is not recognized globally or if keyword is not recognized for the module. psi4.core.get_options() → psi::Options¶; Get options. psi4.core.get_output_file() → str¶. psi4.core.get_variable(arg0: str) → float¶; Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available). psi4.core.get_variables() → Dict[str, float]¶; Returns dictionary of the PSI variables set internally by the modules or python driver. psi4.cor",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:229902,Availability,avail,available,229902,"ly computed gradient for the EFP portion, as a Nefp by 6 Matrix object. psi4.core.get_frequencies() → psi::Vector¶; Returns the most recently computed frequencies, as a 3N-6 Vector object. psi4.core.get_global_option(arg0: str) → object¶; Given a string of a keyword name arg1, returns the value associated with the keyword from the global options. Returns error if keyword is not recognized. psi4.core.get_global_option_list() → List[str]¶; Returns a list of all global options. psi4.core.get_gradient() → psi::Matrix¶; Returns the most recently computed gradient, as a N by 3 Matrix object. psi4.core.get_legacy_molecule() → psi::Molecule¶; Returns the currently active molecule object. psi4.core.get_local_option(arg0: str, arg1: str) → object¶; Given a string of a keyword name arg2 and a particular module arg1, returns the value associated with the keyword in the module options scope. Returns error if keyword is not recognized for the module. psi4.core.get_memory() → int¶; Returns the amount of memory available to Psi (in bytes). psi4.core.get_num_threads() → int¶; Returns the number of threads to use in SMP parallel computations. psi4.core.get_option(arg0: str, arg1: str) → object¶; Given a string of a keyword name arg2 and a particular module arg1, returns the local value associated with the keyword if it’s been set, else the global value if it’s been set, else the local core.default value. Returns error if keyword is not recognized globally or if keyword is not recognized for the module. psi4.core.get_options() → psi::Options¶; Get options. psi4.core.get_output_file() → str¶. psi4.core.get_variable(arg0: str) → float¶; Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available). psi4.core.get_variables() → Dict[str, float]¶; Returns dictionary of the PSI variables set internally by the modules or python driver. psi4.core.get_writer_file_prefix(arg0: str) → str¶; Returns the prefix to use for writi",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:230309,Availability,error,error,230309," all global options. psi4.core.get_gradient() → psi::Matrix¶; Returns the most recently computed gradient, as a N by 3 Matrix object. psi4.core.get_legacy_molecule() → psi::Molecule¶; Returns the currently active molecule object. psi4.core.get_local_option(arg0: str, arg1: str) → object¶; Given a string of a keyword name arg2 and a particular module arg1, returns the value associated with the keyword in the module options scope. Returns error if keyword is not recognized for the module. psi4.core.get_memory() → int¶; Returns the amount of memory available to Psi (in bytes). psi4.core.get_num_threads() → int¶; Returns the number of threads to use in SMP parallel computations. psi4.core.get_option(arg0: str, arg1: str) → object¶; Given a string of a keyword name arg2 and a particular module arg1, returns the local value associated with the keyword if it’s been set, else the global value if it’s been set, else the local core.default value. Returns error if keyword is not recognized globally or if keyword is not recognized for the module. psi4.core.get_options() → psi::Options¶; Get options. psi4.core.get_output_file() → str¶. psi4.core.get_variable(arg0: str) → float¶; Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available). psi4.core.get_variables() → Dict[str, float]¶; Returns dictionary of the PSI variables set internally by the modules or python driver. psi4.core.get_writer_file_prefix(arg0: str) → str¶; Returns the prefix to use for writing files for external programs. psi4.core.git_version() → str¶; Returns the git version of this copy of Psi. psi4.core.has_global_option_changed(arg0: str) → bool¶; Returns boolean for whether the keyword arg1 has been touched in the global scope, by either user or code. Notwithstanding, code is written such that in practice, this returns whether the option has been touched in the global scope by the user. psi4.core.has_local_option_changed(arg0: str, arg",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:230657,Availability,avail,available,230657,".core.get_local_option(arg0: str, arg1: str) → object¶; Given a string of a keyword name arg2 and a particular module arg1, returns the value associated with the keyword in the module options scope. Returns error if keyword is not recognized for the module. psi4.core.get_memory() → int¶; Returns the amount of memory available to Psi (in bytes). psi4.core.get_num_threads() → int¶; Returns the number of threads to use in SMP parallel computations. psi4.core.get_option(arg0: str, arg1: str) → object¶; Given a string of a keyword name arg2 and a particular module arg1, returns the local value associated with the keyword if it’s been set, else the global value if it’s been set, else the local core.default value. Returns error if keyword is not recognized globally or if keyword is not recognized for the module. psi4.core.get_options() → psi::Options¶; Get options. psi4.core.get_output_file() → str¶. psi4.core.get_variable(arg0: str) → float¶; Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available). psi4.core.get_variables() → Dict[str, float]¶; Returns dictionary of the PSI variables set internally by the modules or python driver. psi4.core.get_writer_file_prefix(arg0: str) → str¶; Returns the prefix to use for writing files for external programs. psi4.core.git_version() → str¶; Returns the git version of this copy of Psi. psi4.core.has_global_option_changed(arg0: str) → bool¶; Returns boolean for whether the keyword arg1 has been touched in the global scope, by either user or code. Notwithstanding, code is written such that in practice, this returns whether the option has been touched in the global scope by the user. psi4.core.has_local_option_changed(arg0: str, arg1: str) → bool¶; Returns boolean for whether the keyword arg2 has been touched in the scope of the specified module arg1, by either user or code. Notwithstanding, code is written such that in practice, this returns whether the option h",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:236155,Availability,avail,available,236155,"s, this command is called on the option so that has_changed reflects whether the user (not the program) has touched the option. psi4.core.run_gdma(arg0: psi::Wavefunction, arg1: str) → float¶; Runs the GDMA code. psi4.core.sapt(arg0: psi::Wavefunction, arg1: psi::Wavefunction, arg2: psi::Wavefunction) → float¶; Runs the symmetry adapted perturbation theory code. psi4.core.scatter(arg0: psi::Molecule, arg1: float, arg2: list, arg3: list, arg4: list) → None¶; New Scatter function. psi4.core.scfgrad(arg0: psi::Wavefunction) → psi::Matrix¶; Run scfgrad, which is a specialized DF-SCF gradient program. psi4.core.scfhess(arg0: psi::Wavefunction) → psi::Matrix¶; Run scfhess, which is a specialized DF-SCF hessian program. psi4.core.set_active_molecule(arg0: psi::Molecule) → None¶; Activates a previously defined (in the input) molecule, by name. psi4.core.set_array_variable(arg0: str, arg1: psi::Matrix) → None¶; Sets a PSI variable, by name. psi4.core.set_datadir(arg0: str) → None¶; Returns the amount of memory available to Psi (in bytes). psi4.core.set_efp_torque(arg0: psi::Matrix) → None¶; Assigns the global EFP gradient to the values stored in the Nefp by 6 Matrix argument. psi4.core.set_frequencies(arg0: psi::Vector) → None¶; Assigns the global frequencies to the values stored in the 3N-6 Vector argument. psi4.core.set_global_option(*args, **kwargs)¶; Overloaded function. set_global_option(arg0: str, arg1: list) -> bool. Sets value arg2 to array keyword arg1 for all modules. set_global_option(arg0: str, arg1: int) -> bool. Sets value arg2 to integer keyword arg1 for all modules. set_global_option(arg0: str, arg1: float) -> bool. Sets value arg2 to double keyword arg1 for all modules. set_global_option(arg0: str, arg1: str) -> bool. Sets value arg2 to string keyword arg1 for all modules. psi4.core.set_gradient(arg0: psi::Matrix) → None¶; Assigns the global gradient to the values stored in the N by 3 Matrix argument. psi4.core.set_legacy_molecule(arg0: psi::Molecule) → None¶",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:238196,Availability,avail,available,238196,"in the input) molecule, by name. psi4.core.set_legacy_wavefunction(arg0: psi::Wavefunction) → None¶; Returns the current legacy_wavefunction object from the most recent computation. psi4.core.set_local_option(*args, **kwargs)¶; Overloaded function. set_local_option(arg0: str, arg1: str, arg2: list) -> bool. Sets value arg3 to array keyword arg2 scoped only to a specific module arg1. set_local_option(arg0: str, arg1: str, arg2: int) -> bool. Sets value arg3 to integer keyword arg2 scoped only to a specific module arg1. set_local_option(arg0: str, arg1: str, arg2: float) -> bool. Sets value arg3 to double keyword arg2 scoped only to a specific module arg1. set_local_option(arg0: str, arg1: str, arg2: str) -> bool. Sets value arg3 to string keyword arg2 scoped only to a specific module arg1. psi4.core.set_local_option_python(arg0: str, arg1: object) → None¶; Sets an option to a Python object, but scoped only to a single module. psi4.core.set_memory_bytes(memory: int, quiet: bool=False) → None¶; Sets the memory available to Psi (in bytes). psi4.core.set_num_threads(nthread: int, quiet: bool=False) → None¶; Sets the number of threads to use in SMP parallel computations. psi4.core.set_output_file(*args, **kwargs)¶; Overloaded function. set_output_file(arg0: str) -> None; set_output_file(arg0: str, arg1: bool) -> None. psi4.core.set_parent_symmetry(arg0: str) → None¶; Sets the symmetry of the ‘parent’ (undisplaced) geometry, by Schoenflies symbol, at the beginning of a finite difference computation. psi4.core.set_psi_file_prefix(arg0: str) → None¶. psi4.core.set_variable(arg0: str, arg1: float) → None¶; Sets a PSI variable, by name. psi4.core.tstart() → None¶; docstring. psi4.core.tstop() → None¶; docstring. psi4.core.version() → str¶; Returns the version ID of this copy of Psi. Functions¶. DASUM(arg0, arg1, arg2, arg3); docstring. DAXPY(arg0, arg1, arg2, arg3, arg4, arg5, arg6); docstring. DCOPY(arg0, arg1, arg2, arg3, arg4, arg5); docstring. DDOT(arg0, arg1, arg2, arg3, ",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:243895,Availability,avail,available,243895,"on, from energy points. fd_freq_0(arg0, arg1, arg2); Performs a finite difference frequency computation, from energy points, for a given irrep. fd_freq_1(arg0, arg1, arg2); Performs a finite difference frequency computation, from gradients, for a given irrep. fd_geoms_1_0(arg0); Gets list of displacements needed for a finite difference gradient computation, from energy points. fd_geoms_freq_0(arg0, arg1); Gets list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep. fd_geoms_freq_1(arg0, arg1); Gets list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep. finalize(). flush_outfile(); Flushes the output file. fnocc(arg0); Runs the fno-ccsd(t)/qcisd(t)/mp4/cepa energy code. get_active_efp(); Returns the currently active EFP object. get_active_molecule(); Returns the currently active molecule object. get_array_variable(arg0); Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available). get_array_variables(); Returns dictionary of the PSI variables set internally by the modules or python driver. get_atomic_point_charges(); Returns the most recently computed atomic point charges, as a double * object. get_datadir(); Sets the path to shared text resources, PSIDATADIR. get_efp_torque(); Returns the most recently computed gradient for the EFP portion, as a Nefp by 6 Matrix object. get_frequencies(); Returns the most recently computed frequencies, as a 3N-6 Vector object. get_global_option(arg0); Given a string of a keyword name arg1, returns the value associated with the keyword from the global options. get_global_option_list(); Returns a list of all global options. get_gradient(); Returns the most recently computed gradient, as a N by 3 Matrix object. get_legacy_molecule(); Returns the currently active molecule object. get_local_option(arg0, arg1); Given a string of a keyword name arg2 and a",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:244969,Availability,avail,available,244969,"ariables set internally by the modules or python driver. get_atomic_point_charges(); Returns the most recently computed atomic point charges, as a double * object. get_datadir(); Sets the path to shared text resources, PSIDATADIR. get_efp_torque(); Returns the most recently computed gradient for the EFP portion, as a Nefp by 6 Matrix object. get_frequencies(); Returns the most recently computed frequencies, as a 3N-6 Vector object. get_global_option(arg0); Given a string of a keyword name arg1, returns the value associated with the keyword from the global options. get_global_option_list(); Returns a list of all global options. get_gradient(); Returns the most recently computed gradient, as a N by 3 Matrix object. get_legacy_molecule(); Returns the currently active molecule object. get_local_option(arg0, arg1); Given a string of a keyword name arg2 and a particular module arg1, returns the value associated with the keyword in the module options scope. get_memory(); Returns the amount of memory available to Psi (in bytes). get_num_threads(); Returns the number of threads to use in SMP parallel computations. get_option(arg0, arg1); Given a string of a keyword name arg2 and a particular module arg1, returns the local value associated with the keyword if it’s been set, else the global value if it’s been set, else the local core.default value. get_options(); Get options. get_output_file(). get_variable(arg0); Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available). get_variables(); Returns dictionary of the PSI variables set internally by the modules or python driver. get_writer_file_prefix(arg0); Returns the prefix to use for writing files for external programs. git_version(); Returns the git version of this copy of Psi. has_global_option_changed(arg0); Returns boolean for whether the keyword arg1 has been touched in the global scope, by either user or code. has_local_option_changed(arg0, arg1);",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:245510,Availability,avail,available,245510,"yword name arg1, returns the value associated with the keyword from the global options. get_global_option_list(); Returns a list of all global options. get_gradient(); Returns the most recently computed gradient, as a N by 3 Matrix object. get_legacy_molecule(); Returns the currently active molecule object. get_local_option(arg0, arg1); Given a string of a keyword name arg2 and a particular module arg1, returns the value associated with the keyword in the module options scope. get_memory(); Returns the amount of memory available to Psi (in bytes). get_num_threads(); Returns the number of threads to use in SMP parallel computations. get_option(arg0, arg1); Given a string of a keyword name arg2 and a particular module arg1, returns the local value associated with the keyword if it’s been set, else the global value if it’s been set, else the local core.default value. get_options(); Get options. get_output_file(). get_variable(arg0); Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available). get_variables(); Returns dictionary of the PSI variables set internally by the modules or python driver. get_writer_file_prefix(arg0); Returns the prefix to use for writing files for external programs. git_version(); Returns the git version of this copy of Psi. has_global_option_changed(arg0); Returns boolean for whether the keyword arg1 has been touched in the global scope, by either user or code. has_local_option_changed(arg0, arg1); Returns boolean for whether the keyword arg2 has been touched in the scope of the specified module arg1, by either user or code. has_option_changed(arg0, arg1); Returns boolean for whether the option arg2 has been touched either locally to the specified module arg1 or globally, by either user or code. has_variable(arg0); Returns true if the PSI variable exists/is set. initialize(). legacy_wavefunction(); Returns the current legacy_wavefunction object from the most recent comput",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:248768,Availability,avail,available,248768,"p_srcdir(); Returns the location of the source code. psimrcc(arg0); Runs the multireference coupled cluster code. reopen_outfile(); Reopens the output file. revoke_global_option_changed(arg0); Given a string of a keyword name arg1, sets the has_changed attribute in the global options scope to false. revoke_local_option_changed(arg0, arg1); Given a string of a keyword name arg2 and a particular module arg1, sets the has_changed attribute in the module options scope to false. run_gdma(arg0, arg1); Runs the GDMA code. sapt(arg0, arg1, arg2); Runs the symmetry adapted perturbation theory code. scatter(arg0, arg1, arg2, arg3, arg4); New Scatter function. scfgrad(arg0); Run scfgrad, which is a specialized DF-SCF gradient program. scfhess(arg0); Run scfhess, which is a specialized DF-SCF hessian program. set_active_molecule(arg0); Activates a previously defined (in the input) molecule, by name. set_array_variable(arg0, arg1); Sets a PSI variable, by name. set_datadir(arg0); Returns the amount of memory available to Psi (in bytes). set_efp_torque(arg0); Assigns the global EFP gradient to the values stored in the Nefp by 6 Matrix argument. set_frequencies(arg0); Assigns the global frequencies to the values stored in the 3N-6 Vector argument. set_global_option(*args, **kwargs); Overloaded function. set_global_option_python(key, EXTERN); This is a fairly hacky way to get around EXTERN issues. set_gradient(arg0); Assigns the global gradient to the values stored in the N by 3 Matrix argument. set_legacy_molecule(arg0); Activates a previously defined (in the input) molecule, by name. set_legacy_wavefunction(arg0); Returns the current legacy_wavefunction object from the most recent computation. set_local_option(*args, **kwargs); Overloaded function. set_local_option_python(arg0, arg1); Sets an option to a Python object, but scoped only to a single module. set_memory_bytes(memory, quiet); Sets the memory available to Psi (in bytes). set_num_threads(nthread, quiet); Sets the number o",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:249679,Availability,avail,available,249679,"variable(arg0, arg1); Sets a PSI variable, by name. set_datadir(arg0); Returns the amount of memory available to Psi (in bytes). set_efp_torque(arg0); Assigns the global EFP gradient to the values stored in the Nefp by 6 Matrix argument. set_frequencies(arg0); Assigns the global frequencies to the values stored in the 3N-6 Vector argument. set_global_option(*args, **kwargs); Overloaded function. set_global_option_python(key, EXTERN); This is a fairly hacky way to get around EXTERN issues. set_gradient(arg0); Assigns the global gradient to the values stored in the N by 3 Matrix argument. set_legacy_molecule(arg0); Activates a previously defined (in the input) molecule, by name. set_legacy_wavefunction(arg0); Returns the current legacy_wavefunction object from the most recent computation. set_local_option(*args, **kwargs); Overloaded function. set_local_option_python(arg0, arg1); Sets an option to a Python object, but scoped only to a single module. set_memory_bytes(memory, quiet); Sets the memory available to Psi (in bytes). set_num_threads(nthread, quiet); Sets the number of threads to use in SMP parallel computations. set_output_file(*args, **kwargs); Overloaded function. set_parent_symmetry(arg0); Sets the symmetry of the ‘parent’ (undisplaced) geometry, by Schoenflies symbol, at the beginning of a finite difference computation. set_psi_file_prefix(arg0). set_variable(arg0, arg1); Sets a PSI variable, by name. tstart(); docstring. tstop(); docstring. version(); Returns the version ID of this copy of Psi. Classes¶. AOShellCombinationsIterator. AngularMomentumInt; Computes angular momentum integrals. BSVec. BasisExtents; docstring. BasisFunctions; docstring. BasisSet; Contains basis set information. BlockOPoints; docstring. BoysLocalizer; Performs Boys orbital localization. CIVector; docstring. CIWavefunction; docstring. CUHF; docstring. CdSalcList; Class for generating symmetry adapted linear combinations of Cartesian displacements. CorrelationFactor; docstring. Co",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:259097,Availability,avail,available,259097,"es against PSIvariables. compare_cubes(expected, computed, label); Function to compare two cube files. compare_fcidumps(expected, computed, label); Function to compare two FCIDUMP files. compare_integers(expected, computed, label); Function to compare two integers. compare_matrices(expected, computed, digits, …); Function to compare two matrices. compare_strings(expected, computed, label); Function to compare two strings. compare_values(expected, computed, digits, label); Function to compare two values. compare_vectors(expected, computed, digits, …); Function to compare two vectors. copy_file_from_scratch(filename, prefix, …); Function to move file out of scratch with correct naming convention. copy_file_to_scratch(filename, prefix, …); Function to move file into scratch with correct naming convention. create_plugin(name, template); Generate plugin in directory with sanitized name based upon template. csx2endict(); Grabs the CSX file as a dictionary, encodes translation of PSI variables to XML blocks, gathers all available energies from CSX file into returned dictionary. cubeprop(wfn, **kwargs); Evaluate properties on a grid and generate cube files. dynamic_variable_bind(cls); Function to dynamically add extra members to the core.Molecule class. energy(name, **kwargs); Function to compute the single-point electronic energy. fchk(wfn, filename); Function to write wavefunction information in wfn to filename in Gaussian FCHK format. fcidump(wfn[, fname, oe_ints]); Save integrals to file in FCIDUMP format as defined in Comp. fcidump_from_file(fname); Function to read in a FCIDUMP file. filter_comments(string); Remove from string any Python-style comments (‘#’ to end of line). find_approximate_string_matches(seq1, …); Function to compute approximate string matches from a list of options. freq(name, **kwargs); Function to compute harmonic vibrational frequencies. frequencies(name, **kwargs); Function to compute harmonic vibrational frequencies. frequency(name, **kwargs); F",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:261529,Availability,error,error,261529,"plementary to :py:func:~driver.optimize(). hessian(name, **kwargs); Function complementary to frequency(). join_path(prefix, *args). levenshtein(seq1, seq2); Function to compute the Levenshtein distance between two strings. molden(wfn[, filename, density_a, …]); Function to write wavefunction information in wfn to filename in molden format. molecule_from_arrays; classmethod(function) -> method. molecule_from_schema; classmethod(function) -> method. molecule_from_string; classmethod(function) -> method. molecule_get_attr(self, name); Function to redefine __getattr__ method of molecule class. molecule_set_attr(self, name, value); Function to redefine __setattr__ method of molecule class. oeprop(wfn, *args, **kwargs); Evaluate one-electron properties. opt(name, **kwargs); Function to perform a geometry optimization. optimize(name, **kwargs); Function to perform a geometry optimization. pcm_helper(block); Passes multiline string block to PCMSolver parser. print_stderr(stuff); Function to print stuff to standard error stream. print_stdout(stuff); Function to print stuff to standard output stream. process_input(raw_input[, print_level]); Function to preprocess raw input, the text of the input file, then parse it, validate it for format, and convert it into legitimate Python. process_pubchem_command(matchobj); Function to process match of pubchem in molecule block. prop(*args, **kwargs); Function to compute various properties. properties(*args, **kwargs); Function to compute various properties. sanitize_name(name); Function to return name in coded form, stripped of characters that confuse filenames, characters into lowercase, + into p, * into s, and (, ), -, & , into _. scf_helper(name[, post_scf]); Function serving as helper to SCF, choosing whether to cast up or just run SCF with a standard guess. scf_wavefunction_factory(name, ref_wfn, …); Builds the correct wavefunction from the provided information. set_memory(inputval[, execute]); Function to reset the total memory al",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:46795,Deployability,update,update,46795,".SOMCSCF, arg0: psi4.core.Matrix) → psi4.core.Matrix¶. compute_Hk(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix) → psi4.core.Matrix¶. compute_Q(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix) → psi4.core.Matrix¶. compute_Qk(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix, arg2: psi4.core.Matrix) → psi4.core.Matrix¶. current_AFock(self: psi4.core.SOMCSCF) → psi4.core.Matrix¶. current_IFock(self: psi4.core.SOMCSCF) → psi4.core.Matrix¶. current_ci_energy(self: psi4.core.SOMCSCF) → float¶. current_docc_energy(self: psi4.core.SOMCSCF) → float¶. current_total_energy(self: psi4.core.SOMCSCF) → float¶. form_rotation_matrix(self: psi4.core.SOMCSCF, x: psi4.core.Matrix, order: int=2) → psi4.core.Matrix¶. gradient(self: psi4.core.SOMCSCF) → psi4.core.Matrix¶. gradient_rms(self: psi4.core.SOMCSCF) → float¶. rhf_energy(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix) → float¶. solve(self: psi4.core.SOMCSCF, arg0: int, arg1: float, arg2: bool) → psi4.core.Matrix¶. update(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix, arg2: psi4.core.Matrix, arg3: psi4.core.Matrix, arg4: psi4.core.Matrix) → None¶. zero_redundant(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix) → None¶. class psi4.core.DFTGrid¶; Bases: psi4.core.MolecularGrid; docstring. blocks(self: psi4.core.MolecularGrid) → List[psi4.core.BlockOPoints]¶; Returns a list of blocks. build(*args, **kwargs)¶; Overloaded function. build(arg0: psi4.core.Molecule, arg1: psi4.core.BasisSet) -> psi4.core.DFTGrid; build(arg0: psi4.core.Molecule, arg1: psi4.core.BasisSet, arg2: Dict[str, int], arg3: Dict[str, str]) -> psi4.core.DFTGrid. max_functions(self: psi4.core.MolecularGrid) → int¶; Returns the maximum number of functions in a block. max_points(self: psi4.core.MolecularGrid) → int¶; Returns the maximum number of points in a block. npoints(self: psi4.core.MolecularGrid) → int¶; Returns the number of grid points. orientation(self: psi4.core.MolecularGrid) → psi4.core.Matrix¶; Returns t",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:57209,Deployability,update,update,57209,".SOMCSCF, arg0: psi4.core.Matrix) → psi4.core.Matrix¶. compute_Hk(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix) → psi4.core.Matrix¶. compute_Q(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix) → psi4.core.Matrix¶. compute_Qk(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix, arg2: psi4.core.Matrix) → psi4.core.Matrix¶. current_AFock(self: psi4.core.SOMCSCF) → psi4.core.Matrix¶. current_IFock(self: psi4.core.SOMCSCF) → psi4.core.Matrix¶. current_ci_energy(self: psi4.core.SOMCSCF) → float¶. current_docc_energy(self: psi4.core.SOMCSCF) → float¶. current_total_energy(self: psi4.core.SOMCSCF) → float¶. form_rotation_matrix(self: psi4.core.SOMCSCF, x: psi4.core.Matrix, order: int=2) → psi4.core.Matrix¶. gradient(self: psi4.core.SOMCSCF) → psi4.core.Matrix¶. gradient_rms(self: psi4.core.SOMCSCF) → float¶. rhf_energy(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix) → float¶. solve(self: psi4.core.SOMCSCF, arg0: int, arg1: float, arg2: bool) → psi4.core.Matrix¶. update(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix, arg2: psi4.core.Matrix, arg3: psi4.core.Matrix, arg4: psi4.core.Matrix) → None¶. zero_redundant(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix) → None¶. class psi4.core.Dispersion¶; Bases: pybind11_builtins.pybind11_object; docstring. a1(self: psi4.core.Dispersion) → float¶; docstring. a2(self: psi4.core.Dispersion) → float¶; docstring. bibtex(self: psi4.core.Dispersion) → str¶; Get the BibTeX key for the literature reference. build(type: str, s6: float=0.0, p1: float=0.0, p2: float=0.0, p3: float=0.0) → psi4.core.Dispersion¶; docstring. citation(self: psi4.core.Dispersion) → str¶; docstring. compute_energy(self: psi4.core.Dispersion, arg0: psi4.core.Molecule) → float¶; docstring. compute_gradient(self: psi4.core.Dispersion, arg0: psi4.core.Molecule) → psi4.core.Matrix¶; docstring. compute_hessian(self: psi4.core.Dispersion, arg0: psi4.core.Molecule) → psi4.core.Matrix¶; docstring. d(self: psi4.core.Dispersion) → f",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:185559,Deployability,update,update,185559,".SOMCSCF, arg0: psi4.core.Matrix) → psi4.core.Matrix¶. compute_Hk(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix) → psi4.core.Matrix¶. compute_Q(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix) → psi4.core.Matrix¶. compute_Qk(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix, arg2: psi4.core.Matrix) → psi4.core.Matrix¶. current_AFock(self: psi4.core.SOMCSCF) → psi4.core.Matrix¶. current_IFock(self: psi4.core.SOMCSCF) → psi4.core.Matrix¶. current_ci_energy(self: psi4.core.SOMCSCF) → float¶. current_docc_energy(self: psi4.core.SOMCSCF) → float¶. current_total_energy(self: psi4.core.SOMCSCF) → float¶. form_rotation_matrix(self: psi4.core.SOMCSCF, x: psi4.core.Matrix, order: int=2) → psi4.core.Matrix¶. gradient(self: psi4.core.SOMCSCF) → psi4.core.Matrix¶. gradient_rms(self: psi4.core.SOMCSCF) → float¶. rhf_energy(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix) → float¶. solve(self: psi4.core.SOMCSCF, arg0: int, arg1: float, arg2: bool) → psi4.core.Matrix¶. update(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix, arg2: psi4.core.Matrix, arg3: psi4.core.Matrix, arg4: psi4.core.Matrix) → None¶. zero_redundant(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix) → None¶. class psi4.core.SaveType¶; Bases: pybind11_builtins.pybind11_object; The layout of the matrix for saving. Full = SaveType.Full¶. LowerTriangle = SaveType.LowerTriangle¶. SubBlocks = SaveType.SubBlocks¶. class psi4.core.ShellInfo¶; Bases: pybind11_builtins.pybind11_object. class psi4.core.Slice¶; Bases: pybind11_builtins.pybind11_object; Slicing for Matrix and Vector objects. begin(self: psi4.core.Slice) → psi4.core.Dimension¶; Get the first element of this slice. end(self: psi4.core.Slice) → psi4.core.Dimension¶; Get the past-the-end element of this slice. class psi4.core.SuperFunctional¶; Bases: pybind11_builtins.pybind11_object; docstring. XC_build(arg0: str, arg1: bool) → psi4.core.SuperFunctional¶; Builds a SuperFunctional from a XC string. add_c_functional(sel",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:226044,Deployability,configurat,configuration,226044,"e the similarity transformed Hamiltonian. psi4.core.cclambda(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the coupled cluster lambda equations code. psi4.core.ccresponse(arg0: psi::Wavefunction) → float¶; Runs the coupled cluster response theory code. psi4.core.cctransort(arg0: psi::Wavefunction) → None¶; Runs CCTRANSORT, which transforms and reorders integrals for use in the coupled cluster codes. psi4.core.cctriples(arg0: psi::Wavefunction) → float¶; Runs the coupled cluster (T) energy code. psi4.core.clean() → None¶; Function to remove scratch files. Call between independent jobs. psi4.core.clean_options() → None¶; Function to reset options to clean state. psi4.core.clean_variables() → None¶; Empties all PSI variables that have set internally. psi4.core.close_outfile() → None¶; Closes the output file. psi4.core.dcft(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the density cumulant functional theory code. psi4.core.detci(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the determinant-based configuration interaction code. psi4.core.dfmp2(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the DF-MP2 code. psi4.core.dfocc(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the density-fitted orbital optimized CC codes. psi4.core.displace_atom(arg0: psi::Matrix, arg1: int, arg2: int, arg3: int, arg4: float) → None¶; Displaces one coordinate of single atom. psi4.core.dmrg(arg0: psi::Wavefunction) → float¶; Runs the DMRG code. psi4.core.efp_init() → psi4.core.EFP¶; Initializes the EFP library and returns an EFP object. psi4.core.efp_set_options() → None¶; Set EFP options from environment options object. psi4.core.fcidump_tei_helper(nirrep: int, restricted: bool, DPD_info: Dict[str, int], ints_tolerance: float, fname: str='INTDUMP') → None¶; Write integrals to file in FCIDUMP format. psi4.core.fd_1_0(arg0: psi::Molecule, arg1: list) → psi::Matrix¶; Performs a finite difference gradient computation, from energy points. psi4.core.fd_freq_0(arg0: psi::Mole",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:242288,Deployability,configurat,configuration,242288,"arg1); docstring. benchmark_integrals(arg0, arg1); docstring. benchmark_math(arg0); docstring. ccdensity(arg0); Runs the code to compute coupled cluster density matrices. ccenergy(arg0); Runs the coupled cluster energy code. cceom(arg0); Runs the equation of motion coupled cluster code, for excited states. cchbar(arg0); Runs the code to generate the similarity transformed Hamiltonian. cclambda(arg0); Runs the coupled cluster lambda equations code. ccresponse(arg0); Runs the coupled cluster response theory code. cctransort(arg0); Runs CCTRANSORT, which transforms and reorders integrals for use in the coupled cluster codes. cctriples(arg0); Runs the coupled cluster (T) energy code. clean(); Function to remove scratch files. clean_options(); Function to reset options to clean state. clean_variables(); Empties all PSI variables that have set internally. close_outfile(); Closes the output file. dcft(arg0); Runs the density cumulant functional theory code. detci(arg0); Runs the determinant-based configuration interaction code. dfmp2(arg0); Runs the DF-MP2 code. dfocc(arg0); Runs the density-fitted orbital optimized CC codes. displace_atom(arg0, arg1, arg2, arg3, arg4); Displaces one coordinate of single atom. dmrg(arg0); Runs the DMRG code. efp_init(); Initializes the EFP library and returns an EFP object. efp_set_options(); Set EFP options from environment options object. fcidump_tei_helper(nirrep, restricted, …); Write integrals to file in FCIDUMP format. fd_1_0(arg0, arg1); Performs a finite difference gradient computation, from energy points. fd_freq_0(arg0, arg1, arg2); Performs a finite difference frequency computation, from energy points, for a given irrep. fd_freq_1(arg0, arg1, arg2); Performs a finite difference frequency computation, from gradients, for a given irrep. fd_geoms_1_0(arg0); Gets list of displacements needed for a finite difference gradient computation, from energy points. fd_geoms_freq_0(arg0, arg1); Gets list of displacements needed for a finite d",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:264409,Deployability,update,updated,264409,"et the total memory allocation. set_module_options(module, options_dict); Sets Psi4 module options from a module specification and input dictionary. set_options(options_dict); Sets Psi4 global options from an input dictionary. success(label); Function to print a ‘label…PASSED’ line to screen. vibanal_wfn(wfn[, hess, irrep, molecule, …]). write_eigenvalues(eigs, mo_idx); Prepare multi-line string with one-particle eigenvalues to be written to the FCIDUMP file. xml2dict([filename]); Read XML filename into nested OrderedDict-s. Classes¶. CSXError(msg); Error called when CSX generation fails. ConvergenceError(eqn_description, maxit); Error called for problems with converging and iterative method. Dftd3Error(msg). EmpericalDispersion(alias, dtype, **kwargs). ManagedMethodError(circs). OptimizationConvergenceError(…); Error called for problems with geometry optimizer. ParsingError(msg); Error called for problems parsing a text file. PastureRequiredError(option); Error called when the specified value of option requires some module(s) from Psi4Pasture, but could not be imported. PsiException; Error class for Psi. PsiImportError(msg); Error called for problems import python dependencies. QMMM(). Table([rows, row_label_width, …]); Class defining a flexible Table object for storing data. TestComparisonError(msg); Error called when a test case fails due to a failed compare_values() call. ValidationError(msg); Error called for problems with the input file. datetime(year, month, day[, hour[, minute[, …); The year, month and day arguments are required. Class Inheritance Diagram¶. table of contents. PSI4 API: Linking C++ and Python; psi4.core Module; Functions; Classes; Class Inheritance Diagram. psi4.driver Package; Functions; Classes; Class Inheritance Diagram. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:11318,Energy Efficiency,charge,charges,11318,"eta Density subset. Fa(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Alpha Fock Matrix. Fb(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Beta Fock Matrix. H(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the ‘Core’ Matrix (Potential + Kinetic) Integrals. Hd_vector(self: psi4.core.CIWavefunction, arg0: int) → psi::detci::CIvect¶; docstring. S(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the One-electron Overlap Matrix. X(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Lagrangian Matrix. alpha_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. aotoso(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Atomic Orbital to Symmetry Orbital transformer. arrays(self: psi4.core.Wavefunction) → Dict[str, psi4.core.Matrix]¶; Returns the map of all internal arrays. atomic_point_charges(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.Wavefunction, basis: psi4.core.BasisSet) → psi4.core.Wavefunction¶; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet *basis. ci_nat_orbs(self: psi4.core.CIWavefunction) → None¶; docstring. cleanup_ci(self: psi4.core.CIWavefunction) → None¶; docstring. cleanup_dpd(self: psi4.core.CIWavefunction) → None¶; docstring. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. comp",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:12271,Energy Efficiency,energy,energy,12271,") → psi4.core.Vector¶; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.Wavefunction, basis: psi4.core.BasisSet) → psi4.core.Wavefunction¶; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet *basis. ci_nat_orbs(self: psi4.core.CIWavefunction) → None¶; docstring. cleanup_ci(self: psi4.core.CIWavefunction) → None¶; docstring. cleanup_dpd(self: psi4.core.CIWavefunction) → None¶; docstring. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. compute_state_transfer(self: psi4.core.CIWavefunction, arg0: psi::detci::CIvect, arg1: int, arg2: psi4.core.Matrix, arg3: psi::detci::CIvect) → None¶; docstring. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. diag_h(self: psi4.core.CIWavefunction, arg0: float, arg1: float) → int¶; docstring. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns t",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:12994,Energy Efficiency,energy,energy,12994,"t *basis. ci_nat_orbs(self: psi4.core.CIWavefunction) → None¶; docstring. cleanup_ci(self: psi4.core.CIWavefunction) → None¶; docstring. cleanup_dpd(self: psi4.core.CIWavefunction) → None¶; docstring. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. compute_state_transfer(self: psi4.core.CIWavefunction, arg0: psi::detci::CIvect, arg1: int, arg2: psi4.core.Matrix, arg3: psi::detci::CIvect) → None¶; docstring. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. diag_h(self: psi4.core.CIWavefunction, arg0: float, arg1: float) → int¶; docstring. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Beta Eigenvalues subset. esp_at_nuclei(self: psi4.core.Wavefunction) → psi4.core.Vector¶; returns electrostatic potentials at nuclei. force_doccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only. Sets the number of doubly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. force_soccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:13067,Energy Efficiency,energy,energy,13067,"efunction) → None¶; docstring. cleanup_ci(self: psi4.core.CIWavefunction) → None¶; docstring. cleanup_dpd(self: psi4.core.CIWavefunction) → None¶; docstring. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. compute_state_transfer(self: psi4.core.CIWavefunction, arg0: psi::detci::CIvect, arg1: int, arg2: psi4.core.Matrix, arg3: psi::detci::CIvect) → None¶; docstring. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. diag_h(self: psi4.core.CIWavefunction, arg0: float, arg1: float) → int¶; docstring. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Beta Eigenvalues subset. esp_at_nuclei(self: psi4.core.Wavefunction) → psi4.core.Vector¶; returns electrostatic potentials at nuclei. force_doccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only. Sets the number of doubly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. force_soccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only. Sets the number of singly occupied oribta",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:23023,Energy Efficiency,charge,charges,23023,"atrix. H(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the ‘Core’ Matrix (Potential + Kinetic) Integrals. S(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the One-electron Overlap Matrix. V_potential(self: psi4.core.HF) → psi4.core.VBase¶; Returns the internal DFT V object. Va(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Alpha Kohn-Shame Potential Matrix. Vb(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Alpha Kohn-Shame Potential Matrix. X(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Lagrangian Matrix. alpha_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. aotoso(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Atomic Orbital to Symmetry Orbital transformer. arrays(self: psi4.core.Wavefunction) → Dict[str, psi4.core.Matrix]¶; Returns the map of all internal arrays. atomic_point_charges(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.CUHF, basis: psi4.core.BasisSet) → psi4.core.CUHF¶; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefu",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:23768,Energy Efficiency,energy,energy,23768,"e Atomic Orbital to Symmetry Orbital transformer. arrays(self: psi4.core.Wavefunction) → Dict[str, psi4.core.Matrix]¶; Returns the map of all internal arrays. atomic_point_charges(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.CUHF, basis: psi4.core.BasisSet) → psi4.core.CUHF¶; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix]) → List[psi4.core.Matrix]¶; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF) → bool¶; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int=2) → List[psi4.core.Matrix]¶; Solves the CPHF equations for a given set of x vectors. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wav",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:24653,Energy Efficiency,energy,energy,24653,"ing pre-c1-constructed BasisSet basis. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix]) → List[psi4.core.Matrix]¶; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF) → bool¶; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int=2) → List[psi4.core.Matrix]¶; Solves the CPHF equations for a given set of x vectors. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Beta Eigenvalues subset. esp_at_nuclei(self: psi4.core.Wavefunction) → psi4.core.Vector¶; returns electrostatic potentials at nuclei. finalize_E(self: psi4.core.HF) → float¶; Computes the final SCF energy. force_doccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only. Sets the number of doubly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. force_soccpi(self: psi4.core.Wavef",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:24726,Energy Efficiency,energy,energy,24726,"ute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix]) → List[psi4.core.Matrix]¶; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF) → bool¶; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int=2) → List[psi4.core.Matrix]¶; Solves the CPHF equations for a given set of x vectors. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Beta Eigenvalues subset. esp_at_nuclei(self: psi4.core.Wavefunction) → psi4.core.Vector¶; returns electrostatic potentials at nuclei. finalize_E(self: psi4.core.HF) → float¶; Computes the final SCF energy. force_doccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only. Sets the number of doubly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. force_soccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:25365,Energy Efficiency,energy,energy,25365,"i4.core.Matrix]¶; Solves the CPHF equations for a given set of x vectors. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Beta Eigenvalues subset. esp_at_nuclei(self: psi4.core.Wavefunction) → psi4.core.Vector¶; returns electrostatic potentials at nuclei. finalize_E(self: psi4.core.HF) → float¶; Computes the final SCF energy. force_doccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only. Sets the number of doubly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. force_soccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only. Sets the number of singly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. form_C(self: psi4.core.HF) → None¶; Forms the Orbital Matrices from the current Fock Matrices. form_D(self: psi4.core.HF) → None¶; Forms the Density Matrices from the current Orbitals Matrices. form_F(self: psi4.core.HF) → None¶; Forms the F matrix. form_G(self: psi4.core.HF) → None¶; Forms the G matrix. form_V(self: psi4.core.HF) → None¶; Form the Kohn-Sham Potential Matrices from the current Density Matrices. frequencies(self: psi4.core.Wavefunction) → psi4.cor",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:32387,Energy Efficiency,adapt,adapted,32387,"f Atomic Densities basisset. set_sad_fitting_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities density-fitted basisset. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. twoel_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix], arg1: bool, arg2: str) → List[psi4.core.Matrix]¶; Two-electron Hessian-vector products. variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the map of all internal variables. class psi4.core.CdSalcList¶; Bases: pybind11_builtins.pybind11_object; Class for generating symmetry adapted linear combinations of Cartesian displacements. create_matrices(self: psi4.core.CdSalcList, basename: str, factory: psi4.core.MatrixFactory) → List[psi4.core.Matrix]¶; Return a vector of matrices with the SALC symmetries. Dimensions determined by factory. matrix(self: psi4.core.CdSalcList) → psi4.core.Matrix¶; Return the SALCs. matrix_irrep(self: psi4.core.CdSalcList, h: int) → psi4.core.Matrix¶; Return only the SALCS in irrep h. ncd(self: psi4.core.CdSalcList) → int¶; Return the number of cartesian displacements SALCs. print_out(self: psi4.core.CdSalcList) → None¶; Print the SALC to the output file. salc_name(self: psi4.core.CdSalcList, i: int) → str¶; Return the name of SALC #i. class psi4.core.CorrelationFactor¶; Bases: pybind11_builtins.pybind11_object; docstring. set_params(self: psi4.core.CorrelationFactor, coeff: psi4.core.Vector, exponent: psi4.core.Vector) → None¶; Set coefficient and exponent. class psi4.core.CorrelationTable¶; Bases: pybind11_builtins.pybind11_object; Pr",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:34045,Energy Efficiency,reduce,reduced,34045," to the output file. salc_name(self: psi4.core.CdSalcList, i: int) → str¶; Return the name of SALC #i. class psi4.core.CorrelationFactor¶; Bases: pybind11_builtins.pybind11_object; docstring. set_params(self: psi4.core.CorrelationFactor, coeff: psi4.core.Vector, exponent: psi4.core.Vector) → None¶; Set coefficient and exponent. class psi4.core.CorrelationTable¶; Bases: pybind11_builtins.pybind11_object; Provides a correlation table between two point groups. degen(self: psi4.core.CorrelationTable, arg0: int) → int¶; Returns the degenercy of the irrep. group(*args, **kwargs)¶; Overloaded function. group(self: psi4.core.CorrelationTable) -> psi4.core.PointGroup. Returns higher order point group. group(self: psi4.core.CorrelationTable, arg0: int, arg1: int) -> int. Returns the higher order point group. n(self: psi4.core.CorrelationTable) → int¶; Returns the number of irreps in high order group. ngamma(self: psi4.core.CorrelationTable, arg0: int) → int¶; Returns the number of irreps in the low order group that an irrep from the high order group can be reduced to. subdegen(self: psi4.core.CorrelationTable, arg0: int) → int¶; Returns the degeneracy of the subgroup irrep. subgroup(self: psi4.core.CorrelationTable) → psi4.core.PointGroup¶; Returns lower order pointgroup. subn(self: psi4.core.CorrelationTable) → int¶; Returns number of irreps in subgroup. class psi4.core.CubeProperties¶; Bases: pybind11_builtins.pybind11_object; docstring. compute_properties(self: psi4.core.CubeProperties) → None¶; docstring. psi4.core.DASUM(arg0: int, arg1: int, arg2: psi::Vector, arg3: int) → float¶; docstring. psi4.core.DAXPY(arg0: int, arg1: int, arg2: float, arg3: psi::Vector, arg4: int, arg5: psi::Vector, arg6: int) → None¶; docstring. psi4.core.DCOPY(arg0: int, arg1: int, arg2: psi::Vector, arg3: int, arg4: psi::Vector, arg5: int) → None¶; docstring. psi4.core.DDOT(arg0: int, arg1: int, arg2: psi::Vector, arg3: int, arg4: psi::Vector, arg5: int) → float¶; docstring. class psi4.core.DFEP",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:36824,Energy Efficiency,charge,charges,36824,"t(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Returns the requested Beta Density subset. Fa(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Alpha Fock Matrix. Fb(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Beta Fock Matrix. H(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the ‘Core’ Matrix (Potential + Kinetic) Integrals. S(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the One-electron Overlap Matrix. X(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Lagrangian Matrix. alpha_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. aotoso(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Atomic Orbital to Symmetry Orbital transformer. arrays(self: psi4.core.Wavefunction) → Dict[str, psi4.core.Matrix]¶; Returns the map of all internal arrays. atomic_point_charges(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.Wavefunction, basis: psi4.core.BasisSet) → psi4.core.Wavefunction¶; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet *basis. compute(self: psi4.core.DFEP2Wavefunction, arg0: List[List[int]]) → List[List[Tuple[float, float]]]¶; Computes the density-fitted EP2 energy for the input orbitals. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.co",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:37652,Energy Efficiency,energy,energy,37652,". arrays(self: psi4.core.Wavefunction) → Dict[str, psi4.core.Matrix]¶; Returns the map of all internal arrays. atomic_point_charges(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.Wavefunction, basis: psi4.core.BasisSet) → psi4.core.Wavefunction¶; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet *basis. compute(self: psi4.core.DFEP2Wavefunction, arg0: List[List[int]]) → List[List[Tuple[float, float]]]¶; Computes the density-fitted EP2 energy for the input orbitals. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the ",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:37751,Energy Efficiency,energy,energy,37751,"lf: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.Wavefunction, basis: psi4.core.BasisSet) → psi4.core.Wavefunction¶; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet *basis. compute(self: psi4.core.DFEP2Wavefunction, arg0: List[List[int]]) → List[List[Tuple[float, float]]]¶; Computes the density-fitted EP2 energy for the input orbitals. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Beta",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:38228,Energy Efficiency,energy,energy,38228,"→ psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.Wavefunction, basis: psi4.core.BasisSet) → psi4.core.Wavefunction¶; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet *basis. compute(self: psi4.core.DFEP2Wavefunction, arg0: List[List[int]]) → List[List[Tuple[float, float]]]¶; Computes the density-fitted EP2 energy for the input orbitals. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Beta Eigenvalues subset. esp_at_nuclei(self: psi4.core.Wavefunction) → psi4.core.Vector¶; returns electrostatic potentials at nuclei. force_doccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only. Sets the number of doubly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. force_soccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:38301,Energy Efficiency,energy,energy,38301,"c build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.Wavefunction, basis: psi4.core.BasisSet) → psi4.core.Wavefunction¶; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet *basis. compute(self: psi4.core.DFEP2Wavefunction, arg0: List[List[int]]) → List[List[Tuple[float, float]]]¶; Computes the density-fitted EP2 energy for the input orbitals. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Beta Eigenvalues subset. esp_at_nuclei(self: psi4.core.Wavefunction) → psi4.core.Vector¶; returns electrostatic potentials at nuclei. force_doccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only. Sets the number of doubly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. force_soccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only. Sets the number of singly occupied oribta",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:61566,Energy Efficiency,charge,charge,61566,"one¶; Compute integrals between basis functions in the given shell pair. origin¶; The origin about which the one body ints are being computed. class psi4.core.ErfComplementERI¶; Bases: psi4.core.TwoBodyAOInt; Computes ERF complement electron repulsion integrals. compute_shell(self: psi4.core.TwoBodyAOInt, arg0: int, arg1: int, arg2: int, arg3: int) → int¶; Compute ERIs between 4 shells. class psi4.core.ErfERI¶; Bases: psi4.core.TwoBodyAOInt; Computes ERF electron repulsion integrals. compute_shell(self: psi4.core.TwoBodyAOInt, arg0: int, arg1: int, arg2: int, arg3: int) → int¶; Compute ERIs between 4 shells. class psi4.core.ExternalPotential¶; Bases: pybind11_builtins.pybind11_object; Stores external potential field, computes external potential matrix. addBasis(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet, coefs: psi4.core.Vector) → None¶; Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self: psi4.core.ExternalPotential, Z: float, x: float, y: float, z: float) → None¶; Add a charge Z at (x,y,z). clear(self: psi4.core.ExternalPotential) → None¶; Reset the field to zero (eliminates all entries). computePotentialMatrix(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet) → psi4.core.Matrix¶; Compute the external potential matrix in the given basis set. print_out(self: psi4.core.ExternalPotential) → None¶; Print python print helper to the outfile. setName(self: psi4.core.ExternalPotential, arg0: str) → None¶; Sets the name. class psi4.core.F12¶; Bases: psi4.core.TwoBodyAOInt; Computes F12 electron repulsion integrals. compute_shell(self: psi4.core.TwoBodyAOInt, arg0: int, arg1: int, arg2: int, arg3: int) → int¶; Compute ERIs between 4 shells. class psi4.core.F12DoubleCommutator¶; Bases: psi4.core.TwoBodyAOInt; Computes F12 Double Commutator electron repulsion integrals. compute_shell(self: psi4.core.TwoBodyAOInt, arg0: int, arg1: int, arg2: int, arg3: int) → int¶; Compute ERIs between 4 shells. class psi4.core.F12G12¶; Bases",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:64070,Energy Efficiency,energy,energy,64070," information from a wavefunction object, and writes it to an FCHK file. write(self: psi4.core.FCHKWriter, filename: str) → None¶; Write wavefunction information to file. class psi4.core.FDDS_Dispersion¶; Bases: pybind11_builtins.pybind11_object; docstring. aux_overlap(self: psi4.core.FDDS_Dispersion) → psi4.core.Matrix¶; Obtains the FDDS aux_overlap. form_unc_amplitude(self: psi4.core.FDDS_Dispersion, arg0: str, arg1: float) → psi4.core.Matrix¶; Forms the uncoupled amplitudes for either monomer. metric(self: psi4.core.FDDS_Dispersion) → psi4.core.Matrix¶; Obtains the FDDS metric. metric_inv(self: psi4.core.FDDS_Dispersion) → psi4.core.Matrix¶; Obtains the FDDS metric_inv. project_densities(self: psi4.core.FDDS_Dispersion, arg0: List[psi4.core.Matrix]) → List[psi4.core.Matrix]¶; Projects a density from the primary AO to auxiliary AO space. class psi4.core.FISAPT¶; Bases: pybind11_builtins.pybind11_object; A Fragment-SAPT Wavefunction. compute_energy(self: psi4.core.FISAPT) → None¶; Computes the FSAPT energy. disp(self: psi4.core.FISAPT, arg0: Dict[str, psi4.core.Matrix], arg1: Dict[str, psi4.core.Vector], arg2: bool) → None¶; Computes the MP2-based DispE20 and Exch-DispE20 energy. scalars(self: psi4.core.FISAPT) → Dict[str, float]¶; Return the interally computed scalars. class psi4.core.FittedSlaterCorrelationFactor¶; Bases: psi4.core.CorrelationFactor; docstring. exponent(self: psi4.core.FittedSlaterCorrelationFactor) → float¶. set_params(self: psi4.core.CorrelationFactor, coeff: psi4.core.Vector, exponent: psi4.core.Vector) → None¶; Set coefficient and exponent. class psi4.core.FittingMetric¶; Bases: pybind11_builtins.pybind11_object; docstring. form_QR_inverse(self: psi4.core.FittingMetric, arg0: float) → None¶; docstring. form_cholesky_inverse(self: psi4.core.FittingMetric) → None¶; docstring. form_eig_inverse(self: psi4.core.FittingMetric, arg0: float) → None¶; docstring. form_fitting_metric(self: psi4.core.FittingMetric) → None¶; docstring. form_full_inverse(sel",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:64246,Energy Efficiency,energy,energy,64246,"ation to file. class psi4.core.FDDS_Dispersion¶; Bases: pybind11_builtins.pybind11_object; docstring. aux_overlap(self: psi4.core.FDDS_Dispersion) → psi4.core.Matrix¶; Obtains the FDDS aux_overlap. form_unc_amplitude(self: psi4.core.FDDS_Dispersion, arg0: str, arg1: float) → psi4.core.Matrix¶; Forms the uncoupled amplitudes for either monomer. metric(self: psi4.core.FDDS_Dispersion) → psi4.core.Matrix¶; Obtains the FDDS metric. metric_inv(self: psi4.core.FDDS_Dispersion) → psi4.core.Matrix¶; Obtains the FDDS metric_inv. project_densities(self: psi4.core.FDDS_Dispersion, arg0: List[psi4.core.Matrix]) → List[psi4.core.Matrix]¶; Projects a density from the primary AO to auxiliary AO space. class psi4.core.FISAPT¶; Bases: pybind11_builtins.pybind11_object; A Fragment-SAPT Wavefunction. compute_energy(self: psi4.core.FISAPT) → None¶; Computes the FSAPT energy. disp(self: psi4.core.FISAPT, arg0: Dict[str, psi4.core.Matrix], arg1: Dict[str, psi4.core.Vector], arg2: bool) → None¶; Computes the MP2-based DispE20 and Exch-DispE20 energy. scalars(self: psi4.core.FISAPT) → Dict[str, float]¶; Return the interally computed scalars. class psi4.core.FittedSlaterCorrelationFactor¶; Bases: psi4.core.CorrelationFactor; docstring. exponent(self: psi4.core.FittedSlaterCorrelationFactor) → float¶. set_params(self: psi4.core.CorrelationFactor, coeff: psi4.core.Vector, exponent: psi4.core.Vector) → None¶; Set coefficient and exponent. class psi4.core.FittingMetric¶; Bases: pybind11_builtins.pybind11_object; docstring. form_QR_inverse(self: psi4.core.FittingMetric, arg0: float) → None¶; docstring. form_cholesky_inverse(self: psi4.core.FittingMetric) → None¶; docstring. form_eig_inverse(self: psi4.core.FittingMetric, arg0: float) → None¶; docstring. form_fitting_metric(self: psi4.core.FittingMetric) → None¶; docstring. form_full_inverse(self: psi4.core.FittingMetric) → None¶; docstring. get_algorithm(self: psi4.core.FittingMetric) → str¶; docstring. get_metric(self: psi4.core.FittingMetric) →",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:71140,Energy Efficiency,charge,charges,71140,"atrix. H(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the ‘Core’ Matrix (Potential + Kinetic) Integrals. S(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the One-electron Overlap Matrix. V_potential(self: psi4.core.HF) → psi4.core.VBase¶; Returns the internal DFT V object. Va(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Alpha Kohn-Shame Potential Matrix. Vb(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Alpha Kohn-Shame Potential Matrix. X(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Lagrangian Matrix. alpha_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. aotoso(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Atomic Orbital to Symmetry Orbital transformer. arrays(self: psi4.core.Wavefunction) → Dict[str, psi4.core.Matrix]¶; Returns the map of all internal arrays. atomic_point_charges(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.Wavefunction, basis: psi4.core.BasisSet) → psi4.core.Wavefunction¶; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet *basis. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hess",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:71902,Energy Efficiency,energy,energy,71902,"to Symmetry Orbital transformer. arrays(self: psi4.core.Wavefunction) → Dict[str, psi4.core.Matrix]¶; Returns the map of all internal arrays. atomic_point_charges(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.Wavefunction, basis: psi4.core.BasisSet) → psi4.core.Wavefunction¶; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet *basis. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix]) → List[psi4.core.Matrix]¶; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF) → bool¶; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int=2) → List[psi4.core.Matrix]¶; Solves the CPHF equations for a given set of x vectors. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wav",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:72787,Energy Efficiency,energy,energy,72787,"ng pre-c1-constructed BasisSet *basis. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix]) → List[psi4.core.Matrix]¶; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF) → bool¶; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int=2) → List[psi4.core.Matrix]¶; Solves the CPHF equations for a given set of x vectors. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Beta Eigenvalues subset. esp_at_nuclei(self: psi4.core.Wavefunction) → psi4.core.Vector¶; returns electrostatic potentials at nuclei. finalize_E(self: psi4.core.HF) → float¶; Computes the final SCF energy. force_doccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only. Sets the number of doubly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. force_soccpi(self: psi4.core.Wavef",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:72860,Energy Efficiency,energy,energy,72860,"ute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix]) → List[psi4.core.Matrix]¶; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF) → bool¶; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int=2) → List[psi4.core.Matrix]¶; Solves the CPHF equations for a given set of x vectors. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Beta Eigenvalues subset. esp_at_nuclei(self: psi4.core.Wavefunction) → psi4.core.Vector¶; returns electrostatic potentials at nuclei. finalize_E(self: psi4.core.HF) → float¶; Computes the final SCF energy. force_doccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only. Sets the number of doubly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. force_soccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:73499,Energy Efficiency,energy,energy,73499,"i4.core.Matrix]¶; Solves the CPHF equations for a given set of x vectors. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Beta Eigenvalues subset. esp_at_nuclei(self: psi4.core.Wavefunction) → psi4.core.Vector¶; returns electrostatic potentials at nuclei. finalize_E(self: psi4.core.HF) → float¶; Computes the final SCF energy. force_doccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only. Sets the number of doubly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. force_soccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only. Sets the number of singly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. form_C(self: psi4.core.HF) → None¶; Forms the Orbital Matrices from the current Fock Matrices. form_D(self: psi4.core.HF) → None¶; Forms the Density Matrices from the current Orbitals Matrices. form_F(self: psi4.core.HF) → None¶; Forms the F matrix. form_G(self: psi4.core.HF) → None¶; Forms the G matrix. form_V(self: psi4.core.HF) → None¶; Form the Kohn-Sham Potential Matrices from the current Density Matrices. frequencies(self: psi4.core.Wavefunction) → psi4.cor",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:106435,Energy Efficiency,power,power,106435,".core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType=SaveType.LowerTriangle) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str) → None¶; Loads a matrix from an ASCII file in MPQC format. name¶; The name of the Matrix. Used in printing. nirrep(self: psi4.core.Matrix) → int¶; Returns the number of irreps. np¶; View without only one irrep. classmethod np_read(filename, prefix='')¶; Reads the data from a NumPy compress file. np_write(filename=None, prefix='')¶; Writes the irreped matrix to a NumPy zipped file.; Can return the packed data for saving many matrices into the same file. nph¶; View with irreps. partial_cholesky_factorize(self: psi4.core.Matrix, delta: float=0.0, throw_if_negative: bool=False) → psi4.core.Matrix¶; Computes the fully pivoted partial Cholesky factorization of a real symmetric positive semidefinite matrix, to numerical precision delta. power(self: psi4.core.Matrix, alpha: float, cutoff: float=1e-12) → psi4.core.Dimension¶; Takes the matrix to the alpha power with precision cutoff. print_atom_vector(self: psi4.core.Matrix, RMRoutfile: str='outfile') → None¶; Print the matrix with atom labels, assuming it is an natom X 3 tensor. print_out(self: psi4.core.Matrix) → None¶; Prints the matrix to the output file. pseudoinverse(self: psi4.core.Matrix, condition: float, nremoved: int) → psi4.core.Matrix¶; Computes the matrix which is the conditioned pseudoinverse of this matrix. remove_symmetry(self: psi4.core.Matrix, a: psi4.core.Matrix, transformer: psi4.core.Matrix) → None¶; Remove symmetry from a matrix A with PetiteList::sotoao(). rms(self: psi4.core.Matrix) → float¶; Returns the rms of this matrix. rotate_columns(self: psi4.core.Matrix, h: int, i: int, j: int, theta: float) → None¶; Rotates columns i and j in irrep h by angle theta. rowdim(self: psi4.core.Matrix) → psi4.core.Dimension¶; Returns the rows per irrep array. rows(se",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:106554,Energy Efficiency,power,power,106554,"one. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str) → None¶; Loads a matrix from an ASCII file in MPQC format. name¶; The name of the Matrix. Used in printing. nirrep(self: psi4.core.Matrix) → int¶; Returns the number of irreps. np¶; View without only one irrep. classmethod np_read(filename, prefix='')¶; Reads the data from a NumPy compress file. np_write(filename=None, prefix='')¶; Writes the irreped matrix to a NumPy zipped file.; Can return the packed data for saving many matrices into the same file. nph¶; View with irreps. partial_cholesky_factorize(self: psi4.core.Matrix, delta: float=0.0, throw_if_negative: bool=False) → psi4.core.Matrix¶; Computes the fully pivoted partial Cholesky factorization of a real symmetric positive semidefinite matrix, to numerical precision delta. power(self: psi4.core.Matrix, alpha: float, cutoff: float=1e-12) → psi4.core.Dimension¶; Takes the matrix to the alpha power with precision cutoff. print_atom_vector(self: psi4.core.Matrix, RMRoutfile: str='outfile') → None¶; Print the matrix with atom labels, assuming it is an natom X 3 tensor. print_out(self: psi4.core.Matrix) → None¶; Prints the matrix to the output file. pseudoinverse(self: psi4.core.Matrix, condition: float, nremoved: int) → psi4.core.Matrix¶; Computes the matrix which is the conditioned pseudoinverse of this matrix. remove_symmetry(self: psi4.core.Matrix, a: psi4.core.Matrix, transformer: psi4.core.Matrix) → None¶; Remove symmetry from a matrix A with PetiteList::sotoao(). rms(self: psi4.core.Matrix) → float¶; Returns the rms of this matrix. rotate_columns(self: psi4.core.Matrix, h: int, i: int, j: int, theta: float) → None¶; Rotates columns i and j in irrep h by angle theta. rowdim(self: psi4.core.Matrix) → psi4.core.Dimension¶; Returns the rows per irrep array. rows(self: psi4.core.Matrix, h: int=0) → int¶; Returns the rows in irrep h. save(self: psi4.core.Matrix, filena",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:123862,Energy Efficiency,charge,charge,123862,"ilename: str, Ca: psi4.core.Matrix, Cb: psi4.core.Matrix, Ea: psi4.core.Vector, Eb: psi4.core.Vector, OccA: psi4.core.Vector, OccB: psi4.core.Vector, dovirtual: bool) → None¶; Writes wavefunction information in molden format. class psi4.core.MolecularGrid¶; Bases: pybind11_builtins.pybind11_object; docstring. blocks(self: psi4.core.MolecularGrid) → List[psi4.core.BlockOPoints]¶; Returns a list of blocks. max_functions(self: psi4.core.MolecularGrid) → int¶; Returns the maximum number of functions in a block. max_points(self: psi4.core.MolecularGrid) → int¶; Returns the maximum number of points in a block. npoints(self: psi4.core.MolecularGrid) → int¶; Returns the number of grid points. orientation(self: psi4.core.MolecularGrid) → psi4.core.Matrix¶; Returns the orientation of the grid. print(self: psi4.core.MolecularGrid, arg0: str, arg1: int) → None¶; Prints grid information. class psi4.core.Molecule¶; Bases: pybind11_builtins.pybind11_object; Class to store the elements, coordinates, fragmentation pattern, basis sets, charge, multiplicity, etc. of a molecule. B787(ref_mol, do_plot=False, verbose=1, atoms_map=False, run_resorting=False, mols_align=False, run_to_completion=False, uno_cutoff=0.001, run_mirror=False)¶; Finds shift, rotation, and atom reordering of concern_mol that best; aligns with ref_mol.; Wraps qcdb.align.B787() for qcdb.Molecule or; psi4.core.Molecule. Employs the Kabsch, Hungarian, and; Uno algorithms to exhaustively locate the best alignment for; non-oriented, non-ordered structures. Parameters:; concern_mol (qcdb.Molecule or psi4.core.Molecule) – Molecule of concern, to be shifted, rotated, and reordered into; best coincidence with ref_mol.; ref_mol (qcdb.Molecule or psi4.core.Molecule) – Molecule to match.; atoms_map (bool, optional) – Whether atom1 of ref_mol corresponds to atom1 of concern_mol, etc.; If true, specifying True can save much time.; mols_align (bool, optional) – Whether ref_mol and concern_mol have identical geometries by eye; (ba",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:125866,Energy Efficiency,charge,charge,125866,"procedure is truncated when RMSD condition met, saving time.; do_plot (bool, optional) – Pops up a mpl plot showing before, after, and ref geometries.; run_to_completion (bool, optional) – Run reorderings to completion (past RMSD = 0) even if unnecessary because; mols_align=True. Used to test worst-case timings.; run_resorting (bool, optional) – Run the resorting machinery even if unnecessary because atoms_map=True.; uno_cutoff (float, optional) – TODO; run_mirror (bool, optional) – Run alternate geometries potentially allowing best match to ref_mol; from mirror image of concern_mol. Only run if system confirmed to; be nonsuperimposable upon mirror reflection. Returns:First item is RMSD [A] between ref_mol and the optimally aligned; geometry computed.; Second item is a AlignmentMill namedtuple with fields; (shift, rotation, atommap, mirror) that prescribe the transformation; from concern_mol and the optimally aligned geometry.; Third item is a crude charge-, multiplicity-, fragment-less Molecule; at optimally aligned (and atom-ordered) geometry. Return type; determined by concern_mol type. Return type:float, tuple, qcdb.Molecule or psi4.core.Molecule. BFS(seed_atoms=None, bond_threshold=1.2, return_arrays=False, return_molecules=False, return_molecule=False)¶; Detect fragments among real atoms through a breadth-first search (BFS) algorithm. Parameters:; self (qcdb.Molecule or psi4.core.Molecule) – ; seed_atoms (list, optional) – List of lists of atoms (0-indexed) belonging to independent fragments.; Useful to prompt algorithm or to define intramolecular fragments through; border atoms. Example: [[1, 0], [2]]; bond_threshold (float, optional) – Factor beyond average of covalent radii to determine bond cutoff.; return_arrays (bool, optional) – If True, also return fragments as list of arrays.; return_molecules (bool, optional) – If True, also return fragments as list of Molecules.; return_molecule (bool, optional) – If True, also return one big Molecule with fragmentat",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:127749,Energy Efficiency,charge,charge,127749,"les (bool, optional) – If True, also return fragments as list of Molecules.; return_molecule (bool, optional) – If True, also return one big Molecule with fragmentation encoded. Returns:; bfs_map (list of lists) – Array of atom indices (0-indexed) of detected fragments.; bfs_arrays (tuple of lists of ndarray, optional) – geom, mass, elem info per-fragment.; Only provided if return_arrays is True.; bfs_molecules (list of qcdb.Molecule or psi4.core.Molecule, optional) – List of molecules, each built from one fragment. Center and; orientation of fragments is fixed so orientation info from self is; not lost. Loses chgmult and ghost/dummy info from self and contains; default chgmult.; Only provided if return_molecules is True.; Returned are of same type as self.; bfs_molecule (qcdb.Molecule or psi4.core.Molecule, optional) – Single molecule with same number of real atoms as self with atoms; reordered into adjacent fragments and fragment markers inserted.; Loses ghost/dummy info from self; keeps total charge but not total mult.; Only provided if return_molecule is True.; Returned is of same type as self. Notes. Relies upon van der Waals radii and so faulty for close (especially; hydrogen-bonded) fragments. See seed_atoms. Any existing fragmentation info/chgmult encoded in self is lost.; Original code from Michael S. Marshall, linear-scaling algorithm from; Trent M. Parker, revamped by Lori A. Burns. Z(self: psi4.core.Molecule, arg0: int) → float¶; Nuclear charge of atom. activate_all_fragments(self: psi4.core.Molecule) → None¶; Sets all fragments in the molecule to be active. add_atom(self: psi4.core.Molecule, arg0: float, arg1: float, arg2: float, arg3: float, arg4: str, arg5: float, arg6: float, arg7: str, arg8: int) → None¶; Adds to Molecule arg1 an atom with atomic number arg2, Cartesian coordinates in Bohr (arg3, arg4, arg5), atomic symbol arg6, mass arg7, charge arg8 (optional), and lineno arg9 (optional). atom_at_position(self: psi4.core.Molecule, arg0: float, arg1",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:128212,Energy Efficiency,charge,charge,128212,"ptional) – List of molecules, each built from one fragment. Center and; orientation of fragments is fixed so orientation info from self is; not lost. Loses chgmult and ghost/dummy info from self and contains; default chgmult.; Only provided if return_molecules is True.; Returned are of same type as self.; bfs_molecule (qcdb.Molecule or psi4.core.Molecule, optional) – Single molecule with same number of real atoms as self with atoms; reordered into adjacent fragments and fragment markers inserted.; Loses ghost/dummy info from self; keeps total charge but not total mult.; Only provided if return_molecule is True.; Returned is of same type as self. Notes. Relies upon van der Waals radii and so faulty for close (especially; hydrogen-bonded) fragments. See seed_atoms. Any existing fragmentation info/chgmult encoded in self is lost.; Original code from Michael S. Marshall, linear-scaling algorithm from; Trent M. Parker, revamped by Lori A. Burns. Z(self: psi4.core.Molecule, arg0: int) → float¶; Nuclear charge of atom. activate_all_fragments(self: psi4.core.Molecule) → None¶; Sets all fragments in the molecule to be active. add_atom(self: psi4.core.Molecule, arg0: float, arg1: float, arg2: float, arg3: float, arg4: str, arg5: float, arg6: float, arg7: str, arg8: int) → None¶; Adds to Molecule arg1 an atom with atomic number arg2, Cartesian coordinates in Bohr (arg3, arg4, arg5), atomic symbol arg6, mass arg7, charge arg8 (optional), and lineno arg9 (optional). atom_at_position(self: psi4.core.Molecule, arg0: float, arg1: float) → int¶; Tests to see if an atom is at the position arg2 with a given tolerance arg3. basis_on_atom(self: psi4.core.Molecule, arg0: int) → str¶; Gets the label of the orbital basis set on a given atom. center_of_mass(self: psi4.core.Molecule) → psi4.core.Vector3¶; Computes center of mass of molecule (does not translate molecule). charge(self: psi4.core.Molecule, arg0: int) → float¶; Gets charge of atom. clone(self: psi4.core.Molecule) → psi4.core.Mol",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:128626,Energy Efficiency,charge,charge,128626,"e (qcdb.Molecule or psi4.core.Molecule, optional) – Single molecule with same number of real atoms as self with atoms; reordered into adjacent fragments and fragment markers inserted.; Loses ghost/dummy info from self; keeps total charge but not total mult.; Only provided if return_molecule is True.; Returned is of same type as self. Notes. Relies upon van der Waals radii and so faulty for close (especially; hydrogen-bonded) fragments. See seed_atoms. Any existing fragmentation info/chgmult encoded in self is lost.; Original code from Michael S. Marshall, linear-scaling algorithm from; Trent M. Parker, revamped by Lori A. Burns. Z(self: psi4.core.Molecule, arg0: int) → float¶; Nuclear charge of atom. activate_all_fragments(self: psi4.core.Molecule) → None¶; Sets all fragments in the molecule to be active. add_atom(self: psi4.core.Molecule, arg0: float, arg1: float, arg2: float, arg3: float, arg4: str, arg5: float, arg6: float, arg7: str, arg8: int) → None¶; Adds to Molecule arg1 an atom with atomic number arg2, Cartesian coordinates in Bohr (arg3, arg4, arg5), atomic symbol arg6, mass arg7, charge arg8 (optional), and lineno arg9 (optional). atom_at_position(self: psi4.core.Molecule, arg0: float, arg1: float) → int¶; Tests to see if an atom is at the position arg2 with a given tolerance arg3. basis_on_atom(self: psi4.core.Molecule, arg0: int) → str¶; Gets the label of the orbital basis set on a given atom. center_of_mass(self: psi4.core.Molecule) → psi4.core.Vector3¶; Computes center of mass of molecule (does not translate molecule). charge(self: psi4.core.Molecule, arg0: int) → float¶; Gets charge of atom. clone(self: psi4.core.Molecule) → psi4.core.Molecule¶; Returns a new Molecule identical to arg1. com_fixed(self: psi4.core.Molecule) → bool¶; Get whether or not COM is fixed. create_molecule_from_string(arg0: str) → psi4.core.Molecule¶; Returns a new Molecule with member data from the geometry string arg1 in psi4 format. create_psi4_string_from_molecule(self: psi4",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:129078,Energy Efficiency,charge,charge,129078,"-scaling algorithm from; Trent M. Parker, revamped by Lori A. Burns. Z(self: psi4.core.Molecule, arg0: int) → float¶; Nuclear charge of atom. activate_all_fragments(self: psi4.core.Molecule) → None¶; Sets all fragments in the molecule to be active. add_atom(self: psi4.core.Molecule, arg0: float, arg1: float, arg2: float, arg3: float, arg4: str, arg5: float, arg6: float, arg7: str, arg8: int) → None¶; Adds to Molecule arg1 an atom with atomic number arg2, Cartesian coordinates in Bohr (arg3, arg4, arg5), atomic symbol arg6, mass arg7, charge arg8 (optional), and lineno arg9 (optional). atom_at_position(self: psi4.core.Molecule, arg0: float, arg1: float) → int¶; Tests to see if an atom is at the position arg2 with a given tolerance arg3. basis_on_atom(self: psi4.core.Molecule, arg0: int) → str¶; Gets the label of the orbital basis set on a given atom. center_of_mass(self: psi4.core.Molecule) → psi4.core.Vector3¶; Computes center of mass of molecule (does not translate molecule). charge(self: psi4.core.Molecule, arg0: int) → float¶; Gets charge of atom. clone(self: psi4.core.Molecule) → psi4.core.Molecule¶; Returns a new Molecule identical to arg1. com_fixed(self: psi4.core.Molecule) → bool¶; Get whether or not COM is fixed. create_molecule_from_string(arg0: str) → psi4.core.Molecule¶; Returns a new Molecule with member data from the geometry string arg1 in psi4 format. create_psi4_string_from_molecule(self: psi4.core.Molecule) → str¶; Gets a string reexpressing in input format the current states of the molecule. deactivate_all_fragments(self: psi4.core.Molecule) → None¶; Sets all fragments in the molecule to be inactive. distance_matrix(self: psi4.core.Molecule) → psi4.core.Matrix¶; Returns Matrix of interatom distances. extract_subsets(*args, **kwargs)¶; Overloaded function. extract_subsets(self: psi4.core.Molecule, arg0: List[int], arg1: List[int]) -> psi4.core.Molecule. Returns copy of arg1 with arg2 fragments Real and arg3 fragments Ghost. extract_subsets(self: psi",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:129137,Energy Efficiency,charge,charge,129137,", revamped by Lori A. Burns. Z(self: psi4.core.Molecule, arg0: int) → float¶; Nuclear charge of atom. activate_all_fragments(self: psi4.core.Molecule) → None¶; Sets all fragments in the molecule to be active. add_atom(self: psi4.core.Molecule, arg0: float, arg1: float, arg2: float, arg3: float, arg4: str, arg5: float, arg6: float, arg7: str, arg8: int) → None¶; Adds to Molecule arg1 an atom with atomic number arg2, Cartesian coordinates in Bohr (arg3, arg4, arg5), atomic symbol arg6, mass arg7, charge arg8 (optional), and lineno arg9 (optional). atom_at_position(self: psi4.core.Molecule, arg0: float, arg1: float) → int¶; Tests to see if an atom is at the position arg2 with a given tolerance arg3. basis_on_atom(self: psi4.core.Molecule, arg0: int) → str¶; Gets the label of the orbital basis set on a given atom. center_of_mass(self: psi4.core.Molecule) → psi4.core.Vector3¶; Computes center of mass of molecule (does not translate molecule). charge(self: psi4.core.Molecule, arg0: int) → float¶; Gets charge of atom. clone(self: psi4.core.Molecule) → psi4.core.Molecule¶; Returns a new Molecule identical to arg1. com_fixed(self: psi4.core.Molecule) → bool¶; Get whether or not COM is fixed. create_molecule_from_string(arg0: str) → psi4.core.Molecule¶; Returns a new Molecule with member data from the geometry string arg1 in psi4 format. create_psi4_string_from_molecule(self: psi4.core.Molecule) → str¶; Gets a string reexpressing in input format the current states of the molecule. deactivate_all_fragments(self: psi4.core.Molecule) → None¶; Sets all fragments in the molecule to be inactive. distance_matrix(self: psi4.core.Molecule) → psi4.core.Matrix¶; Returns Matrix of interatom distances. extract_subsets(*args, **kwargs)¶; Overloaded function. extract_subsets(self: psi4.core.Molecule, arg0: List[int], arg1: List[int]) -> psi4.core.Molecule. Returns copy of arg1 with arg2 fragments Real and arg3 fragments Ghost. extract_subsets(self: psi4.core.Molecule, arg0: List[int], arg1: ",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:130856,Energy Efficiency,charge,charge,130856,"wargs)¶; Overloaded function. extract_subsets(self: psi4.core.Molecule, arg0: List[int], arg1: List[int]) -> psi4.core.Molecule. Returns copy of arg1 with arg2 fragments Real and arg3 fragments Ghost. extract_subsets(self: psi4.core.Molecule, arg0: List[int], arg1: int) -> psi4.core.Molecule. Returns copy of arg1 with arg2 fragments Real and arg3 fragment Ghost. extract_subsets(self: psi4.core.Molecule, arg0: int, arg1: List[int]) -> psi4.core.Molecule. Returns copy of arg1 with arg2 fragment Real and arg3 fragments Ghost. extract_subsets(self: psi4.core.Molecule, arg0: int, arg1: int) -> psi4.core.Molecule. Returns copy of arg1 with arg2 fragment Real and arg3 fragment Ghost. extract_subsets(self: psi4.core.Molecule, arg0: List[int]) -> psi4.core.Molecule. Returns copy of arg1 with arg2 fragments Real. extract_subsets(self: psi4.core.Molecule, arg0: int) -> psi4.core.Molecule. Returns copy of arg1 with arg2 fragment Real. fZ(self: psi4.core.Molecule, arg0: int) → float¶; Nuclear charge of atom arg1 (0-indexed including dummies). find_point_group(self: psi4.core.Molecule, arg0: float) → psi4.core.PointGroup¶; Finds computational molecular point group, user can override this with the symmetry keyword. fix_com(self: psi4.core.Molecule, arg0: bool) → None¶; Whether to fix the Cartesian position, or to translate to the C.O.M. fix_orientation(self: psi4.core.Molecule, arg0: bool) → None¶; Fix the orientation at its current frame. form_symmetry_information(self: psi4.core.Molecule, arg0: float) → None¶; Uses the point group object obtain by calling point_group(). classmethod from_arrays(geom=None, elea=None, elez=None, elem=None, mass=None, real=None, elbl=None, name=None, units='Angstrom', input_units_to_au=None, fix_com=None, fix_orientation=None, fix_symmetry=None, fragment_separators=None, fragment_charges=None, fragment_multiplicities=None, molecular_charge=None, molecular_multiplicity=None, missing_enabled_return='error', tooclose=0.1, zero_ghost_fragments=False, non",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:133674,Energy Efficiency,charge,charge,133674,"return Molecule dictionary intermediate.; verbose (int, optional) – Amount of printing. Returns:; mol (psi4.core.Molecule); molrec (dict, optional) – Dictionary representation of instance.; Only provided if return_dict is True. classmethod from_string(molstr, dtype=None, name=None, fix_com=None, fix_orientation=None, fix_symmetry=None, return_dict=False, enable_qm=True, enable_efp=True, missing_enabled_return_qm='none', missing_enabled_return_efp='none', verbose=1)¶. fx(self: psi4.core.Molecule, arg0: int) → float¶; x position of atom arg1 (0-indexed including dummies in Bohr). fy(self: psi4.core.Molecule, arg0: int) → float¶; y position of atom arg1 (0-indexed including dummies in Bohr). fz(self: psi4.core.Molecule, arg0: int) → float¶; z position of atom arg1 (0-indexed including dummies in Bohr). geometry(self: psi4.core.Molecule) → psi4.core.Matrix¶; Gets the geometry as a (Natom X 3) matrix of coordinates (in Bohr). get_fragment_charges(self: psi4.core.Molecule) → List[int]¶; Gets the charge of each fragment. get_fragment_multiplicities(self: psi4.core.Molecule) → List[int]¶; Gets the multiplicity of each fragment. get_fragment_types(self: psi4.core.Molecule) → List[str]¶; Returns a list describing how to handle each fragment {Real, Ghost, Absent}. get_fragments(self: psi4.core.Molecule) → List[Tuple[int, int]]¶; Returns list of pairs of atom ranges defining each fragment from parent molecule(fragments[frag_ind] = <Afirst,Alast+1>). get_full_point_group(self: psi4.core.Molecule) → str¶; Gets point group name such as C3v or S8. get_variable(self: psi4.core.Molecule, arg0: str) → float¶; Checks if variable arg2 is in the list, sets it to val and returns true if it is, and returns false if not. inertia_tensor(self: psi4.core.Molecule) → psi4.core.Matrix¶; Returns intertial tensor. input_units_to_au(self: psi4.core.Molecule) → float¶; Returns unit conversion to [a0] for geometry. irrep_labels(self: psi4.core.Molecule) → List[str]¶; Returns Irreducible Representation",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:135215,Energy Efficiency,charge,charge,135215,"up name such as C3v or S8. get_variable(self: psi4.core.Molecule, arg0: str) → float¶; Checks if variable arg2 is in the list, sets it to val and returns true if it is, and returns false if not. inertia_tensor(self: psi4.core.Molecule) → psi4.core.Matrix¶; Returns intertial tensor. input_units_to_au(self: psi4.core.Molecule) → float¶; Returns unit conversion to [a0] for geometry. irrep_labels(self: psi4.core.Molecule) → List[str]¶; Returns Irreducible Representation symmetry labels. is_variable(self: psi4.core.Molecule, arg0: str) → bool¶; Checks if variable arg2 is in the list, returns true if it is, and returns false if not. label(self: psi4.core.Molecule, arg0: int) → str¶; Gets the original label of the atom as given in the input file (C2, H4). mass(self: psi4.core.Molecule, atom: int) → float¶; Returns mass of atom (0-indexed). mass_number(self: psi4.core.Molecule, arg0: int) → int¶; Mass number (A) of atom if known, else -1. molecular_charge(self: psi4.core.Molecule) → int¶; Gets the molecular charge. move_to_com(self: psi4.core.Molecule) → None¶; Moves molecule to center of mass. multiplicity(self: psi4.core.Molecule) → int¶; Gets the multiplicity (defined as 2Ms + 1). nallatom(self: psi4.core.Molecule) → int¶; Number of real and dummy atoms. name(self: psi4.core.Molecule) → str¶; Gets molecule name. natom(self: psi4.core.Molecule) → int¶; Number of real atoms. nfragments(self: psi4.core.Molecule) → int¶; Gets the number of fragments in the molecule. nuclear_dipole(*args, **kwargs)¶; Overloaded function. nuclear_dipole(self: psi4.core.Molecule, arg0: psi4.core.Vector3) -> psi4.core.Vector3. Gets the nuclear contribution to the dipole, withe respect to a specified origin. nuclear_dipole(self: psi4.core.Molecule) -> psi4.core.Vector3. Gets the nuclear contribution to the dipole, withe respect to the origin. nuclear_repulsion_energy(self: psi4.core.Molecule, dipole_field: List[float[3]]=[0.0, 0.0, 0.0]) → float¶; Computes nuclear repulsion energy. nuclear_repuls",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:136178,Energy Efficiency,energy,energy,136178,"(self: psi4.core.Molecule) → int¶; Gets the molecular charge. move_to_com(self: psi4.core.Molecule) → None¶; Moves molecule to center of mass. multiplicity(self: psi4.core.Molecule) → int¶; Gets the multiplicity (defined as 2Ms + 1). nallatom(self: psi4.core.Molecule) → int¶; Number of real and dummy atoms. name(self: psi4.core.Molecule) → str¶; Gets molecule name. natom(self: psi4.core.Molecule) → int¶; Number of real atoms. nfragments(self: psi4.core.Molecule) → int¶; Gets the number of fragments in the molecule. nuclear_dipole(*args, **kwargs)¶; Overloaded function. nuclear_dipole(self: psi4.core.Molecule, arg0: psi4.core.Vector3) -> psi4.core.Vector3. Gets the nuclear contribution to the dipole, withe respect to a specified origin. nuclear_dipole(self: psi4.core.Molecule) -> psi4.core.Vector3. Gets the nuclear contribution to the dipole, withe respect to the origin. nuclear_repulsion_energy(self: psi4.core.Molecule, dipole_field: List[float[3]]=[0.0, 0.0, 0.0]) → float¶; Computes nuclear repulsion energy. nuclear_repulsion_energy_deriv1(self: psi4.core.Molecule, arg0: List[float[3]]) → psi4.core.Matrix¶; Returns first derivative of nuclear repulsion energy as a matrix (natom, 3). nuclear_repulsion_energy_deriv2(self: psi4.core.Molecule) → psi4.core.Matrix¶; Returns second derivative of nuclear repulsion energy as a matrix (natom X 3, natom X 3). orientation_fixed(self: psi4.core.Molecule) → bool¶; Get whether or not orientation is fixed. point_group(self: psi4.core.Molecule) → psi4.core.PointGroup¶; Returns the current point group object. print_bond_angles(self: psi4.core.Molecule) → None¶; Print the bond angle geometrical parameters. print_cluster(self: psi4.core.Molecule) → None¶; Prints the molecule in Cartesians in input units adding fragment separators. print_distances(self: psi4.core.Molecule) → None¶; Print the interatomic distance geometrical parameters. print_in_input_format(self: psi4.core.Molecule) → None¶; Prints the molecule as Cartesian or ZMatrix ",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:136333,Energy Efficiency,energy,energy,136333,"f: psi4.core.Molecule) → int¶; Gets the multiplicity (defined as 2Ms + 1). nallatom(self: psi4.core.Molecule) → int¶; Number of real and dummy atoms. name(self: psi4.core.Molecule) → str¶; Gets molecule name. natom(self: psi4.core.Molecule) → int¶; Number of real atoms. nfragments(self: psi4.core.Molecule) → int¶; Gets the number of fragments in the molecule. nuclear_dipole(*args, **kwargs)¶; Overloaded function. nuclear_dipole(self: psi4.core.Molecule, arg0: psi4.core.Vector3) -> psi4.core.Vector3. Gets the nuclear contribution to the dipole, withe respect to a specified origin. nuclear_dipole(self: psi4.core.Molecule) -> psi4.core.Vector3. Gets the nuclear contribution to the dipole, withe respect to the origin. nuclear_repulsion_energy(self: psi4.core.Molecule, dipole_field: List[float[3]]=[0.0, 0.0, 0.0]) → float¶; Computes nuclear repulsion energy. nuclear_repulsion_energy_deriv1(self: psi4.core.Molecule, arg0: List[float[3]]) → psi4.core.Matrix¶; Returns first derivative of nuclear repulsion energy as a matrix (natom, 3). nuclear_repulsion_energy_deriv2(self: psi4.core.Molecule) → psi4.core.Matrix¶; Returns second derivative of nuclear repulsion energy as a matrix (natom X 3, natom X 3). orientation_fixed(self: psi4.core.Molecule) → bool¶; Get whether or not orientation is fixed. point_group(self: psi4.core.Molecule) → psi4.core.PointGroup¶; Returns the current point group object. print_bond_angles(self: psi4.core.Molecule) → None¶; Print the bond angle geometrical parameters. print_cluster(self: psi4.core.Molecule) → None¶; Prints the molecule in Cartesians in input units adding fragment separators. print_distances(self: psi4.core.Molecule) → None¶; Print the interatomic distance geometrical parameters. print_in_input_format(self: psi4.core.Molecule) → None¶; Prints the molecule as Cartesian or ZMatrix entries, just as inputted. print_out(self: psi4.core.Molecule) → None¶; Prints the molecule in Cartesians in input units to output file. print_out_in_angstrom(s",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:136490,Energy Efficiency,energy,energy,136490,"i4.core.Molecule) → str¶; Gets molecule name. natom(self: psi4.core.Molecule) → int¶; Number of real atoms. nfragments(self: psi4.core.Molecule) → int¶; Gets the number of fragments in the molecule. nuclear_dipole(*args, **kwargs)¶; Overloaded function. nuclear_dipole(self: psi4.core.Molecule, arg0: psi4.core.Vector3) -> psi4.core.Vector3. Gets the nuclear contribution to the dipole, withe respect to a specified origin. nuclear_dipole(self: psi4.core.Molecule) -> psi4.core.Vector3. Gets the nuclear contribution to the dipole, withe respect to the origin. nuclear_repulsion_energy(self: psi4.core.Molecule, dipole_field: List[float[3]]=[0.0, 0.0, 0.0]) → float¶; Computes nuclear repulsion energy. nuclear_repulsion_energy_deriv1(self: psi4.core.Molecule, arg0: List[float[3]]) → psi4.core.Matrix¶; Returns first derivative of nuclear repulsion energy as a matrix (natom, 3). nuclear_repulsion_energy_deriv2(self: psi4.core.Molecule) → psi4.core.Matrix¶; Returns second derivative of nuclear repulsion energy as a matrix (natom X 3, natom X 3). orientation_fixed(self: psi4.core.Molecule) → bool¶; Get whether or not orientation is fixed. point_group(self: psi4.core.Molecule) → psi4.core.PointGroup¶; Returns the current point group object. print_bond_angles(self: psi4.core.Molecule) → None¶; Print the bond angle geometrical parameters. print_cluster(self: psi4.core.Molecule) → None¶; Prints the molecule in Cartesians in input units adding fragment separators. print_distances(self: psi4.core.Molecule) → None¶; Print the interatomic distance geometrical parameters. print_in_input_format(self: psi4.core.Molecule) → None¶; Prints the molecule as Cartesian or ZMatrix entries, just as inputted. print_out(self: psi4.core.Molecule) → None¶; Prints the molecule in Cartesians in input units to output file. print_out_in_angstrom(self: psi4.core.Molecule) → None¶; Prints the molecule in Cartesians in Angstroms to output file. print_out_in_bohr(self: psi4.core.Molecule) → None¶; Prints the m",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:139773,Energy Efficiency,energy,energy,139773,"psi4.core.Molecule or str) – Molecule on which to run dispersion calculation. Both qcdb and; psi4.core Molecule classes have been extended by this method, so; either allowed. Alternately, a string that can be instantiated; into a qcdb.Molecule.; func (str or None) – Density functional (Psi4, not Turbomole, names) for which to; load parameters from dashcoeff[dashlvl][func]. This is not; passed to DFTD3 and thus may be a dummy or None. Any or all; parameters initialized can be overwritten via dashparam.; dashlvl ({'d2p4', 'd2gr', 'd3zero', 'd3bj', 'd3mzero', d3mbj', 'd', 'd2', 'd3', 'd3m'}) – Flavor of a posteriori dispersion correction for which to load; parameters and call procedure in DFTD3. Must be a keys in; dashcoeff dict (or a key in dashalias that resolves to one).; dashparam (dict, optional) – Dictionary of the same keys as dashcoeff[dashlvl] used to; override any or all values initialized by; dashcoeff[dashlvl][func].; dertype ({None, 0, 'none', 'energy', 1, 'first', 'gradient'}, optional) – Maximum derivative level at which to run DFTD3. For large; mol, energy-only calculations can be significantly more; efficient. Also controls return values, see below.; verbose (bool, optional) – When True, additionally include DFTD3 output in output. Returns:; energy (float, optional) – When dertype is 0, energy [Eh].; gradient (list of lists of floats or psi4.core.Matrix, optional) – When dertype is 1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (float and list of lists of floats or psi4.core.Matrix, optional) – When dertype is unspecified, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; research site: https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/dft-d3; Psi4 mode: When psi4 the python module is importable at import qcdb. time, Psi4 mode is activated, with the following alterations:; * output goes to output file; * gradient returned as psi4.core.Matrix, not list o’lists; * scratch is written to randomly named subdirectory of psi scratch; * psiva",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:139883,Energy Efficiency,energy,energy-only,139883,"e Molecule classes have been extended by this method, so; either allowed. Alternately, a string that can be instantiated; into a qcdb.Molecule.; func (str or None) – Density functional (Psi4, not Turbomole, names) for which to; load parameters from dashcoeff[dashlvl][func]. This is not; passed to DFTD3 and thus may be a dummy or None. Any or all; parameters initialized can be overwritten via dashparam.; dashlvl ({'d2p4', 'd2gr', 'd3zero', 'd3bj', 'd3mzero', d3mbj', 'd', 'd2', 'd3', 'd3m'}) – Flavor of a posteriori dispersion correction for which to load; parameters and call procedure in DFTD3. Must be a keys in; dashcoeff dict (or a key in dashalias that resolves to one).; dashparam (dict, optional) – Dictionary of the same keys as dashcoeff[dashlvl] used to; override any or all values initialized by; dashcoeff[dashlvl][func].; dertype ({None, 0, 'none', 'energy', 1, 'first', 'gradient'}, optional) – Maximum derivative level at which to run DFTD3. For large; mol, energy-only calculations can be significantly more; efficient. Also controls return values, see below.; verbose (bool, optional) – When True, additionally include DFTD3 output in output. Returns:; energy (float, optional) – When dertype is 0, energy [Eh].; gradient (list of lists of floats or psi4.core.Matrix, optional) – When dertype is 1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (float and list of lists of floats or psi4.core.Matrix, optional) – When dertype is unspecified, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; research site: https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/dft-d3; Psi4 mode: When psi4 the python module is importable at import qcdb. time, Psi4 mode is activated, with the following alterations:; * output goes to output file; * gradient returned as psi4.core.Matrix, not list o’lists; * scratch is written to randomly named subdirectory of psi scratch; * psivar “DISPERSION CORRECTION ENERGY” is set; * verbose triggered when PRINT keywork of SCF module >=3. ru",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:139935,Energy Efficiency,efficient,efficient,139935,"e Molecule classes have been extended by this method, so; either allowed. Alternately, a string that can be instantiated; into a qcdb.Molecule.; func (str or None) – Density functional (Psi4, not Turbomole, names) for which to; load parameters from dashcoeff[dashlvl][func]. This is not; passed to DFTD3 and thus may be a dummy or None. Any or all; parameters initialized can be overwritten via dashparam.; dashlvl ({'d2p4', 'd2gr', 'd3zero', 'd3bj', 'd3mzero', d3mbj', 'd', 'd2', 'd3', 'd3m'}) – Flavor of a posteriori dispersion correction for which to load; parameters and call procedure in DFTD3. Must be a keys in; dashcoeff dict (or a key in dashalias that resolves to one).; dashparam (dict, optional) – Dictionary of the same keys as dashcoeff[dashlvl] used to; override any or all values initialized by; dashcoeff[dashlvl][func].; dertype ({None, 0, 'none', 'energy', 1, 'first', 'gradient'}, optional) – Maximum derivative level at which to run DFTD3. For large; mol, energy-only calculations can be significantly more; efficient. Also controls return values, see below.; verbose (bool, optional) – When True, additionally include DFTD3 output in output. Returns:; energy (float, optional) – When dertype is 0, energy [Eh].; gradient (list of lists of floats or psi4.core.Matrix, optional) – When dertype is 1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (float and list of lists of floats or psi4.core.Matrix, optional) – When dertype is unspecified, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; research site: https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/dft-d3; Psi4 mode: When psi4 the python module is importable at import qcdb. time, Psi4 mode is activated, with the following alterations:; * output goes to output file; * gradient returned as psi4.core.Matrix, not list o’lists; * scratch is written to randomly named subdirectory of psi scratch; * psivar “DISPERSION CORRECTION ENERGY” is set; * verbose triggered when PRINT keywork of SCF module >=3. ru",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:140080,Energy Efficiency,energy,energy,140080,"rbomole, names) for which to; load parameters from dashcoeff[dashlvl][func]. This is not; passed to DFTD3 and thus may be a dummy or None. Any or all; parameters initialized can be overwritten via dashparam.; dashlvl ({'d2p4', 'd2gr', 'd3zero', 'd3bj', 'd3mzero', d3mbj', 'd', 'd2', 'd3', 'd3m'}) – Flavor of a posteriori dispersion correction for which to load; parameters and call procedure in DFTD3. Must be a keys in; dashcoeff dict (or a key in dashalias that resolves to one).; dashparam (dict, optional) – Dictionary of the same keys as dashcoeff[dashlvl] used to; override any or all values initialized by; dashcoeff[dashlvl][func].; dertype ({None, 0, 'none', 'energy', 1, 'first', 'gradient'}, optional) – Maximum derivative level at which to run DFTD3. For large; mol, energy-only calculations can be significantly more; efficient. Also controls return values, see below.; verbose (bool, optional) – When True, additionally include DFTD3 output in output. Returns:; energy (float, optional) – When dertype is 0, energy [Eh].; gradient (list of lists of floats or psi4.core.Matrix, optional) – When dertype is 1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (float and list of lists of floats or psi4.core.Matrix, optional) – When dertype is unspecified, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; research site: https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/dft-d3; Psi4 mode: When psi4 the python module is importable at import qcdb. time, Psi4 mode is activated, with the following alterations:; * output goes to output file; * gradient returned as psi4.core.Matrix, not list o’lists; * scratch is written to randomly named subdirectory of psi scratch; * psivar “DISPERSION CORRECTION ENERGY” is set; * verbose triggered when PRINT keywork of SCF module >=3. run_gcp(func=None, dertype=None, verbose=False)¶; Function to call Grimme’s dftd3 program (http://toc.uni-muenster.de/DFTD3/); to compute the -D correction of level dashlvl using parameters for; the f",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:140126,Energy Efficiency,energy,energy,140126,"rbomole, names) for which to; load parameters from dashcoeff[dashlvl][func]. This is not; passed to DFTD3 and thus may be a dummy or None. Any or all; parameters initialized can be overwritten via dashparam.; dashlvl ({'d2p4', 'd2gr', 'd3zero', 'd3bj', 'd3mzero', d3mbj', 'd', 'd2', 'd3', 'd3m'}) – Flavor of a posteriori dispersion correction for which to load; parameters and call procedure in DFTD3. Must be a keys in; dashcoeff dict (or a key in dashalias that resolves to one).; dashparam (dict, optional) – Dictionary of the same keys as dashcoeff[dashlvl] used to; override any or all values initialized by; dashcoeff[dashlvl][func].; dertype ({None, 0, 'none', 'energy', 1, 'first', 'gradient'}, optional) – Maximum derivative level at which to run DFTD3. For large; mol, energy-only calculations can be significantly more; efficient. Also controls return values, see below.; verbose (bool, optional) – When True, additionally include DFTD3 output in output. Returns:; energy (float, optional) – When dertype is 0, energy [Eh].; gradient (list of lists of floats or psi4.core.Matrix, optional) – When dertype is 1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (float and list of lists of floats or psi4.core.Matrix, optional) – When dertype is unspecified, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; research site: https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/dft-d3; Psi4 mode: When psi4 the python module is importable at import qcdb. time, Psi4 mode is activated, with the following alterations:; * output goes to output file; * gradient returned as psi4.core.Matrix, not list o’lists; * scratch is written to randomly named subdirectory of psi scratch; * psivar “DISPERSION CORRECTION ENERGY” is set; * verbose triggered when PRINT keywork of SCF module >=3. run_gcp(func=None, dertype=None, verbose=False)¶; Function to call Grimme’s dftd3 program (http://toc.uni-muenster.de/DFTD3/); to compute the -D correction of level dashlvl using parameters for; the f",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:140255,Energy Efficiency,energy,energy,140255,"overwritten via dashparam.; dashlvl ({'d2p4', 'd2gr', 'd3zero', 'd3bj', 'd3mzero', d3mbj', 'd', 'd2', 'd3', 'd3m'}) – Flavor of a posteriori dispersion correction for which to load; parameters and call procedure in DFTD3. Must be a keys in; dashcoeff dict (or a key in dashalias that resolves to one).; dashparam (dict, optional) – Dictionary of the same keys as dashcoeff[dashlvl] used to; override any or all values initialized by; dashcoeff[dashlvl][func].; dertype ({None, 0, 'none', 'energy', 1, 'first', 'gradient'}, optional) – Maximum derivative level at which to run DFTD3. For large; mol, energy-only calculations can be significantly more; efficient. Also controls return values, see below.; verbose (bool, optional) – When True, additionally include DFTD3 output in output. Returns:; energy (float, optional) – When dertype is 0, energy [Eh].; gradient (list of lists of floats or psi4.core.Matrix, optional) – When dertype is 1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (float and list of lists of floats or psi4.core.Matrix, optional) – When dertype is unspecified, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; research site: https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/dft-d3; Psi4 mode: When psi4 the python module is importable at import qcdb. time, Psi4 mode is activated, with the following alterations:; * output goes to output file; * gradient returned as psi4.core.Matrix, not list o’lists; * scratch is written to randomly named subdirectory of psi scratch; * psivar “DISPERSION CORRECTION ENERGY” is set; * verbose triggered when PRINT keywork of SCF module >=3. run_gcp(func=None, dertype=None, verbose=False)¶; Function to call Grimme’s dftd3 program (http://toc.uni-muenster.de/DFTD3/); to compute the -D correction of level dashlvl using parameters for; the functional func. The dictionary dashparam can be used to supply; a full set of dispersion parameters in the absense of func or to supply; individual overrides in the presence of fun",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:140375,Energy Efficiency,energy,energy,140375,"mbj', 'd', 'd2', 'd3', 'd3m'}) – Flavor of a posteriori dispersion correction for which to load; parameters and call procedure in DFTD3. Must be a keys in; dashcoeff dict (or a key in dashalias that resolves to one).; dashparam (dict, optional) – Dictionary of the same keys as dashcoeff[dashlvl] used to; override any or all values initialized by; dashcoeff[dashlvl][func].; dertype ({None, 0, 'none', 'energy', 1, 'first', 'gradient'}, optional) – Maximum derivative level at which to run DFTD3. For large; mol, energy-only calculations can be significantly more; efficient. Also controls return values, see below.; verbose (bool, optional) – When True, additionally include DFTD3 output in output. Returns:; energy (float, optional) – When dertype is 0, energy [Eh].; gradient (list of lists of floats or psi4.core.Matrix, optional) – When dertype is 1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (float and list of lists of floats or psi4.core.Matrix, optional) – When dertype is unspecified, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; research site: https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/dft-d3; Psi4 mode: When psi4 the python module is importable at import qcdb. time, Psi4 mode is activated, with the following alterations:; * output goes to output file; * gradient returned as psi4.core.Matrix, not list o’lists; * scratch is written to randomly named subdirectory of psi scratch; * psivar “DISPERSION CORRECTION ENERGY” is set; * verbose triggered when PRINT keywork of SCF module >=3. run_gcp(func=None, dertype=None, verbose=False)¶; Function to call Grimme’s dftd3 program (http://toc.uni-muenster.de/DFTD3/); to compute the -D correction of level dashlvl using parameters for; the functional func. The dictionary dashparam can be used to supply; a full set of dispersion parameters in the absense of func or to supply; individual overrides in the presence of func. Returns energy if dertype is 0,; gradient if dertype is 1, else tuple of energy an",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:141295,Energy Efficiency,energy,energy,141295," dertype is unspecified, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; research site: https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/dft-d3; Psi4 mode: When psi4 the python module is importable at import qcdb. time, Psi4 mode is activated, with the following alterations:; * output goes to output file; * gradient returned as psi4.core.Matrix, not list o’lists; * scratch is written to randomly named subdirectory of psi scratch; * psivar “DISPERSION CORRECTION ENERGY” is set; * verbose triggered when PRINT keywork of SCF module >=3. run_gcp(func=None, dertype=None, verbose=False)¶; Function to call Grimme’s dftd3 program (http://toc.uni-muenster.de/DFTD3/); to compute the -D correction of level dashlvl using parameters for; the functional func. The dictionary dashparam can be used to supply; a full set of dispersion parameters in the absense of func or to supply; individual overrides in the presence of func. Returns energy if dertype is 0,; gradient if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The dftd3 executable must be independently compiled and found in; PATH or PSIPATH.; self may be either a qcdb.Molecule (sensibly) or a psi4.Molecule; (works b/c psi4.Molecule has been extended by this method py-side and; only public interface fns used) or a string that can be instantiated; into a qcdb.Molecule. save_string_xyz(self: psi4.core.Molecule) → str¶; Saves the string of an XYZ file to arg2. save_string_xyz_file(self: psi4.core.Molecule) → str¶; Saves an XYZ file to arg2. save_xyz_file(self: psi4.core.Molecule, arg0: str, arg1: bool) → None¶; Saves an XYZ file to arg2. schoenflies_symbol(self: psi4.core.Molecule) → str¶; Returns the Schoenflies symbol. scramble(do_shift=True, do_rotate=True, do_resort=True, deflection=1.0, do_mirror=False, do_plot=False, run_to_completion=False, run_resorting=False, verbose=1)¶; Tester for B787 by shifting, rotating, and atom shuffling ref_mol and; checking that the aligner returns th",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:141360,Energy Efficiency,energy,energy,141360," dertype is unspecified, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; research site: https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/dft-d3; Psi4 mode: When psi4 the python module is importable at import qcdb. time, Psi4 mode is activated, with the following alterations:; * output goes to output file; * gradient returned as psi4.core.Matrix, not list o’lists; * scratch is written to randomly named subdirectory of psi scratch; * psivar “DISPERSION CORRECTION ENERGY” is set; * verbose triggered when PRINT keywork of SCF module >=3. run_gcp(func=None, dertype=None, verbose=False)¶; Function to call Grimme’s dftd3 program (http://toc.uni-muenster.de/DFTD3/); to compute the -D correction of level dashlvl using parameters for; the functional func. The dictionary dashparam can be used to supply; a full set of dispersion parameters in the absense of func or to supply; individual overrides in the presence of func. Returns energy if dertype is 0,; gradient if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The dftd3 executable must be independently compiled and found in; PATH or PSIPATH.; self may be either a qcdb.Molecule (sensibly) or a psi4.Molecule; (works b/c psi4.Molecule has been extended by this method py-side and; only public interface fns used) or a string that can be instantiated; into a qcdb.Molecule. save_string_xyz(self: psi4.core.Molecule) → str¶; Saves the string of an XYZ file to arg2. save_string_xyz_file(self: psi4.core.Molecule) → str¶; Saves an XYZ file to arg2. save_xyz_file(self: psi4.core.Molecule, arg0: str, arg1: bool) → None¶; Saves an XYZ file to arg2. schoenflies_symbol(self: psi4.core.Molecule) → str¶; Returns the Schoenflies symbol. scramble(do_shift=True, do_rotate=True, do_resort=True, deflection=1.0, do_mirror=False, do_plot=False, run_to_completion=False, run_resorting=False, verbose=1)¶; Tester for B787 by shifting, rotating, and atom shuffling ref_mol and; checking that the aligner returns th",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:145079,Energy Efficiency,charge,charge,145079,"s basis set arg2 to all atoms. set_basis_by_label(self: psi4.core.Molecule, arg0: str, arg1: str, arg2: str) → None¶; Sets basis set arg3 to all atoms with label (e.g., H4) arg2. set_basis_by_symbol(self: psi4.core.Molecule, arg0: str, arg1: str, arg2: str) → None¶; Sets basis set arg3 to all atoms with symbol (e.g., H) arg2. set_geometry(self: psi4.core.Molecule, arg0: psi4.core.Matrix) → None¶; Sets the geometry, given a (Natom X 3) matrix arg2 of coordinates (in Bohr). set_ghost_fragment(self: psi4.core.Molecule, arg0: int) → None¶; Sets the specified fragment arg2 to be Ghost. set_ghost_fragments(self: psi4.core.Molecule, arg0: List[int]) → None¶; Sets the specified list arg2 of fragments to be Ghost. set_input_units_to_au(self: psi4.core.Molecule, arg0: float) → None¶; Sets unit conversion to [a0] for geometry. set_mass(self: psi4.core.Molecule, atom: int, mass: float) → None¶; Sets mass of atom (0-indexed) to mass. set_molecular_charge(self: psi4.core.Molecule, arg0: int) → None¶; Sets the molecular charge. set_multiplicity(self: psi4.core.Molecule, arg0: int) → None¶; Sets the multiplicity (defined as 2Ms + 1). set_name(self: psi4.core.Molecule, arg0: str) → None¶; Sets molecule name. set_nuclear_charge(self: psi4.core.Molecule, arg0: int, arg1: float) → None¶; Set the nuclear charge of the given atom to the value provided. set_point_group(self: psi4.core.Molecule, arg0: psi4.core.PointGroup) → None¶; Sets the molecular point group to the point group object arg2. set_units(self: psi4.core.Molecule, arg0: psi4.core.GeometryUnits) → None¶; Sets units (Angstrom or Bohr) used to define the geometry. set_variable(self: psi4.core.Molecule, arg0: str, arg1: float) → None¶; Assigns the value arg3 to the variable arg2 in the list of geometry variables, then calls update_geometry(). symbol(self: psi4.core.Molecule, arg0: int) → str¶; Gets the cleaned up label of atom arg2 (C2 => C, H4 = H). symmetrize(self: psi4.core.Molecule, arg0: float) → None¶; Finds the highest po",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:145363,Energy Efficiency,charge,charge,145363," with symbol (e.g., H) arg2. set_geometry(self: psi4.core.Molecule, arg0: psi4.core.Matrix) → None¶; Sets the geometry, given a (Natom X 3) matrix arg2 of coordinates (in Bohr). set_ghost_fragment(self: psi4.core.Molecule, arg0: int) → None¶; Sets the specified fragment arg2 to be Ghost. set_ghost_fragments(self: psi4.core.Molecule, arg0: List[int]) → None¶; Sets the specified list arg2 of fragments to be Ghost. set_input_units_to_au(self: psi4.core.Molecule, arg0: float) → None¶; Sets unit conversion to [a0] for geometry. set_mass(self: psi4.core.Molecule, atom: int, mass: float) → None¶; Sets mass of atom (0-indexed) to mass. set_molecular_charge(self: psi4.core.Molecule, arg0: int) → None¶; Sets the molecular charge. set_multiplicity(self: psi4.core.Molecule, arg0: int) → None¶; Sets the multiplicity (defined as 2Ms + 1). set_name(self: psi4.core.Molecule, arg0: str) → None¶; Sets molecule name. set_nuclear_charge(self: psi4.core.Molecule, arg0: int, arg1: float) → None¶; Set the nuclear charge of the given atom to the value provided. set_point_group(self: psi4.core.Molecule, arg0: psi4.core.PointGroup) → None¶; Sets the molecular point group to the point group object arg2. set_units(self: psi4.core.Molecule, arg0: psi4.core.GeometryUnits) → None¶; Sets units (Angstrom or Bohr) used to define the geometry. set_variable(self: psi4.core.Molecule, arg0: str, arg1: float) → None¶; Assigns the value arg3 to the variable arg2 in the list of geometry variables, then calls update_geometry(). symbol(self: psi4.core.Molecule, arg0: int) → str¶; Gets the cleaned up label of atom arg2 (C2 => C, H4 = H). symmetrize(self: psi4.core.Molecule, arg0: float) → None¶; Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. symmetry_from_input(self: psi4.core.Molecule) → str¶; Returns the symmetry specified in the input. to_arrays()¶; Exports coordinate info into NumPy arrays. Returns:; geom, mass, elem, elez, uniq (",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:161268,Energy Efficiency,charge,charges,161268,"atrix. H(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the ‘Core’ Matrix (Potential + Kinetic) Integrals. S(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the One-electron Overlap Matrix. V_potential(self: psi4.core.HF) → psi4.core.VBase¶; Returns the internal DFT V object. Va(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Alpha Kohn-Shame Potential Matrix. Vb(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Alpha Kohn-Shame Potential Matrix. X(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Lagrangian Matrix. alpha_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. aotoso(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Atomic Orbital to Symmetry Orbital transformer. arrays(self: psi4.core.Wavefunction) → Dict[str, psi4.core.Matrix]¶; Returns the map of all internal arrays. atomic_point_charges(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.RHF, basis: psi4.core.BasisSet) → psi4.core.RHF¶; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunc",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:162011,Energy Efficiency,energy,energy,162011,"the Atomic Orbital to Symmetry Orbital transformer. arrays(self: psi4.core.Wavefunction) → Dict[str, psi4.core.Matrix]¶; Returns the map of all internal arrays. atomic_point_charges(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.RHF, basis: psi4.core.BasisSet) → psi4.core.RHF¶; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix]) → List[psi4.core.Matrix]¶; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF) → bool¶; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int=2) → List[psi4.core.Matrix]¶; Solves the CPHF equations for a given set of x vectors. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wav",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:162896,Energy Efficiency,energy,energy,162896,"ing pre-c1-constructed BasisSet basis. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix]) → List[psi4.core.Matrix]¶; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF) → bool¶; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int=2) → List[psi4.core.Matrix]¶; Solves the CPHF equations for a given set of x vectors. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Beta Eigenvalues subset. esp_at_nuclei(self: psi4.core.Wavefunction) → psi4.core.Vector¶; returns electrostatic potentials at nuclei. finalize_E(self: psi4.core.HF) → float¶; Computes the final SCF energy. force_doccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only. Sets the number of doubly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. force_soccpi(self: psi4.core.Wavef",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:162969,Energy Efficiency,energy,energy,162969,"ute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix]) → List[psi4.core.Matrix]¶; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF) → bool¶; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int=2) → List[psi4.core.Matrix]¶; Solves the CPHF equations for a given set of x vectors. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Beta Eigenvalues subset. esp_at_nuclei(self: psi4.core.Wavefunction) → psi4.core.Vector¶; returns electrostatic potentials at nuclei. finalize_E(self: psi4.core.HF) → float¶; Computes the final SCF energy. force_doccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only. Sets the number of doubly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. force_soccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:163608,Energy Efficiency,energy,energy,163608,"i4.core.Matrix]¶; Solves the CPHF equations for a given set of x vectors. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Beta Eigenvalues subset. esp_at_nuclei(self: psi4.core.Wavefunction) → psi4.core.Vector¶; returns electrostatic potentials at nuclei. finalize_E(self: psi4.core.HF) → float¶; Computes the final SCF energy. force_doccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only. Sets the number of doubly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. force_soccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only. Sets the number of singly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. form_C(self: psi4.core.HF) → None¶; Forms the Orbital Matrices from the current Fock Matrices. form_D(self: psi4.core.HF) → None¶; Forms the Density Matrices from the current Orbitals Matrices. form_F(self: psi4.core.HF) → None¶; Forms the F matrix. form_G(self: psi4.core.HF) → None¶; Forms the G matrix. form_V(self: psi4.core.HF) → None¶; Form the Kohn-Sham Potential Matrices from the current Density Matrices. frequencies(self: psi4.core.Wavefunction) → psi4.cor",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:173857,Energy Efficiency,charge,charges,173857,"atrix. H(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the ‘Core’ Matrix (Potential + Kinetic) Integrals. S(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the One-electron Overlap Matrix. V_potential(self: psi4.core.HF) → psi4.core.VBase¶; Returns the internal DFT V object. Va(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Alpha Kohn-Shame Potential Matrix. Vb(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Alpha Kohn-Shame Potential Matrix. X(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Lagrangian Matrix. alpha_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. aotoso(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Atomic Orbital to Symmetry Orbital transformer. arrays(self: psi4.core.Wavefunction) → Dict[str, psi4.core.Matrix]¶; Returns the map of all internal arrays. atomic_point_charges(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.ROHF, basis: psi4.core.BasisSet) → psi4.core.ROHF¶; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefu",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:174602,Energy Efficiency,energy,energy,174602,"e Atomic Orbital to Symmetry Orbital transformer. arrays(self: psi4.core.Wavefunction) → Dict[str, psi4.core.Matrix]¶; Returns the map of all internal arrays. atomic_point_charges(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.ROHF, basis: psi4.core.BasisSet) → psi4.core.ROHF¶; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix]) → List[psi4.core.Matrix]¶; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF) → bool¶; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int=2) → List[psi4.core.Matrix]¶; Solves the CPHF equations for a given set of x vectors. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wav",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:175487,Energy Efficiency,energy,energy,175487,"ing pre-c1-constructed BasisSet basis. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix]) → List[psi4.core.Matrix]¶; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF) → bool¶; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int=2) → List[psi4.core.Matrix]¶; Solves the CPHF equations for a given set of x vectors. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Beta Eigenvalues subset. esp_at_nuclei(self: psi4.core.Wavefunction) → psi4.core.Vector¶; returns electrostatic potentials at nuclei. finalize_E(self: psi4.core.HF) → float¶; Computes the final SCF energy. force_doccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only. Sets the number of doubly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. force_soccpi(self: psi4.core.Wavef",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:175560,Energy Efficiency,energy,energy,175560,"ute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix]) → List[psi4.core.Matrix]¶; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF) → bool¶; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int=2) → List[psi4.core.Matrix]¶; Solves the CPHF equations for a given set of x vectors. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Beta Eigenvalues subset. esp_at_nuclei(self: psi4.core.Wavefunction) → psi4.core.Vector¶; returns electrostatic potentials at nuclei. finalize_E(self: psi4.core.HF) → float¶; Computes the final SCF energy. force_doccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only. Sets the number of doubly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. force_soccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:176199,Energy Efficiency,energy,energy,176199,"i4.core.Matrix]¶; Solves the CPHF equations for a given set of x vectors. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Beta Eigenvalues subset. esp_at_nuclei(self: psi4.core.Wavefunction) → psi4.core.Vector¶; returns electrostatic potentials at nuclei. finalize_E(self: psi4.core.HF) → float¶; Computes the final SCF energy. force_doccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only. Sets the number of doubly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. force_soccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only. Sets the number of singly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. form_C(self: psi4.core.HF) → None¶; Forms the Orbital Matrices from the current Fock Matrices. form_D(self: psi4.core.HF) → None¶; Forms the Density Matrices from the current Orbitals Matrices. form_F(self: psi4.core.HF) → None¶; Forms the F matrix. form_G(self: psi4.core.HF) → None¶; Forms the G matrix. form_V(self: psi4.core.HF) → None¶; Form the Kohn-Sham Potential Matrices from the current Density Matrices. frequencies(self: psi4.core.Wavefunction) → psi4.cor",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:186769,Energy Efficiency,allocate,allocate,186769,"trix) → None¶. class psi4.core.SaveType¶; Bases: pybind11_builtins.pybind11_object; The layout of the matrix for saving. Full = SaveType.Full¶. LowerTriangle = SaveType.LowerTriangle¶. SubBlocks = SaveType.SubBlocks¶. class psi4.core.ShellInfo¶; Bases: pybind11_builtins.pybind11_object. class psi4.core.Slice¶; Bases: pybind11_builtins.pybind11_object; Slicing for Matrix and Vector objects. begin(self: psi4.core.Slice) → psi4.core.Dimension¶; Get the first element of this slice. end(self: psi4.core.Slice) → psi4.core.Dimension¶; Get the past-the-end element of this slice. class psi4.core.SuperFunctional¶; Bases: pybind11_builtins.pybind11_object; docstring. XC_build(arg0: str, arg1: bool) → psi4.core.SuperFunctional¶; Builds a SuperFunctional from a XC string. add_c_functional(self: psi4.core.SuperFunctional, arg0: psi::Functional) → None¶; Add a correlation Functional. add_x_functional(self: psi4.core.SuperFunctional, arg0: psi::Functional) → None¶; Add a exchange Functional. allocate(self: psi4.core.SuperFunctional) → None¶; Allocates the vectors, should be called after ansatz or npoint changes. ansatz(self: psi4.core.SuperFunctional) → int¶; SuperFunctional rung. blank() → psi4.core.SuperFunctional¶; Initialize a blank SuperFunctional. c_alpha(self: psi4.core.SuperFunctional) → float¶; Amount of MP2 correlation. c_functional(self: psi4.core.SuperFunctional, arg0: str) → psi::Functional¶; Returns the desired C Functional. c_functionals(self: psi4.core.SuperFunctional) → List[psi::Functional]¶; Returns all C Functionals. c_omega(self: psi4.core.SuperFunctional) → float¶; Range-seperated correlation parameter. c_os_alpha(self: psi4.core.SuperFunctional) → float¶; Amount of SS MP2 correlation. c_ss_alpha(self: psi4.core.SuperFunctional) → float¶; Amount of OS MP2 correlation. citation(self: psi4.core.SuperFunctional) → str¶; SuperFunctional citation. compute_functional(self: psi4.core.SuperFunctional, arg0: Dict[str, psi4.core.Vector], arg1: int) → Dict[str, psi4.core.",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:197342,Energy Efficiency,charge,charges,197342,"atrix. H(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the ‘Core’ Matrix (Potential + Kinetic) Integrals. S(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the One-electron Overlap Matrix. V_potential(self: psi4.core.HF) → psi4.core.VBase¶; Returns the internal DFT V object. Va(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Alpha Kohn-Shame Potential Matrix. Vb(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Alpha Kohn-Shame Potential Matrix. X(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Lagrangian Matrix. alpha_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. aotoso(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Atomic Orbital to Symmetry Orbital transformer. arrays(self: psi4.core.Wavefunction) → Dict[str, psi4.core.Matrix]¶; Returns the map of all internal arrays. atomic_point_charges(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.UHF, basis: psi4.core.BasisSet) → psi4.core.UHF¶; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunc",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:198085,Energy Efficiency,energy,energy,198085,"the Atomic Orbital to Symmetry Orbital transformer. arrays(self: psi4.core.Wavefunction) → Dict[str, psi4.core.Matrix]¶; Returns the map of all internal arrays. atomic_point_charges(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.UHF, basis: psi4.core.BasisSet) → psi4.core.UHF¶; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix]) → List[psi4.core.Matrix]¶; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF) → bool¶; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int=2) → List[psi4.core.Matrix]¶; Solves the CPHF equations for a given set of x vectors. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wav",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:198970,Energy Efficiency,energy,energy,198970,"ing pre-c1-constructed BasisSet basis. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix]) → List[psi4.core.Matrix]¶; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF) → bool¶; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int=2) → List[psi4.core.Matrix]¶; Solves the CPHF equations for a given set of x vectors. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Beta Eigenvalues subset. esp_at_nuclei(self: psi4.core.Wavefunction) → psi4.core.Vector¶; returns electrostatic potentials at nuclei. finalize_E(self: psi4.core.HF) → float¶; Computes the final SCF energy. force_doccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only. Sets the number of doubly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. force_soccpi(self: psi4.core.Wavef",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:199043,Energy Efficiency,energy,energy,199043,"ute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix]) → List[psi4.core.Matrix]¶; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF) → bool¶; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int=2) → List[psi4.core.Matrix]¶; Solves the CPHF equations for a given set of x vectors. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Beta Eigenvalues subset. esp_at_nuclei(self: psi4.core.Wavefunction) → psi4.core.Vector¶; returns electrostatic potentials at nuclei. finalize_E(self: psi4.core.HF) → float¶; Computes the final SCF energy. force_doccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only. Sets the number of doubly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. force_soccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:199682,Energy Efficiency,energy,energy,199682,"i4.core.Matrix]¶; Solves the CPHF equations for a given set of x vectors. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Beta Eigenvalues subset. esp_at_nuclei(self: psi4.core.Wavefunction) → psi4.core.Vector¶; returns electrostatic potentials at nuclei. finalize_E(self: psi4.core.HF) → float¶; Computes the final SCF energy. force_doccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only. Sets the number of doubly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. force_soccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only. Sets the number of singly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. form_C(self: psi4.core.HF) → None¶; Forms the Orbital Matrices from the current Fock Matrices. form_D(self: psi4.core.HF) → None¶; Forms the Density Matrices from the current Orbitals Matrices. form_F(self: psi4.core.HF) → None¶; Forms the F matrix. form_G(self: psi4.core.HF) → None¶; Forms the G matrix. form_V(self: psi4.core.HF) → None¶; Form the Kohn-Sham Potential Matrices from the current Density Matrices. frequencies(self: psi4.core.Wavefunction) → psi4.cor",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:216997,Energy Efficiency,charge,charges,216997,"t(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Returns the requested Beta Density subset. Fa(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Alpha Fock Matrix. Fb(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Beta Fock Matrix. H(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the ‘Core’ Matrix (Potential + Kinetic) Integrals. S(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the One-electron Overlap Matrix. X(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Lagrangian Matrix. alpha_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. aotoso(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Atomic Orbital to Symmetry Orbital transformer. arrays(self: psi4.core.Wavefunction) → Dict[str, psi4.core.Matrix]¶; Returns the map of all internal arrays. atomic_point_charges(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.Wavefunction, basis: psi4.core.BasisSet) → psi4.core.Wavefunction¶; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet *basis. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hess",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:217759,Energy Efficiency,energy,energy,217759,"to Symmetry Orbital transformer. arrays(self: psi4.core.Wavefunction) → Dict[str, psi4.core.Matrix]¶; Returns the map of all internal arrays. atomic_point_charges(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.Wavefunction, basis: psi4.core.BasisSet) → psi4.core.Wavefunction¶; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet *basis. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Beta",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:218236,Energy Efficiency,energy,energy,218236," psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.Wavefunction, basis: psi4.core.BasisSet) → psi4.core.Wavefunction¶; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet *basis. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Beta Eigenvalues subset. esp_at_nuclei(self: psi4.core.Wavefunction) → psi4.core.Vector¶; returns electrostatic potentials at nuclei. force_doccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only. Sets the number of doubly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. force_soccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:218309,Energy Efficiency,energy,energy,218309,"et¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.Wavefunction, basis: psi4.core.BasisSet) → psi4.core.Wavefunction¶; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet *basis. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Beta Eigenvalues subset. esp_at_nuclei(self: psi4.core.Wavefunction) → psi4.core.Vector¶; returns electrostatic potentials at nuclei. force_doccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only. Sets the number of doubly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. force_soccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only. Sets the number of singly occupied oribta",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:224810,Energy Efficiency,energy,energy,224810,"bles. psi4.core.adc(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the ADC propagator code, for excited states. psi4.core.atomic_displacements(arg0: psi::Molecule) → List[psi::Matrix]¶; Returns list of displacements generated by displacing each atom in the +/- x, y, z directions. psi4.core.be_quiet() → None¶; Redirects output to /dev/null. To switch back to regular output mode, use reopen_outfile(). psi4.core.benchmark_blas1(arg0: int, arg1: float) → None¶; docstring. psi4.core.benchmark_blas2(arg0: int, arg1: float) → None¶; docstring. psi4.core.benchmark_blas3(arg0: int, arg1: float, arg2: int) → None¶; docstring. psi4.core.benchmark_disk(arg0: int, arg1: float) → None¶; docstring. psi4.core.benchmark_integrals(arg0: int, arg1: float) → None¶; docstring. psi4.core.benchmark_math(arg0: float) → None¶; docstring. psi4.core.ccdensity(arg0: psi::Wavefunction) → float¶; Runs the code to compute coupled cluster density matrices. psi4.core.ccenergy(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the coupled cluster energy code. psi4.core.cceom(arg0: psi::Wavefunction) → float¶; Runs the equation of motion coupled cluster code, for excited states. psi4.core.cchbar(arg0: psi::Wavefunction) → None¶; Runs the code to generate the similarity transformed Hamiltonian. psi4.core.cclambda(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the coupled cluster lambda equations code. psi4.core.ccresponse(arg0: psi::Wavefunction) → float¶; Runs the coupled cluster response theory code. psi4.core.cctransort(arg0: psi::Wavefunction) → None¶; Runs CCTRANSORT, which transforms and reorders integrals for use in the coupled cluster codes. psi4.core.cctriples(arg0: psi::Wavefunction) → float¶; Runs the coupled cluster (T) energy code. psi4.core.clean() → None¶; Function to remove scratch files. Call between independent jobs. psi4.core.clean_options() → None¶; Function to reset options to clean state. psi4.core.clean_variables() → None¶; Empties all PSI variables that have set inter",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:225512,Energy Efficiency,energy,energy,225512,"e.benchmark_integrals(arg0: int, arg1: float) → None¶; docstring. psi4.core.benchmark_math(arg0: float) → None¶; docstring. psi4.core.ccdensity(arg0: psi::Wavefunction) → float¶; Runs the code to compute coupled cluster density matrices. psi4.core.ccenergy(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the coupled cluster energy code. psi4.core.cceom(arg0: psi::Wavefunction) → float¶; Runs the equation of motion coupled cluster code, for excited states. psi4.core.cchbar(arg0: psi::Wavefunction) → None¶; Runs the code to generate the similarity transformed Hamiltonian. psi4.core.cclambda(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the coupled cluster lambda equations code. psi4.core.ccresponse(arg0: psi::Wavefunction) → float¶; Runs the coupled cluster response theory code. psi4.core.cctransort(arg0: psi::Wavefunction) → None¶; Runs CCTRANSORT, which transforms and reorders integrals for use in the coupled cluster codes. psi4.core.cctriples(arg0: psi::Wavefunction) → float¶; Runs the coupled cluster (T) energy code. psi4.core.clean() → None¶; Function to remove scratch files. Call between independent jobs. psi4.core.clean_options() → None¶; Function to reset options to clean state. psi4.core.clean_variables() → None¶; Empties all PSI variables that have set internally. psi4.core.close_outfile() → None¶; Closes the output file. psi4.core.dcft(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the density cumulant functional theory code. psi4.core.detci(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the determinant-based configuration interaction code. psi4.core.dfmp2(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the DF-MP2 code. psi4.core.dfocc(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the density-fitted orbital optimized CC codes. psi4.core.displace_atom(arg0: psi::Matrix, arg1: int, arg2: int, arg3: int, arg4: float) → None¶; Displaces one coordinate of single atom. psi4.core.dmrg(arg0: psi::Wavefunction) → float¶; Runs the DMRG co",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:226970,Energy Efficiency,energy,energy,226970,"cumulant functional theory code. psi4.core.detci(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the determinant-based configuration interaction code. psi4.core.dfmp2(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the DF-MP2 code. psi4.core.dfocc(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the density-fitted orbital optimized CC codes. psi4.core.displace_atom(arg0: psi::Matrix, arg1: int, arg2: int, arg3: int, arg4: float) → None¶; Displaces one coordinate of single atom. psi4.core.dmrg(arg0: psi::Wavefunction) → float¶; Runs the DMRG code. psi4.core.efp_init() → psi4.core.EFP¶; Initializes the EFP library and returns an EFP object. psi4.core.efp_set_options() → None¶; Set EFP options from environment options object. psi4.core.fcidump_tei_helper(nirrep: int, restricted: bool, DPD_info: Dict[str, int], ints_tolerance: float, fname: str='INTDUMP') → None¶; Write integrals to file in FCIDUMP format. psi4.core.fd_1_0(arg0: psi::Molecule, arg1: list) → psi::Matrix¶; Performs a finite difference gradient computation, from energy points. psi4.core.fd_freq_0(arg0: psi::Molecule, arg1: list, arg2: int) → psi::Matrix¶; Performs a finite difference frequency computation, from energy points, for a given irrep. psi4.core.fd_freq_1(arg0: psi::Molecule, arg1: list, arg2: int) → psi::Matrix¶; Performs a finite difference frequency computation, from gradients, for a given irrep. psi4.core.fd_geoms_1_0(arg0: psi::Molecule) → List[psi::Matrix]¶; Gets list of displacements needed for a finite difference gradient computation, from energy points. psi4.core.fd_geoms_freq_0(arg0: psi::Molecule, arg1: int) → List[psi::Matrix]¶; Gets list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep. psi4.core.fd_geoms_freq_1(arg0: psi::Molecule, arg1: int) → List[psi::Matrix]¶; Gets list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep. psi4.core.finalize() → None¶. psi4.c",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:227122,Energy Efficiency,energy,energy,227122," psi4.core.dfmp2(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the DF-MP2 code. psi4.core.dfocc(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the density-fitted orbital optimized CC codes. psi4.core.displace_atom(arg0: psi::Matrix, arg1: int, arg2: int, arg3: int, arg4: float) → None¶; Displaces one coordinate of single atom. psi4.core.dmrg(arg0: psi::Wavefunction) → float¶; Runs the DMRG code. psi4.core.efp_init() → psi4.core.EFP¶; Initializes the EFP library and returns an EFP object. psi4.core.efp_set_options() → None¶; Set EFP options from environment options object. psi4.core.fcidump_tei_helper(nirrep: int, restricted: bool, DPD_info: Dict[str, int], ints_tolerance: float, fname: str='INTDUMP') → None¶; Write integrals to file in FCIDUMP format. psi4.core.fd_1_0(arg0: psi::Molecule, arg1: list) → psi::Matrix¶; Performs a finite difference gradient computation, from energy points. psi4.core.fd_freq_0(arg0: psi::Molecule, arg1: list, arg2: int) → psi::Matrix¶; Performs a finite difference frequency computation, from energy points, for a given irrep. psi4.core.fd_freq_1(arg0: psi::Molecule, arg1: list, arg2: int) → psi::Matrix¶; Performs a finite difference frequency computation, from gradients, for a given irrep. psi4.core.fd_geoms_1_0(arg0: psi::Molecule) → List[psi::Matrix]¶; Gets list of displacements needed for a finite difference gradient computation, from energy points. psi4.core.fd_geoms_freq_0(arg0: psi::Molecule, arg1: int) → List[psi::Matrix]¶; Gets list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep. psi4.core.fd_geoms_freq_1(arg0: psi::Molecule, arg1: int) → List[psi::Matrix]¶; Gets list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep. psi4.core.finalize() → None¶. psi4.core.flush_outfile() → None¶; Flushes the output file. psi4.core.fnocc(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the fno-ccsd(t)/qcisd(t)/mp4/cep",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:227474,Energy Efficiency,energy,energy,227474,"tom. psi4.core.dmrg(arg0: psi::Wavefunction) → float¶; Runs the DMRG code. psi4.core.efp_init() → psi4.core.EFP¶; Initializes the EFP library and returns an EFP object. psi4.core.efp_set_options() → None¶; Set EFP options from environment options object. psi4.core.fcidump_tei_helper(nirrep: int, restricted: bool, DPD_info: Dict[str, int], ints_tolerance: float, fname: str='INTDUMP') → None¶; Write integrals to file in FCIDUMP format. psi4.core.fd_1_0(arg0: psi::Molecule, arg1: list) → psi::Matrix¶; Performs a finite difference gradient computation, from energy points. psi4.core.fd_freq_0(arg0: psi::Molecule, arg1: list, arg2: int) → psi::Matrix¶; Performs a finite difference frequency computation, from energy points, for a given irrep. psi4.core.fd_freq_1(arg0: psi::Molecule, arg1: list, arg2: int) → psi::Matrix¶; Performs a finite difference frequency computation, from gradients, for a given irrep. psi4.core.fd_geoms_1_0(arg0: psi::Molecule) → List[psi::Matrix]¶; Gets list of displacements needed for a finite difference gradient computation, from energy points. psi4.core.fd_geoms_freq_0(arg0: psi::Molecule, arg1: int) → List[psi::Matrix]¶; Gets list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep. psi4.core.fd_geoms_freq_1(arg0: psi::Molecule, arg1: int) → List[psi::Matrix]¶; Gets list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep. psi4.core.finalize() → None¶. psi4.core.flush_outfile() → None¶; Flushes the output file. psi4.core.fnocc(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the fno-ccsd(t)/qcisd(t)/mp4/cepa energy code. psi4.core.get_active_efp() → psi4.core.EFP¶; Returns the currently active EFP object. psi4.core.get_active_molecule() → psi::Molecule¶; Returns the currently active molecule object. psi4.core.get_array_variable(arg0: str) → psi::Matrix¶; Returns one of the PSI variables set internally by the modules or python driver (se",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:227655,Energy Efficiency,energy,energy,227655,"set_options() → None¶; Set EFP options from environment options object. psi4.core.fcidump_tei_helper(nirrep: int, restricted: bool, DPD_info: Dict[str, int], ints_tolerance: float, fname: str='INTDUMP') → None¶; Write integrals to file in FCIDUMP format. psi4.core.fd_1_0(arg0: psi::Molecule, arg1: list) → psi::Matrix¶; Performs a finite difference gradient computation, from energy points. psi4.core.fd_freq_0(arg0: psi::Molecule, arg1: list, arg2: int) → psi::Matrix¶; Performs a finite difference frequency computation, from energy points, for a given irrep. psi4.core.fd_freq_1(arg0: psi::Molecule, arg1: list, arg2: int) → psi::Matrix¶; Performs a finite difference frequency computation, from gradients, for a given irrep. psi4.core.fd_geoms_1_0(arg0: psi::Molecule) → List[psi::Matrix]¶; Gets list of displacements needed for a finite difference gradient computation, from energy points. psi4.core.fd_geoms_freq_0(arg0: psi::Molecule, arg1: int) → List[psi::Matrix]¶; Gets list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep. psi4.core.fd_geoms_freq_1(arg0: psi::Molecule, arg1: int) → List[psi::Matrix]¶; Gets list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep. psi4.core.finalize() → None¶. psi4.core.flush_outfile() → None¶; Flushes the output file. psi4.core.fnocc(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the fno-ccsd(t)/qcisd(t)/mp4/cepa energy code. psi4.core.get_active_efp() → psi4.core.EFP¶; Returns the currently active EFP object. psi4.core.get_active_molecule() → psi::Molecule¶; Returns the currently active molecule object. psi4.core.get_array_variable(arg0: str) → psi::Matrix¶; Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available). psi4.core.get_array_variables() → Dict[str, psi::Matrix]¶; Returns dictionary of the PSI variables set internally by the modules or ",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:228077,Energy Efficiency,energy,energy,228077," arg2: int) → psi::Matrix¶; Performs a finite difference frequency computation, from energy points, for a given irrep. psi4.core.fd_freq_1(arg0: psi::Molecule, arg1: list, arg2: int) → psi::Matrix¶; Performs a finite difference frequency computation, from gradients, for a given irrep. psi4.core.fd_geoms_1_0(arg0: psi::Molecule) → List[psi::Matrix]¶; Gets list of displacements needed for a finite difference gradient computation, from energy points. psi4.core.fd_geoms_freq_0(arg0: psi::Molecule, arg1: int) → List[psi::Matrix]¶; Gets list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep. psi4.core.fd_geoms_freq_1(arg0: psi::Molecule, arg1: int) → List[psi::Matrix]¶; Gets list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep. psi4.core.finalize() → None¶. psi4.core.flush_outfile() → None¶; Flushes the output file. psi4.core.fnocc(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the fno-ccsd(t)/qcisd(t)/mp4/cepa energy code. psi4.core.get_active_efp() → psi4.core.EFP¶; Returns the currently active EFP object. psi4.core.get_active_molecule() → psi::Molecule¶; Returns the currently active molecule object. psi4.core.get_array_variable(arg0: str) → psi::Matrix¶; Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available). psi4.core.get_array_variables() → Dict[str, psi::Matrix]¶; Returns dictionary of the PSI variables set internally by the modules or python driver. psi4.core.get_atomic_point_charges() → psi::Vector¶; Returns the most recently computed atomic point charges, as a double * object. psi4.core.get_datadir() → str¶; Sets the path to shared text resources, PSIDATADIR. psi4.core.get_efp_torque() → psi::Matrix¶; Returns the most recently computed gradient for the EFP portion, as a Nefp by 6 Matrix object. psi4.core.get_frequencies() → psi::Vector¶; Returns the most recently comp",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:228710,Energy Efficiency,charge,charges,228710,"en irrep. psi4.core.fd_geoms_freq_1(arg0: psi::Molecule, arg1: int) → List[psi::Matrix]¶; Gets list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep. psi4.core.finalize() → None¶. psi4.core.flush_outfile() → None¶; Flushes the output file. psi4.core.fnocc(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the fno-ccsd(t)/qcisd(t)/mp4/cepa energy code. psi4.core.get_active_efp() → psi4.core.EFP¶; Returns the currently active EFP object. psi4.core.get_active_molecule() → psi::Molecule¶; Returns the currently active molecule object. psi4.core.get_array_variable(arg0: str) → psi::Matrix¶; Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available). psi4.core.get_array_variables() → Dict[str, psi::Matrix]¶; Returns dictionary of the PSI variables set internally by the modules or python driver. psi4.core.get_atomic_point_charges() → psi::Vector¶; Returns the most recently computed atomic point charges, as a double * object. psi4.core.get_datadir() → str¶; Sets the path to shared text resources, PSIDATADIR. psi4.core.get_efp_torque() → psi::Matrix¶; Returns the most recently computed gradient for the EFP portion, as a Nefp by 6 Matrix object. psi4.core.get_frequencies() → psi::Vector¶; Returns the most recently computed frequencies, as a 3N-6 Vector object. psi4.core.get_global_option(arg0: str) → object¶; Given a string of a keyword name arg1, returns the value associated with the keyword from the global options. Returns error if keyword is not recognized. psi4.core.get_global_option_list() → List[str]¶; Returns a list of all global options. psi4.core.get_gradient() → psi::Matrix¶; Returns the most recently computed gradient, as a N by 3 Matrix object. psi4.core.get_legacy_molecule() → psi::Molecule¶; Returns the currently active molecule object. psi4.core.get_local_option(arg0: str, arg1: str) → object¶; Given a string of a keyword name arg2 an",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:235469,Energy Efficiency,adapt,adapted,235469,"eopens the output file. psi4.core.revoke_global_option_changed(arg0: str) → None¶; Given a string of a keyword name arg1, sets the has_changed attribute in the global options scope to false. Used in python driver when a function sets the value of an option. Before the function exits, this command is called on the option so that has_changed reflects whether the user (not the program) has touched the option. psi4.core.revoke_local_option_changed(arg0: str, arg1: str) → None¶; Given a string of a keyword name arg2 and a particular module arg1, sets the has_changed attribute in the module options scope to false. Used in python driver when a function sets the value of an option. Before the function exits, this command is called on the option so that has_changed reflects whether the user (not the program) has touched the option. psi4.core.run_gdma(arg0: psi::Wavefunction, arg1: str) → float¶; Runs the GDMA code. psi4.core.sapt(arg0: psi::Wavefunction, arg1: psi::Wavefunction, arg2: psi::Wavefunction) → float¶; Runs the symmetry adapted perturbation theory code. psi4.core.scatter(arg0: psi::Molecule, arg1: float, arg2: list, arg3: list, arg4: list) → None¶; New Scatter function. psi4.core.scfgrad(arg0: psi::Wavefunction) → psi::Matrix¶; Run scfgrad, which is a specialized DF-SCF gradient program. psi4.core.scfhess(arg0: psi::Wavefunction) → psi::Matrix¶; Run scfhess, which is a specialized DF-SCF hessian program. psi4.core.set_active_molecule(arg0: psi::Molecule) → None¶; Activates a previously defined (in the input) molecule, by name. psi4.core.set_array_variable(arg0: str, arg1: psi::Matrix) → None¶; Sets a PSI variable, by name. psi4.core.set_datadir(arg0: str) → None¶; Returns the amount of memory available to Psi (in bytes). psi4.core.set_efp_torque(arg0: psi::Matrix) → None¶; Assigns the global EFP gradient to the values stored in the Nefp by 6 Matrix argument. psi4.core.set_frequencies(arg0: psi::Vector) → None¶; Assigns the global frequencies to the values stored in",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:241495,Energy Efficiency,energy,energy,241495,"rg1, arg2, arg3, arg4, arg5, …); docstring. DTBMV(arg0, arg1, arg2, arg3, arg4, arg5, …); docstring. DTBSV(arg0, arg1, arg2, arg3, arg4, arg5, …); docstring. DTRMM(arg0, arg1, arg2, arg3, arg4, arg5, …); docstring. DTRMV(arg0, arg1, arg2, arg3, arg4, arg5, …); docstring. DTRSM(arg0, arg1, arg2, arg3, arg4, arg5, …); docstring. DTRSV(arg0, arg1, arg2, arg3, arg4, arg5, …); docstring. IDAMAX(arg0, arg1, arg2, arg3); docstring. adc(arg0); Runs the ADC propagator code, for excited states. atomic_displacements(arg0); Returns list of displacements generated by displacing each atom in the +/- x, y, z directions. be_quiet(); Redirects output to /dev/null. benchmark_blas1(arg0, arg1); docstring. benchmark_blas2(arg0, arg1); docstring. benchmark_blas3(arg0, arg1, arg2); docstring. benchmark_disk(arg0, arg1); docstring. benchmark_integrals(arg0, arg1); docstring. benchmark_math(arg0); docstring. ccdensity(arg0); Runs the code to compute coupled cluster density matrices. ccenergy(arg0); Runs the coupled cluster energy code. cceom(arg0); Runs the equation of motion coupled cluster code, for excited states. cchbar(arg0); Runs the code to generate the similarity transformed Hamiltonian. cclambda(arg0); Runs the coupled cluster lambda equations code. ccresponse(arg0); Runs the coupled cluster response theory code. cctransort(arg0); Runs CCTRANSORT, which transforms and reorders integrals for use in the coupled cluster codes. cctriples(arg0); Runs the coupled cluster (T) energy code. clean(); Function to remove scratch files. clean_options(); Function to reset options to clean state. clean_variables(); Empties all PSI variables that have set internally. close_outfile(); Closes the output file. dcft(arg0); Runs the density cumulant functional theory code. detci(arg0); Runs the determinant-based configuration interaction code. dfmp2(arg0); Runs the DF-MP2 code. dfocc(arg0); Runs the density-fitted orbital optimized CC codes. displace_atom(arg0, arg1, arg2, arg3, arg4); Displaces one c",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:241959,Energy Efficiency,energy,energy,241959,"or code, for excited states. atomic_displacements(arg0); Returns list of displacements generated by displacing each atom in the +/- x, y, z directions. be_quiet(); Redirects output to /dev/null. benchmark_blas1(arg0, arg1); docstring. benchmark_blas2(arg0, arg1); docstring. benchmark_blas3(arg0, arg1, arg2); docstring. benchmark_disk(arg0, arg1); docstring. benchmark_integrals(arg0, arg1); docstring. benchmark_math(arg0); docstring. ccdensity(arg0); Runs the code to compute coupled cluster density matrices. ccenergy(arg0); Runs the coupled cluster energy code. cceom(arg0); Runs the equation of motion coupled cluster code, for excited states. cchbar(arg0); Runs the code to generate the similarity transformed Hamiltonian. cclambda(arg0); Runs the coupled cluster lambda equations code. ccresponse(arg0); Runs the coupled cluster response theory code. cctransort(arg0); Runs CCTRANSORT, which transforms and reorders integrals for use in the coupled cluster codes. cctriples(arg0); Runs the coupled cluster (T) energy code. clean(); Function to remove scratch files. clean_options(); Function to reset options to clean state. clean_variables(); Empties all PSI variables that have set internally. close_outfile(); Closes the output file. dcft(arg0); Runs the density cumulant functional theory code. detci(arg0); Runs the determinant-based configuration interaction code. dfmp2(arg0); Runs the DF-MP2 code. dfocc(arg0); Runs the density-fitted orbital optimized CC codes. displace_atom(arg0, arg1, arg2, arg3, arg4); Displaces one coordinate of single atom. dmrg(arg0); Runs the DMRG code. efp_init(); Initializes the EFP library and returns an EFP object. efp_set_options(); Set EFP options from environment options object. fcidump_tei_helper(nirrep, restricted, …); Write integrals to file in FCIDUMP format. fd_1_0(arg0, arg1); Performs a finite difference gradient computation, from energy points. fd_freq_0(arg0, arg1, arg2); Performs a finite difference frequency computation, from energy",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:242835,Energy Efficiency,energy,energy,242835,"ransort(arg0); Runs CCTRANSORT, which transforms and reorders integrals for use in the coupled cluster codes. cctriples(arg0); Runs the coupled cluster (T) energy code. clean(); Function to remove scratch files. clean_options(); Function to reset options to clean state. clean_variables(); Empties all PSI variables that have set internally. close_outfile(); Closes the output file. dcft(arg0); Runs the density cumulant functional theory code. detci(arg0); Runs the determinant-based configuration interaction code. dfmp2(arg0); Runs the DF-MP2 code. dfocc(arg0); Runs the density-fitted orbital optimized CC codes. displace_atom(arg0, arg1, arg2, arg3, arg4); Displaces one coordinate of single atom. dmrg(arg0); Runs the DMRG code. efp_init(); Initializes the EFP library and returns an EFP object. efp_set_options(); Set EFP options from environment options object. fcidump_tei_helper(nirrep, restricted, …); Write integrals to file in FCIDUMP format. fd_1_0(arg0, arg1); Performs a finite difference gradient computation, from energy points. fd_freq_0(arg0, arg1, arg2); Performs a finite difference frequency computation, from energy points, for a given irrep. fd_freq_1(arg0, arg1, arg2); Performs a finite difference frequency computation, from gradients, for a given irrep. fd_geoms_1_0(arg0); Gets list of displacements needed for a finite difference gradient computation, from energy points. fd_geoms_freq_0(arg0, arg1); Gets list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep. fd_geoms_freq_1(arg0, arg1); Gets list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep. finalize(). flush_outfile(); Flushes the output file. fnocc(arg0); Runs the fno-ccsd(t)/qcisd(t)/mp4/cepa energy code. get_active_efp(); Returns the currently active EFP object. get_active_molecule(); Returns the currently active molecule object. get_array_variable(arg0); Returns one of the PSI variable",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:242936,Energy Efficiency,energy,energy,242936,"es. cctriples(arg0); Runs the coupled cluster (T) energy code. clean(); Function to remove scratch files. clean_options(); Function to reset options to clean state. clean_variables(); Empties all PSI variables that have set internally. close_outfile(); Closes the output file. dcft(arg0); Runs the density cumulant functional theory code. detci(arg0); Runs the determinant-based configuration interaction code. dfmp2(arg0); Runs the DF-MP2 code. dfocc(arg0); Runs the density-fitted orbital optimized CC codes. displace_atom(arg0, arg1, arg2, arg3, arg4); Displaces one coordinate of single atom. dmrg(arg0); Runs the DMRG code. efp_init(); Initializes the EFP library and returns an EFP object. efp_set_options(); Set EFP options from environment options object. fcidump_tei_helper(nirrep, restricted, …); Write integrals to file in FCIDUMP format. fd_1_0(arg0, arg1); Performs a finite difference gradient computation, from energy points. fd_freq_0(arg0, arg1, arg2); Performs a finite difference frequency computation, from energy points, for a given irrep. fd_freq_1(arg0, arg1, arg2); Performs a finite difference frequency computation, from gradients, for a given irrep. fd_geoms_1_0(arg0); Gets list of displacements needed for a finite difference gradient computation, from energy points. fd_geoms_freq_0(arg0, arg1); Gets list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep. fd_geoms_freq_1(arg0, arg1); Gets list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep. finalize(). flush_outfile(); Flushes the output file. fnocc(arg0); Runs the fno-ccsd(t)/qcisd(t)/mp4/cepa energy code. get_active_efp(); Returns the currently active EFP object. get_active_molecule(); Returns the currently active molecule object. get_array_variable(arg0); Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available). ge",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:243191,Energy Efficiency,energy,energy,243191,"close_outfile(); Closes the output file. dcft(arg0); Runs the density cumulant functional theory code. detci(arg0); Runs the determinant-based configuration interaction code. dfmp2(arg0); Runs the DF-MP2 code. dfocc(arg0); Runs the density-fitted orbital optimized CC codes. displace_atom(arg0, arg1, arg2, arg3, arg4); Displaces one coordinate of single atom. dmrg(arg0); Runs the DMRG code. efp_init(); Initializes the EFP library and returns an EFP object. efp_set_options(); Set EFP options from environment options object. fcidump_tei_helper(nirrep, restricted, …); Write integrals to file in FCIDUMP format. fd_1_0(arg0, arg1); Performs a finite difference gradient computation, from energy points. fd_freq_0(arg0, arg1, arg2); Performs a finite difference frequency computation, from energy points, for a given irrep. fd_freq_1(arg0, arg1, arg2); Performs a finite difference frequency computation, from gradients, for a given irrep. fd_geoms_1_0(arg0); Gets list of displacements needed for a finite difference gradient computation, from energy points. fd_geoms_freq_0(arg0, arg1); Gets list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep. fd_geoms_freq_1(arg0, arg1); Gets list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep. finalize(). flush_outfile(); Flushes the output file. fnocc(arg0); Runs the fno-ccsd(t)/qcisd(t)/mp4/cepa energy code. get_active_efp(); Returns the currently active EFP object. get_active_molecule(); Returns the currently active molecule object. get_array_variable(arg0); Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available). get_array_variables(); Returns dictionary of the PSI variables set internally by the modules or python driver. get_atomic_point_charges(); Returns the most recently computed atomic point charges, as a double * object. get_datadir(); Sets ",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:243321,Energy Efficiency,energy,energy,243321,"nt-based configuration interaction code. dfmp2(arg0); Runs the DF-MP2 code. dfocc(arg0); Runs the density-fitted orbital optimized CC codes. displace_atom(arg0, arg1, arg2, arg3, arg4); Displaces one coordinate of single atom. dmrg(arg0); Runs the DMRG code. efp_init(); Initializes the EFP library and returns an EFP object. efp_set_options(); Set EFP options from environment options object. fcidump_tei_helper(nirrep, restricted, …); Write integrals to file in FCIDUMP format. fd_1_0(arg0, arg1); Performs a finite difference gradient computation, from energy points. fd_freq_0(arg0, arg1, arg2); Performs a finite difference frequency computation, from energy points, for a given irrep. fd_freq_1(arg0, arg1, arg2); Performs a finite difference frequency computation, from gradients, for a given irrep. fd_geoms_1_0(arg0); Gets list of displacements needed for a finite difference gradient computation, from energy points. fd_geoms_freq_0(arg0, arg1); Gets list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep. fd_geoms_freq_1(arg0, arg1); Gets list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep. finalize(). flush_outfile(); Flushes the output file. fnocc(arg0); Runs the fno-ccsd(t)/qcisd(t)/mp4/cepa energy code. get_active_efp(); Returns the currently active EFP object. get_active_molecule(); Returns the currently active molecule object. get_array_variable(arg0); Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available). get_array_variables(); Returns dictionary of the PSI variables set internally by the modules or python driver. get_atomic_point_charges(); Returns the most recently computed atomic point charges, as a double * object. get_datadir(); Sets the path to shared text resources, PSIDATADIR. get_efp_torque(); Returns the most recently computed gradient for the EFP portion, as a ",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:243606,Energy Efficiency,energy,energy,243606,"urns an EFP object. efp_set_options(); Set EFP options from environment options object. fcidump_tei_helper(nirrep, restricted, …); Write integrals to file in FCIDUMP format. fd_1_0(arg0, arg1); Performs a finite difference gradient computation, from energy points. fd_freq_0(arg0, arg1, arg2); Performs a finite difference frequency computation, from energy points, for a given irrep. fd_freq_1(arg0, arg1, arg2); Performs a finite difference frequency computation, from gradients, for a given irrep. fd_geoms_1_0(arg0); Gets list of displacements needed for a finite difference gradient computation, from energy points. fd_geoms_freq_0(arg0, arg1); Gets list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep. fd_geoms_freq_1(arg0, arg1); Gets list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep. finalize(). flush_outfile(); Flushes the output file. fnocc(arg0); Runs the fno-ccsd(t)/qcisd(t)/mp4/cepa energy code. get_active_efp(); Returns the currently active EFP object. get_active_molecule(); Returns the currently active molecule object. get_array_variable(arg0); Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available). get_array_variables(); Returns dictionary of the PSI variables set internally by the modules or python driver. get_atomic_point_charges(); Returns the most recently computed atomic point charges, as a double * object. get_datadir(); Sets the path to shared text resources, PSIDATADIR. get_efp_torque(); Returns the most recently computed gradient for the EFP portion, as a Nefp by 6 Matrix object. get_frequencies(); Returns the most recently computed frequencies, as a 3N-6 Vector object. get_global_option(arg0); Given a string of a keyword name arg1, returns the value associated with the keyword from the global options. get_global_option_list(); Returns a list of all global",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:244094,Energy Efficiency,charge,charges,244094," a given irrep. fd_geoms_1_0(arg0); Gets list of displacements needed for a finite difference gradient computation, from energy points. fd_geoms_freq_0(arg0, arg1); Gets list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep. fd_geoms_freq_1(arg0, arg1); Gets list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep. finalize(). flush_outfile(); Flushes the output file. fnocc(arg0); Runs the fno-ccsd(t)/qcisd(t)/mp4/cepa energy code. get_active_efp(); Returns the currently active EFP object. get_active_molecule(); Returns the currently active molecule object. get_array_variable(arg0); Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available). get_array_variables(); Returns dictionary of the PSI variables set internally by the modules or python driver. get_atomic_point_charges(); Returns the most recently computed atomic point charges, as a double * object. get_datadir(); Sets the path to shared text resources, PSIDATADIR. get_efp_torque(); Returns the most recently computed gradient for the EFP portion, as a Nefp by 6 Matrix object. get_frequencies(); Returns the most recently computed frequencies, as a 3N-6 Vector object. get_global_option(arg0); Given a string of a keyword name arg1, returns the value associated with the keyword from the global options. get_global_option_list(); Returns a list of all global options. get_gradient(); Returns the most recently computed gradient, as a N by 3 Matrix object. get_legacy_molecule(); Returns the currently active molecule object. get_local_option(arg0, arg1); Given a string of a keyword name arg2 and a particular module arg1, returns the value associated with the keyword in the module options scope. get_memory(); Returns the amount of memory available to Psi (in bytes). get_num_threads(); Returns the number of threads to use in SMP parallel c",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:248320,Energy Efficiency,adapt,adapted,248320," Sets the options module up to return options pertaining to the named argument (e.g. print_global_options(); Prints the currently set global (all modules) options to the output file. print_options(); Prints the currently set options (to the output file) for the current module. print_out(arg0); Prints a string (using sprintf-like notation) to the output file. print_variables(); Prints all PSI variables that have been set internally. psi_top_srcdir(); Returns the location of the source code. psimrcc(arg0); Runs the multireference coupled cluster code. reopen_outfile(); Reopens the output file. revoke_global_option_changed(arg0); Given a string of a keyword name arg1, sets the has_changed attribute in the global options scope to false. revoke_local_option_changed(arg0, arg1); Given a string of a keyword name arg2 and a particular module arg1, sets the has_changed attribute in the module options scope to false. run_gdma(arg0, arg1); Runs the GDMA code. sapt(arg0, arg1, arg2); Runs the symmetry adapted perturbation theory code. scatter(arg0, arg1, arg2, arg3, arg4); New Scatter function. scfgrad(arg0); Run scfgrad, which is a specialized DF-SCF gradient program. scfhess(arg0); Run scfhess, which is a specialized DF-SCF hessian program. set_active_molecule(arg0); Activates a previously defined (in the input) molecule, by name. set_array_variable(arg0, arg1); Sets a PSI variable, by name. set_datadir(arg0); Returns the amount of memory available to Psi (in bytes). set_efp_torque(arg0); Assigns the global EFP gradient to the values stored in the Nefp by 6 Matrix argument. set_frequencies(arg0); Assigns the global frequencies to the values stored in the 3N-6 Vector argument. set_global_option(*args, **kwargs); Overloaded function. set_global_option_python(key, EXTERN); This is a fairly hacky way to get around EXTERN issues. set_gradient(arg0); Assigns the global gradient to the values stored in the N by 3 Matrix argument. set_legacy_molecule(arg0); Activates a previously def",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:250580,Energy Efficiency,adapt,adapted,250580,"object, but scoped only to a single module. set_memory_bytes(memory, quiet); Sets the memory available to Psi (in bytes). set_num_threads(nthread, quiet); Sets the number of threads to use in SMP parallel computations. set_output_file(*args, **kwargs); Overloaded function. set_parent_symmetry(arg0); Sets the symmetry of the ‘parent’ (undisplaced) geometry, by Schoenflies symbol, at the beginning of a finite difference computation. set_psi_file_prefix(arg0). set_variable(arg0, arg1); Sets a PSI variable, by name. tstart(); docstring. tstop(); docstring. version(); Returns the version ID of this copy of Psi. Classes¶. AOShellCombinationsIterator. AngularMomentumInt; Computes angular momentum integrals. BSVec. BasisExtents; docstring. BasisFunctions; docstring. BasisSet; Contains basis set information. BlockOPoints; docstring. BoysLocalizer; Performs Boys orbital localization. CIVector; docstring. CIWavefunction; docstring. CUHF; docstring. CdSalcList; Class for generating symmetry adapted linear combinations of Cartesian displacements. CorrelationFactor; docstring. CorrelationTable; Provides a correlation table between two point groups. CubeProperties; docstring. DFEP2Wavefunction; A density-fitted second-order Electron Propagator Wavefunction. DFHelper; docstring. DFSOMCSCF; docstring. DFTGrid; docstring. DFTensor; docstring. Deriv; Computes gradients of wavefunctions. DiagonalizeOrder; Defines ordering of eigenvalues after diagonalization. Dimension; Initializes and defines Dimension Objects. DipoleInt; Computes dipole integrals. DiskSOMCSCF; docstring. Dispersion; docstring. EFP; Class interfacing with libefp. ERI; Computes normal two electron reuplsion integrals. ElectricFieldInt; Computes electric field integrals. ElectrostaticInt; Computes electrostatic integrals. ErfComplementERI; Computes ERF complement electron repulsion integrals. ErfERI; Computes ERF electron repulsion integrals. ExternalPotential; Stores external potential field, computes external potentia",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:253221,Energy Efficiency,charge,charge,253221,"functions. GaussianType; 0 if Cartesian, 1 if Pure. GeometryUnits; The units used to define the geometry. HF; docstring. IO; docstring. IOManager; PSIOManager is a class designed to be used as a static object to track all PSIO operations in a given PSI4 computation. IntVector; Class handling vectors with integer values. IntegralFactory; Computes integrals. IntegralTransform; IntegralTransform transforms one- and two-electron integrals within general spaces. JK; docstring. KineticInt; Computes kinetic integrals. LaplaceDenominator; docstring. LibXCFunctional; docstring. Localizer; Class containing orbital localization procedures. MOSpace; Defines orbital spaces in which to transform integrals. MOWriter; Writes the MOs. Matrix; Class for creating and manipulating matrices. MatrixFactory; Creates Matrix objects. MintsHelper; Computes integrals. MoldenWriter; Writes wavefunction information in molden format. MolecularGrid; docstring. Molecule; Class to store the elements, coordinates, fragmentation pattern, basis sets, charge, multiplicity, etc. MultipoleInt; Computes arbitrary-order multipole integrals. MultipoleSymmetry; docstring. NBOWriter; The Natural Bond Orbital Writer. NablaInt; Computes nabla integrals. OEProp; docstring. OneBodyAOInt; Basis class for all one-electron integrals. Options; docstring. OrbitalSpace; Contains information about the orbitals. OverlapInt; Computes overlap integrals. PMLocalizer; Performs Pipek-Mezey orbital localization. PetiteList; Handles symmetry transformations. PointFunctions; docstring. PointGroup; Contains information about the point group. PotentialInt; Computes potential integrals. PrimitiveType; May be Normalized or Unnormalized. Prop; docstring. PseudospectralInt; Computes pseudospectral integrals. PsiReturnType; docstring. QuadrupoleInt; Computes quadrupole integrals. RHF; docstring. RKSFunctions; docstring. ROHF; docstring. SADGuess; docstring. SOBasisSet; An SOBasis object describes the transformation from an atomic orbit",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:257664,Energy Efficiency,energy,energy,257664,"f(cls, arg1, arg2, …):. …. It can be called either on the class (e.g. C.f()) or on an instance; (e.g. C().f()). The instance is ignored except for its class.; If a class method is called for a derived class, the derived class; object is passed as the implied first argument.; Class methods are different than C++ or Java static methods.; If you want those, see the staticmethod builtin. Functions¶. activate(mol); Function to set molecule object mol as the current active molecule. ancestor(dir[, n]); Get the nth ancestor of a directory. banner(text[, type, width, strNotOutfile]); Function to print text to output file in a banner of minimum width width and minimum three-line height for type = 1 or one-line height for type = 2. basis_helper(block[, name, key, set_option]); For PsiAPI mode, forms a basis specification function from block and associates it with keyword key under handle name. cbs(func, label, **kwargs); Function to define a multistage energy method from combinations of basis set extrapolations and delta corrections and condense the components into a minimum number of calculations. check_iwl_file_from_scf_type(scf_type, wfn); Ensures that a IWL file has been written based on input SCF type. compare_arrays(expected, computed, digits, label); Function to compare two numpy arrays. compare_csx(); Function to validate energies in CSX files against PSIvariables. compare_cubes(expected, computed, label); Function to compare two cube files. compare_fcidumps(expected, computed, label); Function to compare two FCIDUMP files. compare_integers(expected, computed, label); Function to compare two integers. compare_matrices(expected, computed, digits, …); Function to compare two matrices. compare_strings(expected, computed, label); Function to compare two strings. compare_values(expected, computed, digits, label); Function to compare two values. compare_vectors(expected, computed, digits, …); Function to compare two vectors. copy_file_from_scratch(filename, prefix, …); Funct",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:259334,Energy Efficiency,energy,energy,259334,"gits, …); Function to compare two matrices. compare_strings(expected, computed, label); Function to compare two strings. compare_values(expected, computed, digits, label); Function to compare two values. compare_vectors(expected, computed, digits, …); Function to compare two vectors. copy_file_from_scratch(filename, prefix, …); Function to move file out of scratch with correct naming convention. copy_file_to_scratch(filename, prefix, …); Function to move file into scratch with correct naming convention. create_plugin(name, template); Generate plugin in directory with sanitized name based upon template. csx2endict(); Grabs the CSX file as a dictionary, encodes translation of PSI variables to XML blocks, gathers all available energies from CSX file into returned dictionary. cubeprop(wfn, **kwargs); Evaluate properties on a grid and generate cube files. dynamic_variable_bind(cls); Function to dynamically add extra members to the core.Molecule class. energy(name, **kwargs); Function to compute the single-point electronic energy. fchk(wfn, filename); Function to write wavefunction information in wfn to filename in Gaussian FCHK format. fcidump(wfn[, fname, oe_ints]); Save integrals to file in FCIDUMP format as defined in Comp. fcidump_from_file(fname); Function to read in a FCIDUMP file. filter_comments(string); Remove from string any Python-style comments (‘#’ to end of line). find_approximate_string_matches(seq1, …); Function to compute approximate string matches from a list of options. freq(name, **kwargs); Function to compute harmonic vibrational frequencies. frequencies(name, **kwargs); Function to compute harmonic vibrational frequencies. frequency(name, **kwargs); Function to compute harmonic vibrational frequencies. gdma(wfn[, datafile]); Function to use wavefunction information in wfn and, if specified, additional commands in filename to run GDMA analysis. geometry(geom[, name]); Function to create a molecule object of name name from the geometry in string geom.",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:259406,Energy Efficiency,energy,energy,259406,"gits, …); Function to compare two matrices. compare_strings(expected, computed, label); Function to compare two strings. compare_values(expected, computed, digits, label); Function to compare two values. compare_vectors(expected, computed, digits, …); Function to compare two vectors. copy_file_from_scratch(filename, prefix, …); Function to move file out of scratch with correct naming convention. copy_file_to_scratch(filename, prefix, …); Function to move file into scratch with correct naming convention. create_plugin(name, template); Generate plugin in directory with sanitized name based upon template. csx2endict(); Grabs the CSX file as a dictionary, encodes translation of PSI variables to XML blocks, gathers all available energies from CSX file into returned dictionary. cubeprop(wfn, **kwargs); Evaluate properties on a grid and generate cube files. dynamic_variable_bind(cls); Function to dynamically add extra members to the core.Molecule class. energy(name, **kwargs); Function to compute the single-point electronic energy. fchk(wfn, filename); Function to write wavefunction information in wfn to filename in Gaussian FCHK format. fcidump(wfn[, fname, oe_ints]); Save integrals to file in FCIDUMP format as defined in Comp. fcidump_from_file(fname); Function to read in a FCIDUMP file. filter_comments(string); Remove from string any Python-style comments (‘#’ to end of line). find_approximate_string_matches(seq1, …); Function to compute approximate string matches from a list of options. freq(name, **kwargs); Function to compute harmonic vibrational frequencies. frequencies(name, **kwargs); Function to compute harmonic vibrational frequencies. frequency(name, **kwargs); Function to compute harmonic vibrational frequencies. gdma(wfn[, datafile]); Function to use wavefunction information in wfn and, if specified, additional commands in filename to run GDMA analysis. geometry(geom[, name]); Function to create a molecule object of name name from the geometry in string geom.",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:5480,Integrability,depend,depending,5480,"object. move_atom(self: psi4.core.BasisSet, arg0: int, arg1: psi4.core.Vector3) → None¶; Translate a given atom by a given amount. Does not affect the underlying molecule object. n_ecp_core(*args, **kwargs)¶; Overloaded function. n_ecp_core(self: psi4.core.BasisSet) -> int. Returns the total number of core electrons associated with all ECPs in this basis. n_ecp_core(self: psi4.core.BasisSet, arg0: str) -> int. Returns the number of core electrons associated with any ECP on the specified atom type for this basis set. n_frozen_core(self: psi4.core.BasisSet, arg0: str, arg1: psi4.core.Molecule) → int¶; Returns the number of orbital (non-ECP) frozen core electrons. For a given molecule and FREEZE_CORE, (n_ecp_core()/2 + n_frozen_core()) = constant. name(self: psi4.core.BasisSet) → str¶; Callback handle, may represent string or function. nao(self: psi4.core.BasisSet) → int¶; Returns number of atomic orbitals (Cartesian). nbf(self: psi4.core.BasisSet) → int¶; Returns number of basis functions (Cartesian or spherical depending on has_puream). nprimitive(self: psi4.core.BasisSet) → int¶; Returns total number of primitives in all contractions. nshell(self: psi4.core.BasisSet) → int¶; Returns number of shells. nshell_on_center(self: psi4.core.BasisSet, i: int) → int¶; Return the number of shells on a given center. print_detail_out(self: psi4.core.BasisSet) → None¶; Prints detailed basis set info to outfile. print_out(self: psi4.core.BasisSet) → None¶; Prints basis set info to outfile. shell(*args, **kwargs)¶; Overloaded function. shell(self: psi4.core.BasisSet, si: int) -> psi4.core.GaussianShell. Return the si’th Gaussian shell. shell(self: psi4.core.BasisSet, center: int, si: int) -> psi4.core.GaussianShell. Return the si’th Gaussian shell on center. shell_to_ao_function(self: psi4.core.BasisSet, i: int) → int¶; Return the function number for the first function for the i’th shell. shell_to_basis_function(self: psi4.core.BasisSet, i: int) → int¶; Given a shell return its firs",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:5593,Integrability,contract,contractions,5593,"a given amount. Does not affect the underlying molecule object. n_ecp_core(*args, **kwargs)¶; Overloaded function. n_ecp_core(self: psi4.core.BasisSet) -> int. Returns the total number of core electrons associated with all ECPs in this basis. n_ecp_core(self: psi4.core.BasisSet, arg0: str) -> int. Returns the number of core electrons associated with any ECP on the specified atom type for this basis set. n_frozen_core(self: psi4.core.BasisSet, arg0: str, arg1: psi4.core.Molecule) → int¶; Returns the number of orbital (non-ECP) frozen core electrons. For a given molecule and FREEZE_CORE, (n_ecp_core()/2 + n_frozen_core()) = constant. name(self: psi4.core.BasisSet) → str¶; Callback handle, may represent string or function. nao(self: psi4.core.BasisSet) → int¶; Returns number of atomic orbitals (Cartesian). nbf(self: psi4.core.BasisSet) → int¶; Returns number of basis functions (Cartesian or spherical depending on has_puream). nprimitive(self: psi4.core.BasisSet) → int¶; Returns total number of primitives in all contractions. nshell(self: psi4.core.BasisSet) → int¶; Returns number of shells. nshell_on_center(self: psi4.core.BasisSet, i: int) → int¶; Return the number of shells on a given center. print_detail_out(self: psi4.core.BasisSet) → None¶; Prints detailed basis set info to outfile. print_out(self: psi4.core.BasisSet) → None¶; Prints basis set info to outfile. shell(*args, **kwargs)¶; Overloaded function. shell(self: psi4.core.BasisSet, si: int) -> psi4.core.GaussianShell. Return the si’th Gaussian shell. shell(self: psi4.core.BasisSet, center: int, si: int) -> psi4.core.GaussianShell. Return the si’th Gaussian shell on center. shell_to_ao_function(self: psi4.core.BasisSet, i: int) → int¶; Return the function number for the first function for the i’th shell. shell_to_basis_function(self: psi4.core.BasisSet, i: int) → int¶; Given a shell return its first basis function. shell_to_center(self: psi4.core.BasisSet, i: int) → int¶; Return the atomic center for the i’th s",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:6725,Integrability,contract,contraction,6725,"¶; Return the number of shells on a given center. print_detail_out(self: psi4.core.BasisSet) → None¶; Prints detailed basis set info to outfile. print_out(self: psi4.core.BasisSet) → None¶; Prints basis set info to outfile. shell(*args, **kwargs)¶; Overloaded function. shell(self: psi4.core.BasisSet, si: int) -> psi4.core.GaussianShell. Return the si’th Gaussian shell. shell(self: psi4.core.BasisSet, center: int, si: int) -> psi4.core.GaussianShell. Return the si’th Gaussian shell on center. shell_to_ao_function(self: psi4.core.BasisSet, i: int) → int¶; Return the function number for the first function for the i’th shell. shell_to_basis_function(self: psi4.core.BasisSet, i: int) → int¶; Given a shell return its first basis function. shell_to_center(self: psi4.core.BasisSet, i: int) → int¶; Return the atomic center for the i’th shell. zero_ao_basis_set() → psi4.core.BasisSet¶; Returns a BasisSet object that actually has a single s-function at the origin with an exponent of 0.0 and contraction of 1.0. class psi4.core.BlockOPoints¶; Bases: pybind11_builtins.pybind11_object; docstring. functions_local_to_global(self: psi4.core.BlockOPoints) → List[int]¶; docstring. npoints(self: psi4.core.BlockOPoints) → int¶; docstring. print_out(self: psi4.core.BlockOPoints, out_fname: str='outfile', print: int=2) → None¶; docstring. refresh(self: psi4.core.BlockOPoints) → None¶; docstring. shells_local_to_global(self: psi4.core.BlockOPoints) → List[int]¶; docstring. w(self: psi4.core.BlockOPoints) → psi4.core.Vector¶. x(self: psi4.core.BlockOPoints) → psi4.core.Vector¶. y(self: psi4.core.BlockOPoints) → psi4.core.Vector¶. z(self: psi4.core.BlockOPoints) → psi4.core.Vector¶. class psi4.core.BoysLocalizer¶; Bases: psi4.core.Localizer; Performs Boys orbital localization. L¶; Localized orbital coefficients. U¶; Orbital rotation matrix. build(arg0: str, arg1: psi4.core.BasisSet, arg2: psi4.core.Matrix) → psi4.core.Localizer¶; Build the localization scheme. converged¶; Did the localization ",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:67651,Integrability,contract,contraction,67651,"onal, arg0: int) → None¶; docstring. print_out(self: psi4.core.Functional) → None¶; docstring. set_alpha(self: psi4.core.Functional, arg0: float) → None¶; docstring. set_citation(self: psi4.core.Functional, arg0: str) → None¶; docstring. set_description(self: psi4.core.Functional, arg0: str) → None¶; docstring. set_gga(self: psi4.core.Functional, arg0: bool) → None¶; docstring. set_lsda_cutoff(self: psi4.core.Functional, arg0: float) → None¶; docstring. set_meta(self: psi4.core.Functional, arg0: bool) → None¶; docstring. set_meta_cutoff(self: psi4.core.Functional, arg0: float) → None¶; docstring. set_name(self: psi4.core.Functional, arg0: str) → None¶; docstring. set_omega(self: psi4.core.Functional, arg0: float) → None¶; docstring. set_parameter(self: psi4.core.Functional, arg0: str, arg1: float) → None¶; docstring. class psi4.core.GaussianShell¶; Bases: pybind11_builtins.pybind11_object; Class containing information about basis functions. AMCHAR¶; The upper-case character symbol for the angular momentum of the given contraction. am¶; The angular momentum of the given contraction. amchar¶; The character symbol for the angular momentum of the given contraction. coef(self: psi4.core.GaussianShell, pi: int) → float¶; Return coefficient of the pi’th primitive. erd_coef(self: psi4.core.GaussianShell, pi: int) → float¶; Return ERD normalized coefficient of pi’th primitive. exp(self: psi4.core.GaussianShell, prim: int) → float¶; Returns the exponent of the given primitive. function_index¶; Basis function index where this shell starts. is_cartesian(self: psi4.core.GaussianShell) → bool¶; Returns true if the contraction is Cartesian. is_pure(self: psi4.core.GaussianShell) → bool¶; Returns true if the contraction is pure, i.e. a spherical harmonic basis function. ncartesian¶; Total number of basis functions if this shell was Cartesian. ncenter¶; Returns atom number this shell is on. nfunction¶; Total number of basis functions. nprimitive¶; The number of primitive gaussians. ",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:67703,Integrability,contract,contraction,67703,"l) → None¶; docstring. set_alpha(self: psi4.core.Functional, arg0: float) → None¶; docstring. set_citation(self: psi4.core.Functional, arg0: str) → None¶; docstring. set_description(self: psi4.core.Functional, arg0: str) → None¶; docstring. set_gga(self: psi4.core.Functional, arg0: bool) → None¶; docstring. set_lsda_cutoff(self: psi4.core.Functional, arg0: float) → None¶; docstring. set_meta(self: psi4.core.Functional, arg0: bool) → None¶; docstring. set_meta_cutoff(self: psi4.core.Functional, arg0: float) → None¶; docstring. set_name(self: psi4.core.Functional, arg0: str) → None¶; docstring. set_omega(self: psi4.core.Functional, arg0: float) → None¶; docstring. set_parameter(self: psi4.core.Functional, arg0: str, arg1: float) → None¶; docstring. class psi4.core.GaussianShell¶; Bases: pybind11_builtins.pybind11_object; Class containing information about basis functions. AMCHAR¶; The upper-case character symbol for the angular momentum of the given contraction. am¶; The angular momentum of the given contraction. amchar¶; The character symbol for the angular momentum of the given contraction. coef(self: psi4.core.GaussianShell, pi: int) → float¶; Return coefficient of the pi’th primitive. erd_coef(self: psi4.core.GaussianShell, pi: int) → float¶; Return ERD normalized coefficient of pi’th primitive. exp(self: psi4.core.GaussianShell, prim: int) → float¶; Returns the exponent of the given primitive. function_index¶; Basis function index where this shell starts. is_cartesian(self: psi4.core.GaussianShell) → bool¶; Returns true if the contraction is Cartesian. is_pure(self: psi4.core.GaussianShell) → bool¶; Returns true if the contraction is pure, i.e. a spherical harmonic basis function. ncartesian¶; Total number of basis functions if this shell was Cartesian. ncenter¶; Returns atom number this shell is on. nfunction¶; Total number of basis functions. nprimitive¶; The number of primitive gaussians. original_coef(self: psi4.core.GaussianShell, pi: int) → float¶; Return u",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:67784,Integrability,contract,contraction,67784," float) → None¶; docstring. set_citation(self: psi4.core.Functional, arg0: str) → None¶; docstring. set_description(self: psi4.core.Functional, arg0: str) → None¶; docstring. set_gga(self: psi4.core.Functional, arg0: bool) → None¶; docstring. set_lsda_cutoff(self: psi4.core.Functional, arg0: float) → None¶; docstring. set_meta(self: psi4.core.Functional, arg0: bool) → None¶; docstring. set_meta_cutoff(self: psi4.core.Functional, arg0: float) → None¶; docstring. set_name(self: psi4.core.Functional, arg0: str) → None¶; docstring. set_omega(self: psi4.core.Functional, arg0: float) → None¶; docstring. set_parameter(self: psi4.core.Functional, arg0: str, arg1: float) → None¶; docstring. class psi4.core.GaussianShell¶; Bases: pybind11_builtins.pybind11_object; Class containing information about basis functions. AMCHAR¶; The upper-case character symbol for the angular momentum of the given contraction. am¶; The angular momentum of the given contraction. amchar¶; The character symbol for the angular momentum of the given contraction. coef(self: psi4.core.GaussianShell, pi: int) → float¶; Return coefficient of the pi’th primitive. erd_coef(self: psi4.core.GaussianShell, pi: int) → float¶; Return ERD normalized coefficient of pi’th primitive. exp(self: psi4.core.GaussianShell, prim: int) → float¶; Returns the exponent of the given primitive. function_index¶; Basis function index where this shell starts. is_cartesian(self: psi4.core.GaussianShell) → bool¶; Returns true if the contraction is Cartesian. is_pure(self: psi4.core.GaussianShell) → bool¶; Returns true if the contraction is pure, i.e. a spherical harmonic basis function. ncartesian¶; Total number of basis functions if this shell was Cartesian. ncenter¶; Returns atom number this shell is on. nfunction¶; Total number of basis functions. nprimitive¶; The number of primitive gaussians. original_coef(self: psi4.core.GaussianShell, pi: int) → float¶; Return unnormalized coefficient of the pi’th primitive. class psi4.core.Gau",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:68245,Integrability,contract,contraction,68245," psi4.core.Functional, arg0: str) → None¶; docstring. set_omega(self: psi4.core.Functional, arg0: float) → None¶; docstring. set_parameter(self: psi4.core.Functional, arg0: str, arg1: float) → None¶; docstring. class psi4.core.GaussianShell¶; Bases: pybind11_builtins.pybind11_object; Class containing information about basis functions. AMCHAR¶; The upper-case character symbol for the angular momentum of the given contraction. am¶; The angular momentum of the given contraction. amchar¶; The character symbol for the angular momentum of the given contraction. coef(self: psi4.core.GaussianShell, pi: int) → float¶; Return coefficient of the pi’th primitive. erd_coef(self: psi4.core.GaussianShell, pi: int) → float¶; Return ERD normalized coefficient of pi’th primitive. exp(self: psi4.core.GaussianShell, prim: int) → float¶; Returns the exponent of the given primitive. function_index¶; Basis function index where this shell starts. is_cartesian(self: psi4.core.GaussianShell) → bool¶; Returns true if the contraction is Cartesian. is_pure(self: psi4.core.GaussianShell) → bool¶; Returns true if the contraction is pure, i.e. a spherical harmonic basis function. ncartesian¶; Total number of basis functions if this shell was Cartesian. ncenter¶; Returns atom number this shell is on. nfunction¶; Total number of basis functions. nprimitive¶; The number of primitive gaussians. original_coef(self: psi4.core.GaussianShell, pi: int) → float¶; Return unnormalized coefficient of the pi’th primitive. class psi4.core.GaussianType¶; Bases: pybind11_builtins.pybind11_object; 0 if Cartesian, 1 if Pure. Cartesian = GaussianType.Cartesian¶. Pure = GaussianType.Pure¶. class psi4.core.GeometryUnits¶; Bases: pybind11_builtins.pybind11_object; The units used to define the geometry. Angstrom = GeometryUnits.Angstrom¶. Bohr = GeometryUnits.Bohr¶. class psi4.core.HF¶; Bases: psi4.core.Wavefunction; docstring. Ca(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Alpha Orbitals. Ca_subset(sel",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:68339,Integrability,contract,contraction,68339,"rg0: float) → None¶; docstring. set_parameter(self: psi4.core.Functional, arg0: str, arg1: float) → None¶; docstring. class psi4.core.GaussianShell¶; Bases: pybind11_builtins.pybind11_object; Class containing information about basis functions. AMCHAR¶; The upper-case character symbol for the angular momentum of the given contraction. am¶; The angular momentum of the given contraction. amchar¶; The character symbol for the angular momentum of the given contraction. coef(self: psi4.core.GaussianShell, pi: int) → float¶; Return coefficient of the pi’th primitive. erd_coef(self: psi4.core.GaussianShell, pi: int) → float¶; Return ERD normalized coefficient of pi’th primitive. exp(self: psi4.core.GaussianShell, prim: int) → float¶; Returns the exponent of the given primitive. function_index¶; Basis function index where this shell starts. is_cartesian(self: psi4.core.GaussianShell) → bool¶; Returns true if the contraction is Cartesian. is_pure(self: psi4.core.GaussianShell) → bool¶; Returns true if the contraction is pure, i.e. a spherical harmonic basis function. ncartesian¶; Total number of basis functions if this shell was Cartesian. ncenter¶; Returns atom number this shell is on. nfunction¶; Total number of basis functions. nprimitive¶; The number of primitive gaussians. original_coef(self: psi4.core.GaussianShell, pi: int) → float¶; Return unnormalized coefficient of the pi’th primitive. class psi4.core.GaussianType¶; Bases: pybind11_builtins.pybind11_object; 0 if Cartesian, 1 if Pure. Cartesian = GaussianType.Cartesian¶. Pure = GaussianType.Pure¶. class psi4.core.GeometryUnits¶; Bases: pybind11_builtins.pybind11_object; The units used to define the geometry. Angstrom = GeometryUnits.Angstrom¶. Bohr = GeometryUnits.Bohr¶. class psi4.core.HF¶; Bases: psi4.core.Wavefunction; docstring. Ca(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Alpha Orbitals. Ca_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Matrix¶; Returns the requested A",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:82983,Integrability,protocol,protocol,82983,"e table of contents for the given unit. tocwrite(self: psi4.core.IO, arg0: int) → None¶; Write the table of contents for passed file number. class psi4.core.IOManager¶; Bases: pybind11_builtins.pybind11_object; PSIOManager is a class designed to be used as a static object to track all PSIO operations in a given PSI4 computation. crashclean(self: psi4.core.IOManager) → None¶; Clean from disk-mirrored image after crash. NOT to be called during regular computation. get_default_path(self: psi4.core.IOManager) → str¶; Return the default path. get_file_path(self: psi4.core.IOManager, fileno: int) → str¶; Get the path for a specific file number. mark_file_for_retention(self: psi4.core.IOManager, full_path: str, retain: bool) → None¶; Mark a file to be retained after a psiclean operation, ie for use in a later computation. print_out(self: psi4.core.IOManager) → None¶; Print the current status of PSI4 files. psiclean(self: psi4.core.IOManager) → None¶; Execute the psiclean protocol, deleting all recorded files, except those currently marked for retention. set_default_path(self: psi4.core.IOManager, path: str) → None¶; Set the default path for files to be stored. set_specific_path(self: psi4.core.IOManager, fileno: int, path: str) → None¶; Set the path for specific file numbers. set_specific_retention(self: psi4.core.IOManager, fileno: int, retain: bool) → None¶; Set the specific file number to be retained. shared_object() → psi4.core.IOManager¶; The one and (should be) only instance of PSIOManager for a PSI4 instance. write_scratch_file(self: psi4.core.IOManager, full_path: str, text: str) → None¶; Write a string to a temporary file. The scratch file is opened and closed by this function. class psi4.core.IntVector¶; Bases: pybind11_builtins.pybind11_object; Class handling vectors with integer values. dim(self: psi4.core.IntVector, h: int) → int¶; Returns the number of dimensions per irrep h. get(self: psi4.core.IntVector, h: int, m: int) → int¶; Returns a single element valu",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:109644,Integrability,depend,depending,109644,"pe¶; Shape of the Psi4 data object. subtract(self: psi4.core.Matrix, arg0: psi4.core.Matrix) → None¶; Substract a matrix from this matrix. sum_of_squares(self: psi4.core.Matrix) → float¶; Returns the sum of the squares of this matrix. symmetrize_gradient(self: psi4.core.Matrix, mol: psi::Molecule) → None¶; Symmetrizes a gradient-like matrix (N,3) using information from a given molecule. symmetry(self: psi4.core.Matrix) → int¶; Returns the overall symmetry of the matrix. to_array(copy=True, dense=False)¶; Converts a Psi4 Matrix or Vector to a numpy array. Either copies the data or simply; constructs a view. Parameters:; matrix (Matrix or Vector) – Pointers to which Psi4 core class should be used in the construction.; copy (bool, optional) – Copy the data if True, return a view otherwise; dense (bool, optional) – Converts irreped Psi4 objects to diagonally blocked dense arrays if True. Returns a list of arrays otherwise. Returns:array – Returns either a list of np.array’s or the base array depending on options. Return type:ndarray or list of ndarray. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; 1; 2; 3; 4; 5>>> data = psi4.Matrix(3, 3); >>> data.to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. to_serial()¶; Converts an object with a .nph accessor to a serialized dictionary. trace(self: psi4.core.Matrix) → float¶; Returns the trace of the matrix. transform(*args, **kwargs)¶; Overloaded function. transform(self: psi4.core.Matrix, transformer: psi4.core.Matrix) -> None. Transform this matrix with transformer. transform(self: psi4.core.Matrix, a: psi4.core.Matrix, transformer: psi4.core.Matrix) -> None. Transform A with transformer. transpose(self: psi4.core.Matrix) → psi4.core.Matrix¶; Creates a new matrix that is the transpose of this matrix. transpose_this(self: psi4.core.Matrix) → None¶; Transpose the matrix in-place. triplet(A: psi4.core.Matrix, B: psi4.core.Matrix, C: psi4.core.Matrix, transA: bool=False, transB: bool",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:131987,Integrability,wrap,wrapper,131987,"n override this with the symmetry keyword. fix_com(self: psi4.core.Molecule, arg0: bool) → None¶; Whether to fix the Cartesian position, or to translate to the C.O.M. fix_orientation(self: psi4.core.Molecule, arg0: bool) → None¶; Fix the orientation at its current frame. form_symmetry_information(self: psi4.core.Molecule, arg0: float) → None¶; Uses the point group object obtain by calling point_group(). classmethod from_arrays(geom=None, elea=None, elez=None, elem=None, mass=None, real=None, elbl=None, name=None, units='Angstrom', input_units_to_au=None, fix_com=None, fix_orientation=None, fix_symmetry=None, fragment_separators=None, fragment_charges=None, fragment_multiplicities=None, molecular_charge=None, molecular_multiplicity=None, missing_enabled_return='error', tooclose=0.1, zero_ghost_fragments=False, nonphysical=False, mtol=0.001, verbose=1, return_dict=False)¶; Construct Molecule from unvalidated arrays and variables.; Light wrapper around from_arrays(); that is a full-featured constructor to dictionary representa-; tion of Molecule. This follows one step further to return; Molecule instance.; :param See from_arrays().:. Returns:. Return type:psi4.core.Molecule. from_dict(arg0: dict) → psi4.core.Molecule¶; Returns a new Molecule constructed from python dictionary. In progress: name and capabilities should not be relied upon. classmethod from_schema(molschema, return_dict=False, verbose=1)¶; Construct Molecule from non-Psi4 schema.; Light wrapper around from_arrays(). Parameters:; molschema (dict) – Dictionary form of Molecule following known schema.; return_dict (bool, optional) – Additionally return Molecule dictionary intermediate.; verbose (int, optional) – Amount of printing. Returns:; mol (psi4.core.Molecule); molrec (dict, optional) – Dictionary representation of instance.; Only provided if return_dict is True. classmethod from_string(molstr, dtype=None, name=None, fix_com=None, fix_orientation=None, fix_symmetry=None, return_dict=False, enable_qm=Tr",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:132510,Integrability,wrap,wrapper,132510,"ne, real=None, elbl=None, name=None, units='Angstrom', input_units_to_au=None, fix_com=None, fix_orientation=None, fix_symmetry=None, fragment_separators=None, fragment_charges=None, fragment_multiplicities=None, molecular_charge=None, molecular_multiplicity=None, missing_enabled_return='error', tooclose=0.1, zero_ghost_fragments=False, nonphysical=False, mtol=0.001, verbose=1, return_dict=False)¶; Construct Molecule from unvalidated arrays and variables.; Light wrapper around from_arrays(); that is a full-featured constructor to dictionary representa-; tion of Molecule. This follows one step further to return; Molecule instance.; :param See from_arrays().:. Returns:. Return type:psi4.core.Molecule. from_dict(arg0: dict) → psi4.core.Molecule¶; Returns a new Molecule constructed from python dictionary. In progress: name and capabilities should not be relied upon. classmethod from_schema(molschema, return_dict=False, verbose=1)¶; Construct Molecule from non-Psi4 schema.; Light wrapper around from_arrays(). Parameters:; molschema (dict) – Dictionary form of Molecule following known schema.; return_dict (bool, optional) – Additionally return Molecule dictionary intermediate.; verbose (int, optional) – Amount of printing. Returns:; mol (psi4.core.Molecule); molrec (dict, optional) – Dictionary representation of instance.; Only provided if return_dict is True. classmethod from_string(molstr, dtype=None, name=None, fix_com=None, fix_orientation=None, fix_symmetry=None, return_dict=False, enable_qm=True, enable_efp=True, missing_enabled_return_qm='none', missing_enabled_return_efp='none', verbose=1)¶. fx(self: psi4.core.Molecule, arg0: int) → float¶; x position of atom arg1 (0-indexed including dummies in Bohr). fy(self: psi4.core.Molecule, arg0: int) → float¶; y position of atom arg1 (0-indexed including dummies in Bohr). fz(self: psi4.core.Molecule, arg0: int) → float¶; z position of atom arg1 (0-indexed including dummies in Bohr). geometry(self: psi4.core.Molecule) → psi4",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:141638,Integrability,interface,interface,141638,"; * output goes to output file; * gradient returned as psi4.core.Matrix, not list o’lists; * scratch is written to randomly named subdirectory of psi scratch; * psivar “DISPERSION CORRECTION ENERGY” is set; * verbose triggered when PRINT keywork of SCF module >=3. run_gcp(func=None, dertype=None, verbose=False)¶; Function to call Grimme’s dftd3 program (http://toc.uni-muenster.de/DFTD3/); to compute the -D correction of level dashlvl using parameters for; the functional func. The dictionary dashparam can be used to supply; a full set of dispersion parameters in the absense of func or to supply; individual overrides in the presence of func. Returns energy if dertype is 0,; gradient if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The dftd3 executable must be independently compiled and found in; PATH or PSIPATH.; self may be either a qcdb.Molecule (sensibly) or a psi4.Molecule; (works b/c psi4.Molecule has been extended by this method py-side and; only public interface fns used) or a string that can be instantiated; into a qcdb.Molecule. save_string_xyz(self: psi4.core.Molecule) → str¶; Saves the string of an XYZ file to arg2. save_string_xyz_file(self: psi4.core.Molecule) → str¶; Saves an XYZ file to arg2. save_xyz_file(self: psi4.core.Molecule, arg0: str, arg1: bool) → None¶; Saves an XYZ file to arg2. schoenflies_symbol(self: psi4.core.Molecule) → str¶; Returns the Schoenflies symbol. scramble(do_shift=True, do_rotate=True, do_resort=True, deflection=1.0, do_mirror=False, do_plot=False, run_to_completion=False, run_resorting=False, verbose=1)¶; Tester for B787 by shifting, rotating, and atom shuffling ref_mol and; checking that the aligner returns the opposite transformation. Parameters:; ref_mol (qcdb.Molecule or psi4.core.Molecule) – Molecule to perturb.; do_shift (bool or array-like, optional) – Whether to generate a random atom shift on interval [-3, 3) in each; dimension (True) or leave at current origin. To shift by a specified; vect",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:153530,Integrability,depend,dependencies,153530,"arg1: str, arg2: str) → None¶; set string option. set_str_i(self: psi4.core.Options, arg0: str, arg1: str, arg2: str) → None¶; set string option. validate_options(self: psi4.core.Options) → None¶; validate options for arg0 module. class psi4.core.OrbitalSpace¶; Bases: pybind11_builtins.pybind11_object; Contains information about the orbitals. C(self: psi4.core.OrbitalSpace) → psi4.core.Matrix¶; MO coefficient matrix, AO->MO or SO->MO transformation matrix. basisset(self: psi4.core.OrbitalSpace) → psi::BasisSet¶; The AO basis set used to create C. build_cabs_space(orb_space: psi4.core.OrbitalSpace, ri_space: psi4.core.OrbitalSpace, linear_tol: float) → psi4.core.OrbitalSpace¶; Given two spaces, it projects out one space from the other and returns the new spaces The first argument (orb_space) is the space to project out. The returned space will be orthogonal to this The second argument (ri_space) is the space that is being projected on. The returned space = this space - orb_space The third argument is the tolerance for linear dependencies. build_ri_space(molecule: psi::Molecule, obs_key: str, aux_key: str, lindep_tol: float) → psi4.core.OrbitalSpace¶; Given two basis sets, it merges the basis sets and then constructs an orthogonalized space with the same span. Linearly dependent orbitals are thrown out. The first argument, molecule, is the molecule to construct the basis for The second argument, obs_key, is the option keyword for orbital basis set ‘BASIS’ The third argument, aux_key, is the option keyword for auxiliery basis set ‘DF_BASIS_MP2’ The fourth argument, lindep_tol, is the tolerance for linear dependencies. dim(self: psi4.core.OrbitalSpace) → psi4.core.Dimension¶; MO dimensions. evals(self: psi4.core.OrbitalSpace) → psi4.core.Vector¶; Corresponding eigenvalues of the C matrix. id(self: psi4.core.OrbitalSpace) → str¶; Unique identifier. integral(self: psi4.core.OrbitalSpace) → psi4.core.IntegralFactory¶; The integral factory used to create C. name(self: psi4.c",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:153778,Integrability,depend,dependent,153778,"ct; Contains information about the orbitals. C(self: psi4.core.OrbitalSpace) → psi4.core.Matrix¶; MO coefficient matrix, AO->MO or SO->MO transformation matrix. basisset(self: psi4.core.OrbitalSpace) → psi::BasisSet¶; The AO basis set used to create C. build_cabs_space(orb_space: psi4.core.OrbitalSpace, ri_space: psi4.core.OrbitalSpace, linear_tol: float) → psi4.core.OrbitalSpace¶; Given two spaces, it projects out one space from the other and returns the new spaces The first argument (orb_space) is the space to project out. The returned space will be orthogonal to this The second argument (ri_space) is the space that is being projected on. The returned space = this space - orb_space The third argument is the tolerance for linear dependencies. build_ri_space(molecule: psi::Molecule, obs_key: str, aux_key: str, lindep_tol: float) → psi4.core.OrbitalSpace¶; Given two basis sets, it merges the basis sets and then constructs an orthogonalized space with the same span. Linearly dependent orbitals are thrown out. The first argument, molecule, is the molecule to construct the basis for The second argument, obs_key, is the option keyword for orbital basis set ‘BASIS’ The third argument, aux_key, is the option keyword for auxiliery basis set ‘DF_BASIS_MP2’ The fourth argument, lindep_tol, is the tolerance for linear dependencies. dim(self: psi4.core.OrbitalSpace) → psi4.core.Dimension¶; MO dimensions. evals(self: psi4.core.OrbitalSpace) → psi4.core.Vector¶; Corresponding eigenvalues of the C matrix. id(self: psi4.core.OrbitalSpace) → str¶; Unique identifier. integral(self: psi4.core.OrbitalSpace) → psi4.core.IntegralFactory¶; The integral factory used to create C. name(self: psi4.core.OrbitalSpace) → str¶; Name of the orbital space. nirrep(self: psi4.core.OrbitalSpace) → int¶; Returns number of irreps. print_out(self: psi4.core.OrbitalSpace) → None¶; Print information about the orbital space to the output file. class psi4.core.OverlapInt¶; Bases: psi4.core.OneBodyAOInt; Comp",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:154119,Integrability,depend,dependencies,154119,"ore.OrbitalSpace) → psi::BasisSet¶; The AO basis set used to create C. build_cabs_space(orb_space: psi4.core.OrbitalSpace, ri_space: psi4.core.OrbitalSpace, linear_tol: float) → psi4.core.OrbitalSpace¶; Given two spaces, it projects out one space from the other and returns the new spaces The first argument (orb_space) is the space to project out. The returned space will be orthogonal to this The second argument (ri_space) is the space that is being projected on. The returned space = this space - orb_space The third argument is the tolerance for linear dependencies. build_ri_space(molecule: psi::Molecule, obs_key: str, aux_key: str, lindep_tol: float) → psi4.core.OrbitalSpace¶; Given two basis sets, it merges the basis sets and then constructs an orthogonalized space with the same span. Linearly dependent orbitals are thrown out. The first argument, molecule, is the molecule to construct the basis for The second argument, obs_key, is the option keyword for orbital basis set ‘BASIS’ The third argument, aux_key, is the option keyword for auxiliery basis set ‘DF_BASIS_MP2’ The fourth argument, lindep_tol, is the tolerance for linear dependencies. dim(self: psi4.core.OrbitalSpace) → psi4.core.Dimension¶; MO dimensions. evals(self: psi4.core.OrbitalSpace) → psi4.core.Vector¶; Corresponding eigenvalues of the C matrix. id(self: psi4.core.OrbitalSpace) → str¶; Unique identifier. integral(self: psi4.core.OrbitalSpace) → psi4.core.IntegralFactory¶; The integral factory used to create C. name(self: psi4.core.OrbitalSpace) → str¶; Name of the orbital space. nirrep(self: psi4.core.OrbitalSpace) → int¶; Returns number of irreps. print_out(self: psi4.core.OrbitalSpace) → None¶; Print information about the orbital space to the output file. class psi4.core.OverlapInt¶; Bases: psi4.core.OneBodyAOInt; Computes overlap integrals. basis¶; The basis set on center one. basis1¶; The basis set on center one. basis2¶; The basis set on center two. compute_shell(self: psi4.core.OneBodyAOInt, a",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:213291,Integrability,depend,depending,213291,"or, sc: float) → None¶; Scales the elements of a vector by sc. set(*args, **kwargs)¶; Overloaded function. set(self: psi4.core.Vector, m: int, val: float) -> None. Sets a single element value located at m. set(self: psi4.core.Vector, h: int, m: int, val: float) -> None. Sets a single element value located at m in irrep h. set_block(self: psi4.core.Vector, slice: psi4.core.Slice, block: psi4.core.Vector) → None¶; Set a vector block. shape¶; Shape of the Psi4 data object. to_array(copy=True, dense=False)¶; Converts a Psi4 Matrix or Vector to a numpy array. Either copies the data or simply; constructs a view. Parameters:; matrix (Matrix or Vector) – Pointers to which Psi4 core class should be used in the construction.; copy (bool, optional) – Copy the data if True, return a view otherwise; dense (bool, optional) – Converts irreped Psi4 objects to diagonally blocked dense arrays if True. Returns a list of arrays otherwise. Returns:array – Returns either a list of np.array’s or the base array depending on options. Return type:ndarray or list of ndarray. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; 1; 2; 3; 4; 5>>> data = psi4.Matrix(3, 3); >>> data.to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. to_serial()¶; Converts an object with a .nph accessor to a serialized dictionary. class psi4.core.Vector3¶; Bases: pybind11_builtins.pybind11_object; Class for vectors of length three, often Cartesian coordinate vectors, and their common operations. cross(self: psi4.core.Vector3, arg0: psi4.core.Vector3) → psi4.core.Vector3¶; Returns cross product of arg1 and arg2. distance(self: psi4.core.Vector3, arg0: psi4.core.Vector3) → float¶; Returns distance between two points represented by arg1 and arg2. dot(self: psi4.core.Vector3, arg0: psi4.core.Vector3) → float¶; Returns dot product of arg1 and arg2. norm(self: psi4.core.Vector3) → float¶; Returns Euclidean norm of arg1. normalize(self: psi4.core.Vector3) → None¶; Returns vector of u",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:263669,Integrability,depend,dependencies,263669,"et the total memory allocation. set_module_options(module, options_dict); Sets Psi4 module options from a module specification and input dictionary. set_options(options_dict); Sets Psi4 global options from an input dictionary. success(label); Function to print a ‘label…PASSED’ line to screen. vibanal_wfn(wfn[, hess, irrep, molecule, …]). write_eigenvalues(eigs, mo_idx); Prepare multi-line string with one-particle eigenvalues to be written to the FCIDUMP file. xml2dict([filename]); Read XML filename into nested OrderedDict-s. Classes¶. CSXError(msg); Error called when CSX generation fails. ConvergenceError(eqn_description, maxit); Error called for problems with converging and iterative method. Dftd3Error(msg). EmpericalDispersion(alias, dtype, **kwargs). ManagedMethodError(circs). OptimizationConvergenceError(…); Error called for problems with geometry optimizer. ParsingError(msg); Error called for problems parsing a text file. PastureRequiredError(option); Error called when the specified value of option requires some module(s) from Psi4Pasture, but could not be imported. PsiException; Error class for Psi. PsiImportError(msg); Error called for problems import python dependencies. QMMM(). Table([rows, row_label_width, …]); Class defining a flexible Table object for storing data. TestComparisonError(msg); Error called when a test case fails due to a failed compare_values() call. ValidationError(msg); Error called for problems with the input file. datetime(year, month, day[, hour[, minute[, …); The year, month and day arguments are required. Class Inheritance Diagram¶. table of contents. PSI4 API: Linking C++ and Python; psi4.core Module; Functions; Classes; Class Inheritance Diagram. psi4.driver Package; Functions; Classes; Class Inheritance Diagram. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:1357,Modifiability,extend,extend,1357,"ng. is_done(self: psi4.core.AOShellCombinationsIterator) → bool¶; docstring. next(self: psi4.core.AOShellCombinationsIterator) → None¶; docstring. p¶; Returns current P index. q¶; Returns current Q index. r¶; Returns current R index. s¶; Returns current S index. class psi4.core.AngularMomentumInt¶; Bases: psi4.core.OneBodyAOInt; Computes angular momentum integrals. basis¶; The basis set on center one. basis1¶; The basis set on center one. basis2¶; The basis set on center two. compute_shell(self: psi4.core.OneBodyAOInt, arg0: int, arg1: int) → None¶; Compute integrals between basis functions in the given shell pair. origin¶; The origin about which the one body ints are being computed. class psi4.core.BSVec¶; Bases: pybind11_builtins.pybind11_object. append(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo) → None¶; Add an item to the end of the list. count(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo) → int¶; Return the number of times x appears in the list. extend(self: List[psi4.core.ShellInfo], L: List[psi4.core.ShellInfo]) → None¶; Extend the list by appending all the items in the given list. insert(self: List[psi4.core.ShellInfo], i: int, x: psi4.core.ShellInfo) → None¶; Insert an item at a given position. pop(*args, **kwargs)¶; Overloaded function. pop(self: List[psi4.core.ShellInfo]) -> psi4.core.ShellInfo. Remove and return the last item. pop(self: List[psi4.core.ShellInfo], i: int) -> psi4.core.ShellInfo. Remove and return the item at index i. remove(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo) → None¶; Remove the first item from the list whose value is x. It is an error if there is no such item. class psi4.core.BasisExtents¶; Bases: pybind11_builtins.pybind11_object; docstring. basis(self: psi4.core.BasisExtents) → psi4.core.BasisSet¶; docstring. delta(self: psi4.core.BasisExtents) → float¶; docstring. maxR(self: psi4.core.BasisExtents) → float¶; docstring. set_delta(self: psi4.core.BasisExtents, arg0: float) → None¶; docstring.",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:15568,Modifiability,variab,variable,15568,"ore.Dimension¶; Returns the number of frozen virtual orbitals per irrep. get_array(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Sets the requested internal array. get_basisset(self: psi4.core.Wavefunction, arg0: str) → psi4.core.BasisSet¶; Returns the requested auxiliary basis. get_dimension(self: psi4.core.CIWavefunction, arg0: str) → psi4.core.Dimension¶; docstring. get_dipole_field_strength(self: psi4.core.Wavefunction) → List[float[3]]¶; Returns a vector of length 3, containing the x,y, and z dipole field strengths. get_opdm(self: psi4.core.CIWavefunction, arg0: int, arg1: int, arg2: str, arg3: bool) → psi4.core.Matrix¶; docstring. get_orbitals(self: psi4.core.CIWavefunction, arg0: str) → psi4.core.Matrix¶; docstring. get_print(self: psi4.core.Wavefunction) → int¶; Get the print level of the Wavefunction. get_tpdm(self: psi4.core.CIWavefunction, arg0: str, arg1: bool) → psi4.core.Matrix¶; docstring. get_variable(self: psi4.core.Wavefunction, arg0: str) → float¶; Returns the requested internal variable. gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunctions gradient. hamiltonian(self: psi4.core.CIWavefunction, arg0: int) → psi4.core.Matrix¶; docstring. hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunctions Hessian. mcscf_object(self: psi4.core.CIWavefunction) → psi4.core.SOMCSCF¶; docstring. mo_extents(self: psi4.core.Wavefunction) → List[psi4.core.Vector]¶; returns the wavefunction’s electronic orbital extents. molecule(self: psi4.core.Wavefunction) → psi4.core.Molecule¶; Returns the Wavefunctions molecule. nalpha(self: psi4.core.Wavefunction) → int¶; Number of Alpha electrons. nalphapi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of alpha orbitals per irrep. name(self: psi4.core.Wavefunction) → str¶; The level of theory this wavefunction corresponds to. nbeta(self: psi4.core.Wavefunction) → int¶; Number of Beta electrons. nbetapi(self: psi4.core.Wavefunction",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:19837,Modifiability,variab,variable,19837,"n, arg0: str) → None¶; docstring. set_external_potential(self: psi4.core.Wavefunction, arg0: psi4.core.ExternalPotential) → None¶; Sets the requested external potential. set_frequencies(self: psi4.core.Wavefunction, arg0: psi4.core.Vector) → None¶; Sets the frequencies of the Hessian. set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunctions gradient. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunctions Hessian. set_name(self: psi4.core.Wavefunction, arg0: str) → None¶; Sets the level of theory this wavefunction corresponds to. set_orbitals(self: psi4.core.CIWavefunction, arg0: str, arg1: psi4.core.Matrix) → None¶; docstring. set_print(self: psi4.core.Wavefunction, arg0: int) → None¶; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; docstring. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sigma(*args, **kwargs)¶; Overloaded function. sigma(self: psi4.core.CIWavefunction, arg0: psi::detci::CIvect, arg1: psi::detci::CIvect, arg2: int, arg3: int) -> None. docstring. sigma(self: psi4.core.CIWavefunction, arg0: psi::detci::CIvect, arg1: psi::detci::CIvect, arg2: int, arg3: int, arg4: psi4.core.Vector, arg5: psi4.core.Vector) -> None. docstring. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. tpdm(self: psi4.core.CIWavefunction, arg0: psi::detci::CIvect, arg1: psi::detci::CIvect, arg2: int, arg3: int) → List[psi4.core.Matrix]¶; docstring. transform_ci_integrals(self: psi4.core.CIWavefunction) → None¶; docstring. transform_mcscf_integrals(sel",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:20865,Modifiability,variab,variables,20865,".Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sigma(*args, **kwargs)¶; Overloaded function. sigma(self: psi4.core.CIWavefunction, arg0: psi::detci::CIvect, arg1: psi::detci::CIvect, arg2: int, arg3: int) -> None. docstring. sigma(self: psi4.core.CIWavefunction, arg0: psi::detci::CIvect, arg1: psi::detci::CIvect, arg2: int, arg3: int, arg4: psi4.core.Vector, arg5: psi4.core.Vector) -> None. docstring. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. tpdm(self: psi4.core.CIWavefunction, arg0: psi::detci::CIvect, arg1: psi::detci::CIvect, arg2: int, arg3: int) → List[psi4.core.Matrix]¶; docstring. transform_ci_integrals(self: psi4.core.CIWavefunction) → None¶; docstring. transform_mcscf_integrals(self: psi4.core.CIWavefunction, arg0: bool) → None¶; docstring. variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the map of all internal variables. class psi4.core.CUHF¶; Bases: psi4.core.HF; docstring. Ca(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Alpha Orbitals. Ca_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Matrix¶; Returns the requested Alpha Orbital subset. Cb(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Beta Orbitals. Cb_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Matrix¶; Returns the requested Beta Orbital subset. Da(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Alpha Density Matrix. Da_subset(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Returns the requested Alpha Density subset. Db(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Beta Density Matrix. Db_subset(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Returns the requested Beta Density subset. Fa(self: psi4.core.Wavefuncti",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:20958,Modifiability,variab,variables,20958,"Copies the pointers to the internal data. sigma(*args, **kwargs)¶; Overloaded function. sigma(self: psi4.core.CIWavefunction, arg0: psi::detci::CIvect, arg1: psi::detci::CIvect, arg2: int, arg3: int) -> None. docstring. sigma(self: psi4.core.CIWavefunction, arg0: psi::detci::CIvect, arg1: psi::detci::CIvect, arg2: int, arg3: int, arg4: psi4.core.Vector, arg5: psi4.core.Vector) -> None. docstring. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. tpdm(self: psi4.core.CIWavefunction, arg0: psi::detci::CIvect, arg1: psi::detci::CIvect, arg2: int, arg3: int) → List[psi4.core.Matrix]¶; docstring. transform_ci_integrals(self: psi4.core.CIWavefunction) → None¶; docstring. transform_mcscf_integrals(self: psi4.core.CIWavefunction, arg0: bool) → None¶; docstring. variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the map of all internal variables. class psi4.core.CUHF¶; Bases: psi4.core.HF; docstring. Ca(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Alpha Orbitals. Ca_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Matrix¶; Returns the requested Alpha Orbital subset. Cb(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Beta Orbitals. Cb_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Matrix¶; Returns the requested Beta Orbital subset. Da(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Alpha Density Matrix. Da_subset(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Returns the requested Alpha Density subset. Db(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Beta Density Matrix. Db_subset(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Returns the requested Beta Density subset. Fa(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Alpha Fock Matrix.",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:27299,Modifiability,variab,variable,27299,"e current Density Matrices. frequencies(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the frequencies of the Hessian. frzcpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of frozen core orbitals per irrep. frzvpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of frozen virtual orbitals per irrep. functional(self: psi4.core.HF) → psi4.core.SuperFunctional¶; Returns the internal DFT Superfunctional. get_array(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Sets the requested internal array. get_basisset(self: psi4.core.Wavefunction, arg0: str) → psi4.core.BasisSet¶; Returns the requested auxiliary basis. get_dipole_field_strength(self: psi4.core.Wavefunction) → List[float[3]]¶; Returns a vector of length 3, containing the x,y, and z dipole field strengths. get_print(self: psi4.core.Wavefunction) → int¶; Get the print level of the Wavefunction. get_variable(self: psi4.core.Wavefunction, arg0: str) → float¶; Returns the requested internal variable. gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunctions gradient. guess_Ca(self: psi4.core.HF, arg0: psi4.core.Matrix) → None¶; Sets the guess Alpha Orbital Matrix. guess_Cb(self: psi4.core.HF, arg0: psi4.core.Matrix) → None¶; Sets the guess Beta Orbital Matrix. hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunctions Hessian. initialize(self: psi4.core.HF) → None¶; Initializes the Wavefunction. iterations(self: psi4.core.HF) → None¶; Iterates the Wavefunction until convergence criteria have been met. jk(self: psi4.core.HF) → psi4.core.JK¶; Returns the internal JK object. mo_extents(self: psi4.core.Wavefunction) → List[psi4.core.Vector]¶; returns the wavefunction’s electronic orbital extents. molecule(self: psi4.core.Wavefunction) → psi4.core.Molecule¶; Returns the Wavefunctions molecule. nalpha(self: psi4.core.Wavefunction) → int¶; Number of Alpha electrons. nalphapi(self: psi4.core.Wavefun",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:31679,Modifiability,variab,variable,31679,"sian. set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunctions gradient. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunctions Hessian. set_jk(self: psi4.core.HF, arg0: psi4.core.JK) → None¶; Sets the internal JK object !expert. set_name(self: psi4.core.Wavefunction, arg0: str) → None¶; Sets the level of theory this wavefunction corresponds to. set_print(self: psi4.core.Wavefunction, arg0: int) → None¶; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; docstring. set_sad_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities density-fitted basisset. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. twoel_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix], arg1: bool, arg2: str) → List[psi4.core.Matrix]¶; Two-electron Hessian-vector products. variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the map of all internal variables. class psi4.core.CdSalcList¶; Bases: pybind11_builtins.pybind11_object; Class for generating symmetry adapted linear combinations of Cartesian displacements. create_matrices(self: psi4.core.CdSalcList, basename: str, factory: psi4.core.MatrixFactory) → List[psi4.core.Matrix]¶; Return a vector of matrices with the SALC symmetries. Dimensions determined by fact",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:32182,Modifiability,variab,variables,32182,"ce_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; docstring. set_sad_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities density-fitted basisset. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. twoel_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix], arg1: bool, arg2: str) → List[psi4.core.Matrix]¶; Two-electron Hessian-vector products. variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the map of all internal variables. class psi4.core.CdSalcList¶; Bases: pybind11_builtins.pybind11_object; Class for generating symmetry adapted linear combinations of Cartesian displacements. create_matrices(self: psi4.core.CdSalcList, basename: str, factory: psi4.core.MatrixFactory) → List[psi4.core.Matrix]¶; Return a vector of matrices with the SALC symmetries. Dimensions determined by factory. matrix(self: psi4.core.CdSalcList) → psi4.core.Matrix¶; Return the SALCs. matrix_irrep(self: psi4.core.CdSalcList, h: int) → psi4.core.Matrix¶; Return only the SALCS in irrep h. ncd(self: psi4.core.CdSalcList) → int¶; Return the number of cartesian displacements SALCs. print_out(self: psi4.core.CdSalcList) → None¶; Print the SALC to the output file. salc_name(self: psi4.core.CdSalcList, i: int) → str¶; Return the name of SALC #i. class psi4.core.CorrelationFactor¶; Bases: pybind11_builtins.pybind11_object; docstring. set_params(self: p",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:32275,Modifiability,variab,variables,32275,"i4.core.Wavefunction) → None¶; docstring. set_sad_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities density-fitted basisset. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. twoel_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix], arg1: bool, arg2: str) → List[psi4.core.Matrix]¶; Two-electron Hessian-vector products. variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the map of all internal variables. class psi4.core.CdSalcList¶; Bases: pybind11_builtins.pybind11_object; Class for generating symmetry adapted linear combinations of Cartesian displacements. create_matrices(self: psi4.core.CdSalcList, basename: str, factory: psi4.core.MatrixFactory) → List[psi4.core.Matrix]¶; Return a vector of matrices with the SALC symmetries. Dimensions determined by factory. matrix(self: psi4.core.CdSalcList) → psi4.core.Matrix¶; Return the SALCs. matrix_irrep(self: psi4.core.CdSalcList, h: int) → psi4.core.Matrix¶; Return only the SALCS in irrep h. ncd(self: psi4.core.CdSalcList) → int¶; Return the number of cartesian displacements SALCs. print_out(self: psi4.core.CdSalcList) → None¶; Print the SALC to the output file. salc_name(self: psi4.core.CdSalcList, i: int) → str¶; Return the name of SALC #i. class psi4.core.CorrelationFactor¶; Bases: pybind11_builtins.pybind11_object; docstring. set_params(self: psi4.core.CorrelationFactor, coeff: psi4.core.Vector, ex",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:32387,Modifiability,adapt,adapted,32387,"f Atomic Densities basisset. set_sad_fitting_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities density-fitted basisset. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. twoel_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix], arg1: bool, arg2: str) → List[psi4.core.Matrix]¶; Two-electron Hessian-vector products. variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the map of all internal variables. class psi4.core.CdSalcList¶; Bases: pybind11_builtins.pybind11_object; Class for generating symmetry adapted linear combinations of Cartesian displacements. create_matrices(self: psi4.core.CdSalcList, basename: str, factory: psi4.core.MatrixFactory) → List[psi4.core.Matrix]¶; Return a vector of matrices with the SALC symmetries. Dimensions determined by factory. matrix(self: psi4.core.CdSalcList) → psi4.core.Matrix¶; Return the SALCs. matrix_irrep(self: psi4.core.CdSalcList, h: int) → psi4.core.Matrix¶; Return only the SALCS in irrep h. ncd(self: psi4.core.CdSalcList) → int¶; Return the number of cartesian displacements SALCs. print_out(self: psi4.core.CdSalcList) → None¶; Print the SALC to the output file. salc_name(self: psi4.core.CdSalcList, i: int) → str¶; Return the name of SALC #i. class psi4.core.CorrelationFactor¶; Bases: pybind11_builtins.pybind11_object; docstring. set_params(self: psi4.core.CorrelationFactor, coeff: psi4.core.Vector, exponent: psi4.core.Vector) → None¶; Set coefficient and exponent. class psi4.core.CorrelationTable¶; Bases: pybind11_builtins.pybind11_object; Pr",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:40284,Modifiability,variab,variable,40284,"of singly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. frequencies(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the frequencies of the Hessian. frzcpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of frozen core orbitals per irrep. frzvpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of frozen virtual orbitals per irrep. get_array(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Sets the requested internal array. get_basisset(self: psi4.core.Wavefunction, arg0: str) → psi4.core.BasisSet¶; Returns the requested auxiliary basis. get_dipole_field_strength(self: psi4.core.Wavefunction) → List[float[3]]¶; Returns a vector of length 3, containing the x,y, and z dipole field strengths. get_print(self: psi4.core.Wavefunction) → int¶; Get the print level of the Wavefunction. get_variable(self: psi4.core.Wavefunction, arg0: str) → float¶; Returns the requested internal variable. gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunctions gradient. hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunctions Hessian. mo_extents(self: psi4.core.Wavefunction) → List[psi4.core.Vector]¶; returns the wavefunction’s electronic orbital extents. molecule(self: psi4.core.Wavefunction) → psi4.core.Molecule¶; Returns the Wavefunctions molecule. nalpha(self: psi4.core.Wavefunction) → int¶; Number of Alpha electrons. nalphapi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of alpha orbitals per irrep. name(self: psi4.core.Wavefunction) → str¶; The level of theory this wavefunction corresponds to. nbeta(self: psi4.core.Wavefunction) → int¶; Number of Beta electrons. nbetapi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of beta orbitals per irrep. nfrzc(self: psi4.core.Wavefunction) → int¶; Number of frozen core electrons. nirrep(self: ps",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:43313,Modifiability,variab,variable,43313,"l array. set_basisset(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.BasisSet) → None¶; Sets the requested auxiliary basis. set_external_potential(self: psi4.core.Wavefunction, arg0: psi4.core.ExternalPotential) → None¶; Sets the requested external potential. set_frequencies(self: psi4.core.Wavefunction, arg0: psi4.core.Vector) → None¶; Sets the frequencies of the Hessian. set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunctions gradient. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunctions Hessian. set_name(self: psi4.core.Wavefunction, arg0: str) → None¶; Sets the level of theory this wavefunction corresponds to. set_print(self: psi4.core.Wavefunction, arg0: int) → None¶; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; docstring. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the map of all internal variables. class psi4.core.DFHelper¶; Bases: pybind11_builtins.pybind11_object; docstring. add_space(self: psi4.core.DFHelper, arg0: str, arg1: psi4.core.Matrix) → None¶. add_transformation(self: psi4.core.DFHelper, name: str, key1: str, key2: str, order: str='Qpq') → None¶. clear_all(self: psi4.core.DFHelper) → None¶. clear_spaces(self: psi4.core.DFHelper) → None¶. get_AO_core(self: psi4.core.DFHelper) → bool¶. get_AO_size(self: psi4.core.DFHelper) → int¶. get_MO_core(self: psi4.core.DFHelper) → bool¶. get_memor",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:43669,Modifiability,variab,variables,43669,"self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunctions gradient. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunctions Hessian. set_name(self: psi4.core.Wavefunction, arg0: str) → None¶; Sets the level of theory this wavefunction corresponds to. set_print(self: psi4.core.Wavefunction, arg0: int) → None¶; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; docstring. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the map of all internal variables. class psi4.core.DFHelper¶; Bases: pybind11_builtins.pybind11_object; docstring. add_space(self: psi4.core.DFHelper, arg0: str, arg1: psi4.core.Matrix) → None¶. add_transformation(self: psi4.core.DFHelper, name: str, key1: str, key2: str, order: str='Qpq') → None¶. clear_all(self: psi4.core.DFHelper) → None¶. clear_spaces(self: psi4.core.DFHelper) → None¶. get_AO_core(self: psi4.core.DFHelper) → bool¶. get_AO_size(self: psi4.core.DFHelper) → int¶. get_MO_core(self: psi4.core.DFHelper) → bool¶. get_memory(self: psi4.core.DFHelper) → int¶. get_method(self: psi4.core.DFHelper) → str¶. get_schwarz_cutoff(self: psi4.core.DFHelper) → float¶. get_space_size(self: psi4.core.DFHelper, arg0: str) → int¶. get_tensor(*args, **kwargs)¶; Overloaded function. get_tensor(self: psi4.core.DFHelper, arg0: str) -> psi4.core.Matrix; get_tensor(self: psi4.core.DFHelper, arg0: str, arg1: List[int], arg2: List[int], a",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:43762,Modifiability,variab,variables,43762,"→ None¶; Sets the Wavefunctions gradient. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunctions Hessian. set_name(self: psi4.core.Wavefunction, arg0: str) → None¶; Sets the level of theory this wavefunction corresponds to. set_print(self: psi4.core.Wavefunction, arg0: int) → None¶; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; docstring. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the map of all internal variables. class psi4.core.DFHelper¶; Bases: pybind11_builtins.pybind11_object; docstring. add_space(self: psi4.core.DFHelper, arg0: str, arg1: psi4.core.Matrix) → None¶. add_transformation(self: psi4.core.DFHelper, name: str, key1: str, key2: str, order: str='Qpq') → None¶. clear_all(self: psi4.core.DFHelper) → None¶. clear_spaces(self: psi4.core.DFHelper) → None¶. get_AO_core(self: psi4.core.DFHelper) → bool¶. get_AO_size(self: psi4.core.DFHelper) → int¶. get_MO_core(self: psi4.core.DFHelper) → bool¶. get_memory(self: psi4.core.DFHelper) → int¶. get_method(self: psi4.core.DFHelper) → str¶. get_schwarz_cutoff(self: psi4.core.DFHelper) → float¶. get_space_size(self: psi4.core.DFHelper, arg0: str) → int¶. get_tensor(*args, **kwargs)¶; Overloaded function. get_tensor(self: psi4.core.DFHelper, arg0: str) -> psi4.core.Matrix; get_tensor(self: psi4.core.DFHelper, arg0: str, arg1: List[int], arg2: List[int], arg3: List[int]) -> psi4.core.Matrix. get_tensor_shape(s",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:75433,Modifiability,variab,variable,75433,"e current Density Matrices. frequencies(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the frequencies of the Hessian. frzcpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of frozen core orbitals per irrep. frzvpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of frozen virtual orbitals per irrep. functional(self: psi4.core.HF) → psi4.core.SuperFunctional¶; Returns the internal DFT Superfunctional. get_array(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Sets the requested internal array. get_basisset(self: psi4.core.Wavefunction, arg0: str) → psi4.core.BasisSet¶; Returns the requested auxiliary basis. get_dipole_field_strength(self: psi4.core.Wavefunction) → List[float[3]]¶; Returns a vector of length 3, containing the x,y, and z dipole field strengths. get_print(self: psi4.core.Wavefunction) → int¶; Get the print level of the Wavefunction. get_variable(self: psi4.core.Wavefunction, arg0: str) → float¶; Returns the requested internal variable. gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunctions gradient. guess_Ca(self: psi4.core.HF, arg0: psi4.core.Matrix) → None¶; Sets the guess Alpha Orbital Matrix. guess_Cb(self: psi4.core.HF, arg0: psi4.core.Matrix) → None¶; Sets the guess Beta Orbital Matrix. hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunctions Hessian. initialize(self: psi4.core.HF) → None¶; Initializes the Wavefunction. iterations(self: psi4.core.HF) → None¶; Iterates the Wavefunction until convergence criteria have been met. jk(self: psi4.core.HF) → psi4.core.JK¶; Returns the internal JK object. mo_extents(self: psi4.core.Wavefunction) → List[psi4.core.Vector]¶; returns the wavefunction’s electronic orbital extents. molecule(self: psi4.core.Wavefunction) → psi4.core.Molecule¶; Returns the Wavefunctions molecule. nalpha(self: psi4.core.Wavefunction) → int¶; Number of Alpha electrons. nalphapi(self: psi4.core.Wavefun",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:79813,Modifiability,variab,variable,79813,"sian. set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunctions gradient. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunctions Hessian. set_jk(self: psi4.core.HF, arg0: psi4.core.JK) → None¶; Sets the internal JK object !expert. set_name(self: psi4.core.Wavefunction, arg0: str) → None¶; Sets the level of theory this wavefunction corresponds to. set_print(self: psi4.core.Wavefunction, arg0: int) → None¶; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; docstring. set_sad_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities density-fitted basisset. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. twoel_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix], arg1: bool, arg2: str) → List[psi4.core.Matrix]¶; Two-electron Hessian-vector products. variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the map of all internal variables. psi4.core.IDAMAX(arg0: int, arg1: int, arg2: psi::Vector, arg3: int) → int¶; docstring. class psi4.core.IO¶; Bases: pybind11_builtins.pybind11_object; docstring. change_file_namespace(fileno: int, ns1: str, ns2: str) → None¶; Change file number from ns1 to ns2. close(self: psi4.core.IO, unit: int, keep: int) → None¶; Close unit. If keep == 0, will remove the",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:80316,Modifiability,variab,variables,80316,"ce_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; docstring. set_sad_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities density-fitted basisset. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. twoel_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix], arg1: bool, arg2: str) → List[psi4.core.Matrix]¶; Two-electron Hessian-vector products. variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the map of all internal variables. psi4.core.IDAMAX(arg0: int, arg1: int, arg2: psi::Vector, arg3: int) → int¶; docstring. class psi4.core.IO¶; Bases: pybind11_builtins.pybind11_object; docstring. change_file_namespace(fileno: int, ns1: str, ns2: str) → None¶; Change file number from ns1 to ns2. close(self: psi4.core.IO, unit: int, keep: int) → None¶; Close unit. If keep == 0, will remove the file, else keep it. get_default_namespace() → str¶; Get the default namespace (for PREFIX.NAMESPACE.UNIT file numbering). getpid(self: psi4.core.IO) → str¶; Lookup process id. open(self: psi4.core.IO, unit: int, status: int) → None¶; Open unit. Status can be PSIO_OPEN_OLD (if existing file is to be opened) or PSIO_OPEN_NEW if new file should be open. open_check(self: psi4.core.IO, unit: int) → int¶; Return 1 if unit is open. rehash(self: psi4.core.IO, unit: int) → None¶; Sync up the object to the file on disk by closing and opening the fil",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:80409,Modifiability,variab,variables,80409,"i4.core.Wavefunction) → None¶; docstring. set_sad_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities density-fitted basisset. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. twoel_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix], arg1: bool, arg2: str) → List[psi4.core.Matrix]¶; Two-electron Hessian-vector products. variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the map of all internal variables. psi4.core.IDAMAX(arg0: int, arg1: int, arg2: psi::Vector, arg3: int) → int¶; docstring. class psi4.core.IO¶; Bases: pybind11_builtins.pybind11_object; docstring. change_file_namespace(fileno: int, ns1: str, ns2: str) → None¶; Change file number from ns1 to ns2. close(self: psi4.core.IO, unit: int, keep: int) → None¶; Close unit. If keep == 0, will remove the file, else keep it. get_default_namespace() → str¶; Get the default namespace (for PREFIX.NAMESPACE.UNIT file numbering). getpid(self: psi4.core.IO) → str¶; Lookup process id. open(self: psi4.core.IO, unit: int, status: int) → None¶; Open unit. Status can be PSIO_OPEN_OLD (if existing file is to be opened) or PSIO_OPEN_NEW if new file should be open. open_check(self: psi4.core.IO, unit: int) → int¶; Return 1 if unit is open. rehash(self: psi4.core.IO, unit: int) → None¶; Sync up the object to the file on disk by closing and opening the file, if necessary. set_default_namespace(ns: str) → None¶",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:131969,Modifiability,variab,variables,131969,"i4.core.Molecule, arg0: float) → psi4.core.PointGroup¶; Finds computational molecular point group, user can override this with the symmetry keyword. fix_com(self: psi4.core.Molecule, arg0: bool) → None¶; Whether to fix the Cartesian position, or to translate to the C.O.M. fix_orientation(self: psi4.core.Molecule, arg0: bool) → None¶; Fix the orientation at its current frame. form_symmetry_information(self: psi4.core.Molecule, arg0: float) → None¶; Uses the point group object obtain by calling point_group(). classmethod from_arrays(geom=None, elea=None, elez=None, elem=None, mass=None, real=None, elbl=None, name=None, units='Angstrom', input_units_to_au=None, fix_com=None, fix_orientation=None, fix_symmetry=None, fragment_separators=None, fragment_charges=None, fragment_multiplicities=None, molecular_charge=None, molecular_multiplicity=None, missing_enabled_return='error', tooclose=0.1, zero_ghost_fragments=False, nonphysical=False, mtol=0.001, verbose=1, return_dict=False)¶; Construct Molecule from unvalidated arrays and variables.; Light wrapper around from_arrays(); that is a full-featured constructor to dictionary representa-; tion of Molecule. This follows one step further to return; Molecule instance.; :param See from_arrays().:. Returns:. Return type:psi4.core.Molecule. from_dict(arg0: dict) → psi4.core.Molecule¶; Returns a new Molecule constructed from python dictionary. In progress: name and capabilities should not be relied upon. classmethod from_schema(molschema, return_dict=False, verbose=1)¶; Construct Molecule from non-Psi4 schema.; Light wrapper around from_arrays(). Parameters:; molschema (dict) – Dictionary form of Molecule following known schema.; return_dict (bool, optional) – Additionally return Molecule dictionary intermediate.; verbose (int, optional) – Amount of printing. Returns:; mol (psi4.core.Molecule); molrec (dict, optional) – Dictionary representation of instance.; Only provided if return_dict is True. classmethod from_string(molstr, dty",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:134297,Modifiability,variab,variable,134297,"g1 (0-indexed including dummies in Bohr). fz(self: psi4.core.Molecule, arg0: int) → float¶; z position of atom arg1 (0-indexed including dummies in Bohr). geometry(self: psi4.core.Molecule) → psi4.core.Matrix¶; Gets the geometry as a (Natom X 3) matrix of coordinates (in Bohr). get_fragment_charges(self: psi4.core.Molecule) → List[int]¶; Gets the charge of each fragment. get_fragment_multiplicities(self: psi4.core.Molecule) → List[int]¶; Gets the multiplicity of each fragment. get_fragment_types(self: psi4.core.Molecule) → List[str]¶; Returns a list describing how to handle each fragment {Real, Ghost, Absent}. get_fragments(self: psi4.core.Molecule) → List[Tuple[int, int]]¶; Returns list of pairs of atom ranges defining each fragment from parent molecule(fragments[frag_ind] = <Afirst,Alast+1>). get_full_point_group(self: psi4.core.Molecule) → str¶; Gets point group name such as C3v or S8. get_variable(self: psi4.core.Molecule, arg0: str) → float¶; Checks if variable arg2 is in the list, sets it to val and returns true if it is, and returns false if not. inertia_tensor(self: psi4.core.Molecule) → psi4.core.Matrix¶; Returns intertial tensor. input_units_to_au(self: psi4.core.Molecule) → float¶; Returns unit conversion to [a0] for geometry. irrep_labels(self: psi4.core.Molecule) → List[str]¶; Returns Irreducible Representation symmetry labels. is_variable(self: psi4.core.Molecule, arg0: str) → bool¶; Checks if variable arg2 is in the list, returns true if it is, and returns false if not. label(self: psi4.core.Molecule, arg0: int) → str¶; Gets the original label of the atom as given in the input file (C2, H4). mass(self: psi4.core.Molecule, atom: int) → float¶; Returns mass of atom (0-indexed). mass_number(self: psi4.core.Molecule, arg0: int) → int¶; Mass number (A) of atom if known, else -1. molecular_charge(self: psi4.core.Molecule) → int¶; Gets the molecular charge. move_to_com(self: psi4.core.Molecule) → None¶; Moves molecule to center of mass. multiplicity(self: ps",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:134756,Modifiability,variab,variable,134756," multiplicity of each fragment. get_fragment_types(self: psi4.core.Molecule) → List[str]¶; Returns a list describing how to handle each fragment {Real, Ghost, Absent}. get_fragments(self: psi4.core.Molecule) → List[Tuple[int, int]]¶; Returns list of pairs of atom ranges defining each fragment from parent molecule(fragments[frag_ind] = <Afirst,Alast+1>). get_full_point_group(self: psi4.core.Molecule) → str¶; Gets point group name such as C3v or S8. get_variable(self: psi4.core.Molecule, arg0: str) → float¶; Checks if variable arg2 is in the list, sets it to val and returns true if it is, and returns false if not. inertia_tensor(self: psi4.core.Molecule) → psi4.core.Matrix¶; Returns intertial tensor. input_units_to_au(self: psi4.core.Molecule) → float¶; Returns unit conversion to [a0] for geometry. irrep_labels(self: psi4.core.Molecule) → List[str]¶; Returns Irreducible Representation symmetry labels. is_variable(self: psi4.core.Molecule, arg0: str) → bool¶; Checks if variable arg2 is in the list, returns true if it is, and returns false if not. label(self: psi4.core.Molecule, arg0: int) → str¶; Gets the original label of the atom as given in the input file (C2, H4). mass(self: psi4.core.Molecule, atom: int) → float¶; Returns mass of atom (0-indexed). mass_number(self: psi4.core.Molecule, arg0: int) → int¶; Mass number (A) of atom if known, else -1. molecular_charge(self: psi4.core.Molecule) → int¶; Gets the molecular charge. move_to_com(self: psi4.core.Molecule) → None¶; Moves molecule to center of mass. multiplicity(self: psi4.core.Molecule) → int¶; Gets the multiplicity (defined as 2Ms + 1). nallatom(self: psi4.core.Molecule) → int¶; Number of real and dummy atoms. name(self: psi4.core.Molecule) → str¶; Gets molecule name. natom(self: psi4.core.Molecule) → int¶; Number of real atoms. nfragments(self: psi4.core.Molecule) → int¶; Gets the number of fragments in the molecule. nuclear_dipole(*args, **kwargs)¶; Overloaded function. nuclear_dipole(self: psi4.core.Molecul",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:138934,Modifiability,extend,extended,138934,"cule) → psi4.core.Vector¶; Prints the rotational constants of the molecule. rotational_symmetry_number(self: psi4.core.Molecule) → int¶; Returns number of unique orientations of the rigid molecule that only interchange identical atoms. rotor_type(self: psi4.core.Molecule) → str¶; Returns rotor type, e.g. ‘RT_ATOM’ or ‘RT_SYMMETRIC_TOP’. run_dftd3(func=None, dashlvl=None, dashparam=None, dertype=None, verbose=False)¶; Compute dispersion correction using Grimme’s DFTD3 executable.; Function to call Grimme’s dftd3 program to compute the -D correction; of level dashlvl using parameters for the functional func.; dashparam can supply a full set of dispersion parameters in the; absence of func or individual overrides in the presence of func.; The DFTD3 executable must be independently compiled and found in; PATH or PSIPATH. Parameters:; mol (qcdb.Molecule or psi4.core.Molecule or str) – Molecule on which to run dispersion calculation. Both qcdb and; psi4.core Molecule classes have been extended by this method, so; either allowed. Alternately, a string that can be instantiated; into a qcdb.Molecule.; func (str or None) – Density functional (Psi4, not Turbomole, names) for which to; load parameters from dashcoeff[dashlvl][func]. This is not; passed to DFTD3 and thus may be a dummy or None. Any or all; parameters initialized can be overwritten via dashparam.; dashlvl ({'d2p4', 'd2gr', 'd3zero', 'd3bj', 'd3mzero', d3mbj', 'd', 'd2', 'd3', 'd3m'}) – Flavor of a posteriori dispersion correction for which to load; parameters and call procedure in DFTD3. Must be a keys in; dashcoeff dict (or a key in dashalias that resolves to one).; dashparam (dict, optional) – Dictionary of the same keys as dashcoeff[dashlvl] used to; override any or all values initialized by; dashcoeff[dashlvl][func].; dertype ({None, 0, 'none', 'energy', 1, 'first', 'gradient'}, optional) – Maximum derivative level at which to run DFTD3. For large; mol, energy-only calculations can be significantly more; effic",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:141589,Modifiability,extend,extended,141589,"; * output goes to output file; * gradient returned as psi4.core.Matrix, not list o’lists; * scratch is written to randomly named subdirectory of psi scratch; * psivar “DISPERSION CORRECTION ENERGY” is set; * verbose triggered when PRINT keywork of SCF module >=3. run_gcp(func=None, dertype=None, verbose=False)¶; Function to call Grimme’s dftd3 program (http://toc.uni-muenster.de/DFTD3/); to compute the -D correction of level dashlvl using parameters for; the functional func. The dictionary dashparam can be used to supply; a full set of dispersion parameters in the absense of func or to supply; individual overrides in the presence of func. Returns energy if dertype is 0,; gradient if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The dftd3 executable must be independently compiled and found in; PATH or PSIPATH.; self may be either a qcdb.Molecule (sensibly) or a psi4.Molecule; (works b/c psi4.Molecule has been extended by this method py-side and; only public interface fns used) or a string that can be instantiated; into a qcdb.Molecule. save_string_xyz(self: psi4.core.Molecule) → str¶; Saves the string of an XYZ file to arg2. save_string_xyz_file(self: psi4.core.Molecule) → str¶; Saves an XYZ file to arg2. save_xyz_file(self: psi4.core.Molecule, arg0: str, arg1: bool) → None¶; Saves an XYZ file to arg2. schoenflies_symbol(self: psi4.core.Molecule) → str¶; Returns the Schoenflies symbol. scramble(do_shift=True, do_rotate=True, do_resort=True, deflection=1.0, do_mirror=False, do_plot=False, run_to_completion=False, run_resorting=False, verbose=1)¶; Tester for B787 by shifting, rotating, and atom shuffling ref_mol and; checking that the aligner returns the opposite transformation. Parameters:; ref_mol (qcdb.Molecule or psi4.core.Molecule) – Molecule to perturb.; do_shift (bool or array-like, optional) – Whether to generate a random atom shift on interval [-3, 3) in each; dimension (True) or leave at current origin. To shift by a specified; vect",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:145790,Modifiability,variab,variable,145790,"au(self: psi4.core.Molecule, arg0: float) → None¶; Sets unit conversion to [a0] for geometry. set_mass(self: psi4.core.Molecule, atom: int, mass: float) → None¶; Sets mass of atom (0-indexed) to mass. set_molecular_charge(self: psi4.core.Molecule, arg0: int) → None¶; Sets the molecular charge. set_multiplicity(self: psi4.core.Molecule, arg0: int) → None¶; Sets the multiplicity (defined as 2Ms + 1). set_name(self: psi4.core.Molecule, arg0: str) → None¶; Sets molecule name. set_nuclear_charge(self: psi4.core.Molecule, arg0: int, arg1: float) → None¶; Set the nuclear charge of the given atom to the value provided. set_point_group(self: psi4.core.Molecule, arg0: psi4.core.PointGroup) → None¶; Sets the molecular point group to the point group object arg2. set_units(self: psi4.core.Molecule, arg0: psi4.core.GeometryUnits) → None¶; Sets units (Angstrom or Bohr) used to define the geometry. set_variable(self: psi4.core.Molecule, arg0: str, arg1: float) → None¶; Assigns the value arg3 to the variable arg2 in the list of geometry variables, then calls update_geometry(). symbol(self: psi4.core.Molecule, arg0: int) → str¶; Gets the cleaned up label of atom arg2 (C2 => C, H4 = H). symmetrize(self: psi4.core.Molecule, arg0: float) → None¶; Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. symmetry_from_input(self: psi4.core.Molecule) → str¶; Returns the symmetry specified in the input. to_arrays()¶; Exports coordinate info into NumPy arrays. Returns:; geom, mass, elem, elez, uniq (ndarray, ndarray, ndarray, ndarray, ndarray) – (nat, 3) geometry [a0].; (nat,) mass [u].; (nat,) element symbol.; (nat,) atomic number.; (nat,) hash of element symbol and mass.; Note that coordinate, orientation, and element information is; preserved but fragmentation, chgmult, and dummy/ghost is lost.; Usage; —–; geom, mass, elem, elez, uniq = molinstance.to_arrays(). to_dict(force_c1=False, force_units=False, np_out=True)¶; Serial",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:145828,Modifiability,variab,variables,145828,"au(self: psi4.core.Molecule, arg0: float) → None¶; Sets unit conversion to [a0] for geometry. set_mass(self: psi4.core.Molecule, atom: int, mass: float) → None¶; Sets mass of atom (0-indexed) to mass. set_molecular_charge(self: psi4.core.Molecule, arg0: int) → None¶; Sets the molecular charge. set_multiplicity(self: psi4.core.Molecule, arg0: int) → None¶; Sets the multiplicity (defined as 2Ms + 1). set_name(self: psi4.core.Molecule, arg0: str) → None¶; Sets molecule name. set_nuclear_charge(self: psi4.core.Molecule, arg0: int, arg1: float) → None¶; Set the nuclear charge of the given atom to the value provided. set_point_group(self: psi4.core.Molecule, arg0: psi4.core.PointGroup) → None¶; Sets the molecular point group to the point group object arg2. set_units(self: psi4.core.Molecule, arg0: psi4.core.GeometryUnits) → None¶; Sets units (Angstrom or Bohr) used to define the geometry. set_variable(self: psi4.core.Molecule, arg0: str, arg1: float) → None¶; Assigns the value arg3 to the variable arg2 in the list of geometry variables, then calls update_geometry(). symbol(self: psi4.core.Molecule, arg0: int) → str¶; Gets the cleaned up label of atom arg2 (C2 => C, H4 = H). symmetrize(self: psi4.core.Molecule, arg0: float) → None¶; Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. symmetry_from_input(self: psi4.core.Molecule) → str¶; Returns the symmetry specified in the input. to_arrays()¶; Exports coordinate info into NumPy arrays. Returns:; geom, mass, elem, elez, uniq (ndarray, ndarray, ndarray, ndarray, ndarray) – (nat, 3) geometry [a0].; (nat,) mass [u].; (nat,) element symbol.; (nat,) atomic number.; (nat,) hash of element symbol and mass.; Note that coordinate, orientation, and element information is; preserved but fragmentation, chgmult, and dummy/ghost is lost.; Usage; —–; geom, mass, elem, elez, uniq = molinstance.to_arrays(). to_dict(force_c1=False, force_units=False, np_out=True)¶; Serial",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:147393,Modifiability,variab,variable,147393,"rray, ndarray) – (nat, 3) geometry [a0].; (nat,) mass [u].; (nat,) element symbol.; (nat,) atomic number.; (nat,) hash of element symbol and mass.; Note that coordinate, orientation, and element information is; preserved but fragmentation, chgmult, and dummy/ghost is lost.; Usage; —–; geom, mass, elem, elez, uniq = molinstance.to_arrays(). to_dict(force_c1=False, force_units=False, np_out=True)¶; Serializes instance into Molecule dictionary. to_schema(dtype, units='Angstrom', return_type='json')¶; Serializes instance into JSON or YAML according to schema dtype. to_string(dtype, units='Angstrom', atom_format=None, ghost_format=None, width=17, prec=12)¶; Format a string representation of QM molecule. translate(self: psi4.core.Molecule, arg0: psi4.core.Vector3) → None¶; Translates molecule by arg2. units(self: psi4.core.Molecule) → str¶; Returns units used to define the geometry, i.e. ‘Angstrom’ or ‘Bohr’. update_geometry(self: psi4.core.Molecule) → None¶; Reevaluates the geometry with current variable values, orientation directives, etc. Must be called after initial Molecule definition by string. x(self: psi4.core.Molecule, arg0: int) → float¶; x position of atom. y(self: psi4.core.Molecule, arg0: int) → float¶; y position of atom. z(self: psi4.core.Molecule, arg0: int) → float¶; z position of atom. class psi4.core.MultipoleInt¶; Bases: psi4.core.OneBodyAOInt; Computes arbitrary-order multipole integrals. basis¶; The basis set on center one. basis1¶; The basis set on center one. basis2¶; The basis set on center two. compute_shell(self: psi4.core.OneBodyAOInt, arg0: int, arg1: int) → None¶; Compute integrals between basis functions in the given shell pair. origin¶; The origin about which the one body ints are being computed. class psi4.core.MultipoleSymmetry¶; Bases: pybind11_builtins.pybind11_object; docstring. create_matrices(self: psi4.core.MultipoleSymmetry, arg0: str) → List[psi4.core.Matrix]¶; docstring. class psi4.core.NBOWriter¶; Bases: pybind11_builtins.pybind",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:165542,Modifiability,variab,variable,165542,"e current Density Matrices. frequencies(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the frequencies of the Hessian. frzcpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of frozen core orbitals per irrep. frzvpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of frozen virtual orbitals per irrep. functional(self: psi4.core.HF) → psi4.core.SuperFunctional¶; Returns the internal DFT Superfunctional. get_array(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Sets the requested internal array. get_basisset(self: psi4.core.Wavefunction, arg0: str) → psi4.core.BasisSet¶; Returns the requested auxiliary basis. get_dipole_field_strength(self: psi4.core.Wavefunction) → List[float[3]]¶; Returns a vector of length 3, containing the x,y, and z dipole field strengths. get_print(self: psi4.core.Wavefunction) → int¶; Get the print level of the Wavefunction. get_variable(self: psi4.core.Wavefunction, arg0: str) → float¶; Returns the requested internal variable. gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunctions gradient. guess_Ca(self: psi4.core.HF, arg0: psi4.core.Matrix) → None¶; Sets the guess Alpha Orbital Matrix. guess_Cb(self: psi4.core.HF, arg0: psi4.core.Matrix) → None¶; Sets the guess Beta Orbital Matrix. hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunctions Hessian. initialize(self: psi4.core.HF) → None¶; Initializes the Wavefunction. iterations(self: psi4.core.HF) → None¶; Iterates the Wavefunction until convergence criteria have been met. jk(self: psi4.core.HF) → psi4.core.JK¶; Returns the internal JK object. mo_extents(self: psi4.core.Wavefunction) → List[psi4.core.Vector]¶; returns the wavefunction’s electronic orbital extents. molecule(self: psi4.core.Wavefunction) → psi4.core.Molecule¶; Returns the Wavefunctions molecule. nalpha(self: psi4.core.Wavefunction) → int¶; Number of Alpha electrons. nalphapi(self: psi4.core.Wavefun",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:169922,Modifiability,variab,variable,169922,"sian. set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunctions gradient. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunctions Hessian. set_jk(self: psi4.core.HF, arg0: psi4.core.JK) → None¶; Sets the internal JK object !expert. set_name(self: psi4.core.Wavefunction, arg0: str) → None¶; Sets the level of theory this wavefunction corresponds to. set_print(self: psi4.core.Wavefunction, arg0: int) → None¶; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; docstring. set_sad_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities density-fitted basisset. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. twoel_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix], arg1: bool, arg2: str) → List[psi4.core.Matrix]¶; Two-electron Hessian-vector products. variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the map of all internal variables. class psi4.core.RKSFunctions¶; Bases: psi4.core.PointFunctions; docstring. ansatz(self: psi4.core.PointFunctions) → int¶; docstring. basis_values(self: psi4.core.BasisFunctions) → Dict[str, psi4.core.Matrix]¶; docstring. compute_functions(self: psi4.core.BasisFunctions, arg0: psi::BlockOPoints) → None¶; docstring. compute_points(self: psi4.core.PointFunction",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:170425,Modifiability,variab,variables,170425,"ce_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; docstring. set_sad_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities density-fitted basisset. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. twoel_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix], arg1: bool, arg2: str) → List[psi4.core.Matrix]¶; Two-electron Hessian-vector products. variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the map of all internal variables. class psi4.core.RKSFunctions¶; Bases: psi4.core.PointFunctions; docstring. ansatz(self: psi4.core.PointFunctions) → int¶; docstring. basis_values(self: psi4.core.BasisFunctions) → Dict[str, psi4.core.Matrix]¶; docstring. compute_functions(self: psi4.core.BasisFunctions, arg0: psi::BlockOPoints) → None¶; docstring. compute_points(self: psi4.core.PointFunctions, arg0: psi::BlockOPoints) → None¶; docstring. deriv(self: psi4.core.BasisFunctions) → int¶; docstring. max_functions(self: psi4.core.BasisFunctions) → int¶; docstring. max_points(self: psi4.core.BasisFunctions) → int¶; docstring. orbital_values(self: psi4.core.PointFunctions) → Dict[str, psi4.core.Matrix]¶; docstring. point_values(self: psi4.core.PointFunctions) → Dict[str, psi4.core.Vector]¶; docstring. print_out(self: psi4.core.PointFunctions, out_fname: str='outfile', print: int=2) → None¶; docstring. set_ansatz(self: psi4.core.PointFu",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:170518,Modifiability,variab,variables,170518,"i4.core.Wavefunction) → None¶; docstring. set_sad_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities density-fitted basisset. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. twoel_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix], arg1: bool, arg2: str) → List[psi4.core.Matrix]¶; Two-electron Hessian-vector products. variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the map of all internal variables. class psi4.core.RKSFunctions¶; Bases: psi4.core.PointFunctions; docstring. ansatz(self: psi4.core.PointFunctions) → int¶; docstring. basis_values(self: psi4.core.BasisFunctions) → Dict[str, psi4.core.Matrix]¶; docstring. compute_functions(self: psi4.core.BasisFunctions, arg0: psi::BlockOPoints) → None¶; docstring. compute_points(self: psi4.core.PointFunctions, arg0: psi::BlockOPoints) → None¶; docstring. deriv(self: psi4.core.BasisFunctions) → int¶; docstring. max_functions(self: psi4.core.BasisFunctions) → int¶; docstring. max_points(self: psi4.core.BasisFunctions) → int¶; docstring. orbital_values(self: psi4.core.PointFunctions) → Dict[str, psi4.core.Matrix]¶; docstring. point_values(self: psi4.core.PointFunctions) → Dict[str, psi4.core.Vector]¶; docstring. print_out(self: psi4.core.PointFunctions, out_fname: str='outfile', print: int=2) → None¶; docstring. set_ansatz(self: psi4.core.PointFunctions, arg0: int) → None¶; docstring. set_deriv(self:",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:178133,Modifiability,variab,variable,178133,"e current Density Matrices. frequencies(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the frequencies of the Hessian. frzcpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of frozen core orbitals per irrep. frzvpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of frozen virtual orbitals per irrep. functional(self: psi4.core.HF) → psi4.core.SuperFunctional¶; Returns the internal DFT Superfunctional. get_array(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Sets the requested internal array. get_basisset(self: psi4.core.Wavefunction, arg0: str) → psi4.core.BasisSet¶; Returns the requested auxiliary basis. get_dipole_field_strength(self: psi4.core.Wavefunction) → List[float[3]]¶; Returns a vector of length 3, containing the x,y, and z dipole field strengths. get_print(self: psi4.core.Wavefunction) → int¶; Get the print level of the Wavefunction. get_variable(self: psi4.core.Wavefunction, arg0: str) → float¶; Returns the requested internal variable. gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunctions gradient. guess_Ca(self: psi4.core.HF, arg0: psi4.core.Matrix) → None¶; Sets the guess Alpha Orbital Matrix. guess_Cb(self: psi4.core.HF, arg0: psi4.core.Matrix) → None¶; Sets the guess Beta Orbital Matrix. hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunctions Hessian. initialize(self: psi4.core.HF) → None¶; Initializes the Wavefunction. iterations(self: psi4.core.HF) → None¶; Iterates the Wavefunction until convergence criteria have been met. jk(self: psi4.core.HF) → psi4.core.JK¶; Returns the internal JK object. moFa(self: psi4.core.ROHF) → psi4.core.Matrix¶; docstring. moFb(self: psi4.core.ROHF) → psi4.core.Matrix¶; docstring. moFeff(self: psi4.core.ROHF) → psi4.core.Matrix¶; docstring. mo_extents(self: psi4.core.Wavefunction) → List[psi4.core.Vector]¶; returns the wavefunction’s electronic orbital extents. molecule(self: psi4.cor",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:182692,Modifiability,variab,variable,182692,"sian. set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunctions gradient. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunctions Hessian. set_jk(self: psi4.core.HF, arg0: psi4.core.JK) → None¶; Sets the internal JK object !expert. set_name(self: psi4.core.Wavefunction, arg0: str) → None¶; Sets the level of theory this wavefunction corresponds to. set_print(self: psi4.core.Wavefunction, arg0: int) → None¶; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; docstring. set_sad_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities density-fitted basisset. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. twoel_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix], arg1: bool, arg2: str) → List[psi4.core.Matrix]¶; Two-electron Hessian-vector products. variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the map of all internal variables. class psi4.core.SADGuess¶; Bases: pybind11_builtins.pybind11_object; docstring. Ca(self: psi4.core.SADGuess) → psi4.core.Matrix¶. Cb(self: psi4.core.SADGuess) → psi4.core.Matrix¶. Da(self: psi4.core.SADGuess) → psi4.core.Matrix¶. Db(self: psi4.core.SADGuess) → psi4.core.Matrix¶. build_SAD(arg0: psi4.core.BasisSet, arg1: List[psi4.core.BasisSet], arg2: int, a",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:183195,Modifiability,variab,variables,183195,"ce_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; docstring. set_sad_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities density-fitted basisset. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. twoel_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix], arg1: bool, arg2: str) → List[psi4.core.Matrix]¶; Two-electron Hessian-vector products. variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the map of all internal variables. class psi4.core.SADGuess¶; Bases: pybind11_builtins.pybind11_object; docstring. Ca(self: psi4.core.SADGuess) → psi4.core.Matrix¶. Cb(self: psi4.core.SADGuess) → psi4.core.Matrix¶. Da(self: psi4.core.SADGuess) → psi4.core.Matrix¶. Db(self: psi4.core.SADGuess) → psi4.core.Matrix¶. build_SAD(arg0: psi4.core.BasisSet, arg1: List[psi4.core.BasisSet], arg2: int, arg3: int) → psi4.core.SADGuess¶. compute_guess(self: psi4.core.SADGuess) → None¶. set_atomic_fit_bases(self: psi4.core.SADGuess, arg0: List[psi4.core.BasisSet]) → None¶. set_debug(self: psi4.core.SADGuess, arg0: int) → None¶. set_print(self: psi4.core.SADGuess, arg0: int) → None¶. class psi4.core.SOBasisSet¶; Bases: pybind11_builtins.pybind11_object; An SOBasis object describes the transformation from an atomic orbital basis to a symmetry orbital basis. petite_list(self: psi4.core.SOBasisSet) → psi4.core.PetiteList¶; Return the PetiteList o",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:183288,Modifiability,variab,variables,183288,"i4.core.Wavefunction) → None¶; docstring. set_sad_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities density-fitted basisset. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. twoel_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix], arg1: bool, arg2: str) → List[psi4.core.Matrix]¶; Two-electron Hessian-vector products. variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the map of all internal variables. class psi4.core.SADGuess¶; Bases: pybind11_builtins.pybind11_object; docstring. Ca(self: psi4.core.SADGuess) → psi4.core.Matrix¶. Cb(self: psi4.core.SADGuess) → psi4.core.Matrix¶. Da(self: psi4.core.SADGuess) → psi4.core.Matrix¶. Db(self: psi4.core.SADGuess) → psi4.core.Matrix¶. build_SAD(arg0: psi4.core.BasisSet, arg1: List[psi4.core.BasisSet], arg2: int, arg3: int) → psi4.core.SADGuess¶. compute_guess(self: psi4.core.SADGuess) → None¶. set_atomic_fit_bases(self: psi4.core.SADGuess, arg0: List[psi4.core.BasisSet]) → None¶. set_debug(self: psi4.core.SADGuess, arg0: int) → None¶. set_print(self: psi4.core.SADGuess, arg0: int) → None¶. class psi4.core.SOBasisSet¶; Bases: pybind11_builtins.pybind11_object; An SOBasis object describes the transformation from an atomic orbital basis to a symmetry orbital basis. petite_list(self: psi4.core.SOBasisSet) → psi4.core.PetiteList¶; Return the PetiteList object used in creating this SO basis. class psi4.core.S",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:201616,Modifiability,variab,variable,201616,"e current Density Matrices. frequencies(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the frequencies of the Hessian. frzcpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of frozen core orbitals per irrep. frzvpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of frozen virtual orbitals per irrep. functional(self: psi4.core.HF) → psi4.core.SuperFunctional¶; Returns the internal DFT Superfunctional. get_array(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Sets the requested internal array. get_basisset(self: psi4.core.Wavefunction, arg0: str) → psi4.core.BasisSet¶; Returns the requested auxiliary basis. get_dipole_field_strength(self: psi4.core.Wavefunction) → List[float[3]]¶; Returns a vector of length 3, containing the x,y, and z dipole field strengths. get_print(self: psi4.core.Wavefunction) → int¶; Get the print level of the Wavefunction. get_variable(self: psi4.core.Wavefunction, arg0: str) → float¶; Returns the requested internal variable. gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunctions gradient. guess_Ca(self: psi4.core.HF, arg0: psi4.core.Matrix) → None¶; Sets the guess Alpha Orbital Matrix. guess_Cb(self: psi4.core.HF, arg0: psi4.core.Matrix) → None¶; Sets the guess Beta Orbital Matrix. hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunctions Hessian. initialize(self: psi4.core.HF) → None¶; Initializes the Wavefunction. iterations(self: psi4.core.HF) → None¶; Iterates the Wavefunction until convergence criteria have been met. jk(self: psi4.core.HF) → psi4.core.JK¶; Returns the internal JK object. mo_extents(self: psi4.core.Wavefunction) → List[psi4.core.Vector]¶; returns the wavefunction’s electronic orbital extents. molecule(self: psi4.core.Wavefunction) → psi4.core.Molecule¶; Returns the Wavefunctions molecule. nalpha(self: psi4.core.Wavefunction) → int¶; Number of Alpha electrons. nalphapi(self: psi4.core.Wavefun",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:205996,Modifiability,variab,variable,205996,"sian. set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunctions gradient. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunctions Hessian. set_jk(self: psi4.core.HF, arg0: psi4.core.JK) → None¶; Sets the internal JK object !expert. set_name(self: psi4.core.Wavefunction, arg0: str) → None¶; Sets the level of theory this wavefunction corresponds to. set_print(self: psi4.core.Wavefunction, arg0: int) → None¶; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; docstring. set_sad_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities density-fitted basisset. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. twoel_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix], arg1: bool, arg2: str) → List[psi4.core.Matrix]¶; Two-electron Hessian-vector products. variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the map of all internal variables. class psi4.core.UKSFunctions¶; Bases: psi4.core.PointFunctions; docstring. ansatz(self: psi4.core.PointFunctions) → int¶; docstring. basis_values(self: psi4.core.BasisFunctions) → Dict[str, psi4.core.Matrix]¶; docstring. compute_functions(self: psi4.core.BasisFunctions, arg0: psi::BlockOPoints) → None¶; docstring. compute_points(self: psi4.core.PointFunction",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:206499,Modifiability,variab,variables,206499,"ce_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; docstring. set_sad_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities density-fitted basisset. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. twoel_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix], arg1: bool, arg2: str) → List[psi4.core.Matrix]¶; Two-electron Hessian-vector products. variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the map of all internal variables. class psi4.core.UKSFunctions¶; Bases: psi4.core.PointFunctions; docstring. ansatz(self: psi4.core.PointFunctions) → int¶; docstring. basis_values(self: psi4.core.BasisFunctions) → Dict[str, psi4.core.Matrix]¶; docstring. compute_functions(self: psi4.core.BasisFunctions, arg0: psi::BlockOPoints) → None¶; docstring. compute_points(self: psi4.core.PointFunctions, arg0: psi::BlockOPoints) → None¶; docstring. deriv(self: psi4.core.BasisFunctions) → int¶; docstring. max_functions(self: psi4.core.BasisFunctions) → int¶; docstring. max_points(self: psi4.core.BasisFunctions) → int¶; docstring. orbital_values(self: psi4.core.PointFunctions) → Dict[str, psi4.core.Matrix]¶; docstring. point_values(self: psi4.core.PointFunctions) → Dict[str, psi4.core.Vector]¶; docstring. print_out(self: psi4.core.PointFunctions, out_fname: str='outfile', print: int=2) → None¶; docstring. set_ansatz(self: psi4.core.PointFu",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:206592,Modifiability,variab,variables,206592,"i4.core.Wavefunction) → None¶; docstring. set_sad_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities density-fitted basisset. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. twoel_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix], arg1: bool, arg2: str) → List[psi4.core.Matrix]¶; Two-electron Hessian-vector products. variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the map of all internal variables. class psi4.core.UKSFunctions¶; Bases: psi4.core.PointFunctions; docstring. ansatz(self: psi4.core.PointFunctions) → int¶; docstring. basis_values(self: psi4.core.BasisFunctions) → Dict[str, psi4.core.Matrix]¶; docstring. compute_functions(self: psi4.core.BasisFunctions, arg0: psi::BlockOPoints) → None¶; docstring. compute_points(self: psi4.core.PointFunctions, arg0: psi::BlockOPoints) → None¶; docstring. deriv(self: psi4.core.BasisFunctions) → int¶; docstring. max_functions(self: psi4.core.BasisFunctions) → int¶; docstring. max_points(self: psi4.core.BasisFunctions) → int¶; docstring. orbital_values(self: psi4.core.PointFunctions) → Dict[str, psi4.core.Matrix]¶; docstring. point_values(self: psi4.core.PointFunctions) → Dict[str, psi4.core.Vector]¶; docstring. print_out(self: psi4.core.PointFunctions, out_fname: str='outfile', print: int=2) → None¶; docstring. set_ansatz(self: psi4.core.PointFunctions, arg0: int) → None¶; docstring. set_deriv(self:",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:214591,Modifiability,extend,extend,214591,"r3¶; Bases: pybind11_builtins.pybind11_object; Class for vectors of length three, often Cartesian coordinate vectors, and their common operations. cross(self: psi4.core.Vector3, arg0: psi4.core.Vector3) → psi4.core.Vector3¶; Returns cross product of arg1 and arg2. distance(self: psi4.core.Vector3, arg0: psi4.core.Vector3) → float¶; Returns distance between two points represented by arg1 and arg2. dot(self: psi4.core.Vector3, arg0: psi4.core.Vector3) → float¶; Returns dot product of arg1 and arg2. norm(self: psi4.core.Vector3) → float¶; Returns Euclidean norm of arg1. normalize(self: psi4.core.Vector3) → None¶; Returns vector of unit length and arg1 direction. class psi4.core.VectorMatrix¶; Bases: pybind11_builtins.pybind11_object. append(self: List[psi::Matrix], x: psi::Matrix) → None¶; Add an item to the end of the list. count(self: List[psi::Matrix], x: psi::Matrix) → int¶; Return the number of times x appears in the list. extend(self: List[psi::Matrix], L: List[psi::Matrix]) → None¶; Extend the list by appending all the items in the given list. insert(self: List[psi::Matrix], i: int, x: psi::Matrix) → None¶; Insert an item at a given position. pop(*args, **kwargs)¶; Overloaded function. pop(self: List[psi::Matrix]) -> psi::Matrix. Remove and return the last item. pop(self: List[psi::Matrix], i: int) -> psi::Matrix. Remove and return the item at index i. remove(self: List[psi::Matrix], x: psi::Matrix) → None¶; Remove the first item from the list whose value is x. It is an error if there is no such item. class psi4.core.Wavefunction¶; Bases: pybind11_builtins.pybind11_object; docstring. Ca(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Alpha Orbitals. Ca_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Matrix¶; Returns the requested Alpha Orbital subset. Cb(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Beta Orbitals. Cb_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Matrix¶; Returns the r",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:220292,Modifiability,variab,variable,220292,"of singly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. frequencies(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the frequencies of the Hessian. frzcpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of frozen core orbitals per irrep. frzvpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of frozen virtual orbitals per irrep. get_array(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Sets the requested internal array. get_basisset(self: psi4.core.Wavefunction, arg0: str) → psi4.core.BasisSet¶; Returns the requested auxiliary basis. get_dipole_field_strength(self: psi4.core.Wavefunction) → List[float[3]]¶; Returns a vector of length 3, containing the x,y, and z dipole field strengths. get_print(self: psi4.core.Wavefunction) → int¶; Get the print level of the Wavefunction. get_variable(self: psi4.core.Wavefunction, arg0: str) → float¶; Returns the requested internal variable. gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunctions gradient. hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunctions Hessian. mo_extents(self: psi4.core.Wavefunction) → List[psi4.core.Vector]¶; returns the wavefunction’s electronic orbital extents. molecule(self: psi4.core.Wavefunction) → psi4.core.Molecule¶; Returns the Wavefunctions molecule. nalpha(self: psi4.core.Wavefunction) → int¶; Number of Alpha electrons. nalphapi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of alpha orbitals per irrep. name(self: psi4.core.Wavefunction) → str¶; The level of theory this wavefunction corresponds to. nbeta(self: psi4.core.Wavefunction) → int¶; Number of Beta electrons. nbetapi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of beta orbitals per irrep. nfrzc(self: psi4.core.Wavefunction) → int¶; Number of frozen core electrons. nirrep(self: ps",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:223321,Modifiability,variab,variable,223321,"l array. set_basisset(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.BasisSet) → None¶; Sets the requested auxiliary basis. set_external_potential(self: psi4.core.Wavefunction, arg0: psi4.core.ExternalPotential) → None¶; Sets the requested external potential. set_frequencies(self: psi4.core.Wavefunction, arg0: psi4.core.Vector) → None¶; Sets the frequencies of the Hessian. set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunctions gradient. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunctions Hessian. set_name(self: psi4.core.Wavefunction, arg0: str) → None¶; Sets the level of theory this wavefunction corresponds to. set_print(self: psi4.core.Wavefunction, arg0: int) → None¶; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; docstring. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the map of all internal variables. psi4.core.adc(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the ADC propagator code, for excited states. psi4.core.atomic_displacements(arg0: psi::Molecule) → List[psi::Matrix]¶; Returns list of displacements generated by displacing each atom in the +/- x, y, z directions. psi4.core.be_quiet() → None¶; Redirects output to /dev/null. To switch back to regular output mode, use reopen_outfile(). psi4.core.benchmark_blas1(arg0: int, arg1: float) → None¶; docstring. psi4.core.benchmark_blas2(arg0: int",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:223677,Modifiability,variab,variables,223677,"self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunctions gradient. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunctions Hessian. set_name(self: psi4.core.Wavefunction, arg0: str) → None¶; Sets the level of theory this wavefunction corresponds to. set_print(self: psi4.core.Wavefunction, arg0: int) → None¶; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; docstring. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the map of all internal variables. psi4.core.adc(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the ADC propagator code, for excited states. psi4.core.atomic_displacements(arg0: psi::Molecule) → List[psi::Matrix]¶; Returns list of displacements generated by displacing each atom in the +/- x, y, z directions. psi4.core.be_quiet() → None¶; Redirects output to /dev/null. To switch back to regular output mode, use reopen_outfile(). psi4.core.benchmark_blas1(arg0: int, arg1: float) → None¶; docstring. psi4.core.benchmark_blas2(arg0: int, arg1: float) → None¶; docstring. psi4.core.benchmark_blas3(arg0: int, arg1: float, arg2: int) → None¶; docstring. psi4.core.benchmark_disk(arg0: int, arg1: float) → None¶; docstring. psi4.core.benchmark_integrals(arg0: int, arg1: float) → None¶; docstring. psi4.core.benchmark_math(arg0: float) → None¶; docstring. psi4.core.ccdensity(arg0: psi::Wavefunction) → float¶; Runs the code to compute co",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:223770,Modifiability,variab,variables,223770,"→ None¶; Sets the Wavefunctions gradient. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunctions Hessian. set_name(self: psi4.core.Wavefunction, arg0: str) → None¶; Sets the level of theory this wavefunction corresponds to. set_print(self: psi4.core.Wavefunction, arg0: int) → None¶; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; docstring. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the map of all internal variables. psi4.core.adc(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the ADC propagator code, for excited states. psi4.core.atomic_displacements(arg0: psi::Molecule) → List[psi::Matrix]¶; Returns list of displacements generated by displacing each atom in the +/- x, y, z directions. psi4.core.be_quiet() → None¶; Redirects output to /dev/null. To switch back to regular output mode, use reopen_outfile(). psi4.core.benchmark_blas1(arg0: int, arg1: float) → None¶; docstring. psi4.core.benchmark_blas2(arg0: int, arg1: float) → None¶; docstring. psi4.core.benchmark_blas3(arg0: int, arg1: float, arg2: int) → None¶; docstring. psi4.core.benchmark_disk(arg0: int, arg1: float) → None¶; docstring. psi4.core.benchmark_integrals(arg0: int, arg1: float) → None¶; docstring. psi4.core.benchmark_math(arg0: float) → None¶; docstring. psi4.core.ccdensity(arg0: psi::Wavefunction) → float¶; Runs the code to compute coupled cluster density matrices. psi4.core.ccenergy(arg0",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:225747,Modifiability,variab,variables,225747," psi::Wavefunction) → psi::Wavefunction¶; Runs the coupled cluster energy code. psi4.core.cceom(arg0: psi::Wavefunction) → float¶; Runs the equation of motion coupled cluster code, for excited states. psi4.core.cchbar(arg0: psi::Wavefunction) → None¶; Runs the code to generate the similarity transformed Hamiltonian. psi4.core.cclambda(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the coupled cluster lambda equations code. psi4.core.ccresponse(arg0: psi::Wavefunction) → float¶; Runs the coupled cluster response theory code. psi4.core.cctransort(arg0: psi::Wavefunction) → None¶; Runs CCTRANSORT, which transforms and reorders integrals for use in the coupled cluster codes. psi4.core.cctriples(arg0: psi::Wavefunction) → float¶; Runs the coupled cluster (T) energy code. psi4.core.clean() → None¶; Function to remove scratch files. Call between independent jobs. psi4.core.clean_options() → None¶; Function to reset options to clean state. psi4.core.clean_variables() → None¶; Empties all PSI variables that have set internally. psi4.core.close_outfile() → None¶; Closes the output file. psi4.core.dcft(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the density cumulant functional theory code. psi4.core.detci(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the determinant-based configuration interaction code. psi4.core.dfmp2(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the DF-MP2 code. psi4.core.dfocc(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the density-fitted orbital optimized CC codes. psi4.core.displace_atom(arg0: psi::Matrix, arg1: int, arg2: int, arg3: int, arg4: float) → None¶; Displaces one coordinate of single atom. psi4.core.dmrg(arg0: psi::Wavefunction) → float¶; Runs the DMRG code. psi4.core.efp_init() → psi4.core.EFP¶; Initializes the EFP library and returns an EFP object. psi4.core.efp_set_options() → None¶; Set EFP options from environment options object. psi4.core.fcidump_tei_helper(nirrep: int, restricted: bool, DPD_info: Dict[str",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:226044,Modifiability,config,configuration,226044,"e the similarity transformed Hamiltonian. psi4.core.cclambda(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the coupled cluster lambda equations code. psi4.core.ccresponse(arg0: psi::Wavefunction) → float¶; Runs the coupled cluster response theory code. psi4.core.cctransort(arg0: psi::Wavefunction) → None¶; Runs CCTRANSORT, which transforms and reorders integrals for use in the coupled cluster codes. psi4.core.cctriples(arg0: psi::Wavefunction) → float¶; Runs the coupled cluster (T) energy code. psi4.core.clean() → None¶; Function to remove scratch files. Call between independent jobs. psi4.core.clean_options() → None¶; Function to reset options to clean state. psi4.core.clean_variables() → None¶; Empties all PSI variables that have set internally. psi4.core.close_outfile() → None¶; Closes the output file. psi4.core.dcft(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the density cumulant functional theory code. psi4.core.detci(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the determinant-based configuration interaction code. psi4.core.dfmp2(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the DF-MP2 code. psi4.core.dfocc(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the density-fitted orbital optimized CC codes. psi4.core.displace_atom(arg0: psi::Matrix, arg1: int, arg2: int, arg3: int, arg4: float) → None¶; Displaces one coordinate of single atom. psi4.core.dmrg(arg0: psi::Wavefunction) → float¶; Runs the DMRG code. psi4.core.efp_init() → psi4.core.EFP¶; Initializes the EFP library and returns an EFP object. psi4.core.efp_set_options() → None¶; Set EFP options from environment options object. psi4.core.fcidump_tei_helper(nirrep: int, restricted: bool, DPD_info: Dict[str, int], ints_tolerance: float, fname: str='INTDUMP') → None¶; Write integrals to file in FCIDUMP format. psi4.core.fd_1_0(arg0: psi::Molecule, arg1: list) → psi::Matrix¶; Performs a finite difference gradient computation, from energy points. psi4.core.fd_freq_0(arg0: psi::Mole",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:228351,Modifiability,variab,variables,228351,"st[psi::Matrix]¶; Gets list of displacements needed for a finite difference gradient computation, from energy points. psi4.core.fd_geoms_freq_0(arg0: psi::Molecule, arg1: int) → List[psi::Matrix]¶; Gets list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep. psi4.core.fd_geoms_freq_1(arg0: psi::Molecule, arg1: int) → List[psi::Matrix]¶; Gets list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep. psi4.core.finalize() → None¶. psi4.core.flush_outfile() → None¶; Flushes the output file. psi4.core.fnocc(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the fno-ccsd(t)/qcisd(t)/mp4/cepa energy code. psi4.core.get_active_efp() → psi4.core.EFP¶; Returns the currently active EFP object. psi4.core.get_active_molecule() → psi::Molecule¶; Returns the currently active molecule object. psi4.core.get_array_variable(arg0: str) → psi::Matrix¶; Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available). psi4.core.get_array_variables() → Dict[str, psi::Matrix]¶; Returns dictionary of the PSI variables set internally by the modules or python driver. psi4.core.get_atomic_point_charges() → psi::Vector¶; Returns the most recently computed atomic point charges, as a double * object. psi4.core.get_datadir() → str¶; Sets the path to shared text resources, PSIDATADIR. psi4.core.get_efp_torque() → psi::Matrix¶; Returns the most recently computed gradient for the EFP portion, as a Nefp by 6 Matrix object. psi4.core.get_frequencies() → psi::Vector¶; Returns the most recently computed frequencies, as a 3N-6 Vector object. psi4.core.get_global_option(arg0: str) → object¶; Given a string of a keyword name arg1, returns the value associated with the keyword from the global options. Returns error if keyword is not recognized. psi4.core.get_global_option_list() → List[str]¶; Returns a list of all global options. p",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:228440,Modifiability,variab,variables,228440,"st[psi::Matrix]¶; Gets list of displacements needed for a finite difference gradient computation, from energy points. psi4.core.fd_geoms_freq_0(arg0: psi::Molecule, arg1: int) → List[psi::Matrix]¶; Gets list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep. psi4.core.fd_geoms_freq_1(arg0: psi::Molecule, arg1: int) → List[psi::Matrix]¶; Gets list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep. psi4.core.finalize() → None¶. psi4.core.flush_outfile() → None¶; Flushes the output file. psi4.core.fnocc(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the fno-ccsd(t)/qcisd(t)/mp4/cepa energy code. psi4.core.get_active_efp() → psi4.core.EFP¶; Returns the currently active EFP object. psi4.core.get_active_molecule() → psi::Molecule¶; Returns the currently active molecule object. psi4.core.get_array_variable(arg0: str) → psi::Matrix¶; Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available). psi4.core.get_array_variables() → Dict[str, psi::Matrix]¶; Returns dictionary of the PSI variables set internally by the modules or python driver. psi4.core.get_atomic_point_charges() → psi::Vector¶; Returns the most recently computed atomic point charges, as a double * object. psi4.core.get_datadir() → str¶; Sets the path to shared text resources, PSIDATADIR. psi4.core.get_efp_torque() → psi::Matrix¶; Returns the most recently computed gradient for the EFP portion, as a Nefp by 6 Matrix object. psi4.core.get_frequencies() → psi::Vector¶; Returns the most recently computed frequencies, as a 3N-6 Vector object. psi4.core.get_global_option(arg0: str) → object¶; Given a string of a keyword name arg1, returns the value associated with the keyword from the global options. Returns error if keyword is not recognized. psi4.core.get_global_option_list() → List[str]¶; Returns a list of all global options. p",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:228551,Modifiability,variab,variables,228551,": int) → List[psi::Matrix]¶; Gets list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep. psi4.core.fd_geoms_freq_1(arg0: psi::Molecule, arg1: int) → List[psi::Matrix]¶; Gets list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep. psi4.core.finalize() → None¶. psi4.core.flush_outfile() → None¶; Flushes the output file. psi4.core.fnocc(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the fno-ccsd(t)/qcisd(t)/mp4/cepa energy code. psi4.core.get_active_efp() → psi4.core.EFP¶; Returns the currently active EFP object. psi4.core.get_active_molecule() → psi::Molecule¶; Returns the currently active molecule object. psi4.core.get_array_variable(arg0: str) → psi::Matrix¶; Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available). psi4.core.get_array_variables() → Dict[str, psi::Matrix]¶; Returns dictionary of the PSI variables set internally by the modules or python driver. psi4.core.get_atomic_point_charges() → psi::Vector¶; Returns the most recently computed atomic point charges, as a double * object. psi4.core.get_datadir() → str¶; Sets the path to shared text resources, PSIDATADIR. psi4.core.get_efp_torque() → psi::Matrix¶; Returns the most recently computed gradient for the EFP portion, as a Nefp by 6 Matrix object. psi4.core.get_frequencies() → psi::Vector¶; Returns the most recently computed frequencies, as a 3N-6 Vector object. psi4.core.get_global_option(arg0: str) → object¶; Given a string of a keyword name arg1, returns the value associated with the keyword from the global options. Returns error if keyword is not recognized. psi4.core.get_global_option_list() → List[str]¶; Returns a list of all global options. psi4.core.get_gradient() → psi::Matrix¶; Returns the most recently computed gradient, as a N by 3 Matrix object. psi4.core.get_legacy_molecule() → psi::Molecule¶; Return",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:230558,Modifiability,variab,variables,230558,".core.get_local_option(arg0: str, arg1: str) → object¶; Given a string of a keyword name arg2 and a particular module arg1, returns the value associated with the keyword in the module options scope. Returns error if keyword is not recognized for the module. psi4.core.get_memory() → int¶; Returns the amount of memory available to Psi (in bytes). psi4.core.get_num_threads() → int¶; Returns the number of threads to use in SMP parallel computations. psi4.core.get_option(arg0: str, arg1: str) → object¶; Given a string of a keyword name arg2 and a particular module arg1, returns the local value associated with the keyword if it’s been set, else the global value if it’s been set, else the local core.default value. Returns error if keyword is not recognized globally or if keyword is not recognized for the module. psi4.core.get_options() → psi::Options¶; Get options. psi4.core.get_output_file() → str¶. psi4.core.get_variable(arg0: str) → float¶; Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available). psi4.core.get_variables() → Dict[str, float]¶; Returns dictionary of the PSI variables set internally by the modules or python driver. psi4.core.get_writer_file_prefix(arg0: str) → str¶; Returns the prefix to use for writing files for external programs. psi4.core.git_version() → str¶; Returns the git version of this copy of Psi. psi4.core.has_global_option_changed(arg0: str) → bool¶; Returns boolean for whether the keyword arg1 has been touched in the global scope, by either user or code. Notwithstanding, code is written such that in practice, this returns whether the option has been touched in the global scope by the user. psi4.core.has_local_option_changed(arg0: str, arg1: str) → bool¶; Returns boolean for whether the keyword arg2 has been touched in the scope of the specified module arg1, by either user or code. Notwithstanding, code is written such that in practice, this returns whether the option h",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:230647,Modifiability,variab,variables,230647,".core.get_local_option(arg0: str, arg1: str) → object¶; Given a string of a keyword name arg2 and a particular module arg1, returns the value associated with the keyword in the module options scope. Returns error if keyword is not recognized for the module. psi4.core.get_memory() → int¶; Returns the amount of memory available to Psi (in bytes). psi4.core.get_num_threads() → int¶; Returns the number of threads to use in SMP parallel computations. psi4.core.get_option(arg0: str, arg1: str) → object¶; Given a string of a keyword name arg2 and a particular module arg1, returns the local value associated with the keyword if it’s been set, else the global value if it’s been set, else the local core.default value. Returns error if keyword is not recognized globally or if keyword is not recognized for the module. psi4.core.get_options() → psi::Options¶; Get options. psi4.core.get_output_file() → str¶. psi4.core.get_variable(arg0: str) → float¶; Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available). psi4.core.get_variables() → Dict[str, float]¶; Returns dictionary of the PSI variables set internally by the modules or python driver. psi4.core.get_writer_file_prefix(arg0: str) → str¶; Returns the prefix to use for writing files for external programs. psi4.core.git_version() → str¶; Returns the git version of this copy of Psi. psi4.core.has_global_option_changed(arg0: str) → bool¶; Returns boolean for whether the keyword arg1 has been touched in the global scope, by either user or code. Notwithstanding, code is written such that in practice, this returns whether the option has been touched in the global scope by the user. psi4.core.has_local_option_changed(arg0: str, arg1: str) → bool¶; Returns boolean for whether the keyword arg2 has been touched in the scope of the specified module arg1, by either user or code. Notwithstanding, code is written such that in practice, this returns whether the option h",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:230746,Modifiability,variab,variables,230746," the keyword in the module options scope. Returns error if keyword is not recognized for the module. psi4.core.get_memory() → int¶; Returns the amount of memory available to Psi (in bytes). psi4.core.get_num_threads() → int¶; Returns the number of threads to use in SMP parallel computations. psi4.core.get_option(arg0: str, arg1: str) → object¶; Given a string of a keyword name arg2 and a particular module arg1, returns the local value associated with the keyword if it’s been set, else the global value if it’s been set, else the local core.default value. Returns error if keyword is not recognized globally or if keyword is not recognized for the module. psi4.core.get_options() → psi::Options¶; Get options. psi4.core.get_output_file() → str¶. psi4.core.get_variable(arg0: str) → float¶; Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available). psi4.core.get_variables() → Dict[str, float]¶; Returns dictionary of the PSI variables set internally by the modules or python driver. psi4.core.get_writer_file_prefix(arg0: str) → str¶; Returns the prefix to use for writing files for external programs. psi4.core.git_version() → str¶; Returns the git version of this copy of Psi. psi4.core.has_global_option_changed(arg0: str) → bool¶; Returns boolean for whether the keyword arg1 has been touched in the global scope, by either user or code. Notwithstanding, code is written such that in practice, this returns whether the option has been touched in the global scope by the user. psi4.core.has_local_option_changed(arg0: str, arg1: str) → bool¶; Returns boolean for whether the keyword arg2 has been touched in the scope of the specified module arg1, by either user or code. Notwithstanding, code is written such that in practice, this returns whether the option has been touched in the module scope by the user. psi4.core.has_option_changed(arg0: str, arg1: str) → bool¶; Returns boolean for whether the option arg2 has",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:232021,Modifiability,variab,variable,232021,".core.has_global_option_changed(arg0: str) → bool¶; Returns boolean for whether the keyword arg1 has been touched in the global scope, by either user or code. Notwithstanding, code is written such that in practice, this returns whether the option has been touched in the global scope by the user. psi4.core.has_local_option_changed(arg0: str, arg1: str) → bool¶; Returns boolean for whether the keyword arg2 has been touched in the scope of the specified module arg1, by either user or code. Notwithstanding, code is written such that in practice, this returns whether the option has been touched in the module scope by the user. psi4.core.has_option_changed(arg0: str, arg1: str) → bool¶; Returns boolean for whether the option arg2 has been touched either locally to the specified module arg1 or globally, by either user or code. Notwithstanding, code is written such that in practice, this returns whether the option has been touched by the user. psi4.core.has_variable(arg0: str) → bool¶; Returns true if the PSI variable exists/is set. psi4.core.initialize() → bool¶. psi4.core.legacy_wavefunction() → psi::Wavefunction¶; Returns the current legacy_wavefunction object from the most recent computation. psi4.core.libfock(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs a CPHF calculation, using libfock. psi4.core.mcscf(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the MCSCF code, (N.B. restricted to certain active spaces). psi4.core.mrcc_generate_input(arg0: psi::Wavefunction, arg1: dict) → psi4.core.PsiReturnType¶; Generates an input for Kallay’s MRCC code. psi4.core.mrcc_load_densities(arg0: psi::Wavefunction, arg1: dict) → psi4.core.PsiReturnType¶; Reads in the density matrices from Kallay’s MRCC code. psi4.core.occ(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the orbital optimized CC codes. psi4.core.opt_clean() → None¶; Cleans up the optimizer’s scratch files. psi4.core.option_exists_in_module(arg0: str, arg1: str) → bool¶; Given a string of a keyword name arg",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:233251,Modifiability,plugin,plugin,233251,"on, using libfock. psi4.core.mcscf(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the MCSCF code, (N.B. restricted to certain active spaces). psi4.core.mrcc_generate_input(arg0: psi::Wavefunction, arg1: dict) → psi4.core.PsiReturnType¶; Generates an input for Kallay’s MRCC code. psi4.core.mrcc_load_densities(arg0: psi::Wavefunction, arg1: dict) → psi4.core.PsiReturnType¶; Reads in the density matrices from Kallay’s MRCC code. psi4.core.occ(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the orbital optimized CC codes. psi4.core.opt_clean() → None¶; Cleans up the optimizer’s scratch files. psi4.core.option_exists_in_module(arg0: str, arg1: str) → bool¶; Given a string of a keyword name arg1 and a particular module arg0, returns whether arg1 is a valid option for arg0. psi4.core.optking() → int¶; Runs the geometry optimization / frequency analysis code. psi4.core.outfile_name() → str¶; Returns the name of the output file. psi4.core.plugin(arg0: str, arg1: psi::Wavefunction) → psi::Wavefunction¶; Call the plugin of name arg0. Returns the plugin code result. psi4.core.plugin_close(arg0: str) → None¶; Close the plugin of name arg0. psi4.core.plugin_close_all() → None¶; Close all open plugins. psi4.core.plugin_load(arg0: str) → int¶; Load the plugin of name arg0. Returns 0 if not loaded, 1 if loaded, 2 if already loaded. psi4.core.prepare_options_for_module(arg0: str) → None¶; Sets the options module up to return options pertaining to the named argument (e.g. SCF). psi4.core.print_global_options() → None¶; Prints the currently set global (all modules) options to the output file. psi4.core.print_options() → None¶; Prints the currently set options (to the output file) for the current module. psi4.core.print_out(arg0: str) → None¶; Prints a string (using sprintf-like notation) to the output file. psi4.core.print_variables() → None¶; Prints all PSI variables that have been set internally. psi4.core.psi_top_srcdir() → str¶; Returns the location of the source code. psi",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:233325,Modifiability,plugin,plugin,233325,"on, using libfock. psi4.core.mcscf(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the MCSCF code, (N.B. restricted to certain active spaces). psi4.core.mrcc_generate_input(arg0: psi::Wavefunction, arg1: dict) → psi4.core.PsiReturnType¶; Generates an input for Kallay’s MRCC code. psi4.core.mrcc_load_densities(arg0: psi::Wavefunction, arg1: dict) → psi4.core.PsiReturnType¶; Reads in the density matrices from Kallay’s MRCC code. psi4.core.occ(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the orbital optimized CC codes. psi4.core.opt_clean() → None¶; Cleans up the optimizer’s scratch files. psi4.core.option_exists_in_module(arg0: str, arg1: str) → bool¶; Given a string of a keyword name arg1 and a particular module arg0, returns whether arg1 is a valid option for arg0. psi4.core.optking() → int¶; Runs the geometry optimization / frequency analysis code. psi4.core.outfile_name() → str¶; Returns the name of the output file. psi4.core.plugin(arg0: str, arg1: psi::Wavefunction) → psi::Wavefunction¶; Call the plugin of name arg0. Returns the plugin code result. psi4.core.plugin_close(arg0: str) → None¶; Close the plugin of name arg0. psi4.core.plugin_close_all() → None¶; Close all open plugins. psi4.core.plugin_load(arg0: str) → int¶; Load the plugin of name arg0. Returns 0 if not loaded, 1 if loaded, 2 if already loaded. psi4.core.prepare_options_for_module(arg0: str) → None¶; Sets the options module up to return options pertaining to the named argument (e.g. SCF). psi4.core.print_global_options() → None¶; Prints the currently set global (all modules) options to the output file. psi4.core.print_options() → None¶; Prints the currently set options (to the output file) for the current module. psi4.core.print_out(arg0: str) → None¶; Prints a string (using sprintf-like notation) to the output file. psi4.core.print_variables() → None¶; Prints all PSI variables that have been set internally. psi4.core.psi_top_srcdir() → str¶; Returns the location of the source code. psi",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:233358,Modifiability,plugin,plugin,233358,"si::Wavefunction¶; Runs the MCSCF code, (N.B. restricted to certain active spaces). psi4.core.mrcc_generate_input(arg0: psi::Wavefunction, arg1: dict) → psi4.core.PsiReturnType¶; Generates an input for Kallay’s MRCC code. psi4.core.mrcc_load_densities(arg0: psi::Wavefunction, arg1: dict) → psi4.core.PsiReturnType¶; Reads in the density matrices from Kallay’s MRCC code. psi4.core.occ(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the orbital optimized CC codes. psi4.core.opt_clean() → None¶; Cleans up the optimizer’s scratch files. psi4.core.option_exists_in_module(arg0: str, arg1: str) → bool¶; Given a string of a keyword name arg1 and a particular module arg0, returns whether arg1 is a valid option for arg0. psi4.core.optking() → int¶; Runs the geometry optimization / frequency analysis code. psi4.core.outfile_name() → str¶; Returns the name of the output file. psi4.core.plugin(arg0: str, arg1: psi::Wavefunction) → psi::Wavefunction¶; Call the plugin of name arg0. Returns the plugin code result. psi4.core.plugin_close(arg0: str) → None¶; Close the plugin of name arg0. psi4.core.plugin_close_all() → None¶; Close all open plugins. psi4.core.plugin_load(arg0: str) → int¶; Load the plugin of name arg0. Returns 0 if not loaded, 1 if loaded, 2 if already loaded. psi4.core.prepare_options_for_module(arg0: str) → None¶; Sets the options module up to return options pertaining to the named argument (e.g. SCF). psi4.core.print_global_options() → None¶; Prints the currently set global (all modules) options to the output file. psi4.core.print_options() → None¶; Prints the currently set options (to the output file) for the current module. psi4.core.print_out(arg0: str) → None¶; Prints a string (using sprintf-like notation) to the output file. psi4.core.print_variables() → None¶; Prints all PSI variables that have been set internally. psi4.core.psi_top_srcdir() → str¶; Returns the location of the source code. psi4.core.psimrcc(arg0: psi::Wavefunction) → float¶; Runs the mult",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:233431,Modifiability,plugin,plugin,233431,"o certain active spaces). psi4.core.mrcc_generate_input(arg0: psi::Wavefunction, arg1: dict) → psi4.core.PsiReturnType¶; Generates an input for Kallay’s MRCC code. psi4.core.mrcc_load_densities(arg0: psi::Wavefunction, arg1: dict) → psi4.core.PsiReturnType¶; Reads in the density matrices from Kallay’s MRCC code. psi4.core.occ(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the orbital optimized CC codes. psi4.core.opt_clean() → None¶; Cleans up the optimizer’s scratch files. psi4.core.option_exists_in_module(arg0: str, arg1: str) → bool¶; Given a string of a keyword name arg1 and a particular module arg0, returns whether arg1 is a valid option for arg0. psi4.core.optking() → int¶; Runs the geometry optimization / frequency analysis code. psi4.core.outfile_name() → str¶; Returns the name of the output file. psi4.core.plugin(arg0: str, arg1: psi::Wavefunction) → psi::Wavefunction¶; Call the plugin of name arg0. Returns the plugin code result. psi4.core.plugin_close(arg0: str) → None¶; Close the plugin of name arg0. psi4.core.plugin_close_all() → None¶; Close all open plugins. psi4.core.plugin_load(arg0: str) → int¶; Load the plugin of name arg0. Returns 0 if not loaded, 1 if loaded, 2 if already loaded. psi4.core.prepare_options_for_module(arg0: str) → None¶; Sets the options module up to return options pertaining to the named argument (e.g. SCF). psi4.core.print_global_options() → None¶; Prints the currently set global (all modules) options to the output file. psi4.core.print_options() → None¶; Prints the currently set options (to the output file) for the current module. psi4.core.print_out(arg0: str) → None¶; Prints a string (using sprintf-like notation) to the output file. psi4.core.print_variables() → None¶; Prints all PSI variables that have been set internally. psi4.core.psi_top_srcdir() → str¶; Returns the location of the source code. psi4.core.psimrcc(arg0: psi::Wavefunction) → float¶; Runs the multireference coupled cluster code. psi4.core.reopen_outfile()",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:233505,Modifiability,plugin,plugins,233505,"avefunction, arg1: dict) → psi4.core.PsiReturnType¶; Generates an input for Kallay’s MRCC code. psi4.core.mrcc_load_densities(arg0: psi::Wavefunction, arg1: dict) → psi4.core.PsiReturnType¶; Reads in the density matrices from Kallay’s MRCC code. psi4.core.occ(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the orbital optimized CC codes. psi4.core.opt_clean() → None¶; Cleans up the optimizer’s scratch files. psi4.core.option_exists_in_module(arg0: str, arg1: str) → bool¶; Given a string of a keyword name arg1 and a particular module arg0, returns whether arg1 is a valid option for arg0. psi4.core.optking() → int¶; Runs the geometry optimization / frequency analysis code. psi4.core.outfile_name() → str¶; Returns the name of the output file. psi4.core.plugin(arg0: str, arg1: psi::Wavefunction) → psi::Wavefunction¶; Call the plugin of name arg0. Returns the plugin code result. psi4.core.plugin_close(arg0: str) → None¶; Close the plugin of name arg0. psi4.core.plugin_close_all() → None¶; Close all open plugins. psi4.core.plugin_load(arg0: str) → int¶; Load the plugin of name arg0. Returns 0 if not loaded, 1 if loaded, 2 if already loaded. psi4.core.prepare_options_for_module(arg0: str) → None¶; Sets the options module up to return options pertaining to the named argument (e.g. SCF). psi4.core.print_global_options() → None¶; Prints the currently set global (all modules) options to the output file. psi4.core.print_options() → None¶; Prints the currently set options (to the output file) for the current module. psi4.core.print_out(arg0: str) → None¶; Prints a string (using sprintf-like notation) to the output file. psi4.core.print_variables() → None¶; Prints all PSI variables that have been set internally. psi4.core.psi_top_srcdir() → str¶; Returns the location of the source code. psi4.core.psimrcc(arg0: psi::Wavefunction) → float¶; Runs the multireference coupled cluster code. psi4.core.reopen_outfile() → None¶; Reopens the output file. psi4.core.revoke_global_option_ch",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:233564,Modifiability,plugin,plugin,233564,"nput for Kallay’s MRCC code. psi4.core.mrcc_load_densities(arg0: psi::Wavefunction, arg1: dict) → psi4.core.PsiReturnType¶; Reads in the density matrices from Kallay’s MRCC code. psi4.core.occ(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the orbital optimized CC codes. psi4.core.opt_clean() → None¶; Cleans up the optimizer’s scratch files. psi4.core.option_exists_in_module(arg0: str, arg1: str) → bool¶; Given a string of a keyword name arg1 and a particular module arg0, returns whether arg1 is a valid option for arg0. psi4.core.optking() → int¶; Runs the geometry optimization / frequency analysis code. psi4.core.outfile_name() → str¶; Returns the name of the output file. psi4.core.plugin(arg0: str, arg1: psi::Wavefunction) → psi::Wavefunction¶; Call the plugin of name arg0. Returns the plugin code result. psi4.core.plugin_close(arg0: str) → None¶; Close the plugin of name arg0. psi4.core.plugin_close_all() → None¶; Close all open plugins. psi4.core.plugin_load(arg0: str) → int¶; Load the plugin of name arg0. Returns 0 if not loaded, 1 if loaded, 2 if already loaded. psi4.core.prepare_options_for_module(arg0: str) → None¶; Sets the options module up to return options pertaining to the named argument (e.g. SCF). psi4.core.print_global_options() → None¶; Prints the currently set global (all modules) options to the output file. psi4.core.print_options() → None¶; Prints the currently set options (to the output file) for the current module. psi4.core.print_out(arg0: str) → None¶; Prints a string (using sprintf-like notation) to the output file. psi4.core.print_variables() → None¶; Prints all PSI variables that have been set internally. psi4.core.psi_top_srcdir() → str¶; Returns the location of the source code. psi4.core.psimrcc(arg0: psi::Wavefunction) → float¶; Runs the multireference coupled cluster code. psi4.core.reopen_outfile() → None¶; Reopens the output file. psi4.core.revoke_global_option_changed(arg0: str) → None¶; Given a string of a keyword name arg1, s",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:234178,Modifiability,variab,variables,234178,"ore.outfile_name() → str¶; Returns the name of the output file. psi4.core.plugin(arg0: str, arg1: psi::Wavefunction) → psi::Wavefunction¶; Call the plugin of name arg0. Returns the plugin code result. psi4.core.plugin_close(arg0: str) → None¶; Close the plugin of name arg0. psi4.core.plugin_close_all() → None¶; Close all open plugins. psi4.core.plugin_load(arg0: str) → int¶; Load the plugin of name arg0. Returns 0 if not loaded, 1 if loaded, 2 if already loaded. psi4.core.prepare_options_for_module(arg0: str) → None¶; Sets the options module up to return options pertaining to the named argument (e.g. SCF). psi4.core.print_global_options() → None¶; Prints the currently set global (all modules) options to the output file. psi4.core.print_options() → None¶; Prints the currently set options (to the output file) for the current module. psi4.core.print_out(arg0: str) → None¶; Prints a string (using sprintf-like notation) to the output file. psi4.core.print_variables() → None¶; Prints all PSI variables that have been set internally. psi4.core.psi_top_srcdir() → str¶; Returns the location of the source code. psi4.core.psimrcc(arg0: psi::Wavefunction) → float¶; Runs the multireference coupled cluster code. psi4.core.reopen_outfile() → None¶; Reopens the output file. psi4.core.revoke_global_option_changed(arg0: str) → None¶; Given a string of a keyword name arg1, sets the has_changed attribute in the global options scope to false. Used in python driver when a function sets the value of an option. Before the function exits, this command is called on the option so that has_changed reflects whether the user (not the program) has touched the option. psi4.core.revoke_local_option_changed(arg0: str, arg1: str) → None¶; Given a string of a keyword name arg2 and a particular module arg1, sets the has_changed attribute in the module options scope to false. Used in python driver when a function sets the value of an option. Before the function exits, this command is called on the option",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:235469,Modifiability,adapt,adapted,235469,"eopens the output file. psi4.core.revoke_global_option_changed(arg0: str) → None¶; Given a string of a keyword name arg1, sets the has_changed attribute in the global options scope to false. Used in python driver when a function sets the value of an option. Before the function exits, this command is called on the option so that has_changed reflects whether the user (not the program) has touched the option. psi4.core.revoke_local_option_changed(arg0: str, arg1: str) → None¶; Given a string of a keyword name arg2 and a particular module arg1, sets the has_changed attribute in the module options scope to false. Used in python driver when a function sets the value of an option. Before the function exits, this command is called on the option so that has_changed reflects whether the user (not the program) has touched the option. psi4.core.run_gdma(arg0: psi::Wavefunction, arg1: str) → float¶; Runs the GDMA code. psi4.core.sapt(arg0: psi::Wavefunction, arg1: psi::Wavefunction, arg2: psi::Wavefunction) → float¶; Runs the symmetry adapted perturbation theory code. psi4.core.scatter(arg0: psi::Molecule, arg1: float, arg2: list, arg3: list, arg4: list) → None¶; New Scatter function. psi4.core.scfgrad(arg0: psi::Wavefunction) → psi::Matrix¶; Run scfgrad, which is a specialized DF-SCF gradient program. psi4.core.scfhess(arg0: psi::Wavefunction) → psi::Matrix¶; Run scfhess, which is a specialized DF-SCF hessian program. psi4.core.set_active_molecule(arg0: psi::Molecule) → None¶; Activates a previously defined (in the input) molecule, by name. psi4.core.set_array_variable(arg0: str, arg1: psi::Matrix) → None¶; Sets a PSI variable, by name. psi4.core.set_datadir(arg0: str) → None¶; Returns the amount of memory available to Psi (in bytes). psi4.core.set_efp_torque(arg0: psi::Matrix) → None¶; Assigns the global EFP gradient to the values stored in the Nefp by 6 Matrix argument. psi4.core.set_frequencies(arg0: psi::Vector) → None¶; Assigns the global frequencies to the values stored in",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:236065,Modifiability,variab,variable,236065," false. Used in python driver when a function sets the value of an option. Before the function exits, this command is called on the option so that has_changed reflects whether the user (not the program) has touched the option. psi4.core.run_gdma(arg0: psi::Wavefunction, arg1: str) → float¶; Runs the GDMA code. psi4.core.sapt(arg0: psi::Wavefunction, arg1: psi::Wavefunction, arg2: psi::Wavefunction) → float¶; Runs the symmetry adapted perturbation theory code. psi4.core.scatter(arg0: psi::Molecule, arg1: float, arg2: list, arg3: list, arg4: list) → None¶; New Scatter function. psi4.core.scfgrad(arg0: psi::Wavefunction) → psi::Matrix¶; Run scfgrad, which is a specialized DF-SCF gradient program. psi4.core.scfhess(arg0: psi::Wavefunction) → psi::Matrix¶; Run scfhess, which is a specialized DF-SCF hessian program. psi4.core.set_active_molecule(arg0: psi::Molecule) → None¶; Activates a previously defined (in the input) molecule, by name. psi4.core.set_array_variable(arg0: str, arg1: psi::Matrix) → None¶; Sets a PSI variable, by name. psi4.core.set_datadir(arg0: str) → None¶; Returns the amount of memory available to Psi (in bytes). psi4.core.set_efp_torque(arg0: psi::Matrix) → None¶; Assigns the global EFP gradient to the values stored in the Nefp by 6 Matrix argument. psi4.core.set_frequencies(arg0: psi::Vector) → None¶; Assigns the global frequencies to the values stored in the 3N-6 Vector argument. psi4.core.set_global_option(*args, **kwargs)¶; Overloaded function. set_global_option(arg0: str, arg1: list) -> bool. Sets value arg2 to array keyword arg1 for all modules. set_global_option(arg0: str, arg1: int) -> bool. Sets value arg2 to integer keyword arg1 for all modules. set_global_option(arg0: str, arg1: float) -> bool. Sets value arg2 to double keyword arg1 for all modules. set_global_option(arg0: str, arg1: str) -> bool. Sets value arg2 to string keyword arg1 for all modules. psi4.core.set_gradient(arg0: psi::Matrix) → None¶; Assigns the global gradient to the valu",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:238808,Modifiability,variab,variable,238808,"ord arg2 scoped only to a specific module arg1. set_local_option(arg0: str, arg1: str, arg2: str) -> bool. Sets value arg3 to string keyword arg2 scoped only to a specific module arg1. psi4.core.set_local_option_python(arg0: str, arg1: object) → None¶; Sets an option to a Python object, but scoped only to a single module. psi4.core.set_memory_bytes(memory: int, quiet: bool=False) → None¶; Sets the memory available to Psi (in bytes). psi4.core.set_num_threads(nthread: int, quiet: bool=False) → None¶; Sets the number of threads to use in SMP parallel computations. psi4.core.set_output_file(*args, **kwargs)¶; Overloaded function. set_output_file(arg0: str) -> None; set_output_file(arg0: str, arg1: bool) -> None. psi4.core.set_parent_symmetry(arg0: str) → None¶; Sets the symmetry of the ‘parent’ (undisplaced) geometry, by Schoenflies symbol, at the beginning of a finite difference computation. psi4.core.set_psi_file_prefix(arg0: str) → None¶. psi4.core.set_variable(arg0: str, arg1: float) → None¶; Sets a PSI variable, by name. psi4.core.tstart() → None¶; docstring. psi4.core.tstop() → None¶; docstring. psi4.core.version() → str¶; Returns the version ID of this copy of Psi. Functions¶. DASUM(arg0, arg1, arg2, arg3); docstring. DAXPY(arg0, arg1, arg2, arg3, arg4, arg5, arg6); docstring. DCOPY(arg0, arg1, arg2, arg3, arg4, arg5); docstring. DDOT(arg0, arg1, arg2, arg3, arg4, arg5); docstring. DGBMV(arg0, arg1, arg2, arg3, arg4, arg5, …); docstring. DGEEV(arg0, arg1, arg2, arg3, arg4, arg5, …); docstring. DGEMM(arg0, arg1, arg2, arg3, arg4, arg5, …); docstring. DGEMV(arg0, arg1, arg2, arg3, arg4, arg5, …); docstring. DGER(arg0, arg1, arg2, arg3, arg4, arg5, …); docstring. DGETRF(arg0, arg1, arg2, arg3, arg4, arg5); docstring. DGETRI(arg0, arg1, arg2, arg3, arg4, arg5, arg6); docstring. DGETRS(arg0, arg1, arg2, arg3, arg4, arg5, …); docstring. DNRM2(arg0, arg1, arg2, arg3); docstring. DPOTRF(arg0, arg1, arg2, arg3, arg4); docstring. DPOTRI(arg0, arg1, arg2, arg3, arg4); docst",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:242109,Modifiability,variab,variables,242109,"irects output to /dev/null. benchmark_blas1(arg0, arg1); docstring. benchmark_blas2(arg0, arg1); docstring. benchmark_blas3(arg0, arg1, arg2); docstring. benchmark_disk(arg0, arg1); docstring. benchmark_integrals(arg0, arg1); docstring. benchmark_math(arg0); docstring. ccdensity(arg0); Runs the code to compute coupled cluster density matrices. ccenergy(arg0); Runs the coupled cluster energy code. cceom(arg0); Runs the equation of motion coupled cluster code, for excited states. cchbar(arg0); Runs the code to generate the similarity transformed Hamiltonian. cclambda(arg0); Runs the coupled cluster lambda equations code. ccresponse(arg0); Runs the coupled cluster response theory code. cctransort(arg0); Runs CCTRANSORT, which transforms and reorders integrals for use in the coupled cluster codes. cctriples(arg0); Runs the coupled cluster (T) energy code. clean(); Function to remove scratch files. clean_options(); Function to reset options to clean state. clean_variables(); Empties all PSI variables that have set internally. close_outfile(); Closes the output file. dcft(arg0); Runs the density cumulant functional theory code. detci(arg0); Runs the determinant-based configuration interaction code. dfmp2(arg0); Runs the DF-MP2 code. dfocc(arg0); Runs the density-fitted orbital optimized CC codes. displace_atom(arg0, arg1, arg2, arg3, arg4); Displaces one coordinate of single atom. dmrg(arg0); Runs the DMRG code. efp_init(); Initializes the EFP library and returns an EFP object. efp_set_options(); Set EFP options from environment options object. fcidump_tei_helper(nirrep, restricted, …); Write integrals to file in FCIDUMP format. fd_1_0(arg0, arg1); Performs a finite difference gradient computation, from energy points. fd_freq_0(arg0, arg1, arg2); Performs a finite difference frequency computation, from energy points, for a given irrep. fd_freq_1(arg0, arg1, arg2); Performs a finite difference frequency computation, from gradients, for a given irrep. fd_geoms_1_0(arg0); Get",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:242288,Modifiability,config,configuration,242288,"arg1); docstring. benchmark_integrals(arg0, arg1); docstring. benchmark_math(arg0); docstring. ccdensity(arg0); Runs the code to compute coupled cluster density matrices. ccenergy(arg0); Runs the coupled cluster energy code. cceom(arg0); Runs the equation of motion coupled cluster code, for excited states. cchbar(arg0); Runs the code to generate the similarity transformed Hamiltonian. cclambda(arg0); Runs the coupled cluster lambda equations code. ccresponse(arg0); Runs the coupled cluster response theory code. cctransort(arg0); Runs CCTRANSORT, which transforms and reorders integrals for use in the coupled cluster codes. cctriples(arg0); Runs the coupled cluster (T) energy code. clean(); Function to remove scratch files. clean_options(); Function to reset options to clean state. clean_variables(); Empties all PSI variables that have set internally. close_outfile(); Closes the output file. dcft(arg0); Runs the density cumulant functional theory code. detci(arg0); Runs the determinant-based configuration interaction code. dfmp2(arg0); Runs the DF-MP2 code. dfocc(arg0); Runs the density-fitted orbital optimized CC codes. displace_atom(arg0, arg1, arg2, arg3, arg4); Displaces one coordinate of single atom. dmrg(arg0); Runs the DMRG code. efp_init(); Initializes the EFP library and returns an EFP object. efp_set_options(); Set EFP options from environment options object. fcidump_tei_helper(nirrep, restricted, …); Write integrals to file in FCIDUMP format. fd_1_0(arg0, arg1); Performs a finite difference gradient computation, from energy points. fd_freq_0(arg0, arg1, arg2); Performs a finite difference frequency computation, from energy points, for a given irrep. fd_freq_1(arg0, arg1, arg2); Performs a finite difference frequency computation, from gradients, for a given irrep. fd_geoms_1_0(arg0); Gets list of displacements needed for a finite difference gradient computation, from energy points. fd_geoms_freq_0(arg0, arg1); Gets list of displacements needed for a finite d",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:243796,Modifiability,variab,variables,243796,"on, from energy points. fd_freq_0(arg0, arg1, arg2); Performs a finite difference frequency computation, from energy points, for a given irrep. fd_freq_1(arg0, arg1, arg2); Performs a finite difference frequency computation, from gradients, for a given irrep. fd_geoms_1_0(arg0); Gets list of displacements needed for a finite difference gradient computation, from energy points. fd_geoms_freq_0(arg0, arg1); Gets list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep. fd_geoms_freq_1(arg0, arg1); Gets list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep. finalize(). flush_outfile(); Flushes the output file. fnocc(arg0); Runs the fno-ccsd(t)/qcisd(t)/mp4/cepa energy code. get_active_efp(); Returns the currently active EFP object. get_active_molecule(); Returns the currently active molecule object. get_array_variable(arg0); Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available). get_array_variables(); Returns dictionary of the PSI variables set internally by the modules or python driver. get_atomic_point_charges(); Returns the most recently computed atomic point charges, as a double * object. get_datadir(); Sets the path to shared text resources, PSIDATADIR. get_efp_torque(); Returns the most recently computed gradient for the EFP portion, as a Nefp by 6 Matrix object. get_frequencies(); Returns the most recently computed frequencies, as a 3N-6 Vector object. get_global_option(arg0); Given a string of a keyword name arg1, returns the value associated with the keyword from the global options. get_global_option_list(); Returns a list of all global options. get_gradient(); Returns the most recently computed gradient, as a N by 3 Matrix object. get_legacy_molecule(); Returns the currently active molecule object. get_local_option(arg0, arg1); Given a string of a keyword name arg2 and a",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:243885,Modifiability,variab,variables,243885,"on, from energy points. fd_freq_0(arg0, arg1, arg2); Performs a finite difference frequency computation, from energy points, for a given irrep. fd_freq_1(arg0, arg1, arg2); Performs a finite difference frequency computation, from gradients, for a given irrep. fd_geoms_1_0(arg0); Gets list of displacements needed for a finite difference gradient computation, from energy points. fd_geoms_freq_0(arg0, arg1); Gets list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep. fd_geoms_freq_1(arg0, arg1); Gets list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep. finalize(). flush_outfile(); Flushes the output file. fnocc(arg0); Runs the fno-ccsd(t)/qcisd(t)/mp4/cepa energy code. get_active_efp(); Returns the currently active EFP object. get_active_molecule(); Returns the currently active molecule object. get_array_variable(arg0); Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available). get_array_variables(); Returns dictionary of the PSI variables set internally by the modules or python driver. get_atomic_point_charges(); Returns the most recently computed atomic point charges, as a double * object. get_datadir(); Sets the path to shared text resources, PSIDATADIR. get_efp_torque(); Returns the most recently computed gradient for the EFP portion, as a Nefp by 6 Matrix object. get_frequencies(); Returns the most recently computed frequencies, as a 3N-6 Vector object. get_global_option(arg0); Given a string of a keyword name arg1, returns the value associated with the keyword from the global options. get_global_option_list(); Returns a list of all global options. get_gradient(); Returns the most recently computed gradient, as a N by 3 Matrix object. get_legacy_molecule(); Returns the currently active molecule object. get_local_option(arg0, arg1); Given a string of a keyword name arg2 and a",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:243960,Modifiability,variab,variables,243960,"n irrep. fd_freq_1(arg0, arg1, arg2); Performs a finite difference frequency computation, from gradients, for a given irrep. fd_geoms_1_0(arg0); Gets list of displacements needed for a finite difference gradient computation, from energy points. fd_geoms_freq_0(arg0, arg1); Gets list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep. fd_geoms_freq_1(arg0, arg1); Gets list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep. finalize(). flush_outfile(); Flushes the output file. fnocc(arg0); Runs the fno-ccsd(t)/qcisd(t)/mp4/cepa energy code. get_active_efp(); Returns the currently active EFP object. get_active_molecule(); Returns the currently active molecule object. get_array_variable(arg0); Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available). get_array_variables(); Returns dictionary of the PSI variables set internally by the modules or python driver. get_atomic_point_charges(); Returns the most recently computed atomic point charges, as a double * object. get_datadir(); Sets the path to shared text resources, PSIDATADIR. get_efp_torque(); Returns the most recently computed gradient for the EFP portion, as a Nefp by 6 Matrix object. get_frequencies(); Returns the most recently computed frequencies, as a 3N-6 Vector object. get_global_option(arg0); Given a string of a keyword name arg1, returns the value associated with the keyword from the global options. get_global_option_list(); Returns a list of all global options. get_gradient(); Returns the most recently computed gradient, as a N by 3 Matrix object. get_legacy_molecule(); Returns the currently active molecule object. get_local_option(arg0, arg1); Given a string of a keyword name arg2 and a particular module arg1, returns the value associated with the keyword in the module options scope. get_memory(); Returns the amount of ",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:245411,Modifiability,variab,variables,245411,"yword name arg1, returns the value associated with the keyword from the global options. get_global_option_list(); Returns a list of all global options. get_gradient(); Returns the most recently computed gradient, as a N by 3 Matrix object. get_legacy_molecule(); Returns the currently active molecule object. get_local_option(arg0, arg1); Given a string of a keyword name arg2 and a particular module arg1, returns the value associated with the keyword in the module options scope. get_memory(); Returns the amount of memory available to Psi (in bytes). get_num_threads(); Returns the number of threads to use in SMP parallel computations. get_option(arg0, arg1); Given a string of a keyword name arg2 and a particular module arg1, returns the local value associated with the keyword if it’s been set, else the global value if it’s been set, else the local core.default value. get_options(); Get options. get_output_file(). get_variable(arg0); Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available). get_variables(); Returns dictionary of the PSI variables set internally by the modules or python driver. get_writer_file_prefix(arg0); Returns the prefix to use for writing files for external programs. git_version(); Returns the git version of this copy of Psi. has_global_option_changed(arg0); Returns boolean for whether the keyword arg1 has been touched in the global scope, by either user or code. has_local_option_changed(arg0, arg1); Returns boolean for whether the keyword arg2 has been touched in the scope of the specified module arg1, by either user or code. has_option_changed(arg0, arg1); Returns boolean for whether the option arg2 has been touched either locally to the specified module arg1 or globally, by either user or code. has_variable(arg0); Returns true if the PSI variable exists/is set. initialize(). legacy_wavefunction(); Returns the current legacy_wavefunction object from the most recent comput",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:245500,Modifiability,variab,variables,245500,"yword name arg1, returns the value associated with the keyword from the global options. get_global_option_list(); Returns a list of all global options. get_gradient(); Returns the most recently computed gradient, as a N by 3 Matrix object. get_legacy_molecule(); Returns the currently active molecule object. get_local_option(arg0, arg1); Given a string of a keyword name arg2 and a particular module arg1, returns the value associated with the keyword in the module options scope. get_memory(); Returns the amount of memory available to Psi (in bytes). get_num_threads(); Returns the number of threads to use in SMP parallel computations. get_option(arg0, arg1); Given a string of a keyword name arg2 and a particular module arg1, returns the local value associated with the keyword if it’s been set, else the global value if it’s been set, else the local core.default value. get_options(); Get options. get_output_file(). get_variable(arg0); Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available). get_variables(); Returns dictionary of the PSI variables set internally by the modules or python driver. get_writer_file_prefix(arg0); Returns the prefix to use for writing files for external programs. git_version(); Returns the git version of this copy of Psi. has_global_option_changed(arg0); Returns boolean for whether the keyword arg1 has been touched in the global scope, by either user or code. has_local_option_changed(arg0, arg1); Returns boolean for whether the keyword arg2 has been touched in the scope of the specified module arg1, by either user or code. has_option_changed(arg0, arg1); Returns boolean for whether the option arg2 has been touched either locally to the specified module arg1 or globally, by either user or code. has_variable(arg0); Returns true if the PSI variable exists/is set. initialize(). legacy_wavefunction(); Returns the current legacy_wavefunction object from the most recent comput",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:245569,Modifiability,variab,variables,245569,"of all global options. get_gradient(); Returns the most recently computed gradient, as a N by 3 Matrix object. get_legacy_molecule(); Returns the currently active molecule object. get_local_option(arg0, arg1); Given a string of a keyword name arg2 and a particular module arg1, returns the value associated with the keyword in the module options scope. get_memory(); Returns the amount of memory available to Psi (in bytes). get_num_threads(); Returns the number of threads to use in SMP parallel computations. get_option(arg0, arg1); Given a string of a keyword name arg2 and a particular module arg1, returns the local value associated with the keyword if it’s been set, else the global value if it’s been set, else the local core.default value. get_options(); Get options. get_output_file(). get_variable(arg0); Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available). get_variables(); Returns dictionary of the PSI variables set internally by the modules or python driver. get_writer_file_prefix(arg0); Returns the prefix to use for writing files for external programs. git_version(); Returns the git version of this copy of Psi. has_global_option_changed(arg0); Returns boolean for whether the keyword arg1 has been touched in the global scope, by either user or code. has_local_option_changed(arg0, arg1); Returns boolean for whether the keyword arg2 has been touched in the scope of the specified module arg1, by either user or code. has_option_changed(arg0, arg1); Returns boolean for whether the option arg2 has been touched either locally to the specified module arg1 or globally, by either user or code. has_variable(arg0); Returns true if the PSI variable exists/is set. initialize(). legacy_wavefunction(); Returns the current legacy_wavefunction object from the most recent computation. libfock(arg0); Runs a CPHF calculation, using libfock. mcscf(arg0); Runs the MCSCF code, (N.B. mrcc_generate_input(arg0, ar",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:246309,Modifiability,variab,variable,246309,"al core.default value. get_options(); Get options. get_output_file(). get_variable(arg0); Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available). get_variables(); Returns dictionary of the PSI variables set internally by the modules or python driver. get_writer_file_prefix(arg0); Returns the prefix to use for writing files for external programs. git_version(); Returns the git version of this copy of Psi. has_global_option_changed(arg0); Returns boolean for whether the keyword arg1 has been touched in the global scope, by either user or code. has_local_option_changed(arg0, arg1); Returns boolean for whether the keyword arg2 has been touched in the scope of the specified module arg1, by either user or code. has_option_changed(arg0, arg1); Returns boolean for whether the option arg2 has been touched either locally to the specified module arg1 or globally, by either user or code. has_variable(arg0); Returns true if the PSI variable exists/is set. initialize(). legacy_wavefunction(); Returns the current legacy_wavefunction object from the most recent computation. libfock(arg0); Runs a CPHF calculation, using libfock. mcscf(arg0); Runs the MCSCF code, (N.B. mrcc_generate_input(arg0, arg1); Generates an input for Kallay’s MRCC code. mrcc_load_densities(arg0, arg1); Reads in the density matrices from Kallay’s MRCC code. occ(arg0); Runs the orbital optimized CC codes. opt_clean(); Cleans up the optimizer’s scratch files. option_exists_in_module(arg0, arg1); Given a string of a keyword name arg1 and a particular module arg0, returns whether arg1 is a valid option for arg0. optking(); Runs the geometry optimization / frequency analysis code. outfile_name(); Returns the name of the output file. plugin(arg0, arg1); Call the plugin of name arg0. plugin_close(arg0); Close the plugin of name arg0. plugin_close_all(); Close all open plugins. plugin_load(arg0); Load the plugin of name arg0. prepare_options_",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:247088,Modifiability,plugin,plugin,247088,"g0, arg1); Returns boolean for whether the option arg2 has been touched either locally to the specified module arg1 or globally, by either user or code. has_variable(arg0); Returns true if the PSI variable exists/is set. initialize(). legacy_wavefunction(); Returns the current legacy_wavefunction object from the most recent computation. libfock(arg0); Runs a CPHF calculation, using libfock. mcscf(arg0); Runs the MCSCF code, (N.B. mrcc_generate_input(arg0, arg1); Generates an input for Kallay’s MRCC code. mrcc_load_densities(arg0, arg1); Reads in the density matrices from Kallay’s MRCC code. occ(arg0); Runs the orbital optimized CC codes. opt_clean(); Cleans up the optimizer’s scratch files. option_exists_in_module(arg0, arg1); Given a string of a keyword name arg1 and a particular module arg0, returns whether arg1 is a valid option for arg0. optking(); Runs the geometry optimization / frequency analysis code. outfile_name(); Returns the name of the output file. plugin(arg0, arg1); Call the plugin of name arg0. plugin_close(arg0); Close the plugin of name arg0. plugin_close_all(); Close all open plugins. plugin_load(arg0); Load the plugin of name arg0. prepare_options_for_module(arg0); Sets the options module up to return options pertaining to the named argument (e.g. print_global_options(); Prints the currently set global (all modules) options to the output file. print_options(); Prints the currently set options (to the output file) for the current module. print_out(arg0); Prints a string (using sprintf-like notation) to the output file. print_variables(); Prints all PSI variables that have been set internally. psi_top_srcdir(); Returns the location of the source code. psimrcc(arg0); Runs the multireference coupled cluster code. reopen_outfile(); Reopens the output file. revoke_global_option_changed(arg0); Given a string of a keyword name arg1, sets the has_changed attribute in the global options scope to false. revoke_local_option_changed(arg0, arg1); Given a strin",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:247117,Modifiability,plugin,plugin,247117,"g0, arg1); Returns boolean for whether the option arg2 has been touched either locally to the specified module arg1 or globally, by either user or code. has_variable(arg0); Returns true if the PSI variable exists/is set. initialize(). legacy_wavefunction(); Returns the current legacy_wavefunction object from the most recent computation. libfock(arg0); Runs a CPHF calculation, using libfock. mcscf(arg0); Runs the MCSCF code, (N.B. mrcc_generate_input(arg0, arg1); Generates an input for Kallay’s MRCC code. mrcc_load_densities(arg0, arg1); Reads in the density matrices from Kallay’s MRCC code. occ(arg0); Runs the orbital optimized CC codes. opt_clean(); Cleans up the optimizer’s scratch files. option_exists_in_module(arg0, arg1); Given a string of a keyword name arg1 and a particular module arg0, returns whether arg1 is a valid option for arg0. optking(); Runs the geometry optimization / frequency analysis code. outfile_name(); Returns the name of the output file. plugin(arg0, arg1); Call the plugin of name arg0. plugin_close(arg0); Close the plugin of name arg0. plugin_close_all(); Close all open plugins. plugin_load(arg0); Load the plugin of name arg0. prepare_options_for_module(arg0); Sets the options module up to return options pertaining to the named argument (e.g. print_global_options(); Prints the currently set global (all modules) options to the output file. print_options(); Prints the currently set options (to the output file) for the current module. print_out(arg0); Prints a string (using sprintf-like notation) to the output file. print_variables(); Prints all PSI variables that have been set internally. psi_top_srcdir(); Returns the location of the source code. psimrcc(arg0); Runs the multireference coupled cluster code. reopen_outfile(); Reopens the output file. revoke_global_option_changed(arg0); Given a string of a keyword name arg1, sets the has_changed attribute in the global options scope to false. revoke_local_option_changed(arg0, arg1); Given a strin",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:247168,Modifiability,plugin,plugin,247168,"arg2 has been touched either locally to the specified module arg1 or globally, by either user or code. has_variable(arg0); Returns true if the PSI variable exists/is set. initialize(). legacy_wavefunction(); Returns the current legacy_wavefunction object from the most recent computation. libfock(arg0); Runs a CPHF calculation, using libfock. mcscf(arg0); Runs the MCSCF code, (N.B. mrcc_generate_input(arg0, arg1); Generates an input for Kallay’s MRCC code. mrcc_load_densities(arg0, arg1); Reads in the density matrices from Kallay’s MRCC code. occ(arg0); Runs the orbital optimized CC codes. opt_clean(); Cleans up the optimizer’s scratch files. option_exists_in_module(arg0, arg1); Given a string of a keyword name arg1 and a particular module arg0, returns whether arg1 is a valid option for arg0. optking(); Runs the geometry optimization / frequency analysis code. outfile_name(); Returns the name of the output file. plugin(arg0, arg1); Call the plugin of name arg0. plugin_close(arg0); Close the plugin of name arg0. plugin_close_all(); Close all open plugins. plugin_load(arg0); Load the plugin of name arg0. prepare_options_for_module(arg0); Sets the options module up to return options pertaining to the named argument (e.g. print_global_options(); Prints the currently set global (all modules) options to the output file. print_options(); Prints the currently set options (to the output file) for the current module. print_out(arg0); Prints a string (using sprintf-like notation) to the output file. print_variables(); Prints all PSI variables that have been set internally. psi_top_srcdir(); Returns the location of the source code. psimrcc(arg0); Runs the multireference coupled cluster code. reopen_outfile(); Reopens the output file. revoke_global_option_changed(arg0); Given a string of a keyword name arg1, sets the has_changed attribute in the global options scope to false. revoke_local_option_changed(arg0, arg1); Given a string of a keyword name arg2 and a particular module ar",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:247224,Modifiability,plugin,plugins,247224,"ified module arg1 or globally, by either user or code. has_variable(arg0); Returns true if the PSI variable exists/is set. initialize(). legacy_wavefunction(); Returns the current legacy_wavefunction object from the most recent computation. libfock(arg0); Runs a CPHF calculation, using libfock. mcscf(arg0); Runs the MCSCF code, (N.B. mrcc_generate_input(arg0, arg1); Generates an input for Kallay’s MRCC code. mrcc_load_densities(arg0, arg1); Reads in the density matrices from Kallay’s MRCC code. occ(arg0); Runs the orbital optimized CC codes. opt_clean(); Cleans up the optimizer’s scratch files. option_exists_in_module(arg0, arg1); Given a string of a keyword name arg1 and a particular module arg0, returns whether arg1 is a valid option for arg0. optking(); Runs the geometry optimization / frequency analysis code. outfile_name(); Returns the name of the output file. plugin(arg0, arg1); Call the plugin of name arg0. plugin_close(arg0); Close the plugin of name arg0. plugin_close_all(); Close all open plugins. plugin_load(arg0); Load the plugin of name arg0. prepare_options_for_module(arg0); Sets the options module up to return options pertaining to the named argument (e.g. print_global_options(); Prints the currently set global (all modules) options to the output file. print_options(); Prints the currently set options (to the output file) for the current module. print_out(arg0); Prints a string (using sprintf-like notation) to the output file. print_variables(); Prints all PSI variables that have been set internally. psi_top_srcdir(); Returns the location of the source code. psimrcc(arg0); Runs the multireference coupled cluster code. reopen_outfile(); Reopens the output file. revoke_global_option_changed(arg0); Given a string of a keyword name arg1, sets the has_changed attribute in the global options scope to false. revoke_local_option_changed(arg0, arg1); Given a string of a keyword name arg2 and a particular module arg1, sets the has_changed attribute in the modul",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:247261,Modifiability,plugin,plugin,247261,"or code. has_variable(arg0); Returns true if the PSI variable exists/is set. initialize(). legacy_wavefunction(); Returns the current legacy_wavefunction object from the most recent computation. libfock(arg0); Runs a CPHF calculation, using libfock. mcscf(arg0); Runs the MCSCF code, (N.B. mrcc_generate_input(arg0, arg1); Generates an input for Kallay’s MRCC code. mrcc_load_densities(arg0, arg1); Reads in the density matrices from Kallay’s MRCC code. occ(arg0); Runs the orbital optimized CC codes. opt_clean(); Cleans up the optimizer’s scratch files. option_exists_in_module(arg0, arg1); Given a string of a keyword name arg1 and a particular module arg0, returns whether arg1 is a valid option for arg0. optking(); Runs the geometry optimization / frequency analysis code. outfile_name(); Returns the name of the output file. plugin(arg0, arg1); Call the plugin of name arg0. plugin_close(arg0); Close the plugin of name arg0. plugin_close_all(); Close all open plugins. plugin_load(arg0); Load the plugin of name arg0. prepare_options_for_module(arg0); Sets the options module up to return options pertaining to the named argument (e.g. print_global_options(); Prints the currently set global (all modules) options to the output file. print_options(); Prints the currently set options (to the output file) for the current module. print_out(arg0); Prints a string (using sprintf-like notation) to the output file. print_variables(); Prints all PSI variables that have been set internally. psi_top_srcdir(); Returns the location of the source code. psimrcc(arg0); Runs the multireference coupled cluster code. reopen_outfile(); Reopens the output file. revoke_global_option_changed(arg0); Given a string of a keyword name arg1, sets the has_changed attribute in the global options scope to false. revoke_local_option_changed(arg0, arg1); Given a string of a keyword name arg2 and a particular module arg1, sets the has_changed attribute in the module options scope to false. run_gdma(arg0, arg1);",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:247710,Modifiability,variab,variables,247710,"c(arg0); Runs the orbital optimized CC codes. opt_clean(); Cleans up the optimizer’s scratch files. option_exists_in_module(arg0, arg1); Given a string of a keyword name arg1 and a particular module arg0, returns whether arg1 is a valid option for arg0. optking(); Runs the geometry optimization / frequency analysis code. outfile_name(); Returns the name of the output file. plugin(arg0, arg1); Call the plugin of name arg0. plugin_close(arg0); Close the plugin of name arg0. plugin_close_all(); Close all open plugins. plugin_load(arg0); Load the plugin of name arg0. prepare_options_for_module(arg0); Sets the options module up to return options pertaining to the named argument (e.g. print_global_options(); Prints the currently set global (all modules) options to the output file. print_options(); Prints the currently set options (to the output file) for the current module. print_out(arg0); Prints a string (using sprintf-like notation) to the output file. print_variables(); Prints all PSI variables that have been set internally. psi_top_srcdir(); Returns the location of the source code. psimrcc(arg0); Runs the multireference coupled cluster code. reopen_outfile(); Reopens the output file. revoke_global_option_changed(arg0); Given a string of a keyword name arg1, sets the has_changed attribute in the global options scope to false. revoke_local_option_changed(arg0, arg1); Given a string of a keyword name arg2 and a particular module arg1, sets the has_changed attribute in the module options scope to false. run_gdma(arg0, arg1); Runs the GDMA code. sapt(arg0, arg1, arg2); Runs the symmetry adapted perturbation theory code. scatter(arg0, arg1, arg2, arg3, arg4); New Scatter function. scfgrad(arg0); Run scfgrad, which is a specialized DF-SCF gradient program. scfhess(arg0); Run scfhess, which is a specialized DF-SCF hessian program. set_active_molecule(arg0); Activates a previously defined (in the input) molecule, by name. set_array_variable(arg0, arg1); Sets a PSI variable, by",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:248320,Modifiability,adapt,adapted,248320," Sets the options module up to return options pertaining to the named argument (e.g. print_global_options(); Prints the currently set global (all modules) options to the output file. print_options(); Prints the currently set options (to the output file) for the current module. print_out(arg0); Prints a string (using sprintf-like notation) to the output file. print_variables(); Prints all PSI variables that have been set internally. psi_top_srcdir(); Returns the location of the source code. psimrcc(arg0); Runs the multireference coupled cluster code. reopen_outfile(); Reopens the output file. revoke_global_option_changed(arg0); Given a string of a keyword name arg1, sets the has_changed attribute in the global options scope to false. revoke_local_option_changed(arg0, arg1); Given a string of a keyword name arg2 and a particular module arg1, sets the has_changed attribute in the module options scope to false. run_gdma(arg0, arg1); Runs the GDMA code. sapt(arg0, arg1, arg2); Runs the symmetry adapted perturbation theory code. scatter(arg0, arg1, arg2, arg3, arg4); New Scatter function. scfgrad(arg0); Run scfgrad, which is a specialized DF-SCF gradient program. scfhess(arg0); Run scfhess, which is a specialized DF-SCF hessian program. set_active_molecule(arg0); Activates a previously defined (in the input) molecule, by name. set_array_variable(arg0, arg1); Sets a PSI variable, by name. set_datadir(arg0); Returns the amount of memory available to Psi (in bytes). set_efp_torque(arg0); Assigns the global EFP gradient to the values stored in the Nefp by 6 Matrix argument. set_frequencies(arg0); Assigns the global frequencies to the values stored in the 3N-6 Vector argument. set_global_option(*args, **kwargs); Overloaded function. set_global_option_python(key, EXTERN); This is a fairly hacky way to get around EXTERN issues. set_gradient(arg0); Assigns the global gradient to the values stored in the N by 3 Matrix argument. set_legacy_molecule(arg0); Activates a previously def",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:248701,Modifiability,variab,variable,248701,"les(); Prints all PSI variables that have been set internally. psi_top_srcdir(); Returns the location of the source code. psimrcc(arg0); Runs the multireference coupled cluster code. reopen_outfile(); Reopens the output file. revoke_global_option_changed(arg0); Given a string of a keyword name arg1, sets the has_changed attribute in the global options scope to false. revoke_local_option_changed(arg0, arg1); Given a string of a keyword name arg2 and a particular module arg1, sets the has_changed attribute in the module options scope to false. run_gdma(arg0, arg1); Runs the GDMA code. sapt(arg0, arg1, arg2); Runs the symmetry adapted perturbation theory code. scatter(arg0, arg1, arg2, arg3, arg4); New Scatter function. scfgrad(arg0); Run scfgrad, which is a specialized DF-SCF gradient program. scfhess(arg0); Run scfhess, which is a specialized DF-SCF hessian program. set_active_molecule(arg0); Activates a previously defined (in the input) molecule, by name. set_array_variable(arg0, arg1); Sets a PSI variable, by name. set_datadir(arg0); Returns the amount of memory available to Psi (in bytes). set_efp_torque(arg0); Assigns the global EFP gradient to the values stored in the Nefp by 6 Matrix argument. set_frequencies(arg0); Assigns the global frequencies to the values stored in the 3N-6 Vector argument. set_global_option(*args, **kwargs); Overloaded function. set_global_option_python(key, EXTERN); This is a fairly hacky way to get around EXTERN issues. set_gradient(arg0); Assigns the global gradient to the values stored in the N by 3 Matrix argument. set_legacy_molecule(arg0); Activates a previously defined (in the input) molecule, by name. set_legacy_wavefunction(arg0); Returns the current legacy_wavefunction object from the most recent computation. set_local_option(*args, **kwargs); Overloaded function. set_local_option_python(arg0, arg1); Sets an option to a Python object, but scoped only to a single module. set_memory_bytes(memory, quiet); Sets the memory available",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:250085,Modifiability,variab,variable,250085,"al_option_python(key, EXTERN); This is a fairly hacky way to get around EXTERN issues. set_gradient(arg0); Assigns the global gradient to the values stored in the N by 3 Matrix argument. set_legacy_molecule(arg0); Activates a previously defined (in the input) molecule, by name. set_legacy_wavefunction(arg0); Returns the current legacy_wavefunction object from the most recent computation. set_local_option(*args, **kwargs); Overloaded function. set_local_option_python(arg0, arg1); Sets an option to a Python object, but scoped only to a single module. set_memory_bytes(memory, quiet); Sets the memory available to Psi (in bytes). set_num_threads(nthread, quiet); Sets the number of threads to use in SMP parallel computations. set_output_file(*args, **kwargs); Overloaded function. set_parent_symmetry(arg0); Sets the symmetry of the ‘parent’ (undisplaced) geometry, by Schoenflies symbol, at the beginning of a finite difference computation. set_psi_file_prefix(arg0). set_variable(arg0, arg1); Sets a PSI variable, by name. tstart(); docstring. tstop(); docstring. version(); Returns the version ID of this copy of Psi. Classes¶. AOShellCombinationsIterator. AngularMomentumInt; Computes angular momentum integrals. BSVec. BasisExtents; docstring. BasisFunctions; docstring. BasisSet; Contains basis set information. BlockOPoints; docstring. BoysLocalizer; Performs Boys orbital localization. CIVector; docstring. CIWavefunction; docstring. CUHF; docstring. CdSalcList; Class for generating symmetry adapted linear combinations of Cartesian displacements. CorrelationFactor; docstring. CorrelationTable; Provides a correlation table between two point groups. CubeProperties; docstring. DFEP2Wavefunction; A density-fitted second-order Electron Propagator Wavefunction. DFHelper; docstring. DFSOMCSCF; docstring. DFTGrid; docstring. DFTensor; docstring. Deriv; Computes gradients of wavefunctions. DiagonalizeOrder; Defines ordering of eigenvalues after diagonalization. Dimension; Initializes an",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:250580,Modifiability,adapt,adapted,250580,"object, but scoped only to a single module. set_memory_bytes(memory, quiet); Sets the memory available to Psi (in bytes). set_num_threads(nthread, quiet); Sets the number of threads to use in SMP parallel computations. set_output_file(*args, **kwargs); Overloaded function. set_parent_symmetry(arg0); Sets the symmetry of the ‘parent’ (undisplaced) geometry, by Schoenflies symbol, at the beginning of a finite difference computation. set_psi_file_prefix(arg0). set_variable(arg0, arg1); Sets a PSI variable, by name. tstart(); docstring. tstop(); docstring. version(); Returns the version ID of this copy of Psi. Classes¶. AOShellCombinationsIterator. AngularMomentumInt; Computes angular momentum integrals. BSVec. BasisExtents; docstring. BasisFunctions; docstring. BasisSet; Contains basis set information. BlockOPoints; docstring. BoysLocalizer; Performs Boys orbital localization. CIVector; docstring. CIWavefunction; docstring. CUHF; docstring. CdSalcList; Class for generating symmetry adapted linear combinations of Cartesian displacements. CorrelationFactor; docstring. CorrelationTable; Provides a correlation table between two point groups. CubeProperties; docstring. DFEP2Wavefunction; A density-fitted second-order Electron Propagator Wavefunction. DFHelper; docstring. DFSOMCSCF; docstring. DFTGrid; docstring. DFTensor; docstring. Deriv; Computes gradients of wavefunctions. DiagonalizeOrder; Defines ordering of eigenvalues after diagonalization. Dimension; Initializes and defines Dimension Objects. DipoleInt; Computes dipole integrals. DiskSOMCSCF; docstring. Dispersion; docstring. EFP; Class interfacing with libefp. ERI; Computes normal two electron reuplsion integrals. ElectricFieldInt; Computes electric field integrals. ElectrostaticInt; Computes electrostatic integrals. ErfComplementERI; Computes ERF complement electron repulsion integrals. ErfERI; Computes ERF electron repulsion integrals. ExternalPotential; Stores external potential field, computes external potentia",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:258922,Modifiability,plugin,plugin,258922,"_arrays(expected, computed, digits, label); Function to compare two numpy arrays. compare_csx(); Function to validate energies in CSX files against PSIvariables. compare_cubes(expected, computed, label); Function to compare two cube files. compare_fcidumps(expected, computed, label); Function to compare two FCIDUMP files. compare_integers(expected, computed, label); Function to compare two integers. compare_matrices(expected, computed, digits, …); Function to compare two matrices. compare_strings(expected, computed, label); Function to compare two strings. compare_values(expected, computed, digits, label); Function to compare two values. compare_vectors(expected, computed, digits, …); Function to compare two vectors. copy_file_from_scratch(filename, prefix, …); Function to move file out of scratch with correct naming convention. copy_file_to_scratch(filename, prefix, …); Function to move file into scratch with correct naming convention. create_plugin(name, template); Generate plugin in directory with sanitized name based upon template. csx2endict(); Grabs the CSX file as a dictionary, encodes translation of PSI variables to XML blocks, gathers all available energies from CSX file into returned dictionary. cubeprop(wfn, **kwargs); Evaluate properties on a grid and generate cube files. dynamic_variable_bind(cls); Function to dynamically add extra members to the core.Molecule class. energy(name, **kwargs); Function to compute the single-point electronic energy. fchk(wfn, filename); Function to write wavefunction information in wfn to filename in Gaussian FCHK format. fcidump(wfn[, fname, oe_ints]); Save integrals to file in FCIDUMP format as defined in Comp. fcidump_from_file(fname); Function to read in a FCIDUMP file. filter_comments(string); Remove from string any Python-style comments (‘#’ to end of line). find_approximate_string_matches(seq1, …); Function to compute approximate string matches from a list of options. freq(name, **kwargs); Function to compute harmonic",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:259060,Modifiability,variab,variables,259060,"es against PSIvariables. compare_cubes(expected, computed, label); Function to compare two cube files. compare_fcidumps(expected, computed, label); Function to compare two FCIDUMP files. compare_integers(expected, computed, label); Function to compare two integers. compare_matrices(expected, computed, digits, …); Function to compare two matrices. compare_strings(expected, computed, label); Function to compare two strings. compare_values(expected, computed, digits, label); Function to compare two values. compare_vectors(expected, computed, digits, …); Function to compare two vectors. copy_file_from_scratch(filename, prefix, …); Function to move file out of scratch with correct naming convention. copy_file_to_scratch(filename, prefix, …); Function to move file into scratch with correct naming convention. create_plugin(name, template); Generate plugin in directory with sanitized name based upon template. csx2endict(); Grabs the CSX file as a dictionary, encodes translation of PSI variables to XML blocks, gathers all available energies from CSX file into returned dictionary. cubeprop(wfn, **kwargs); Evaluate properties on a grid and generate cube files. dynamic_variable_bind(cls); Function to dynamically add extra members to the core.Molecule class. energy(name, **kwargs); Function to compute the single-point electronic energy. fchk(wfn, filename); Function to write wavefunction information in wfn to filename in Gaussian FCHK format. fcidump(wfn[, fname, oe_ints]); Save integrals to file in FCIDUMP format as defined in Comp. fcidump_from_file(fname); Function to read in a FCIDUMP file. filter_comments(string); Remove from string any Python-style comments (‘#’ to end of line). find_approximate_string_matches(seq1, …); Function to compute approximate string matches from a list of options. freq(name, **kwargs); Function to compute harmonic vibrational frequencies. frequencies(name, **kwargs); Function to compute harmonic vibrational frequencies. frequency(name, **kwargs); F",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:263743,Modifiability,flexible,flexible,263743,"et the total memory allocation. set_module_options(module, options_dict); Sets Psi4 module options from a module specification and input dictionary. set_options(options_dict); Sets Psi4 global options from an input dictionary. success(label); Function to print a ‘label…PASSED’ line to screen. vibanal_wfn(wfn[, hess, irrep, molecule, …]). write_eigenvalues(eigs, mo_idx); Prepare multi-line string with one-particle eigenvalues to be written to the FCIDUMP file. xml2dict([filename]); Read XML filename into nested OrderedDict-s. Classes¶. CSXError(msg); Error called when CSX generation fails. ConvergenceError(eqn_description, maxit); Error called for problems with converging and iterative method. Dftd3Error(msg). EmpericalDispersion(alias, dtype, **kwargs). ManagedMethodError(circs). OptimizationConvergenceError(…); Error called for problems with geometry optimizer. ParsingError(msg); Error called for problems parsing a text file. PastureRequiredError(option); Error called when the specified value of option requires some module(s) from Psi4Pasture, but could not be imported. PsiException; Error class for Psi. PsiImportError(msg); Error called for problems import python dependencies. QMMM(). Table([rows, row_label_width, …]); Class defining a flexible Table object for storing data. TestComparisonError(msg); Error called when a test case fails due to a failed compare_values() call. ValidationError(msg); Error called for problems with the input file. datetime(year, month, day[, hour[, minute[, …); The year, month and day arguments are required. Class Inheritance Diagram¶. table of contents. PSI4 API: Linking C++ and Python; psi4.core Module; Functions; Classes; Class Inheritance Diagram. psi4.driver Package; Functions; Classes; Class Inheritance Diagram. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:105091,Performance,load,load,105091,"ument transb Transpose the right matrix? argument alpha Prefactor for the matrix multiplication argument A Left matrix argument B Right matrix argument beta Prefactor for the resulting matrix. general_invert(self: psi4.core.Matrix) → None¶; Computes the inverse of any nonsingular matrix using LU factorization. get(*args, **kwargs)¶; Overloaded function. get(self: psi4.core.Matrix, h: int, m: int, n: int) -> float. Returns a single element of a matrix in subblock h, row m, col n. get(self: psi4.core.Matrix, m: int, n: int) -> float. Returns a single element of a matrix, row m, col n. get_block(self: psi4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice) → psi4.core.Matrix¶; Get a matrix block. hermitivitize(self: psi4.core.Matrix) → None¶; Average off-diagonal element in-place. identity(self: psi4.core.Matrix) → None¶; Sets the matrix to the identity. invert(self: psi4.core.Matrix) → None¶; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs)¶; Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType=SaveType.LowerTriangle) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str) → None¶; Loads a matrix from an ASCII file in MPQC format. name¶; The name of the Matrix. Used in printing. nirrep(self: psi4.core.Matrix) → int¶; Returns the number of irreps. np¶; View without only one irrep. classmethod np_read(filename, prefix='')¶; Reads the data from a NumPy compress file. np_write(filename=None, prefix='')¶; Writes the irreped matrix to a NumPy zipped file.; Can return the packed data for sa",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:105136,Performance,load,load,105136,"t matrix? argument alpha Prefactor for the matrix multiplication argument A Left matrix argument B Right matrix argument beta Prefactor for the resulting matrix. general_invert(self: psi4.core.Matrix) → None¶; Computes the inverse of any nonsingular matrix using LU factorization. get(*args, **kwargs)¶; Overloaded function. get(self: psi4.core.Matrix, h: int, m: int, n: int) -> float. Returns a single element of a matrix in subblock h, row m, col n. get(self: psi4.core.Matrix, m: int, n: int) -> float. Returns a single element of a matrix, row m, col n. get_block(self: psi4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice) → psi4.core.Matrix¶; Get a matrix block. hermitivitize(self: psi4.core.Matrix) → None¶; Average off-diagonal element in-place. identity(self: psi4.core.Matrix) → None¶; Sets the matrix to the identity. invert(self: psi4.core.Matrix) → None¶; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs)¶; Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType=SaveType.LowerTriangle) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str) → None¶; Loads a matrix from an ASCII file in MPQC format. name¶; The name of the Matrix. Used in printing. nirrep(self: psi4.core.Matrix) → int¶; Returns the number of irreps. np¶; View without only one irrep. classmethod np_read(filename, prefix='')¶; Reads the data from a NumPy compress file. np_write(filename=None, prefix='')¶; Writes the irreped matrix to a NumPy zipped file.; Can return the packed data for saving many matrices into the sam",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:105260,Performance,load,load,105260,"a Prefactor for the resulting matrix. general_invert(self: psi4.core.Matrix) → None¶; Computes the inverse of any nonsingular matrix using LU factorization. get(*args, **kwargs)¶; Overloaded function. get(self: psi4.core.Matrix, h: int, m: int, n: int) -> float. Returns a single element of a matrix in subblock h, row m, col n. get(self: psi4.core.Matrix, m: int, n: int) -> float. Returns a single element of a matrix, row m, col n. get_block(self: psi4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice) → psi4.core.Matrix¶; Get a matrix block. hermitivitize(self: psi4.core.Matrix) → None¶; Average off-diagonal element in-place. identity(self: psi4.core.Matrix) → None¶; Sets the matrix to the identity. invert(self: psi4.core.Matrix) → None¶; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs)¶; Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType=SaveType.LowerTriangle) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str) → None¶; Loads a matrix from an ASCII file in MPQC format. name¶; The name of the Matrix. Used in printing. nirrep(self: psi4.core.Matrix) → int¶; Returns the number of irreps. np¶; View without only one irrep. classmethod np_read(filename, prefix='')¶; Reads the data from a NumPy compress file. np_write(filename=None, prefix='')¶; Writes the irreped matrix to a NumPy zipped file.; Can return the packed data for saving many matrices into the same file. nph¶; View with irreps. partial_cholesky_factorize(self: psi4.core.Matrix, delta: float=0.0, throw_if_negative: bool",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:105428,Performance,load,load,105428,"**kwargs)¶; Overloaded function. get(self: psi4.core.Matrix, h: int, m: int, n: int) -> float. Returns a single element of a matrix in subblock h, row m, col n. get(self: psi4.core.Matrix, m: int, n: int) -> float. Returns a single element of a matrix, row m, col n. get_block(self: psi4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice) → psi4.core.Matrix¶; Get a matrix block. hermitivitize(self: psi4.core.Matrix) → None¶; Average off-diagonal element in-place. identity(self: psi4.core.Matrix) → None¶; Sets the matrix to the identity. invert(self: psi4.core.Matrix) → None¶; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs)¶; Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType=SaveType.LowerTriangle) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str) → None¶; Loads a matrix from an ASCII file in MPQC format. name¶; The name of the Matrix. Used in printing. nirrep(self: psi4.core.Matrix) → int¶; Returns the number of irreps. np¶; View without only one irrep. classmethod np_read(filename, prefix='')¶; Reads the data from a NumPy compress file. np_write(filename=None, prefix='')¶; Writes the irreped matrix to a NumPy zipped file.; Can return the packed data for saving many matrices into the same file. nph¶; View with irreps. partial_cholesky_factorize(self: psi4.core.Matrix, delta: float=0.0, throw_if_negative: bool=False) → psi4.core.Matrix¶; Computes the fully pivoted partial Cholesky factorization of a real symmetric positive semidefinite matrix, to numerical precision delta. p",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:139133,Performance,load,load,139133,"s of the rigid molecule that only interchange identical atoms. rotor_type(self: psi4.core.Molecule) → str¶; Returns rotor type, e.g. ‘RT_ATOM’ or ‘RT_SYMMETRIC_TOP’. run_dftd3(func=None, dashlvl=None, dashparam=None, dertype=None, verbose=False)¶; Compute dispersion correction using Grimme’s DFTD3 executable.; Function to call Grimme’s dftd3 program to compute the -D correction; of level dashlvl using parameters for the functional func.; dashparam can supply a full set of dispersion parameters in the; absence of func or individual overrides in the presence of func.; The DFTD3 executable must be independently compiled and found in; PATH or PSIPATH. Parameters:; mol (qcdb.Molecule or psi4.core.Molecule or str) – Molecule on which to run dispersion calculation. Both qcdb and; psi4.core Molecule classes have been extended by this method, so; either allowed. Alternately, a string that can be instantiated; into a qcdb.Molecule.; func (str or None) – Density functional (Psi4, not Turbomole, names) for which to; load parameters from dashcoeff[dashlvl][func]. This is not; passed to DFTD3 and thus may be a dummy or None. Any or all; parameters initialized can be overwritten via dashparam.; dashlvl ({'d2p4', 'd2gr', 'd3zero', 'd3bj', 'd3mzero', d3mbj', 'd', 'd2', 'd3', 'd3m'}) – Flavor of a posteriori dispersion correction for which to load; parameters and call procedure in DFTD3. Must be a keys in; dashcoeff dict (or a key in dashalias that resolves to one).; dashparam (dict, optional) – Dictionary of the same keys as dashcoeff[dashlvl] used to; override any or all values initialized by; dashcoeff[dashlvl][func].; dertype ({None, 0, 'none', 'energy', 1, 'first', 'gradient'}, optional) – Maximum derivative level at which to run DFTD3. For large; mol, energy-only calculations can be significantly more; efficient. Also controls return values, see below.; verbose (bool, optional) – When True, additionally include DFTD3 output in output. Returns:; energy (float, optional) – When de",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:139460,Performance,load,load,139460,"FTD3 executable.; Function to call Grimme’s dftd3 program to compute the -D correction; of level dashlvl using parameters for the functional func.; dashparam can supply a full set of dispersion parameters in the; absence of func or individual overrides in the presence of func.; The DFTD3 executable must be independently compiled and found in; PATH or PSIPATH. Parameters:; mol (qcdb.Molecule or psi4.core.Molecule or str) – Molecule on which to run dispersion calculation. Both qcdb and; psi4.core Molecule classes have been extended by this method, so; either allowed. Alternately, a string that can be instantiated; into a qcdb.Molecule.; func (str or None) – Density functional (Psi4, not Turbomole, names) for which to; load parameters from dashcoeff[dashlvl][func]. This is not; passed to DFTD3 and thus may be a dummy or None. Any or all; parameters initialized can be overwritten via dashparam.; dashlvl ({'d2p4', 'd2gr', 'd3zero', 'd3bj', 'd3mzero', d3mbj', 'd', 'd2', 'd3', 'd3m'}) – Flavor of a posteriori dispersion correction for which to load; parameters and call procedure in DFTD3. Must be a keys in; dashcoeff dict (or a key in dashalias that resolves to one).; dashparam (dict, optional) – Dictionary of the same keys as dashcoeff[dashlvl] used to; override any or all values initialized by; dashcoeff[dashlvl][func].; dertype ({None, 0, 'none', 'energy', 1, 'first', 'gradient'}, optional) – Maximum derivative level at which to run DFTD3. For large; mol, energy-only calculations can be significantly more; efficient. Also controls return values, see below.; verbose (bool, optional) – When True, additionally include DFTD3 output in output. Returns:; energy (float, optional) – When dertype is 0, energy [Eh].; gradient (list of lists of floats or psi4.core.Matrix, optional) – When dertype is 1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (float and list of lists of floats or psi4.core.Matrix, optional) – When dertype is unspecified, both energy [Eh] and (nat, 3) gradient",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:226256,Performance,optimiz,optimized,226256,"float¶; Runs the coupled cluster response theory code. psi4.core.cctransort(arg0: psi::Wavefunction) → None¶; Runs CCTRANSORT, which transforms and reorders integrals for use in the coupled cluster codes. psi4.core.cctriples(arg0: psi::Wavefunction) → float¶; Runs the coupled cluster (T) energy code. psi4.core.clean() → None¶; Function to remove scratch files. Call between independent jobs. psi4.core.clean_options() → None¶; Function to reset options to clean state. psi4.core.clean_variables() → None¶; Empties all PSI variables that have set internally. psi4.core.close_outfile() → None¶; Closes the output file. psi4.core.dcft(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the density cumulant functional theory code. psi4.core.detci(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the determinant-based configuration interaction code. psi4.core.dfmp2(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the DF-MP2 code. psi4.core.dfocc(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the density-fitted orbital optimized CC codes. psi4.core.displace_atom(arg0: psi::Matrix, arg1: int, arg2: int, arg3: int, arg4: float) → None¶; Displaces one coordinate of single atom. psi4.core.dmrg(arg0: psi::Wavefunction) → float¶; Runs the DMRG code. psi4.core.efp_init() → psi4.core.EFP¶; Initializes the EFP library and returns an EFP object. psi4.core.efp_set_options() → None¶; Set EFP options from environment options object. psi4.core.fcidump_tei_helper(nirrep: int, restricted: bool, DPD_info: Dict[str, int], ints_tolerance: float, fname: str='INTDUMP') → None¶; Write integrals to file in FCIDUMP format. psi4.core.fd_1_0(arg0: psi::Molecule, arg1: list) → psi::Matrix¶; Performs a finite difference gradient computation, from energy points. psi4.core.fd_freq_0(arg0: psi::Molecule, arg1: list, arg2: int) → psi::Matrix¶; Performs a finite difference frequency computation, from energy points, for a given irrep. psi4.core.fd_freq_1(arg0: psi::Molecule, arg1: list, arg2: int) → p",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:232811,Performance,optimiz,optimized,232811," module arg1 or globally, by either user or code. Notwithstanding, code is written such that in practice, this returns whether the option has been touched by the user. psi4.core.has_variable(arg0: str) → bool¶; Returns true if the PSI variable exists/is set. psi4.core.initialize() → bool¶. psi4.core.legacy_wavefunction() → psi::Wavefunction¶; Returns the current legacy_wavefunction object from the most recent computation. psi4.core.libfock(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs a CPHF calculation, using libfock. psi4.core.mcscf(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the MCSCF code, (N.B. restricted to certain active spaces). psi4.core.mrcc_generate_input(arg0: psi::Wavefunction, arg1: dict) → psi4.core.PsiReturnType¶; Generates an input for Kallay’s MRCC code. psi4.core.mrcc_load_densities(arg0: psi::Wavefunction, arg1: dict) → psi4.core.PsiReturnType¶; Reads in the density matrices from Kallay’s MRCC code. psi4.core.occ(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the orbital optimized CC codes. psi4.core.opt_clean() → None¶; Cleans up the optimizer’s scratch files. psi4.core.option_exists_in_module(arg0: str, arg1: str) → bool¶; Given a string of a keyword name arg1 and a particular module arg0, returns whether arg1 is a valid option for arg0. psi4.core.optking() → int¶; Runs the geometry optimization / frequency analysis code. psi4.core.outfile_name() → str¶; Returns the name of the output file. psi4.core.plugin(arg0: str, arg1: psi::Wavefunction) → psi::Wavefunction¶; Call the plugin of name arg0. Returns the plugin code result. psi4.core.plugin_close(arg0: str) → None¶; Close the plugin of name arg0. psi4.core.plugin_close_all() → None¶; Close all open plugins. psi4.core.plugin_load(arg0: str) → int¶; Load the plugin of name arg0. Returns 0 if not loaded, 1 if loaded, 2 if already loaded. psi4.core.prepare_options_for_module(arg0: str) → None¶; Sets the options module up to return options pertaining to the named argument (e.g. SC",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:232876,Performance,optimiz,optimizer,232876,"ch that in practice, this returns whether the option has been touched by the user. psi4.core.has_variable(arg0: str) → bool¶; Returns true if the PSI variable exists/is set. psi4.core.initialize() → bool¶. psi4.core.legacy_wavefunction() → psi::Wavefunction¶; Returns the current legacy_wavefunction object from the most recent computation. psi4.core.libfock(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs a CPHF calculation, using libfock. psi4.core.mcscf(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the MCSCF code, (N.B. restricted to certain active spaces). psi4.core.mrcc_generate_input(arg0: psi::Wavefunction, arg1: dict) → psi4.core.PsiReturnType¶; Generates an input for Kallay’s MRCC code. psi4.core.mrcc_load_densities(arg0: psi::Wavefunction, arg1: dict) → psi4.core.PsiReturnType¶; Reads in the density matrices from Kallay’s MRCC code. psi4.core.occ(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the orbital optimized CC codes. psi4.core.opt_clean() → None¶; Cleans up the optimizer’s scratch files. psi4.core.option_exists_in_module(arg0: str, arg1: str) → bool¶; Given a string of a keyword name arg1 and a particular module arg0, returns whether arg1 is a valid option for arg0. psi4.core.optking() → int¶; Runs the geometry optimization / frequency analysis code. psi4.core.outfile_name() → str¶; Returns the name of the output file. psi4.core.plugin(arg0: str, arg1: psi::Wavefunction) → psi::Wavefunction¶; Call the plugin of name arg0. Returns the plugin code result. psi4.core.plugin_close(arg0: str) → None¶; Close the plugin of name arg0. psi4.core.plugin_close_all() → None¶; Close all open plugins. psi4.core.plugin_load(arg0: str) → int¶; Load the plugin of name arg0. Returns 0 if not loaded, 1 if loaded, 2 if already loaded. psi4.core.prepare_options_for_module(arg0: str) → None¶; Sets the options module up to return options pertaining to the named argument (e.g. SCF). psi4.core.print_global_options() → None¶; Prints the currently set global (all mo",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:233131,Performance,optimiz,optimization,233131,"eturns the current legacy_wavefunction object from the most recent computation. psi4.core.libfock(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs a CPHF calculation, using libfock. psi4.core.mcscf(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the MCSCF code, (N.B. restricted to certain active spaces). psi4.core.mrcc_generate_input(arg0: psi::Wavefunction, arg1: dict) → psi4.core.PsiReturnType¶; Generates an input for Kallay’s MRCC code. psi4.core.mrcc_load_densities(arg0: psi::Wavefunction, arg1: dict) → psi4.core.PsiReturnType¶; Reads in the density matrices from Kallay’s MRCC code. psi4.core.occ(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the orbital optimized CC codes. psi4.core.opt_clean() → None¶; Cleans up the optimizer’s scratch files. psi4.core.option_exists_in_module(arg0: str, arg1: str) → bool¶; Given a string of a keyword name arg1 and a particular module arg0, returns whether arg1 is a valid option for arg0. psi4.core.optking() → int¶; Runs the geometry optimization / frequency analysis code. psi4.core.outfile_name() → str¶; Returns the name of the output file. psi4.core.plugin(arg0: str, arg1: psi::Wavefunction) → psi::Wavefunction¶; Call the plugin of name arg0. Returns the plugin code result. psi4.core.plugin_close(arg0: str) → None¶; Close the plugin of name arg0. psi4.core.plugin_close_all() → None¶; Close all open plugins. psi4.core.plugin_load(arg0: str) → int¶; Load the plugin of name arg0. Returns 0 if not loaded, 1 if loaded, 2 if already loaded. psi4.core.prepare_options_for_module(arg0: str) → None¶; Sets the options module up to return options pertaining to the named argument (e.g. SCF). psi4.core.print_global_options() → None¶; Prints the currently set global (all modules) options to the output file. psi4.core.print_options() → None¶; Prints the currently set options (to the output file) for the current module. psi4.core.print_out(arg0: str) → None¶; Prints a string (using sprintf-like notation) to the output file. psi4.co",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:233602,Performance,load,loaded,233602,"arg0: psi::Wavefunction, arg1: dict) → psi4.core.PsiReturnType¶; Reads in the density matrices from Kallay’s MRCC code. psi4.core.occ(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the orbital optimized CC codes. psi4.core.opt_clean() → None¶; Cleans up the optimizer’s scratch files. psi4.core.option_exists_in_module(arg0: str, arg1: str) → bool¶; Given a string of a keyword name arg1 and a particular module arg0, returns whether arg1 is a valid option for arg0. psi4.core.optking() → int¶; Runs the geometry optimization / frequency analysis code. psi4.core.outfile_name() → str¶; Returns the name of the output file. psi4.core.plugin(arg0: str, arg1: psi::Wavefunction) → psi::Wavefunction¶; Call the plugin of name arg0. Returns the plugin code result. psi4.core.plugin_close(arg0: str) → None¶; Close the plugin of name arg0. psi4.core.plugin_close_all() → None¶; Close all open plugins. psi4.core.plugin_load(arg0: str) → int¶; Load the plugin of name arg0. Returns 0 if not loaded, 1 if loaded, 2 if already loaded. psi4.core.prepare_options_for_module(arg0: str) → None¶; Sets the options module up to return options pertaining to the named argument (e.g. SCF). psi4.core.print_global_options() → None¶; Prints the currently set global (all modules) options to the output file. psi4.core.print_options() → None¶; Prints the currently set options (to the output file) for the current module. psi4.core.print_out(arg0: str) → None¶; Prints a string (using sprintf-like notation) to the output file. psi4.core.print_variables() → None¶; Prints all PSI variables that have been set internally. psi4.core.psi_top_srcdir() → str¶; Returns the location of the source code. psi4.core.psimrcc(arg0: psi::Wavefunction) → float¶; Runs the multireference coupled cluster code. psi4.core.reopen_outfile() → None¶; Reopens the output file. psi4.core.revoke_global_option_changed(arg0: str) → None¶; Given a string of a keyword name arg1, sets the has_changed attribute in the global options scope to",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:233615,Performance,load,loaded,233615,"arg0: psi::Wavefunction, arg1: dict) → psi4.core.PsiReturnType¶; Reads in the density matrices from Kallay’s MRCC code. psi4.core.occ(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the orbital optimized CC codes. psi4.core.opt_clean() → None¶; Cleans up the optimizer’s scratch files. psi4.core.option_exists_in_module(arg0: str, arg1: str) → bool¶; Given a string of a keyword name arg1 and a particular module arg0, returns whether arg1 is a valid option for arg0. psi4.core.optking() → int¶; Runs the geometry optimization / frequency analysis code. psi4.core.outfile_name() → str¶; Returns the name of the output file. psi4.core.plugin(arg0: str, arg1: psi::Wavefunction) → psi::Wavefunction¶; Call the plugin of name arg0. Returns the plugin code result. psi4.core.plugin_close(arg0: str) → None¶; Close the plugin of name arg0. psi4.core.plugin_close_all() → None¶; Close all open plugins. psi4.core.plugin_load(arg0: str) → int¶; Load the plugin of name arg0. Returns 0 if not loaded, 1 if loaded, 2 if already loaded. psi4.core.prepare_options_for_module(arg0: str) → None¶; Sets the options module up to return options pertaining to the named argument (e.g. SCF). psi4.core.print_global_options() → None¶; Prints the currently set global (all modules) options to the output file. psi4.core.print_options() → None¶; Prints the currently set options (to the output file) for the current module. psi4.core.print_out(arg0: str) → None¶; Prints a string (using sprintf-like notation) to the output file. psi4.core.print_variables() → None¶; Prints all PSI variables that have been set internally. psi4.core.psi_top_srcdir() → str¶; Returns the location of the source code. psi4.core.psimrcc(arg0: psi::Wavefunction) → float¶; Runs the multireference coupled cluster code. psi4.core.reopen_outfile() → None¶; Reopens the output file. psi4.core.revoke_global_option_changed(arg0: str) → None¶; Given a string of a keyword name arg1, sets the has_changed attribute in the global options scope to",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:233636,Performance,load,loaded,233636,"arg0: psi::Wavefunction, arg1: dict) → psi4.core.PsiReturnType¶; Reads in the density matrices from Kallay’s MRCC code. psi4.core.occ(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the orbital optimized CC codes. psi4.core.opt_clean() → None¶; Cleans up the optimizer’s scratch files. psi4.core.option_exists_in_module(arg0: str, arg1: str) → bool¶; Given a string of a keyword name arg1 and a particular module arg0, returns whether arg1 is a valid option for arg0. psi4.core.optking() → int¶; Runs the geometry optimization / frequency analysis code. psi4.core.outfile_name() → str¶; Returns the name of the output file. psi4.core.plugin(arg0: str, arg1: psi::Wavefunction) → psi::Wavefunction¶; Call the plugin of name arg0. Returns the plugin code result. psi4.core.plugin_close(arg0: str) → None¶; Close the plugin of name arg0. psi4.core.plugin_close_all() → None¶; Close all open plugins. psi4.core.plugin_load(arg0: str) → int¶; Load the plugin of name arg0. Returns 0 if not loaded, 1 if loaded, 2 if already loaded. psi4.core.prepare_options_for_module(arg0: str) → None¶; Sets the options module up to return options pertaining to the named argument (e.g. SCF). psi4.core.print_global_options() → None¶; Prints the currently set global (all modules) options to the output file. psi4.core.print_options() → None¶; Prints the currently set options (to the output file) for the current module. psi4.core.print_out(arg0: str) → None¶; Prints a string (using sprintf-like notation) to the output file. psi4.core.print_variables() → None¶; Prints all PSI variables that have been set internally. psi4.core.psi_top_srcdir() → str¶; Returns the location of the source code. psi4.core.psimrcc(arg0: psi::Wavefunction) → float¶; Runs the multireference coupled cluster code. psi4.core.reopen_outfile() → None¶; Reopens the output file. psi4.core.revoke_global_option_changed(arg0: str) → None¶; Given a string of a keyword name arg1, sets the has_changed attribute in the global options scope to",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:242400,Performance,optimiz,optimized,242400,"y(arg0); Runs the code to compute coupled cluster density matrices. ccenergy(arg0); Runs the coupled cluster energy code. cceom(arg0); Runs the equation of motion coupled cluster code, for excited states. cchbar(arg0); Runs the code to generate the similarity transformed Hamiltonian. cclambda(arg0); Runs the coupled cluster lambda equations code. ccresponse(arg0); Runs the coupled cluster response theory code. cctransort(arg0); Runs CCTRANSORT, which transforms and reorders integrals for use in the coupled cluster codes. cctriples(arg0); Runs the coupled cluster (T) energy code. clean(); Function to remove scratch files. clean_options(); Function to reset options to clean state. clean_variables(); Empties all PSI variables that have set internally. close_outfile(); Closes the output file. dcft(arg0); Runs the density cumulant functional theory code. detci(arg0); Runs the determinant-based configuration interaction code. dfmp2(arg0); Runs the DF-MP2 code. dfocc(arg0); Runs the density-fitted orbital optimized CC codes. displace_atom(arg0, arg1, arg2, arg3, arg4); Displaces one coordinate of single atom. dmrg(arg0); Runs the DMRG code. efp_init(); Initializes the EFP library and returns an EFP object. efp_set_options(); Set EFP options from environment options object. fcidump_tei_helper(nirrep, restricted, …); Write integrals to file in FCIDUMP format. fd_1_0(arg0, arg1); Performs a finite difference gradient computation, from energy points. fd_freq_0(arg0, arg1, arg2); Performs a finite difference frequency computation, from energy points, for a given irrep. fd_freq_1(arg0, arg1, arg2); Performs a finite difference frequency computation, from gradients, for a given irrep. fd_geoms_1_0(arg0); Gets list of displacements needed for a finite difference gradient computation, from energy points. fd_geoms_freq_0(arg0, arg1); Gets list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep. fd_geoms_freq_1(arg0, arg1); Get",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:246738,Performance,optimiz,optimized,246738,"on(); Returns the git version of this copy of Psi. has_global_option_changed(arg0); Returns boolean for whether the keyword arg1 has been touched in the global scope, by either user or code. has_local_option_changed(arg0, arg1); Returns boolean for whether the keyword arg2 has been touched in the scope of the specified module arg1, by either user or code. has_option_changed(arg0, arg1); Returns boolean for whether the option arg2 has been touched either locally to the specified module arg1 or globally, by either user or code. has_variable(arg0); Returns true if the PSI variable exists/is set. initialize(). legacy_wavefunction(); Returns the current legacy_wavefunction object from the most recent computation. libfock(arg0); Runs a CPHF calculation, using libfock. mcscf(arg0); Runs the MCSCF code, (N.B. mrcc_generate_input(arg0, arg1); Generates an input for Kallay’s MRCC code. mrcc_load_densities(arg0, arg1); Reads in the density matrices from Kallay’s MRCC code. occ(arg0); Runs the orbital optimized CC codes. opt_clean(); Cleans up the optimizer’s scratch files. option_exists_in_module(arg0, arg1); Given a string of a keyword name arg1 and a particular module arg0, returns whether arg1 is a valid option for arg0. optking(); Runs the geometry optimization / frequency analysis code. outfile_name(); Returns the name of the output file. plugin(arg0, arg1); Call the plugin of name arg0. plugin_close(arg0); Close the plugin of name arg0. plugin_close_all(); Close all open plugins. plugin_load(arg0); Load the plugin of name arg0. prepare_options_for_module(arg0); Sets the options module up to return options pertaining to the named argument (e.g. print_global_options(); Prints the currently set global (all modules) options to the output file. print_options(); Prints the currently set options (to the output file) for the current module. print_out(arg0); Prints a string (using sprintf-like notation) to the output file. print_variables(); Prints all PSI variables that have bee",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:246785,Performance,optimiz,optimizer,246785,"has_global_option_changed(arg0); Returns boolean for whether the keyword arg1 has been touched in the global scope, by either user or code. has_local_option_changed(arg0, arg1); Returns boolean for whether the keyword arg2 has been touched in the scope of the specified module arg1, by either user or code. has_option_changed(arg0, arg1); Returns boolean for whether the option arg2 has been touched either locally to the specified module arg1 or globally, by either user or code. has_variable(arg0); Returns true if the PSI variable exists/is set. initialize(). legacy_wavefunction(); Returns the current legacy_wavefunction object from the most recent computation. libfock(arg0); Runs a CPHF calculation, using libfock. mcscf(arg0); Runs the MCSCF code, (N.B. mrcc_generate_input(arg0, arg1); Generates an input for Kallay’s MRCC code. mrcc_load_densities(arg0, arg1); Reads in the density matrices from Kallay’s MRCC code. occ(arg0); Runs the orbital optimized CC codes. opt_clean(); Cleans up the optimizer’s scratch files. option_exists_in_module(arg0, arg1); Given a string of a keyword name arg1 and a particular module arg0, returns whether arg1 is a valid option for arg0. optking(); Runs the geometry optimization / frequency analysis code. outfile_name(); Returns the name of the output file. plugin(arg0, arg1); Call the plugin of name arg0. plugin_close(arg0); Close the plugin of name arg0. plugin_close_all(); Close all open plugins. plugin_load(arg0); Load the plugin of name arg0. prepare_options_for_module(arg0); Sets the options module up to return options pertaining to the named argument (e.g. print_global_options(); Prints the currently set global (all modules) options to the output file. print_options(); Prints the currently set options (to the output file) for the current module. print_out(arg0); Prints a string (using sprintf-like notation) to the output file. print_variables(); Prints all PSI variables that have been set internally. psi_top_srcdir(); Returns the loc",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:246995,Performance,optimiz,optimization,246995,"rd arg2 has been touched in the scope of the specified module arg1, by either user or code. has_option_changed(arg0, arg1); Returns boolean for whether the option arg2 has been touched either locally to the specified module arg1 or globally, by either user or code. has_variable(arg0); Returns true if the PSI variable exists/is set. initialize(). legacy_wavefunction(); Returns the current legacy_wavefunction object from the most recent computation. libfock(arg0); Runs a CPHF calculation, using libfock. mcscf(arg0); Runs the MCSCF code, (N.B. mrcc_generate_input(arg0, arg1); Generates an input for Kallay’s MRCC code. mrcc_load_densities(arg0, arg1); Reads in the density matrices from Kallay’s MRCC code. occ(arg0); Runs the orbital optimized CC codes. opt_clean(); Cleans up the optimizer’s scratch files. option_exists_in_module(arg0, arg1); Given a string of a keyword name arg1 and a particular module arg0, returns whether arg1 is a valid option for arg0. optking(); Runs the geometry optimization / frequency analysis code. outfile_name(); Returns the name of the output file. plugin(arg0, arg1); Call the plugin of name arg0. plugin_close(arg0); Close the plugin of name arg0. plugin_close_all(); Close all open plugins. plugin_load(arg0); Load the plugin of name arg0. prepare_options_for_module(arg0); Sets the options module up to return options pertaining to the named argument (e.g. print_global_options(); Prints the currently set global (all modules) options to the output file. print_options(); Prints the currently set options (to the output file) for the current module. print_out(arg0); Prints a string (using sprintf-like notation) to the output file. print_variables(); Prints all PSI variables that have been set internally. psi_top_srcdir(); Returns the location of the source code. psimrcc(arg0); Runs the multireference coupled cluster code. reopen_outfile(); Reopens the output file. revoke_global_option_changed(arg0); Given a string of a keyword name arg1, sets the ha",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:260537,Performance,optimiz,optimize,260537," oe_ints]); Save integrals to file in FCIDUMP format as defined in Comp. fcidump_from_file(fname); Function to read in a FCIDUMP file. filter_comments(string); Remove from string any Python-style comments (‘#’ to end of line). find_approximate_string_matches(seq1, …); Function to compute approximate string matches from a list of options. freq(name, **kwargs); Function to compute harmonic vibrational frequencies. frequencies(name, **kwargs); Function to compute harmonic vibrational frequencies. frequency(name, **kwargs); Function to compute harmonic vibrational frequencies. gdma(wfn[, datafile]); Function to use wavefunction information in wfn and, if specified, additional commands in filename to run GDMA analysis. geometry(geom[, name]); Function to create a molecule object of name name from the geometry in string geom. getFromDict(dataDict, mapList). get_memory(); Function to return the total memory allocation. gradient(name, **kwargs); Function complementary to :py:func:~driver.optimize(). hessian(name, **kwargs); Function complementary to frequency(). join_path(prefix, *args). levenshtein(seq1, seq2); Function to compute the Levenshtein distance between two strings. molden(wfn[, filename, density_a, …]); Function to write wavefunction information in wfn to filename in molden format. molecule_from_arrays; classmethod(function) -> method. molecule_from_schema; classmethod(function) -> method. molecule_from_string; classmethod(function) -> method. molecule_get_attr(self, name); Function to redefine __getattr__ method of molecule class. molecule_set_attr(self, name, value); Function to redefine __setattr__ method of molecule class. oeprop(wfn, *args, **kwargs); Evaluate one-electron properties. opt(name, **kwargs); Function to perform a geometry optimization. optimize(name, **kwargs); Function to perform a geometry optimization. pcm_helper(block); Passes multiline string block to PCMSolver parser. print_stderr(stuff); Function to print stuff to standard error stream. ",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:261298,Performance,perform,perform,261298,"n to create a molecule object of name name from the geometry in string geom. getFromDict(dataDict, mapList). get_memory(); Function to return the total memory allocation. gradient(name, **kwargs); Function complementary to :py:func:~driver.optimize(). hessian(name, **kwargs); Function complementary to frequency(). join_path(prefix, *args). levenshtein(seq1, seq2); Function to compute the Levenshtein distance between two strings. molden(wfn[, filename, density_a, …]); Function to write wavefunction information in wfn to filename in molden format. molecule_from_arrays; classmethod(function) -> method. molecule_from_schema; classmethod(function) -> method. molecule_from_string; classmethod(function) -> method. molecule_get_attr(self, name); Function to redefine __getattr__ method of molecule class. molecule_set_attr(self, name, value); Function to redefine __setattr__ method of molecule class. oeprop(wfn, *args, **kwargs); Evaluate one-electron properties. opt(name, **kwargs); Function to perform a geometry optimization. optimize(name, **kwargs); Function to perform a geometry optimization. pcm_helper(block); Passes multiline string block to PCMSolver parser. print_stderr(stuff); Function to print stuff to standard error stream. print_stdout(stuff); Function to print stuff to standard output stream. process_input(raw_input[, print_level]); Function to preprocess raw input, the text of the input file, then parse it, validate it for format, and convert it into legitimate Python. process_pubchem_command(matchobj); Function to process match of pubchem in molecule block. prop(*args, **kwargs); Function to compute various properties. properties(*args, **kwargs); Function to compute various properties. sanitize_name(name); Function to return name in coded form, stripped of characters that confuse filenames, characters into lowercase, + into p, * into s, and (, ), -, & , into _. scf_helper(name[, post_scf]); Function serving as helper to SCF, choosing whether to cast up or jus",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:261317,Performance,optimiz,optimization,261317,"n to create a molecule object of name name from the geometry in string geom. getFromDict(dataDict, mapList). get_memory(); Function to return the total memory allocation. gradient(name, **kwargs); Function complementary to :py:func:~driver.optimize(). hessian(name, **kwargs); Function complementary to frequency(). join_path(prefix, *args). levenshtein(seq1, seq2); Function to compute the Levenshtein distance between two strings. molden(wfn[, filename, density_a, …]); Function to write wavefunction information in wfn to filename in molden format. molecule_from_arrays; classmethod(function) -> method. molecule_from_schema; classmethod(function) -> method. molecule_from_string; classmethod(function) -> method. molecule_get_attr(self, name); Function to redefine __getattr__ method of molecule class. molecule_set_attr(self, name, value); Function to redefine __setattr__ method of molecule class. oeprop(wfn, *args, **kwargs); Evaluate one-electron properties. opt(name, **kwargs); Function to perform a geometry optimization. optimize(name, **kwargs); Function to perform a geometry optimization. pcm_helper(block); Passes multiline string block to PCMSolver parser. print_stderr(stuff); Function to print stuff to standard error stream. print_stdout(stuff); Function to print stuff to standard output stream. process_input(raw_input[, print_level]); Function to preprocess raw input, the text of the input file, then parse it, validate it for format, and convert it into legitimate Python. process_pubchem_command(matchobj); Function to process match of pubchem in molecule block. prop(*args, **kwargs); Function to compute various properties. properties(*args, **kwargs); Function to compute various properties. sanitize_name(name); Function to return name in coded form, stripped of characters that confuse filenames, characters into lowercase, + into p, * into s, and (, ), -, & , into _. scf_helper(name[, post_scf]); Function serving as helper to SCF, choosing whether to cast up or jus",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:261331,Performance,optimiz,optimize,261331,"ng geom. getFromDict(dataDict, mapList). get_memory(); Function to return the total memory allocation. gradient(name, **kwargs); Function complementary to :py:func:~driver.optimize(). hessian(name, **kwargs); Function complementary to frequency(). join_path(prefix, *args). levenshtein(seq1, seq2); Function to compute the Levenshtein distance between two strings. molden(wfn[, filename, density_a, …]); Function to write wavefunction information in wfn to filename in molden format. molecule_from_arrays; classmethod(function) -> method. molecule_from_schema; classmethod(function) -> method. molecule_from_string; classmethod(function) -> method. molecule_get_attr(self, name); Function to redefine __getattr__ method of molecule class. molecule_set_attr(self, name, value); Function to redefine __setattr__ method of molecule class. oeprop(wfn, *args, **kwargs); Evaluate one-electron properties. opt(name, **kwargs); Function to perform a geometry optimization. optimize(name, **kwargs); Function to perform a geometry optimization. pcm_helper(block); Passes multiline string block to PCMSolver parser. print_stderr(stuff); Function to print stuff to standard error stream. print_stdout(stuff); Function to print stuff to standard output stream. process_input(raw_input[, print_level]); Function to preprocess raw input, the text of the input file, then parse it, validate it for format, and convert it into legitimate Python. process_pubchem_command(matchobj); Function to process match of pubchem in molecule block. prop(*args, **kwargs); Function to compute various properties. properties(*args, **kwargs); Function to compute various properties. sanitize_name(name); Function to return name in coded form, stripped of characters that confuse filenames, characters into lowercase, + into p, * into s, and (, ), -, & , into _. scf_helper(name[, post_scf]); Function serving as helper to SCF, choosing whether to cast up or just run SCF with a standard guess. scf_wavefunction_factory(name, ref_w",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:261369,Performance,perform,perform,261369,"ng geom. getFromDict(dataDict, mapList). get_memory(); Function to return the total memory allocation. gradient(name, **kwargs); Function complementary to :py:func:~driver.optimize(). hessian(name, **kwargs); Function complementary to frequency(). join_path(prefix, *args). levenshtein(seq1, seq2); Function to compute the Levenshtein distance between two strings. molden(wfn[, filename, density_a, …]); Function to write wavefunction information in wfn to filename in molden format. molecule_from_arrays; classmethod(function) -> method. molecule_from_schema; classmethod(function) -> method. molecule_from_string; classmethod(function) -> method. molecule_get_attr(self, name); Function to redefine __getattr__ method of molecule class. molecule_set_attr(self, name, value); Function to redefine __setattr__ method of molecule class. oeprop(wfn, *args, **kwargs); Evaluate one-electron properties. opt(name, **kwargs); Function to perform a geometry optimization. optimize(name, **kwargs); Function to perform a geometry optimization. pcm_helper(block); Passes multiline string block to PCMSolver parser. print_stderr(stuff); Function to print stuff to standard error stream. print_stdout(stuff); Function to print stuff to standard output stream. process_input(raw_input[, print_level]); Function to preprocess raw input, the text of the input file, then parse it, validate it for format, and convert it into legitimate Python. process_pubchem_command(matchobj); Function to process match of pubchem in molecule block. prop(*args, **kwargs); Function to compute various properties. properties(*args, **kwargs); Function to compute various properties. sanitize_name(name); Function to return name in coded form, stripped of characters that confuse filenames, characters into lowercase, + into p, * into s, and (, ), -, & , into _. scf_helper(name[, post_scf]); Function serving as helper to SCF, choosing whether to cast up or just run SCF with a standard guess. scf_wavefunction_factory(name, ref_w",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:261388,Performance,optimiz,optimization,261388,"ng geom. getFromDict(dataDict, mapList). get_memory(); Function to return the total memory allocation. gradient(name, **kwargs); Function complementary to :py:func:~driver.optimize(). hessian(name, **kwargs); Function complementary to frequency(). join_path(prefix, *args). levenshtein(seq1, seq2); Function to compute the Levenshtein distance between two strings. molden(wfn[, filename, density_a, …]); Function to write wavefunction information in wfn to filename in molden format. molecule_from_arrays; classmethod(function) -> method. molecule_from_schema; classmethod(function) -> method. molecule_from_string; classmethod(function) -> method. molecule_get_attr(self, name); Function to redefine __getattr__ method of molecule class. molecule_set_attr(self, name, value); Function to redefine __setattr__ method of molecule class. oeprop(wfn, *args, **kwargs); Evaluate one-electron properties. opt(name, **kwargs); Function to perform a geometry optimization. optimize(name, **kwargs); Function to perform a geometry optimization. pcm_helper(block); Passes multiline string block to PCMSolver parser. print_stderr(stuff); Function to print stuff to standard error stream. print_stdout(stuff); Function to print stuff to standard output stream. process_input(raw_input[, print_level]); Function to preprocess raw input, the text of the input file, then parse it, validate it for format, and convert it into legitimate Python. process_pubchem_command(matchobj); Function to process match of pubchem in molecule block. prop(*args, **kwargs); Function to compute various properties. properties(*args, **kwargs); Function to compute various properties. sanitize_name(name); Function to return name in coded form, stripped of characters that confuse filenames, characters into lowercase, + into p, * into s, and (, ), -, & , into _. scf_helper(name[, post_scf]); Function serving as helper to SCF, choosing whether to cast up or just run SCF with a standard guess. scf_wavefunction_factory(name, ref_w",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:263349,Performance,optimiz,optimizer,263349,"ndard guess. scf_wavefunction_factory(name, ref_wfn, …); Builds the correct wavefunction from the provided information. set_memory(inputval[, execute]); Function to reset the total memory allocation. set_module_options(module, options_dict); Sets Psi4 module options from a module specification and input dictionary. set_options(options_dict); Sets Psi4 global options from an input dictionary. success(label); Function to print a ‘label…PASSED’ line to screen. vibanal_wfn(wfn[, hess, irrep, molecule, …]). write_eigenvalues(eigs, mo_idx); Prepare multi-line string with one-particle eigenvalues to be written to the FCIDUMP file. xml2dict([filename]); Read XML filename into nested OrderedDict-s. Classes¶. CSXError(msg); Error called when CSX generation fails. ConvergenceError(eqn_description, maxit); Error called for problems with converging and iterative method. Dftd3Error(msg). EmpericalDispersion(alias, dtype, **kwargs). ManagedMethodError(circs). OptimizationConvergenceError(…); Error called for problems with geometry optimizer. ParsingError(msg); Error called for problems parsing a text file. PastureRequiredError(option); Error called when the specified value of option requires some module(s) from Psi4Pasture, but could not be imported. PsiException; Error class for Psi. PsiImportError(msg); Error called for problems import python dependencies. QMMM(). Table([rows, row_label_width, …]); Class defining a flexible Table object for storing data. TestComparisonError(msg); Error called when a test case fails due to a failed compare_values() call. ValidationError(msg); Error called for problems with the input file. datetime(year, month, day[, hour[, minute[, …); The year, month and day arguments are required. Class Inheritance Diagram¶. table of contents. PSI4 API: Linking C++ and Python; psi4.core Module; Functions; Classes; Class Inheritance Diagram. psi4.driver Package; Functions; Classes; Class Inheritance Diagram. «; hide menu. menu; sidebar; »; . Navigation. Index. m",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:126989,Safety,detect,detected,126989,"y. Return type; determined by concern_mol type. Return type:float, tuple, qcdb.Molecule or psi4.core.Molecule. BFS(seed_atoms=None, bond_threshold=1.2, return_arrays=False, return_molecules=False, return_molecule=False)¶; Detect fragments among real atoms through a breadth-first search (BFS) algorithm. Parameters:; self (qcdb.Molecule or psi4.core.Molecule) – ; seed_atoms (list, optional) – List of lists of atoms (0-indexed) belonging to independent fragments.; Useful to prompt algorithm or to define intramolecular fragments through; border atoms. Example: [[1, 0], [2]]; bond_threshold (float, optional) – Factor beyond average of covalent radii to determine bond cutoff.; return_arrays (bool, optional) – If True, also return fragments as list of arrays.; return_molecules (bool, optional) – If True, also return fragments as list of Molecules.; return_molecule (bool, optional) – If True, also return one big Molecule with fragmentation encoded. Returns:; bfs_map (list of lists) – Array of atom indices (0-indexed) of detected fragments.; bfs_arrays (tuple of lists of ndarray, optional) – geom, mass, elem info per-fragment.; Only provided if return_arrays is True.; bfs_molecules (list of qcdb.Molecule or psi4.core.Molecule, optional) – List of molecules, each built from one fragment. Center and; orientation of fragments is fixed so orientation info from self is; not lost. Loses chgmult and ghost/dummy info from self and contains; default chgmult.; Only provided if return_molecules is True.; Returned are of same type as self.; bfs_molecule (qcdb.Molecule or psi4.core.Molecule, optional) – Single molecule with same number of real atoms as self with atoms; reordered into adjacent fragments and fragment markers inserted.; Loses ghost/dummy info from self; keeps total charge but not total mult.; Only provided if return_molecule is True.; Returned is of same type as self. Notes. Relies upon van der Waals radii and so faulty for close (especially; hydrogen-bonded) fragments. See ",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:109947,Security,access,accessor,109947,"gradient-like matrix (N,3) using information from a given molecule. symmetry(self: psi4.core.Matrix) → int¶; Returns the overall symmetry of the matrix. to_array(copy=True, dense=False)¶; Converts a Psi4 Matrix or Vector to a numpy array. Either copies the data or simply; constructs a view. Parameters:; matrix (Matrix or Vector) – Pointers to which Psi4 core class should be used in the construction.; copy (bool, optional) – Copy the data if True, return a view otherwise; dense (bool, optional) – Converts irreped Psi4 objects to diagonally blocked dense arrays if True. Returns a list of arrays otherwise. Returns:array – Returns either a list of np.array’s or the base array depending on options. Return type:ndarray or list of ndarray. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; 1; 2; 3; 4; 5>>> data = psi4.Matrix(3, 3); >>> data.to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. to_serial()¶; Converts an object with a .nph accessor to a serialized dictionary. trace(self: psi4.core.Matrix) → float¶; Returns the trace of the matrix. transform(*args, **kwargs)¶; Overloaded function. transform(self: psi4.core.Matrix, transformer: psi4.core.Matrix) -> None. Transform this matrix with transformer. transform(self: psi4.core.Matrix, a: psi4.core.Matrix, transformer: psi4.core.Matrix) -> None. Transform A with transformer. transpose(self: psi4.core.Matrix) → psi4.core.Matrix¶; Creates a new matrix that is the transpose of this matrix. transpose_this(self: psi4.core.Matrix) → None¶; Transpose the matrix in-place. triplet(A: psi4.core.Matrix, B: psi4.core.Matrix, C: psi4.core.Matrix, transA: bool=False, transB: bool=False, transC: bool=False) → psi4.core.Matrix¶; Returns the multiplication of three matrics A, B, and C, with options to transpose each beforehand. vector_dot(self: psi4.core.Matrix, rhs: psi4.core.Matrix) → float¶; Returns the vector dot product of this with rhs. zero(self: psi4.core.Matrix) → None¶; Zero all elements",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:146501,Security,hash,hash,146501,"nt group to the point group object arg2. set_units(self: psi4.core.Molecule, arg0: psi4.core.GeometryUnits) → None¶; Sets units (Angstrom or Bohr) used to define the geometry. set_variable(self: psi4.core.Molecule, arg0: str, arg1: float) → None¶; Assigns the value arg3 to the variable arg2 in the list of geometry variables, then calls update_geometry(). symbol(self: psi4.core.Molecule, arg0: int) → str¶; Gets the cleaned up label of atom arg2 (C2 => C, H4 = H). symmetrize(self: psi4.core.Molecule, arg0: float) → None¶; Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. symmetry_from_input(self: psi4.core.Molecule) → str¶; Returns the symmetry specified in the input. to_arrays()¶; Exports coordinate info into NumPy arrays. Returns:; geom, mass, elem, elez, uniq (ndarray, ndarray, ndarray, ndarray, ndarray) – (nat, 3) geometry [a0].; (nat,) mass [u].; (nat,) element symbol.; (nat,) atomic number.; (nat,) hash of element symbol and mass.; Note that coordinate, orientation, and element information is; preserved but fragmentation, chgmult, and dummy/ghost is lost.; Usage; —–; geom, mass, elem, elez, uniq = molinstance.to_arrays(). to_dict(force_c1=False, force_units=False, np_out=True)¶; Serializes instance into Molecule dictionary. to_schema(dtype, units='Angstrom', return_type='json')¶; Serializes instance into JSON or YAML according to schema dtype. to_string(dtype, units='Angstrom', atom_format=None, ghost_format=None, width=17, prec=12)¶; Format a string representation of QM molecule. translate(self: psi4.core.Molecule, arg0: psi4.core.Vector3) → None¶; Translates molecule by arg2. units(self: psi4.core.Molecule) → str¶; Returns units used to define the geometry, i.e. ‘Angstrom’ or ‘Bohr’. update_geometry(self: psi4.core.Molecule) → None¶; Reevaluates the geometry with current variable values, orientation directives, etc. Must be called after initial Molecule definition by string. x(self: psi4.c",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:152687,Security,validat,validate,152687,"d function. get_str(self: psi4.core.Options, arg0: str) -> str. get string option. get_str(self: psi4.core.Options, arg0: str) -> str. get string option. read_globals(self: psi4.core.Options) → bool¶; expert. set_array(self: psi4.core.Options, arg0: str, arg1: str) → None¶; set array option. set_bool(self: psi4.core.Options, arg0: str, arg1: str, arg2: bool) → None¶; set bool option. set_current_module(self: psi4.core.Options, arg0: str) → None¶; sets arg0 (all CAPS) as current module. set_double(self: psi4.core.Options, arg0: str, arg1: str, arg2: float) → None¶; set double option. set_int(self: psi4.core.Options, arg0: str, arg1: str, arg2: int) → None¶; set int option. set_read_globals(self: psi4.core.Options, arg0: bool) → None¶; expert. set_str(self: psi4.core.Options, arg0: str, arg1: str, arg2: str) → None¶; set string option. set_str_i(self: psi4.core.Options, arg0: str, arg1: str, arg2: str) → None¶; set string option. validate_options(self: psi4.core.Options) → None¶; validate options for arg0 module. class psi4.core.OrbitalSpace¶; Bases: pybind11_builtins.pybind11_object; Contains information about the orbitals. C(self: psi4.core.OrbitalSpace) → psi4.core.Matrix¶; MO coefficient matrix, AO->MO or SO->MO transformation matrix. basisset(self: psi4.core.OrbitalSpace) → psi::BasisSet¶; The AO basis set used to create C. build_cabs_space(orb_space: psi4.core.OrbitalSpace, ri_space: psi4.core.OrbitalSpace, linear_tol: float) → psi4.core.OrbitalSpace¶; Given two spaces, it projects out one space from the other and returns the new spaces The first argument (orb_space) is the space to project out. The returned space will be orthogonal to this The second argument (ri_space) is the space that is being projected on. The returned space = this space - orb_space The third argument is the tolerance for linear dependencies. build_ri_space(molecule: psi::Molecule, obs_key: str, aux_key: str, lindep_tol: float) → psi4.core.OrbitalSpace¶; Given two basis sets, it merges the b",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:213594,Security,access,accessor,213594,". set_block(self: psi4.core.Vector, slice: psi4.core.Slice, block: psi4.core.Vector) → None¶; Set a vector block. shape¶; Shape of the Psi4 data object. to_array(copy=True, dense=False)¶; Converts a Psi4 Matrix or Vector to a numpy array. Either copies the data or simply; constructs a view. Parameters:; matrix (Matrix or Vector) – Pointers to which Psi4 core class should be used in the construction.; copy (bool, optional) – Copy the data if True, return a view otherwise; dense (bool, optional) – Converts irreped Psi4 objects to diagonally blocked dense arrays if True. Returns a list of arrays otherwise. Returns:array – Returns either a list of np.array’s or the base array depending on options. Return type:ndarray or list of ndarray. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; 1; 2; 3; 4; 5>>> data = psi4.Matrix(3, 3); >>> data.to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. to_serial()¶; Converts an object with a .nph accessor to a serialized dictionary. class psi4.core.Vector3¶; Bases: pybind11_builtins.pybind11_object; Class for vectors of length three, often Cartesian coordinate vectors, and their common operations. cross(self: psi4.core.Vector3, arg0: psi4.core.Vector3) → psi4.core.Vector3¶; Returns cross product of arg1 and arg2. distance(self: psi4.core.Vector3, arg0: psi4.core.Vector3) → float¶; Returns distance between two points represented by arg1 and arg2. dot(self: psi4.core.Vector3, arg0: psi4.core.Vector3) → float¶; Returns dot product of arg1 and arg2. norm(self: psi4.core.Vector3) → float¶; Returns Euclidean norm of arg1. normalize(self: psi4.core.Vector3) → None¶; Returns vector of unit length and arg1 direction. class psi4.core.VectorMatrix¶; Bases: pybind11_builtins.pybind11_object. append(self: List[psi::Matrix], x: psi::Matrix) → None¶; Add an item to the end of the list. count(self: List[psi::Matrix], x: psi::Matrix) → int¶; Return the number of times x appears in the list. extend(self: List[p",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:258040,Security,validat,validate,258040,"want those, see the staticmethod builtin. Functions¶. activate(mol); Function to set molecule object mol as the current active molecule. ancestor(dir[, n]); Get the nth ancestor of a directory. banner(text[, type, width, strNotOutfile]); Function to print text to output file in a banner of minimum width width and minimum three-line height for type = 1 or one-line height for type = 2. basis_helper(block[, name, key, set_option]); For PsiAPI mode, forms a basis specification function from block and associates it with keyword key under handle name. cbs(func, label, **kwargs); Function to define a multistage energy method from combinations of basis set extrapolations and delta corrections and condense the components into a minimum number of calculations. check_iwl_file_from_scf_type(scf_type, wfn); Ensures that a IWL file has been written based on input SCF type. compare_arrays(expected, computed, digits, label); Function to compare two numpy arrays. compare_csx(); Function to validate energies in CSX files against PSIvariables. compare_cubes(expected, computed, label); Function to compare two cube files. compare_fcidumps(expected, computed, label); Function to compare two FCIDUMP files. compare_integers(expected, computed, label); Function to compare two integers. compare_matrices(expected, computed, digits, …); Function to compare two matrices. compare_strings(expected, computed, label); Function to compare two strings. compare_values(expected, computed, digits, label); Function to compare two values. compare_vectors(expected, computed, digits, …); Function to compare two vectors. copy_file_from_scratch(filename, prefix, …); Function to move file out of scratch with correct naming convention. copy_file_to_scratch(filename, prefix, …); Function to move file into scratch with correct naming convention. create_plugin(name, template); Generate plugin in directory with sanitized name based upon template. csx2endict(); Grabs the CSX file as a dictionary, encodes translation",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:258947,Security,sanitiz,sanitized,258947,"_arrays(expected, computed, digits, label); Function to compare two numpy arrays. compare_csx(); Function to validate energies in CSX files against PSIvariables. compare_cubes(expected, computed, label); Function to compare two cube files. compare_fcidumps(expected, computed, label); Function to compare two FCIDUMP files. compare_integers(expected, computed, label); Function to compare two integers. compare_matrices(expected, computed, digits, …); Function to compare two matrices. compare_strings(expected, computed, label); Function to compare two strings. compare_values(expected, computed, digits, label); Function to compare two values. compare_vectors(expected, computed, digits, …); Function to compare two vectors. copy_file_from_scratch(filename, prefix, …); Function to move file out of scratch with correct naming convention. copy_file_to_scratch(filename, prefix, …); Function to move file into scratch with correct naming convention. create_plugin(name, template); Generate plugin in directory with sanitized name based upon template. csx2endict(); Grabs the CSX file as a dictionary, encodes translation of PSI variables to XML blocks, gathers all available energies from CSX file into returned dictionary. cubeprop(wfn, **kwargs); Evaluate properties on a grid and generate cube files. dynamic_variable_bind(cls); Function to dynamically add extra members to the core.Molecule class. energy(name, **kwargs); Function to compute the single-point electronic energy. fchk(wfn, filename); Function to write wavefunction information in wfn to filename in Gaussian FCHK format. fcidump(wfn[, fname, oe_ints]); Save integrals to file in FCIDUMP format as defined in Comp. fcidump_from_file(fname); Function to read in a FCIDUMP file. filter_comments(string); Remove from string any Python-style comments (‘#’ to end of line). find_approximate_string_matches(seq1, …); Function to compute approximate string matches from a list of options. freq(name, **kwargs); Function to compute harmonic",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:261733,Security,validat,validate,261733,"ance between two strings. molden(wfn[, filename, density_a, …]); Function to write wavefunction information in wfn to filename in molden format. molecule_from_arrays; classmethod(function) -> method. molecule_from_schema; classmethod(function) -> method. molecule_from_string; classmethod(function) -> method. molecule_get_attr(self, name); Function to redefine __getattr__ method of molecule class. molecule_set_attr(self, name, value); Function to redefine __setattr__ method of molecule class. oeprop(wfn, *args, **kwargs); Evaluate one-electron properties. opt(name, **kwargs); Function to perform a geometry optimization. optimize(name, **kwargs); Function to perform a geometry optimization. pcm_helper(block); Passes multiline string block to PCMSolver parser. print_stderr(stuff); Function to print stuff to standard error stream. print_stdout(stuff); Function to print stuff to standard output stream. process_input(raw_input[, print_level]); Function to preprocess raw input, the text of the input file, then parse it, validate it for format, and convert it into legitimate Python. process_pubchem_command(matchobj); Function to process match of pubchem in molecule block. prop(*args, **kwargs); Function to compute various properties. properties(*args, **kwargs); Function to compute various properties. sanitize_name(name); Function to return name in coded form, stripped of characters that confuse filenames, characters into lowercase, + into p, * into s, and (, ), -, & , into _. scf_helper(name[, post_scf]); Function serving as helper to SCF, choosing whether to cast up or just run SCF with a standard guess. scf_wavefunction_factory(name, ref_wfn, …); Builds the correct wavefunction from the provided information. set_memory(inputval[, execute]); Function to reset the total memory allocation. set_module_options(module, options_dict); Sets Psi4 module options from a module specification and input dictionary. set_options(options_dict); Sets Psi4 global options from an input dicti",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:105234,Testability,test,tests,105234," matrix argument B Right matrix argument beta Prefactor for the resulting matrix. general_invert(self: psi4.core.Matrix) → None¶; Computes the inverse of any nonsingular matrix using LU factorization. get(*args, **kwargs)¶; Overloaded function. get(self: psi4.core.Matrix, h: int, m: int, n: int) -> float. Returns a single element of a matrix in subblock h, row m, col n. get(self: psi4.core.Matrix, m: int, n: int) -> float. Returns a single element of a matrix, row m, col n. get_block(self: psi4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice) → psi4.core.Matrix¶; Get a matrix block. hermitivitize(self: psi4.core.Matrix) → None¶; Average off-diagonal element in-place. identity(self: psi4.core.Matrix) → None¶; Sets the matrix to the identity. invert(self: psi4.core.Matrix) → None¶; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs)¶; Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType=SaveType.LowerTriangle) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str) → None¶; Loads a matrix from an ASCII file in MPQC format. name¶; The name of the Matrix. Used in printing. nirrep(self: psi4.core.Matrix) → int¶; Returns the number of irreps. np¶; View without only one irrep. classmethod np_read(filename, prefix='')¶; Reads the data from a NumPy compress file. np_write(filename=None, prefix='')¶; Writes the irreped matrix to a NumPy zipped file.; Can return the packed data for saving many matrices into the same file. nph¶; View with irreps. partial_cholesky_factorize(self: psi4.core.Matri",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:125191,Testability,test,test,125191,"; psi4.core.Molecule. Employs the Kabsch, Hungarian, and; Uno algorithms to exhaustively locate the best alignment for; non-oriented, non-ordered structures. Parameters:; concern_mol (qcdb.Molecule or psi4.core.Molecule) – Molecule of concern, to be shifted, rotated, and reordered into; best coincidence with ref_mol.; ref_mol (qcdb.Molecule or psi4.core.Molecule) – Molecule to match.; atoms_map (bool, optional) – Whether atom1 of ref_mol corresponds to atom1 of concern_mol, etc.; If true, specifying True can save much time.; mols_align (bool, optional) – Whether ref_mol and concern_mol have identical geometries by eye; (barring orientation or atom mapping) and expected final RMSD = 0.; If True, procedure is truncated when RMSD condition met, saving time.; do_plot (bool, optional) – Pops up a mpl plot showing before, after, and ref geometries.; run_to_completion (bool, optional) – Run reorderings to completion (past RMSD = 0) even if unnecessary because; mols_align=True. Used to test worst-case timings.; run_resorting (bool, optional) – Run the resorting machinery even if unnecessary because atoms_map=True.; uno_cutoff (float, optional) – TODO; run_mirror (bool, optional) – Run alternate geometries potentially allowing best match to ref_mol; from mirror image of concern_mol. Only run if system confirmed to; be nonsuperimposable upon mirror reflection. Returns:First item is RMSD [A] between ref_mol and the optimally aligned; geometry computed.; Second item is a AlignmentMill namedtuple with fields; (shift, rotation, atommap, mirror) that prescribe the transformation; from concern_mol and the optimally aligned geometry.; Third item is a crude charge-, multiplicity-, fragment-less Molecule; at optimally aligned (and atom-ordered) geometry. Return type; determined by concern_mol type. Return type:float, tuple, qcdb.Molecule or psi4.core.Molecule. BFS(seed_atoms=None, bond_threshold=1.2, return_arrays=False, return_molecules=False, return_molecule=False)¶; Detect fragments",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:143642,Testability,test,test,143642,"specified; vector, supply a 3-element list.; do_rotate (bool or array-like, optional) – Whether to generate a random 3D rotation according to algorithm of Arvo.; To rotate by a specified matrix, supply a 9-element list of lists.; do_resort (bool or array-like, optional) – Whether to shuffle atoms (True) or leave 1st atom 1st, etc. (False).; To specify shuffle, supply a nat-element list of indices.; deflection (float, optional) – If do_rotate, how random a rotation: 0.0 is no change, 0.1 is small; perturbation, 1.0 is completely random.; do_mirror (bool, optional) – Whether to construct the mirror image structure by inverting y-axis.; do_plot (bool, optional) – Pops up a mpl plot showing before, after, and ref geometries.; run_to_completion (bool, optional) – By construction, scrambled systems are fully alignable (final RMSD=0).; Even so, True turns off the mechanism to stop when RMSD reaches zero; and instead proceed to worst possible time.; run_resorting (bool, optional) – Even if atoms not shuffled, test the resorting machinery.; verbose (int, optional) – Print level. Returns:. Return type:None. set_active_fragment(self: psi4.core.Molecule, arg0: int) → None¶; Sets the specified fragment arg2 to be Real. set_active_fragments(self: psi4.core.Molecule, arg0: List[int]) → None¶; Sets the specified list arg2 of fragments to be Real. set_basis_all_atoms(self: psi4.core.Molecule, arg0: str, arg1: str) → None¶; Sets basis set arg2 to all atoms. set_basis_by_label(self: psi4.core.Molecule, arg0: str, arg1: str, arg2: str) → None¶; Sets basis set arg3 to all atoms with label (e.g., H4) arg2. set_basis_by_symbol(self: psi4.core.Molecule, arg0: str, arg1: str, arg2: str) → None¶; Sets basis set arg3 to all atoms with symbol (e.g., H) arg2. set_geometry(self: psi4.core.Molecule, arg0: psi4.core.Matrix) → None¶; Sets the geometry, given a (Natom X 3) matrix arg2 of coordinates (in Bohr). set_ghost_fragment(self: psi4.core.Molecule, arg0: int) → None¶; Sets the specified fragme",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:191596,Testability,test,testing,191596,"¶; Locks the functional to prevent changes. set_max_points(self: psi4.core.SuperFunctional, arg0: int) → None¶; Sets the maximum number of points. set_name(self: psi4.core.SuperFunctional, arg0: str) → None¶; Sets the SuperFunctional name. set_vv10_b(self: psi4.core.SuperFunctional, arg0: float) → None¶; Sets the VV10 b parameter. set_vv10_c(self: psi4.core.SuperFunctional, arg0: float) → None¶; Sets the VV10 c parameter. set_x_alpha(self: psi4.core.SuperFunctional, arg0: float) → None¶; Sets the amount of exact global HF exchange. set_x_beta(self: psi4.core.SuperFunctional, arg0: float) → None¶; Sets the amount of exact HF exchange at long range. set_x_omega(self: psi4.core.SuperFunctional, arg0: float) → None¶; Sets the range-seperation exchange parameter. test_functional(self: psi4.core.SuperFunctional, arg0: psi4.core.Vector, arg1: psi4.core.Vector, arg2: psi4.core.Vector, arg3: psi4.core.Vector, arg4: psi4.core.Vector, arg5: psi4.core.Vector, arg6: psi4.core.Vector) → None¶; Quick testing capabilities. value(self: psi4.core.SuperFunctional, arg0: str) → psi4.core.Vector¶; Returns a given internal value. values(self: psi4.core.SuperFunctional) → Dict[str, psi4.core.Vector]¶; Return all internal values. vv10_b(self: psi4.core.SuperFunctional) → float¶; The VV10 b parameter. vv10_c(self: psi4.core.SuperFunctional) → float¶; The VV10 c parameter. x_alpha(self: psi4.core.SuperFunctional) → float¶; Amount of exact HF exchange. x_beta(self: psi4.core.SuperFunctional) → float¶; Amount of exact HF exchange. x_functional(self: psi4.core.SuperFunctional, arg0: str) → psi::Functional¶; Returns the desired X Functional. x_functionals(self: psi4.core.SuperFunctional) → List[psi::Functional]¶; Returns all X Functionals. x_omega(self: psi4.core.SuperFunctional) → float¶; Range-seperated exchange parameter. class psi4.core.SymmetryOperation¶; Bases: pybind11_builtins.pybind11_object; Class to provide a 3 by 3 matrix representation of a symmetry operation, such as a rotation or ",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:263829,Testability,test,test,263829,"et the total memory allocation. set_module_options(module, options_dict); Sets Psi4 module options from a module specification and input dictionary. set_options(options_dict); Sets Psi4 global options from an input dictionary. success(label); Function to print a ‘label…PASSED’ line to screen. vibanal_wfn(wfn[, hess, irrep, molecule, …]). write_eigenvalues(eigs, mo_idx); Prepare multi-line string with one-particle eigenvalues to be written to the FCIDUMP file. xml2dict([filename]); Read XML filename into nested OrderedDict-s. Classes¶. CSXError(msg); Error called when CSX generation fails. ConvergenceError(eqn_description, maxit); Error called for problems with converging and iterative method. Dftd3Error(msg). EmpericalDispersion(alias, dtype, **kwargs). ManagedMethodError(circs). OptimizationConvergenceError(…); Error called for problems with geometry optimizer. ParsingError(msg); Error called for problems parsing a text file. PastureRequiredError(option); Error called when the specified value of option requires some module(s) from Psi4Pasture, but could not be imported. PsiException; Error class for Psi. PsiImportError(msg); Error called for problems import python dependencies. QMMM(). Table([rows, row_label_width, …]); Class defining a flexible Table object for storing data. TestComparisonError(msg); Error called when a test case fails due to a failed compare_values() call. ValidationError(msg); Error called for problems with the input file. datetime(year, month, day[, hour[, minute[, …); The year, month and day arguments are required. Class Inheritance Diagram¶. table of contents. PSI4 API: Linking C++ and Python; psi4.core Module; Functions; Classes; Class Inheritance Diagram. psi4.driver Package; Functions; Classes; Class Inheritance Diagram. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:61587,Usability,clear,clear,61587,"iven shell pair. origin¶; The origin about which the one body ints are being computed. class psi4.core.ErfComplementERI¶; Bases: psi4.core.TwoBodyAOInt; Computes ERF complement electron repulsion integrals. compute_shell(self: psi4.core.TwoBodyAOInt, arg0: int, arg1: int, arg2: int, arg3: int) → int¶; Compute ERIs between 4 shells. class psi4.core.ErfERI¶; Bases: psi4.core.TwoBodyAOInt; Computes ERF electron repulsion integrals. compute_shell(self: psi4.core.TwoBodyAOInt, arg0: int, arg1: int, arg2: int, arg3: int) → int¶; Compute ERIs between 4 shells. class psi4.core.ExternalPotential¶; Bases: pybind11_builtins.pybind11_object; Stores external potential field, computes external potential matrix. addBasis(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet, coefs: psi4.core.Vector) → None¶; Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self: psi4.core.ExternalPotential, Z: float, x: float, y: float, z: float) → None¶; Add a charge Z at (x,y,z). clear(self: psi4.core.ExternalPotential) → None¶; Reset the field to zero (eliminates all entries). computePotentialMatrix(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet) → psi4.core.Matrix¶; Compute the external potential matrix in the given basis set. print_out(self: psi4.core.ExternalPotential) → None¶; Print python print helper to the outfile. setName(self: psi4.core.ExternalPotential, arg0: str) → None¶; Sets the name. class psi4.core.F12¶; Bases: psi4.core.TwoBodyAOInt; Computes F12 electron repulsion integrals. compute_shell(self: psi4.core.TwoBodyAOInt, arg0: int, arg1: int, arg2: int, arg3: int) → int¶; Compute ERIs between 4 shells. class psi4.core.F12DoubleCommutator¶; Bases: psi4.core.TwoBodyAOInt; Computes F12 Double Commutator electron repulsion integrals. compute_shell(self: psi4.core.TwoBodyAOInt, arg0: int, arg1: int, arg2: int, arg3: int) → int¶; Compute ERIs between 4 shells. class psi4.core.F12G12¶; Bases: psi4.core.TwoBodyAOInt; Computes F12G12 electron repul",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:109228,Usability,simpl,simply,109228,"al. set(self: psi4.core.Matrix, m: int, n: int, val: float) -> None. Sets a single element of a matrix to val at row m, col n. set(self: psi4.core.Matrix, h: int, m: int, n: int, val: float) -> None. Sets a single element of a matrix, subblock h, row m, col n, with value val. set_block(self: psi4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice, block: psi4.core.Matrix) → None¶; Set a matrix block. shape¶; Shape of the Psi4 data object. subtract(self: psi4.core.Matrix, arg0: psi4.core.Matrix) → None¶; Substract a matrix from this matrix. sum_of_squares(self: psi4.core.Matrix) → float¶; Returns the sum of the squares of this matrix. symmetrize_gradient(self: psi4.core.Matrix, mol: psi::Molecule) → None¶; Symmetrizes a gradient-like matrix (N,3) using information from a given molecule. symmetry(self: psi4.core.Matrix) → int¶; Returns the overall symmetry of the matrix. to_array(copy=True, dense=False)¶; Converts a Psi4 Matrix or Vector to a numpy array. Either copies the data or simply; constructs a view. Parameters:; matrix (Matrix or Vector) – Pointers to which Psi4 core class should be used in the construction.; copy (bool, optional) – Copy the data if True, return a view otherwise; dense (bool, optional) – Converts irreped Psi4 objects to diagonally blocked dense arrays if True. Returns a list of arrays otherwise. Returns:array – Returns either a list of np.array’s or the base array depending on options. Return type:ndarray or list of ndarray. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; 1; 2; 3; 4; 5>>> data = psi4.Matrix(3, 3); >>> data.to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. to_serial()¶; Converts an object with a .nph accessor to a serialized dictionary. trace(self: psi4.core.Matrix) → float¶; Returns the trace of the matrix. transform(*args, **kwargs)¶; Overloaded function. transform(self: psi4.core.Matrix, transformer: psi4.core.Matrix) -> None. Transform this matrix with transformer. transfo",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:149480,Usability,clear,clear,149480,"Write the natural bond orbitals to a file. class psi4.core.NablaInt¶; Bases: psi4.core.OneBodyAOInt; Computes nabla integrals. basis¶; The basis set on center one. basis1¶; The basis set on center one. basis2¶; The basis set on center two. compute_shell(self: psi4.core.OneBodyAOInt, arg0: int, arg1: int) → None¶; Compute integrals between basis functions in the given shell pair. origin¶; The origin about which the one body ints are being computed. class psi4.core.OEProp¶; Bases: psi4.core.Prop; docstring. Exvals(self: psi4.core.OEProp) → List[float]¶; The x component of the field (in a.u.) at each grid point. Eyvals(self: psi4.core.OEProp) → List[float]¶; The y component of the field (in a.u.) at each grid point. Ezvals(self: psi4.core.OEProp) → List[float]¶; The z component of the field (in a.u.) at each grid point. Vvals(self: psi4.core.OEProp) → List[float]¶; The electrostatic potential (in a.u.) at each grid point. add(self: psi4.core.OEProp, arg0: str) → None¶; docstring. clear(self: psi4.core.OEProp) → None¶; docstring. compute(self: psi4.core.OEProp) → None¶; docstring. set_Da_ao(self: psi4.core.OEProp, Da: psi::Matrix, symmetry: int=0) → None¶; docstring. set_Da_mo(self: psi4.core.OEProp, arg0: psi::Matrix) → None¶; docstring. set_Da_so(self: psi4.core.OEProp, arg0: psi::Matrix) → None¶; docstring. set_Db_ao(self: psi4.core.OEProp, Db: psi::Matrix, symmetry: int=0) → None¶; docstring. set_Db_mo(self: psi4.core.OEProp, arg0: psi::Matrix) → None¶; docstring. set_Db_so(self: psi4.core.OEProp, arg0: psi::Matrix) → None¶; docstring. set_title(self: psi4.core.Prop, arg0: str) → None¶; docstring. valid_methods = ['DIPOLE', 'QUADRUPOLE', 'MULLIKEN_CHARGES', 'LOWDIN_CHARGES', 'WIBERG_LOWDIN_INDICES', 'MAYER_INDICES', 'MAYER_INDICES', 'MO_EXTENTS', 'GRID_FIELD', 'GRID_ESP', 'ESP_AT_NUCLEI', 'NO_OCCUPATIONS']¶. class psi4.core.OneBodyAOInt¶; Bases: pybind11_builtins.pybind11_object; Basis class for all one-electron integrals. basis¶; The basis set on center one. basis1",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psi4api.html:212875,Usability,simpl,simply,212875,"s. np¶; View without only one irrep. classmethod np_read(filename, prefix='')¶; Reads the data from a NumPy compress file. np_write(filename=None, prefix='')¶; Writes the irreped matrix to a NumPy zipped file.; Can return the packed data for saving many matrices into the same file. nph¶; View with irreps. print_out(self: psi4.core.Vector) → None¶; Prints the vector to the output file. scale(self: psi4.core.Vector, sc: float) → None¶; Scales the elements of a vector by sc. set(*args, **kwargs)¶; Overloaded function. set(self: psi4.core.Vector, m: int, val: float) -> None. Sets a single element value located at m. set(self: psi4.core.Vector, h: int, m: int, val: float) -> None. Sets a single element value located at m in irrep h. set_block(self: psi4.core.Vector, slice: psi4.core.Slice, block: psi4.core.Vector) → None¶; Set a vector block. shape¶; Shape of the Psi4 data object. to_array(copy=True, dense=False)¶; Converts a Psi4 Matrix or Vector to a numpy array. Either copies the data or simply; constructs a view. Parameters:; matrix (Matrix or Vector) – Pointers to which Psi4 core class should be used in the construction.; copy (bool, optional) – Copy the data if True, return a view otherwise; dense (bool, optional) – Converts irreped Psi4 objects to diagonally blocked dense arrays if True. Returns a list of arrays otherwise. Returns:array – Returns either a list of np.array’s or the base array depending on options. Return type:ndarray or list of ndarray. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; 1; 2; 3; 4; 5>>> data = psi4.Matrix(3, 3); >>> data.to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. to_serial()¶; Converts an object with a .nph accessor to a serialized dictionary. class psi4.core.Vector3¶; Bases: pybind11_builtins.pybind11_object; Class for vectors of length three, often Cartesian coordinate vectors, and their common operations. cross(self: psi4.core.Vector3, arg0: psi4.core.Vector3) → psi4.core.Vector3¶",MatchSource.WIKI,psi4manual/1.2.1/psi4api.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api.html
https://psicode.org/psi4manual/1.2.1/psiapi-1.html:2863,Availability,avail,available,2863,"is selected. I. Basic Input Structure¶; Psi4 is now a Python module; so, we need to import it into our Python; environment:. In [1]:. try:; import os, sys; sys.path.insert(1, os.path.abspath('/scratch/psilocaluser/conda-builds/psi4-docs-multiout_1532505956776/work/build/stage//opt/anaconda1anaconda2anaconda3/lib/python3.6/site-packages')); except ImportError:; pass. import psi4. Psi4 is now able to be controlled directly from Python. By default, Psi4; will print any output to the screen; this can be changed by giving a; file name (with path if not in the current working directory) to the; function psi4.core.set_output_file(); API,; as a string:. In [2]:. psi4.core.set_output_file('output.dat', False). Additionally, output may be suppressed by instead setting; psi4.core.be_quiet(); API. II. Running a Basic Hartree-Fock Calculation¶; In our first example, we will consider a Hartree-Fock SCF computation; for the water molecule using a cc-pVDZ basis set. First, we will set the; available memory for Psi4 to use with the psi4.set_memory(); API; function, which takes either a string like '30 GB' (with units!) or; an integer number of bytes of memory as its argument. Next, our; molecular geometry is passed as a string into psi4.geometry(); API.; We may input this geometry in either Z-matrix or Cartesian format; to; allow the string to break over multiple lines, use Python’s triple-quote; """"""string"""""" syntax. Finally, we will compute the Hartree-Fock SCF; energy with the cc-pVDZ basis set by passing the method/basis set as a; string ('scf/cc-pvdz') into the function psi4.energy(); API:. In [3]:. #! Sample HF/cc-pVDZ H2O Computation. psi4.set_memory('500 MB'). h2o = psi4.geometry(""""""; O; H 1 0.96; H 1 0.96 2 104.5; """"""). psi4.energy('scf/cc-pvdz'). Out[3]:. -76.02663273488399. If everything goes well, the computation should complete and should; report a final restricted Hartree-Fock energy in the output file; output.dat in a section like this:; Energy converged. @DF-RHF Final",MatchSource.WIKI,psi4manual/1.2.1/psiapi-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi-1.html
https://psicode.org/psi4manual/1.2.1/psiapi-1.html:7690,Availability,down,downhill,7690,",; such as geometry optimizations and vibrational frequency computations.; These can be specified by replacing psi4.energy(); API; with psi4.optimize(); API; or psi4.frequency(); API,; respectively.; Let’s take a look at an example of optimizing the H\(_2\)O; molecule using Hartree-Fock with a cc-pVDZ basis set.; Now, here comes the real beauty of running Psi4 interactively: above,; when we computed the energy of H\(_2\)O with HF/cc-pVDZ, we; defined the Psi4 molecule object h2o. Since we’re still in the; Python shell, as long as you executed that block of code, we can reuse; the h2o molecule object in our optimization without redefining it,; by adding the molecule=h2o argument to the psi4.optimize(); API; function:. In [5]:. psi4.set_options({'reference': 'rhf'}); psi4.optimize('scf/cc-pvdz', molecule=h2o). Optimizer: Optimization complete!. Out[5]:. -76.02703272937504. This should perform a series of gradient computations. The gradient; points which way is downhill in energy, and the optimizer then modifies; the geometry to follow the gradient. After a few cycles, the geometry; should converge with a message like Optimization complete!. As; indicated in the following table (printed by the optimizer at the end of; the computation and grep-able with ~), the energy decreases with; each step, and the maximum force on each atom also decreases with each; step (in principle, these numbers could increase in some iterations, but; here they do not).; --------------------------------------------------------------------------------------------------------------- ~  Step         Total Energy             Delta E       MAX Force       RMS Force        MAX Disp        RMS Disp  ~ --------------------------------------------------------------------------------------------------------------- ~     1     -76.026632734908    -76.026632734908      0.01523518      0.01245755      0.02742222      0.02277530  ~     2     -76.027022666011     -0.000389931104      0.00178779      0.0014294",MatchSource.WIKI,psi4manual/1.2.1/psiapi-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi-1.html
https://psicode.org/psi4manual/1.2.1/psiapi-1.html:9937,Availability,error,errors,9937,"--------------------------------------------------------------------------- ~; To get harmonic vibrational frequencies, it’s important to keep in mind; that the values of the vibrational frequencies are a function of the; molecular geometry. Therefore, it’s important to obtain the vibrational; frequencies AT THE OPTIMIZED GEOMETRY. Luckily, Psi4 updates the; molecule with optimized geometry as it is being optimized. So, the; optimized geometry for H\(_2\)O is stored inside the h2o; molecule object, which we can access! To compute the frequencies, all we; need to do is to again pass the molecule=h2o argument to the; psi4.frequency(); API; function:. In [6]:. scf_e, scf_wfn = psi4.frequency('scf/cc-pvdz', molecule=h2o, return_wfn=True, dertype=1). 6 displacements needed.; 1 2 3 4 5 6. Executing this cell will prompt Psi4 to compute the Hessian (second; derivative matrix) of the electronic energy with respect to nuclear; displacements. From this, it can obtain the harmonic vibrational; frequencies, given below (roundoff errors of around \(0.1\); cm\(^{-1}\) may exist):; Irrep Harmonic Frequency; (cm-1); -----------------------------------------------; A1 1775.6478; A1 4113.3795; B2 4212.1814; -----------------------------------------------. Notice the symmetry type of the normal modes is specified (A1, A1, B2).; The program also print out the normal modes in terms of Cartesian; coordinates of each atom. For example, the normal mode at \(1776\); cm\(^{-1}\) is:; Frequency: 1775.65; Force constant: 0.1193; X Y Z mass; O 0.000 0.000 -0.068 15.994915; H 0.000 0.416 0.536 1.007825; H 0.000 -0.416 0.536 1.007825. where the table shows the displacements in the X, Y, and Z dimensions; for each atom along the normal mode coordinate. (This information could; be used to animate the vibrational frequency using visualization; software.); Because the vibrational frequencies are available, a thermodynamics; analysis is automatically performed at the end of the computation. You; can s",MatchSource.WIKI,psi4manual/1.2.1/psiapi-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi-1.html
https://psicode.org/psi4manual/1.2.1/psiapi-1.html:10798,Availability,avail,available,10798,"to nuclear; displacements. From this, it can obtain the harmonic vibrational; frequencies, given below (roundoff errors of around \(0.1\); cm\(^{-1}\) may exist):; Irrep Harmonic Frequency; (cm-1); -----------------------------------------------; A1 1775.6478; A1 4113.3795; B2 4212.1814; -----------------------------------------------. Notice the symmetry type of the normal modes is specified (A1, A1, B2).; The program also print out the normal modes in terms of Cartesian; coordinates of each atom. For example, the normal mode at \(1776\); cm\(^{-1}\) is:; Frequency: 1775.65; Force constant: 0.1193; X Y Z mass; O 0.000 0.000 -0.068 15.994915; H 0.000 0.416 0.536 1.007825; H 0.000 -0.416 0.536 1.007825. where the table shows the displacements in the X, Y, and Z dimensions; for each atom along the normal mode coordinate. (This information could; be used to animate the vibrational frequency using visualization; software.); Because the vibrational frequencies are available, a thermodynamics; analysis is automatically performed at the end of the computation. You; can see this in the next section of the output file output.dat. The; vibrational frequencies are sufficient to obtain vibrational; contributions to enthalpy (H), entropy (S), and Gibbs free energy (G).; Similarly, the molecular geometry is used to obtain rotational; constants, which are then used to obtain rotational contributions to H,; S, and G.; Note: Psi4 has several synonyms for the functions called in this; example. For instance, psi4.frequency(); API; will compute molecular vibrational frequencies, and psi4.optimize(); API; will perform a geometry optimization. IV. Analysis of Intermolecular Interactions¶; Now let’s consider something a little more interesting. Psi4 contains; code to analyze the nature of intermolecular interactions between two; molecules, via symmetry-adapted perturbation theory (SAPT); (Jeziorski:1994:1887).; This kind of analysis gives a lot of insight into the nature of; intermolecula",MatchSource.WIKI,psi4manual/1.2.1/psiapi-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi-1.html
https://psicode.org/psi4manual/1.2.1/psiapi-1.html:13681,Availability,error,error,13681,"sapt0/jun-cc-pvdz', molecule=dimer). Out[8]:. -0.0022355825227244703. All of the options we have currently set using psi4.set_options(); API; are “global” options (meaning that they are visible to all parts of the; program). Most common Psi4 options can be set like this. If an option; needs to be visible only to one part of the program (e.g., we only; want to increase the energy convergence in the SCF code, but not the; rest of the code), it can be set by with the; psi4.set_module_options(); API; function, psi4.set_module_options('scf', {'e_convergence': '1e-8'}).; Note: The arguments to the functions we’ve used so far, like; psi4.set_options(); API,; psi4.set_module_options(); API,; psi4.energy(); API,; psi4.optimize(); API,; psi4.frequency(); API,; etc., are case-insensitive.; Back to our SAPT example, we have found that for basic-level SAPT; computations (i.e., SAPT0), a good error cancellation is found; (Hohenstein:2012:WIREs); with the jun-cc-pVDZ basis (this is the usual aug-cc-pVDZ basis, but; without diffuse functions on hydrogen and without diffuse \(d\); functions on heavy atoms); (Papajak:2011:10).; So, we’ll use that as our standard basis set. The SAPT code is designed; to use density fitting techniques, because they introduce minimal errors; while providing much faster computations; (Hohenstein:2010:184111,Hohenstein:2010:014101).; Since we’re using density fitting for the SAPT, we might as well also; use it for the Hartree-Fock computations that are performed as part of; the SAPT. We can specify that by adding 'scf_type': 'df' to the; dictionary passed to psi4.set_options().; Density fitting procedures require the use of auxiliary basis sets that; pair with the primary basis set. Fortunately, Psi4 is usually smart; enough to figure out what auxiliary basis sets are needed for a given; computation. In this case, jun-cc-pVDZ is a standard enough basis set; (just a simple truncation of the very popular aug-cc-pVDZ basis set); that Psi4 correctly guesses th",MatchSource.WIKI,psi4manual/1.2.1/psiapi-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi-1.html
https://psicode.org/psi4manual/1.2.1/psiapi-1.html:14056,Availability,error,errors,14056,"s. If an option; needs to be visible only to one part of the program (e.g., we only; want to increase the energy convergence in the SCF code, but not the; rest of the code), it can be set by with the; psi4.set_module_options(); API; function, psi4.set_module_options('scf', {'e_convergence': '1e-8'}).; Note: The arguments to the functions we’ve used so far, like; psi4.set_options(); API,; psi4.set_module_options(); API,; psi4.energy(); API,; psi4.optimize(); API,; psi4.frequency(); API,; etc., are case-insensitive.; Back to our SAPT example, we have found that for basic-level SAPT; computations (i.e., SAPT0), a good error cancellation is found; (Hohenstein:2012:WIREs); with the jun-cc-pVDZ basis (this is the usual aug-cc-pVDZ basis, but; without diffuse functions on hydrogen and without diffuse \(d\); functions on heavy atoms); (Papajak:2011:10).; So, we’ll use that as our standard basis set. The SAPT code is designed; to use density fitting techniques, because they introduce minimal errors; while providing much faster computations; (Hohenstein:2010:184111,Hohenstein:2010:014101).; Since we’re using density fitting for the SAPT, we might as well also; use it for the Hartree-Fock computations that are performed as part of; the SAPT. We can specify that by adding 'scf_type': 'df' to the; dictionary passed to psi4.set_options().; Density fitting procedures require the use of auxiliary basis sets that; pair with the primary basis set. Fortunately, Psi4 is usually smart; enough to figure out what auxiliary basis sets are needed for a given; computation. In this case, jun-cc-pVDZ is a standard enough basis set; (just a simple truncation of the very popular aug-cc-pVDZ basis set); that Psi4 correctly guesses that we want the jun-cc-pVDZ-JKFIT auxiliary; basis for the Hartree-Fock, and the jun-cc-pVDZ-RI basis set for the; SAPT procedure.; To speed up the computation a little, we also tell the SAPT procedure to; freeze the core electrons by adding 'freeze_core': 'true' to th",MatchSource.WIKI,psi4manual/1.2.1/psiapi-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi-1.html
https://psicode.org/psi4manual/1.2.1/psiapi-1.html:865,Deployability,release,release,865,"﻿. PsiAPI Tutorial: Using Psi4 as a Python Module. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. A PSI4 Tutorial. PsiAPI Tutorial: Using Psi4 as a Python Module¶; transcribed by D. A. Sirianni. Note: Psithon and PsiAPI refer to two modes of interacting with; Psi4. In Psithon mode, you write an input file in our domain-specific; language (not quite Python) where commands don’t have psi4. in; front, then submit it to the executable psi4 which processes the; Psithon into pure Python and runs it internally. In PsiAPI mode, you; write a pure Python script with import psi4 at the top and commands; are behind the psi4. namespace, then submit it to the python; interpreter. Both modes are equally powerful. This tutorial covers the; PsiAPI mode. Warning: Although the developers have been using PsiAPI mode stably; for months before the 1.1 release and while we believe we’ve gotten; everything nicely arranged within the psi4. namespace, the API; should not be considered completely stable. Most importantly, as we; someday deprecate the last of the global variables, options will be; added to the method calls (e.g.,; energy('scf', molecule=mol, options=opt)); Note: Consult How to run Psi4 as Python module after; compilation; or How to run Psi4 as a Python module from conda; installation; for assistance in setting up Psi4. Unlike in the past, where Psi4 was executable software which could only; be called via input files like input.dat, it is now interactive,; able to be loaded directly as a Python module. Here, we will explore the; basics of using Psi4 in this new style by reproducing the section A; Psi4 Tutorial; from the Psi4 manual in an interactive Jupyter Notebook.; Note: If the newest version of Psi4 (v.1.1a2dev42 or newer) is in your; path, feel free to execute each cell as you read along by pressing; Shift+Enter when the cell is selected. I. Basic Input Structure¶; Psi4 is now a Python module; so, we need to import it into our Python; environment:. In",MatchSource.WIKI,psi4manual/1.2.1/psiapi-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi-1.html
https://psicode.org/psi4manual/1.2.1/psiapi-1.html:1304,Deployability,install,installation,1304,"er to two modes of interacting with; Psi4. In Psithon mode, you write an input file in our domain-specific; language (not quite Python) where commands don’t have psi4. in; front, then submit it to the executable psi4 which processes the; Psithon into pure Python and runs it internally. In PsiAPI mode, you; write a pure Python script with import psi4 at the top and commands; are behind the psi4. namespace, then submit it to the python; interpreter. Both modes are equally powerful. This tutorial covers the; PsiAPI mode. Warning: Although the developers have been using PsiAPI mode stably; for months before the 1.1 release and while we believe we’ve gotten; everything nicely arranged within the psi4. namespace, the API; should not be considered completely stable. Most importantly, as we; someday deprecate the last of the global variables, options will be; added to the method calls (e.g.,; energy('scf', molecule=mol, options=opt)); Note: Consult How to run Psi4 as Python module after; compilation; or How to run Psi4 as a Python module from conda; installation; for assistance in setting up Psi4. Unlike in the past, where Psi4 was executable software which could only; be called via input files like input.dat, it is now interactive,; able to be loaded directly as a Python module. Here, we will explore the; basics of using Psi4 in this new style by reproducing the section A; Psi4 Tutorial; from the Psi4 manual in an interactive Jupyter Notebook.; Note: If the newest version of Psi4 (v.1.1a2dev42 or newer) is in your; path, feel free to execute each cell as you read along by pressing; Shift+Enter when the cell is selected. I. Basic Input Structure¶; Psi4 is now a Python module; so, we need to import it into our Python; environment:. In [1]:. try:; import os, sys; sys.path.insert(1, os.path.abspath('/scratch/psilocaluser/conda-builds/psi4-docs-multiout_1532505956776/work/build/stage//opt/anaconda1anaconda2anaconda3/lib/python3.6/site-packages')); except ImportError:; pass. impo",MatchSource.WIKI,psi4manual/1.2.1/psiapi-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi-1.html
https://psicode.org/psi4manual/1.2.1/psiapi-1.html:4149,Deployability,install,installation,4149,"matrix or Cartesian format; to; allow the string to break over multiple lines, use Python’s triple-quote; """"""string"""""" syntax. Finally, we will compute the Hartree-Fock SCF; energy with the cc-pVDZ basis set by passing the method/basis set as a; string ('scf/cc-pvdz') into the function psi4.energy(); API:. In [3]:. #! Sample HF/cc-pVDZ H2O Computation. psi4.set_memory('500 MB'). h2o = psi4.geometry(""""""; O; H 1 0.96; H 1 0.96 2 104.5; """"""). psi4.energy('scf/cc-pvdz'). Out[3]:. -76.02663273488399. If everything goes well, the computation should complete and should; report a final restricted Hartree-Fock energy in the output file; output.dat in a section like this:; Energy converged. @DF-RHF Final Energy: -76.02663273486682. By default, the energy should be converged to about; \(1.0\times 10^{-6}\), so agreement is only expected for about the; first 6 digits after the decimal. If the computation does not complete,; there is probably a problem with the compilation or installation of the; program (see the installation instructions in the main Psi4 manual; section Compiling and Installing from; Source).; This very simple input is sufficient to run the requested information.; Notice we didn’t tell the program some otherwise useful information like; the charge of the molecule (0, it’s neutral), the spin multiplicity (1; for a closed-shell molecule with all electrons paired), or the reference; wavefunction to use (restricted Hartree-Fock, or RHF, is usually; appropriate for a closed-shell molecule). The program correctly guessed; all of these options for us. We can change the default behavior through; additional keywords.; Let’s consider what we would do for an open-shell molecule, where not; all the electrons are paired. For example, let’s run a computation on; methylene (\(\text{CH}_2\)), whose ground electronic state has two; unpaired electrons (triplet electronic state, or a spin multiplicity; \(2S + 1 = 3\)). In this case, the default spin multiplicity (1) is; not corre",MatchSource.WIKI,psi4manual/1.2.1/psiapi-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi-1.html
https://psicode.org/psi4manual/1.2.1/psiapi-1.html:4187,Deployability,install,installation,4187,"matrix or Cartesian format; to; allow the string to break over multiple lines, use Python’s triple-quote; """"""string"""""" syntax. Finally, we will compute the Hartree-Fock SCF; energy with the cc-pVDZ basis set by passing the method/basis set as a; string ('scf/cc-pvdz') into the function psi4.energy(); API:. In [3]:. #! Sample HF/cc-pVDZ H2O Computation. psi4.set_memory('500 MB'). h2o = psi4.geometry(""""""; O; H 1 0.96; H 1 0.96 2 104.5; """"""). psi4.energy('scf/cc-pvdz'). Out[3]:. -76.02663273488399. If everything goes well, the computation should complete and should; report a final restricted Hartree-Fock energy in the output file; output.dat in a section like this:; Energy converged. @DF-RHF Final Energy: -76.02663273486682. By default, the energy should be converged to about; \(1.0\times 10^{-6}\), so agreement is only expected for about the; first 6 digits after the decimal. If the computation does not complete,; there is probably a problem with the compilation or installation of the; program (see the installation instructions in the main Psi4 manual; section Compiling and Installing from; Source).; This very simple input is sufficient to run the requested information.; Notice we didn’t tell the program some otherwise useful information like; the charge of the molecule (0, it’s neutral), the spin multiplicity (1; for a closed-shell molecule with all electrons paired), or the reference; wavefunction to use (restricted Hartree-Fock, or RHF, is usually; appropriate for a closed-shell molecule). The program correctly guessed; all of these options for us. We can change the default behavior through; additional keywords.; Let’s consider what we would do for an open-shell molecule, where not; all the electrons are paired. For example, let’s run a computation on; methylene (\(\text{CH}_2\)), whose ground electronic state has two; unpaired electrons (triplet electronic state, or a spin multiplicity; \(2S + 1 = 3\)). In this case, the default spin multiplicity (1) is; not corre",MatchSource.WIKI,psi4manual/1.2.1/psiapi-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi-1.html
https://psicode.org/psi4manual/1.2.1/psiapi-1.html:9252,Deployability,update,updates,9252,"--------------- ~  Step         Total Energy             Delta E       MAX Force       RMS Force        MAX Disp        RMS Disp  ~ --------------------------------------------------------------------------------------------------------------- ~     1     -76.026632734908    -76.026632734908      0.01523518      0.01245755      0.02742222      0.02277530  ~     2     -76.027022666011     -0.000389931104      0.00178779      0.00142946      0.01008137      0.00594928  ~     3     -76.027032729374     -0.000010063363      0.00014019      0.00008488      0.00077463      0.00044738  ~ --------------------------------------------------------------------------------------------------------------- ~; To get harmonic vibrational frequencies, it’s important to keep in mind; that the values of the vibrational frequencies are a function of the; molecular geometry. Therefore, it’s important to obtain the vibrational; frequencies AT THE OPTIMIZED GEOMETRY. Luckily, Psi4 updates the; molecule with optimized geometry as it is being optimized. So, the; optimized geometry for H\(_2\)O is stored inside the h2o; molecule object, which we can access! To compute the frequencies, all we; need to do is to again pass the molecule=h2o argument to the; psi4.frequency(); API; function:. In [6]:. scf_e, scf_wfn = psi4.frequency('scf/cc-pvdz', molecule=h2o, return_wfn=True, dertype=1). 6 displacements needed.; 1 2 3 4 5 6. Executing this cell will prompt Psi4 to compute the Hessian (second; derivative matrix) of the electronic energy with respect to nuclear; displacements. From this, it can obtain the harmonic vibrational; frequencies, given below (roundoff errors of around \(0.1\); cm\(^{-1}\) may exist):; Irrep Harmonic Frequency; (cm-1); -----------------------------------------------; A1 1775.6478; A1 4113.3795; B2 4212.1814; -----------------------------------------------. Notice the symmetry type of the normal modes is specified (A1, A1, B2).; The program also print out the normal modes i",MatchSource.WIKI,psi4manual/1.2.1/psiapi-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi-1.html
https://psicode.org/psi4manual/1.2.1/psiapi-1.html:24115,Deployability,update,updated,24115,"ents = (1,), basis = (1, 2): -128.70932405488935); ...; N-Body: Computing complex (1/1) with fragments (1, 2) in the basis of fragments (1, 2).; ...; N-Body: Complex Energy (fragments = (1, 2), basis = (1, 2): -257.41867403127321); ...; ==> N-Body: Counterpoise Corrected (CP) energies <==. n-Body Total Energy [Eh] I.E. [kcal/mol] Delta [kcal/mol]; 1 -257.418648109779 0.000000000000 0.000000000000; 2 -257.418674031273 -0.016265984132 -0.016265984132. And that’s it! The only remaining part of the example is a little table; of the different R values and the CP-corrected CCSD(T) energies,; converted from atomic units (Hartree) to kcal mol\(^{-1}\) by; multiplying by the automatically-defined conversion factor; psi4.constants.hartree2kcalmol. Psi4 provides several built-in; physical constants and conversion factors, as described in the Psi4; manual section Physical; Constants.; The table can be printed either to the screen, by using standard Python; ``print()`; syntax <https://docs.python.org/3/whatsnew/3.0.html#print-is-a-function>`__,; or to the designated output file output.dat using Psi4’s built-in; function psi4.core.print_out(); API; (C style printing).; As we’ve seen so far, the combination of Psi4 and Python creates a; unique, interactive approach to quantum chemistry. The next section will; explore this synergistic relationship in greater detail, describing how; even very complex tasks can be done very easily with Psi4. table of contents. PsiAPI Tutorial: Using Psi4 as a Python Module; I. Basic Input Structure; II. Running a Basic Hartree-Fock Calculation; III. Geometry Optimization and Vibrational Frequency Analysis; IV. Analysis of Intermolecular Interactions; V. Potential Surface Scans and Counterpoise Correction Made Easy. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. A PSI4 Tutorial. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/psiapi-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi-1.html
https://psicode.org/psi4manual/1.2.1/psiapi-1.html:721,Energy Efficiency,power,powerful,721,"﻿. PsiAPI Tutorial: Using Psi4 as a Python Module. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. A PSI4 Tutorial. PsiAPI Tutorial: Using Psi4 as a Python Module¶; transcribed by D. A. Sirianni. Note: Psithon and PsiAPI refer to two modes of interacting with; Psi4. In Psithon mode, you write an input file in our domain-specific; language (not quite Python) where commands don’t have psi4. in; front, then submit it to the executable psi4 which processes the; Psithon into pure Python and runs it internally. In PsiAPI mode, you; write a pure Python script with import psi4 at the top and commands; are behind the psi4. namespace, then submit it to the python; interpreter. Both modes are equally powerful. This tutorial covers the; PsiAPI mode. Warning: Although the developers have been using PsiAPI mode stably; for months before the 1.1 release and while we believe we’ve gotten; everything nicely arranged within the psi4. namespace, the API; should not be considered completely stable. Most importantly, as we; someday deprecate the last of the global variables, options will be; added to the method calls (e.g.,; energy('scf', molecule=mol, options=opt)); Note: Consult How to run Psi4 as Python module after; compilation; or How to run Psi4 as a Python module from conda; installation; for assistance in setting up Psi4. Unlike in the past, where Psi4 was executable software which could only; be called via input files like input.dat, it is now interactive,; able to be loaded directly as a Python module. Here, we will explore the; basics of using Psi4 in this new style by reproducing the section A; Psi4 Tutorial; from the Psi4 manual in an interactive Jupyter Notebook.; Note: If the newest version of Psi4 (v.1.1a2dev42 or newer) is in your; path, feel free to execute each cell as you read along by pressing; Shift+Enter when the cell is selected. I. Basic Input Structure¶; Psi4 is now a Python module; so, we need to import it into our Python; environment:. In",MatchSource.WIKI,psi4manual/1.2.1/psiapi-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi-1.html
https://psicode.org/psi4manual/1.2.1/psiapi-1.html:1144,Energy Efficiency,energy,energy,1144,"er to two modes of interacting with; Psi4. In Psithon mode, you write an input file in our domain-specific; language (not quite Python) where commands don’t have psi4. in; front, then submit it to the executable psi4 which processes the; Psithon into pure Python and runs it internally. In PsiAPI mode, you; write a pure Python script with import psi4 at the top and commands; are behind the psi4. namespace, then submit it to the python; interpreter. Both modes are equally powerful. This tutorial covers the; PsiAPI mode. Warning: Although the developers have been using PsiAPI mode stably; for months before the 1.1 release and while we believe we’ve gotten; everything nicely arranged within the psi4. namespace, the API; should not be considered completely stable. Most importantly, as we; someday deprecate the last of the global variables, options will be; added to the method calls (e.g.,; energy('scf', molecule=mol, options=opt)); Note: Consult How to run Psi4 as Python module after; compilation; or How to run Psi4 as a Python module from conda; installation; for assistance in setting up Psi4. Unlike in the past, where Psi4 was executable software which could only; be called via input files like input.dat, it is now interactive,; able to be loaded directly as a Python module. Here, we will explore the; basics of using Psi4 in this new style by reproducing the section A; Psi4 Tutorial; from the Psi4 manual in an interactive Jupyter Notebook.; Note: If the newest version of Psi4 (v.1.1a2dev42 or newer) is in your; path, feel free to execute each cell as you read along by pressing; Shift+Enter when the cell is selected. I. Basic Input Structure¶; Psi4 is now a Python module; so, we need to import it into our Python; environment:. In [1]:. try:; import os, sys; sys.path.insert(1, os.path.abspath('/scratch/psilocaluser/conda-builds/psi4-docs-multiout_1532505956776/work/build/stage//opt/anaconda1anaconda2anaconda3/lib/python3.6/site-packages')); except ImportError:; pass. impo",MatchSource.WIKI,psi4manual/1.2.1/psiapi-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi-1.html
https://psicode.org/psi4manual/1.2.1/psiapi-1.html:3345,Energy Efficiency,energy,energy,3345,"hanged by giving a; file name (with path if not in the current working directory) to the; function psi4.core.set_output_file(); API,; as a string:. In [2]:. psi4.core.set_output_file('output.dat', False). Additionally, output may be suppressed by instead setting; psi4.core.be_quiet(); API. II. Running a Basic Hartree-Fock Calculation¶; In our first example, we will consider a Hartree-Fock SCF computation; for the water molecule using a cc-pVDZ basis set. First, we will set the; available memory for Psi4 to use with the psi4.set_memory(); API; function, which takes either a string like '30 GB' (with units!) or; an integer number of bytes of memory as its argument. Next, our; molecular geometry is passed as a string into psi4.geometry(); API.; We may input this geometry in either Z-matrix or Cartesian format; to; allow the string to break over multiple lines, use Python’s triple-quote; """"""string"""""" syntax. Finally, we will compute the Hartree-Fock SCF; energy with the cc-pVDZ basis set by passing the method/basis set as a; string ('scf/cc-pvdz') into the function psi4.energy(); API:. In [3]:. #! Sample HF/cc-pVDZ H2O Computation. psi4.set_memory('500 MB'). h2o = psi4.geometry(""""""; O; H 1 0.96; H 1 0.96 2 104.5; """"""). psi4.energy('scf/cc-pvdz'). Out[3]:. -76.02663273488399. If everything goes well, the computation should complete and should; report a final restricted Hartree-Fock energy in the output file; output.dat in a section like this:; Energy converged. @DF-RHF Final Energy: -76.02663273486682. By default, the energy should be converged to about; \(1.0\times 10^{-6}\), so agreement is only expected for about the; first 6 digits after the decimal. If the computation does not complete,; there is probably a problem with the compilation or installation of the; program (see the installation instructions in the main Psi4 manual; section Compiling and Installing from; Source).; This very simple input is sufficient to run the requested information.; Notice we didn’t tell",MatchSource.WIKI,psi4manual/1.2.1/psiapi-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi-1.html
https://psicode.org/psi4manual/1.2.1/psiapi-1.html:3463,Energy Efficiency,energy,energy,3463,"function psi4.core.set_output_file(); API,; as a string:. In [2]:. psi4.core.set_output_file('output.dat', False). Additionally, output may be suppressed by instead setting; psi4.core.be_quiet(); API. II. Running a Basic Hartree-Fock Calculation¶; In our first example, we will consider a Hartree-Fock SCF computation; for the water molecule using a cc-pVDZ basis set. First, we will set the; available memory for Psi4 to use with the psi4.set_memory(); API; function, which takes either a string like '30 GB' (with units!) or; an integer number of bytes of memory as its argument. Next, our; molecular geometry is passed as a string into psi4.geometry(); API.; We may input this geometry in either Z-matrix or Cartesian format; to; allow the string to break over multiple lines, use Python’s triple-quote; """"""string"""""" syntax. Finally, we will compute the Hartree-Fock SCF; energy with the cc-pVDZ basis set by passing the method/basis set as a; string ('scf/cc-pvdz') into the function psi4.energy(); API:. In [3]:. #! Sample HF/cc-pVDZ H2O Computation. psi4.set_memory('500 MB'). h2o = psi4.geometry(""""""; O; H 1 0.96; H 1 0.96 2 104.5; """"""). psi4.energy('scf/cc-pvdz'). Out[3]:. -76.02663273488399. If everything goes well, the computation should complete and should; report a final restricted Hartree-Fock energy in the output file; output.dat in a section like this:; Energy converged. @DF-RHF Final Energy: -76.02663273486682. By default, the energy should be converged to about; \(1.0\times 10^{-6}\), so agreement is only expected for about the; first 6 digits after the decimal. If the computation does not complete,; there is probably a problem with the compilation or installation of the; program (see the installation instructions in the main Psi4 manual; section Compiling and Installing from; Source).; This very simple input is sufficient to run the requested information.; Notice we didn’t tell the program some otherwise useful information like; the charge of the molecule (0, it’s ne",MatchSource.WIKI,psi4manual/1.2.1/psiapi-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi-1.html
https://psicode.org/psi4manual/1.2.1/psiapi-1.html:3620,Energy Efficiency,energy,energy,3620,"ead setting; psi4.core.be_quiet(); API. II. Running a Basic Hartree-Fock Calculation¶; In our first example, we will consider a Hartree-Fock SCF computation; for the water molecule using a cc-pVDZ basis set. First, we will set the; available memory for Psi4 to use with the psi4.set_memory(); API; function, which takes either a string like '30 GB' (with units!) or; an integer number of bytes of memory as its argument. Next, our; molecular geometry is passed as a string into psi4.geometry(); API.; We may input this geometry in either Z-matrix or Cartesian format; to; allow the string to break over multiple lines, use Python’s triple-quote; """"""string"""""" syntax. Finally, we will compute the Hartree-Fock SCF; energy with the cc-pVDZ basis set by passing the method/basis set as a; string ('scf/cc-pvdz') into the function psi4.energy(); API:. In [3]:. #! Sample HF/cc-pVDZ H2O Computation. psi4.set_memory('500 MB'). h2o = psi4.geometry(""""""; O; H 1 0.96; H 1 0.96 2 104.5; """"""). psi4.energy('scf/cc-pvdz'). Out[3]:. -76.02663273488399. If everything goes well, the computation should complete and should; report a final restricted Hartree-Fock energy in the output file; output.dat in a section like this:; Energy converged. @DF-RHF Final Energy: -76.02663273486682. By default, the energy should be converged to about; \(1.0\times 10^{-6}\), so agreement is only expected for about the; first 6 digits after the decimal. If the computation does not complete,; there is probably a problem with the compilation or installation of the; program (see the installation instructions in the main Psi4 manual; section Compiling and Installing from; Source).; This very simple input is sufficient to run the requested information.; Notice we didn’t tell the program some otherwise useful information like; the charge of the molecule (0, it’s neutral), the spin multiplicity (1; for a closed-shell molecule with all electrons paired), or the reference; wavefunction to use (restricted Hartree-Fock, or RHF",MatchSource.WIKI,psi4manual/1.2.1/psiapi-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi-1.html
https://psicode.org/psi4manual/1.2.1/psiapi-1.html:3780,Energy Efficiency,energy,energy,3780," will consider a Hartree-Fock SCF computation; for the water molecule using a cc-pVDZ basis set. First, we will set the; available memory for Psi4 to use with the psi4.set_memory(); API; function, which takes either a string like '30 GB' (with units!) or; an integer number of bytes of memory as its argument. Next, our; molecular geometry is passed as a string into psi4.geometry(); API.; We may input this geometry in either Z-matrix or Cartesian format; to; allow the string to break over multiple lines, use Python’s triple-quote; """"""string"""""" syntax. Finally, we will compute the Hartree-Fock SCF; energy with the cc-pVDZ basis set by passing the method/basis set as a; string ('scf/cc-pvdz') into the function psi4.energy(); API:. In [3]:. #! Sample HF/cc-pVDZ H2O Computation. psi4.set_memory('500 MB'). h2o = psi4.geometry(""""""; O; H 1 0.96; H 1 0.96 2 104.5; """"""). psi4.energy('scf/cc-pvdz'). Out[3]:. -76.02663273488399. If everything goes well, the computation should complete and should; report a final restricted Hartree-Fock energy in the output file; output.dat in a section like this:; Energy converged. @DF-RHF Final Energy: -76.02663273486682. By default, the energy should be converged to about; \(1.0\times 10^{-6}\), so agreement is only expected for about the; first 6 digits after the decimal. If the computation does not complete,; there is probably a problem with the compilation or installation of the; program (see the installation instructions in the main Psi4 manual; section Compiling and Installing from; Source).; This very simple input is sufficient to run the requested information.; Notice we didn’t tell the program some otherwise useful information like; the charge of the molecule (0, it’s neutral), the spin multiplicity (1; for a closed-shell molecule with all electrons paired), or the reference; wavefunction to use (restricted Hartree-Fock, or RHF, is usually; appropriate for a closed-shell molecule). The program correctly guessed; all of these options for ",MatchSource.WIKI,psi4manual/1.2.1/psiapi-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi-1.html
https://psicode.org/psi4manual/1.2.1/psiapi-1.html:3919,Energy Efficiency,energy,energy,3919,"nction, which takes either a string like '30 GB' (with units!) or; an integer number of bytes of memory as its argument. Next, our; molecular geometry is passed as a string into psi4.geometry(); API.; We may input this geometry in either Z-matrix or Cartesian format; to; allow the string to break over multiple lines, use Python’s triple-quote; """"""string"""""" syntax. Finally, we will compute the Hartree-Fock SCF; energy with the cc-pVDZ basis set by passing the method/basis set as a; string ('scf/cc-pvdz') into the function psi4.energy(); API:. In [3]:. #! Sample HF/cc-pVDZ H2O Computation. psi4.set_memory('500 MB'). h2o = psi4.geometry(""""""; O; H 1 0.96; H 1 0.96 2 104.5; """"""). psi4.energy('scf/cc-pvdz'). Out[3]:. -76.02663273488399. If everything goes well, the computation should complete and should; report a final restricted Hartree-Fock energy in the output file; output.dat in a section like this:; Energy converged. @DF-RHF Final Energy: -76.02663273486682. By default, the energy should be converged to about; \(1.0\times 10^{-6}\), so agreement is only expected for about the; first 6 digits after the decimal. If the computation does not complete,; there is probably a problem with the compilation or installation of the; program (see the installation instructions in the main Psi4 manual; section Compiling and Installing from; Source).; This very simple input is sufficient to run the requested information.; Notice we didn’t tell the program some otherwise useful information like; the charge of the molecule (0, it’s neutral), the spin multiplicity (1; for a closed-shell molecule with all electrons paired), or the reference; wavefunction to use (restricted Hartree-Fock, or RHF, is usually; appropriate for a closed-shell molecule). The program correctly guessed; all of these options for us. We can change the default behavior through; additional keywords.; Let’s consider what we would do for an open-shell molecule, where not; all the electrons are paired. For example, let’",MatchSource.WIKI,psi4manual/1.2.1/psiapi-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi-1.html
https://psicode.org/psi4manual/1.2.1/psiapi-1.html:4437,Energy Efficiency,charge,charge,4437,"ion. psi4.set_memory('500 MB'). h2o = psi4.geometry(""""""; O; H 1 0.96; H 1 0.96 2 104.5; """"""). psi4.energy('scf/cc-pvdz'). Out[3]:. -76.02663273488399. If everything goes well, the computation should complete and should; report a final restricted Hartree-Fock energy in the output file; output.dat in a section like this:; Energy converged. @DF-RHF Final Energy: -76.02663273486682. By default, the energy should be converged to about; \(1.0\times 10^{-6}\), so agreement is only expected for about the; first 6 digits after the decimal. If the computation does not complete,; there is probably a problem with the compilation or installation of the; program (see the installation instructions in the main Psi4 manual; section Compiling and Installing from; Source).; This very simple input is sufficient to run the requested information.; Notice we didn’t tell the program some otherwise useful information like; the charge of the molecule (0, it’s neutral), the spin multiplicity (1; for a closed-shell molecule with all electrons paired), or the reference; wavefunction to use (restricted Hartree-Fock, or RHF, is usually; appropriate for a closed-shell molecule). The program correctly guessed; all of these options for us. We can change the default behavior through; additional keywords.; Let’s consider what we would do for an open-shell molecule, where not; all the electrons are paired. For example, let’s run a computation on; methylene (\(\text{CH}_2\)), whose ground electronic state has two; unpaired electrons (triplet electronic state, or a spin multiplicity; \(2S + 1 = 3\)). In this case, the default spin multiplicity (1) is; not correct, so we need to tell the program the true value (3). Like; many programs, Psi4 can get the charge and multiplicity as the first two; integers in the Z-matrix (note the line with 0 3 at the beginning of; the molecule specification below). In this example, we will also specify; the bond length and bond angle as variables (\(R\) and \(A\)),; whose va",MatchSource.WIKI,psi4manual/1.2.1/psiapi-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi-1.html
https://psicode.org/psi4manual/1.2.1/psiapi-1.html:5264,Energy Efficiency,charge,charge,5264,"icient to run the requested information.; Notice we didn’t tell the program some otherwise useful information like; the charge of the molecule (0, it’s neutral), the spin multiplicity (1; for a closed-shell molecule with all electrons paired), or the reference; wavefunction to use (restricted Hartree-Fock, or RHF, is usually; appropriate for a closed-shell molecule). The program correctly guessed; all of these options for us. We can change the default behavior through; additional keywords.; Let’s consider what we would do for an open-shell molecule, where not; all the electrons are paired. For example, let’s run a computation on; methylene (\(\text{CH}_2\)), whose ground electronic state has two; unpaired electrons (triplet electronic state, or a spin multiplicity; \(2S + 1 = 3\)). In this case, the default spin multiplicity (1) is; not correct, so we need to tell the program the true value (3). Like; many programs, Psi4 can get the charge and multiplicity as the first two; integers in the Z-matrix (note the line with 0 3 at the beginning of; the molecule specification below). In this example, we will also specify; the bond length and bond angle as variables (\(R\) and \(A\)),; whose values are first stored and then inserted into the geometry; specification using Python 3 string; formatting. In [4]:. #! Sample UHF/6-31G** CH2 Computation. R = 1.075; A = 133.93. ch2 = psi4.geometry(""""""; 0 3; C; H 1 {0}; H 1 {0} 2 {1}; """""".format(R, A); ). psi4.set_options({'reference': 'uhf'}); psi4.energy('scf/6-31g**'). Out[4]:. -38.925334628859886. Executing this cell should yield the final energy as; @DF-UHF Final Energy: -38.92533462887677. Notice the new command, psi4.set_options(); API,; to the input. This function takes a Python; dictionary; as its argument, which is a key-value list which associates a Psi4; keyword; with its user-defined value. For open shell molecules, we have a choice; of unrestricted orbitals (unrestricted Hartree-Fock, or UHF) or; restricted orbitals (res",MatchSource.WIKI,psi4manual/1.2.1/psiapi-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi-1.html
https://psicode.org/psi4manual/1.2.1/psiapi-1.html:5824,Energy Efficiency,energy,energy,5824," would do for an open-shell molecule, where not; all the electrons are paired. For example, let’s run a computation on; methylene (\(\text{CH}_2\)), whose ground electronic state has two; unpaired electrons (triplet electronic state, or a spin multiplicity; \(2S + 1 = 3\)). In this case, the default spin multiplicity (1) is; not correct, so we need to tell the program the true value (3). Like; many programs, Psi4 can get the charge and multiplicity as the first two; integers in the Z-matrix (note the line with 0 3 at the beginning of; the molecule specification below). In this example, we will also specify; the bond length and bond angle as variables (\(R\) and \(A\)),; whose values are first stored and then inserted into the geometry; specification using Python 3 string; formatting. In [4]:. #! Sample UHF/6-31G** CH2 Computation. R = 1.075; A = 133.93. ch2 = psi4.geometry(""""""; 0 3; C; H 1 {0}; H 1 {0} 2 {1}; """""".format(R, A); ). psi4.set_options({'reference': 'uhf'}); psi4.energy('scf/6-31g**'). Out[4]:. -38.925334628859886. Executing this cell should yield the final energy as; @DF-UHF Final Energy: -38.92533462887677. Notice the new command, psi4.set_options(); API,; to the input. This function takes a Python; dictionary; as its argument, which is a key-value list which associates a Psi4; keyword; with its user-defined value. For open shell molecules, we have a choice; of unrestricted orbitals (unrestricted Hartree-Fock, or UHF) or; restricted orbitals (restricted open-shell Hartree-Fock, or ROHF).; Usually, UHF is a little easier to converge (although it may be more; susceptible to spin contamination than ROHF). III. Geometry Optimization and Vibrational Frequency Analysis¶; The above examples were simple single-point energy computations (as; specified by the psi4.energy(); API; function). Of course there are other kinds of computations to perform,; such as geometry optimizations and vibrational frequency computations.; These can be specified by replacing psi4.en",MatchSource.WIKI,psi4manual/1.2.1/psiapi-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi-1.html
https://psicode.org/psi4manual/1.2.1/psiapi-1.html:5920,Energy Efficiency,energy,energy,5920,"r example, let’s run a computation on; methylene (\(\text{CH}_2\)), whose ground electronic state has two; unpaired electrons (triplet electronic state, or a spin multiplicity; \(2S + 1 = 3\)). In this case, the default spin multiplicity (1) is; not correct, so we need to tell the program the true value (3). Like; many programs, Psi4 can get the charge and multiplicity as the first two; integers in the Z-matrix (note the line with 0 3 at the beginning of; the molecule specification below). In this example, we will also specify; the bond length and bond angle as variables (\(R\) and \(A\)),; whose values are first stored and then inserted into the geometry; specification using Python 3 string; formatting. In [4]:. #! Sample UHF/6-31G** CH2 Computation. R = 1.075; A = 133.93. ch2 = psi4.geometry(""""""; 0 3; C; H 1 {0}; H 1 {0} 2 {1}; """""".format(R, A); ). psi4.set_options({'reference': 'uhf'}); psi4.energy('scf/6-31g**'). Out[4]:. -38.925334628859886. Executing this cell should yield the final energy as; @DF-UHF Final Energy: -38.92533462887677. Notice the new command, psi4.set_options(); API,; to the input. This function takes a Python; dictionary; as its argument, which is a key-value list which associates a Psi4; keyword; with its user-defined value. For open shell molecules, we have a choice; of unrestricted orbitals (unrestricted Hartree-Fock, or UHF) or; restricted orbitals (restricted open-shell Hartree-Fock, or ROHF).; Usually, UHF is a little easier to converge (although it may be more; susceptible to spin contamination than ROHF). III. Geometry Optimization and Vibrational Frequency Analysis¶; The above examples were simple single-point energy computations (as; specified by the psi4.energy(); API; function). Of course there are other kinds of computations to perform,; such as geometry optimizations and vibrational frequency computations.; These can be specified by replacing psi4.energy(); API; with psi4.optimize(); API; or psi4.frequency(); API,; respectively.; ",MatchSource.WIKI,psi4manual/1.2.1/psiapi-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi-1.html
https://psicode.org/psi4manual/1.2.1/psiapi-1.html:6586,Energy Efficiency,energy,energy,6586,"rted into the geometry; specification using Python 3 string; formatting. In [4]:. #! Sample UHF/6-31G** CH2 Computation. R = 1.075; A = 133.93. ch2 = psi4.geometry(""""""; 0 3; C; H 1 {0}; H 1 {0} 2 {1}; """""".format(R, A); ). psi4.set_options({'reference': 'uhf'}); psi4.energy('scf/6-31g**'). Out[4]:. -38.925334628859886. Executing this cell should yield the final energy as; @DF-UHF Final Energy: -38.92533462887677. Notice the new command, psi4.set_options(); API,; to the input. This function takes a Python; dictionary; as its argument, which is a key-value list which associates a Psi4; keyword; with its user-defined value. For open shell molecules, we have a choice; of unrestricted orbitals (unrestricted Hartree-Fock, or UHF) or; restricted orbitals (restricted open-shell Hartree-Fock, or ROHF).; Usually, UHF is a little easier to converge (although it may be more; susceptible to spin contamination than ROHF). III. Geometry Optimization and Vibrational Frequency Analysis¶; The above examples were simple single-point energy computations (as; specified by the psi4.energy(); API; function). Of course there are other kinds of computations to perform,; such as geometry optimizations and vibrational frequency computations.; These can be specified by replacing psi4.energy(); API; with psi4.optimize(); API; or psi4.frequency(); API,; respectively.; Let’s take a look at an example of optimizing the H\(_2\)O; molecule using Hartree-Fock with a cc-pVDZ basis set.; Now, here comes the real beauty of running Psi4 interactively: above,; when we computed the energy of H\(_2\)O with HF/cc-pVDZ, we; defined the Psi4 molecule object h2o. Since we’re still in the; Python shell, as long as you executed that block of code, we can reuse; the h2o molecule object in our optimization without redefining it,; by adding the molecule=h2o argument to the psi4.optimize(); API; function:. In [5]:. psi4.set_options({'reference': 'rhf'}); psi4.optimize('scf/cc-pvdz', molecule=h2o). Optimizer: Optimizati",MatchSource.WIKI,psi4manual/1.2.1/psiapi-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi-1.html
https://psicode.org/psi4manual/1.2.1/psiapi-1.html:6633,Energy Efficiency,energy,energy,6633,"ple UHF/6-31G** CH2 Computation. R = 1.075; A = 133.93. ch2 = psi4.geometry(""""""; 0 3; C; H 1 {0}; H 1 {0} 2 {1}; """""".format(R, A); ). psi4.set_options({'reference': 'uhf'}); psi4.energy('scf/6-31g**'). Out[4]:. -38.925334628859886. Executing this cell should yield the final energy as; @DF-UHF Final Energy: -38.92533462887677. Notice the new command, psi4.set_options(); API,; to the input. This function takes a Python; dictionary; as its argument, which is a key-value list which associates a Psi4; keyword; with its user-defined value. For open shell molecules, we have a choice; of unrestricted orbitals (unrestricted Hartree-Fock, or UHF) or; restricted orbitals (restricted open-shell Hartree-Fock, or ROHF).; Usually, UHF is a little easier to converge (although it may be more; susceptible to spin contamination than ROHF). III. Geometry Optimization and Vibrational Frequency Analysis¶; The above examples were simple single-point energy computations (as; specified by the psi4.energy(); API; function). Of course there are other kinds of computations to perform,; such as geometry optimizations and vibrational frequency computations.; These can be specified by replacing psi4.energy(); API; with psi4.optimize(); API; or psi4.frequency(); API,; respectively.; Let’s take a look at an example of optimizing the H\(_2\)O; molecule using Hartree-Fock with a cc-pVDZ basis set.; Now, here comes the real beauty of running Psi4 interactively: above,; when we computed the energy of H\(_2\)O with HF/cc-pVDZ, we; defined the Psi4 molecule object h2o. Since we’re still in the; Python shell, as long as you executed that block of code, we can reuse; the h2o molecule object in our optimization without redefining it,; by adding the molecule=h2o argument to the psi4.optimize(); API; function:. In [5]:. psi4.set_options({'reference': 'rhf'}); psi4.optimize('scf/cc-pvdz', molecule=h2o). Optimizer: Optimization complete!. Out[5]:. -76.02703272937504. This should perform a series of gradient comp",MatchSource.WIKI,psi4manual/1.2.1/psiapi-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi-1.html
https://psicode.org/psi4manual/1.2.1/psiapi-1.html:6833,Energy Efficiency,energy,energy,6833,". Out[4]:. -38.925334628859886. Executing this cell should yield the final energy as; @DF-UHF Final Energy: -38.92533462887677. Notice the new command, psi4.set_options(); API,; to the input. This function takes a Python; dictionary; as its argument, which is a key-value list which associates a Psi4; keyword; with its user-defined value. For open shell molecules, we have a choice; of unrestricted orbitals (unrestricted Hartree-Fock, or UHF) or; restricted orbitals (restricted open-shell Hartree-Fock, or ROHF).; Usually, UHF is a little easier to converge (although it may be more; susceptible to spin contamination than ROHF). III. Geometry Optimization and Vibrational Frequency Analysis¶; The above examples were simple single-point energy computations (as; specified by the psi4.energy(); API; function). Of course there are other kinds of computations to perform,; such as geometry optimizations and vibrational frequency computations.; These can be specified by replacing psi4.energy(); API; with psi4.optimize(); API; or psi4.frequency(); API,; respectively.; Let’s take a look at an example of optimizing the H\(_2\)O; molecule using Hartree-Fock with a cc-pVDZ basis set.; Now, here comes the real beauty of running Psi4 interactively: above,; when we computed the energy of H\(_2\)O with HF/cc-pVDZ, we; defined the Psi4 molecule object h2o. Since we’re still in the; Python shell, as long as you executed that block of code, we can reuse; the h2o molecule object in our optimization without redefining it,; by adding the molecule=h2o argument to the psi4.optimize(); API; function:. In [5]:. psi4.set_options({'reference': 'rhf'}); psi4.optimize('scf/cc-pvdz', molecule=h2o). Optimizer: Optimization complete!. Out[5]:. -76.02703272937504. This should perform a series of gradient computations. The gradient; points which way is downhill in energy, and the optimizer then modifies; the geometry to follow the gradient. After a few cycles, the geometry; should converge with a message l",MatchSource.WIKI,psi4manual/1.2.1/psiapi-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi-1.html
https://psicode.org/psi4manual/1.2.1/psiapi-1.html:7124,Energy Efficiency,energy,energy,7124,"e list which associates a Psi4; keyword; with its user-defined value. For open shell molecules, we have a choice; of unrestricted orbitals (unrestricted Hartree-Fock, or UHF) or; restricted orbitals (restricted open-shell Hartree-Fock, or ROHF).; Usually, UHF is a little easier to converge (although it may be more; susceptible to spin contamination than ROHF). III. Geometry Optimization and Vibrational Frequency Analysis¶; The above examples were simple single-point energy computations (as; specified by the psi4.energy(); API; function). Of course there are other kinds of computations to perform,; such as geometry optimizations and vibrational frequency computations.; These can be specified by replacing psi4.energy(); API; with psi4.optimize(); API; or psi4.frequency(); API,; respectively.; Let’s take a look at an example of optimizing the H\(_2\)O; molecule using Hartree-Fock with a cc-pVDZ basis set.; Now, here comes the real beauty of running Psi4 interactively: above,; when we computed the energy of H\(_2\)O with HF/cc-pVDZ, we; defined the Psi4 molecule object h2o. Since we’re still in the; Python shell, as long as you executed that block of code, we can reuse; the h2o molecule object in our optimization without redefining it,; by adding the molecule=h2o argument to the psi4.optimize(); API; function:. In [5]:. psi4.set_options({'reference': 'rhf'}); psi4.optimize('scf/cc-pvdz', molecule=h2o). Optimizer: Optimization complete!. Out[5]:. -76.02703272937504. This should perform a series of gradient computations. The gradient; points which way is downhill in energy, and the optimizer then modifies; the geometry to follow the gradient. After a few cycles, the geometry; should converge with a message like Optimization complete!. As; indicated in the following table (printed by the optimizer at the end of; the computation and grep-able with ~), the energy decreases with; each step, and the maximum force on each atom also decreases with each; step (in principle, these ",MatchSource.WIKI,psi4manual/1.2.1/psiapi-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi-1.html
https://psicode.org/psi4manual/1.2.1/psiapi-1.html:7702,Energy Efficiency,energy,energy,7702,",; such as geometry optimizations and vibrational frequency computations.; These can be specified by replacing psi4.energy(); API; with psi4.optimize(); API; or psi4.frequency(); API,; respectively.; Let’s take a look at an example of optimizing the H\(_2\)O; molecule using Hartree-Fock with a cc-pVDZ basis set.; Now, here comes the real beauty of running Psi4 interactively: above,; when we computed the energy of H\(_2\)O with HF/cc-pVDZ, we; defined the Psi4 molecule object h2o. Since we’re still in the; Python shell, as long as you executed that block of code, we can reuse; the h2o molecule object in our optimization without redefining it,; by adding the molecule=h2o argument to the psi4.optimize(); API; function:. In [5]:. psi4.set_options({'reference': 'rhf'}); psi4.optimize('scf/cc-pvdz', molecule=h2o). Optimizer: Optimization complete!. Out[5]:. -76.02703272937504. This should perform a series of gradient computations. The gradient; points which way is downhill in energy, and the optimizer then modifies; the geometry to follow the gradient. After a few cycles, the geometry; should converge with a message like Optimization complete!. As; indicated in the following table (printed by the optimizer at the end of; the computation and grep-able with ~), the energy decreases with; each step, and the maximum force on each atom also decreases with each; step (in principle, these numbers could increase in some iterations, but; here they do not).; --------------------------------------------------------------------------------------------------------------- ~  Step         Total Energy             Delta E       MAX Force       RMS Force        MAX Disp        RMS Disp  ~ --------------------------------------------------------------------------------------------------------------- ~     1     -76.026632734908    -76.026632734908      0.01523518      0.01245755      0.02742222      0.02277530  ~     2     -76.027022666011     -0.000389931104      0.00178779      0.0014294",MatchSource.WIKI,psi4manual/1.2.1/psiapi-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi-1.html
https://psicode.org/psi4manual/1.2.1/psiapi-1.html:7995,Energy Efficiency,energy,energy,7995,"et.; Now, here comes the real beauty of running Psi4 interactively: above,; when we computed the energy of H\(_2\)O with HF/cc-pVDZ, we; defined the Psi4 molecule object h2o. Since we’re still in the; Python shell, as long as you executed that block of code, we can reuse; the h2o molecule object in our optimization without redefining it,; by adding the molecule=h2o argument to the psi4.optimize(); API; function:. In [5]:. psi4.set_options({'reference': 'rhf'}); psi4.optimize('scf/cc-pvdz', molecule=h2o). Optimizer: Optimization complete!. Out[5]:. -76.02703272937504. This should perform a series of gradient computations. The gradient; points which way is downhill in energy, and the optimizer then modifies; the geometry to follow the gradient. After a few cycles, the geometry; should converge with a message like Optimization complete!. As; indicated in the following table (printed by the optimizer at the end of; the computation and grep-able with ~), the energy decreases with; each step, and the maximum force on each atom also decreases with each; step (in principle, these numbers could increase in some iterations, but; here they do not).; --------------------------------------------------------------------------------------------------------------- ~  Step         Total Energy             Delta E       MAX Force       RMS Force        MAX Disp        RMS Disp  ~ --------------------------------------------------------------------------------------------------------------- ~     1     -76.026632734908    -76.026632734908      0.01523518      0.01245755      0.02742222      0.02277530  ~     2     -76.027022666011     -0.000389931104      0.00178779      0.00142946      0.01008137      0.00594928  ~     3     -76.027032729374     -0.000010063363      0.00014019      0.00008488      0.00077463      0.00044738  ~ --------------------------------------------------------------------------------------------------------------- ~; To get harmonic vibrational frequencies, it’s",MatchSource.WIKI,psi4manual/1.2.1/psiapi-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi-1.html
https://psicode.org/psi4manual/1.2.1/psiapi-1.html:9804,Energy Efficiency,energy,energy,9804,"2729374     -0.000010063363      0.00014019      0.00008488      0.00077463      0.00044738  ~ --------------------------------------------------------------------------------------------------------------- ~; To get harmonic vibrational frequencies, it’s important to keep in mind; that the values of the vibrational frequencies are a function of the; molecular geometry. Therefore, it’s important to obtain the vibrational; frequencies AT THE OPTIMIZED GEOMETRY. Luckily, Psi4 updates the; molecule with optimized geometry as it is being optimized. So, the; optimized geometry for H\(_2\)O is stored inside the h2o; molecule object, which we can access! To compute the frequencies, all we; need to do is to again pass the molecule=h2o argument to the; psi4.frequency(); API; function:. In [6]:. scf_e, scf_wfn = psi4.frequency('scf/cc-pvdz', molecule=h2o, return_wfn=True, dertype=1). 6 displacements needed.; 1 2 3 4 5 6. Executing this cell will prompt Psi4 to compute the Hessian (second; derivative matrix) of the electronic energy with respect to nuclear; displacements. From this, it can obtain the harmonic vibrational; frequencies, given below (roundoff errors of around \(0.1\); cm\(^{-1}\) may exist):; Irrep Harmonic Frequency; (cm-1); -----------------------------------------------; A1 1775.6478; A1 4113.3795; B2 4212.1814; -----------------------------------------------. Notice the symmetry type of the normal modes is specified (A1, A1, B2).; The program also print out the normal modes in terms of Cartesian; coordinates of each atom. For example, the normal mode at \(1776\); cm\(^{-1}\) is:; Frequency: 1775.65; Force constant: 0.1193; X Y Z mass; O 0.000 0.000 -0.068 15.994915; H 0.000 0.416 0.536 1.007825; H 0.000 -0.416 0.536 1.007825. where the table shows the displacements in the X, Y, and Z dimensions; for each atom along the normal mode coordinate. (This information could; be used to animate the vibrational frequency using visualization; software.); Because the vibr",MatchSource.WIKI,psi4manual/1.2.1/psiapi-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi-1.html
https://psicode.org/psi4manual/1.2.1/psiapi-1.html:11089,Energy Efficiency,energy,energy,11089,"--------------------------------------; A1 1775.6478; A1 4113.3795; B2 4212.1814; -----------------------------------------------. Notice the symmetry type of the normal modes is specified (A1, A1, B2).; The program also print out the normal modes in terms of Cartesian; coordinates of each atom. For example, the normal mode at \(1776\); cm\(^{-1}\) is:; Frequency: 1775.65; Force constant: 0.1193; X Y Z mass; O 0.000 0.000 -0.068 15.994915; H 0.000 0.416 0.536 1.007825; H 0.000 -0.416 0.536 1.007825. where the table shows the displacements in the X, Y, and Z dimensions; for each atom along the normal mode coordinate. (This information could; be used to animate the vibrational frequency using visualization; software.); Because the vibrational frequencies are available, a thermodynamics; analysis is automatically performed at the end of the computation. You; can see this in the next section of the output file output.dat. The; vibrational frequencies are sufficient to obtain vibrational; contributions to enthalpy (H), entropy (S), and Gibbs free energy (G).; Similarly, the molecular geometry is used to obtain rotational; constants, which are then used to obtain rotational contributions to H,; S, and G.; Note: Psi4 has several synonyms for the functions called in this; example. For instance, psi4.frequency(); API; will compute molecular vibrational frequencies, and psi4.optimize(); API; will perform a geometry optimization. IV. Analysis of Intermolecular Interactions¶; Now let’s consider something a little more interesting. Psi4 contains; code to analyze the nature of intermolecular interactions between two; molecules, via symmetry-adapted perturbation theory (SAPT); (Jeziorski:1994:1887).; This kind of analysis gives a lot of insight into the nature of; intermolecular interactions, and Psi4 makes these computations easier; than ever.; For a SAPT computation, the input needs to provide information on two; distinct molecules. This is very easy, we just give a Z-matrix or ",MatchSource.WIKI,psi4manual/1.2.1/psiapi-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi-1.html
https://psicode.org/psi4manual/1.2.1/psiapi-1.html:11686,Energy Efficiency,adapt,adapted,11686,"s information could; be used to animate the vibrational frequency using visualization; software.); Because the vibrational frequencies are available, a thermodynamics; analysis is automatically performed at the end of the computation. You; can see this in the next section of the output file output.dat. The; vibrational frequencies are sufficient to obtain vibrational; contributions to enthalpy (H), entropy (S), and Gibbs free energy (G).; Similarly, the molecular geometry is used to obtain rotational; constants, which are then used to obtain rotational contributions to H,; S, and G.; Note: Psi4 has several synonyms for the functions called in this; example. For instance, psi4.frequency(); API; will compute molecular vibrational frequencies, and psi4.optimize(); API; will perform a geometry optimization. IV. Analysis of Intermolecular Interactions¶; Now let’s consider something a little more interesting. Psi4 contains; code to analyze the nature of intermolecular interactions between two; molecules, via symmetry-adapted perturbation theory (SAPT); (Jeziorski:1994:1887).; This kind of analysis gives a lot of insight into the nature of; intermolecular interactions, and Psi4 makes these computations easier; than ever.; For a SAPT computation, the input needs to provide information on two; distinct molecules. This is very easy, we just give a Z-matrix or set of; Cartesian coordinates for each molecule, and separate the two with two; dashes, like this:. In [7]:. # Example SAPT computation for ethene*ethyne (*i.e.*, ethylene*acetylene).; # Test case 16 from S22 Database. dimer = psi4.geometry(""""""; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; units angstrom; """"""). Here’s the second half of the input,",MatchSource.WIKI,psi4manual/1.2.1/psiapi-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi-1.html
https://psicode.org/psi4manual/1.2.1/psiapi-1.html:12781,Energy Efficiency,energy,energy,12781,"ure of; intermolecular interactions, and Psi4 makes these computations easier; than ever.; For a SAPT computation, the input needs to provide information on two; distinct molecules. This is very easy, we just give a Z-matrix or set of; Cartesian coordinates for each molecule, and separate the two with two; dashes, like this:. In [7]:. # Example SAPT computation for ethene*ethyne (*i.e.*, ethylene*acetylene).; # Test case 16 from S22 Database. dimer = psi4.geometry(""""""; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; units angstrom; """"""). Here’s the second half of the input, where we specify the computation; options:. In [8]:. psi4.set_options({'scf_type': 'df',; 'freeze_core': 'true'}). psi4.energy('sapt0/jun-cc-pvdz', molecule=dimer). Out[8]:. -0.0022355825227244703. All of the options we have currently set using psi4.set_options(); API; are “global” options (meaning that they are visible to all parts of the; program). Most common Psi4 options can be set like this. If an option; needs to be visible only to one part of the program (e.g., we only; want to increase the energy convergence in the SCF code, but not the; rest of the code), it can be set by with the; psi4.set_module_options(); API; function, psi4.set_module_options('scf', {'e_convergence': '1e-8'}).; Note: The arguments to the functions we’ve used so far, like; psi4.set_options(); API,; psi4.set_module_options(); API,; psi4.energy(); API,; psi4.optimize(); API,; psi4.frequency(); API,; etc., are case-insensitive.; Back to our SAPT example, we have found that for basic-level SAPT; computations (i.e., SAPT0), a good error cancellation is found; (Hohenstein:2012:WIREs); with the jun-cc-pVDZ basis (this is the usual aug-cc-pVDZ basis, but",MatchSource.WIKI,psi4manual/1.2.1/psiapi-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi-1.html
https://psicode.org/psi4manual/1.2.1/psiapi-1.html:13164,Energy Efficiency,energy,energy,13164,"lene*acetylene).; # Test case 16 from S22 Database. dimer = psi4.geometry(""""""; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; units angstrom; """"""). Here’s the second half of the input, where we specify the computation; options:. In [8]:. psi4.set_options({'scf_type': 'df',; 'freeze_core': 'true'}). psi4.energy('sapt0/jun-cc-pvdz', molecule=dimer). Out[8]:. -0.0022355825227244703. All of the options we have currently set using psi4.set_options(); API; are “global” options (meaning that they are visible to all parts of the; program). Most common Psi4 options can be set like this. If an option; needs to be visible only to one part of the program (e.g., we only; want to increase the energy convergence in the SCF code, but not the; rest of the code), it can be set by with the; psi4.set_module_options(); API; function, psi4.set_module_options('scf', {'e_convergence': '1e-8'}).; Note: The arguments to the functions we’ve used so far, like; psi4.set_options(); API,; psi4.set_module_options(); API,; psi4.energy(); API,; psi4.optimize(); API,; psi4.frequency(); API,; etc., are case-insensitive.; Back to our SAPT example, we have found that for basic-level SAPT; computations (i.e., SAPT0), a good error cancellation is found; (Hohenstein:2012:WIREs); with the jun-cc-pVDZ basis (this is the usual aug-cc-pVDZ basis, but; without diffuse functions on hydrogen and without diffuse \(d\); functions on heavy atoms); (Papajak:2011:10).; So, we’ll use that as our standard basis set. The SAPT code is designed; to use density fitting techniques, because they introduce minimal errors; while providing much faster computations; (Hohenstein:2010:184111,Hohenstein:2010:014101).; Since we’re using density fitting for the ",MatchSource.WIKI,psi4manual/1.2.1/psiapi-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi-1.html
https://psicode.org/psi4manual/1.2.1/psiapi-1.html:13487,Energy Efficiency,energy,energy,13487,"0000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; units angstrom; """"""). Here’s the second half of the input, where we specify the computation; options:. In [8]:. psi4.set_options({'scf_type': 'df',; 'freeze_core': 'true'}). psi4.energy('sapt0/jun-cc-pvdz', molecule=dimer). Out[8]:. -0.0022355825227244703. All of the options we have currently set using psi4.set_options(); API; are “global” options (meaning that they are visible to all parts of the; program). Most common Psi4 options can be set like this. If an option; needs to be visible only to one part of the program (e.g., we only; want to increase the energy convergence in the SCF code, but not the; rest of the code), it can be set by with the; psi4.set_module_options(); API; function, psi4.set_module_options('scf', {'e_convergence': '1e-8'}).; Note: The arguments to the functions we’ve used so far, like; psi4.set_options(); API,; psi4.set_module_options(); API,; psi4.energy(); API,; psi4.optimize(); API,; psi4.frequency(); API,; etc., are case-insensitive.; Back to our SAPT example, we have found that for basic-level SAPT; computations (i.e., SAPT0), a good error cancellation is found; (Hohenstein:2012:WIREs); with the jun-cc-pVDZ basis (this is the usual aug-cc-pVDZ basis, but; without diffuse functions on hydrogen and without diffuse \(d\); functions on heavy atoms); (Papajak:2011:10).; So, we’ll use that as our standard basis set. The SAPT code is designed; to use density fitting techniques, because they introduce minimal errors; while providing much faster computations; (Hohenstein:2010:184111,Hohenstein:2010:014101).; Since we’re using density fitting for the SAPT, we might as well also; use it for the Hartree-Fock computations that are performed as part of; the SAPT. We can specify that by adding 'scf_type': 'df' to the; dictionary passed to psi4.set_options().; Density fitting procedures require the use of auxiliary basis sets that; pair with the prima",MatchSource.WIKI,psi4manual/1.2.1/psiapi-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi-1.html
https://psicode.org/psi4manual/1.2.1/psiapi-1.html:15141,Energy Efficiency,energy,energy,15141,"e’re using density fitting for the SAPT, we might as well also; use it for the Hartree-Fock computations that are performed as part of; the SAPT. We can specify that by adding 'scf_type': 'df' to the; dictionary passed to psi4.set_options().; Density fitting procedures require the use of auxiliary basis sets that; pair with the primary basis set. Fortunately, Psi4 is usually smart; enough to figure out what auxiliary basis sets are needed for a given; computation. In this case, jun-cc-pVDZ is a standard enough basis set; (just a simple truncation of the very popular aug-cc-pVDZ basis set); that Psi4 correctly guesses that we want the jun-cc-pVDZ-JKFIT auxiliary; basis for the Hartree-Fock, and the jun-cc-pVDZ-RI basis set for the; SAPT procedure.; To speed up the computation a little, we also tell the SAPT procedure to; freeze the core electrons by adding 'freeze_core': 'true' to the; dictionary passed to psi4.set_options(). The SAPT procedure is; invoked by psi4.energy('sapt0/jun-cc-pvdz', molecule=dimer). Here,; Psi4 knows to automatically run two monomer computations and a dimer; computation and then use these results to perform the SAPT analysis. The; various energy components are printed at the end of the output, in; addition to the total SAPT0 interaction energy. An explanation of the; various energy components can be found in the review by Jeziorski,; Moszynski, and Szalewicz; (Jeziorski:1994:1887),; and this is discussed in more detail in the SAPT; section of the Psi4; manual.; For now, we’ll note that most of the SAPT energy components are; negative; this means those are attractive contributions (the zero of; energy in a SAPT computation is defined as non-interacting monomers).; The exchange contributions are positive (repulsive). In this example,; the most attractive contribution between ethylene and acetylene is an; electrostatic term of \(-2.12\) kcal/mol (Elst10,r where the 1; indicates the first-order perturbation theory result with respect to the; int",MatchSource.WIKI,psi4manual/1.2.1/psiapi-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi-1.html
https://psicode.org/psi4manual/1.2.1/psiapi-1.html:15345,Energy Efficiency,energy,energy,15345,"et_options().; Density fitting procedures require the use of auxiliary basis sets that; pair with the primary basis set. Fortunately, Psi4 is usually smart; enough to figure out what auxiliary basis sets are needed for a given; computation. In this case, jun-cc-pVDZ is a standard enough basis set; (just a simple truncation of the very popular aug-cc-pVDZ basis set); that Psi4 correctly guesses that we want the jun-cc-pVDZ-JKFIT auxiliary; basis for the Hartree-Fock, and the jun-cc-pVDZ-RI basis set for the; SAPT procedure.; To speed up the computation a little, we also tell the SAPT procedure to; freeze the core electrons by adding 'freeze_core': 'true' to the; dictionary passed to psi4.set_options(). The SAPT procedure is; invoked by psi4.energy('sapt0/jun-cc-pvdz', molecule=dimer). Here,; Psi4 knows to automatically run two monomer computations and a dimer; computation and then use these results to perform the SAPT analysis. The; various energy components are printed at the end of the output, in; addition to the total SAPT0 interaction energy. An explanation of the; various energy components can be found in the review by Jeziorski,; Moszynski, and Szalewicz; (Jeziorski:1994:1887),; and this is discussed in more detail in the SAPT; section of the Psi4; manual.; For now, we’ll note that most of the SAPT energy components are; negative; this means those are attractive contributions (the zero of; energy in a SAPT computation is defined as non-interacting monomers).; The exchange contributions are positive (repulsive). In this example,; the most attractive contribution between ethylene and acetylene is an; electrostatic term of \(-2.12\) kcal/mol (Elst10,r where the 1; indicates the first-order perturbation theory result with respect to the; intermolecular interaction, and the 0 indicates zeroth-order with; respect to the intramolecular electron correlation). The next most; attractive contribution is the Disp20 term (second order; intermolecular dispersion, which looks ",MatchSource.WIKI,psi4manual/1.2.1/psiapi-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi-1.html
https://psicode.org/psi4manual/1.2.1/psiapi-1.html:15445,Energy Efficiency,energy,energy,15445,"et_options().; Density fitting procedures require the use of auxiliary basis sets that; pair with the primary basis set. Fortunately, Psi4 is usually smart; enough to figure out what auxiliary basis sets are needed for a given; computation. In this case, jun-cc-pVDZ is a standard enough basis set; (just a simple truncation of the very popular aug-cc-pVDZ basis set); that Psi4 correctly guesses that we want the jun-cc-pVDZ-JKFIT auxiliary; basis for the Hartree-Fock, and the jun-cc-pVDZ-RI basis set for the; SAPT procedure.; To speed up the computation a little, we also tell the SAPT procedure to; freeze the core electrons by adding 'freeze_core': 'true' to the; dictionary passed to psi4.set_options(). The SAPT procedure is; invoked by psi4.energy('sapt0/jun-cc-pvdz', molecule=dimer). Here,; Psi4 knows to automatically run two monomer computations and a dimer; computation and then use these results to perform the SAPT analysis. The; various energy components are printed at the end of the output, in; addition to the total SAPT0 interaction energy. An explanation of the; various energy components can be found in the review by Jeziorski,; Moszynski, and Szalewicz; (Jeziorski:1994:1887),; and this is discussed in more detail in the SAPT; section of the Psi4; manual.; For now, we’ll note that most of the SAPT energy components are; negative; this means those are attractive contributions (the zero of; energy in a SAPT computation is defined as non-interacting monomers).; The exchange contributions are positive (repulsive). In this example,; the most attractive contribution between ethylene and acetylene is an; electrostatic term of \(-2.12\) kcal/mol (Elst10,r where the 1; indicates the first-order perturbation theory result with respect to the; intermolecular interaction, and the 0 indicates zeroth-order with; respect to the intramolecular electron correlation). The next most; attractive contribution is the Disp20 term (second order; intermolecular dispersion, which looks ",MatchSource.WIKI,psi4manual/1.2.1/psiapi-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi-1.html
https://psicode.org/psi4manual/1.2.1/psiapi-1.html:15484,Energy Efficiency,energy,energy,15484,"re out what auxiliary basis sets are needed for a given; computation. In this case, jun-cc-pVDZ is a standard enough basis set; (just a simple truncation of the very popular aug-cc-pVDZ basis set); that Psi4 correctly guesses that we want the jun-cc-pVDZ-JKFIT auxiliary; basis for the Hartree-Fock, and the jun-cc-pVDZ-RI basis set for the; SAPT procedure.; To speed up the computation a little, we also tell the SAPT procedure to; freeze the core electrons by adding 'freeze_core': 'true' to the; dictionary passed to psi4.set_options(). The SAPT procedure is; invoked by psi4.energy('sapt0/jun-cc-pvdz', molecule=dimer). Here,; Psi4 knows to automatically run two monomer computations and a dimer; computation and then use these results to perform the SAPT analysis. The; various energy components are printed at the end of the output, in; addition to the total SAPT0 interaction energy. An explanation of the; various energy components can be found in the review by Jeziorski,; Moszynski, and Szalewicz; (Jeziorski:1994:1887),; and this is discussed in more detail in the SAPT; section of the Psi4; manual.; For now, we’ll note that most of the SAPT energy components are; negative; this means those are attractive contributions (the zero of; energy in a SAPT computation is defined as non-interacting monomers).; The exchange contributions are positive (repulsive). In this example,; the most attractive contribution between ethylene and acetylene is an; electrostatic term of \(-2.12\) kcal/mol (Elst10,r where the 1; indicates the first-order perturbation theory result with respect to the; intermolecular interaction, and the 0 indicates zeroth-order with; respect to the intramolecular electron correlation). The next most; attractive contribution is the Disp20 term (second order; intermolecular dispersion, which looks like MP2 in which one excitation; is placed on each monomer), contributing an attraction of \(-1.21\); kcal/mol. It is not surprising that the electrostatic contribution ",MatchSource.WIKI,psi4manual/1.2.1/psiapi-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi-1.html
https://psicode.org/psi4manual/1.2.1/psiapi-1.html:15716,Energy Efficiency,energy,energy,15716,"ctly guesses that we want the jun-cc-pVDZ-JKFIT auxiliary; basis for the Hartree-Fock, and the jun-cc-pVDZ-RI basis set for the; SAPT procedure.; To speed up the computation a little, we also tell the SAPT procedure to; freeze the core electrons by adding 'freeze_core': 'true' to the; dictionary passed to psi4.set_options(). The SAPT procedure is; invoked by psi4.energy('sapt0/jun-cc-pvdz', molecule=dimer). Here,; Psi4 knows to automatically run two monomer computations and a dimer; computation and then use these results to perform the SAPT analysis. The; various energy components are printed at the end of the output, in; addition to the total SAPT0 interaction energy. An explanation of the; various energy components can be found in the review by Jeziorski,; Moszynski, and Szalewicz; (Jeziorski:1994:1887),; and this is discussed in more detail in the SAPT; section of the Psi4; manual.; For now, we’ll note that most of the SAPT energy components are; negative; this means those are attractive contributions (the zero of; energy in a SAPT computation is defined as non-interacting monomers).; The exchange contributions are positive (repulsive). In this example,; the most attractive contribution between ethylene and acetylene is an; electrostatic term of \(-2.12\) kcal/mol (Elst10,r where the 1; indicates the first-order perturbation theory result with respect to the; intermolecular interaction, and the 0 indicates zeroth-order with; respect to the intramolecular electron correlation). The next most; attractive contribution is the Disp20 term (second order; intermolecular dispersion, which looks like MP2 in which one excitation; is placed on each monomer), contributing an attraction of \(-1.21\); kcal/mol. It is not surprising that the electrostatic contribution is; dominant, because the geometry chosen for this example has the acetylene; perpendicular to the ethylene, with the acetylene hydrogen pointing; directly at the double bond in ethylene; this will be attractive b",MatchSource.WIKI,psi4manual/1.2.1/psiapi-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi-1.html
https://psicode.org/psi4manual/1.2.1/psiapi-1.html:15809,Energy Efficiency,energy,energy,15809,"ctly guesses that we want the jun-cc-pVDZ-JKFIT auxiliary; basis for the Hartree-Fock, and the jun-cc-pVDZ-RI basis set for the; SAPT procedure.; To speed up the computation a little, we also tell the SAPT procedure to; freeze the core electrons by adding 'freeze_core': 'true' to the; dictionary passed to psi4.set_options(). The SAPT procedure is; invoked by psi4.energy('sapt0/jun-cc-pvdz', molecule=dimer). Here,; Psi4 knows to automatically run two monomer computations and a dimer; computation and then use these results to perform the SAPT analysis. The; various energy components are printed at the end of the output, in; addition to the total SAPT0 interaction energy. An explanation of the; various energy components can be found in the review by Jeziorski,; Moszynski, and Szalewicz; (Jeziorski:1994:1887),; and this is discussed in more detail in the SAPT; section of the Psi4; manual.; For now, we’ll note that most of the SAPT energy components are; negative; this means those are attractive contributions (the zero of; energy in a SAPT computation is defined as non-interacting monomers).; The exchange contributions are positive (repulsive). In this example,; the most attractive contribution between ethylene and acetylene is an; electrostatic term of \(-2.12\) kcal/mol (Elst10,r where the 1; indicates the first-order perturbation theory result with respect to the; intermolecular interaction, and the 0 indicates zeroth-order with; respect to the intramolecular electron correlation). The next most; attractive contribution is the Disp20 term (second order; intermolecular dispersion, which looks like MP2 in which one excitation; is placed on each monomer), contributing an attraction of \(-1.21\); kcal/mol. It is not surprising that the electrostatic contribution is; dominant, because the geometry chosen for this example has the acetylene; perpendicular to the ethylene, with the acetylene hydrogen pointing; directly at the double bond in ethylene; this will be attractive b",MatchSource.WIKI,psi4manual/1.2.1/psiapi-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi-1.html
https://psicode.org/psi4manual/1.2.1/psiapi-1.html:16832,Energy Efficiency,charge,charge,16832,"APT energy components are; negative; this means those are attractive contributions (the zero of; energy in a SAPT computation is defined as non-interacting monomers).; The exchange contributions are positive (repulsive). In this example,; the most attractive contribution between ethylene and acetylene is an; electrostatic term of \(-2.12\) kcal/mol (Elst10,r where the 1; indicates the first-order perturbation theory result with respect to the; intermolecular interaction, and the 0 indicates zeroth-order with; respect to the intramolecular electron correlation). The next most; attractive contribution is the Disp20 term (second order; intermolecular dispersion, which looks like MP2 in which one excitation; is placed on each monomer), contributing an attraction of \(-1.21\); kcal/mol. It is not surprising that the electrostatic contribution is; dominant, because the geometry chosen for this example has the acetylene; perpendicular to the ethylene, with the acetylene hydrogen pointing; directly at the double bond in ethylene; this will be attractive because; the H atoms in acetylene bear a partial positive charge, while the; electron rich double bond in ethylene bears a partial negative charge.; At the same time, the dispersion interaction should be smaller because; the perpendicular geometry does not allow much overlap between the; monomers. Hence, the SAPT analysis helps clarify (and quantify) our; physical understanding about the interaction between the two monomers. V. Potential Surface Scans and Counterpoise Correction Made Easy¶; Finally, let’s consider an example which highlights the advantages of; being able to interact with Psi4 directly with Python.; Suppose you want to do a limited potential energy surface scan, such as; computing the interaction energy between two neon atoms at various; interatomic distances. One simple but unappealing way to do this is to; generate separate geometries for each distance to be studied. Instead,; we can leverage Python loops an",MatchSource.WIKI,psi4manual/1.2.1/psiapi-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi-1.html
https://psicode.org/psi4manual/1.2.1/psiapi-1.html:16914,Energy Efficiency,charge,charge,16914,"APT energy components are; negative; this means those are attractive contributions (the zero of; energy in a SAPT computation is defined as non-interacting monomers).; The exchange contributions are positive (repulsive). In this example,; the most attractive contribution between ethylene and acetylene is an; electrostatic term of \(-2.12\) kcal/mol (Elst10,r where the 1; indicates the first-order perturbation theory result with respect to the; intermolecular interaction, and the 0 indicates zeroth-order with; respect to the intramolecular electron correlation). The next most; attractive contribution is the Disp20 term (second order; intermolecular dispersion, which looks like MP2 in which one excitation; is placed on each monomer), contributing an attraction of \(-1.21\); kcal/mol. It is not surprising that the electrostatic contribution is; dominant, because the geometry chosen for this example has the acetylene; perpendicular to the ethylene, with the acetylene hydrogen pointing; directly at the double bond in ethylene; this will be attractive because; the H atoms in acetylene bear a partial positive charge, while the; electron rich double bond in ethylene bears a partial negative charge.; At the same time, the dispersion interaction should be smaller because; the perpendicular geometry does not allow much overlap between the; monomers. Hence, the SAPT analysis helps clarify (and quantify) our; physical understanding about the interaction between the two monomers. V. Potential Surface Scans and Counterpoise Correction Made Easy¶; Finally, let’s consider an example which highlights the advantages of; being able to interact with Psi4 directly with Python.; Suppose you want to do a limited potential energy surface scan, such as; computing the interaction energy between two neon atoms at various; interatomic distances. One simple but unappealing way to do this is to; generate separate geometries for each distance to be studied. Instead,; we can leverage Python loops an",MatchSource.WIKI,psi4manual/1.2.1/psiapi-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi-1.html
https://psicode.org/psi4manual/1.2.1/psiapi-1.html:17440,Energy Efficiency,energy,energy,17440,"ion of \(-1.21\); kcal/mol. It is not surprising that the electrostatic contribution is; dominant, because the geometry chosen for this example has the acetylene; perpendicular to the ethylene, with the acetylene hydrogen pointing; directly at the double bond in ethylene; this will be attractive because; the H atoms in acetylene bear a partial positive charge, while the; electron rich double bond in ethylene bears a partial negative charge.; At the same time, the dispersion interaction should be smaller because; the perpendicular geometry does not allow much overlap between the; monomers. Hence, the SAPT analysis helps clarify (and quantify) our; physical understanding about the interaction between the two monomers. V. Potential Surface Scans and Counterpoise Correction Made Easy¶; Finally, let’s consider an example which highlights the advantages of; being able to interact with Psi4 directly with Python.; Suppose you want to do a limited potential energy surface scan, such as; computing the interaction energy between two neon atoms at various; interatomic distances. One simple but unappealing way to do this is to; generate separate geometries for each distance to be studied. Instead,; we can leverage Python loops and string formatting to make our lives; simpler. Additionally, let’s suppose you want to do counterpoise (CP); correction to compute interaction energies. Counterpoise correction; involves computing the dimer energy and then subtracting out the; energies of the two monomers, each evaluated in the dimer basis. Again,; each of these computations could be run in a separate input file, but; because counterpoise correction is a fairly standard procedure for; intermolecular interactions, Psi4 knows about it and has a built-in; routine to perform counterpoise correction. It only needs to know what; method you want to do the couterpoise correction on (here, let’s; consider CCSD(T)), and it needs to know what’s monomer A and what’s; monomer B. This last issue of sp",MatchSource.WIKI,psi4manual/1.2.1/psiapi-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi-1.html
https://psicode.org/psi4manual/1.2.1/psiapi-1.html:17496,Energy Efficiency,energy,energy,17496,"ion of \(-1.21\); kcal/mol. It is not surprising that the electrostatic contribution is; dominant, because the geometry chosen for this example has the acetylene; perpendicular to the ethylene, with the acetylene hydrogen pointing; directly at the double bond in ethylene; this will be attractive because; the H atoms in acetylene bear a partial positive charge, while the; electron rich double bond in ethylene bears a partial negative charge.; At the same time, the dispersion interaction should be smaller because; the perpendicular geometry does not allow much overlap between the; monomers. Hence, the SAPT analysis helps clarify (and quantify) our; physical understanding about the interaction between the two monomers. V. Potential Surface Scans and Counterpoise Correction Made Easy¶; Finally, let’s consider an example which highlights the advantages of; being able to interact with Psi4 directly with Python.; Suppose you want to do a limited potential energy surface scan, such as; computing the interaction energy between two neon atoms at various; interatomic distances. One simple but unappealing way to do this is to; generate separate geometries for each distance to be studied. Instead,; we can leverage Python loops and string formatting to make our lives; simpler. Additionally, let’s suppose you want to do counterpoise (CP); correction to compute interaction energies. Counterpoise correction; involves computing the dimer energy and then subtracting out the; energies of the two monomers, each evaluated in the dimer basis. Again,; each of these computations could be run in a separate input file, but; because counterpoise correction is a fairly standard procedure for; intermolecular interactions, Psi4 knows about it and has a built-in; routine to perform counterpoise correction. It only needs to know what; method you want to do the couterpoise correction on (here, let’s; consider CCSD(T)), and it needs to know what’s monomer A and what’s; monomer B. This last issue of sp",MatchSource.WIKI,psi4manual/1.2.1/psiapi-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi-1.html
https://psicode.org/psi4manual/1.2.1/psiapi-1.html:17921,Energy Efficiency,energy,energy,17921," dispersion interaction should be smaller because; the perpendicular geometry does not allow much overlap between the; monomers. Hence, the SAPT analysis helps clarify (and quantify) our; physical understanding about the interaction between the two monomers. V. Potential Surface Scans and Counterpoise Correction Made Easy¶; Finally, let’s consider an example which highlights the advantages of; being able to interact with Psi4 directly with Python.; Suppose you want to do a limited potential energy surface scan, such as; computing the interaction energy between two neon atoms at various; interatomic distances. One simple but unappealing way to do this is to; generate separate geometries for each distance to be studied. Instead,; we can leverage Python loops and string formatting to make our lives; simpler. Additionally, let’s suppose you want to do counterpoise (CP); correction to compute interaction energies. Counterpoise correction; involves computing the dimer energy and then subtracting out the; energies of the two monomers, each evaluated in the dimer basis. Again,; each of these computations could be run in a separate input file, but; because counterpoise correction is a fairly standard procedure for; intermolecular interactions, Psi4 knows about it and has a built-in; routine to perform counterpoise correction. It only needs to know what; method you want to do the couterpoise correction on (here, let’s; consider CCSD(T)), and it needs to know what’s monomer A and what’s; monomer B. This last issue of specifying the monomers separately was; already dealt with in the previous SAPT example, where we saw that two; dashes in the psi4.geometry() string can be used to separate; monomers.; So, we’re going to do counterpoise-corrected CCSD(T) energies for; Ne\(_2\) at a series of different interatomic distances. And let’s; print out a table of the interatomic distances we’ve considered, and the; CP-corrected CCSD(T) interaction energies (in kcal/mol) at each; geometry:",MatchSource.WIKI,psi4manual/1.2.1/psiapi-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi-1.html
https://psicode.org/psi4manual/1.2.1/psiapi-1.html:18976,Energy Efficiency,energy,energy,18976,"each evaluated in the dimer basis. Again,; each of these computations could be run in a separate input file, but; because counterpoise correction is a fairly standard procedure for; intermolecular interactions, Psi4 knows about it and has a built-in; routine to perform counterpoise correction. It only needs to know what; method you want to do the couterpoise correction on (here, let’s; consider CCSD(T)), and it needs to know what’s monomer A and what’s; monomer B. This last issue of specifying the monomers separately was; already dealt with in the previous SAPT example, where we saw that two; dashes in the psi4.geometry() string can be used to separate; monomers.; So, we’re going to do counterpoise-corrected CCSD(T) energies for; Ne\(_2\) at a series of different interatomic distances. And let’s; print out a table of the interatomic distances we’ve considered, and the; CP-corrected CCSD(T) interaction energies (in kcal/mol) at each; geometry:. In [9]:. #! Example potential energy surface scan and CP-correction for Ne2. ne2_geometry = """"""; Ne; --; Ne 1 {0}; """""". Rvals = [2.5, 3.0, 4.0]. psi4.set_options({'freeze_core': 'true'}). # Initialize a blank dictionary of counterpoise corrected energies; # (Need this for the syntax below to work). ecp = {}. for R in Rvals:; ne2 = psi4.geometry(ne2_geometry.format(R)); ecp[R] = psi4.energy('ccsd(t)/aug-cc-pvdz', bsse_type='cp', molecule=ne2). # Prints to screen; print(""CP-corrected CCSD(T)/aug-cc-pVDZ Interaction Energies\n\n""); print("" R [Ang] E_int [kcal/mol] ""); print(""---------------------------------------------------------""); for R in Rvals:; e = ecp[R] * psi4.constants.hartree2kcalmol; print("" {:3.1f} {:1.6f}"".format(R, e)). # Prints to output.dat; psi4.core.print_out(""CP-corrected CCSD(T)/aug-cc-pVDZ Interaction Energies\n\n""); psi4.core.print_out("" R [Ang] E_int [kcal/mol] \n""); psi4.core.print_out(""---------------------------------------------------------\n""); for R in Rvals:; e = ecp[R] * psi4.constants.hartree2kcal",MatchSource.WIKI,psi4manual/1.2.1/psiapi-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi-1.html
https://psicode.org/psi4manual/1.2.1/psiapi-1.html:19332,Energy Efficiency,energy,energy,19332," (here, let’s; consider CCSD(T)), and it needs to know what’s monomer A and what’s; monomer B. This last issue of specifying the monomers separately was; already dealt with in the previous SAPT example, where we saw that two; dashes in the psi4.geometry() string can be used to separate; monomers.; So, we’re going to do counterpoise-corrected CCSD(T) energies for; Ne\(_2\) at a series of different interatomic distances. And let’s; print out a table of the interatomic distances we’ve considered, and the; CP-corrected CCSD(T) interaction energies (in kcal/mol) at each; geometry:. In [9]:. #! Example potential energy surface scan and CP-correction for Ne2. ne2_geometry = """"""; Ne; --; Ne 1 {0}; """""". Rvals = [2.5, 3.0, 4.0]. psi4.set_options({'freeze_core': 'true'}). # Initialize a blank dictionary of counterpoise corrected energies; # (Need this for the syntax below to work). ecp = {}. for R in Rvals:; ne2 = psi4.geometry(ne2_geometry.format(R)); ecp[R] = psi4.energy('ccsd(t)/aug-cc-pvdz', bsse_type='cp', molecule=ne2). # Prints to screen; print(""CP-corrected CCSD(T)/aug-cc-pVDZ Interaction Energies\n\n""); print("" R [Ang] E_int [kcal/mol] ""); print(""---------------------------------------------------------""); for R in Rvals:; e = ecp[R] * psi4.constants.hartree2kcalmol; print("" {:3.1f} {:1.6f}"".format(R, e)). # Prints to output.dat; psi4.core.print_out(""CP-corrected CCSD(T)/aug-cc-pVDZ Interaction Energies\n\n""); psi4.core.print_out("" R [Ang] E_int [kcal/mol] \n""); psi4.core.print_out(""---------------------------------------------------------\n""); for R in Rvals:; e = ecp[R] * psi4.constants.hartree2kcalmol; psi4.core.print_out("" {:3.1f} {:1.6f}\n"".format(R, e)). CP-corrected CCSD(T)/aug-cc-pVDZ Interaction Energies. R [Ang] E_int [kcal/mol]; ---------------------------------------------------------; 2.5 0.758605; 3.0 0.015968; 4.0 -0.016215. First, you can see the geometry string ne2_geometry has a two dashes; to separate the monomers from each other. Also note we’ve us",MatchSource.WIKI,psi4manual/1.2.1/psiapi-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi-1.html
https://psicode.org/psi4manual/1.2.1/psiapi-1.html:20628,Energy Efficiency,energy,energy,20628,"artree2kcalmol; print("" {:3.1f} {:1.6f}"".format(R, e)). # Prints to output.dat; psi4.core.print_out(""CP-corrected CCSD(T)/aug-cc-pVDZ Interaction Energies\n\n""); psi4.core.print_out("" R [Ang] E_int [kcal/mol] \n""); psi4.core.print_out(""---------------------------------------------------------\n""); for R in Rvals:; e = ecp[R] * psi4.constants.hartree2kcalmol; psi4.core.print_out("" {:3.1f} {:1.6f}\n"".format(R, e)). CP-corrected CCSD(T)/aug-cc-pVDZ Interaction Energies. R [Ang] E_int [kcal/mol]; ---------------------------------------------------------; 2.5 0.758605; 3.0 0.015968; 4.0 -0.016215. First, you can see the geometry string ne2_geometry has a two dashes; to separate the monomers from each other. Also note we’ve used a; Z-matrix to specify the geometry, and we’ve used a variable (R) as; the interatomic distance. We have not specified the value of R in; the ne2_geometry string like we normally would. That’s because we; are going to vary it during the scan across the potential energy; surface, by using a Python loop over the list of interatomic distances; Rvals. Before we are able to pass our molecule to Psi4, we need to; do two things. First, we must set the value of the intermolecular; separation in our Z-matrix (by using Python 3 string; formatting); to the particular value of R. Second, we need to turn the Z-matrix; string into a Psi4 molecule, by passing it to; `psi4.geometry() <http://psicode.org/psi4manual/master/api/psi4.driver.geometry.html#psi4.driver.geometry>`__.; The argument bsse_type='cp' tells Psi4 to perform counterpoise (CP); correction on the dimer to compute the CCSD(T)/aug-cc-pVDZ interaction; energy, which is stored in our ecp dictionary at each iteration of; our Python loop. Note that we didn’t need to specify ghost atoms, and we; didn’t need to call the monomer and dimer computations separately. Psi4; does it all for us, automatically.; Near the very end of the output file output.dat, the counterpoise; correction Python function will prin",MatchSource.WIKI,psi4manual/1.2.1/psiapi-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi-1.html
https://psicode.org/psi4manual/1.2.1/psiapi-1.html:21278,Energy Efficiency,energy,energy,21278,"ee the geometry string ne2_geometry has a two dashes; to separate the monomers from each other. Also note we’ve used a; Z-matrix to specify the geometry, and we’ve used a variable (R) as; the interatomic distance. We have not specified the value of R in; the ne2_geometry string like we normally would. That’s because we; are going to vary it during the scan across the potential energy; surface, by using a Python loop over the list of interatomic distances; Rvals. Before we are able to pass our molecule to Psi4, we need to; do two things. First, we must set the value of the intermolecular; separation in our Z-matrix (by using Python 3 string; formatting); to the particular value of R. Second, we need to turn the Z-matrix; string into a Psi4 molecule, by passing it to; `psi4.geometry() <http://psicode.org/psi4manual/master/api/psi4.driver.geometry.html#psi4.driver.geometry>`__.; The argument bsse_type='cp' tells Psi4 to perform counterpoise (CP); correction on the dimer to compute the CCSD(T)/aug-cc-pVDZ interaction; energy, which is stored in our ecp dictionary at each iteration of; our Python loop. Note that we didn’t need to specify ghost atoms, and we; didn’t need to call the monomer and dimer computations separately. Psi4; does it all for us, automatically.; Near the very end of the output file output.dat, the counterpoise; correction Python function will print a nice summary of the results of; the counterpoise computation (the energies of the dimer, of monomer 1; with the ghost functions of monomer 2, of monomer 2 with the ghost; functions of monomer 1, and the overall counterpoise corrected; interaction energy):; N-Body: Computing complex (1/2) with fragments (2,) in the basis of fragments (1, 2).; ...; N-Body: Complex Energy (fragments = (2,), basis = (1, 2): -128.70932405488924); ...; N-Body: Computing complex (2/2) with fragments (1,) in the basis of fragments (1, 2).; ...; N-Body: Complex Energy (fragments = (1,), basis = (1, 2): -128.70932405488935); ...; N-",MatchSource.WIKI,psi4manual/1.2.1/psiapi-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi-1.html
https://psicode.org/psi4manual/1.2.1/psiapi-1.html:21883,Energy Efficiency,energy,energy,21883," do two things. First, we must set the value of the intermolecular; separation in our Z-matrix (by using Python 3 string; formatting); to the particular value of R. Second, we need to turn the Z-matrix; string into a Psi4 molecule, by passing it to; `psi4.geometry() <http://psicode.org/psi4manual/master/api/psi4.driver.geometry.html#psi4.driver.geometry>`__.; The argument bsse_type='cp' tells Psi4 to perform counterpoise (CP); correction on the dimer to compute the CCSD(T)/aug-cc-pVDZ interaction; energy, which is stored in our ecp dictionary at each iteration of; our Python loop. Note that we didn’t need to specify ghost atoms, and we; didn’t need to call the monomer and dimer computations separately. Psi4; does it all for us, automatically.; Near the very end of the output file output.dat, the counterpoise; correction Python function will print a nice summary of the results of; the counterpoise computation (the energies of the dimer, of monomer 1; with the ghost functions of monomer 2, of monomer 2 with the ghost; functions of monomer 1, and the overall counterpoise corrected; interaction energy):; N-Body: Computing complex (1/2) with fragments (2,) in the basis of fragments (1, 2).; ...; N-Body: Complex Energy (fragments = (2,), basis = (1, 2): -128.70932405488924); ...; N-Body: Computing complex (2/2) with fragments (1,) in the basis of fragments (1, 2).; ...; N-Body: Complex Energy (fragments = (1,), basis = (1, 2): -128.70932405488935); ...; N-Body: Computing complex (1/1) with fragments (1, 2) in the basis of fragments (1, 2).; ...; N-Body: Complex Energy (fragments = (1, 2), basis = (1, 2): -257.41867403127321); ...; ==> N-Body: Counterpoise Corrected (CP) energies <==. n-Body Total Energy [Eh] I.E. [kcal/mol] Delta [kcal/mol]; 1 -257.418648109779 0.000000000000 0.000000000000; 2 -257.418674031273 -0.016265984132 -0.016265984132. And that’s it! The only remaining part of the example is a little table; of the different R values and the CP-corrected CCSD(T) ene",MatchSource.WIKI,psi4manual/1.2.1/psiapi-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi-1.html
https://psicode.org/psi4manual/1.2.1/psiapi-1.html:7837,Integrability,message,message,7837,"g psi4.energy(); API; with psi4.optimize(); API; or psi4.frequency(); API,; respectively.; Let’s take a look at an example of optimizing the H\(_2\)O; molecule using Hartree-Fock with a cc-pVDZ basis set.; Now, here comes the real beauty of running Psi4 interactively: above,; when we computed the energy of H\(_2\)O with HF/cc-pVDZ, we; defined the Psi4 molecule object h2o. Since we’re still in the; Python shell, as long as you executed that block of code, we can reuse; the h2o molecule object in our optimization without redefining it,; by adding the molecule=h2o argument to the psi4.optimize(); API; function:. In [5]:. psi4.set_options({'reference': 'rhf'}); psi4.optimize('scf/cc-pvdz', molecule=h2o). Optimizer: Optimization complete!. Out[5]:. -76.02703272937504. This should perform a series of gradient computations. The gradient; points which way is downhill in energy, and the optimizer then modifies; the geometry to follow the gradient. After a few cycles, the geometry; should converge with a message like Optimization complete!. As; indicated in the following table (printed by the optimizer at the end of; the computation and grep-able with ~), the energy decreases with; each step, and the maximum force on each atom also decreases with each; step (in principle, these numbers could increase in some iterations, but; here they do not).; --------------------------------------------------------------------------------------------------------------- ~  Step         Total Energy             Delta E       MAX Force       RMS Force        MAX Disp        RMS Disp  ~ --------------------------------------------------------------------------------------------------------------- ~     1     -76.026632734908    -76.026632734908      0.01523518      0.01245755      0.02742222      0.02277530  ~     2     -76.027022666011     -0.000389931104      0.00178779      0.00142946      0.01008137      0.00594928  ~     3     -76.027032729374     -0.000010063363      0.00014019      0.00",MatchSource.WIKI,psi4manual/1.2.1/psiapi-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi-1.html
https://psicode.org/psi4manual/1.2.1/psiapi-1.html:18239,Integrability,rout,routine,18239,"ng about the interaction between the two monomers. V. Potential Surface Scans and Counterpoise Correction Made Easy¶; Finally, let’s consider an example which highlights the advantages of; being able to interact with Psi4 directly with Python.; Suppose you want to do a limited potential energy surface scan, such as; computing the interaction energy between two neon atoms at various; interatomic distances. One simple but unappealing way to do this is to; generate separate geometries for each distance to be studied. Instead,; we can leverage Python loops and string formatting to make our lives; simpler. Additionally, let’s suppose you want to do counterpoise (CP); correction to compute interaction energies. Counterpoise correction; involves computing the dimer energy and then subtracting out the; energies of the two monomers, each evaluated in the dimer basis. Again,; each of these computations could be run in a separate input file, but; because counterpoise correction is a fairly standard procedure for; intermolecular interactions, Psi4 knows about it and has a built-in; routine to perform counterpoise correction. It only needs to know what; method you want to do the couterpoise correction on (here, let’s; consider CCSD(T)), and it needs to know what’s monomer A and what’s; monomer B. This last issue of specifying the monomers separately was; already dealt with in the previous SAPT example, where we saw that two; dashes in the psi4.geometry() string can be used to separate; monomers.; So, we’re going to do counterpoise-corrected CCSD(T) energies for; Ne\(_2\) at a series of different interatomic distances. And let’s; print out a table of the interatomic distances we’ve considered, and the; CP-corrected CCSD(T) interaction energies (in kcal/mol) at each; geometry:. In [9]:. #! Example potential energy surface scan and CP-correction for Ne2. ne2_geometry = """"""; Ne; --; Ne 1 {0}; """""". Rvals = [2.5, 3.0, 4.0]. psi4.set_options({'freeze_core': 'true'}). # Initialize a bla",MatchSource.WIKI,psi4manual/1.2.1/psiapi-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi-1.html
https://psicode.org/psi4manual/1.2.1/psiapi-1.html:1082,Modifiability,variab,variables,1082,"    .    .    .    .  · ; 1.2.1;  · . PSI4. A PSI4 Tutorial. PsiAPI Tutorial: Using Psi4 as a Python Module¶; transcribed by D. A. Sirianni. Note: Psithon and PsiAPI refer to two modes of interacting with; Psi4. In Psithon mode, you write an input file in our domain-specific; language (not quite Python) where commands don’t have psi4. in; front, then submit it to the executable psi4 which processes the; Psithon into pure Python and runs it internally. In PsiAPI mode, you; write a pure Python script with import psi4 at the top and commands; are behind the psi4. namespace, then submit it to the python; interpreter. Both modes are equally powerful. This tutorial covers the; PsiAPI mode. Warning: Although the developers have been using PsiAPI mode stably; for months before the 1.1 release and while we believe we’ve gotten; everything nicely arranged within the psi4. namespace, the API; should not be considered completely stable. Most importantly, as we; someday deprecate the last of the global variables, options will be; added to the method calls (e.g.,; energy('scf', molecule=mol, options=opt)); Note: Consult How to run Psi4 as Python module after; compilation; or How to run Psi4 as a Python module from conda; installation; for assistance in setting up Psi4. Unlike in the past, where Psi4 was executable software which could only; be called via input files like input.dat, it is now interactive,; able to be loaded directly as a Python module. Here, we will explore the; basics of using Psi4 in this new style by reproducing the section A; Psi4 Tutorial; from the Psi4 manual in an interactive Jupyter Notebook.; Note: If the newest version of Psi4 (v.1.1a2dev42 or newer) is in your; path, feel free to execute each cell as you read along by pressing; Shift+Enter when the cell is selected. I. Basic Input Structure¶; Psi4 is now a Python module; so, we need to import it into our Python; environment:. In [1]:. try:; import os, sys; sys.path.insert(1, os.path.abspath('/scratch/ps",MatchSource.WIKI,psi4manual/1.2.1/psiapi-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi-1.html
https://psicode.org/psi4manual/1.2.1/psiapi-1.html:5484,Modifiability,variab,variables,5484,"hell molecule with all electrons paired), or the reference; wavefunction to use (restricted Hartree-Fock, or RHF, is usually; appropriate for a closed-shell molecule). The program correctly guessed; all of these options for us. We can change the default behavior through; additional keywords.; Let’s consider what we would do for an open-shell molecule, where not; all the electrons are paired. For example, let’s run a computation on; methylene (\(\text{CH}_2\)), whose ground electronic state has two; unpaired electrons (triplet electronic state, or a spin multiplicity; \(2S + 1 = 3\)). In this case, the default spin multiplicity (1) is; not correct, so we need to tell the program the true value (3). Like; many programs, Psi4 can get the charge and multiplicity as the first two; integers in the Z-matrix (note the line with 0 3 at the beginning of; the molecule specification below). In this example, we will also specify; the bond length and bond angle as variables (\(R\) and \(A\)),; whose values are first stored and then inserted into the geometry; specification using Python 3 string; formatting. In [4]:. #! Sample UHF/6-31G** CH2 Computation. R = 1.075; A = 133.93. ch2 = psi4.geometry(""""""; 0 3; C; H 1 {0}; H 1 {0} 2 {1}; """""".format(R, A); ). psi4.set_options({'reference': 'uhf'}); psi4.energy('scf/6-31g**'). Out[4]:. -38.925334628859886. Executing this cell should yield the final energy as; @DF-UHF Final Energy: -38.92533462887677. Notice the new command, psi4.set_options(); API,; to the input. This function takes a Python; dictionary; as its argument, which is a key-value list which associates a Psi4; keyword; with its user-defined value. For open shell molecules, we have a choice; of unrestricted orbitals (unrestricted Hartree-Fock, or UHF) or; restricted orbitals (restricted open-shell Hartree-Fock, or ROHF).; Usually, UHF is a little easier to converge (although it may be more; susceptible to spin contamination than ROHF). III. Geometry Optimization and Vibrational",MatchSource.WIKI,psi4manual/1.2.1/psiapi-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi-1.html
https://psicode.org/psi4manual/1.2.1/psiapi-1.html:11686,Modifiability,adapt,adapted,11686,"s information could; be used to animate the vibrational frequency using visualization; software.); Because the vibrational frequencies are available, a thermodynamics; analysis is automatically performed at the end of the computation. You; can see this in the next section of the output file output.dat. The; vibrational frequencies are sufficient to obtain vibrational; contributions to enthalpy (H), entropy (S), and Gibbs free energy (G).; Similarly, the molecular geometry is used to obtain rotational; constants, which are then used to obtain rotational contributions to H,; S, and G.; Note: Psi4 has several synonyms for the functions called in this; example. For instance, psi4.frequency(); API; will compute molecular vibrational frequencies, and psi4.optimize(); API; will perform a geometry optimization. IV. Analysis of Intermolecular Interactions¶; Now let’s consider something a little more interesting. Psi4 contains; code to analyze the nature of intermolecular interactions between two; molecules, via symmetry-adapted perturbation theory (SAPT); (Jeziorski:1994:1887).; This kind of analysis gives a lot of insight into the nature of; intermolecular interactions, and Psi4 makes these computations easier; than ever.; For a SAPT computation, the input needs to provide information on two; distinct molecules. This is very easy, we just give a Z-matrix or set of; Cartesian coordinates for each molecule, and separate the two with two; dashes, like this:. In [7]:. # Example SAPT computation for ethene*ethyne (*i.e.*, ethylene*acetylene).; # Test case 16 from S22 Database. dimer = psi4.geometry(""""""; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; units angstrom; """"""). Here’s the second half of the input,",MatchSource.WIKI,psi4manual/1.2.1/psiapi-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi-1.html
https://psicode.org/psi4manual/1.2.1/psiapi-1.html:20419,Modifiability,variab,variable,20419,"to screen; print(""CP-corrected CCSD(T)/aug-cc-pVDZ Interaction Energies\n\n""); print("" R [Ang] E_int [kcal/mol] ""); print(""---------------------------------------------------------""); for R in Rvals:; e = ecp[R] * psi4.constants.hartree2kcalmol; print("" {:3.1f} {:1.6f}"".format(R, e)). # Prints to output.dat; psi4.core.print_out(""CP-corrected CCSD(T)/aug-cc-pVDZ Interaction Energies\n\n""); psi4.core.print_out("" R [Ang] E_int [kcal/mol] \n""); psi4.core.print_out(""---------------------------------------------------------\n""); for R in Rvals:; e = ecp[R] * psi4.constants.hartree2kcalmol; psi4.core.print_out("" {:3.1f} {:1.6f}\n"".format(R, e)). CP-corrected CCSD(T)/aug-cc-pVDZ Interaction Energies. R [Ang] E_int [kcal/mol]; ---------------------------------------------------------; 2.5 0.758605; 3.0 0.015968; 4.0 -0.016215. First, you can see the geometry string ne2_geometry has a two dashes; to separate the monomers from each other. Also note we’ve used a; Z-matrix to specify the geometry, and we’ve used a variable (R) as; the interatomic distance. We have not specified the value of R in; the ne2_geometry string like we normally would. That’s because we; are going to vary it during the scan across the potential energy; surface, by using a Python loop over the list of interatomic distances; Rvals. Before we are able to pass our molecule to Psi4, we need to; do two things. First, we must set the value of the intermolecular; separation in our Z-matrix (by using Python 3 string; formatting); to the particular value of R. Second, we need to turn the Z-matrix; string into a Psi4 molecule, by passing it to; `psi4.geometry() <http://psicode.org/psi4manual/master/api/psi4.driver.geometry.html#psi4.driver.geometry>`__.; The argument bsse_type='cp' tells Psi4 to perform counterpoise (CP); correction on the dimer to compute the CCSD(T)/aug-cc-pVDZ interaction; energy, which is stored in our ecp dictionary at each iteration of; our Python loop. Note that we didn’t need to specify gho",MatchSource.WIKI,psi4manual/1.2.1/psiapi-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi-1.html
https://psicode.org/psi4manual/1.2.1/psiapi-1.html:1503,Performance,load,loaded,1503,"e Python and runs it internally. In PsiAPI mode, you; write a pure Python script with import psi4 at the top and commands; are behind the psi4. namespace, then submit it to the python; interpreter. Both modes are equally powerful. This tutorial covers the; PsiAPI mode. Warning: Although the developers have been using PsiAPI mode stably; for months before the 1.1 release and while we believe we’ve gotten; everything nicely arranged within the psi4. namespace, the API; should not be considered completely stable. Most importantly, as we; someday deprecate the last of the global variables, options will be; added to the method calls (e.g.,; energy('scf', molecule=mol, options=opt)); Note: Consult How to run Psi4 as Python module after; compilation; or How to run Psi4 as a Python module from conda; installation; for assistance in setting up Psi4. Unlike in the past, where Psi4 was executable software which could only; be called via input files like input.dat, it is now interactive,; able to be loaded directly as a Python module. Here, we will explore the; basics of using Psi4 in this new style by reproducing the section A; Psi4 Tutorial; from the Psi4 manual in an interactive Jupyter Notebook.; Note: If the newest version of Psi4 (v.1.1a2dev42 or newer) is in your; path, feel free to execute each cell as you read along by pressing; Shift+Enter when the cell is selected. I. Basic Input Structure¶; Psi4 is now a Python module; so, we need to import it into our Python; environment:. In [1]:. try:; import os, sys; sys.path.insert(1, os.path.abspath('/scratch/psilocaluser/conda-builds/psi4-docs-multiout_1532505956776/work/build/stage//opt/anaconda1anaconda2anaconda3/lib/python3.6/site-packages')); except ImportError:; pass. import psi4. Psi4 is now able to be controlled directly from Python. By default, Psi4; will print any output to the screen; this can be changed by giving a; file name (with path if not in the current working directory) to the; function psi4.core.set_output_f",MatchSource.WIKI,psi4manual/1.2.1/psiapi-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi-1.html
https://psicode.org/psi4manual/1.2.1/psiapi-1.html:6710,Performance,perform,perform,6710,"; 0 3; C; H 1 {0}; H 1 {0} 2 {1}; """""".format(R, A); ). psi4.set_options({'reference': 'uhf'}); psi4.energy('scf/6-31g**'). Out[4]:. -38.925334628859886. Executing this cell should yield the final energy as; @DF-UHF Final Energy: -38.92533462887677. Notice the new command, psi4.set_options(); API,; to the input. This function takes a Python; dictionary; as its argument, which is a key-value list which associates a Psi4; keyword; with its user-defined value. For open shell molecules, we have a choice; of unrestricted orbitals (unrestricted Hartree-Fock, or UHF) or; restricted orbitals (restricted open-shell Hartree-Fock, or ROHF).; Usually, UHF is a little easier to converge (although it may be more; susceptible to spin contamination than ROHF). III. Geometry Optimization and Vibrational Frequency Analysis¶; The above examples were simple single-point energy computations (as; specified by the psi4.energy(); API; function). Of course there are other kinds of computations to perform,; such as geometry optimizations and vibrational frequency computations.; These can be specified by replacing psi4.energy(); API; with psi4.optimize(); API; or psi4.frequency(); API,; respectively.; Let’s take a look at an example of optimizing the H\(_2\)O; molecule using Hartree-Fock with a cc-pVDZ basis set.; Now, here comes the real beauty of running Psi4 interactively: above,; when we computed the energy of H\(_2\)O with HF/cc-pVDZ, we; defined the Psi4 molecule object h2o. Since we’re still in the; Python shell, as long as you executed that block of code, we can reuse; the h2o molecule object in our optimization without redefining it,; by adding the molecule=h2o argument to the psi4.optimize(); API; function:. In [5]:. psi4.set_options({'reference': 'rhf'}); psi4.optimize('scf/cc-pvdz', molecule=h2o). Optimizer: Optimization complete!. Out[5]:. -76.02703272937504. This should perform a series of gradient computations. The gradient; points which way is downhill in energy, and the optimi",MatchSource.WIKI,psi4manual/1.2.1/psiapi-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi-1.html
https://psicode.org/psi4manual/1.2.1/psiapi-1.html:6737,Performance,optimiz,optimizations,6737,"; 0 3; C; H 1 {0}; H 1 {0} 2 {1}; """""".format(R, A); ). psi4.set_options({'reference': 'uhf'}); psi4.energy('scf/6-31g**'). Out[4]:. -38.925334628859886. Executing this cell should yield the final energy as; @DF-UHF Final Energy: -38.92533462887677. Notice the new command, psi4.set_options(); API,; to the input. This function takes a Python; dictionary; as its argument, which is a key-value list which associates a Psi4; keyword; with its user-defined value. For open shell molecules, we have a choice; of unrestricted orbitals (unrestricted Hartree-Fock, or UHF) or; restricted orbitals (restricted open-shell Hartree-Fock, or ROHF).; Usually, UHF is a little easier to converge (although it may be more; susceptible to spin contamination than ROHF). III. Geometry Optimization and Vibrational Frequency Analysis¶; The above examples were simple single-point energy computations (as; specified by the psi4.energy(); API; function). Of course there are other kinds of computations to perform,; such as geometry optimizations and vibrational frequency computations.; These can be specified by replacing psi4.energy(); API; with psi4.optimize(); API; or psi4.frequency(); API,; respectively.; Let’s take a look at an example of optimizing the H\(_2\)O; molecule using Hartree-Fock with a cc-pVDZ basis set.; Now, here comes the real beauty of running Psi4 interactively: above,; when we computed the energy of H\(_2\)O with HF/cc-pVDZ, we; defined the Psi4 molecule object h2o. Since we’re still in the; Python shell, as long as you executed that block of code, we can reuse; the h2o molecule object in our optimization without redefining it,; by adding the molecule=h2o argument to the psi4.optimize(); API; function:. In [5]:. psi4.set_options({'reference': 'rhf'}); psi4.optimize('scf/cc-pvdz', molecule=h2o). Optimizer: Optimization complete!. Out[5]:. -76.02703272937504. This should perform a series of gradient computations. The gradient; points which way is downhill in energy, and the optimi",MatchSource.WIKI,psi4manual/1.2.1/psiapi-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi-1.html
https://psicode.org/psi4manual/1.2.1/psiapi-1.html:6858,Performance,optimiz,optimize,6858,"59886. Executing this cell should yield the final energy as; @DF-UHF Final Energy: -38.92533462887677. Notice the new command, psi4.set_options(); API,; to the input. This function takes a Python; dictionary; as its argument, which is a key-value list which associates a Psi4; keyword; with its user-defined value. For open shell molecules, we have a choice; of unrestricted orbitals (unrestricted Hartree-Fock, or UHF) or; restricted orbitals (restricted open-shell Hartree-Fock, or ROHF).; Usually, UHF is a little easier to converge (although it may be more; susceptible to spin contamination than ROHF). III. Geometry Optimization and Vibrational Frequency Analysis¶; The above examples were simple single-point energy computations (as; specified by the psi4.energy(); API; function). Of course there are other kinds of computations to perform,; such as geometry optimizations and vibrational frequency computations.; These can be specified by replacing psi4.energy(); API; with psi4.optimize(); API; or psi4.frequency(); API,; respectively.; Let’s take a look at an example of optimizing the H\(_2\)O; molecule using Hartree-Fock with a cc-pVDZ basis set.; Now, here comes the real beauty of running Psi4 interactively: above,; when we computed the energy of H\(_2\)O with HF/cc-pVDZ, we; defined the Psi4 molecule object h2o. Since we’re still in the; Python shell, as long as you executed that block of code, we can reuse; the h2o molecule object in our optimization without redefining it,; by adding the molecule=h2o argument to the psi4.optimize(); API; function:. In [5]:. psi4.set_options({'reference': 'rhf'}); psi4.optimize('scf/cc-pvdz', molecule=h2o). Optimizer: Optimization complete!. Out[5]:. -76.02703272937504. This should perform a series of gradient computations. The gradient; points which way is downhill in energy, and the optimizer then modifies; the geometry to follow the gradient. After a few cycles, the geometry; should converge with a message like Optimization complete",MatchSource.WIKI,psi4manual/1.2.1/psiapi-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi-1.html
https://psicode.org/psi4manual/1.2.1/psiapi-1.html:6952,Performance,optimiz,optimizing,6952," Notice the new command, psi4.set_options(); API,; to the input. This function takes a Python; dictionary; as its argument, which is a key-value list which associates a Psi4; keyword; with its user-defined value. For open shell molecules, we have a choice; of unrestricted orbitals (unrestricted Hartree-Fock, or UHF) or; restricted orbitals (restricted open-shell Hartree-Fock, or ROHF).; Usually, UHF is a little easier to converge (although it may be more; susceptible to spin contamination than ROHF). III. Geometry Optimization and Vibrational Frequency Analysis¶; The above examples were simple single-point energy computations (as; specified by the psi4.energy(); API; function). Of course there are other kinds of computations to perform,; such as geometry optimizations and vibrational frequency computations.; These can be specified by replacing psi4.energy(); API; with psi4.optimize(); API; or psi4.frequency(); API,; respectively.; Let’s take a look at an example of optimizing the H\(_2\)O; molecule using Hartree-Fock with a cc-pVDZ basis set.; Now, here comes the real beauty of running Psi4 interactively: above,; when we computed the energy of H\(_2\)O with HF/cc-pVDZ, we; defined the Psi4 molecule object h2o. Since we’re still in the; Python shell, as long as you executed that block of code, we can reuse; the h2o molecule object in our optimization without redefining it,; by adding the molecule=h2o argument to the psi4.optimize(); API; function:. In [5]:. psi4.set_options({'reference': 'rhf'}); psi4.optimize('scf/cc-pvdz', molecule=h2o). Optimizer: Optimization complete!. Out[5]:. -76.02703272937504. This should perform a series of gradient computations. The gradient; points which way is downhill in energy, and the optimizer then modifies; the geometry to follow the gradient. After a few cycles, the geometry; should converge with a message like Optimization complete!. As; indicated in the following table (printed by the optimizer at the end of; the computation and g",MatchSource.WIKI,psi4manual/1.2.1/psiapi-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi-1.html
https://psicode.org/psi4manual/1.2.1/psiapi-1.html:7331,Performance,optimiz,optimization,7331,"itals (restricted open-shell Hartree-Fock, or ROHF).; Usually, UHF is a little easier to converge (although it may be more; susceptible to spin contamination than ROHF). III. Geometry Optimization and Vibrational Frequency Analysis¶; The above examples were simple single-point energy computations (as; specified by the psi4.energy(); API; function). Of course there are other kinds of computations to perform,; such as geometry optimizations and vibrational frequency computations.; These can be specified by replacing psi4.energy(); API; with psi4.optimize(); API; or psi4.frequency(); API,; respectively.; Let’s take a look at an example of optimizing the H\(_2\)O; molecule using Hartree-Fock with a cc-pVDZ basis set.; Now, here comes the real beauty of running Psi4 interactively: above,; when we computed the energy of H\(_2\)O with HF/cc-pVDZ, we; defined the Psi4 molecule object h2o. Since we’re still in the; Python shell, as long as you executed that block of code, we can reuse; the h2o molecule object in our optimization without redefining it,; by adding the molecule=h2o argument to the psi4.optimize(); API; function:. In [5]:. psi4.set_options({'reference': 'rhf'}); psi4.optimize('scf/cc-pvdz', molecule=h2o). Optimizer: Optimization complete!. Out[5]:. -76.02703272937504. This should perform a series of gradient computations. The gradient; points which way is downhill in energy, and the optimizer then modifies; the geometry to follow the gradient. After a few cycles, the geometry; should converge with a message like Optimization complete!. As; indicated in the following table (printed by the optimizer at the end of; the computation and grep-able with ~), the energy decreases with; each step, and the maximum force on each atom also decreases with each; step (in principle, these numbers could increase in some iterations, but; here they do not).; --------------------------------------------------------------------------------------------------------------- ~  Step      ",MatchSource.WIKI,psi4manual/1.2.1/psiapi-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi-1.html
https://psicode.org/psi4manual/1.2.1/psiapi-1.html:7416,Performance,optimiz,optimize,7416,"e; susceptible to spin contamination than ROHF). III. Geometry Optimization and Vibrational Frequency Analysis¶; The above examples were simple single-point energy computations (as; specified by the psi4.energy(); API; function). Of course there are other kinds of computations to perform,; such as geometry optimizations and vibrational frequency computations.; These can be specified by replacing psi4.energy(); API; with psi4.optimize(); API; or psi4.frequency(); API,; respectively.; Let’s take a look at an example of optimizing the H\(_2\)O; molecule using Hartree-Fock with a cc-pVDZ basis set.; Now, here comes the real beauty of running Psi4 interactively: above,; when we computed the energy of H\(_2\)O with HF/cc-pVDZ, we; defined the Psi4 molecule object h2o. Since we’re still in the; Python shell, as long as you executed that block of code, we can reuse; the h2o molecule object in our optimization without redefining it,; by adding the molecule=h2o argument to the psi4.optimize(); API; function:. In [5]:. psi4.set_options({'reference': 'rhf'}); psi4.optimize('scf/cc-pvdz', molecule=h2o). Optimizer: Optimization complete!. Out[5]:. -76.02703272937504. This should perform a series of gradient computations. The gradient; points which way is downhill in energy, and the optimizer then modifies; the geometry to follow the gradient. After a few cycles, the geometry; should converge with a message like Optimization complete!. As; indicated in the following table (printed by the optimizer at the end of; the computation and grep-able with ~), the energy decreases with; each step, and the maximum force on each atom also decreases with each; step (in principle, these numbers could increase in some iterations, but; here they do not).; --------------------------------------------------------------------------------------------------------------- ~  Step         Total Energy             Delta E       MAX Force       RMS Force        MAX Disp        RMS Disp  ~ ------------------",MatchSource.WIKI,psi4manual/1.2.1/psiapi-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi-1.html
https://psicode.org/psi4manual/1.2.1/psiapi-1.html:7498,Performance,optimiz,optimize,7498,"nal Frequency Analysis¶; The above examples were simple single-point energy computations (as; specified by the psi4.energy(); API; function). Of course there are other kinds of computations to perform,; such as geometry optimizations and vibrational frequency computations.; These can be specified by replacing psi4.energy(); API; with psi4.optimize(); API; or psi4.frequency(); API,; respectively.; Let’s take a look at an example of optimizing the H\(_2\)O; molecule using Hartree-Fock with a cc-pVDZ basis set.; Now, here comes the real beauty of running Psi4 interactively: above,; when we computed the energy of H\(_2\)O with HF/cc-pVDZ, we; defined the Psi4 molecule object h2o. Since we’re still in the; Python shell, as long as you executed that block of code, we can reuse; the h2o molecule object in our optimization without redefining it,; by adding the molecule=h2o argument to the psi4.optimize(); API; function:. In [5]:. psi4.set_options({'reference': 'rhf'}); psi4.optimize('scf/cc-pvdz', molecule=h2o). Optimizer: Optimization complete!. Out[5]:. -76.02703272937504. This should perform a series of gradient computations. The gradient; points which way is downhill in energy, and the optimizer then modifies; the geometry to follow the gradient. After a few cycles, the geometry; should converge with a message like Optimization complete!. As; indicated in the following table (printed by the optimizer at the end of; the computation and grep-able with ~), the energy decreases with; each step, and the maximum force on each atom also decreases with each; step (in principle, these numbers could increase in some iterations, but; here they do not).; --------------------------------------------------------------------------------------------------------------- ~  Step         Total Energy             Delta E       MAX Force       RMS Force        MAX Disp        RMS Disp  ~ ---------------------------------------------------------------------------------------------------------",MatchSource.WIKI,psi4manual/1.2.1/psiapi-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi-1.html
https://psicode.org/psi4manual/1.2.1/psiapi-1.html:7613,Performance,perform,perform,7613," psi4.energy(); API; function). Of course there are other kinds of computations to perform,; such as geometry optimizations and vibrational frequency computations.; These can be specified by replacing psi4.energy(); API; with psi4.optimize(); API; or psi4.frequency(); API,; respectively.; Let’s take a look at an example of optimizing the H\(_2\)O; molecule using Hartree-Fock with a cc-pVDZ basis set.; Now, here comes the real beauty of running Psi4 interactively: above,; when we computed the energy of H\(_2\)O with HF/cc-pVDZ, we; defined the Psi4 molecule object h2o. Since we’re still in the; Python shell, as long as you executed that block of code, we can reuse; the h2o molecule object in our optimization without redefining it,; by adding the molecule=h2o argument to the psi4.optimize(); API; function:. In [5]:. psi4.set_options({'reference': 'rhf'}); psi4.optimize('scf/cc-pvdz', molecule=h2o). Optimizer: Optimization complete!. Out[5]:. -76.02703272937504. This should perform a series of gradient computations. The gradient; points which way is downhill in energy, and the optimizer then modifies; the geometry to follow the gradient. After a few cycles, the geometry; should converge with a message like Optimization complete!. As; indicated in the following table (printed by the optimizer at the end of; the computation and grep-able with ~), the energy decreases with; each step, and the maximum force on each atom also decreases with each; step (in principle, these numbers could increase in some iterations, but; here they do not).; --------------------------------------------------------------------------------------------------------------- ~  Step         Total Energy             Delta E       MAX Force       RMS Force        MAX Disp        RMS Disp  ~ --------------------------------------------------------------------------------------------------------------- ~     1     -76.026632734908    -76.026632734908      0.01523518      0.01245755      0.02742222      0.",MatchSource.WIKI,psi4manual/1.2.1/psiapi-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi-1.html
https://psicode.org/psi4manual/1.2.1/psiapi-1.html:7718,Performance,optimiz,optimizer,7718,",; such as geometry optimizations and vibrational frequency computations.; These can be specified by replacing psi4.energy(); API; with psi4.optimize(); API; or psi4.frequency(); API,; respectively.; Let’s take a look at an example of optimizing the H\(_2\)O; molecule using Hartree-Fock with a cc-pVDZ basis set.; Now, here comes the real beauty of running Psi4 interactively: above,; when we computed the energy of H\(_2\)O with HF/cc-pVDZ, we; defined the Psi4 molecule object h2o. Since we’re still in the; Python shell, as long as you executed that block of code, we can reuse; the h2o molecule object in our optimization without redefining it,; by adding the molecule=h2o argument to the psi4.optimize(); API; function:. In [5]:. psi4.set_options({'reference': 'rhf'}); psi4.optimize('scf/cc-pvdz', molecule=h2o). Optimizer: Optimization complete!. Out[5]:. -76.02703272937504. This should perform a series of gradient computations. The gradient; points which way is downhill in energy, and the optimizer then modifies; the geometry to follow the gradient. After a few cycles, the geometry; should converge with a message like Optimization complete!. As; indicated in the following table (printed by the optimizer at the end of; the computation and grep-able with ~), the energy decreases with; each step, and the maximum force on each atom also decreases with each; step (in principle, these numbers could increase in some iterations, but; here they do not).; --------------------------------------------------------------------------------------------------------------- ~  Step         Total Energy             Delta E       MAX Force       RMS Force        MAX Disp        RMS Disp  ~ --------------------------------------------------------------------------------------------------------------- ~     1     -76.026632734908    -76.026632734908      0.01523518      0.01245755      0.02742222      0.02277530  ~     2     -76.027022666011     -0.000389931104      0.00178779      0.0014294",MatchSource.WIKI,psi4manual/1.2.1/psiapi-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi-1.html
https://psicode.org/psi4manual/1.2.1/psiapi-1.html:7927,Performance,optimiz,optimizer,7927,"et.; Now, here comes the real beauty of running Psi4 interactively: above,; when we computed the energy of H\(_2\)O with HF/cc-pVDZ, we; defined the Psi4 molecule object h2o. Since we’re still in the; Python shell, as long as you executed that block of code, we can reuse; the h2o molecule object in our optimization without redefining it,; by adding the molecule=h2o argument to the psi4.optimize(); API; function:. In [5]:. psi4.set_options({'reference': 'rhf'}); psi4.optimize('scf/cc-pvdz', molecule=h2o). Optimizer: Optimization complete!. Out[5]:. -76.02703272937504. This should perform a series of gradient computations. The gradient; points which way is downhill in energy, and the optimizer then modifies; the geometry to follow the gradient. After a few cycles, the geometry; should converge with a message like Optimization complete!. As; indicated in the following table (printed by the optimizer at the end of; the computation and grep-able with ~), the energy decreases with; each step, and the maximum force on each atom also decreases with each; step (in principle, these numbers could increase in some iterations, but; here they do not).; --------------------------------------------------------------------------------------------------------------- ~  Step         Total Energy             Delta E       MAX Force       RMS Force        MAX Disp        RMS Disp  ~ --------------------------------------------------------------------------------------------------------------- ~     1     -76.026632734908    -76.026632734908      0.01523518      0.01245755      0.02742222      0.02277530  ~     2     -76.027022666011     -0.000389931104      0.00178779      0.00142946      0.01008137      0.00594928  ~     3     -76.027032729374     -0.000010063363      0.00014019      0.00008488      0.00077463      0.00044738  ~ --------------------------------------------------------------------------------------------------------------- ~; To get harmonic vibrational frequencies, it’s",MatchSource.WIKI,psi4manual/1.2.1/psiapi-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi-1.html
https://psicode.org/psi4manual/1.2.1/psiapi-1.html:9279,Performance,optimiz,optimized,9279,"--------------- ~  Step         Total Energy             Delta E       MAX Force       RMS Force        MAX Disp        RMS Disp  ~ --------------------------------------------------------------------------------------------------------------- ~     1     -76.026632734908    -76.026632734908      0.01523518      0.01245755      0.02742222      0.02277530  ~     2     -76.027022666011     -0.000389931104      0.00178779      0.00142946      0.01008137      0.00594928  ~     3     -76.027032729374     -0.000010063363      0.00014019      0.00008488      0.00077463      0.00044738  ~ --------------------------------------------------------------------------------------------------------------- ~; To get harmonic vibrational frequencies, it’s important to keep in mind; that the values of the vibrational frequencies are a function of the; molecular geometry. Therefore, it’s important to obtain the vibrational; frequencies AT THE OPTIMIZED GEOMETRY. Luckily, Psi4 updates the; molecule with optimized geometry as it is being optimized. So, the; optimized geometry for H\(_2\)O is stored inside the h2o; molecule object, which we can access! To compute the frequencies, all we; need to do is to again pass the molecule=h2o argument to the; psi4.frequency(); API; function:. In [6]:. scf_e, scf_wfn = psi4.frequency('scf/cc-pvdz', molecule=h2o, return_wfn=True, dertype=1). 6 displacements needed.; 1 2 3 4 5 6. Executing this cell will prompt Psi4 to compute the Hessian (second; derivative matrix) of the electronic energy with respect to nuclear; displacements. From this, it can obtain the harmonic vibrational; frequencies, given below (roundoff errors of around \(0.1\); cm\(^{-1}\) may exist):; Irrep Harmonic Frequency; (cm-1); -----------------------------------------------; A1 1775.6478; A1 4113.3795; B2 4212.1814; -----------------------------------------------. Notice the symmetry type of the normal modes is specified (A1, A1, B2).; The program also print out the normal modes i",MatchSource.WIKI,psi4manual/1.2.1/psiapi-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi-1.html
https://psicode.org/psi4manual/1.2.1/psiapi-1.html:9313,Performance,optimiz,optimized,9313,"--------------- ~  Step         Total Energy             Delta E       MAX Force       RMS Force        MAX Disp        RMS Disp  ~ --------------------------------------------------------------------------------------------------------------- ~     1     -76.026632734908    -76.026632734908      0.01523518      0.01245755      0.02742222      0.02277530  ~     2     -76.027022666011     -0.000389931104      0.00178779      0.00142946      0.01008137      0.00594928  ~     3     -76.027032729374     -0.000010063363      0.00014019      0.00008488      0.00077463      0.00044738  ~ --------------------------------------------------------------------------------------------------------------- ~; To get harmonic vibrational frequencies, it’s important to keep in mind; that the values of the vibrational frequencies are a function of the; molecular geometry. Therefore, it’s important to obtain the vibrational; frequencies AT THE OPTIMIZED GEOMETRY. Luckily, Psi4 updates the; molecule with optimized geometry as it is being optimized. So, the; optimized geometry for H\(_2\)O is stored inside the h2o; molecule object, which we can access! To compute the frequencies, all we; need to do is to again pass the molecule=h2o argument to the; psi4.frequency(); API; function:. In [6]:. scf_e, scf_wfn = psi4.frequency('scf/cc-pvdz', molecule=h2o, return_wfn=True, dertype=1). 6 displacements needed.; 1 2 3 4 5 6. Executing this cell will prompt Psi4 to compute the Hessian (second; derivative matrix) of the electronic energy with respect to nuclear; displacements. From this, it can obtain the harmonic vibrational; frequencies, given below (roundoff errors of around \(0.1\); cm\(^{-1}\) may exist):; Irrep Harmonic Frequency; (cm-1); -----------------------------------------------; A1 1775.6478; A1 4113.3795; B2 4212.1814; -----------------------------------------------. Notice the symmetry type of the normal modes is specified (A1, A1, B2).; The program also print out the normal modes i",MatchSource.WIKI,psi4manual/1.2.1/psiapi-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi-1.html
https://psicode.org/psi4manual/1.2.1/psiapi-1.html:9333,Performance,optimiz,optimized,9333,"------------------------------------------------------------------------------------------------ ~     1     -76.026632734908    -76.026632734908      0.01523518      0.01245755      0.02742222      0.02277530  ~     2     -76.027022666011     -0.000389931104      0.00178779      0.00142946      0.01008137      0.00594928  ~     3     -76.027032729374     -0.000010063363      0.00014019      0.00008488      0.00077463      0.00044738  ~ --------------------------------------------------------------------------------------------------------------- ~; To get harmonic vibrational frequencies, it’s important to keep in mind; that the values of the vibrational frequencies are a function of the; molecular geometry. Therefore, it’s important to obtain the vibrational; frequencies AT THE OPTIMIZED GEOMETRY. Luckily, Psi4 updates the; molecule with optimized geometry as it is being optimized. So, the; optimized geometry for H\(_2\)O is stored inside the h2o; molecule object, which we can access! To compute the frequencies, all we; need to do is to again pass the molecule=h2o argument to the; psi4.frequency(); API; function:. In [6]:. scf_e, scf_wfn = psi4.frequency('scf/cc-pvdz', molecule=h2o, return_wfn=True, dertype=1). 6 displacements needed.; 1 2 3 4 5 6. Executing this cell will prompt Psi4 to compute the Hessian (second; derivative matrix) of the electronic energy with respect to nuclear; displacements. From this, it can obtain the harmonic vibrational; frequencies, given below (roundoff errors of around \(0.1\); cm\(^{-1}\) may exist):; Irrep Harmonic Frequency; (cm-1); -----------------------------------------------; A1 1775.6478; A1 4113.3795; B2 4212.1814; -----------------------------------------------. Notice the symmetry type of the normal modes is specified (A1, A1, B2).; The program also print out the normal modes in terms of Cartesian; coordinates of each atom. For example, the normal mode at \(1776\); cm\(^{-1}\) is:; Frequency: 1775.65; Force constant: 0.119",MatchSource.WIKI,psi4manual/1.2.1/psiapi-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi-1.html
https://psicode.org/psi4manual/1.2.1/psiapi-1.html:10853,Performance,perform,performed,10853,"to nuclear; displacements. From this, it can obtain the harmonic vibrational; frequencies, given below (roundoff errors of around \(0.1\); cm\(^{-1}\) may exist):; Irrep Harmonic Frequency; (cm-1); -----------------------------------------------; A1 1775.6478; A1 4113.3795; B2 4212.1814; -----------------------------------------------. Notice the symmetry type of the normal modes is specified (A1, A1, B2).; The program also print out the normal modes in terms of Cartesian; coordinates of each atom. For example, the normal mode at \(1776\); cm\(^{-1}\) is:; Frequency: 1775.65; Force constant: 0.1193; X Y Z mass; O 0.000 0.000 -0.068 15.994915; H 0.000 0.416 0.536 1.007825; H 0.000 -0.416 0.536 1.007825. where the table shows the displacements in the X, Y, and Z dimensions; for each atom along the normal mode coordinate. (This information could; be used to animate the vibrational frequency using visualization; software.); Because the vibrational frequencies are available, a thermodynamics; analysis is automatically performed at the end of the computation. You; can see this in the next section of the output file output.dat. The; vibrational frequencies are sufficient to obtain vibrational; contributions to enthalpy (H), entropy (S), and Gibbs free energy (G).; Similarly, the molecular geometry is used to obtain rotational; constants, which are then used to obtain rotational contributions to H,; S, and G.; Note: Psi4 has several synonyms for the functions called in this; example. For instance, psi4.frequency(); API; will compute molecular vibrational frequencies, and psi4.optimize(); API; will perform a geometry optimization. IV. Analysis of Intermolecular Interactions¶; Now let’s consider something a little more interesting. Psi4 contains; code to analyze the nature of intermolecular interactions between two; molecules, via symmetry-adapted perturbation theory (SAPT); (Jeziorski:1994:1887).; This kind of analysis gives a lot of insight into the nature of; intermolecula",MatchSource.WIKI,psi4manual/1.2.1/psiapi-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi-1.html
https://psicode.org/psi4manual/1.2.1/psiapi-1.html:11419,Performance,optimiz,optimize,11419,".000 0.000 -0.068 15.994915; H 0.000 0.416 0.536 1.007825; H 0.000 -0.416 0.536 1.007825. where the table shows the displacements in the X, Y, and Z dimensions; for each atom along the normal mode coordinate. (This information could; be used to animate the vibrational frequency using visualization; software.); Because the vibrational frequencies are available, a thermodynamics; analysis is automatically performed at the end of the computation. You; can see this in the next section of the output file output.dat. The; vibrational frequencies are sufficient to obtain vibrational; contributions to enthalpy (H), entropy (S), and Gibbs free energy (G).; Similarly, the molecular geometry is used to obtain rotational; constants, which are then used to obtain rotational contributions to H,; S, and G.; Note: Psi4 has several synonyms for the functions called in this; example. For instance, psi4.frequency(); API; will compute molecular vibrational frequencies, and psi4.optimize(); API; will perform a geometry optimization. IV. Analysis of Intermolecular Interactions¶; Now let’s consider something a little more interesting. Psi4 contains; code to analyze the nature of intermolecular interactions between two; molecules, via symmetry-adapted perturbation theory (SAPT); (Jeziorski:1994:1887).; This kind of analysis gives a lot of insight into the nature of; intermolecular interactions, and Psi4 makes these computations easier; than ever.; For a SAPT computation, the input needs to provide information on two; distinct molecules. This is very easy, we just give a Z-matrix or set of; Cartesian coordinates for each molecule, and separate the two with two; dashes, like this:. In [7]:. # Example SAPT computation for ethene*ethyne (*i.e.*, ethylene*acetylene).; # Test case 16 from S22 Database. dimer = psi4.geometry(""""""; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.",MatchSource.WIKI,psi4manual/1.2.1/psiapi-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi-1.html
https://psicode.org/psi4manual/1.2.1/psiapi-1.html:11441,Performance,perform,perform,11441,".000 0.000 -0.068 15.994915; H 0.000 0.416 0.536 1.007825; H 0.000 -0.416 0.536 1.007825. where the table shows the displacements in the X, Y, and Z dimensions; for each atom along the normal mode coordinate. (This information could; be used to animate the vibrational frequency using visualization; software.); Because the vibrational frequencies are available, a thermodynamics; analysis is automatically performed at the end of the computation. You; can see this in the next section of the output file output.dat. The; vibrational frequencies are sufficient to obtain vibrational; contributions to enthalpy (H), entropy (S), and Gibbs free energy (G).; Similarly, the molecular geometry is used to obtain rotational; constants, which are then used to obtain rotational contributions to H,; S, and G.; Note: Psi4 has several synonyms for the functions called in this; example. For instance, psi4.frequency(); API; will compute molecular vibrational frequencies, and psi4.optimize(); API; will perform a geometry optimization. IV. Analysis of Intermolecular Interactions¶; Now let’s consider something a little more interesting. Psi4 contains; code to analyze the nature of intermolecular interactions between two; molecules, via symmetry-adapted perturbation theory (SAPT); (Jeziorski:1994:1887).; This kind of analysis gives a lot of insight into the nature of; intermolecular interactions, and Psi4 makes these computations easier; than ever.; For a SAPT computation, the input needs to provide information on two; distinct molecules. This is very easy, we just give a Z-matrix or set of; Cartesian coordinates for each molecule, and separate the two with two; dashes, like this:. In [7]:. # Example SAPT computation for ethene*ethyne (*i.e.*, ethylene*acetylene).; # Test case 16 from S22 Database. dimer = psi4.geometry(""""""; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.",MatchSource.WIKI,psi4manual/1.2.1/psiapi-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi-1.html
https://psicode.org/psi4manual/1.2.1/psiapi-1.html:11460,Performance,optimiz,optimization,11460,".000 0.000 -0.068 15.994915; H 0.000 0.416 0.536 1.007825; H 0.000 -0.416 0.536 1.007825. where the table shows the displacements in the X, Y, and Z dimensions; for each atom along the normal mode coordinate. (This information could; be used to animate the vibrational frequency using visualization; software.); Because the vibrational frequencies are available, a thermodynamics; analysis is automatically performed at the end of the computation. You; can see this in the next section of the output file output.dat. The; vibrational frequencies are sufficient to obtain vibrational; contributions to enthalpy (H), entropy (S), and Gibbs free energy (G).; Similarly, the molecular geometry is used to obtain rotational; constants, which are then used to obtain rotational contributions to H,; S, and G.; Note: Psi4 has several synonyms for the functions called in this; example. For instance, psi4.frequency(); API; will compute molecular vibrational frequencies, and psi4.optimize(); API; will perform a geometry optimization. IV. Analysis of Intermolecular Interactions¶; Now let’s consider something a little more interesting. Psi4 contains; code to analyze the nature of intermolecular interactions between two; molecules, via symmetry-adapted perturbation theory (SAPT); (Jeziorski:1994:1887).; This kind of analysis gives a lot of insight into the nature of; intermolecular interactions, and Psi4 makes these computations easier; than ever.; For a SAPT computation, the input needs to provide information on two; distinct molecules. This is very easy, we just give a Z-matrix or set of; Cartesian coordinates for each molecule, and separate the two with two; dashes, like this:. In [7]:. # Example SAPT computation for ethene*ethyne (*i.e.*, ethylene*acetylene).; # Test case 16 from S22 Database. dimer = psi4.geometry(""""""; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.",MatchSource.WIKI,psi4manual/1.2.1/psiapi-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi-1.html
https://psicode.org/psi4manual/1.2.1/psiapi-1.html:13508,Performance,optimiz,optimize,13508,"000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; units angstrom; """"""). Here’s the second half of the input, where we specify the computation; options:. In [8]:. psi4.set_options({'scf_type': 'df',; 'freeze_core': 'true'}). psi4.energy('sapt0/jun-cc-pvdz', molecule=dimer). Out[8]:. -0.0022355825227244703. All of the options we have currently set using psi4.set_options(); API; are “global” options (meaning that they are visible to all parts of the; program). Most common Psi4 options can be set like this. If an option; needs to be visible only to one part of the program (e.g., we only; want to increase the energy convergence in the SCF code, but not the; rest of the code), it can be set by with the; psi4.set_module_options(); API; function, psi4.set_module_options('scf', {'e_convergence': '1e-8'}).; Note: The arguments to the functions we’ve used so far, like; psi4.set_options(); API,; psi4.set_module_options(); API,; psi4.energy(); API,; psi4.optimize(); API,; psi4.frequency(); API,; etc., are case-insensitive.; Back to our SAPT example, we have found that for basic-level SAPT; computations (i.e., SAPT0), a good error cancellation is found; (Hohenstein:2012:WIREs); with the jun-cc-pVDZ basis (this is the usual aug-cc-pVDZ basis, but; without diffuse functions on hydrogen and without diffuse \(d\); functions on heavy atoms); (Papajak:2011:10).; So, we’ll use that as our standard basis set. The SAPT code is designed; to use density fitting techniques, because they introduce minimal errors; while providing much faster computations; (Hohenstein:2010:184111,Hohenstein:2010:014101).; Since we’re using density fitting for the SAPT, we might as well also; use it for the Hartree-Fock computations that are performed as part of; the SAPT. We can specify that by adding 'scf_type': 'df' to the; dictionary passed to psi4.set_options().; Density fitting procedures require the use of auxiliary basis sets that; pair with the primary basis set. Fortunat",MatchSource.WIKI,psi4manual/1.2.1/psiapi-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi-1.html
https://psicode.org/psi4manual/1.2.1/psiapi-1.html:14277,Performance,perform,performed,14277," it can be set by with the; psi4.set_module_options(); API; function, psi4.set_module_options('scf', {'e_convergence': '1e-8'}).; Note: The arguments to the functions we’ve used so far, like; psi4.set_options(); API,; psi4.set_module_options(); API,; psi4.energy(); API,; psi4.optimize(); API,; psi4.frequency(); API,; etc., are case-insensitive.; Back to our SAPT example, we have found that for basic-level SAPT; computations (i.e., SAPT0), a good error cancellation is found; (Hohenstein:2012:WIREs); with the jun-cc-pVDZ basis (this is the usual aug-cc-pVDZ basis, but; without diffuse functions on hydrogen and without diffuse \(d\); functions on heavy atoms); (Papajak:2011:10).; So, we’ll use that as our standard basis set. The SAPT code is designed; to use density fitting techniques, because they introduce minimal errors; while providing much faster computations; (Hohenstein:2010:184111,Hohenstein:2010:014101).; Since we’re using density fitting for the SAPT, we might as well also; use it for the Hartree-Fock computations that are performed as part of; the SAPT. We can specify that by adding 'scf_type': 'df' to the; dictionary passed to psi4.set_options().; Density fitting procedures require the use of auxiliary basis sets that; pair with the primary basis set. Fortunately, Psi4 is usually smart; enough to figure out what auxiliary basis sets are needed for a given; computation. In this case, jun-cc-pVDZ is a standard enough basis set; (just a simple truncation of the very popular aug-cc-pVDZ basis set); that Psi4 correctly guesses that we want the jun-cc-pVDZ-JKFIT auxiliary; basis for the Hartree-Fock, and the jun-cc-pVDZ-RI basis set for the; SAPT procedure.; To speed up the computation a little, we also tell the SAPT procedure to; freeze the core electrons by adding 'freeze_core': 'true' to the; dictionary passed to psi4.set_options(). The SAPT procedure is; invoked by psi4.energy('sapt0/jun-cc-pvdz', molecule=dimer). Here,; Psi4 knows to automatically run two mo",MatchSource.WIKI,psi4manual/1.2.1/psiapi-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi-1.html
https://psicode.org/psi4manual/1.2.1/psiapi-1.html:15305,Performance,perform,perform,15305,"putations that are performed as part of; the SAPT. We can specify that by adding 'scf_type': 'df' to the; dictionary passed to psi4.set_options().; Density fitting procedures require the use of auxiliary basis sets that; pair with the primary basis set. Fortunately, Psi4 is usually smart; enough to figure out what auxiliary basis sets are needed for a given; computation. In this case, jun-cc-pVDZ is a standard enough basis set; (just a simple truncation of the very popular aug-cc-pVDZ basis set); that Psi4 correctly guesses that we want the jun-cc-pVDZ-JKFIT auxiliary; basis for the Hartree-Fock, and the jun-cc-pVDZ-RI basis set for the; SAPT procedure.; To speed up the computation a little, we also tell the SAPT procedure to; freeze the core electrons by adding 'freeze_core': 'true' to the; dictionary passed to psi4.set_options(). The SAPT procedure is; invoked by psi4.energy('sapt0/jun-cc-pvdz', molecule=dimer). Here,; Psi4 knows to automatically run two monomer computations and a dimer; computation and then use these results to perform the SAPT analysis. The; various energy components are printed at the end of the output, in; addition to the total SAPT0 interaction energy. An explanation of the; various energy components can be found in the review by Jeziorski,; Moszynski, and Szalewicz; (Jeziorski:1994:1887),; and this is discussed in more detail in the SAPT; section of the Psi4; manual.; For now, we’ll note that most of the SAPT energy components are; negative; this means those are attractive contributions (the zero of; energy in a SAPT computation is defined as non-interacting monomers).; The exchange contributions are positive (repulsive). In this example,; the most attractive contribution between ethylene and acetylene is an; electrostatic term of \(-2.12\) kcal/mol (Elst10,r where the 1; indicates the first-order perturbation theory result with respect to the; intermolecular interaction, and the 0 indicates zeroth-order with; respect to the intramolecular e",MatchSource.WIKI,psi4manual/1.2.1/psiapi-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi-1.html
https://psicode.org/psi4manual/1.2.1/psiapi-1.html:18250,Performance,perform,perform,18250,"ng about the interaction between the two monomers. V. Potential Surface Scans and Counterpoise Correction Made Easy¶; Finally, let’s consider an example which highlights the advantages of; being able to interact with Psi4 directly with Python.; Suppose you want to do a limited potential energy surface scan, such as; computing the interaction energy between two neon atoms at various; interatomic distances. One simple but unappealing way to do this is to; generate separate geometries for each distance to be studied. Instead,; we can leverage Python loops and string formatting to make our lives; simpler. Additionally, let’s suppose you want to do counterpoise (CP); correction to compute interaction energies. Counterpoise correction; involves computing the dimer energy and then subtracting out the; energies of the two monomers, each evaluated in the dimer basis. Again,; each of these computations could be run in a separate input file, but; because counterpoise correction is a fairly standard procedure for; intermolecular interactions, Psi4 knows about it and has a built-in; routine to perform counterpoise correction. It only needs to know what; method you want to do the couterpoise correction on (here, let’s; consider CCSD(T)), and it needs to know what’s monomer A and what’s; monomer B. This last issue of specifying the monomers separately was; already dealt with in the previous SAPT example, where we saw that two; dashes in the psi4.geometry() string can be used to separate; monomers.; So, we’re going to do counterpoise-corrected CCSD(T) energies for; Ne\(_2\) at a series of different interatomic distances. And let’s; print out a table of the interatomic distances we’ve considered, and the; CP-corrected CCSD(T) interaction energies (in kcal/mol) at each; geometry:. In [9]:. #! Example potential energy surface scan and CP-correction for Ne2. ne2_geometry = """"""; Ne; --; Ne 1 {0}; """""". Rvals = [2.5, 3.0, 4.0]. psi4.set_options({'freeze_core': 'true'}). # Initialize a bla",MatchSource.WIKI,psi4manual/1.2.1/psiapi-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi-1.html
https://psicode.org/psi4manual/1.2.1/psiapi-1.html:21179,Performance,perform,perform,21179,"ee the geometry string ne2_geometry has a two dashes; to separate the monomers from each other. Also note we’ve used a; Z-matrix to specify the geometry, and we’ve used a variable (R) as; the interatomic distance. We have not specified the value of R in; the ne2_geometry string like we normally would. That’s because we; are going to vary it during the scan across the potential energy; surface, by using a Python loop over the list of interatomic distances; Rvals. Before we are able to pass our molecule to Psi4, we need to; do two things. First, we must set the value of the intermolecular; separation in our Z-matrix (by using Python 3 string; formatting); to the particular value of R. Second, we need to turn the Z-matrix; string into a Psi4 molecule, by passing it to; `psi4.geometry() <http://psicode.org/psi4manual/master/api/psi4.driver.geometry.html#psi4.driver.geometry>`__.; The argument bsse_type='cp' tells Psi4 to perform counterpoise (CP); correction on the dimer to compute the CCSD(T)/aug-cc-pVDZ interaction; energy, which is stored in our ecp dictionary at each iteration of; our Python loop. Note that we didn’t need to specify ghost atoms, and we; didn’t need to call the monomer and dimer computations separately. Psi4; does it all for us, automatically.; Near the very end of the output file output.dat, the counterpoise; correction Python function will print a nice summary of the results of; the counterpoise computation (the energies of the dimer, of monomer 1; with the ghost functions of monomer 2, of monomer 2 with the ghost; functions of monomer 1, and the overall counterpoise corrected; interaction energy):; N-Body: Computing complex (1/2) with fragments (2,) in the basis of fragments (1, 2).; ...; N-Body: Complex Energy (fragments = (2,), basis = (1, 2): -128.70932405488924); ...; N-Body: Computing complex (2/2) with fragments (1,) in the basis of fragments (1, 2).; ...; N-Body: Complex Energy (fragments = (1,), basis = (1, 2): -128.70932405488935); ...; N-",MatchSource.WIKI,psi4manual/1.2.1/psiapi-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi-1.html
https://psicode.org/psi4manual/1.2.1/psiapi-1.html:9421,Security,access,access,9421,"------------------------------------------------------------------------------------------------ ~     1     -76.026632734908    -76.026632734908      0.01523518      0.01245755      0.02742222      0.02277530  ~     2     -76.027022666011     -0.000389931104      0.00178779      0.00142946      0.01008137      0.00594928  ~     3     -76.027032729374     -0.000010063363      0.00014019      0.00008488      0.00077463      0.00044738  ~ --------------------------------------------------------------------------------------------------------------- ~; To get harmonic vibrational frequencies, it’s important to keep in mind; that the values of the vibrational frequencies are a function of the; molecular geometry. Therefore, it’s important to obtain the vibrational; frequencies AT THE OPTIMIZED GEOMETRY. Luckily, Psi4 updates the; molecule with optimized geometry as it is being optimized. So, the; optimized geometry for H\(_2\)O is stored inside the h2o; molecule object, which we can access! To compute the frequencies, all we; need to do is to again pass the molecule=h2o argument to the; psi4.frequency(); API; function:. In [6]:. scf_e, scf_wfn = psi4.frequency('scf/cc-pvdz', molecule=h2o, return_wfn=True, dertype=1). 6 displacements needed.; 1 2 3 4 5 6. Executing this cell will prompt Psi4 to compute the Hessian (second; derivative matrix) of the electronic energy with respect to nuclear; displacements. From this, it can obtain the harmonic vibrational; frequencies, given below (roundoff errors of around \(0.1\); cm\(^{-1}\) may exist):; Irrep Harmonic Frequency; (cm-1); -----------------------------------------------; A1 1775.6478; A1 4113.3795; B2 4212.1814; -----------------------------------------------. Notice the symmetry type of the normal modes is specified (A1, A1, B2).; The program also print out the normal modes in terms of Cartesian; coordinates of each atom. For example, the normal mode at \(1776\); cm\(^{-1}\) is:; Frequency: 1775.65; Force constant: 0.119",MatchSource.WIKI,psi4manual/1.2.1/psiapi-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi-1.html
https://psicode.org/psi4manual/1.2.1/psiapi-1.html:4297,Usability,simpl,simple,4297,"e the Hartree-Fock SCF; energy with the cc-pVDZ basis set by passing the method/basis set as a; string ('scf/cc-pvdz') into the function psi4.energy(); API:. In [3]:. #! Sample HF/cc-pVDZ H2O Computation. psi4.set_memory('500 MB'). h2o = psi4.geometry(""""""; O; H 1 0.96; H 1 0.96 2 104.5; """"""). psi4.energy('scf/cc-pvdz'). Out[3]:. -76.02663273488399. If everything goes well, the computation should complete and should; report a final restricted Hartree-Fock energy in the output file; output.dat in a section like this:; Energy converged. @DF-RHF Final Energy: -76.02663273486682. By default, the energy should be converged to about; \(1.0\times 10^{-6}\), so agreement is only expected for about the; first 6 digits after the decimal. If the computation does not complete,; there is probably a problem with the compilation or installation of the; program (see the installation instructions in the main Psi4 manual; section Compiling and Installing from; Source).; This very simple input is sufficient to run the requested information.; Notice we didn’t tell the program some otherwise useful information like; the charge of the molecule (0, it’s neutral), the spin multiplicity (1; for a closed-shell molecule with all electrons paired), or the reference; wavefunction to use (restricted Hartree-Fock, or RHF, is usually; appropriate for a closed-shell molecule). The program correctly guessed; all of these options for us. We can change the default behavior through; additional keywords.; Let’s consider what we would do for an open-shell molecule, where not; all the electrons are paired. For example, let’s run a computation on; methylene (\(\text{CH}_2\)), whose ground electronic state has two; unpaired electrons (triplet electronic state, or a spin multiplicity; \(2S + 1 = 3\)). In this case, the default spin multiplicity (1) is; not correct, so we need to tell the program the true value (3). Like; many programs, Psi4 can get the charge and multiplicity as the first two; integers in the",MatchSource.WIKI,psi4manual/1.2.1/psiapi-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi-1.html
https://psicode.org/psi4manual/1.2.1/psiapi-1.html:6566,Usability,simpl,simple,6566,"rted into the geometry; specification using Python 3 string; formatting. In [4]:. #! Sample UHF/6-31G** CH2 Computation. R = 1.075; A = 133.93. ch2 = psi4.geometry(""""""; 0 3; C; H 1 {0}; H 1 {0} 2 {1}; """""".format(R, A); ). psi4.set_options({'reference': 'uhf'}); psi4.energy('scf/6-31g**'). Out[4]:. -38.925334628859886. Executing this cell should yield the final energy as; @DF-UHF Final Energy: -38.92533462887677. Notice the new command, psi4.set_options(); API,; to the input. This function takes a Python; dictionary; as its argument, which is a key-value list which associates a Psi4; keyword; with its user-defined value. For open shell molecules, we have a choice; of unrestricted orbitals (unrestricted Hartree-Fock, or UHF) or; restricted orbitals (restricted open-shell Hartree-Fock, or ROHF).; Usually, UHF is a little easier to converge (although it may be more; susceptible to spin contamination than ROHF). III. Geometry Optimization and Vibrational Frequency Analysis¶; The above examples were simple single-point energy computations (as; specified by the psi4.energy(); API; function). Of course there are other kinds of computations to perform,; such as geometry optimizations and vibrational frequency computations.; These can be specified by replacing psi4.energy(); API; with psi4.optimize(); API; or psi4.frequency(); API,; respectively.; Let’s take a look at an example of optimizing the H\(_2\)O; molecule using Hartree-Fock with a cc-pVDZ basis set.; Now, here comes the real beauty of running Psi4 interactively: above,; when we computed the energy of H\(_2\)O with HF/cc-pVDZ, we; defined the Psi4 molecule object h2o. Since we’re still in the; Python shell, as long as you executed that block of code, we can reuse; the h2o molecule object in our optimization without redefining it,; by adding the molecule=h2o argument to the psi4.optimize(); API; function:. In [5]:. psi4.set_options({'reference': 'rhf'}); psi4.optimize('scf/cc-pvdz', molecule=h2o). Optimizer: Optimizati",MatchSource.WIKI,psi4manual/1.2.1/psiapi-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi-1.html
https://psicode.org/psi4manual/1.2.1/psiapi-1.html:14698,Usability,simpl,simple,14698,"usual aug-cc-pVDZ basis, but; without diffuse functions on hydrogen and without diffuse \(d\); functions on heavy atoms); (Papajak:2011:10).; So, we’ll use that as our standard basis set. The SAPT code is designed; to use density fitting techniques, because they introduce minimal errors; while providing much faster computations; (Hohenstein:2010:184111,Hohenstein:2010:014101).; Since we’re using density fitting for the SAPT, we might as well also; use it for the Hartree-Fock computations that are performed as part of; the SAPT. We can specify that by adding 'scf_type': 'df' to the; dictionary passed to psi4.set_options().; Density fitting procedures require the use of auxiliary basis sets that; pair with the primary basis set. Fortunately, Psi4 is usually smart; enough to figure out what auxiliary basis sets are needed for a given; computation. In this case, jun-cc-pVDZ is a standard enough basis set; (just a simple truncation of the very popular aug-cc-pVDZ basis set); that Psi4 correctly guesses that we want the jun-cc-pVDZ-JKFIT auxiliary; basis for the Hartree-Fock, and the jun-cc-pVDZ-RI basis set for the; SAPT procedure.; To speed up the computation a little, we also tell the SAPT procedure to; freeze the core electrons by adding 'freeze_core': 'true' to the; dictionary passed to psi4.set_options(). The SAPT procedure is; invoked by psi4.energy('sapt0/jun-cc-pvdz', molecule=dimer). Here,; Psi4 knows to automatically run two monomer computations and a dimer; computation and then use these results to perform the SAPT analysis. The; various energy components are printed at the end of the output, in; addition to the total SAPT0 interaction energy. An explanation of the; various energy components can be found in the review by Jeziorski,; Moszynski, and Szalewicz; (Jeziorski:1994:1887),; and this is discussed in more detail in the SAPT; section of the Psi4; manual.; For now, we’ll note that most of the SAPT energy components are; negative; this means those are attra",MatchSource.WIKI,psi4manual/1.2.1/psiapi-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi-1.html
https://psicode.org/psi4manual/1.2.1/psiapi-1.html:17565,Usability,simpl,simple,17565,"ample has the acetylene; perpendicular to the ethylene, with the acetylene hydrogen pointing; directly at the double bond in ethylene; this will be attractive because; the H atoms in acetylene bear a partial positive charge, while the; electron rich double bond in ethylene bears a partial negative charge.; At the same time, the dispersion interaction should be smaller because; the perpendicular geometry does not allow much overlap between the; monomers. Hence, the SAPT analysis helps clarify (and quantify) our; physical understanding about the interaction between the two monomers. V. Potential Surface Scans and Counterpoise Correction Made Easy¶; Finally, let’s consider an example which highlights the advantages of; being able to interact with Psi4 directly with Python.; Suppose you want to do a limited potential energy surface scan, such as; computing the interaction energy between two neon atoms at various; interatomic distances. One simple but unappealing way to do this is to; generate separate geometries for each distance to be studied. Instead,; we can leverage Python loops and string formatting to make our lives; simpler. Additionally, let’s suppose you want to do counterpoise (CP); correction to compute interaction energies. Counterpoise correction; involves computing the dimer energy and then subtracting out the; energies of the two monomers, each evaluated in the dimer basis. Again,; each of these computations could be run in a separate input file, but; because counterpoise correction is a fairly standard procedure for; intermolecular interactions, Psi4 knows about it and has a built-in; routine to perform counterpoise correction. It only needs to know what; method you want to do the couterpoise correction on (here, let’s; consider CCSD(T)), and it needs to know what’s monomer A and what’s; monomer B. This last issue of specifying the monomers separately was; already dealt with in the previous SAPT example, where we saw that two; dashes in the psi4.geometry(",MatchSource.WIKI,psi4manual/1.2.1/psiapi-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi-1.html
https://psicode.org/psi4manual/1.2.1/psiapi-1.html:17752,Usability,simpl,simpler,17752,"ly at the double bond in ethylene; this will be attractive because; the H atoms in acetylene bear a partial positive charge, while the; electron rich double bond in ethylene bears a partial negative charge.; At the same time, the dispersion interaction should be smaller because; the perpendicular geometry does not allow much overlap between the; monomers. Hence, the SAPT analysis helps clarify (and quantify) our; physical understanding about the interaction between the two monomers. V. Potential Surface Scans and Counterpoise Correction Made Easy¶; Finally, let’s consider an example which highlights the advantages of; being able to interact with Psi4 directly with Python.; Suppose you want to do a limited potential energy surface scan, such as; computing the interaction energy between two neon atoms at various; interatomic distances. One simple but unappealing way to do this is to; generate separate geometries for each distance to be studied. Instead,; we can leverage Python loops and string formatting to make our lives; simpler. Additionally, let’s suppose you want to do counterpoise (CP); correction to compute interaction energies. Counterpoise correction; involves computing the dimer energy and then subtracting out the; energies of the two monomers, each evaluated in the dimer basis. Again,; each of these computations could be run in a separate input file, but; because counterpoise correction is a fairly standard procedure for; intermolecular interactions, Psi4 knows about it and has a built-in; routine to perform counterpoise correction. It only needs to know what; method you want to do the couterpoise correction on (here, let’s; consider CCSD(T)), and it needs to know what’s monomer A and what’s; monomer B. This last issue of specifying the monomers separately was; already dealt with in the previous SAPT example, where we saw that two; dashes in the psi4.geometry() string can be used to separate; monomers.; So, we’re going to do counterpoise-corrected CCSD(T) en",MatchSource.WIKI,psi4manual/1.2.1/psiapi-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi-1.html
https://psicode.org/psi4manual/1.2.1/psiapi.html:2863,Availability,avail,available,2863,"is selected. I. Basic Input Structure¶; Psi4 is now a Python module; so, we need to import it into our Python; environment:. In [1]:. try:; import os, sys; sys.path.insert(1, os.path.abspath('/scratch/psilocaluser/conda-builds/psi4-docs-multiout_1532505956776/work/build/stage//opt/anaconda1anaconda2anaconda3/lib/python3.6/site-packages')); except ImportError:; pass. import psi4. Psi4 is now able to be controlled directly from Python. By default, Psi4; will print any output to the screen; this can be changed by giving a; file name (with path if not in the current working directory) to the; function psi4.core.set_output_file(); API,; as a string:. In [2]:. psi4.core.set_output_file('output.dat', False). Additionally, output may be suppressed by instead setting; psi4.core.be_quiet(); API. II. Running a Basic Hartree-Fock Calculation¶; In our first example, we will consider a Hartree-Fock SCF computation; for the water molecule using a cc-pVDZ basis set. First, we will set the; available memory for Psi4 to use with the psi4.set_memory(); API; function, which takes either a string like '30 GB' (with units!) or; an integer number of bytes of memory as its argument. Next, our; molecular geometry is passed as a string into psi4.geometry(); API.; We may input this geometry in either Z-matrix or Cartesian format; to; allow the string to break over multiple lines, use Python’s triple-quote; """"""string"""""" syntax. Finally, we will compute the Hartree-Fock SCF; energy with the cc-pVDZ basis set by passing the method/basis set as a; string ('scf/cc-pvdz') into the function psi4.energy(); API:. In [3]:. #! Sample HF/cc-pVDZ H2O Computation. psi4.set_memory('500 MB'). h2o = psi4.geometry(""""""; O; H 1 0.96; H 1 0.96 2 104.5; """"""). psi4.energy('scf/cc-pvdz'). Out[3]:. -76.02663273488399. If everything goes well, the computation should complete and should; report a final restricted Hartree-Fock energy in the output file; output.dat in a section like this:; Energy converged. @DF-RHF Final",MatchSource.WIKI,psi4manual/1.2.1/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi.html
https://psicode.org/psi4manual/1.2.1/psiapi.html:7690,Availability,down,downhill,7690,",; such as geometry optimizations and vibrational frequency computations.; These can be specified by replacing psi4.energy(); API; with psi4.optimize(); API; or psi4.frequency(); API,; respectively.; Let’s take a look at an example of optimizing the H\(_2\)O; molecule using Hartree-Fock with a cc-pVDZ basis set.; Now, here comes the real beauty of running Psi4 interactively: above,; when we computed the energy of H\(_2\)O with HF/cc-pVDZ, we; defined the Psi4 molecule object h2o. Since we’re still in the; Python shell, as long as you executed that block of code, we can reuse; the h2o molecule object in our optimization without redefining it,; by adding the molecule=h2o argument to the psi4.optimize(); API; function:. In [5]:. psi4.set_options({'reference': 'rhf'}); psi4.optimize('scf/cc-pvdz', molecule=h2o). Optimizer: Optimization complete!. Out[5]:. -76.02703272937504. This should perform a series of gradient computations. The gradient; points which way is downhill in energy, and the optimizer then modifies; the geometry to follow the gradient. After a few cycles, the geometry; should converge with a message like Optimization complete!. As; indicated in the following table (printed by the optimizer at the end of; the computation and grep-able with ~), the energy decreases with; each step, and the maximum force on each atom also decreases with each; step (in principle, these numbers could increase in some iterations, but; here they do not).; --------------------------------------------------------------------------------------------------------------- ~  Step         Total Energy             Delta E       MAX Force       RMS Force        MAX Disp        RMS Disp  ~ --------------------------------------------------------------------------------------------------------------- ~     1     -76.026632734908    -76.026632734908      0.01523518      0.01245755      0.02742222      0.02277530  ~     2     -76.027022666011     -0.000389931104      0.00178779      0.0014294",MatchSource.WIKI,psi4manual/1.2.1/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi.html
https://psicode.org/psi4manual/1.2.1/psiapi.html:9937,Availability,error,errors,9937,"--------------------------------------------------------------------------- ~; To get harmonic vibrational frequencies, it’s important to keep in mind; that the values of the vibrational frequencies are a function of the; molecular geometry. Therefore, it’s important to obtain the vibrational; frequencies AT THE OPTIMIZED GEOMETRY. Luckily, Psi4 updates the; molecule with optimized geometry as it is being optimized. So, the; optimized geometry for H\(_2\)O is stored inside the h2o; molecule object, which we can access! To compute the frequencies, all we; need to do is to again pass the molecule=h2o argument to the; psi4.frequency(); API; function:. In [6]:. scf_e, scf_wfn = psi4.frequency('scf/cc-pvdz', molecule=h2o, return_wfn=True, dertype=1). 6 displacements needed.; 1 2 3 4 5 6. Executing this cell will prompt Psi4 to compute the Hessian (second; derivative matrix) of the electronic energy with respect to nuclear; displacements. From this, it can obtain the harmonic vibrational; frequencies, given below (roundoff errors of around \(0.1\); cm\(^{-1}\) may exist):; Irrep Harmonic Frequency; (cm-1); -----------------------------------------------; A1 1775.6478; A1 4113.3795; B2 4212.1814; -----------------------------------------------. Notice the symmetry type of the normal modes is specified (A1, A1, B2).; The program also print out the normal modes in terms of Cartesian; coordinates of each atom. For example, the normal mode at \(1776\); cm\(^{-1}\) is:; Frequency: 1775.65; Force constant: 0.1193; X Y Z mass; O 0.000 0.000 -0.068 15.994915; H 0.000 0.416 0.536 1.007825; H 0.000 -0.416 0.536 1.007825. where the table shows the displacements in the X, Y, and Z dimensions; for each atom along the normal mode coordinate. (This information could; be used to animate the vibrational frequency using visualization; software.); Because the vibrational frequencies are available, a thermodynamics; analysis is automatically performed at the end of the computation. You; can s",MatchSource.WIKI,psi4manual/1.2.1/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi.html
https://psicode.org/psi4manual/1.2.1/psiapi.html:10798,Availability,avail,available,10798,"to nuclear; displacements. From this, it can obtain the harmonic vibrational; frequencies, given below (roundoff errors of around \(0.1\); cm\(^{-1}\) may exist):; Irrep Harmonic Frequency; (cm-1); -----------------------------------------------; A1 1775.6478; A1 4113.3795; B2 4212.1814; -----------------------------------------------. Notice the symmetry type of the normal modes is specified (A1, A1, B2).; The program also print out the normal modes in terms of Cartesian; coordinates of each atom. For example, the normal mode at \(1776\); cm\(^{-1}\) is:; Frequency: 1775.65; Force constant: 0.1193; X Y Z mass; O 0.000 0.000 -0.068 15.994915; H 0.000 0.416 0.536 1.007825; H 0.000 -0.416 0.536 1.007825. where the table shows the displacements in the X, Y, and Z dimensions; for each atom along the normal mode coordinate. (This information could; be used to animate the vibrational frequency using visualization; software.); Because the vibrational frequencies are available, a thermodynamics; analysis is automatically performed at the end of the computation. You; can see this in the next section of the output file output.dat. The; vibrational frequencies are sufficient to obtain vibrational; contributions to enthalpy (H), entropy (S), and Gibbs free energy (G).; Similarly, the molecular geometry is used to obtain rotational; constants, which are then used to obtain rotational contributions to H,; S, and G.; Note: Psi4 has several synonyms for the functions called in this; example. For instance, psi4.frequency(); API; will compute molecular vibrational frequencies, and psi4.optimize(); API; will perform a geometry optimization. IV. Analysis of Intermolecular Interactions¶; Now let’s consider something a little more interesting. Psi4 contains; code to analyze the nature of intermolecular interactions between two; molecules, via symmetry-adapted perturbation theory (SAPT); (Jeziorski:1994:1887).; This kind of analysis gives a lot of insight into the nature of; intermolecula",MatchSource.WIKI,psi4manual/1.2.1/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi.html
https://psicode.org/psi4manual/1.2.1/psiapi.html:13681,Availability,error,error,13681,"sapt0/jun-cc-pvdz', molecule=dimer). Out[8]:. -0.0022355825227244703. All of the options we have currently set using psi4.set_options(); API; are “global” options (meaning that they are visible to all parts of the; program). Most common Psi4 options can be set like this. If an option; needs to be visible only to one part of the program (e.g., we only; want to increase the energy convergence in the SCF code, but not the; rest of the code), it can be set by with the; psi4.set_module_options(); API; function, psi4.set_module_options('scf', {'e_convergence': '1e-8'}).; Note: The arguments to the functions we’ve used so far, like; psi4.set_options(); API,; psi4.set_module_options(); API,; psi4.energy(); API,; psi4.optimize(); API,; psi4.frequency(); API,; etc., are case-insensitive.; Back to our SAPT example, we have found that for basic-level SAPT; computations (i.e., SAPT0), a good error cancellation is found; (Hohenstein:2012:WIREs); with the jun-cc-pVDZ basis (this is the usual aug-cc-pVDZ basis, but; without diffuse functions on hydrogen and without diffuse \(d\); functions on heavy atoms); (Papajak:2011:10).; So, we’ll use that as our standard basis set. The SAPT code is designed; to use density fitting techniques, because they introduce minimal errors; while providing much faster computations; (Hohenstein:2010:184111,Hohenstein:2010:014101).; Since we’re using density fitting for the SAPT, we might as well also; use it for the Hartree-Fock computations that are performed as part of; the SAPT. We can specify that by adding 'scf_type': 'df' to the; dictionary passed to psi4.set_options().; Density fitting procedures require the use of auxiliary basis sets that; pair with the primary basis set. Fortunately, Psi4 is usually smart; enough to figure out what auxiliary basis sets are needed for a given; computation. In this case, jun-cc-pVDZ is a standard enough basis set; (just a simple truncation of the very popular aug-cc-pVDZ basis set); that Psi4 correctly guesses th",MatchSource.WIKI,psi4manual/1.2.1/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi.html
https://psicode.org/psi4manual/1.2.1/psiapi.html:14056,Availability,error,errors,14056,"s. If an option; needs to be visible only to one part of the program (e.g., we only; want to increase the energy convergence in the SCF code, but not the; rest of the code), it can be set by with the; psi4.set_module_options(); API; function, psi4.set_module_options('scf', {'e_convergence': '1e-8'}).; Note: The arguments to the functions we’ve used so far, like; psi4.set_options(); API,; psi4.set_module_options(); API,; psi4.energy(); API,; psi4.optimize(); API,; psi4.frequency(); API,; etc., are case-insensitive.; Back to our SAPT example, we have found that for basic-level SAPT; computations (i.e., SAPT0), a good error cancellation is found; (Hohenstein:2012:WIREs); with the jun-cc-pVDZ basis (this is the usual aug-cc-pVDZ basis, but; without diffuse functions on hydrogen and without diffuse \(d\); functions on heavy atoms); (Papajak:2011:10).; So, we’ll use that as our standard basis set. The SAPT code is designed; to use density fitting techniques, because they introduce minimal errors; while providing much faster computations; (Hohenstein:2010:184111,Hohenstein:2010:014101).; Since we’re using density fitting for the SAPT, we might as well also; use it for the Hartree-Fock computations that are performed as part of; the SAPT. We can specify that by adding 'scf_type': 'df' to the; dictionary passed to psi4.set_options().; Density fitting procedures require the use of auxiliary basis sets that; pair with the primary basis set. Fortunately, Psi4 is usually smart; enough to figure out what auxiliary basis sets are needed for a given; computation. In this case, jun-cc-pVDZ is a standard enough basis set; (just a simple truncation of the very popular aug-cc-pVDZ basis set); that Psi4 correctly guesses that we want the jun-cc-pVDZ-JKFIT auxiliary; basis for the Hartree-Fock, and the jun-cc-pVDZ-RI basis set for the; SAPT procedure.; To speed up the computation a little, we also tell the SAPT procedure to; freeze the core electrons by adding 'freeze_core': 'true' to th",MatchSource.WIKI,psi4manual/1.2.1/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi.html
https://psicode.org/psi4manual/1.2.1/psiapi.html:865,Deployability,release,release,865,"﻿. PsiAPI Tutorial: Using Psi4 as a Python Module. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. A PSI4 Tutorial. PsiAPI Tutorial: Using Psi4 as a Python Module¶; transcribed by D. A. Sirianni. Note: Psithon and PsiAPI refer to two modes of interacting with; Psi4. In Psithon mode, you write an input file in our domain-specific; language (not quite Python) where commands don’t have psi4. in; front, then submit it to the executable psi4 which processes the; Psithon into pure Python and runs it internally. In PsiAPI mode, you; write a pure Python script with import psi4 at the top and commands; are behind the psi4. namespace, then submit it to the python; interpreter. Both modes are equally powerful. This tutorial covers the; PsiAPI mode. Warning: Although the developers have been using PsiAPI mode stably; for months before the 1.1 release and while we believe we’ve gotten; everything nicely arranged within the psi4. namespace, the API; should not be considered completely stable. Most importantly, as we; someday deprecate the last of the global variables, options will be; added to the method calls (e.g.,; energy('scf', molecule=mol, options=opt)); Note: Consult How to run Psi4 as Python module after; compilation; or How to run Psi4 as a Python module from conda; installation; for assistance in setting up Psi4. Unlike in the past, where Psi4 was executable software which could only; be called via input files like input.dat, it is now interactive,; able to be loaded directly as a Python module. Here, we will explore the; basics of using Psi4 in this new style by reproducing the section A; Psi4 Tutorial; from the Psi4 manual in an interactive Jupyter Notebook.; Note: If the newest version of Psi4 (v.1.1a2dev42 or newer) is in your; path, feel free to execute each cell as you read along by pressing; Shift+Enter when the cell is selected. I. Basic Input Structure¶; Psi4 is now a Python module; so, we need to import it into our Python; environment:. In",MatchSource.WIKI,psi4manual/1.2.1/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi.html
https://psicode.org/psi4manual/1.2.1/psiapi.html:1304,Deployability,install,installation,1304,"er to two modes of interacting with; Psi4. In Psithon mode, you write an input file in our domain-specific; language (not quite Python) where commands don’t have psi4. in; front, then submit it to the executable psi4 which processes the; Psithon into pure Python and runs it internally. In PsiAPI mode, you; write a pure Python script with import psi4 at the top and commands; are behind the psi4. namespace, then submit it to the python; interpreter. Both modes are equally powerful. This tutorial covers the; PsiAPI mode. Warning: Although the developers have been using PsiAPI mode stably; for months before the 1.1 release and while we believe we’ve gotten; everything nicely arranged within the psi4. namespace, the API; should not be considered completely stable. Most importantly, as we; someday deprecate the last of the global variables, options will be; added to the method calls (e.g.,; energy('scf', molecule=mol, options=opt)); Note: Consult How to run Psi4 as Python module after; compilation; or How to run Psi4 as a Python module from conda; installation; for assistance in setting up Psi4. Unlike in the past, where Psi4 was executable software which could only; be called via input files like input.dat, it is now interactive,; able to be loaded directly as a Python module. Here, we will explore the; basics of using Psi4 in this new style by reproducing the section A; Psi4 Tutorial; from the Psi4 manual in an interactive Jupyter Notebook.; Note: If the newest version of Psi4 (v.1.1a2dev42 or newer) is in your; path, feel free to execute each cell as you read along by pressing; Shift+Enter when the cell is selected. I. Basic Input Structure¶; Psi4 is now a Python module; so, we need to import it into our Python; environment:. In [1]:. try:; import os, sys; sys.path.insert(1, os.path.abspath('/scratch/psilocaluser/conda-builds/psi4-docs-multiout_1532505956776/work/build/stage//opt/anaconda1anaconda2anaconda3/lib/python3.6/site-packages')); except ImportError:; pass. impo",MatchSource.WIKI,psi4manual/1.2.1/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi.html
https://psicode.org/psi4manual/1.2.1/psiapi.html:4149,Deployability,install,installation,4149,"matrix or Cartesian format; to; allow the string to break over multiple lines, use Python’s triple-quote; """"""string"""""" syntax. Finally, we will compute the Hartree-Fock SCF; energy with the cc-pVDZ basis set by passing the method/basis set as a; string ('scf/cc-pvdz') into the function psi4.energy(); API:. In [3]:. #! Sample HF/cc-pVDZ H2O Computation. psi4.set_memory('500 MB'). h2o = psi4.geometry(""""""; O; H 1 0.96; H 1 0.96 2 104.5; """"""). psi4.energy('scf/cc-pvdz'). Out[3]:. -76.02663273488399. If everything goes well, the computation should complete and should; report a final restricted Hartree-Fock energy in the output file; output.dat in a section like this:; Energy converged. @DF-RHF Final Energy: -76.02663273486682. By default, the energy should be converged to about; \(1.0\times 10^{-6}\), so agreement is only expected for about the; first 6 digits after the decimal. If the computation does not complete,; there is probably a problem with the compilation or installation of the; program (see the installation instructions in the main Psi4 manual; section Compiling and Installing from; Source).; This very simple input is sufficient to run the requested information.; Notice we didn’t tell the program some otherwise useful information like; the charge of the molecule (0, it’s neutral), the spin multiplicity (1; for a closed-shell molecule with all electrons paired), or the reference; wavefunction to use (restricted Hartree-Fock, or RHF, is usually; appropriate for a closed-shell molecule). The program correctly guessed; all of these options for us. We can change the default behavior through; additional keywords.; Let’s consider what we would do for an open-shell molecule, where not; all the electrons are paired. For example, let’s run a computation on; methylene (\(\text{CH}_2\)), whose ground electronic state has two; unpaired electrons (triplet electronic state, or a spin multiplicity; \(2S + 1 = 3\)). In this case, the default spin multiplicity (1) is; not corre",MatchSource.WIKI,psi4manual/1.2.1/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi.html
https://psicode.org/psi4manual/1.2.1/psiapi.html:4187,Deployability,install,installation,4187,"matrix or Cartesian format; to; allow the string to break over multiple lines, use Python’s triple-quote; """"""string"""""" syntax. Finally, we will compute the Hartree-Fock SCF; energy with the cc-pVDZ basis set by passing the method/basis set as a; string ('scf/cc-pvdz') into the function psi4.energy(); API:. In [3]:. #! Sample HF/cc-pVDZ H2O Computation. psi4.set_memory('500 MB'). h2o = psi4.geometry(""""""; O; H 1 0.96; H 1 0.96 2 104.5; """"""). psi4.energy('scf/cc-pvdz'). Out[3]:. -76.02663273488399. If everything goes well, the computation should complete and should; report a final restricted Hartree-Fock energy in the output file; output.dat in a section like this:; Energy converged. @DF-RHF Final Energy: -76.02663273486682. By default, the energy should be converged to about; \(1.0\times 10^{-6}\), so agreement is only expected for about the; first 6 digits after the decimal. If the computation does not complete,; there is probably a problem with the compilation or installation of the; program (see the installation instructions in the main Psi4 manual; section Compiling and Installing from; Source).; This very simple input is sufficient to run the requested information.; Notice we didn’t tell the program some otherwise useful information like; the charge of the molecule (0, it’s neutral), the spin multiplicity (1; for a closed-shell molecule with all electrons paired), or the reference; wavefunction to use (restricted Hartree-Fock, or RHF, is usually; appropriate for a closed-shell molecule). The program correctly guessed; all of these options for us. We can change the default behavior through; additional keywords.; Let’s consider what we would do for an open-shell molecule, where not; all the electrons are paired. For example, let’s run a computation on; methylene (\(\text{CH}_2\)), whose ground electronic state has two; unpaired electrons (triplet electronic state, or a spin multiplicity; \(2S + 1 = 3\)). In this case, the default spin multiplicity (1) is; not corre",MatchSource.WIKI,psi4manual/1.2.1/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi.html
https://psicode.org/psi4manual/1.2.1/psiapi.html:9252,Deployability,update,updates,9252,"--------------- ~  Step         Total Energy             Delta E       MAX Force       RMS Force        MAX Disp        RMS Disp  ~ --------------------------------------------------------------------------------------------------------------- ~     1     -76.026632734908    -76.026632734908      0.01523518      0.01245755      0.02742222      0.02277530  ~     2     -76.027022666011     -0.000389931104      0.00178779      0.00142946      0.01008137      0.00594928  ~     3     -76.027032729374     -0.000010063363      0.00014019      0.00008488      0.00077463      0.00044738  ~ --------------------------------------------------------------------------------------------------------------- ~; To get harmonic vibrational frequencies, it’s important to keep in mind; that the values of the vibrational frequencies are a function of the; molecular geometry. Therefore, it’s important to obtain the vibrational; frequencies AT THE OPTIMIZED GEOMETRY. Luckily, Psi4 updates the; molecule with optimized geometry as it is being optimized. So, the; optimized geometry for H\(_2\)O is stored inside the h2o; molecule object, which we can access! To compute the frequencies, all we; need to do is to again pass the molecule=h2o argument to the; psi4.frequency(); API; function:. In [6]:. scf_e, scf_wfn = psi4.frequency('scf/cc-pvdz', molecule=h2o, return_wfn=True, dertype=1). 6 displacements needed.; 1 2 3 4 5 6. Executing this cell will prompt Psi4 to compute the Hessian (second; derivative matrix) of the electronic energy with respect to nuclear; displacements. From this, it can obtain the harmonic vibrational; frequencies, given below (roundoff errors of around \(0.1\); cm\(^{-1}\) may exist):; Irrep Harmonic Frequency; (cm-1); -----------------------------------------------; A1 1775.6478; A1 4113.3795; B2 4212.1814; -----------------------------------------------. Notice the symmetry type of the normal modes is specified (A1, A1, B2).; The program also print out the normal modes i",MatchSource.WIKI,psi4manual/1.2.1/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi.html
https://psicode.org/psi4manual/1.2.1/psiapi.html:24115,Deployability,update,updated,24115,"ents = (1,), basis = (1, 2): -128.70932405488935); ...; N-Body: Computing complex (1/1) with fragments (1, 2) in the basis of fragments (1, 2).; ...; N-Body: Complex Energy (fragments = (1, 2), basis = (1, 2): -257.41867403127321); ...; ==> N-Body: Counterpoise Corrected (CP) energies <==. n-Body Total Energy [Eh] I.E. [kcal/mol] Delta [kcal/mol]; 1 -257.418648109779 0.000000000000 0.000000000000; 2 -257.418674031273 -0.016265984132 -0.016265984132. And that’s it! The only remaining part of the example is a little table; of the different R values and the CP-corrected CCSD(T) energies,; converted from atomic units (Hartree) to kcal mol\(^{-1}\) by; multiplying by the automatically-defined conversion factor; psi4.constants.hartree2kcalmol. Psi4 provides several built-in; physical constants and conversion factors, as described in the Psi4; manual section Physical; Constants.; The table can be printed either to the screen, by using standard Python; ``print()`; syntax <https://docs.python.org/3/whatsnew/3.0.html#print-is-a-function>`__,; or to the designated output file output.dat using Psi4’s built-in; function psi4.core.print_out(); API; (C style printing).; As we’ve seen so far, the combination of Psi4 and Python creates a; unique, interactive approach to quantum chemistry. The next section will; explore this synergistic relationship in greater detail, describing how; even very complex tasks can be done very easily with Psi4. table of contents. PsiAPI Tutorial: Using Psi4 as a Python Module; I. Basic Input Structure; II. Running a Basic Hartree-Fock Calculation; III. Geometry Optimization and Vibrational Frequency Analysis; IV. Analysis of Intermolecular Interactions; V. Potential Surface Scans and Counterpoise Correction Made Easy. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. A PSI4 Tutorial. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi.html
https://psicode.org/psi4manual/1.2.1/psiapi.html:721,Energy Efficiency,power,powerful,721,"﻿. PsiAPI Tutorial: Using Psi4 as a Python Module. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. A PSI4 Tutorial. PsiAPI Tutorial: Using Psi4 as a Python Module¶; transcribed by D. A. Sirianni. Note: Psithon and PsiAPI refer to two modes of interacting with; Psi4. In Psithon mode, you write an input file in our domain-specific; language (not quite Python) where commands don’t have psi4. in; front, then submit it to the executable psi4 which processes the; Psithon into pure Python and runs it internally. In PsiAPI mode, you; write a pure Python script with import psi4 at the top and commands; are behind the psi4. namespace, then submit it to the python; interpreter. Both modes are equally powerful. This tutorial covers the; PsiAPI mode. Warning: Although the developers have been using PsiAPI mode stably; for months before the 1.1 release and while we believe we’ve gotten; everything nicely arranged within the psi4. namespace, the API; should not be considered completely stable. Most importantly, as we; someday deprecate the last of the global variables, options will be; added to the method calls (e.g.,; energy('scf', molecule=mol, options=opt)); Note: Consult How to run Psi4 as Python module after; compilation; or How to run Psi4 as a Python module from conda; installation; for assistance in setting up Psi4. Unlike in the past, where Psi4 was executable software which could only; be called via input files like input.dat, it is now interactive,; able to be loaded directly as a Python module. Here, we will explore the; basics of using Psi4 in this new style by reproducing the section A; Psi4 Tutorial; from the Psi4 manual in an interactive Jupyter Notebook.; Note: If the newest version of Psi4 (v.1.1a2dev42 or newer) is in your; path, feel free to execute each cell as you read along by pressing; Shift+Enter when the cell is selected. I. Basic Input Structure¶; Psi4 is now a Python module; so, we need to import it into our Python; environment:. In",MatchSource.WIKI,psi4manual/1.2.1/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi.html
https://psicode.org/psi4manual/1.2.1/psiapi.html:1144,Energy Efficiency,energy,energy,1144,"er to two modes of interacting with; Psi4. In Psithon mode, you write an input file in our domain-specific; language (not quite Python) where commands don’t have psi4. in; front, then submit it to the executable psi4 which processes the; Psithon into pure Python and runs it internally. In PsiAPI mode, you; write a pure Python script with import psi4 at the top and commands; are behind the psi4. namespace, then submit it to the python; interpreter. Both modes are equally powerful. This tutorial covers the; PsiAPI mode. Warning: Although the developers have been using PsiAPI mode stably; for months before the 1.1 release and while we believe we’ve gotten; everything nicely arranged within the psi4. namespace, the API; should not be considered completely stable. Most importantly, as we; someday deprecate the last of the global variables, options will be; added to the method calls (e.g.,; energy('scf', molecule=mol, options=opt)); Note: Consult How to run Psi4 as Python module after; compilation; or How to run Psi4 as a Python module from conda; installation; for assistance in setting up Psi4. Unlike in the past, where Psi4 was executable software which could only; be called via input files like input.dat, it is now interactive,; able to be loaded directly as a Python module. Here, we will explore the; basics of using Psi4 in this new style by reproducing the section A; Psi4 Tutorial; from the Psi4 manual in an interactive Jupyter Notebook.; Note: If the newest version of Psi4 (v.1.1a2dev42 or newer) is in your; path, feel free to execute each cell as you read along by pressing; Shift+Enter when the cell is selected. I. Basic Input Structure¶; Psi4 is now a Python module; so, we need to import it into our Python; environment:. In [1]:. try:; import os, sys; sys.path.insert(1, os.path.abspath('/scratch/psilocaluser/conda-builds/psi4-docs-multiout_1532505956776/work/build/stage//opt/anaconda1anaconda2anaconda3/lib/python3.6/site-packages')); except ImportError:; pass. impo",MatchSource.WIKI,psi4manual/1.2.1/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi.html
https://psicode.org/psi4manual/1.2.1/psiapi.html:3345,Energy Efficiency,energy,energy,3345,"hanged by giving a; file name (with path if not in the current working directory) to the; function psi4.core.set_output_file(); API,; as a string:. In [2]:. psi4.core.set_output_file('output.dat', False). Additionally, output may be suppressed by instead setting; psi4.core.be_quiet(); API. II. Running a Basic Hartree-Fock Calculation¶; In our first example, we will consider a Hartree-Fock SCF computation; for the water molecule using a cc-pVDZ basis set. First, we will set the; available memory for Psi4 to use with the psi4.set_memory(); API; function, which takes either a string like '30 GB' (with units!) or; an integer number of bytes of memory as its argument. Next, our; molecular geometry is passed as a string into psi4.geometry(); API.; We may input this geometry in either Z-matrix or Cartesian format; to; allow the string to break over multiple lines, use Python’s triple-quote; """"""string"""""" syntax. Finally, we will compute the Hartree-Fock SCF; energy with the cc-pVDZ basis set by passing the method/basis set as a; string ('scf/cc-pvdz') into the function psi4.energy(); API:. In [3]:. #! Sample HF/cc-pVDZ H2O Computation. psi4.set_memory('500 MB'). h2o = psi4.geometry(""""""; O; H 1 0.96; H 1 0.96 2 104.5; """"""). psi4.energy('scf/cc-pvdz'). Out[3]:. -76.02663273488399. If everything goes well, the computation should complete and should; report a final restricted Hartree-Fock energy in the output file; output.dat in a section like this:; Energy converged. @DF-RHF Final Energy: -76.02663273486682. By default, the energy should be converged to about; \(1.0\times 10^{-6}\), so agreement is only expected for about the; first 6 digits after the decimal. If the computation does not complete,; there is probably a problem with the compilation or installation of the; program (see the installation instructions in the main Psi4 manual; section Compiling and Installing from; Source).; This very simple input is sufficient to run the requested information.; Notice we didn’t tell",MatchSource.WIKI,psi4manual/1.2.1/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi.html
https://psicode.org/psi4manual/1.2.1/psiapi.html:3463,Energy Efficiency,energy,energy,3463,"function psi4.core.set_output_file(); API,; as a string:. In [2]:. psi4.core.set_output_file('output.dat', False). Additionally, output may be suppressed by instead setting; psi4.core.be_quiet(); API. II. Running a Basic Hartree-Fock Calculation¶; In our first example, we will consider a Hartree-Fock SCF computation; for the water molecule using a cc-pVDZ basis set. First, we will set the; available memory for Psi4 to use with the psi4.set_memory(); API; function, which takes either a string like '30 GB' (with units!) or; an integer number of bytes of memory as its argument. Next, our; molecular geometry is passed as a string into psi4.geometry(); API.; We may input this geometry in either Z-matrix or Cartesian format; to; allow the string to break over multiple lines, use Python’s triple-quote; """"""string"""""" syntax. Finally, we will compute the Hartree-Fock SCF; energy with the cc-pVDZ basis set by passing the method/basis set as a; string ('scf/cc-pvdz') into the function psi4.energy(); API:. In [3]:. #! Sample HF/cc-pVDZ H2O Computation. psi4.set_memory('500 MB'). h2o = psi4.geometry(""""""; O; H 1 0.96; H 1 0.96 2 104.5; """"""). psi4.energy('scf/cc-pvdz'). Out[3]:. -76.02663273488399. If everything goes well, the computation should complete and should; report a final restricted Hartree-Fock energy in the output file; output.dat in a section like this:; Energy converged. @DF-RHF Final Energy: -76.02663273486682. By default, the energy should be converged to about; \(1.0\times 10^{-6}\), so agreement is only expected for about the; first 6 digits after the decimal. If the computation does not complete,; there is probably a problem with the compilation or installation of the; program (see the installation instructions in the main Psi4 manual; section Compiling and Installing from; Source).; This very simple input is sufficient to run the requested information.; Notice we didn’t tell the program some otherwise useful information like; the charge of the molecule (0, it’s ne",MatchSource.WIKI,psi4manual/1.2.1/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi.html
https://psicode.org/psi4manual/1.2.1/psiapi.html:3620,Energy Efficiency,energy,energy,3620,"ead setting; psi4.core.be_quiet(); API. II. Running a Basic Hartree-Fock Calculation¶; In our first example, we will consider a Hartree-Fock SCF computation; for the water molecule using a cc-pVDZ basis set. First, we will set the; available memory for Psi4 to use with the psi4.set_memory(); API; function, which takes either a string like '30 GB' (with units!) or; an integer number of bytes of memory as its argument. Next, our; molecular geometry is passed as a string into psi4.geometry(); API.; We may input this geometry in either Z-matrix or Cartesian format; to; allow the string to break over multiple lines, use Python’s triple-quote; """"""string"""""" syntax. Finally, we will compute the Hartree-Fock SCF; energy with the cc-pVDZ basis set by passing the method/basis set as a; string ('scf/cc-pvdz') into the function psi4.energy(); API:. In [3]:. #! Sample HF/cc-pVDZ H2O Computation. psi4.set_memory('500 MB'). h2o = psi4.geometry(""""""; O; H 1 0.96; H 1 0.96 2 104.5; """"""). psi4.energy('scf/cc-pvdz'). Out[3]:. -76.02663273488399. If everything goes well, the computation should complete and should; report a final restricted Hartree-Fock energy in the output file; output.dat in a section like this:; Energy converged. @DF-RHF Final Energy: -76.02663273486682. By default, the energy should be converged to about; \(1.0\times 10^{-6}\), so agreement is only expected for about the; first 6 digits after the decimal. If the computation does not complete,; there is probably a problem with the compilation or installation of the; program (see the installation instructions in the main Psi4 manual; section Compiling and Installing from; Source).; This very simple input is sufficient to run the requested information.; Notice we didn’t tell the program some otherwise useful information like; the charge of the molecule (0, it’s neutral), the spin multiplicity (1; for a closed-shell molecule with all electrons paired), or the reference; wavefunction to use (restricted Hartree-Fock, or RHF",MatchSource.WIKI,psi4manual/1.2.1/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi.html
https://psicode.org/psi4manual/1.2.1/psiapi.html:3780,Energy Efficiency,energy,energy,3780," will consider a Hartree-Fock SCF computation; for the water molecule using a cc-pVDZ basis set. First, we will set the; available memory for Psi4 to use with the psi4.set_memory(); API; function, which takes either a string like '30 GB' (with units!) or; an integer number of bytes of memory as its argument. Next, our; molecular geometry is passed as a string into psi4.geometry(); API.; We may input this geometry in either Z-matrix or Cartesian format; to; allow the string to break over multiple lines, use Python’s triple-quote; """"""string"""""" syntax. Finally, we will compute the Hartree-Fock SCF; energy with the cc-pVDZ basis set by passing the method/basis set as a; string ('scf/cc-pvdz') into the function psi4.energy(); API:. In [3]:. #! Sample HF/cc-pVDZ H2O Computation. psi4.set_memory('500 MB'). h2o = psi4.geometry(""""""; O; H 1 0.96; H 1 0.96 2 104.5; """"""). psi4.energy('scf/cc-pvdz'). Out[3]:. -76.02663273488399. If everything goes well, the computation should complete and should; report a final restricted Hartree-Fock energy in the output file; output.dat in a section like this:; Energy converged. @DF-RHF Final Energy: -76.02663273486682. By default, the energy should be converged to about; \(1.0\times 10^{-6}\), so agreement is only expected for about the; first 6 digits after the decimal. If the computation does not complete,; there is probably a problem with the compilation or installation of the; program (see the installation instructions in the main Psi4 manual; section Compiling and Installing from; Source).; This very simple input is sufficient to run the requested information.; Notice we didn’t tell the program some otherwise useful information like; the charge of the molecule (0, it’s neutral), the spin multiplicity (1; for a closed-shell molecule with all electrons paired), or the reference; wavefunction to use (restricted Hartree-Fock, or RHF, is usually; appropriate for a closed-shell molecule). The program correctly guessed; all of these options for ",MatchSource.WIKI,psi4manual/1.2.1/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi.html
https://psicode.org/psi4manual/1.2.1/psiapi.html:3919,Energy Efficiency,energy,energy,3919,"nction, which takes either a string like '30 GB' (with units!) or; an integer number of bytes of memory as its argument. Next, our; molecular geometry is passed as a string into psi4.geometry(); API.; We may input this geometry in either Z-matrix or Cartesian format; to; allow the string to break over multiple lines, use Python’s triple-quote; """"""string"""""" syntax. Finally, we will compute the Hartree-Fock SCF; energy with the cc-pVDZ basis set by passing the method/basis set as a; string ('scf/cc-pvdz') into the function psi4.energy(); API:. In [3]:. #! Sample HF/cc-pVDZ H2O Computation. psi4.set_memory('500 MB'). h2o = psi4.geometry(""""""; O; H 1 0.96; H 1 0.96 2 104.5; """"""). psi4.energy('scf/cc-pvdz'). Out[3]:. -76.02663273488399. If everything goes well, the computation should complete and should; report a final restricted Hartree-Fock energy in the output file; output.dat in a section like this:; Energy converged. @DF-RHF Final Energy: -76.02663273486682. By default, the energy should be converged to about; \(1.0\times 10^{-6}\), so agreement is only expected for about the; first 6 digits after the decimal. If the computation does not complete,; there is probably a problem with the compilation or installation of the; program (see the installation instructions in the main Psi4 manual; section Compiling and Installing from; Source).; This very simple input is sufficient to run the requested information.; Notice we didn’t tell the program some otherwise useful information like; the charge of the molecule (0, it’s neutral), the spin multiplicity (1; for a closed-shell molecule with all electrons paired), or the reference; wavefunction to use (restricted Hartree-Fock, or RHF, is usually; appropriate for a closed-shell molecule). The program correctly guessed; all of these options for us. We can change the default behavior through; additional keywords.; Let’s consider what we would do for an open-shell molecule, where not; all the electrons are paired. For example, let’",MatchSource.WIKI,psi4manual/1.2.1/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi.html
https://psicode.org/psi4manual/1.2.1/psiapi.html:4437,Energy Efficiency,charge,charge,4437,"ion. psi4.set_memory('500 MB'). h2o = psi4.geometry(""""""; O; H 1 0.96; H 1 0.96 2 104.5; """"""). psi4.energy('scf/cc-pvdz'). Out[3]:. -76.02663273488399. If everything goes well, the computation should complete and should; report a final restricted Hartree-Fock energy in the output file; output.dat in a section like this:; Energy converged. @DF-RHF Final Energy: -76.02663273486682. By default, the energy should be converged to about; \(1.0\times 10^{-6}\), so agreement is only expected for about the; first 6 digits after the decimal. If the computation does not complete,; there is probably a problem with the compilation or installation of the; program (see the installation instructions in the main Psi4 manual; section Compiling and Installing from; Source).; This very simple input is sufficient to run the requested information.; Notice we didn’t tell the program some otherwise useful information like; the charge of the molecule (0, it’s neutral), the spin multiplicity (1; for a closed-shell molecule with all electrons paired), or the reference; wavefunction to use (restricted Hartree-Fock, or RHF, is usually; appropriate for a closed-shell molecule). The program correctly guessed; all of these options for us. We can change the default behavior through; additional keywords.; Let’s consider what we would do for an open-shell molecule, where not; all the electrons are paired. For example, let’s run a computation on; methylene (\(\text{CH}_2\)), whose ground electronic state has two; unpaired electrons (triplet electronic state, or a spin multiplicity; \(2S + 1 = 3\)). In this case, the default spin multiplicity (1) is; not correct, so we need to tell the program the true value (3). Like; many programs, Psi4 can get the charge and multiplicity as the first two; integers in the Z-matrix (note the line with 0 3 at the beginning of; the molecule specification below). In this example, we will also specify; the bond length and bond angle as variables (\(R\) and \(A\)),; whose va",MatchSource.WIKI,psi4manual/1.2.1/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi.html
https://psicode.org/psi4manual/1.2.1/psiapi.html:5264,Energy Efficiency,charge,charge,5264,"icient to run the requested information.; Notice we didn’t tell the program some otherwise useful information like; the charge of the molecule (0, it’s neutral), the spin multiplicity (1; for a closed-shell molecule with all electrons paired), or the reference; wavefunction to use (restricted Hartree-Fock, or RHF, is usually; appropriate for a closed-shell molecule). The program correctly guessed; all of these options for us. We can change the default behavior through; additional keywords.; Let’s consider what we would do for an open-shell molecule, where not; all the electrons are paired. For example, let’s run a computation on; methylene (\(\text{CH}_2\)), whose ground electronic state has two; unpaired electrons (triplet electronic state, or a spin multiplicity; \(2S + 1 = 3\)). In this case, the default spin multiplicity (1) is; not correct, so we need to tell the program the true value (3). Like; many programs, Psi4 can get the charge and multiplicity as the first two; integers in the Z-matrix (note the line with 0 3 at the beginning of; the molecule specification below). In this example, we will also specify; the bond length and bond angle as variables (\(R\) and \(A\)),; whose values are first stored and then inserted into the geometry; specification using Python 3 string; formatting. In [4]:. #! Sample UHF/6-31G** CH2 Computation. R = 1.075; A = 133.93. ch2 = psi4.geometry(""""""; 0 3; C; H 1 {0}; H 1 {0} 2 {1}; """""".format(R, A); ). psi4.set_options({'reference': 'uhf'}); psi4.energy('scf/6-31g**'). Out[4]:. -38.925334628859886. Executing this cell should yield the final energy as; @DF-UHF Final Energy: -38.92533462887677. Notice the new command, psi4.set_options(); API,; to the input. This function takes a Python; dictionary; as its argument, which is a key-value list which associates a Psi4; keyword; with its user-defined value. For open shell molecules, we have a choice; of unrestricted orbitals (unrestricted Hartree-Fock, or UHF) or; restricted orbitals (res",MatchSource.WIKI,psi4manual/1.2.1/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi.html
https://psicode.org/psi4manual/1.2.1/psiapi.html:5824,Energy Efficiency,energy,energy,5824," would do for an open-shell molecule, where not; all the electrons are paired. For example, let’s run a computation on; methylene (\(\text{CH}_2\)), whose ground electronic state has two; unpaired electrons (triplet electronic state, or a spin multiplicity; \(2S + 1 = 3\)). In this case, the default spin multiplicity (1) is; not correct, so we need to tell the program the true value (3). Like; many programs, Psi4 can get the charge and multiplicity as the first two; integers in the Z-matrix (note the line with 0 3 at the beginning of; the molecule specification below). In this example, we will also specify; the bond length and bond angle as variables (\(R\) and \(A\)),; whose values are first stored and then inserted into the geometry; specification using Python 3 string; formatting. In [4]:. #! Sample UHF/6-31G** CH2 Computation. R = 1.075; A = 133.93. ch2 = psi4.geometry(""""""; 0 3; C; H 1 {0}; H 1 {0} 2 {1}; """""".format(R, A); ). psi4.set_options({'reference': 'uhf'}); psi4.energy('scf/6-31g**'). Out[4]:. -38.925334628859886. Executing this cell should yield the final energy as; @DF-UHF Final Energy: -38.92533462887677. Notice the new command, psi4.set_options(); API,; to the input. This function takes a Python; dictionary; as its argument, which is a key-value list which associates a Psi4; keyword; with its user-defined value. For open shell molecules, we have a choice; of unrestricted orbitals (unrestricted Hartree-Fock, or UHF) or; restricted orbitals (restricted open-shell Hartree-Fock, or ROHF).; Usually, UHF is a little easier to converge (although it may be more; susceptible to spin contamination than ROHF). III. Geometry Optimization and Vibrational Frequency Analysis¶; The above examples were simple single-point energy computations (as; specified by the psi4.energy(); API; function). Of course there are other kinds of computations to perform,; such as geometry optimizations and vibrational frequency computations.; These can be specified by replacing psi4.en",MatchSource.WIKI,psi4manual/1.2.1/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi.html
https://psicode.org/psi4manual/1.2.1/psiapi.html:5920,Energy Efficiency,energy,energy,5920,"r example, let’s run a computation on; methylene (\(\text{CH}_2\)), whose ground electronic state has two; unpaired electrons (triplet electronic state, or a spin multiplicity; \(2S + 1 = 3\)). In this case, the default spin multiplicity (1) is; not correct, so we need to tell the program the true value (3). Like; many programs, Psi4 can get the charge and multiplicity as the first two; integers in the Z-matrix (note the line with 0 3 at the beginning of; the molecule specification below). In this example, we will also specify; the bond length and bond angle as variables (\(R\) and \(A\)),; whose values are first stored and then inserted into the geometry; specification using Python 3 string; formatting. In [4]:. #! Sample UHF/6-31G** CH2 Computation. R = 1.075; A = 133.93. ch2 = psi4.geometry(""""""; 0 3; C; H 1 {0}; H 1 {0} 2 {1}; """""".format(R, A); ). psi4.set_options({'reference': 'uhf'}); psi4.energy('scf/6-31g**'). Out[4]:. -38.925334628859886. Executing this cell should yield the final energy as; @DF-UHF Final Energy: -38.92533462887677. Notice the new command, psi4.set_options(); API,; to the input. This function takes a Python; dictionary; as its argument, which is a key-value list which associates a Psi4; keyword; with its user-defined value. For open shell molecules, we have a choice; of unrestricted orbitals (unrestricted Hartree-Fock, or UHF) or; restricted orbitals (restricted open-shell Hartree-Fock, or ROHF).; Usually, UHF is a little easier to converge (although it may be more; susceptible to spin contamination than ROHF). III. Geometry Optimization and Vibrational Frequency Analysis¶; The above examples were simple single-point energy computations (as; specified by the psi4.energy(); API; function). Of course there are other kinds of computations to perform,; such as geometry optimizations and vibrational frequency computations.; These can be specified by replacing psi4.energy(); API; with psi4.optimize(); API; or psi4.frequency(); API,; respectively.; ",MatchSource.WIKI,psi4manual/1.2.1/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi.html
https://psicode.org/psi4manual/1.2.1/psiapi.html:6586,Energy Efficiency,energy,energy,6586,"rted into the geometry; specification using Python 3 string; formatting. In [4]:. #! Sample UHF/6-31G** CH2 Computation. R = 1.075; A = 133.93. ch2 = psi4.geometry(""""""; 0 3; C; H 1 {0}; H 1 {0} 2 {1}; """""".format(R, A); ). psi4.set_options({'reference': 'uhf'}); psi4.energy('scf/6-31g**'). Out[4]:. -38.925334628859886. Executing this cell should yield the final energy as; @DF-UHF Final Energy: -38.92533462887677. Notice the new command, psi4.set_options(); API,; to the input. This function takes a Python; dictionary; as its argument, which is a key-value list which associates a Psi4; keyword; with its user-defined value. For open shell molecules, we have a choice; of unrestricted orbitals (unrestricted Hartree-Fock, or UHF) or; restricted orbitals (restricted open-shell Hartree-Fock, or ROHF).; Usually, UHF is a little easier to converge (although it may be more; susceptible to spin contamination than ROHF). III. Geometry Optimization and Vibrational Frequency Analysis¶; The above examples were simple single-point energy computations (as; specified by the psi4.energy(); API; function). Of course there are other kinds of computations to perform,; such as geometry optimizations and vibrational frequency computations.; These can be specified by replacing psi4.energy(); API; with psi4.optimize(); API; or psi4.frequency(); API,; respectively.; Let’s take a look at an example of optimizing the H\(_2\)O; molecule using Hartree-Fock with a cc-pVDZ basis set.; Now, here comes the real beauty of running Psi4 interactively: above,; when we computed the energy of H\(_2\)O with HF/cc-pVDZ, we; defined the Psi4 molecule object h2o. Since we’re still in the; Python shell, as long as you executed that block of code, we can reuse; the h2o molecule object in our optimization without redefining it,; by adding the molecule=h2o argument to the psi4.optimize(); API; function:. In [5]:. psi4.set_options({'reference': 'rhf'}); psi4.optimize('scf/cc-pvdz', molecule=h2o). Optimizer: Optimizati",MatchSource.WIKI,psi4manual/1.2.1/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi.html
https://psicode.org/psi4manual/1.2.1/psiapi.html:6633,Energy Efficiency,energy,energy,6633,"ple UHF/6-31G** CH2 Computation. R = 1.075; A = 133.93. ch2 = psi4.geometry(""""""; 0 3; C; H 1 {0}; H 1 {0} 2 {1}; """""".format(R, A); ). psi4.set_options({'reference': 'uhf'}); psi4.energy('scf/6-31g**'). Out[4]:. -38.925334628859886. Executing this cell should yield the final energy as; @DF-UHF Final Energy: -38.92533462887677. Notice the new command, psi4.set_options(); API,; to the input. This function takes a Python; dictionary; as its argument, which is a key-value list which associates a Psi4; keyword; with its user-defined value. For open shell molecules, we have a choice; of unrestricted orbitals (unrestricted Hartree-Fock, or UHF) or; restricted orbitals (restricted open-shell Hartree-Fock, or ROHF).; Usually, UHF is a little easier to converge (although it may be more; susceptible to spin contamination than ROHF). III. Geometry Optimization and Vibrational Frequency Analysis¶; The above examples were simple single-point energy computations (as; specified by the psi4.energy(); API; function). Of course there are other kinds of computations to perform,; such as geometry optimizations and vibrational frequency computations.; These can be specified by replacing psi4.energy(); API; with psi4.optimize(); API; or psi4.frequency(); API,; respectively.; Let’s take a look at an example of optimizing the H\(_2\)O; molecule using Hartree-Fock with a cc-pVDZ basis set.; Now, here comes the real beauty of running Psi4 interactively: above,; when we computed the energy of H\(_2\)O with HF/cc-pVDZ, we; defined the Psi4 molecule object h2o. Since we’re still in the; Python shell, as long as you executed that block of code, we can reuse; the h2o molecule object in our optimization without redefining it,; by adding the molecule=h2o argument to the psi4.optimize(); API; function:. In [5]:. psi4.set_options({'reference': 'rhf'}); psi4.optimize('scf/cc-pvdz', molecule=h2o). Optimizer: Optimization complete!. Out[5]:. -76.02703272937504. This should perform a series of gradient comp",MatchSource.WIKI,psi4manual/1.2.1/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi.html
https://psicode.org/psi4manual/1.2.1/psiapi.html:6833,Energy Efficiency,energy,energy,6833,". Out[4]:. -38.925334628859886. Executing this cell should yield the final energy as; @DF-UHF Final Energy: -38.92533462887677. Notice the new command, psi4.set_options(); API,; to the input. This function takes a Python; dictionary; as its argument, which is a key-value list which associates a Psi4; keyword; with its user-defined value. For open shell molecules, we have a choice; of unrestricted orbitals (unrestricted Hartree-Fock, or UHF) or; restricted orbitals (restricted open-shell Hartree-Fock, or ROHF).; Usually, UHF is a little easier to converge (although it may be more; susceptible to spin contamination than ROHF). III. Geometry Optimization and Vibrational Frequency Analysis¶; The above examples were simple single-point energy computations (as; specified by the psi4.energy(); API; function). Of course there are other kinds of computations to perform,; such as geometry optimizations and vibrational frequency computations.; These can be specified by replacing psi4.energy(); API; with psi4.optimize(); API; or psi4.frequency(); API,; respectively.; Let’s take a look at an example of optimizing the H\(_2\)O; molecule using Hartree-Fock with a cc-pVDZ basis set.; Now, here comes the real beauty of running Psi4 interactively: above,; when we computed the energy of H\(_2\)O with HF/cc-pVDZ, we; defined the Psi4 molecule object h2o. Since we’re still in the; Python shell, as long as you executed that block of code, we can reuse; the h2o molecule object in our optimization without redefining it,; by adding the molecule=h2o argument to the psi4.optimize(); API; function:. In [5]:. psi4.set_options({'reference': 'rhf'}); psi4.optimize('scf/cc-pvdz', molecule=h2o). Optimizer: Optimization complete!. Out[5]:. -76.02703272937504. This should perform a series of gradient computations. The gradient; points which way is downhill in energy, and the optimizer then modifies; the geometry to follow the gradient. After a few cycles, the geometry; should converge with a message l",MatchSource.WIKI,psi4manual/1.2.1/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi.html
https://psicode.org/psi4manual/1.2.1/psiapi.html:7124,Energy Efficiency,energy,energy,7124,"e list which associates a Psi4; keyword; with its user-defined value. For open shell molecules, we have a choice; of unrestricted orbitals (unrestricted Hartree-Fock, or UHF) or; restricted orbitals (restricted open-shell Hartree-Fock, or ROHF).; Usually, UHF is a little easier to converge (although it may be more; susceptible to spin contamination than ROHF). III. Geometry Optimization and Vibrational Frequency Analysis¶; The above examples were simple single-point energy computations (as; specified by the psi4.energy(); API; function). Of course there are other kinds of computations to perform,; such as geometry optimizations and vibrational frequency computations.; These can be specified by replacing psi4.energy(); API; with psi4.optimize(); API; or psi4.frequency(); API,; respectively.; Let’s take a look at an example of optimizing the H\(_2\)O; molecule using Hartree-Fock with a cc-pVDZ basis set.; Now, here comes the real beauty of running Psi4 interactively: above,; when we computed the energy of H\(_2\)O with HF/cc-pVDZ, we; defined the Psi4 molecule object h2o. Since we’re still in the; Python shell, as long as you executed that block of code, we can reuse; the h2o molecule object in our optimization without redefining it,; by adding the molecule=h2o argument to the psi4.optimize(); API; function:. In [5]:. psi4.set_options({'reference': 'rhf'}); psi4.optimize('scf/cc-pvdz', molecule=h2o). Optimizer: Optimization complete!. Out[5]:. -76.02703272937504. This should perform a series of gradient computations. The gradient; points which way is downhill in energy, and the optimizer then modifies; the geometry to follow the gradient. After a few cycles, the geometry; should converge with a message like Optimization complete!. As; indicated in the following table (printed by the optimizer at the end of; the computation and grep-able with ~), the energy decreases with; each step, and the maximum force on each atom also decreases with each; step (in principle, these ",MatchSource.WIKI,psi4manual/1.2.1/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi.html
https://psicode.org/psi4manual/1.2.1/psiapi.html:7702,Energy Efficiency,energy,energy,7702,",; such as geometry optimizations and vibrational frequency computations.; These can be specified by replacing psi4.energy(); API; with psi4.optimize(); API; or psi4.frequency(); API,; respectively.; Let’s take a look at an example of optimizing the H\(_2\)O; molecule using Hartree-Fock with a cc-pVDZ basis set.; Now, here comes the real beauty of running Psi4 interactively: above,; when we computed the energy of H\(_2\)O with HF/cc-pVDZ, we; defined the Psi4 molecule object h2o. Since we’re still in the; Python shell, as long as you executed that block of code, we can reuse; the h2o molecule object in our optimization without redefining it,; by adding the molecule=h2o argument to the psi4.optimize(); API; function:. In [5]:. psi4.set_options({'reference': 'rhf'}); psi4.optimize('scf/cc-pvdz', molecule=h2o). Optimizer: Optimization complete!. Out[5]:. -76.02703272937504. This should perform a series of gradient computations. The gradient; points which way is downhill in energy, and the optimizer then modifies; the geometry to follow the gradient. After a few cycles, the geometry; should converge with a message like Optimization complete!. As; indicated in the following table (printed by the optimizer at the end of; the computation and grep-able with ~), the energy decreases with; each step, and the maximum force on each atom also decreases with each; step (in principle, these numbers could increase in some iterations, but; here they do not).; --------------------------------------------------------------------------------------------------------------- ~  Step         Total Energy             Delta E       MAX Force       RMS Force        MAX Disp        RMS Disp  ~ --------------------------------------------------------------------------------------------------------------- ~     1     -76.026632734908    -76.026632734908      0.01523518      0.01245755      0.02742222      0.02277530  ~     2     -76.027022666011     -0.000389931104      0.00178779      0.0014294",MatchSource.WIKI,psi4manual/1.2.1/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi.html
https://psicode.org/psi4manual/1.2.1/psiapi.html:7995,Energy Efficiency,energy,energy,7995,"et.; Now, here comes the real beauty of running Psi4 interactively: above,; when we computed the energy of H\(_2\)O with HF/cc-pVDZ, we; defined the Psi4 molecule object h2o. Since we’re still in the; Python shell, as long as you executed that block of code, we can reuse; the h2o molecule object in our optimization without redefining it,; by adding the molecule=h2o argument to the psi4.optimize(); API; function:. In [5]:. psi4.set_options({'reference': 'rhf'}); psi4.optimize('scf/cc-pvdz', molecule=h2o). Optimizer: Optimization complete!. Out[5]:. -76.02703272937504. This should perform a series of gradient computations. The gradient; points which way is downhill in energy, and the optimizer then modifies; the geometry to follow the gradient. After a few cycles, the geometry; should converge with a message like Optimization complete!. As; indicated in the following table (printed by the optimizer at the end of; the computation and grep-able with ~), the energy decreases with; each step, and the maximum force on each atom also decreases with each; step (in principle, these numbers could increase in some iterations, but; here they do not).; --------------------------------------------------------------------------------------------------------------- ~  Step         Total Energy             Delta E       MAX Force       RMS Force        MAX Disp        RMS Disp  ~ --------------------------------------------------------------------------------------------------------------- ~     1     -76.026632734908    -76.026632734908      0.01523518      0.01245755      0.02742222      0.02277530  ~     2     -76.027022666011     -0.000389931104      0.00178779      0.00142946      0.01008137      0.00594928  ~     3     -76.027032729374     -0.000010063363      0.00014019      0.00008488      0.00077463      0.00044738  ~ --------------------------------------------------------------------------------------------------------------- ~; To get harmonic vibrational frequencies, it’s",MatchSource.WIKI,psi4manual/1.2.1/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi.html
https://psicode.org/psi4manual/1.2.1/psiapi.html:9804,Energy Efficiency,energy,energy,9804,"2729374     -0.000010063363      0.00014019      0.00008488      0.00077463      0.00044738  ~ --------------------------------------------------------------------------------------------------------------- ~; To get harmonic vibrational frequencies, it’s important to keep in mind; that the values of the vibrational frequencies are a function of the; molecular geometry. Therefore, it’s important to obtain the vibrational; frequencies AT THE OPTIMIZED GEOMETRY. Luckily, Psi4 updates the; molecule with optimized geometry as it is being optimized. So, the; optimized geometry for H\(_2\)O is stored inside the h2o; molecule object, which we can access! To compute the frequencies, all we; need to do is to again pass the molecule=h2o argument to the; psi4.frequency(); API; function:. In [6]:. scf_e, scf_wfn = psi4.frequency('scf/cc-pvdz', molecule=h2o, return_wfn=True, dertype=1). 6 displacements needed.; 1 2 3 4 5 6. Executing this cell will prompt Psi4 to compute the Hessian (second; derivative matrix) of the electronic energy with respect to nuclear; displacements. From this, it can obtain the harmonic vibrational; frequencies, given below (roundoff errors of around \(0.1\); cm\(^{-1}\) may exist):; Irrep Harmonic Frequency; (cm-1); -----------------------------------------------; A1 1775.6478; A1 4113.3795; B2 4212.1814; -----------------------------------------------. Notice the symmetry type of the normal modes is specified (A1, A1, B2).; The program also print out the normal modes in terms of Cartesian; coordinates of each atom. For example, the normal mode at \(1776\); cm\(^{-1}\) is:; Frequency: 1775.65; Force constant: 0.1193; X Y Z mass; O 0.000 0.000 -0.068 15.994915; H 0.000 0.416 0.536 1.007825; H 0.000 -0.416 0.536 1.007825. where the table shows the displacements in the X, Y, and Z dimensions; for each atom along the normal mode coordinate. (This information could; be used to animate the vibrational frequency using visualization; software.); Because the vibr",MatchSource.WIKI,psi4manual/1.2.1/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi.html
https://psicode.org/psi4manual/1.2.1/psiapi.html:11089,Energy Efficiency,energy,energy,11089,"--------------------------------------; A1 1775.6478; A1 4113.3795; B2 4212.1814; -----------------------------------------------. Notice the symmetry type of the normal modes is specified (A1, A1, B2).; The program also print out the normal modes in terms of Cartesian; coordinates of each atom. For example, the normal mode at \(1776\); cm\(^{-1}\) is:; Frequency: 1775.65; Force constant: 0.1193; X Y Z mass; O 0.000 0.000 -0.068 15.994915; H 0.000 0.416 0.536 1.007825; H 0.000 -0.416 0.536 1.007825. where the table shows the displacements in the X, Y, and Z dimensions; for each atom along the normal mode coordinate. (This information could; be used to animate the vibrational frequency using visualization; software.); Because the vibrational frequencies are available, a thermodynamics; analysis is automatically performed at the end of the computation. You; can see this in the next section of the output file output.dat. The; vibrational frequencies are sufficient to obtain vibrational; contributions to enthalpy (H), entropy (S), and Gibbs free energy (G).; Similarly, the molecular geometry is used to obtain rotational; constants, which are then used to obtain rotational contributions to H,; S, and G.; Note: Psi4 has several synonyms for the functions called in this; example. For instance, psi4.frequency(); API; will compute molecular vibrational frequencies, and psi4.optimize(); API; will perform a geometry optimization. IV. Analysis of Intermolecular Interactions¶; Now let’s consider something a little more interesting. Psi4 contains; code to analyze the nature of intermolecular interactions between two; molecules, via symmetry-adapted perturbation theory (SAPT); (Jeziorski:1994:1887).; This kind of analysis gives a lot of insight into the nature of; intermolecular interactions, and Psi4 makes these computations easier; than ever.; For a SAPT computation, the input needs to provide information on two; distinct molecules. This is very easy, we just give a Z-matrix or ",MatchSource.WIKI,psi4manual/1.2.1/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi.html
https://psicode.org/psi4manual/1.2.1/psiapi.html:11686,Energy Efficiency,adapt,adapted,11686,"s information could; be used to animate the vibrational frequency using visualization; software.); Because the vibrational frequencies are available, a thermodynamics; analysis is automatically performed at the end of the computation. You; can see this in the next section of the output file output.dat. The; vibrational frequencies are sufficient to obtain vibrational; contributions to enthalpy (H), entropy (S), and Gibbs free energy (G).; Similarly, the molecular geometry is used to obtain rotational; constants, which are then used to obtain rotational contributions to H,; S, and G.; Note: Psi4 has several synonyms for the functions called in this; example. For instance, psi4.frequency(); API; will compute molecular vibrational frequencies, and psi4.optimize(); API; will perform a geometry optimization. IV. Analysis of Intermolecular Interactions¶; Now let’s consider something a little more interesting. Psi4 contains; code to analyze the nature of intermolecular interactions between two; molecules, via symmetry-adapted perturbation theory (SAPT); (Jeziorski:1994:1887).; This kind of analysis gives a lot of insight into the nature of; intermolecular interactions, and Psi4 makes these computations easier; than ever.; For a SAPT computation, the input needs to provide information on two; distinct molecules. This is very easy, we just give a Z-matrix or set of; Cartesian coordinates for each molecule, and separate the two with two; dashes, like this:. In [7]:. # Example SAPT computation for ethene*ethyne (*i.e.*, ethylene*acetylene).; # Test case 16 from S22 Database. dimer = psi4.geometry(""""""; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; units angstrom; """"""). Here’s the second half of the input,",MatchSource.WIKI,psi4manual/1.2.1/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi.html
https://psicode.org/psi4manual/1.2.1/psiapi.html:12781,Energy Efficiency,energy,energy,12781,"ure of; intermolecular interactions, and Psi4 makes these computations easier; than ever.; For a SAPT computation, the input needs to provide information on two; distinct molecules. This is very easy, we just give a Z-matrix or set of; Cartesian coordinates for each molecule, and separate the two with two; dashes, like this:. In [7]:. # Example SAPT computation for ethene*ethyne (*i.e.*, ethylene*acetylene).; # Test case 16 from S22 Database. dimer = psi4.geometry(""""""; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; units angstrom; """"""). Here’s the second half of the input, where we specify the computation; options:. In [8]:. psi4.set_options({'scf_type': 'df',; 'freeze_core': 'true'}). psi4.energy('sapt0/jun-cc-pvdz', molecule=dimer). Out[8]:. -0.0022355825227244703. All of the options we have currently set using psi4.set_options(); API; are “global” options (meaning that they are visible to all parts of the; program). Most common Psi4 options can be set like this. If an option; needs to be visible only to one part of the program (e.g., we only; want to increase the energy convergence in the SCF code, but not the; rest of the code), it can be set by with the; psi4.set_module_options(); API; function, psi4.set_module_options('scf', {'e_convergence': '1e-8'}).; Note: The arguments to the functions we’ve used so far, like; psi4.set_options(); API,; psi4.set_module_options(); API,; psi4.energy(); API,; psi4.optimize(); API,; psi4.frequency(); API,; etc., are case-insensitive.; Back to our SAPT example, we have found that for basic-level SAPT; computations (i.e., SAPT0), a good error cancellation is found; (Hohenstein:2012:WIREs); with the jun-cc-pVDZ basis (this is the usual aug-cc-pVDZ basis, but",MatchSource.WIKI,psi4manual/1.2.1/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi.html
https://psicode.org/psi4manual/1.2.1/psiapi.html:13164,Energy Efficiency,energy,energy,13164,"lene*acetylene).; # Test case 16 from S22 Database. dimer = psi4.geometry(""""""; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; units angstrom; """"""). Here’s the second half of the input, where we specify the computation; options:. In [8]:. psi4.set_options({'scf_type': 'df',; 'freeze_core': 'true'}). psi4.energy('sapt0/jun-cc-pvdz', molecule=dimer). Out[8]:. -0.0022355825227244703. All of the options we have currently set using psi4.set_options(); API; are “global” options (meaning that they are visible to all parts of the; program). Most common Psi4 options can be set like this. If an option; needs to be visible only to one part of the program (e.g., we only; want to increase the energy convergence in the SCF code, but not the; rest of the code), it can be set by with the; psi4.set_module_options(); API; function, psi4.set_module_options('scf', {'e_convergence': '1e-8'}).; Note: The arguments to the functions we’ve used so far, like; psi4.set_options(); API,; psi4.set_module_options(); API,; psi4.energy(); API,; psi4.optimize(); API,; psi4.frequency(); API,; etc., are case-insensitive.; Back to our SAPT example, we have found that for basic-level SAPT; computations (i.e., SAPT0), a good error cancellation is found; (Hohenstein:2012:WIREs); with the jun-cc-pVDZ basis (this is the usual aug-cc-pVDZ basis, but; without diffuse functions on hydrogen and without diffuse \(d\); functions on heavy atoms); (Papajak:2011:10).; So, we’ll use that as our standard basis set. The SAPT code is designed; to use density fitting techniques, because they introduce minimal errors; while providing much faster computations; (Hohenstein:2010:184111,Hohenstein:2010:014101).; Since we’re using density fitting for the ",MatchSource.WIKI,psi4manual/1.2.1/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi.html
https://psicode.org/psi4manual/1.2.1/psiapi.html:13487,Energy Efficiency,energy,energy,13487,"0000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; units angstrom; """"""). Here’s the second half of the input, where we specify the computation; options:. In [8]:. psi4.set_options({'scf_type': 'df',; 'freeze_core': 'true'}). psi4.energy('sapt0/jun-cc-pvdz', molecule=dimer). Out[8]:. -0.0022355825227244703. All of the options we have currently set using psi4.set_options(); API; are “global” options (meaning that they are visible to all parts of the; program). Most common Psi4 options can be set like this. If an option; needs to be visible only to one part of the program (e.g., we only; want to increase the energy convergence in the SCF code, but not the; rest of the code), it can be set by with the; psi4.set_module_options(); API; function, psi4.set_module_options('scf', {'e_convergence': '1e-8'}).; Note: The arguments to the functions we’ve used so far, like; psi4.set_options(); API,; psi4.set_module_options(); API,; psi4.energy(); API,; psi4.optimize(); API,; psi4.frequency(); API,; etc., are case-insensitive.; Back to our SAPT example, we have found that for basic-level SAPT; computations (i.e., SAPT0), a good error cancellation is found; (Hohenstein:2012:WIREs); with the jun-cc-pVDZ basis (this is the usual aug-cc-pVDZ basis, but; without diffuse functions on hydrogen and without diffuse \(d\); functions on heavy atoms); (Papajak:2011:10).; So, we’ll use that as our standard basis set. The SAPT code is designed; to use density fitting techniques, because they introduce minimal errors; while providing much faster computations; (Hohenstein:2010:184111,Hohenstein:2010:014101).; Since we’re using density fitting for the SAPT, we might as well also; use it for the Hartree-Fock computations that are performed as part of; the SAPT. We can specify that by adding 'scf_type': 'df' to the; dictionary passed to psi4.set_options().; Density fitting procedures require the use of auxiliary basis sets that; pair with the prima",MatchSource.WIKI,psi4manual/1.2.1/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi.html
https://psicode.org/psi4manual/1.2.1/psiapi.html:15141,Energy Efficiency,energy,energy,15141,"e’re using density fitting for the SAPT, we might as well also; use it for the Hartree-Fock computations that are performed as part of; the SAPT. We can specify that by adding 'scf_type': 'df' to the; dictionary passed to psi4.set_options().; Density fitting procedures require the use of auxiliary basis sets that; pair with the primary basis set. Fortunately, Psi4 is usually smart; enough to figure out what auxiliary basis sets are needed for a given; computation. In this case, jun-cc-pVDZ is a standard enough basis set; (just a simple truncation of the very popular aug-cc-pVDZ basis set); that Psi4 correctly guesses that we want the jun-cc-pVDZ-JKFIT auxiliary; basis for the Hartree-Fock, and the jun-cc-pVDZ-RI basis set for the; SAPT procedure.; To speed up the computation a little, we also tell the SAPT procedure to; freeze the core electrons by adding 'freeze_core': 'true' to the; dictionary passed to psi4.set_options(). The SAPT procedure is; invoked by psi4.energy('sapt0/jun-cc-pvdz', molecule=dimer). Here,; Psi4 knows to automatically run two monomer computations and a dimer; computation and then use these results to perform the SAPT analysis. The; various energy components are printed at the end of the output, in; addition to the total SAPT0 interaction energy. An explanation of the; various energy components can be found in the review by Jeziorski,; Moszynski, and Szalewicz; (Jeziorski:1994:1887),; and this is discussed in more detail in the SAPT; section of the Psi4; manual.; For now, we’ll note that most of the SAPT energy components are; negative; this means those are attractive contributions (the zero of; energy in a SAPT computation is defined as non-interacting monomers).; The exchange contributions are positive (repulsive). In this example,; the most attractive contribution between ethylene and acetylene is an; electrostatic term of \(-2.12\) kcal/mol (Elst10,r where the 1; indicates the first-order perturbation theory result with respect to the; int",MatchSource.WIKI,psi4manual/1.2.1/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi.html
https://psicode.org/psi4manual/1.2.1/psiapi.html:15345,Energy Efficiency,energy,energy,15345,"et_options().; Density fitting procedures require the use of auxiliary basis sets that; pair with the primary basis set. Fortunately, Psi4 is usually smart; enough to figure out what auxiliary basis sets are needed for a given; computation. In this case, jun-cc-pVDZ is a standard enough basis set; (just a simple truncation of the very popular aug-cc-pVDZ basis set); that Psi4 correctly guesses that we want the jun-cc-pVDZ-JKFIT auxiliary; basis for the Hartree-Fock, and the jun-cc-pVDZ-RI basis set for the; SAPT procedure.; To speed up the computation a little, we also tell the SAPT procedure to; freeze the core electrons by adding 'freeze_core': 'true' to the; dictionary passed to psi4.set_options(). The SAPT procedure is; invoked by psi4.energy('sapt0/jun-cc-pvdz', molecule=dimer). Here,; Psi4 knows to automatically run two monomer computations and a dimer; computation and then use these results to perform the SAPT analysis. The; various energy components are printed at the end of the output, in; addition to the total SAPT0 interaction energy. An explanation of the; various energy components can be found in the review by Jeziorski,; Moszynski, and Szalewicz; (Jeziorski:1994:1887),; and this is discussed in more detail in the SAPT; section of the Psi4; manual.; For now, we’ll note that most of the SAPT energy components are; negative; this means those are attractive contributions (the zero of; energy in a SAPT computation is defined as non-interacting monomers).; The exchange contributions are positive (repulsive). In this example,; the most attractive contribution between ethylene and acetylene is an; electrostatic term of \(-2.12\) kcal/mol (Elst10,r where the 1; indicates the first-order perturbation theory result with respect to the; intermolecular interaction, and the 0 indicates zeroth-order with; respect to the intramolecular electron correlation). The next most; attractive contribution is the Disp20 term (second order; intermolecular dispersion, which looks ",MatchSource.WIKI,psi4manual/1.2.1/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi.html
https://psicode.org/psi4manual/1.2.1/psiapi.html:15445,Energy Efficiency,energy,energy,15445,"et_options().; Density fitting procedures require the use of auxiliary basis sets that; pair with the primary basis set. Fortunately, Psi4 is usually smart; enough to figure out what auxiliary basis sets are needed for a given; computation. In this case, jun-cc-pVDZ is a standard enough basis set; (just a simple truncation of the very popular aug-cc-pVDZ basis set); that Psi4 correctly guesses that we want the jun-cc-pVDZ-JKFIT auxiliary; basis for the Hartree-Fock, and the jun-cc-pVDZ-RI basis set for the; SAPT procedure.; To speed up the computation a little, we also tell the SAPT procedure to; freeze the core electrons by adding 'freeze_core': 'true' to the; dictionary passed to psi4.set_options(). The SAPT procedure is; invoked by psi4.energy('sapt0/jun-cc-pvdz', molecule=dimer). Here,; Psi4 knows to automatically run two monomer computations and a dimer; computation and then use these results to perform the SAPT analysis. The; various energy components are printed at the end of the output, in; addition to the total SAPT0 interaction energy. An explanation of the; various energy components can be found in the review by Jeziorski,; Moszynski, and Szalewicz; (Jeziorski:1994:1887),; and this is discussed in more detail in the SAPT; section of the Psi4; manual.; For now, we’ll note that most of the SAPT energy components are; negative; this means those are attractive contributions (the zero of; energy in a SAPT computation is defined as non-interacting monomers).; The exchange contributions are positive (repulsive). In this example,; the most attractive contribution between ethylene and acetylene is an; electrostatic term of \(-2.12\) kcal/mol (Elst10,r where the 1; indicates the first-order perturbation theory result with respect to the; intermolecular interaction, and the 0 indicates zeroth-order with; respect to the intramolecular electron correlation). The next most; attractive contribution is the Disp20 term (second order; intermolecular dispersion, which looks ",MatchSource.WIKI,psi4manual/1.2.1/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi.html
https://psicode.org/psi4manual/1.2.1/psiapi.html:15484,Energy Efficiency,energy,energy,15484,"re out what auxiliary basis sets are needed for a given; computation. In this case, jun-cc-pVDZ is a standard enough basis set; (just a simple truncation of the very popular aug-cc-pVDZ basis set); that Psi4 correctly guesses that we want the jun-cc-pVDZ-JKFIT auxiliary; basis for the Hartree-Fock, and the jun-cc-pVDZ-RI basis set for the; SAPT procedure.; To speed up the computation a little, we also tell the SAPT procedure to; freeze the core electrons by adding 'freeze_core': 'true' to the; dictionary passed to psi4.set_options(). The SAPT procedure is; invoked by psi4.energy('sapt0/jun-cc-pvdz', molecule=dimer). Here,; Psi4 knows to automatically run two monomer computations and a dimer; computation and then use these results to perform the SAPT analysis. The; various energy components are printed at the end of the output, in; addition to the total SAPT0 interaction energy. An explanation of the; various energy components can be found in the review by Jeziorski,; Moszynski, and Szalewicz; (Jeziorski:1994:1887),; and this is discussed in more detail in the SAPT; section of the Psi4; manual.; For now, we’ll note that most of the SAPT energy components are; negative; this means those are attractive contributions (the zero of; energy in a SAPT computation is defined as non-interacting monomers).; The exchange contributions are positive (repulsive). In this example,; the most attractive contribution between ethylene and acetylene is an; electrostatic term of \(-2.12\) kcal/mol (Elst10,r where the 1; indicates the first-order perturbation theory result with respect to the; intermolecular interaction, and the 0 indicates zeroth-order with; respect to the intramolecular electron correlation). The next most; attractive contribution is the Disp20 term (second order; intermolecular dispersion, which looks like MP2 in which one excitation; is placed on each monomer), contributing an attraction of \(-1.21\); kcal/mol. It is not surprising that the electrostatic contribution ",MatchSource.WIKI,psi4manual/1.2.1/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi.html
https://psicode.org/psi4manual/1.2.1/psiapi.html:15716,Energy Efficiency,energy,energy,15716,"ctly guesses that we want the jun-cc-pVDZ-JKFIT auxiliary; basis for the Hartree-Fock, and the jun-cc-pVDZ-RI basis set for the; SAPT procedure.; To speed up the computation a little, we also tell the SAPT procedure to; freeze the core electrons by adding 'freeze_core': 'true' to the; dictionary passed to psi4.set_options(). The SAPT procedure is; invoked by psi4.energy('sapt0/jun-cc-pvdz', molecule=dimer). Here,; Psi4 knows to automatically run two monomer computations and a dimer; computation and then use these results to perform the SAPT analysis. The; various energy components are printed at the end of the output, in; addition to the total SAPT0 interaction energy. An explanation of the; various energy components can be found in the review by Jeziorski,; Moszynski, and Szalewicz; (Jeziorski:1994:1887),; and this is discussed in more detail in the SAPT; section of the Psi4; manual.; For now, we’ll note that most of the SAPT energy components are; negative; this means those are attractive contributions (the zero of; energy in a SAPT computation is defined as non-interacting monomers).; The exchange contributions are positive (repulsive). In this example,; the most attractive contribution between ethylene and acetylene is an; electrostatic term of \(-2.12\) kcal/mol (Elst10,r where the 1; indicates the first-order perturbation theory result with respect to the; intermolecular interaction, and the 0 indicates zeroth-order with; respect to the intramolecular electron correlation). The next most; attractive contribution is the Disp20 term (second order; intermolecular dispersion, which looks like MP2 in which one excitation; is placed on each monomer), contributing an attraction of \(-1.21\); kcal/mol. It is not surprising that the electrostatic contribution is; dominant, because the geometry chosen for this example has the acetylene; perpendicular to the ethylene, with the acetylene hydrogen pointing; directly at the double bond in ethylene; this will be attractive b",MatchSource.WIKI,psi4manual/1.2.1/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi.html
https://psicode.org/psi4manual/1.2.1/psiapi.html:15809,Energy Efficiency,energy,energy,15809,"ctly guesses that we want the jun-cc-pVDZ-JKFIT auxiliary; basis for the Hartree-Fock, and the jun-cc-pVDZ-RI basis set for the; SAPT procedure.; To speed up the computation a little, we also tell the SAPT procedure to; freeze the core electrons by adding 'freeze_core': 'true' to the; dictionary passed to psi4.set_options(). The SAPT procedure is; invoked by psi4.energy('sapt0/jun-cc-pvdz', molecule=dimer). Here,; Psi4 knows to automatically run two monomer computations and a dimer; computation and then use these results to perform the SAPT analysis. The; various energy components are printed at the end of the output, in; addition to the total SAPT0 interaction energy. An explanation of the; various energy components can be found in the review by Jeziorski,; Moszynski, and Szalewicz; (Jeziorski:1994:1887),; and this is discussed in more detail in the SAPT; section of the Psi4; manual.; For now, we’ll note that most of the SAPT energy components are; negative; this means those are attractive contributions (the zero of; energy in a SAPT computation is defined as non-interacting monomers).; The exchange contributions are positive (repulsive). In this example,; the most attractive contribution between ethylene and acetylene is an; electrostatic term of \(-2.12\) kcal/mol (Elst10,r where the 1; indicates the first-order perturbation theory result with respect to the; intermolecular interaction, and the 0 indicates zeroth-order with; respect to the intramolecular electron correlation). The next most; attractive contribution is the Disp20 term (second order; intermolecular dispersion, which looks like MP2 in which one excitation; is placed on each monomer), contributing an attraction of \(-1.21\); kcal/mol. It is not surprising that the electrostatic contribution is; dominant, because the geometry chosen for this example has the acetylene; perpendicular to the ethylene, with the acetylene hydrogen pointing; directly at the double bond in ethylene; this will be attractive b",MatchSource.WIKI,psi4manual/1.2.1/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi.html
https://psicode.org/psi4manual/1.2.1/psiapi.html:16832,Energy Efficiency,charge,charge,16832,"APT energy components are; negative; this means those are attractive contributions (the zero of; energy in a SAPT computation is defined as non-interacting monomers).; The exchange contributions are positive (repulsive). In this example,; the most attractive contribution between ethylene and acetylene is an; electrostatic term of \(-2.12\) kcal/mol (Elst10,r where the 1; indicates the first-order perturbation theory result with respect to the; intermolecular interaction, and the 0 indicates zeroth-order with; respect to the intramolecular electron correlation). The next most; attractive contribution is the Disp20 term (second order; intermolecular dispersion, which looks like MP2 in which one excitation; is placed on each monomer), contributing an attraction of \(-1.21\); kcal/mol. It is not surprising that the electrostatic contribution is; dominant, because the geometry chosen for this example has the acetylene; perpendicular to the ethylene, with the acetylene hydrogen pointing; directly at the double bond in ethylene; this will be attractive because; the H atoms in acetylene bear a partial positive charge, while the; electron rich double bond in ethylene bears a partial negative charge.; At the same time, the dispersion interaction should be smaller because; the perpendicular geometry does not allow much overlap between the; monomers. Hence, the SAPT analysis helps clarify (and quantify) our; physical understanding about the interaction between the two monomers. V. Potential Surface Scans and Counterpoise Correction Made Easy¶; Finally, let’s consider an example which highlights the advantages of; being able to interact with Psi4 directly with Python.; Suppose you want to do a limited potential energy surface scan, such as; computing the interaction energy between two neon atoms at various; interatomic distances. One simple but unappealing way to do this is to; generate separate geometries for each distance to be studied. Instead,; we can leverage Python loops an",MatchSource.WIKI,psi4manual/1.2.1/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi.html
https://psicode.org/psi4manual/1.2.1/psiapi.html:16914,Energy Efficiency,charge,charge,16914,"APT energy components are; negative; this means those are attractive contributions (the zero of; energy in a SAPT computation is defined as non-interacting monomers).; The exchange contributions are positive (repulsive). In this example,; the most attractive contribution between ethylene and acetylene is an; electrostatic term of \(-2.12\) kcal/mol (Elst10,r where the 1; indicates the first-order perturbation theory result with respect to the; intermolecular interaction, and the 0 indicates zeroth-order with; respect to the intramolecular electron correlation). The next most; attractive contribution is the Disp20 term (second order; intermolecular dispersion, which looks like MP2 in which one excitation; is placed on each monomer), contributing an attraction of \(-1.21\); kcal/mol. It is not surprising that the electrostatic contribution is; dominant, because the geometry chosen for this example has the acetylene; perpendicular to the ethylene, with the acetylene hydrogen pointing; directly at the double bond in ethylene; this will be attractive because; the H atoms in acetylene bear a partial positive charge, while the; electron rich double bond in ethylene bears a partial negative charge.; At the same time, the dispersion interaction should be smaller because; the perpendicular geometry does not allow much overlap between the; monomers. Hence, the SAPT analysis helps clarify (and quantify) our; physical understanding about the interaction between the two monomers. V. Potential Surface Scans and Counterpoise Correction Made Easy¶; Finally, let’s consider an example which highlights the advantages of; being able to interact with Psi4 directly with Python.; Suppose you want to do a limited potential energy surface scan, such as; computing the interaction energy between two neon atoms at various; interatomic distances. One simple but unappealing way to do this is to; generate separate geometries for each distance to be studied. Instead,; we can leverage Python loops an",MatchSource.WIKI,psi4manual/1.2.1/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi.html
https://psicode.org/psi4manual/1.2.1/psiapi.html:17440,Energy Efficiency,energy,energy,17440,"ion of \(-1.21\); kcal/mol. It is not surprising that the electrostatic contribution is; dominant, because the geometry chosen for this example has the acetylene; perpendicular to the ethylene, with the acetylene hydrogen pointing; directly at the double bond in ethylene; this will be attractive because; the H atoms in acetylene bear a partial positive charge, while the; electron rich double bond in ethylene bears a partial negative charge.; At the same time, the dispersion interaction should be smaller because; the perpendicular geometry does not allow much overlap between the; monomers. Hence, the SAPT analysis helps clarify (and quantify) our; physical understanding about the interaction between the two monomers. V. Potential Surface Scans and Counterpoise Correction Made Easy¶; Finally, let’s consider an example which highlights the advantages of; being able to interact with Psi4 directly with Python.; Suppose you want to do a limited potential energy surface scan, such as; computing the interaction energy between two neon atoms at various; interatomic distances. One simple but unappealing way to do this is to; generate separate geometries for each distance to be studied. Instead,; we can leverage Python loops and string formatting to make our lives; simpler. Additionally, let’s suppose you want to do counterpoise (CP); correction to compute interaction energies. Counterpoise correction; involves computing the dimer energy and then subtracting out the; energies of the two monomers, each evaluated in the dimer basis. Again,; each of these computations could be run in a separate input file, but; because counterpoise correction is a fairly standard procedure for; intermolecular interactions, Psi4 knows about it and has a built-in; routine to perform counterpoise correction. It only needs to know what; method you want to do the couterpoise correction on (here, let’s; consider CCSD(T)), and it needs to know what’s monomer A and what’s; monomer B. This last issue of sp",MatchSource.WIKI,psi4manual/1.2.1/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi.html
https://psicode.org/psi4manual/1.2.1/psiapi.html:17496,Energy Efficiency,energy,energy,17496,"ion of \(-1.21\); kcal/mol. It is not surprising that the electrostatic contribution is; dominant, because the geometry chosen for this example has the acetylene; perpendicular to the ethylene, with the acetylene hydrogen pointing; directly at the double bond in ethylene; this will be attractive because; the H atoms in acetylene bear a partial positive charge, while the; electron rich double bond in ethylene bears a partial negative charge.; At the same time, the dispersion interaction should be smaller because; the perpendicular geometry does not allow much overlap between the; monomers. Hence, the SAPT analysis helps clarify (and quantify) our; physical understanding about the interaction between the two monomers. V. Potential Surface Scans and Counterpoise Correction Made Easy¶; Finally, let’s consider an example which highlights the advantages of; being able to interact with Psi4 directly with Python.; Suppose you want to do a limited potential energy surface scan, such as; computing the interaction energy between two neon atoms at various; interatomic distances. One simple but unappealing way to do this is to; generate separate geometries for each distance to be studied. Instead,; we can leverage Python loops and string formatting to make our lives; simpler. Additionally, let’s suppose you want to do counterpoise (CP); correction to compute interaction energies. Counterpoise correction; involves computing the dimer energy and then subtracting out the; energies of the two monomers, each evaluated in the dimer basis. Again,; each of these computations could be run in a separate input file, but; because counterpoise correction is a fairly standard procedure for; intermolecular interactions, Psi4 knows about it and has a built-in; routine to perform counterpoise correction. It only needs to know what; method you want to do the couterpoise correction on (here, let’s; consider CCSD(T)), and it needs to know what’s monomer A and what’s; monomer B. This last issue of sp",MatchSource.WIKI,psi4manual/1.2.1/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi.html
https://psicode.org/psi4manual/1.2.1/psiapi.html:17921,Energy Efficiency,energy,energy,17921," dispersion interaction should be smaller because; the perpendicular geometry does not allow much overlap between the; monomers. Hence, the SAPT analysis helps clarify (and quantify) our; physical understanding about the interaction between the two monomers. V. Potential Surface Scans and Counterpoise Correction Made Easy¶; Finally, let’s consider an example which highlights the advantages of; being able to interact with Psi4 directly with Python.; Suppose you want to do a limited potential energy surface scan, such as; computing the interaction energy between two neon atoms at various; interatomic distances. One simple but unappealing way to do this is to; generate separate geometries for each distance to be studied. Instead,; we can leverage Python loops and string formatting to make our lives; simpler. Additionally, let’s suppose you want to do counterpoise (CP); correction to compute interaction energies. Counterpoise correction; involves computing the dimer energy and then subtracting out the; energies of the two monomers, each evaluated in the dimer basis. Again,; each of these computations could be run in a separate input file, but; because counterpoise correction is a fairly standard procedure for; intermolecular interactions, Psi4 knows about it and has a built-in; routine to perform counterpoise correction. It only needs to know what; method you want to do the couterpoise correction on (here, let’s; consider CCSD(T)), and it needs to know what’s monomer A and what’s; monomer B. This last issue of specifying the monomers separately was; already dealt with in the previous SAPT example, where we saw that two; dashes in the psi4.geometry() string can be used to separate; monomers.; So, we’re going to do counterpoise-corrected CCSD(T) energies for; Ne\(_2\) at a series of different interatomic distances. And let’s; print out a table of the interatomic distances we’ve considered, and the; CP-corrected CCSD(T) interaction energies (in kcal/mol) at each; geometry:",MatchSource.WIKI,psi4manual/1.2.1/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi.html
https://psicode.org/psi4manual/1.2.1/psiapi.html:18976,Energy Efficiency,energy,energy,18976,"each evaluated in the dimer basis. Again,; each of these computations could be run in a separate input file, but; because counterpoise correction is a fairly standard procedure for; intermolecular interactions, Psi4 knows about it and has a built-in; routine to perform counterpoise correction. It only needs to know what; method you want to do the couterpoise correction on (here, let’s; consider CCSD(T)), and it needs to know what’s monomer A and what’s; monomer B. This last issue of specifying the monomers separately was; already dealt with in the previous SAPT example, where we saw that two; dashes in the psi4.geometry() string can be used to separate; monomers.; So, we’re going to do counterpoise-corrected CCSD(T) energies for; Ne\(_2\) at a series of different interatomic distances. And let’s; print out a table of the interatomic distances we’ve considered, and the; CP-corrected CCSD(T) interaction energies (in kcal/mol) at each; geometry:. In [9]:. #! Example potential energy surface scan and CP-correction for Ne2. ne2_geometry = """"""; Ne; --; Ne 1 {0}; """""". Rvals = [2.5, 3.0, 4.0]. psi4.set_options({'freeze_core': 'true'}). # Initialize a blank dictionary of counterpoise corrected energies; # (Need this for the syntax below to work). ecp = {}. for R in Rvals:; ne2 = psi4.geometry(ne2_geometry.format(R)); ecp[R] = psi4.energy('ccsd(t)/aug-cc-pvdz', bsse_type='cp', molecule=ne2). # Prints to screen; print(""CP-corrected CCSD(T)/aug-cc-pVDZ Interaction Energies\n\n""); print("" R [Ang] E_int [kcal/mol] ""); print(""---------------------------------------------------------""); for R in Rvals:; e = ecp[R] * psi4.constants.hartree2kcalmol; print("" {:3.1f} {:1.6f}"".format(R, e)). # Prints to output.dat; psi4.core.print_out(""CP-corrected CCSD(T)/aug-cc-pVDZ Interaction Energies\n\n""); psi4.core.print_out("" R [Ang] E_int [kcal/mol] \n""); psi4.core.print_out(""---------------------------------------------------------\n""); for R in Rvals:; e = ecp[R] * psi4.constants.hartree2kcal",MatchSource.WIKI,psi4manual/1.2.1/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi.html
https://psicode.org/psi4manual/1.2.1/psiapi.html:19332,Energy Efficiency,energy,energy,19332," (here, let’s; consider CCSD(T)), and it needs to know what’s monomer A and what’s; monomer B. This last issue of specifying the monomers separately was; already dealt with in the previous SAPT example, where we saw that two; dashes in the psi4.geometry() string can be used to separate; monomers.; So, we’re going to do counterpoise-corrected CCSD(T) energies for; Ne\(_2\) at a series of different interatomic distances. And let’s; print out a table of the interatomic distances we’ve considered, and the; CP-corrected CCSD(T) interaction energies (in kcal/mol) at each; geometry:. In [9]:. #! Example potential energy surface scan and CP-correction for Ne2. ne2_geometry = """"""; Ne; --; Ne 1 {0}; """""". Rvals = [2.5, 3.0, 4.0]. psi4.set_options({'freeze_core': 'true'}). # Initialize a blank dictionary of counterpoise corrected energies; # (Need this for the syntax below to work). ecp = {}. for R in Rvals:; ne2 = psi4.geometry(ne2_geometry.format(R)); ecp[R] = psi4.energy('ccsd(t)/aug-cc-pvdz', bsse_type='cp', molecule=ne2). # Prints to screen; print(""CP-corrected CCSD(T)/aug-cc-pVDZ Interaction Energies\n\n""); print("" R [Ang] E_int [kcal/mol] ""); print(""---------------------------------------------------------""); for R in Rvals:; e = ecp[R] * psi4.constants.hartree2kcalmol; print("" {:3.1f} {:1.6f}"".format(R, e)). # Prints to output.dat; psi4.core.print_out(""CP-corrected CCSD(T)/aug-cc-pVDZ Interaction Energies\n\n""); psi4.core.print_out("" R [Ang] E_int [kcal/mol] \n""); psi4.core.print_out(""---------------------------------------------------------\n""); for R in Rvals:; e = ecp[R] * psi4.constants.hartree2kcalmol; psi4.core.print_out("" {:3.1f} {:1.6f}\n"".format(R, e)). CP-corrected CCSD(T)/aug-cc-pVDZ Interaction Energies. R [Ang] E_int [kcal/mol]; ---------------------------------------------------------; 2.5 0.758605; 3.0 0.015968; 4.0 -0.016215. First, you can see the geometry string ne2_geometry has a two dashes; to separate the monomers from each other. Also note we’ve us",MatchSource.WIKI,psi4manual/1.2.1/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi.html
https://psicode.org/psi4manual/1.2.1/psiapi.html:20628,Energy Efficiency,energy,energy,20628,"artree2kcalmol; print("" {:3.1f} {:1.6f}"".format(R, e)). # Prints to output.dat; psi4.core.print_out(""CP-corrected CCSD(T)/aug-cc-pVDZ Interaction Energies\n\n""); psi4.core.print_out("" R [Ang] E_int [kcal/mol] \n""); psi4.core.print_out(""---------------------------------------------------------\n""); for R in Rvals:; e = ecp[R] * psi4.constants.hartree2kcalmol; psi4.core.print_out("" {:3.1f} {:1.6f}\n"".format(R, e)). CP-corrected CCSD(T)/aug-cc-pVDZ Interaction Energies. R [Ang] E_int [kcal/mol]; ---------------------------------------------------------; 2.5 0.758605; 3.0 0.015968; 4.0 -0.016215. First, you can see the geometry string ne2_geometry has a two dashes; to separate the monomers from each other. Also note we’ve used a; Z-matrix to specify the geometry, and we’ve used a variable (R) as; the interatomic distance. We have not specified the value of R in; the ne2_geometry string like we normally would. That’s because we; are going to vary it during the scan across the potential energy; surface, by using a Python loop over the list of interatomic distances; Rvals. Before we are able to pass our molecule to Psi4, we need to; do two things. First, we must set the value of the intermolecular; separation in our Z-matrix (by using Python 3 string; formatting); to the particular value of R. Second, we need to turn the Z-matrix; string into a Psi4 molecule, by passing it to; `psi4.geometry() <http://psicode.org/psi4manual/master/api/psi4.driver.geometry.html#psi4.driver.geometry>`__.; The argument bsse_type='cp' tells Psi4 to perform counterpoise (CP); correction on the dimer to compute the CCSD(T)/aug-cc-pVDZ interaction; energy, which is stored in our ecp dictionary at each iteration of; our Python loop. Note that we didn’t need to specify ghost atoms, and we; didn’t need to call the monomer and dimer computations separately. Psi4; does it all for us, automatically.; Near the very end of the output file output.dat, the counterpoise; correction Python function will prin",MatchSource.WIKI,psi4manual/1.2.1/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi.html
https://psicode.org/psi4manual/1.2.1/psiapi.html:21278,Energy Efficiency,energy,energy,21278,"ee the geometry string ne2_geometry has a two dashes; to separate the monomers from each other. Also note we’ve used a; Z-matrix to specify the geometry, and we’ve used a variable (R) as; the interatomic distance. We have not specified the value of R in; the ne2_geometry string like we normally would. That’s because we; are going to vary it during the scan across the potential energy; surface, by using a Python loop over the list of interatomic distances; Rvals. Before we are able to pass our molecule to Psi4, we need to; do two things. First, we must set the value of the intermolecular; separation in our Z-matrix (by using Python 3 string; formatting); to the particular value of R. Second, we need to turn the Z-matrix; string into a Psi4 molecule, by passing it to; `psi4.geometry() <http://psicode.org/psi4manual/master/api/psi4.driver.geometry.html#psi4.driver.geometry>`__.; The argument bsse_type='cp' tells Psi4 to perform counterpoise (CP); correction on the dimer to compute the CCSD(T)/aug-cc-pVDZ interaction; energy, which is stored in our ecp dictionary at each iteration of; our Python loop. Note that we didn’t need to specify ghost atoms, and we; didn’t need to call the monomer and dimer computations separately. Psi4; does it all for us, automatically.; Near the very end of the output file output.dat, the counterpoise; correction Python function will print a nice summary of the results of; the counterpoise computation (the energies of the dimer, of monomer 1; with the ghost functions of monomer 2, of monomer 2 with the ghost; functions of monomer 1, and the overall counterpoise corrected; interaction energy):; N-Body: Computing complex (1/2) with fragments (2,) in the basis of fragments (1, 2).; ...; N-Body: Complex Energy (fragments = (2,), basis = (1, 2): -128.70932405488924); ...; N-Body: Computing complex (2/2) with fragments (1,) in the basis of fragments (1, 2).; ...; N-Body: Complex Energy (fragments = (1,), basis = (1, 2): -128.70932405488935); ...; N-",MatchSource.WIKI,psi4manual/1.2.1/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi.html
https://psicode.org/psi4manual/1.2.1/psiapi.html:21883,Energy Efficiency,energy,energy,21883," do two things. First, we must set the value of the intermolecular; separation in our Z-matrix (by using Python 3 string; formatting); to the particular value of R. Second, we need to turn the Z-matrix; string into a Psi4 molecule, by passing it to; `psi4.geometry() <http://psicode.org/psi4manual/master/api/psi4.driver.geometry.html#psi4.driver.geometry>`__.; The argument bsse_type='cp' tells Psi4 to perform counterpoise (CP); correction on the dimer to compute the CCSD(T)/aug-cc-pVDZ interaction; energy, which is stored in our ecp dictionary at each iteration of; our Python loop. Note that we didn’t need to specify ghost atoms, and we; didn’t need to call the monomer and dimer computations separately. Psi4; does it all for us, automatically.; Near the very end of the output file output.dat, the counterpoise; correction Python function will print a nice summary of the results of; the counterpoise computation (the energies of the dimer, of monomer 1; with the ghost functions of monomer 2, of monomer 2 with the ghost; functions of monomer 1, and the overall counterpoise corrected; interaction energy):; N-Body: Computing complex (1/2) with fragments (2,) in the basis of fragments (1, 2).; ...; N-Body: Complex Energy (fragments = (2,), basis = (1, 2): -128.70932405488924); ...; N-Body: Computing complex (2/2) with fragments (1,) in the basis of fragments (1, 2).; ...; N-Body: Complex Energy (fragments = (1,), basis = (1, 2): -128.70932405488935); ...; N-Body: Computing complex (1/1) with fragments (1, 2) in the basis of fragments (1, 2).; ...; N-Body: Complex Energy (fragments = (1, 2), basis = (1, 2): -257.41867403127321); ...; ==> N-Body: Counterpoise Corrected (CP) energies <==. n-Body Total Energy [Eh] I.E. [kcal/mol] Delta [kcal/mol]; 1 -257.418648109779 0.000000000000 0.000000000000; 2 -257.418674031273 -0.016265984132 -0.016265984132. And that’s it! The only remaining part of the example is a little table; of the different R values and the CP-corrected CCSD(T) ene",MatchSource.WIKI,psi4manual/1.2.1/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi.html
https://psicode.org/psi4manual/1.2.1/psiapi.html:7837,Integrability,message,message,7837,"g psi4.energy(); API; with psi4.optimize(); API; or psi4.frequency(); API,; respectively.; Let’s take a look at an example of optimizing the H\(_2\)O; molecule using Hartree-Fock with a cc-pVDZ basis set.; Now, here comes the real beauty of running Psi4 interactively: above,; when we computed the energy of H\(_2\)O with HF/cc-pVDZ, we; defined the Psi4 molecule object h2o. Since we’re still in the; Python shell, as long as you executed that block of code, we can reuse; the h2o molecule object in our optimization without redefining it,; by adding the molecule=h2o argument to the psi4.optimize(); API; function:. In [5]:. psi4.set_options({'reference': 'rhf'}); psi4.optimize('scf/cc-pvdz', molecule=h2o). Optimizer: Optimization complete!. Out[5]:. -76.02703272937504. This should perform a series of gradient computations. The gradient; points which way is downhill in energy, and the optimizer then modifies; the geometry to follow the gradient. After a few cycles, the geometry; should converge with a message like Optimization complete!. As; indicated in the following table (printed by the optimizer at the end of; the computation and grep-able with ~), the energy decreases with; each step, and the maximum force on each atom also decreases with each; step (in principle, these numbers could increase in some iterations, but; here they do not).; --------------------------------------------------------------------------------------------------------------- ~  Step         Total Energy             Delta E       MAX Force       RMS Force        MAX Disp        RMS Disp  ~ --------------------------------------------------------------------------------------------------------------- ~     1     -76.026632734908    -76.026632734908      0.01523518      0.01245755      0.02742222      0.02277530  ~     2     -76.027022666011     -0.000389931104      0.00178779      0.00142946      0.01008137      0.00594928  ~     3     -76.027032729374     -0.000010063363      0.00014019      0.00",MatchSource.WIKI,psi4manual/1.2.1/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi.html
https://psicode.org/psi4manual/1.2.1/psiapi.html:18239,Integrability,rout,routine,18239,"ng about the interaction between the two monomers. V. Potential Surface Scans and Counterpoise Correction Made Easy¶; Finally, let’s consider an example which highlights the advantages of; being able to interact with Psi4 directly with Python.; Suppose you want to do a limited potential energy surface scan, such as; computing the interaction energy between two neon atoms at various; interatomic distances. One simple but unappealing way to do this is to; generate separate geometries for each distance to be studied. Instead,; we can leverage Python loops and string formatting to make our lives; simpler. Additionally, let’s suppose you want to do counterpoise (CP); correction to compute interaction energies. Counterpoise correction; involves computing the dimer energy and then subtracting out the; energies of the two monomers, each evaluated in the dimer basis. Again,; each of these computations could be run in a separate input file, but; because counterpoise correction is a fairly standard procedure for; intermolecular interactions, Psi4 knows about it and has a built-in; routine to perform counterpoise correction. It only needs to know what; method you want to do the couterpoise correction on (here, let’s; consider CCSD(T)), and it needs to know what’s monomer A and what’s; monomer B. This last issue of specifying the monomers separately was; already dealt with in the previous SAPT example, where we saw that two; dashes in the psi4.geometry() string can be used to separate; monomers.; So, we’re going to do counterpoise-corrected CCSD(T) energies for; Ne\(_2\) at a series of different interatomic distances. And let’s; print out a table of the interatomic distances we’ve considered, and the; CP-corrected CCSD(T) interaction energies (in kcal/mol) at each; geometry:. In [9]:. #! Example potential energy surface scan and CP-correction for Ne2. ne2_geometry = """"""; Ne; --; Ne 1 {0}; """""". Rvals = [2.5, 3.0, 4.0]. psi4.set_options({'freeze_core': 'true'}). # Initialize a bla",MatchSource.WIKI,psi4manual/1.2.1/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi.html
https://psicode.org/psi4manual/1.2.1/psiapi.html:1082,Modifiability,variab,variables,1082,"    .    .    .    .  · ; 1.2.1;  · . PSI4. A PSI4 Tutorial. PsiAPI Tutorial: Using Psi4 as a Python Module¶; transcribed by D. A. Sirianni. Note: Psithon and PsiAPI refer to two modes of interacting with; Psi4. In Psithon mode, you write an input file in our domain-specific; language (not quite Python) where commands don’t have psi4. in; front, then submit it to the executable psi4 which processes the; Psithon into pure Python and runs it internally. In PsiAPI mode, you; write a pure Python script with import psi4 at the top and commands; are behind the psi4. namespace, then submit it to the python; interpreter. Both modes are equally powerful. This tutorial covers the; PsiAPI mode. Warning: Although the developers have been using PsiAPI mode stably; for months before the 1.1 release and while we believe we’ve gotten; everything nicely arranged within the psi4. namespace, the API; should not be considered completely stable. Most importantly, as we; someday deprecate the last of the global variables, options will be; added to the method calls (e.g.,; energy('scf', molecule=mol, options=opt)); Note: Consult How to run Psi4 as Python module after; compilation; or How to run Psi4 as a Python module from conda; installation; for assistance in setting up Psi4. Unlike in the past, where Psi4 was executable software which could only; be called via input files like input.dat, it is now interactive,; able to be loaded directly as a Python module. Here, we will explore the; basics of using Psi4 in this new style by reproducing the section A; Psi4 Tutorial; from the Psi4 manual in an interactive Jupyter Notebook.; Note: If the newest version of Psi4 (v.1.1a2dev42 or newer) is in your; path, feel free to execute each cell as you read along by pressing; Shift+Enter when the cell is selected. I. Basic Input Structure¶; Psi4 is now a Python module; so, we need to import it into our Python; environment:. In [1]:. try:; import os, sys; sys.path.insert(1, os.path.abspath('/scratch/ps",MatchSource.WIKI,psi4manual/1.2.1/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi.html
https://psicode.org/psi4manual/1.2.1/psiapi.html:5484,Modifiability,variab,variables,5484,"hell molecule with all electrons paired), or the reference; wavefunction to use (restricted Hartree-Fock, or RHF, is usually; appropriate for a closed-shell molecule). The program correctly guessed; all of these options for us. We can change the default behavior through; additional keywords.; Let’s consider what we would do for an open-shell molecule, where not; all the electrons are paired. For example, let’s run a computation on; methylene (\(\text{CH}_2\)), whose ground electronic state has two; unpaired electrons (triplet electronic state, or a spin multiplicity; \(2S + 1 = 3\)). In this case, the default spin multiplicity (1) is; not correct, so we need to tell the program the true value (3). Like; many programs, Psi4 can get the charge and multiplicity as the first two; integers in the Z-matrix (note the line with 0 3 at the beginning of; the molecule specification below). In this example, we will also specify; the bond length and bond angle as variables (\(R\) and \(A\)),; whose values are first stored and then inserted into the geometry; specification using Python 3 string; formatting. In [4]:. #! Sample UHF/6-31G** CH2 Computation. R = 1.075; A = 133.93. ch2 = psi4.geometry(""""""; 0 3; C; H 1 {0}; H 1 {0} 2 {1}; """""".format(R, A); ). psi4.set_options({'reference': 'uhf'}); psi4.energy('scf/6-31g**'). Out[4]:. -38.925334628859886. Executing this cell should yield the final energy as; @DF-UHF Final Energy: -38.92533462887677. Notice the new command, psi4.set_options(); API,; to the input. This function takes a Python; dictionary; as its argument, which is a key-value list which associates a Psi4; keyword; with its user-defined value. For open shell molecules, we have a choice; of unrestricted orbitals (unrestricted Hartree-Fock, or UHF) or; restricted orbitals (restricted open-shell Hartree-Fock, or ROHF).; Usually, UHF is a little easier to converge (although it may be more; susceptible to spin contamination than ROHF). III. Geometry Optimization and Vibrational",MatchSource.WIKI,psi4manual/1.2.1/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi.html
https://psicode.org/psi4manual/1.2.1/psiapi.html:11686,Modifiability,adapt,adapted,11686,"s information could; be used to animate the vibrational frequency using visualization; software.); Because the vibrational frequencies are available, a thermodynamics; analysis is automatically performed at the end of the computation. You; can see this in the next section of the output file output.dat. The; vibrational frequencies are sufficient to obtain vibrational; contributions to enthalpy (H), entropy (S), and Gibbs free energy (G).; Similarly, the molecular geometry is used to obtain rotational; constants, which are then used to obtain rotational contributions to H,; S, and G.; Note: Psi4 has several synonyms for the functions called in this; example. For instance, psi4.frequency(); API; will compute molecular vibrational frequencies, and psi4.optimize(); API; will perform a geometry optimization. IV. Analysis of Intermolecular Interactions¶; Now let’s consider something a little more interesting. Psi4 contains; code to analyze the nature of intermolecular interactions between two; molecules, via symmetry-adapted perturbation theory (SAPT); (Jeziorski:1994:1887).; This kind of analysis gives a lot of insight into the nature of; intermolecular interactions, and Psi4 makes these computations easier; than ever.; For a SAPT computation, the input needs to provide information on two; distinct molecules. This is very easy, we just give a Z-matrix or set of; Cartesian coordinates for each molecule, and separate the two with two; dashes, like this:. In [7]:. # Example SAPT computation for ethene*ethyne (*i.e.*, ethylene*acetylene).; # Test case 16 from S22 Database. dimer = psi4.geometry(""""""; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; units angstrom; """"""). Here’s the second half of the input,",MatchSource.WIKI,psi4manual/1.2.1/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi.html
https://psicode.org/psi4manual/1.2.1/psiapi.html:20419,Modifiability,variab,variable,20419,"to screen; print(""CP-corrected CCSD(T)/aug-cc-pVDZ Interaction Energies\n\n""); print("" R [Ang] E_int [kcal/mol] ""); print(""---------------------------------------------------------""); for R in Rvals:; e = ecp[R] * psi4.constants.hartree2kcalmol; print("" {:3.1f} {:1.6f}"".format(R, e)). # Prints to output.dat; psi4.core.print_out(""CP-corrected CCSD(T)/aug-cc-pVDZ Interaction Energies\n\n""); psi4.core.print_out("" R [Ang] E_int [kcal/mol] \n""); psi4.core.print_out(""---------------------------------------------------------\n""); for R in Rvals:; e = ecp[R] * psi4.constants.hartree2kcalmol; psi4.core.print_out("" {:3.1f} {:1.6f}\n"".format(R, e)). CP-corrected CCSD(T)/aug-cc-pVDZ Interaction Energies. R [Ang] E_int [kcal/mol]; ---------------------------------------------------------; 2.5 0.758605; 3.0 0.015968; 4.0 -0.016215. First, you can see the geometry string ne2_geometry has a two dashes; to separate the monomers from each other. Also note we’ve used a; Z-matrix to specify the geometry, and we’ve used a variable (R) as; the interatomic distance. We have not specified the value of R in; the ne2_geometry string like we normally would. That’s because we; are going to vary it during the scan across the potential energy; surface, by using a Python loop over the list of interatomic distances; Rvals. Before we are able to pass our molecule to Psi4, we need to; do two things. First, we must set the value of the intermolecular; separation in our Z-matrix (by using Python 3 string; formatting); to the particular value of R. Second, we need to turn the Z-matrix; string into a Psi4 molecule, by passing it to; `psi4.geometry() <http://psicode.org/psi4manual/master/api/psi4.driver.geometry.html#psi4.driver.geometry>`__.; The argument bsse_type='cp' tells Psi4 to perform counterpoise (CP); correction on the dimer to compute the CCSD(T)/aug-cc-pVDZ interaction; energy, which is stored in our ecp dictionary at each iteration of; our Python loop. Note that we didn’t need to specify gho",MatchSource.WIKI,psi4manual/1.2.1/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi.html
https://psicode.org/psi4manual/1.2.1/psiapi.html:1503,Performance,load,loaded,1503,"e Python and runs it internally. In PsiAPI mode, you; write a pure Python script with import psi4 at the top and commands; are behind the psi4. namespace, then submit it to the python; interpreter. Both modes are equally powerful. This tutorial covers the; PsiAPI mode. Warning: Although the developers have been using PsiAPI mode stably; for months before the 1.1 release and while we believe we’ve gotten; everything nicely arranged within the psi4. namespace, the API; should not be considered completely stable. Most importantly, as we; someday deprecate the last of the global variables, options will be; added to the method calls (e.g.,; energy('scf', molecule=mol, options=opt)); Note: Consult How to run Psi4 as Python module after; compilation; or How to run Psi4 as a Python module from conda; installation; for assistance in setting up Psi4. Unlike in the past, where Psi4 was executable software which could only; be called via input files like input.dat, it is now interactive,; able to be loaded directly as a Python module. Here, we will explore the; basics of using Psi4 in this new style by reproducing the section A; Psi4 Tutorial; from the Psi4 manual in an interactive Jupyter Notebook.; Note: If the newest version of Psi4 (v.1.1a2dev42 or newer) is in your; path, feel free to execute each cell as you read along by pressing; Shift+Enter when the cell is selected. I. Basic Input Structure¶; Psi4 is now a Python module; so, we need to import it into our Python; environment:. In [1]:. try:; import os, sys; sys.path.insert(1, os.path.abspath('/scratch/psilocaluser/conda-builds/psi4-docs-multiout_1532505956776/work/build/stage//opt/anaconda1anaconda2anaconda3/lib/python3.6/site-packages')); except ImportError:; pass. import psi4. Psi4 is now able to be controlled directly from Python. By default, Psi4; will print any output to the screen; this can be changed by giving a; file name (with path if not in the current working directory) to the; function psi4.core.set_output_f",MatchSource.WIKI,psi4manual/1.2.1/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi.html
https://psicode.org/psi4manual/1.2.1/psiapi.html:6710,Performance,perform,perform,6710,"; 0 3; C; H 1 {0}; H 1 {0} 2 {1}; """""".format(R, A); ). psi4.set_options({'reference': 'uhf'}); psi4.energy('scf/6-31g**'). Out[4]:. -38.925334628859886. Executing this cell should yield the final energy as; @DF-UHF Final Energy: -38.92533462887677. Notice the new command, psi4.set_options(); API,; to the input. This function takes a Python; dictionary; as its argument, which is a key-value list which associates a Psi4; keyword; with its user-defined value. For open shell molecules, we have a choice; of unrestricted orbitals (unrestricted Hartree-Fock, or UHF) or; restricted orbitals (restricted open-shell Hartree-Fock, or ROHF).; Usually, UHF is a little easier to converge (although it may be more; susceptible to spin contamination than ROHF). III. Geometry Optimization and Vibrational Frequency Analysis¶; The above examples were simple single-point energy computations (as; specified by the psi4.energy(); API; function). Of course there are other kinds of computations to perform,; such as geometry optimizations and vibrational frequency computations.; These can be specified by replacing psi4.energy(); API; with psi4.optimize(); API; or psi4.frequency(); API,; respectively.; Let’s take a look at an example of optimizing the H\(_2\)O; molecule using Hartree-Fock with a cc-pVDZ basis set.; Now, here comes the real beauty of running Psi4 interactively: above,; when we computed the energy of H\(_2\)O with HF/cc-pVDZ, we; defined the Psi4 molecule object h2o. Since we’re still in the; Python shell, as long as you executed that block of code, we can reuse; the h2o molecule object in our optimization without redefining it,; by adding the molecule=h2o argument to the psi4.optimize(); API; function:. In [5]:. psi4.set_options({'reference': 'rhf'}); psi4.optimize('scf/cc-pvdz', molecule=h2o). Optimizer: Optimization complete!. Out[5]:. -76.02703272937504. This should perform a series of gradient computations. The gradient; points which way is downhill in energy, and the optimi",MatchSource.WIKI,psi4manual/1.2.1/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi.html
https://psicode.org/psi4manual/1.2.1/psiapi.html:6737,Performance,optimiz,optimizations,6737,"; 0 3; C; H 1 {0}; H 1 {0} 2 {1}; """""".format(R, A); ). psi4.set_options({'reference': 'uhf'}); psi4.energy('scf/6-31g**'). Out[4]:. -38.925334628859886. Executing this cell should yield the final energy as; @DF-UHF Final Energy: -38.92533462887677. Notice the new command, psi4.set_options(); API,; to the input. This function takes a Python; dictionary; as its argument, which is a key-value list which associates a Psi4; keyword; with its user-defined value. For open shell molecules, we have a choice; of unrestricted orbitals (unrestricted Hartree-Fock, or UHF) or; restricted orbitals (restricted open-shell Hartree-Fock, or ROHF).; Usually, UHF is a little easier to converge (although it may be more; susceptible to spin contamination than ROHF). III. Geometry Optimization and Vibrational Frequency Analysis¶; The above examples were simple single-point energy computations (as; specified by the psi4.energy(); API; function). Of course there are other kinds of computations to perform,; such as geometry optimizations and vibrational frequency computations.; These can be specified by replacing psi4.energy(); API; with psi4.optimize(); API; or psi4.frequency(); API,; respectively.; Let’s take a look at an example of optimizing the H\(_2\)O; molecule using Hartree-Fock with a cc-pVDZ basis set.; Now, here comes the real beauty of running Psi4 interactively: above,; when we computed the energy of H\(_2\)O with HF/cc-pVDZ, we; defined the Psi4 molecule object h2o. Since we’re still in the; Python shell, as long as you executed that block of code, we can reuse; the h2o molecule object in our optimization without redefining it,; by adding the molecule=h2o argument to the psi4.optimize(); API; function:. In [5]:. psi4.set_options({'reference': 'rhf'}); psi4.optimize('scf/cc-pvdz', molecule=h2o). Optimizer: Optimization complete!. Out[5]:. -76.02703272937504. This should perform a series of gradient computations. The gradient; points which way is downhill in energy, and the optimi",MatchSource.WIKI,psi4manual/1.2.1/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi.html
https://psicode.org/psi4manual/1.2.1/psiapi.html:6858,Performance,optimiz,optimize,6858,"59886. Executing this cell should yield the final energy as; @DF-UHF Final Energy: -38.92533462887677. Notice the new command, psi4.set_options(); API,; to the input. This function takes a Python; dictionary; as its argument, which is a key-value list which associates a Psi4; keyword; with its user-defined value. For open shell molecules, we have a choice; of unrestricted orbitals (unrestricted Hartree-Fock, or UHF) or; restricted orbitals (restricted open-shell Hartree-Fock, or ROHF).; Usually, UHF is a little easier to converge (although it may be more; susceptible to spin contamination than ROHF). III. Geometry Optimization and Vibrational Frequency Analysis¶; The above examples were simple single-point energy computations (as; specified by the psi4.energy(); API; function). Of course there are other kinds of computations to perform,; such as geometry optimizations and vibrational frequency computations.; These can be specified by replacing psi4.energy(); API; with psi4.optimize(); API; or psi4.frequency(); API,; respectively.; Let’s take a look at an example of optimizing the H\(_2\)O; molecule using Hartree-Fock with a cc-pVDZ basis set.; Now, here comes the real beauty of running Psi4 interactively: above,; when we computed the energy of H\(_2\)O with HF/cc-pVDZ, we; defined the Psi4 molecule object h2o. Since we’re still in the; Python shell, as long as you executed that block of code, we can reuse; the h2o molecule object in our optimization without redefining it,; by adding the molecule=h2o argument to the psi4.optimize(); API; function:. In [5]:. psi4.set_options({'reference': 'rhf'}); psi4.optimize('scf/cc-pvdz', molecule=h2o). Optimizer: Optimization complete!. Out[5]:. -76.02703272937504. This should perform a series of gradient computations. The gradient; points which way is downhill in energy, and the optimizer then modifies; the geometry to follow the gradient. After a few cycles, the geometry; should converge with a message like Optimization complete",MatchSource.WIKI,psi4manual/1.2.1/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi.html
https://psicode.org/psi4manual/1.2.1/psiapi.html:6952,Performance,optimiz,optimizing,6952," Notice the new command, psi4.set_options(); API,; to the input. This function takes a Python; dictionary; as its argument, which is a key-value list which associates a Psi4; keyword; with its user-defined value. For open shell molecules, we have a choice; of unrestricted orbitals (unrestricted Hartree-Fock, or UHF) or; restricted orbitals (restricted open-shell Hartree-Fock, or ROHF).; Usually, UHF is a little easier to converge (although it may be more; susceptible to spin contamination than ROHF). III. Geometry Optimization and Vibrational Frequency Analysis¶; The above examples were simple single-point energy computations (as; specified by the psi4.energy(); API; function). Of course there are other kinds of computations to perform,; such as geometry optimizations and vibrational frequency computations.; These can be specified by replacing psi4.energy(); API; with psi4.optimize(); API; or psi4.frequency(); API,; respectively.; Let’s take a look at an example of optimizing the H\(_2\)O; molecule using Hartree-Fock with a cc-pVDZ basis set.; Now, here comes the real beauty of running Psi4 interactively: above,; when we computed the energy of H\(_2\)O with HF/cc-pVDZ, we; defined the Psi4 molecule object h2o. Since we’re still in the; Python shell, as long as you executed that block of code, we can reuse; the h2o molecule object in our optimization without redefining it,; by adding the molecule=h2o argument to the psi4.optimize(); API; function:. In [5]:. psi4.set_options({'reference': 'rhf'}); psi4.optimize('scf/cc-pvdz', molecule=h2o). Optimizer: Optimization complete!. Out[5]:. -76.02703272937504. This should perform a series of gradient computations. The gradient; points which way is downhill in energy, and the optimizer then modifies; the geometry to follow the gradient. After a few cycles, the geometry; should converge with a message like Optimization complete!. As; indicated in the following table (printed by the optimizer at the end of; the computation and g",MatchSource.WIKI,psi4manual/1.2.1/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi.html
https://psicode.org/psi4manual/1.2.1/psiapi.html:7331,Performance,optimiz,optimization,7331,"itals (restricted open-shell Hartree-Fock, or ROHF).; Usually, UHF is a little easier to converge (although it may be more; susceptible to spin contamination than ROHF). III. Geometry Optimization and Vibrational Frequency Analysis¶; The above examples were simple single-point energy computations (as; specified by the psi4.energy(); API; function). Of course there are other kinds of computations to perform,; such as geometry optimizations and vibrational frequency computations.; These can be specified by replacing psi4.energy(); API; with psi4.optimize(); API; or psi4.frequency(); API,; respectively.; Let’s take a look at an example of optimizing the H\(_2\)O; molecule using Hartree-Fock with a cc-pVDZ basis set.; Now, here comes the real beauty of running Psi4 interactively: above,; when we computed the energy of H\(_2\)O with HF/cc-pVDZ, we; defined the Psi4 molecule object h2o. Since we’re still in the; Python shell, as long as you executed that block of code, we can reuse; the h2o molecule object in our optimization without redefining it,; by adding the molecule=h2o argument to the psi4.optimize(); API; function:. In [5]:. psi4.set_options({'reference': 'rhf'}); psi4.optimize('scf/cc-pvdz', molecule=h2o). Optimizer: Optimization complete!. Out[5]:. -76.02703272937504. This should perform a series of gradient computations. The gradient; points which way is downhill in energy, and the optimizer then modifies; the geometry to follow the gradient. After a few cycles, the geometry; should converge with a message like Optimization complete!. As; indicated in the following table (printed by the optimizer at the end of; the computation and grep-able with ~), the energy decreases with; each step, and the maximum force on each atom also decreases with each; step (in principle, these numbers could increase in some iterations, but; here they do not).; --------------------------------------------------------------------------------------------------------------- ~  Step      ",MatchSource.WIKI,psi4manual/1.2.1/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi.html
https://psicode.org/psi4manual/1.2.1/psiapi.html:7416,Performance,optimiz,optimize,7416,"e; susceptible to spin contamination than ROHF). III. Geometry Optimization and Vibrational Frequency Analysis¶; The above examples were simple single-point energy computations (as; specified by the psi4.energy(); API; function). Of course there are other kinds of computations to perform,; such as geometry optimizations and vibrational frequency computations.; These can be specified by replacing psi4.energy(); API; with psi4.optimize(); API; or psi4.frequency(); API,; respectively.; Let’s take a look at an example of optimizing the H\(_2\)O; molecule using Hartree-Fock with a cc-pVDZ basis set.; Now, here comes the real beauty of running Psi4 interactively: above,; when we computed the energy of H\(_2\)O with HF/cc-pVDZ, we; defined the Psi4 molecule object h2o. Since we’re still in the; Python shell, as long as you executed that block of code, we can reuse; the h2o molecule object in our optimization without redefining it,; by adding the molecule=h2o argument to the psi4.optimize(); API; function:. In [5]:. psi4.set_options({'reference': 'rhf'}); psi4.optimize('scf/cc-pvdz', molecule=h2o). Optimizer: Optimization complete!. Out[5]:. -76.02703272937504. This should perform a series of gradient computations. The gradient; points which way is downhill in energy, and the optimizer then modifies; the geometry to follow the gradient. After a few cycles, the geometry; should converge with a message like Optimization complete!. As; indicated in the following table (printed by the optimizer at the end of; the computation and grep-able with ~), the energy decreases with; each step, and the maximum force on each atom also decreases with each; step (in principle, these numbers could increase in some iterations, but; here they do not).; --------------------------------------------------------------------------------------------------------------- ~  Step         Total Energy             Delta E       MAX Force       RMS Force        MAX Disp        RMS Disp  ~ ------------------",MatchSource.WIKI,psi4manual/1.2.1/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi.html
https://psicode.org/psi4manual/1.2.1/psiapi.html:7498,Performance,optimiz,optimize,7498,"nal Frequency Analysis¶; The above examples were simple single-point energy computations (as; specified by the psi4.energy(); API; function). Of course there are other kinds of computations to perform,; such as geometry optimizations and vibrational frequency computations.; These can be specified by replacing psi4.energy(); API; with psi4.optimize(); API; or psi4.frequency(); API,; respectively.; Let’s take a look at an example of optimizing the H\(_2\)O; molecule using Hartree-Fock with a cc-pVDZ basis set.; Now, here comes the real beauty of running Psi4 interactively: above,; when we computed the energy of H\(_2\)O with HF/cc-pVDZ, we; defined the Psi4 molecule object h2o. Since we’re still in the; Python shell, as long as you executed that block of code, we can reuse; the h2o molecule object in our optimization without redefining it,; by adding the molecule=h2o argument to the psi4.optimize(); API; function:. In [5]:. psi4.set_options({'reference': 'rhf'}); psi4.optimize('scf/cc-pvdz', molecule=h2o). Optimizer: Optimization complete!. Out[5]:. -76.02703272937504. This should perform a series of gradient computations. The gradient; points which way is downhill in energy, and the optimizer then modifies; the geometry to follow the gradient. After a few cycles, the geometry; should converge with a message like Optimization complete!. As; indicated in the following table (printed by the optimizer at the end of; the computation and grep-able with ~), the energy decreases with; each step, and the maximum force on each atom also decreases with each; step (in principle, these numbers could increase in some iterations, but; here they do not).; --------------------------------------------------------------------------------------------------------------- ~  Step         Total Energy             Delta E       MAX Force       RMS Force        MAX Disp        RMS Disp  ~ ---------------------------------------------------------------------------------------------------------",MatchSource.WIKI,psi4manual/1.2.1/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi.html
https://psicode.org/psi4manual/1.2.1/psiapi.html:7613,Performance,perform,perform,7613," psi4.energy(); API; function). Of course there are other kinds of computations to perform,; such as geometry optimizations and vibrational frequency computations.; These can be specified by replacing psi4.energy(); API; with psi4.optimize(); API; or psi4.frequency(); API,; respectively.; Let’s take a look at an example of optimizing the H\(_2\)O; molecule using Hartree-Fock with a cc-pVDZ basis set.; Now, here comes the real beauty of running Psi4 interactively: above,; when we computed the energy of H\(_2\)O with HF/cc-pVDZ, we; defined the Psi4 molecule object h2o. Since we’re still in the; Python shell, as long as you executed that block of code, we can reuse; the h2o molecule object in our optimization without redefining it,; by adding the molecule=h2o argument to the psi4.optimize(); API; function:. In [5]:. psi4.set_options({'reference': 'rhf'}); psi4.optimize('scf/cc-pvdz', molecule=h2o). Optimizer: Optimization complete!. Out[5]:. -76.02703272937504. This should perform a series of gradient computations. The gradient; points which way is downhill in energy, and the optimizer then modifies; the geometry to follow the gradient. After a few cycles, the geometry; should converge with a message like Optimization complete!. As; indicated in the following table (printed by the optimizer at the end of; the computation and grep-able with ~), the energy decreases with; each step, and the maximum force on each atom also decreases with each; step (in principle, these numbers could increase in some iterations, but; here they do not).; --------------------------------------------------------------------------------------------------------------- ~  Step         Total Energy             Delta E       MAX Force       RMS Force        MAX Disp        RMS Disp  ~ --------------------------------------------------------------------------------------------------------------- ~     1     -76.026632734908    -76.026632734908      0.01523518      0.01245755      0.02742222      0.",MatchSource.WIKI,psi4manual/1.2.1/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi.html
https://psicode.org/psi4manual/1.2.1/psiapi.html:7718,Performance,optimiz,optimizer,7718,",; such as geometry optimizations and vibrational frequency computations.; These can be specified by replacing psi4.energy(); API; with psi4.optimize(); API; or psi4.frequency(); API,; respectively.; Let’s take a look at an example of optimizing the H\(_2\)O; molecule using Hartree-Fock with a cc-pVDZ basis set.; Now, here comes the real beauty of running Psi4 interactively: above,; when we computed the energy of H\(_2\)O with HF/cc-pVDZ, we; defined the Psi4 molecule object h2o. Since we’re still in the; Python shell, as long as you executed that block of code, we can reuse; the h2o molecule object in our optimization without redefining it,; by adding the molecule=h2o argument to the psi4.optimize(); API; function:. In [5]:. psi4.set_options({'reference': 'rhf'}); psi4.optimize('scf/cc-pvdz', molecule=h2o). Optimizer: Optimization complete!. Out[5]:. -76.02703272937504. This should perform a series of gradient computations. The gradient; points which way is downhill in energy, and the optimizer then modifies; the geometry to follow the gradient. After a few cycles, the geometry; should converge with a message like Optimization complete!. As; indicated in the following table (printed by the optimizer at the end of; the computation and grep-able with ~), the energy decreases with; each step, and the maximum force on each atom also decreases with each; step (in principle, these numbers could increase in some iterations, but; here they do not).; --------------------------------------------------------------------------------------------------------------- ~  Step         Total Energy             Delta E       MAX Force       RMS Force        MAX Disp        RMS Disp  ~ --------------------------------------------------------------------------------------------------------------- ~     1     -76.026632734908    -76.026632734908      0.01523518      0.01245755      0.02742222      0.02277530  ~     2     -76.027022666011     -0.000389931104      0.00178779      0.0014294",MatchSource.WIKI,psi4manual/1.2.1/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi.html
https://psicode.org/psi4manual/1.2.1/psiapi.html:7927,Performance,optimiz,optimizer,7927,"et.; Now, here comes the real beauty of running Psi4 interactively: above,; when we computed the energy of H\(_2\)O with HF/cc-pVDZ, we; defined the Psi4 molecule object h2o. Since we’re still in the; Python shell, as long as you executed that block of code, we can reuse; the h2o molecule object in our optimization without redefining it,; by adding the molecule=h2o argument to the psi4.optimize(); API; function:. In [5]:. psi4.set_options({'reference': 'rhf'}); psi4.optimize('scf/cc-pvdz', molecule=h2o). Optimizer: Optimization complete!. Out[5]:. -76.02703272937504. This should perform a series of gradient computations. The gradient; points which way is downhill in energy, and the optimizer then modifies; the geometry to follow the gradient. After a few cycles, the geometry; should converge with a message like Optimization complete!. As; indicated in the following table (printed by the optimizer at the end of; the computation and grep-able with ~), the energy decreases with; each step, and the maximum force on each atom also decreases with each; step (in principle, these numbers could increase in some iterations, but; here they do not).; --------------------------------------------------------------------------------------------------------------- ~  Step         Total Energy             Delta E       MAX Force       RMS Force        MAX Disp        RMS Disp  ~ --------------------------------------------------------------------------------------------------------------- ~     1     -76.026632734908    -76.026632734908      0.01523518      0.01245755      0.02742222      0.02277530  ~     2     -76.027022666011     -0.000389931104      0.00178779      0.00142946      0.01008137      0.00594928  ~     3     -76.027032729374     -0.000010063363      0.00014019      0.00008488      0.00077463      0.00044738  ~ --------------------------------------------------------------------------------------------------------------- ~; To get harmonic vibrational frequencies, it’s",MatchSource.WIKI,psi4manual/1.2.1/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi.html
https://psicode.org/psi4manual/1.2.1/psiapi.html:9279,Performance,optimiz,optimized,9279,"--------------- ~  Step         Total Energy             Delta E       MAX Force       RMS Force        MAX Disp        RMS Disp  ~ --------------------------------------------------------------------------------------------------------------- ~     1     -76.026632734908    -76.026632734908      0.01523518      0.01245755      0.02742222      0.02277530  ~     2     -76.027022666011     -0.000389931104      0.00178779      0.00142946      0.01008137      0.00594928  ~     3     -76.027032729374     -0.000010063363      0.00014019      0.00008488      0.00077463      0.00044738  ~ --------------------------------------------------------------------------------------------------------------- ~; To get harmonic vibrational frequencies, it’s important to keep in mind; that the values of the vibrational frequencies are a function of the; molecular geometry. Therefore, it’s important to obtain the vibrational; frequencies AT THE OPTIMIZED GEOMETRY. Luckily, Psi4 updates the; molecule with optimized geometry as it is being optimized. So, the; optimized geometry for H\(_2\)O is stored inside the h2o; molecule object, which we can access! To compute the frequencies, all we; need to do is to again pass the molecule=h2o argument to the; psi4.frequency(); API; function:. In [6]:. scf_e, scf_wfn = psi4.frequency('scf/cc-pvdz', molecule=h2o, return_wfn=True, dertype=1). 6 displacements needed.; 1 2 3 4 5 6. Executing this cell will prompt Psi4 to compute the Hessian (second; derivative matrix) of the electronic energy with respect to nuclear; displacements. From this, it can obtain the harmonic vibrational; frequencies, given below (roundoff errors of around \(0.1\); cm\(^{-1}\) may exist):; Irrep Harmonic Frequency; (cm-1); -----------------------------------------------; A1 1775.6478; A1 4113.3795; B2 4212.1814; -----------------------------------------------. Notice the symmetry type of the normal modes is specified (A1, A1, B2).; The program also print out the normal modes i",MatchSource.WIKI,psi4manual/1.2.1/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi.html
https://psicode.org/psi4manual/1.2.1/psiapi.html:9313,Performance,optimiz,optimized,9313,"--------------- ~  Step         Total Energy             Delta E       MAX Force       RMS Force        MAX Disp        RMS Disp  ~ --------------------------------------------------------------------------------------------------------------- ~     1     -76.026632734908    -76.026632734908      0.01523518      0.01245755      0.02742222      0.02277530  ~     2     -76.027022666011     -0.000389931104      0.00178779      0.00142946      0.01008137      0.00594928  ~     3     -76.027032729374     -0.000010063363      0.00014019      0.00008488      0.00077463      0.00044738  ~ --------------------------------------------------------------------------------------------------------------- ~; To get harmonic vibrational frequencies, it’s important to keep in mind; that the values of the vibrational frequencies are a function of the; molecular geometry. Therefore, it’s important to obtain the vibrational; frequencies AT THE OPTIMIZED GEOMETRY. Luckily, Psi4 updates the; molecule with optimized geometry as it is being optimized. So, the; optimized geometry for H\(_2\)O is stored inside the h2o; molecule object, which we can access! To compute the frequencies, all we; need to do is to again pass the molecule=h2o argument to the; psi4.frequency(); API; function:. In [6]:. scf_e, scf_wfn = psi4.frequency('scf/cc-pvdz', molecule=h2o, return_wfn=True, dertype=1). 6 displacements needed.; 1 2 3 4 5 6. Executing this cell will prompt Psi4 to compute the Hessian (second; derivative matrix) of the electronic energy with respect to nuclear; displacements. From this, it can obtain the harmonic vibrational; frequencies, given below (roundoff errors of around \(0.1\); cm\(^{-1}\) may exist):; Irrep Harmonic Frequency; (cm-1); -----------------------------------------------; A1 1775.6478; A1 4113.3795; B2 4212.1814; -----------------------------------------------. Notice the symmetry type of the normal modes is specified (A1, A1, B2).; The program also print out the normal modes i",MatchSource.WIKI,psi4manual/1.2.1/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi.html
https://psicode.org/psi4manual/1.2.1/psiapi.html:9333,Performance,optimiz,optimized,9333,"------------------------------------------------------------------------------------------------ ~     1     -76.026632734908    -76.026632734908      0.01523518      0.01245755      0.02742222      0.02277530  ~     2     -76.027022666011     -0.000389931104      0.00178779      0.00142946      0.01008137      0.00594928  ~     3     -76.027032729374     -0.000010063363      0.00014019      0.00008488      0.00077463      0.00044738  ~ --------------------------------------------------------------------------------------------------------------- ~; To get harmonic vibrational frequencies, it’s important to keep in mind; that the values of the vibrational frequencies are a function of the; molecular geometry. Therefore, it’s important to obtain the vibrational; frequencies AT THE OPTIMIZED GEOMETRY. Luckily, Psi4 updates the; molecule with optimized geometry as it is being optimized. So, the; optimized geometry for H\(_2\)O is stored inside the h2o; molecule object, which we can access! To compute the frequencies, all we; need to do is to again pass the molecule=h2o argument to the; psi4.frequency(); API; function:. In [6]:. scf_e, scf_wfn = psi4.frequency('scf/cc-pvdz', molecule=h2o, return_wfn=True, dertype=1). 6 displacements needed.; 1 2 3 4 5 6. Executing this cell will prompt Psi4 to compute the Hessian (second; derivative matrix) of the electronic energy with respect to nuclear; displacements. From this, it can obtain the harmonic vibrational; frequencies, given below (roundoff errors of around \(0.1\); cm\(^{-1}\) may exist):; Irrep Harmonic Frequency; (cm-1); -----------------------------------------------; A1 1775.6478; A1 4113.3795; B2 4212.1814; -----------------------------------------------. Notice the symmetry type of the normal modes is specified (A1, A1, B2).; The program also print out the normal modes in terms of Cartesian; coordinates of each atom. For example, the normal mode at \(1776\); cm\(^{-1}\) is:; Frequency: 1775.65; Force constant: 0.119",MatchSource.WIKI,psi4manual/1.2.1/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi.html
https://psicode.org/psi4manual/1.2.1/psiapi.html:10853,Performance,perform,performed,10853,"to nuclear; displacements. From this, it can obtain the harmonic vibrational; frequencies, given below (roundoff errors of around \(0.1\); cm\(^{-1}\) may exist):; Irrep Harmonic Frequency; (cm-1); -----------------------------------------------; A1 1775.6478; A1 4113.3795; B2 4212.1814; -----------------------------------------------. Notice the symmetry type of the normal modes is specified (A1, A1, B2).; The program also print out the normal modes in terms of Cartesian; coordinates of each atom. For example, the normal mode at \(1776\); cm\(^{-1}\) is:; Frequency: 1775.65; Force constant: 0.1193; X Y Z mass; O 0.000 0.000 -0.068 15.994915; H 0.000 0.416 0.536 1.007825; H 0.000 -0.416 0.536 1.007825. where the table shows the displacements in the X, Y, and Z dimensions; for each atom along the normal mode coordinate. (This information could; be used to animate the vibrational frequency using visualization; software.); Because the vibrational frequencies are available, a thermodynamics; analysis is automatically performed at the end of the computation. You; can see this in the next section of the output file output.dat. The; vibrational frequencies are sufficient to obtain vibrational; contributions to enthalpy (H), entropy (S), and Gibbs free energy (G).; Similarly, the molecular geometry is used to obtain rotational; constants, which are then used to obtain rotational contributions to H,; S, and G.; Note: Psi4 has several synonyms for the functions called in this; example. For instance, psi4.frequency(); API; will compute molecular vibrational frequencies, and psi4.optimize(); API; will perform a geometry optimization. IV. Analysis of Intermolecular Interactions¶; Now let’s consider something a little more interesting. Psi4 contains; code to analyze the nature of intermolecular interactions between two; molecules, via symmetry-adapted perturbation theory (SAPT); (Jeziorski:1994:1887).; This kind of analysis gives a lot of insight into the nature of; intermolecula",MatchSource.WIKI,psi4manual/1.2.1/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi.html
https://psicode.org/psi4manual/1.2.1/psiapi.html:11419,Performance,optimiz,optimize,11419,".000 0.000 -0.068 15.994915; H 0.000 0.416 0.536 1.007825; H 0.000 -0.416 0.536 1.007825. where the table shows the displacements in the X, Y, and Z dimensions; for each atom along the normal mode coordinate. (This information could; be used to animate the vibrational frequency using visualization; software.); Because the vibrational frequencies are available, a thermodynamics; analysis is automatically performed at the end of the computation. You; can see this in the next section of the output file output.dat. The; vibrational frequencies are sufficient to obtain vibrational; contributions to enthalpy (H), entropy (S), and Gibbs free energy (G).; Similarly, the molecular geometry is used to obtain rotational; constants, which are then used to obtain rotational contributions to H,; S, and G.; Note: Psi4 has several synonyms for the functions called in this; example. For instance, psi4.frequency(); API; will compute molecular vibrational frequencies, and psi4.optimize(); API; will perform a geometry optimization. IV. Analysis of Intermolecular Interactions¶; Now let’s consider something a little more interesting. Psi4 contains; code to analyze the nature of intermolecular interactions between two; molecules, via symmetry-adapted perturbation theory (SAPT); (Jeziorski:1994:1887).; This kind of analysis gives a lot of insight into the nature of; intermolecular interactions, and Psi4 makes these computations easier; than ever.; For a SAPT computation, the input needs to provide information on two; distinct molecules. This is very easy, we just give a Z-matrix or set of; Cartesian coordinates for each molecule, and separate the two with two; dashes, like this:. In [7]:. # Example SAPT computation for ethene*ethyne (*i.e.*, ethylene*acetylene).; # Test case 16 from S22 Database. dimer = psi4.geometry(""""""; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.",MatchSource.WIKI,psi4manual/1.2.1/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi.html
https://psicode.org/psi4manual/1.2.1/psiapi.html:11441,Performance,perform,perform,11441,".000 0.000 -0.068 15.994915; H 0.000 0.416 0.536 1.007825; H 0.000 -0.416 0.536 1.007825. where the table shows the displacements in the X, Y, and Z dimensions; for each atom along the normal mode coordinate. (This information could; be used to animate the vibrational frequency using visualization; software.); Because the vibrational frequencies are available, a thermodynamics; analysis is automatically performed at the end of the computation. You; can see this in the next section of the output file output.dat. The; vibrational frequencies are sufficient to obtain vibrational; contributions to enthalpy (H), entropy (S), and Gibbs free energy (G).; Similarly, the molecular geometry is used to obtain rotational; constants, which are then used to obtain rotational contributions to H,; S, and G.; Note: Psi4 has several synonyms for the functions called in this; example. For instance, psi4.frequency(); API; will compute molecular vibrational frequencies, and psi4.optimize(); API; will perform a geometry optimization. IV. Analysis of Intermolecular Interactions¶; Now let’s consider something a little more interesting. Psi4 contains; code to analyze the nature of intermolecular interactions between two; molecules, via symmetry-adapted perturbation theory (SAPT); (Jeziorski:1994:1887).; This kind of analysis gives a lot of insight into the nature of; intermolecular interactions, and Psi4 makes these computations easier; than ever.; For a SAPT computation, the input needs to provide information on two; distinct molecules. This is very easy, we just give a Z-matrix or set of; Cartesian coordinates for each molecule, and separate the two with two; dashes, like this:. In [7]:. # Example SAPT computation for ethene*ethyne (*i.e.*, ethylene*acetylene).; # Test case 16 from S22 Database. dimer = psi4.geometry(""""""; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.",MatchSource.WIKI,psi4manual/1.2.1/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi.html
https://psicode.org/psi4manual/1.2.1/psiapi.html:11460,Performance,optimiz,optimization,11460,".000 0.000 -0.068 15.994915; H 0.000 0.416 0.536 1.007825; H 0.000 -0.416 0.536 1.007825. where the table shows the displacements in the X, Y, and Z dimensions; for each atom along the normal mode coordinate. (This information could; be used to animate the vibrational frequency using visualization; software.); Because the vibrational frequencies are available, a thermodynamics; analysis is automatically performed at the end of the computation. You; can see this in the next section of the output file output.dat. The; vibrational frequencies are sufficient to obtain vibrational; contributions to enthalpy (H), entropy (S), and Gibbs free energy (G).; Similarly, the molecular geometry is used to obtain rotational; constants, which are then used to obtain rotational contributions to H,; S, and G.; Note: Psi4 has several synonyms for the functions called in this; example. For instance, psi4.frequency(); API; will compute molecular vibrational frequencies, and psi4.optimize(); API; will perform a geometry optimization. IV. Analysis of Intermolecular Interactions¶; Now let’s consider something a little more interesting. Psi4 contains; code to analyze the nature of intermolecular interactions between two; molecules, via symmetry-adapted perturbation theory (SAPT); (Jeziorski:1994:1887).; This kind of analysis gives a lot of insight into the nature of; intermolecular interactions, and Psi4 makes these computations easier; than ever.; For a SAPT computation, the input needs to provide information on two; distinct molecules. This is very easy, we just give a Z-matrix or set of; Cartesian coordinates for each molecule, and separate the two with two; dashes, like this:. In [7]:. # Example SAPT computation for ethene*ethyne (*i.e.*, ethylene*acetylene).; # Test case 16 from S22 Database. dimer = psi4.geometry(""""""; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.",MatchSource.WIKI,psi4manual/1.2.1/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi.html
https://psicode.org/psi4manual/1.2.1/psiapi.html:13508,Performance,optimiz,optimize,13508,"000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; units angstrom; """"""). Here’s the second half of the input, where we specify the computation; options:. In [8]:. psi4.set_options({'scf_type': 'df',; 'freeze_core': 'true'}). psi4.energy('sapt0/jun-cc-pvdz', molecule=dimer). Out[8]:. -0.0022355825227244703. All of the options we have currently set using psi4.set_options(); API; are “global” options (meaning that they are visible to all parts of the; program). Most common Psi4 options can be set like this. If an option; needs to be visible only to one part of the program (e.g., we only; want to increase the energy convergence in the SCF code, but not the; rest of the code), it can be set by with the; psi4.set_module_options(); API; function, psi4.set_module_options('scf', {'e_convergence': '1e-8'}).; Note: The arguments to the functions we’ve used so far, like; psi4.set_options(); API,; psi4.set_module_options(); API,; psi4.energy(); API,; psi4.optimize(); API,; psi4.frequency(); API,; etc., are case-insensitive.; Back to our SAPT example, we have found that for basic-level SAPT; computations (i.e., SAPT0), a good error cancellation is found; (Hohenstein:2012:WIREs); with the jun-cc-pVDZ basis (this is the usual aug-cc-pVDZ basis, but; without diffuse functions on hydrogen and without diffuse \(d\); functions on heavy atoms); (Papajak:2011:10).; So, we’ll use that as our standard basis set. The SAPT code is designed; to use density fitting techniques, because they introduce minimal errors; while providing much faster computations; (Hohenstein:2010:184111,Hohenstein:2010:014101).; Since we’re using density fitting for the SAPT, we might as well also; use it for the Hartree-Fock computations that are performed as part of; the SAPT. We can specify that by adding 'scf_type': 'df' to the; dictionary passed to psi4.set_options().; Density fitting procedures require the use of auxiliary basis sets that; pair with the primary basis set. Fortunat",MatchSource.WIKI,psi4manual/1.2.1/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi.html
https://psicode.org/psi4manual/1.2.1/psiapi.html:14277,Performance,perform,performed,14277," it can be set by with the; psi4.set_module_options(); API; function, psi4.set_module_options('scf', {'e_convergence': '1e-8'}).; Note: The arguments to the functions we’ve used so far, like; psi4.set_options(); API,; psi4.set_module_options(); API,; psi4.energy(); API,; psi4.optimize(); API,; psi4.frequency(); API,; etc., are case-insensitive.; Back to our SAPT example, we have found that for basic-level SAPT; computations (i.e., SAPT0), a good error cancellation is found; (Hohenstein:2012:WIREs); with the jun-cc-pVDZ basis (this is the usual aug-cc-pVDZ basis, but; without diffuse functions on hydrogen and without diffuse \(d\); functions on heavy atoms); (Papajak:2011:10).; So, we’ll use that as our standard basis set. The SAPT code is designed; to use density fitting techniques, because they introduce minimal errors; while providing much faster computations; (Hohenstein:2010:184111,Hohenstein:2010:014101).; Since we’re using density fitting for the SAPT, we might as well also; use it for the Hartree-Fock computations that are performed as part of; the SAPT. We can specify that by adding 'scf_type': 'df' to the; dictionary passed to psi4.set_options().; Density fitting procedures require the use of auxiliary basis sets that; pair with the primary basis set. Fortunately, Psi4 is usually smart; enough to figure out what auxiliary basis sets are needed for a given; computation. In this case, jun-cc-pVDZ is a standard enough basis set; (just a simple truncation of the very popular aug-cc-pVDZ basis set); that Psi4 correctly guesses that we want the jun-cc-pVDZ-JKFIT auxiliary; basis for the Hartree-Fock, and the jun-cc-pVDZ-RI basis set for the; SAPT procedure.; To speed up the computation a little, we also tell the SAPT procedure to; freeze the core electrons by adding 'freeze_core': 'true' to the; dictionary passed to psi4.set_options(). The SAPT procedure is; invoked by psi4.energy('sapt0/jun-cc-pvdz', molecule=dimer). Here,; Psi4 knows to automatically run two mo",MatchSource.WIKI,psi4manual/1.2.1/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi.html
https://psicode.org/psi4manual/1.2.1/psiapi.html:15305,Performance,perform,perform,15305,"putations that are performed as part of; the SAPT. We can specify that by adding 'scf_type': 'df' to the; dictionary passed to psi4.set_options().; Density fitting procedures require the use of auxiliary basis sets that; pair with the primary basis set. Fortunately, Psi4 is usually smart; enough to figure out what auxiliary basis sets are needed for a given; computation. In this case, jun-cc-pVDZ is a standard enough basis set; (just a simple truncation of the very popular aug-cc-pVDZ basis set); that Psi4 correctly guesses that we want the jun-cc-pVDZ-JKFIT auxiliary; basis for the Hartree-Fock, and the jun-cc-pVDZ-RI basis set for the; SAPT procedure.; To speed up the computation a little, we also tell the SAPT procedure to; freeze the core electrons by adding 'freeze_core': 'true' to the; dictionary passed to psi4.set_options(). The SAPT procedure is; invoked by psi4.energy('sapt0/jun-cc-pvdz', molecule=dimer). Here,; Psi4 knows to automatically run two monomer computations and a dimer; computation and then use these results to perform the SAPT analysis. The; various energy components are printed at the end of the output, in; addition to the total SAPT0 interaction energy. An explanation of the; various energy components can be found in the review by Jeziorski,; Moszynski, and Szalewicz; (Jeziorski:1994:1887),; and this is discussed in more detail in the SAPT; section of the Psi4; manual.; For now, we’ll note that most of the SAPT energy components are; negative; this means those are attractive contributions (the zero of; energy in a SAPT computation is defined as non-interacting monomers).; The exchange contributions are positive (repulsive). In this example,; the most attractive contribution between ethylene and acetylene is an; electrostatic term of \(-2.12\) kcal/mol (Elst10,r where the 1; indicates the first-order perturbation theory result with respect to the; intermolecular interaction, and the 0 indicates zeroth-order with; respect to the intramolecular e",MatchSource.WIKI,psi4manual/1.2.1/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi.html
https://psicode.org/psi4manual/1.2.1/psiapi.html:18250,Performance,perform,perform,18250,"ng about the interaction between the two monomers. V. Potential Surface Scans and Counterpoise Correction Made Easy¶; Finally, let’s consider an example which highlights the advantages of; being able to interact with Psi4 directly with Python.; Suppose you want to do a limited potential energy surface scan, such as; computing the interaction energy between two neon atoms at various; interatomic distances. One simple but unappealing way to do this is to; generate separate geometries for each distance to be studied. Instead,; we can leverage Python loops and string formatting to make our lives; simpler. Additionally, let’s suppose you want to do counterpoise (CP); correction to compute interaction energies. Counterpoise correction; involves computing the dimer energy and then subtracting out the; energies of the two monomers, each evaluated in the dimer basis. Again,; each of these computations could be run in a separate input file, but; because counterpoise correction is a fairly standard procedure for; intermolecular interactions, Psi4 knows about it and has a built-in; routine to perform counterpoise correction. It only needs to know what; method you want to do the couterpoise correction on (here, let’s; consider CCSD(T)), and it needs to know what’s monomer A and what’s; monomer B. This last issue of specifying the monomers separately was; already dealt with in the previous SAPT example, where we saw that two; dashes in the psi4.geometry() string can be used to separate; monomers.; So, we’re going to do counterpoise-corrected CCSD(T) energies for; Ne\(_2\) at a series of different interatomic distances. And let’s; print out a table of the interatomic distances we’ve considered, and the; CP-corrected CCSD(T) interaction energies (in kcal/mol) at each; geometry:. In [9]:. #! Example potential energy surface scan and CP-correction for Ne2. ne2_geometry = """"""; Ne; --; Ne 1 {0}; """""". Rvals = [2.5, 3.0, 4.0]. psi4.set_options({'freeze_core': 'true'}). # Initialize a bla",MatchSource.WIKI,psi4manual/1.2.1/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi.html
https://psicode.org/psi4manual/1.2.1/psiapi.html:21179,Performance,perform,perform,21179,"ee the geometry string ne2_geometry has a two dashes; to separate the monomers from each other. Also note we’ve used a; Z-matrix to specify the geometry, and we’ve used a variable (R) as; the interatomic distance. We have not specified the value of R in; the ne2_geometry string like we normally would. That’s because we; are going to vary it during the scan across the potential energy; surface, by using a Python loop over the list of interatomic distances; Rvals. Before we are able to pass our molecule to Psi4, we need to; do two things. First, we must set the value of the intermolecular; separation in our Z-matrix (by using Python 3 string; formatting); to the particular value of R. Second, we need to turn the Z-matrix; string into a Psi4 molecule, by passing it to; `psi4.geometry() <http://psicode.org/psi4manual/master/api/psi4.driver.geometry.html#psi4.driver.geometry>`__.; The argument bsse_type='cp' tells Psi4 to perform counterpoise (CP); correction on the dimer to compute the CCSD(T)/aug-cc-pVDZ interaction; energy, which is stored in our ecp dictionary at each iteration of; our Python loop. Note that we didn’t need to specify ghost atoms, and we; didn’t need to call the monomer and dimer computations separately. Psi4; does it all for us, automatically.; Near the very end of the output file output.dat, the counterpoise; correction Python function will print a nice summary of the results of; the counterpoise computation (the energies of the dimer, of monomer 1; with the ghost functions of monomer 2, of monomer 2 with the ghost; functions of monomer 1, and the overall counterpoise corrected; interaction energy):; N-Body: Computing complex (1/2) with fragments (2,) in the basis of fragments (1, 2).; ...; N-Body: Complex Energy (fragments = (2,), basis = (1, 2): -128.70932405488924); ...; N-Body: Computing complex (2/2) with fragments (1,) in the basis of fragments (1, 2).; ...; N-Body: Complex Energy (fragments = (1,), basis = (1, 2): -128.70932405488935); ...; N-",MatchSource.WIKI,psi4manual/1.2.1/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi.html
https://psicode.org/psi4manual/1.2.1/psiapi.html:9421,Security,access,access,9421,"------------------------------------------------------------------------------------------------ ~     1     -76.026632734908    -76.026632734908      0.01523518      0.01245755      0.02742222      0.02277530  ~     2     -76.027022666011     -0.000389931104      0.00178779      0.00142946      0.01008137      0.00594928  ~     3     -76.027032729374     -0.000010063363      0.00014019      0.00008488      0.00077463      0.00044738  ~ --------------------------------------------------------------------------------------------------------------- ~; To get harmonic vibrational frequencies, it’s important to keep in mind; that the values of the vibrational frequencies are a function of the; molecular geometry. Therefore, it’s important to obtain the vibrational; frequencies AT THE OPTIMIZED GEOMETRY. Luckily, Psi4 updates the; molecule with optimized geometry as it is being optimized. So, the; optimized geometry for H\(_2\)O is stored inside the h2o; molecule object, which we can access! To compute the frequencies, all we; need to do is to again pass the molecule=h2o argument to the; psi4.frequency(); API; function:. In [6]:. scf_e, scf_wfn = psi4.frequency('scf/cc-pvdz', molecule=h2o, return_wfn=True, dertype=1). 6 displacements needed.; 1 2 3 4 5 6. Executing this cell will prompt Psi4 to compute the Hessian (second; derivative matrix) of the electronic energy with respect to nuclear; displacements. From this, it can obtain the harmonic vibrational; frequencies, given below (roundoff errors of around \(0.1\); cm\(^{-1}\) may exist):; Irrep Harmonic Frequency; (cm-1); -----------------------------------------------; A1 1775.6478; A1 4113.3795; B2 4212.1814; -----------------------------------------------. Notice the symmetry type of the normal modes is specified (A1, A1, B2).; The program also print out the normal modes in terms of Cartesian; coordinates of each atom. For example, the normal mode at \(1776\); cm\(^{-1}\) is:; Frequency: 1775.65; Force constant: 0.119",MatchSource.WIKI,psi4manual/1.2.1/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi.html
https://psicode.org/psi4manual/1.2.1/psiapi.html:4297,Usability,simpl,simple,4297,"e the Hartree-Fock SCF; energy with the cc-pVDZ basis set by passing the method/basis set as a; string ('scf/cc-pvdz') into the function psi4.energy(); API:. In [3]:. #! Sample HF/cc-pVDZ H2O Computation. psi4.set_memory('500 MB'). h2o = psi4.geometry(""""""; O; H 1 0.96; H 1 0.96 2 104.5; """"""). psi4.energy('scf/cc-pvdz'). Out[3]:. -76.02663273488399. If everything goes well, the computation should complete and should; report a final restricted Hartree-Fock energy in the output file; output.dat in a section like this:; Energy converged. @DF-RHF Final Energy: -76.02663273486682. By default, the energy should be converged to about; \(1.0\times 10^{-6}\), so agreement is only expected for about the; first 6 digits after the decimal. If the computation does not complete,; there is probably a problem with the compilation or installation of the; program (see the installation instructions in the main Psi4 manual; section Compiling and Installing from; Source).; This very simple input is sufficient to run the requested information.; Notice we didn’t tell the program some otherwise useful information like; the charge of the molecule (0, it’s neutral), the spin multiplicity (1; for a closed-shell molecule with all electrons paired), or the reference; wavefunction to use (restricted Hartree-Fock, or RHF, is usually; appropriate for a closed-shell molecule). The program correctly guessed; all of these options for us. We can change the default behavior through; additional keywords.; Let’s consider what we would do for an open-shell molecule, where not; all the electrons are paired. For example, let’s run a computation on; methylene (\(\text{CH}_2\)), whose ground electronic state has two; unpaired electrons (triplet electronic state, or a spin multiplicity; \(2S + 1 = 3\)). In this case, the default spin multiplicity (1) is; not correct, so we need to tell the program the true value (3). Like; many programs, Psi4 can get the charge and multiplicity as the first two; integers in the",MatchSource.WIKI,psi4manual/1.2.1/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi.html
https://psicode.org/psi4manual/1.2.1/psiapi.html:6566,Usability,simpl,simple,6566,"rted into the geometry; specification using Python 3 string; formatting. In [4]:. #! Sample UHF/6-31G** CH2 Computation. R = 1.075; A = 133.93. ch2 = psi4.geometry(""""""; 0 3; C; H 1 {0}; H 1 {0} 2 {1}; """""".format(R, A); ). psi4.set_options({'reference': 'uhf'}); psi4.energy('scf/6-31g**'). Out[4]:. -38.925334628859886. Executing this cell should yield the final energy as; @DF-UHF Final Energy: -38.92533462887677. Notice the new command, psi4.set_options(); API,; to the input. This function takes a Python; dictionary; as its argument, which is a key-value list which associates a Psi4; keyword; with its user-defined value. For open shell molecules, we have a choice; of unrestricted orbitals (unrestricted Hartree-Fock, or UHF) or; restricted orbitals (restricted open-shell Hartree-Fock, or ROHF).; Usually, UHF is a little easier to converge (although it may be more; susceptible to spin contamination than ROHF). III. Geometry Optimization and Vibrational Frequency Analysis¶; The above examples were simple single-point energy computations (as; specified by the psi4.energy(); API; function). Of course there are other kinds of computations to perform,; such as geometry optimizations and vibrational frequency computations.; These can be specified by replacing psi4.energy(); API; with psi4.optimize(); API; or psi4.frequency(); API,; respectively.; Let’s take a look at an example of optimizing the H\(_2\)O; molecule using Hartree-Fock with a cc-pVDZ basis set.; Now, here comes the real beauty of running Psi4 interactively: above,; when we computed the energy of H\(_2\)O with HF/cc-pVDZ, we; defined the Psi4 molecule object h2o. Since we’re still in the; Python shell, as long as you executed that block of code, we can reuse; the h2o molecule object in our optimization without redefining it,; by adding the molecule=h2o argument to the psi4.optimize(); API; function:. In [5]:. psi4.set_options({'reference': 'rhf'}); psi4.optimize('scf/cc-pvdz', molecule=h2o). Optimizer: Optimizati",MatchSource.WIKI,psi4manual/1.2.1/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi.html
https://psicode.org/psi4manual/1.2.1/psiapi.html:14698,Usability,simpl,simple,14698,"usual aug-cc-pVDZ basis, but; without diffuse functions on hydrogen and without diffuse \(d\); functions on heavy atoms); (Papajak:2011:10).; So, we’ll use that as our standard basis set. The SAPT code is designed; to use density fitting techniques, because they introduce minimal errors; while providing much faster computations; (Hohenstein:2010:184111,Hohenstein:2010:014101).; Since we’re using density fitting for the SAPT, we might as well also; use it for the Hartree-Fock computations that are performed as part of; the SAPT. We can specify that by adding 'scf_type': 'df' to the; dictionary passed to psi4.set_options().; Density fitting procedures require the use of auxiliary basis sets that; pair with the primary basis set. Fortunately, Psi4 is usually smart; enough to figure out what auxiliary basis sets are needed for a given; computation. In this case, jun-cc-pVDZ is a standard enough basis set; (just a simple truncation of the very popular aug-cc-pVDZ basis set); that Psi4 correctly guesses that we want the jun-cc-pVDZ-JKFIT auxiliary; basis for the Hartree-Fock, and the jun-cc-pVDZ-RI basis set for the; SAPT procedure.; To speed up the computation a little, we also tell the SAPT procedure to; freeze the core electrons by adding 'freeze_core': 'true' to the; dictionary passed to psi4.set_options(). The SAPT procedure is; invoked by psi4.energy('sapt0/jun-cc-pvdz', molecule=dimer). Here,; Psi4 knows to automatically run two monomer computations and a dimer; computation and then use these results to perform the SAPT analysis. The; various energy components are printed at the end of the output, in; addition to the total SAPT0 interaction energy. An explanation of the; various energy components can be found in the review by Jeziorski,; Moszynski, and Szalewicz; (Jeziorski:1994:1887),; and this is discussed in more detail in the SAPT; section of the Psi4; manual.; For now, we’ll note that most of the SAPT energy components are; negative; this means those are attra",MatchSource.WIKI,psi4manual/1.2.1/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi.html
https://psicode.org/psi4manual/1.2.1/psiapi.html:17565,Usability,simpl,simple,17565,"ample has the acetylene; perpendicular to the ethylene, with the acetylene hydrogen pointing; directly at the double bond in ethylene; this will be attractive because; the H atoms in acetylene bear a partial positive charge, while the; electron rich double bond in ethylene bears a partial negative charge.; At the same time, the dispersion interaction should be smaller because; the perpendicular geometry does not allow much overlap between the; monomers. Hence, the SAPT analysis helps clarify (and quantify) our; physical understanding about the interaction between the two monomers. V. Potential Surface Scans and Counterpoise Correction Made Easy¶; Finally, let’s consider an example which highlights the advantages of; being able to interact with Psi4 directly with Python.; Suppose you want to do a limited potential energy surface scan, such as; computing the interaction energy between two neon atoms at various; interatomic distances. One simple but unappealing way to do this is to; generate separate geometries for each distance to be studied. Instead,; we can leverage Python loops and string formatting to make our lives; simpler. Additionally, let’s suppose you want to do counterpoise (CP); correction to compute interaction energies. Counterpoise correction; involves computing the dimer energy and then subtracting out the; energies of the two monomers, each evaluated in the dimer basis. Again,; each of these computations could be run in a separate input file, but; because counterpoise correction is a fairly standard procedure for; intermolecular interactions, Psi4 knows about it and has a built-in; routine to perform counterpoise correction. It only needs to know what; method you want to do the couterpoise correction on (here, let’s; consider CCSD(T)), and it needs to know what’s monomer A and what’s; monomer B. This last issue of specifying the monomers separately was; already dealt with in the previous SAPT example, where we saw that two; dashes in the psi4.geometry(",MatchSource.WIKI,psi4manual/1.2.1/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi.html
https://psicode.org/psi4manual/1.2.1/psiapi.html:17752,Usability,simpl,simpler,17752,"ly at the double bond in ethylene; this will be attractive because; the H atoms in acetylene bear a partial positive charge, while the; electron rich double bond in ethylene bears a partial negative charge.; At the same time, the dispersion interaction should be smaller because; the perpendicular geometry does not allow much overlap between the; monomers. Hence, the SAPT analysis helps clarify (and quantify) our; physical understanding about the interaction between the two monomers. V. Potential Surface Scans and Counterpoise Correction Made Easy¶; Finally, let’s consider an example which highlights the advantages of; being able to interact with Psi4 directly with Python.; Suppose you want to do a limited potential energy surface scan, such as; computing the interaction energy between two neon atoms at various; interatomic distances. One simple but unappealing way to do this is to; generate separate geometries for each distance to be studied. Instead,; we can leverage Python loops and string formatting to make our lives; simpler. Additionally, let’s suppose you want to do counterpoise (CP); correction to compute interaction energies. Counterpoise correction; involves computing the dimer energy and then subtracting out the; energies of the two monomers, each evaluated in the dimer basis. Again,; each of these computations could be run in a separate input file, but; because counterpoise correction is a fairly standard procedure for; intermolecular interactions, Psi4 knows about it and has a built-in; routine to perform counterpoise correction. It only needs to know what; method you want to do the couterpoise correction on (here, let’s; consider CCSD(T)), and it needs to know what’s monomer A and what’s; monomer B. This last issue of specifying the monomers separately was; already dealt with in the previous SAPT example, where we saw that two; dashes in the psi4.geometry() string can be used to separate; monomers.; So, we’re going to do counterpoise-corrected CCSD(T) en",MatchSource.WIKI,psi4manual/1.2.1/psiapi.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi.html
https://psicode.org/psi4manual/1.2.1/psimrcc-1.html:5616,Availability,avail,available,5616," the effective Hamiltonian. A value of 1; instructs PSIMRCC to follow the solution with the lowest energy given; a certain set of determinants.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25molecule o2 {; 0 3; O; O 1 2.265122720724; units au; }; set {; basis cc-pvtz; }; set mcscf {; reference rohf; docc [3,0,0,0,0,2,1,1] # Doubly occupied MOs; socc [0,0,1,1,0,0,0,0] # Singly occupied MOs; }; set psimrcc {; corr_wfn ccsd # Do Mk-MRCCSD; frozen_docc [1,0,0,0,0,1,0,0] # Frozen MOs; restricted_docc [2,0,0,0,0,1,1,1] # Doubly occupied MOs; active [0,0,1,1,0,0,0,0] # Active MOs; frozen_uocc [0,0,0,0,0,0,0,0] # Frozen virtual MOs; corr_multp 1 # Select the Ms = 0 component; follow_root 1; wfn_sym B1g # Select the B1g state; }; energy('psimrcc'). Note that the oxygen molecule has 16 electrons (including core), while; the docc array contains only 7 doubly-occupied orbitals (or 14; electrons). Hence, two more electrons are available to place into; the active space (given by active), which consists of 2 orbitals.; Thus there are two active electrons in two orbitals. In this particular; example, we are using standard ROHF orbitals for the Mk-MRCCSD procedure,; rather than TCSCF orbitals. Nevertheless, with the present code,; these orbitals must be provided through the MCSCF module, as specified in the; set mcscf section above. Orbital ordering and selection of the model space¶; The reference determinants \(\Phi_\mu\) are specified in PSIMRCC; via occupational numbers. PSIMRCC requires that four arrays be specified; for this purpose. Frozen doubly occupied orbitals (FROZEN_DOCC) are doubly; occupied in each reference determinant and are not correlated in the; MRCC procedure.; Doubly occupied orbitals (RESTRICTED_DOCC) are doubly; occupied in each reference determinant and are correlated in the MRCC; procedure.; Active orbitals (ACTIVE) are partially occupied in each; reference determinant.; Frozen virtual orbitals (FROZEN_UOCC) are unoc",MatchSource.WIKI,psi4manual/1.2.1/psimrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psimrcc-1.html
https://psicode.org/psi4manual/1.2.1/psimrcc-1.html:2744,Deployability,configurat,configuration,2744,"he Mk-MRCC energy is a chosen eigenvalue of the effective Hamiltonian,; \(\textrm{H}^{eff}_{\mu \nu}\). \[\sum_\nu \textrm{H}^{eff}_{\mu \nu} c_\nu =E c_\nu\]; where. \[\textrm{H}^{eff}_{\mu \nu} = \left \langle \Phi_\mu \right | \hat{H}e^{\hat{T}^\nu} \left | \Phi_\nu \right \rangle \, \textrm{.}\]; PSI4 currently implements Mk-MRCC with singles and doubles; [Mk-MRCCSD] and Mk-MRCCSD with perturbative triples [Mk-MRCCSD(T)]; as formulated in [Evangelista:2010:074107]. A companion perturbation; method (Mk-MRPT2) has been developed based on the Mukherjee formalisim; as shown in [Evangelista:2009:4728].; The current version of the code is limited to reference active spaces; in which all determinants are connected to each other by no more than two; excitations. In practice, this usually means that the active space can have; at most two particles, or at most two holes. Examples would include; CAS(2,2), CAS(2,8), CAS(4,3), etc., where CAS(n,m) refers to a; complete-active-space configuration interaction (CAS-CI) reference with n; electrons in m orbitals. If the user specifies active spaces that do not fit; these limitations, then the code will still run, but some relevant; determinants will be missing, and the answer obtained will be an approximation; to the true Mk-MRCC procedure.; The PSIMRCC code itself does not perform orbital optimization. Hence, the; references used might be considered CAS-CI references, but not CASSCF; references (CASSCF implies that the orbitals have been optimized specifically; to minimize the energy of the CAS-CI reference). However, if one wishes to; use two-configuration self-consistent-field (TCSCF) orbitals, those can; be obtained using the multi-configuration self-consistent-field (MCSCF); component of PSIMRCC (specifying REFERENCE to be twocon).; This is suitable for describing diradicals. Otherwise, one may use RHF or; ROHF orbitals as input to PSIMRCC. Due to a current limitation in the code,; one must obtain orbitals using PSIMRCC’s MCS",MatchSource.WIKI,psi4manual/1.2.1/psimrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psimrcc-1.html
https://psicode.org/psi4manual/1.2.1/psimrcc-1.html:3364,Deployability,configurat,configuration,3364,"ch all determinants are connected to each other by no more than two; excitations. In practice, this usually means that the active space can have; at most two particles, or at most two holes. Examples would include; CAS(2,2), CAS(2,8), CAS(4,3), etc., where CAS(n,m) refers to a; complete-active-space configuration interaction (CAS-CI) reference with n; electrons in m orbitals. If the user specifies active spaces that do not fit; these limitations, then the code will still run, but some relevant; determinants will be missing, and the answer obtained will be an approximation; to the true Mk-MRCC procedure.; The PSIMRCC code itself does not perform orbital optimization. Hence, the; references used might be considered CAS-CI references, but not CASSCF; references (CASSCF implies that the orbitals have been optimized specifically; to minimize the energy of the CAS-CI reference). However, if one wishes to; use two-configuration self-consistent-field (TCSCF) orbitals, those can; be obtained using the multi-configuration self-consistent-field (MCSCF); component of PSIMRCC (specifying REFERENCE to be twocon).; This is suitable for describing diradicals. Otherwise, one may use RHF or; ROHF orbitals as input to PSIMRCC. Due to a current limitation in the code,; one must obtain orbitals using PSIMRCC’s MCSCF module regardless of what; orbital type is chosen, twocon, rhf, or rohf. An example of the; MCSCF input is given below.; PSIMRCC is most commonly used for low-spin cases (singlets or open-shell; singlets). It is capable of performing computations on higher spin states; (e.g., triplets), but in general, not all the required matrix elements have; been coded for high-spin cases, meaning that results will correspond to an; approximate Mk-MRCC computation for high-spin cases. A Simple Example¶; The CORR_WFN allows you to select one of three methods; Mk-MRPT2 [PT2], Mk-MRCCSD [CCSD], or Mk-MRCCSD(T) [CCSD_T].; The CORR_MULTP option allows you to select the Slater; determinants with",MatchSource.WIKI,psi4manual/1.2.1/psimrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psimrcc-1.html
https://psicode.org/psi4manual/1.2.1/psimrcc-1.html:3457,Deployability,configurat,configuration,3457,"ch all determinants are connected to each other by no more than two; excitations. In practice, this usually means that the active space can have; at most two particles, or at most two holes. Examples would include; CAS(2,2), CAS(2,8), CAS(4,3), etc., where CAS(n,m) refers to a; complete-active-space configuration interaction (CAS-CI) reference with n; electrons in m orbitals. If the user specifies active spaces that do not fit; these limitations, then the code will still run, but some relevant; determinants will be missing, and the answer obtained will be an approximation; to the true Mk-MRCC procedure.; The PSIMRCC code itself does not perform orbital optimization. Hence, the; references used might be considered CAS-CI references, but not CASSCF; references (CASSCF implies that the orbitals have been optimized specifically; to minimize the energy of the CAS-CI reference). However, if one wishes to; use two-configuration self-consistent-field (TCSCF) orbitals, those can; be obtained using the multi-configuration self-consistent-field (MCSCF); component of PSIMRCC (specifying REFERENCE to be twocon).; This is suitable for describing diradicals. Otherwise, one may use RHF or; ROHF orbitals as input to PSIMRCC. Due to a current limitation in the code,; one must obtain orbitals using PSIMRCC’s MCSCF module regardless of what; orbital type is chosen, twocon, rhf, or rohf. An example of the; MCSCF input is given below.; PSIMRCC is most commonly used for low-spin cases (singlets or open-shell; singlets). It is capable of performing computations on higher spin states; (e.g., triplets), but in general, not all the required matrix elements have; been coded for high-spin cases, meaning that results will correspond to an; approximate Mk-MRCC computation for high-spin cases. A Simple Example¶; The CORR_WFN allows you to select one of three methods; Mk-MRPT2 [PT2], Mk-MRCCSD [CCSD], or Mk-MRCCSD(T) [CCSD_T].; The CORR_MULTP option allows you to select the Slater; determinants with",MatchSource.WIKI,psi4manual/1.2.1/psimrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psimrcc-1.html
https://psicode.org/psi4manual/1.2.1/psimrcc-1.html:8226,Deployability,update,updated,8226," in each reference determinant and are not correlated in the; MRCC procedure.; Doubly occupied orbitals (RESTRICTED_DOCC) are doubly; occupied in each reference determinant and are correlated in the MRCC; procedure.; Active orbitals (ACTIVE) are partially occupied in each; reference determinant.; Frozen virtual orbitals (FROZEN_UOCC) are unoccupied in; all reference determinants and are excluded from the correlated wave; function. The model space is selected by considering all possible occupations; of the electrons among the orbitals in the active space that result; in determinants with the correct symmetry (WFN_SYM); and the correct \(\textrm{M}_s\) value specified by the keyword; CORR_MULTP. Note that this does not consider the multiplicity; of the wavefunction. Thus, in order to obtain the wavefunction; with a set of \(\textrm{M}_s = 0\) reference determinants for; an open-shell system you should request a CORR_MULTP of; 1 within the PSIMRCC module, and select the root of the effective; Hamiltonian that corresponds to the state of interest. In addition,; the WFN_SYM keyword needs to be specified otherwise the; wavefunction belonging to the all-symmetric irrep will be selected. In; addition, it should be noted that for an open-shell singlet based; on two \(\textrm{M}_s = 0\) determinants the eigenvector is; [\(\frac{1}{\sqrt{2}}\text{,}\frac{1}{\sqrt{2}}\)], which corresponds; to a wavefunction of the following form:. \[\frac{1}{\sqrt{2}} \left( \chi_1 \alpha (1) \chi_2 \beta (2) + \chi_2 \alpha(1) \chi_1 \beta (2) \right)\]; See Appendix PSIMRCC for a complete list of PSIMRCC options. table of contents. PSIMRCC Implementation of Mk-MRCC Theory; A Simple Example; Orbital ordering and selection of the model space. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Theoretical Methods: SCF to FCI. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/psimrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psimrcc-1.html
https://psicode.org/psi4manual/1.2.1/psimrcc-1.html:716,Energy Efficiency,power,powerful,716,"﻿. PSIMRCC Implementation of Mk-MRCC Theory. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Theoretical Methods: SCF to FCI. PSIMRCC Implementation of Mk-MRCC Theory¶; Code author: Francesco A. Evangelista and Andrew C. Simmonett; Section author: Alexander E. Vaughn; Module: Keywords, PSI Variables, PSIMRCC; State-specific Multireference coupled cluster theories provide highly; accurate energies and properties of electronic states that require; a multiconfigurational zeroth-order wavefunction. The PSIMRCC; module contained in PSI4 implements the state-specific; multireference coupled-cluster approach of Mukherjee and co-workers; (Mk-MRCC). This method is implemented and shown to be a powerful tool in; [Evangelista:2006:154113] and [Evangelista:2008:124104]. Mk-MRCC is; based on the Jeziorski-Monkhorst ansatz [Jeziorski:1981:1668] for the; wavefunction, \(\Psi\). \[\left| \Psi \right \rangle = \sum_\mu^d e^{\hat{T}^\mu} \left| \Phi_\mu \right\rangle c_\mu \, \text{,}\]; where \(\Phi_\mu\) are the reference determinants,; \(\hat{T}^\mu\) are reference-specific excitation operators, and; \(c_\mu\) are expansion coefficients obtained through diagonalization; of the Mk-MRCC effective Hamiltonian matrix that allows the various; reference determinants to interact. As an example of how this works; the Mk-MRCCSD excitation operators for each reference is contracted; two-body terms. \[\hat{T}^\mu = \hat{T}^\mu_1 + \hat{T}^\mu_2\]; where. \[\hat{T}^\mu_1 = \sum_i^{\textrm{occ}(\mu)} \sum_a^{\textrm{vir}(\mu)} t_i^a (\mu) \hat{a}^\dagger_a \hat{a}_i\]; and. \[\hat{T}^\mu_2 =\frac{1}{4} \sum_i^{\textrm{occ}(\mu)} \sum_a^{\textrm{vir}(\mu)} t_{ij}^{ab} (\mu) \hat{a}^\dagger_b \hat{a}_j \hat{a}^\dagger_a \hat{a}_i\]; The Mk-MRCC energy is a chosen eigenvalue of the effective Hamiltonian,; \(\textrm{H}^{eff}_{\mu \nu}\). \[\sum_\nu \textrm{H}^{eff}_{\mu \nu} c_\nu =E c_\nu\]; where. \[\textrm{H}^{eff}_{\mu \nu} = \left \langle \Phi_\mu \right | \hat{H}e^{\hat{",MatchSource.WIKI,psi4manual/1.2.1/psimrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psimrcc-1.html
https://psicode.org/psi4manual/1.2.1/psimrcc-1.html:1767,Energy Efficiency,energy,energy,1767,"ool in; [Evangelista:2006:154113] and [Evangelista:2008:124104]. Mk-MRCC is; based on the Jeziorski-Monkhorst ansatz [Jeziorski:1981:1668] for the; wavefunction, \(\Psi\). \[\left| \Psi \right \rangle = \sum_\mu^d e^{\hat{T}^\mu} \left| \Phi_\mu \right\rangle c_\mu \, \text{,}\]; where \(\Phi_\mu\) are the reference determinants,; \(\hat{T}^\mu\) are reference-specific excitation operators, and; \(c_\mu\) are expansion coefficients obtained through diagonalization; of the Mk-MRCC effective Hamiltonian matrix that allows the various; reference determinants to interact. As an example of how this works; the Mk-MRCCSD excitation operators for each reference is contracted; two-body terms. \[\hat{T}^\mu = \hat{T}^\mu_1 + \hat{T}^\mu_2\]; where. \[\hat{T}^\mu_1 = \sum_i^{\textrm{occ}(\mu)} \sum_a^{\textrm{vir}(\mu)} t_i^a (\mu) \hat{a}^\dagger_a \hat{a}_i\]; and. \[\hat{T}^\mu_2 =\frac{1}{4} \sum_i^{\textrm{occ}(\mu)} \sum_a^{\textrm{vir}(\mu)} t_{ij}^{ab} (\mu) \hat{a}^\dagger_b \hat{a}_j \hat{a}^\dagger_a \hat{a}_i\]; The Mk-MRCC energy is a chosen eigenvalue of the effective Hamiltonian,; \(\textrm{H}^{eff}_{\mu \nu}\). \[\sum_\nu \textrm{H}^{eff}_{\mu \nu} c_\nu =E c_\nu\]; where. \[\textrm{H}^{eff}_{\mu \nu} = \left \langle \Phi_\mu \right | \hat{H}e^{\hat{T}^\nu} \left | \Phi_\nu \right \rangle \, \textrm{.}\]; PSI4 currently implements Mk-MRCC with singles and doubles; [Mk-MRCCSD] and Mk-MRCCSD with perturbative triples [Mk-MRCCSD(T)]; as formulated in [Evangelista:2010:074107]. A companion perturbation; method (Mk-MRPT2) has been developed based on the Mukherjee formalisim; as shown in [Evangelista:2009:4728].; The current version of the code is limited to reference active spaces; in which all determinants are connected to each other by no more than two; excitations. In practice, this usually means that the active space can have; at most two particles, or at most two holes. Examples would include; CAS(2,2), CAS(2,8), CAS(4,3), etc., where CAS(n,m) refers to a; compl",MatchSource.WIKI,psi4manual/1.2.1/psimrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psimrcc-1.html
https://psicode.org/psi4manual/1.2.1/psimrcc-1.html:3296,Energy Efficiency,energy,energy,3296,"74107]. A companion perturbation; method (Mk-MRPT2) has been developed based on the Mukherjee formalisim; as shown in [Evangelista:2009:4728].; The current version of the code is limited to reference active spaces; in which all determinants are connected to each other by no more than two; excitations. In practice, this usually means that the active space can have; at most two particles, or at most two holes. Examples would include; CAS(2,2), CAS(2,8), CAS(4,3), etc., where CAS(n,m) refers to a; complete-active-space configuration interaction (CAS-CI) reference with n; electrons in m orbitals. If the user specifies active spaces that do not fit; these limitations, then the code will still run, but some relevant; determinants will be missing, and the answer obtained will be an approximation; to the true Mk-MRCC procedure.; The PSIMRCC code itself does not perform orbital optimization. Hence, the; references used might be considered CAS-CI references, but not CASSCF; references (CASSCF implies that the orbitals have been optimized specifically; to minimize the energy of the CAS-CI reference). However, if one wishes to; use two-configuration self-consistent-field (TCSCF) orbitals, those can; be obtained using the multi-configuration self-consistent-field (MCSCF); component of PSIMRCC (specifying REFERENCE to be twocon).; This is suitable for describing diradicals. Otherwise, one may use RHF or; ROHF orbitals as input to PSIMRCC. Due to a current limitation in the code,; one must obtain orbitals using PSIMRCC’s MCSCF module regardless of what; orbital type is chosen, twocon, rhf, or rohf. An example of the; MCSCF input is given below.; PSIMRCC is most commonly used for low-spin cases (singlets or open-shell; singlets). It is capable of performing computations on higher spin states; (e.g., triplets), but in general, not all the required matrix elements have; been coded for high-spin cases, meaning that results will correspond to an; approximate Mk-MRCC computation for high",MatchSource.WIKI,psi4manual/1.2.1/psimrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psimrcc-1.html
https://psicode.org/psi4manual/1.2.1/psimrcc-1.html:4541,Energy Efficiency,energy,energy,4541,"ecifying REFERENCE to be twocon).; This is suitable for describing diradicals. Otherwise, one may use RHF or; ROHF orbitals as input to PSIMRCC. Due to a current limitation in the code,; one must obtain orbitals using PSIMRCC’s MCSCF module regardless of what; orbital type is chosen, twocon, rhf, or rohf. An example of the; MCSCF input is given below.; PSIMRCC is most commonly used for low-spin cases (singlets or open-shell; singlets). It is capable of performing computations on higher spin states; (e.g., triplets), but in general, not all the required matrix elements have; been coded for high-spin cases, meaning that results will correspond to an; approximate Mk-MRCC computation for high-spin cases. A Simple Example¶; The CORR_WFN allows you to select one of three methods; Mk-MRPT2 [PT2], Mk-MRCCSD [CCSD], or Mk-MRCCSD(T) [CCSD_T].; The CORR_MULTP option allows you to select the Slater; determinants with a particular \(M_s\) value. The WFN_SYM; keyword is neccesary if you do not want to compute the energy of the; totally-symmetric state. The FOLLOW_ROOT option may be used; to follow different roots of the effective Hamiltonian. A value of 1; instructs PSIMRCC to follow the solution with the lowest energy given; a certain set of determinants.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25molecule o2 {; 0 3; O; O 1 2.265122720724; units au; }; set {; basis cc-pvtz; }; set mcscf {; reference rohf; docc [3,0,0,0,0,2,1,1] # Doubly occupied MOs; socc [0,0,1,1,0,0,0,0] # Singly occupied MOs; }; set psimrcc {; corr_wfn ccsd # Do Mk-MRCCSD; frozen_docc [1,0,0,0,0,1,0,0] # Frozen MOs; restricted_docc [2,0,0,0,0,1,1,1] # Doubly occupied MOs; active [0,0,1,1,0,0,0,0] # Active MOs; frozen_uocc [0,0,0,0,0,0,0,0] # Frozen virtual MOs; corr_multp 1 # Select the Ms = 0 component; follow_root 1; wfn_sym B1g # Select the B1g state; }; energy('psimrcc'). Note that the oxygen molecule has 16 electrons (including core), while; the docc array c",MatchSource.WIKI,psi4manual/1.2.1/psimrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psimrcc-1.html
https://psicode.org/psi4manual/1.2.1/psimrcc-1.html:4744,Energy Efficiency,energy,energy,4744,"rbitals using PSIMRCC’s MCSCF module regardless of what; orbital type is chosen, twocon, rhf, or rohf. An example of the; MCSCF input is given below.; PSIMRCC is most commonly used for low-spin cases (singlets or open-shell; singlets). It is capable of performing computations on higher spin states; (e.g., triplets), but in general, not all the required matrix elements have; been coded for high-spin cases, meaning that results will correspond to an; approximate Mk-MRCC computation for high-spin cases. A Simple Example¶; The CORR_WFN allows you to select one of three methods; Mk-MRPT2 [PT2], Mk-MRCCSD [CCSD], or Mk-MRCCSD(T) [CCSD_T].; The CORR_MULTP option allows you to select the Slater; determinants with a particular \(M_s\) value. The WFN_SYM; keyword is neccesary if you do not want to compute the energy of the; totally-symmetric state. The FOLLOW_ROOT option may be used; to follow different roots of the effective Hamiltonian. A value of 1; instructs PSIMRCC to follow the solution with the lowest energy given; a certain set of determinants.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25molecule o2 {; 0 3; O; O 1 2.265122720724; units au; }; set {; basis cc-pvtz; }; set mcscf {; reference rohf; docc [3,0,0,0,0,2,1,1] # Doubly occupied MOs; socc [0,0,1,1,0,0,0,0] # Singly occupied MOs; }; set psimrcc {; corr_wfn ccsd # Do Mk-MRCCSD; frozen_docc [1,0,0,0,0,1,0,0] # Frozen MOs; restricted_docc [2,0,0,0,0,1,1,1] # Doubly occupied MOs; active [0,0,1,1,0,0,0,0] # Active MOs; frozen_uocc [0,0,0,0,0,0,0,0] # Frozen virtual MOs; corr_multp 1 # Select the Ms = 0 component; follow_root 1; wfn_sym B1g # Select the B1g state; }; energy('psimrcc'). Note that the oxygen molecule has 16 electrons (including core), while; the docc array contains only 7 doubly-occupied orbitals (or 14; electrons). Hence, two more electrons are available to place into; the active space (given by active), which consists of 2 orbitals.; Thus there are two act",MatchSource.WIKI,psi4manual/1.2.1/psimrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psimrcc-1.html
https://psicode.org/psi4manual/1.2.1/psimrcc-1.html:5419,Energy Efficiency,energy,energy,5419,"ond to an; approximate Mk-MRCC computation for high-spin cases. A Simple Example¶; The CORR_WFN allows you to select one of three methods; Mk-MRPT2 [PT2], Mk-MRCCSD [CCSD], or Mk-MRCCSD(T) [CCSD_T].; The CORR_MULTP option allows you to select the Slater; determinants with a particular \(M_s\) value. The WFN_SYM; keyword is neccesary if you do not want to compute the energy of the; totally-symmetric state. The FOLLOW_ROOT option may be used; to follow different roots of the effective Hamiltonian. A value of 1; instructs PSIMRCC to follow the solution with the lowest energy given; a certain set of determinants.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25molecule o2 {; 0 3; O; O 1 2.265122720724; units au; }; set {; basis cc-pvtz; }; set mcscf {; reference rohf; docc [3,0,0,0,0,2,1,1] # Doubly occupied MOs; socc [0,0,1,1,0,0,0,0] # Singly occupied MOs; }; set psimrcc {; corr_wfn ccsd # Do Mk-MRCCSD; frozen_docc [1,0,0,0,0,1,0,0] # Frozen MOs; restricted_docc [2,0,0,0,0,1,1,1] # Doubly occupied MOs; active [0,0,1,1,0,0,0,0] # Active MOs; frozen_uocc [0,0,0,0,0,0,0,0] # Frozen virtual MOs; corr_multp 1 # Select the Ms = 0 component; follow_root 1; wfn_sym B1g # Select the B1g state; }; energy('psimrcc'). Note that the oxygen molecule has 16 electrons (including core), while; the docc array contains only 7 doubly-occupied orbitals (or 14; electrons). Hence, two more electrons are available to place into; the active space (given by active), which consists of 2 orbitals.; Thus there are two active electrons in two orbitals. In this particular; example, we are using standard ROHF orbitals for the Mk-MRCCSD procedure,; rather than TCSCF orbitals. Nevertheless, with the present code,; these orbitals must be provided through the MCSCF module, as specified in the; set mcscf section above. Orbital ordering and selection of the model space¶; The reference determinants \(\Phi_\mu\) are specified in PSIMRCC; via occupational numbers. PSI",MatchSource.WIKI,psi4manual/1.2.1/psimrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psimrcc-1.html
https://psicode.org/psi4manual/1.2.1/psimrcc-1.html:1391,Integrability,contract,contracted,1391,"nce coupled cluster theories provide highly; accurate energies and properties of electronic states that require; a multiconfigurational zeroth-order wavefunction. The PSIMRCC; module contained in PSI4 implements the state-specific; multireference coupled-cluster approach of Mukherjee and co-workers; (Mk-MRCC). This method is implemented and shown to be a powerful tool in; [Evangelista:2006:154113] and [Evangelista:2008:124104]. Mk-MRCC is; based on the Jeziorski-Monkhorst ansatz [Jeziorski:1981:1668] for the; wavefunction, \(\Psi\). \[\left| \Psi \right \rangle = \sum_\mu^d e^{\hat{T}^\mu} \left| \Phi_\mu \right\rangle c_\mu \, \text{,}\]; where \(\Phi_\mu\) are the reference determinants,; \(\hat{T}^\mu\) are reference-specific excitation operators, and; \(c_\mu\) are expansion coefficients obtained through diagonalization; of the Mk-MRCC effective Hamiltonian matrix that allows the various; reference determinants to interact. As an example of how this works; the Mk-MRCCSD excitation operators for each reference is contracted; two-body terms. \[\hat{T}^\mu = \hat{T}^\mu_1 + \hat{T}^\mu_2\]; where. \[\hat{T}^\mu_1 = \sum_i^{\textrm{occ}(\mu)} \sum_a^{\textrm{vir}(\mu)} t_i^a (\mu) \hat{a}^\dagger_a \hat{a}_i\]; and. \[\hat{T}^\mu_2 =\frac{1}{4} \sum_i^{\textrm{occ}(\mu)} \sum_a^{\textrm{vir}(\mu)} t_{ij}^{ab} (\mu) \hat{a}^\dagger_b \hat{a}_j \hat{a}^\dagger_a \hat{a}_i\]; The Mk-MRCC energy is a chosen eigenvalue of the effective Hamiltonian,; \(\textrm{H}^{eff}_{\mu \nu}\). \[\sum_\nu \textrm{H}^{eff}_{\mu \nu} c_\nu =E c_\nu\]; where. \[\textrm{H}^{eff}_{\mu \nu} = \left \langle \Phi_\mu \right | \hat{H}e^{\hat{T}^\nu} \left | \Phi_\nu \right \rangle \, \textrm{.}\]; PSI4 currently implements Mk-MRCC with singles and doubles; [Mk-MRCCSD] and Mk-MRCCSD with perturbative triples [Mk-MRCCSD(T)]; as formulated in [Evangelista:2010:074107]. A companion perturbation; method (Mk-MRPT2) has been developed based on the Mukherjee formalisim; as shown in [Evangelista:2009:4",MatchSource.WIKI,psi4manual/1.2.1/psimrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psimrcc-1.html
https://psicode.org/psi4manual/1.2.1/psimrcc-1.html:2744,Modifiability,config,configuration,2744,"he Mk-MRCC energy is a chosen eigenvalue of the effective Hamiltonian,; \(\textrm{H}^{eff}_{\mu \nu}\). \[\sum_\nu \textrm{H}^{eff}_{\mu \nu} c_\nu =E c_\nu\]; where. \[\textrm{H}^{eff}_{\mu \nu} = \left \langle \Phi_\mu \right | \hat{H}e^{\hat{T}^\nu} \left | \Phi_\nu \right \rangle \, \textrm{.}\]; PSI4 currently implements Mk-MRCC with singles and doubles; [Mk-MRCCSD] and Mk-MRCCSD with perturbative triples [Mk-MRCCSD(T)]; as formulated in [Evangelista:2010:074107]. A companion perturbation; method (Mk-MRPT2) has been developed based on the Mukherjee formalisim; as shown in [Evangelista:2009:4728].; The current version of the code is limited to reference active spaces; in which all determinants are connected to each other by no more than two; excitations. In practice, this usually means that the active space can have; at most two particles, or at most two holes. Examples would include; CAS(2,2), CAS(2,8), CAS(4,3), etc., where CAS(n,m) refers to a; complete-active-space configuration interaction (CAS-CI) reference with n; electrons in m orbitals. If the user specifies active spaces that do not fit; these limitations, then the code will still run, but some relevant; determinants will be missing, and the answer obtained will be an approximation; to the true Mk-MRCC procedure.; The PSIMRCC code itself does not perform orbital optimization. Hence, the; references used might be considered CAS-CI references, but not CASSCF; references (CASSCF implies that the orbitals have been optimized specifically; to minimize the energy of the CAS-CI reference). However, if one wishes to; use two-configuration self-consistent-field (TCSCF) orbitals, those can; be obtained using the multi-configuration self-consistent-field (MCSCF); component of PSIMRCC (specifying REFERENCE to be twocon).; This is suitable for describing diradicals. Otherwise, one may use RHF or; ROHF orbitals as input to PSIMRCC. Due to a current limitation in the code,; one must obtain orbitals using PSIMRCC’s MCS",MatchSource.WIKI,psi4manual/1.2.1/psimrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psimrcc-1.html
https://psicode.org/psi4manual/1.2.1/psimrcc-1.html:3364,Modifiability,config,configuration,3364,"ch all determinants are connected to each other by no more than two; excitations. In practice, this usually means that the active space can have; at most two particles, or at most two holes. Examples would include; CAS(2,2), CAS(2,8), CAS(4,3), etc., where CAS(n,m) refers to a; complete-active-space configuration interaction (CAS-CI) reference with n; electrons in m orbitals. If the user specifies active spaces that do not fit; these limitations, then the code will still run, but some relevant; determinants will be missing, and the answer obtained will be an approximation; to the true Mk-MRCC procedure.; The PSIMRCC code itself does not perform orbital optimization. Hence, the; references used might be considered CAS-CI references, but not CASSCF; references (CASSCF implies that the orbitals have been optimized specifically; to minimize the energy of the CAS-CI reference). However, if one wishes to; use two-configuration self-consistent-field (TCSCF) orbitals, those can; be obtained using the multi-configuration self-consistent-field (MCSCF); component of PSIMRCC (specifying REFERENCE to be twocon).; This is suitable for describing diradicals. Otherwise, one may use RHF or; ROHF orbitals as input to PSIMRCC. Due to a current limitation in the code,; one must obtain orbitals using PSIMRCC’s MCSCF module regardless of what; orbital type is chosen, twocon, rhf, or rohf. An example of the; MCSCF input is given below.; PSIMRCC is most commonly used for low-spin cases (singlets or open-shell; singlets). It is capable of performing computations on higher spin states; (e.g., triplets), but in general, not all the required matrix elements have; been coded for high-spin cases, meaning that results will correspond to an; approximate Mk-MRCC computation for high-spin cases. A Simple Example¶; The CORR_WFN allows you to select one of three methods; Mk-MRPT2 [PT2], Mk-MRCCSD [CCSD], or Mk-MRCCSD(T) [CCSD_T].; The CORR_MULTP option allows you to select the Slater; determinants with",MatchSource.WIKI,psi4manual/1.2.1/psimrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psimrcc-1.html
https://psicode.org/psi4manual/1.2.1/psimrcc-1.html:3457,Modifiability,config,configuration,3457,"ch all determinants are connected to each other by no more than two; excitations. In practice, this usually means that the active space can have; at most two particles, or at most two holes. Examples would include; CAS(2,2), CAS(2,8), CAS(4,3), etc., where CAS(n,m) refers to a; complete-active-space configuration interaction (CAS-CI) reference with n; electrons in m orbitals. If the user specifies active spaces that do not fit; these limitations, then the code will still run, but some relevant; determinants will be missing, and the answer obtained will be an approximation; to the true Mk-MRCC procedure.; The PSIMRCC code itself does not perform orbital optimization. Hence, the; references used might be considered CAS-CI references, but not CASSCF; references (CASSCF implies that the orbitals have been optimized specifically; to minimize the energy of the CAS-CI reference). However, if one wishes to; use two-configuration self-consistent-field (TCSCF) orbitals, those can; be obtained using the multi-configuration self-consistent-field (MCSCF); component of PSIMRCC (specifying REFERENCE to be twocon).; This is suitable for describing diradicals. Otherwise, one may use RHF or; ROHF orbitals as input to PSIMRCC. Due to a current limitation in the code,; one must obtain orbitals using PSIMRCC’s MCSCF module regardless of what; orbital type is chosen, twocon, rhf, or rohf. An example of the; MCSCF input is given below.; PSIMRCC is most commonly used for low-spin cases (singlets or open-shell; singlets). It is capable of performing computations on higher spin states; (e.g., triplets), but in general, not all the required matrix elements have; been coded for high-spin cases, meaning that results will correspond to an; approximate Mk-MRCC computation for high-spin cases. A Simple Example¶; The CORR_WFN allows you to select one of three methods; Mk-MRPT2 [PT2], Mk-MRCCSD [CCSD], or Mk-MRCCSD(T) [CCSD_T].; The CORR_MULTP option allows you to select the Slater; determinants with",MatchSource.WIKI,psi4manual/1.2.1/psimrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psimrcc-1.html
https://psicode.org/psi4manual/1.2.1/psimrcc-1.html:3088,Performance,perform,perform,3088,"k-MRCC with singles and doubles; [Mk-MRCCSD] and Mk-MRCCSD with perturbative triples [Mk-MRCCSD(T)]; as formulated in [Evangelista:2010:074107]. A companion perturbation; method (Mk-MRPT2) has been developed based on the Mukherjee formalisim; as shown in [Evangelista:2009:4728].; The current version of the code is limited to reference active spaces; in which all determinants are connected to each other by no more than two; excitations. In practice, this usually means that the active space can have; at most two particles, or at most two holes. Examples would include; CAS(2,2), CAS(2,8), CAS(4,3), etc., where CAS(n,m) refers to a; complete-active-space configuration interaction (CAS-CI) reference with n; electrons in m orbitals. If the user specifies active spaces that do not fit; these limitations, then the code will still run, but some relevant; determinants will be missing, and the answer obtained will be an approximation; to the true Mk-MRCC procedure.; The PSIMRCC code itself does not perform orbital optimization. Hence, the; references used might be considered CAS-CI references, but not CASSCF; references (CASSCF implies that the orbitals have been optimized specifically; to minimize the energy of the CAS-CI reference). However, if one wishes to; use two-configuration self-consistent-field (TCSCF) orbitals, those can; be obtained using the multi-configuration self-consistent-field (MCSCF); component of PSIMRCC (specifying REFERENCE to be twocon).; This is suitable for describing diradicals. Otherwise, one may use RHF or; ROHF orbitals as input to PSIMRCC. Due to a current limitation in the code,; one must obtain orbitals using PSIMRCC’s MCSCF module regardless of what; orbital type is chosen, twocon, rhf, or rohf. An example of the; MCSCF input is given below.; PSIMRCC is most commonly used for low-spin cases (singlets or open-shell; singlets). It is capable of performing computations on higher spin states; (e.g., triplets), but in general, not all the required ",MatchSource.WIKI,psi4manual/1.2.1/psimrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psimrcc-1.html
https://psicode.org/psi4manual/1.2.1/psimrcc-1.html:3104,Performance,optimiz,optimization,3104,"k-MRCC with singles and doubles; [Mk-MRCCSD] and Mk-MRCCSD with perturbative triples [Mk-MRCCSD(T)]; as formulated in [Evangelista:2010:074107]. A companion perturbation; method (Mk-MRPT2) has been developed based on the Mukherjee formalisim; as shown in [Evangelista:2009:4728].; The current version of the code is limited to reference active spaces; in which all determinants are connected to each other by no more than two; excitations. In practice, this usually means that the active space can have; at most two particles, or at most two holes. Examples would include; CAS(2,2), CAS(2,8), CAS(4,3), etc., where CAS(n,m) refers to a; complete-active-space configuration interaction (CAS-CI) reference with n; electrons in m orbitals. If the user specifies active spaces that do not fit; these limitations, then the code will still run, but some relevant; determinants will be missing, and the answer obtained will be an approximation; to the true Mk-MRCC procedure.; The PSIMRCC code itself does not perform orbital optimization. Hence, the; references used might be considered CAS-CI references, but not CASSCF; references (CASSCF implies that the orbitals have been optimized specifically; to minimize the energy of the CAS-CI reference). However, if one wishes to; use two-configuration self-consistent-field (TCSCF) orbitals, those can; be obtained using the multi-configuration self-consistent-field (MCSCF); component of PSIMRCC (specifying REFERENCE to be twocon).; This is suitable for describing diradicals. Otherwise, one may use RHF or; ROHF orbitals as input to PSIMRCC. Due to a current limitation in the code,; one must obtain orbitals using PSIMRCC’s MCSCF module regardless of what; orbital type is chosen, twocon, rhf, or rohf. An example of the; MCSCF input is given below.; PSIMRCC is most commonly used for low-spin cases (singlets or open-shell; singlets). It is capable of performing computations on higher spin states; (e.g., triplets), but in general, not all the required ",MatchSource.WIKI,psi4manual/1.2.1/psimrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psimrcc-1.html
https://psicode.org/psi4manual/1.2.1/psimrcc-1.html:3256,Performance,optimiz,optimized,3256,"74107]. A companion perturbation; method (Mk-MRPT2) has been developed based on the Mukherjee formalisim; as shown in [Evangelista:2009:4728].; The current version of the code is limited to reference active spaces; in which all determinants are connected to each other by no more than two; excitations. In practice, this usually means that the active space can have; at most two particles, or at most two holes. Examples would include; CAS(2,2), CAS(2,8), CAS(4,3), etc., where CAS(n,m) refers to a; complete-active-space configuration interaction (CAS-CI) reference with n; electrons in m orbitals. If the user specifies active spaces that do not fit; these limitations, then the code will still run, but some relevant; determinants will be missing, and the answer obtained will be an approximation; to the true Mk-MRCC procedure.; The PSIMRCC code itself does not perform orbital optimization. Hence, the; references used might be considered CAS-CI references, but not CASSCF; references (CASSCF implies that the orbitals have been optimized specifically; to minimize the energy of the CAS-CI reference). However, if one wishes to; use two-configuration self-consistent-field (TCSCF) orbitals, those can; be obtained using the multi-configuration self-consistent-field (MCSCF); component of PSIMRCC (specifying REFERENCE to be twocon).; This is suitable for describing diradicals. Otherwise, one may use RHF or; ROHF orbitals as input to PSIMRCC. Due to a current limitation in the code,; one must obtain orbitals using PSIMRCC’s MCSCF module regardless of what; orbital type is chosen, twocon, rhf, or rohf. An example of the; MCSCF input is given below.; PSIMRCC is most commonly used for low-spin cases (singlets or open-shell; singlets). It is capable of performing computations on higher spin states; (e.g., triplets), but in general, not all the required matrix elements have; been coded for high-spin cases, meaning that results will correspond to an; approximate Mk-MRCC computation for high",MatchSource.WIKI,psi4manual/1.2.1/psimrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psimrcc-1.html
https://psicode.org/psi4manual/1.2.1/psimrcc-1.html:3983,Performance,perform,performing,3983,"ll be an approximation; to the true Mk-MRCC procedure.; The PSIMRCC code itself does not perform orbital optimization. Hence, the; references used might be considered CAS-CI references, but not CASSCF; references (CASSCF implies that the orbitals have been optimized specifically; to minimize the energy of the CAS-CI reference). However, if one wishes to; use two-configuration self-consistent-field (TCSCF) orbitals, those can; be obtained using the multi-configuration self-consistent-field (MCSCF); component of PSIMRCC (specifying REFERENCE to be twocon).; This is suitable for describing diradicals. Otherwise, one may use RHF or; ROHF orbitals as input to PSIMRCC. Due to a current limitation in the code,; one must obtain orbitals using PSIMRCC’s MCSCF module regardless of what; orbital type is chosen, twocon, rhf, or rohf. An example of the; MCSCF input is given below.; PSIMRCC is most commonly used for low-spin cases (singlets or open-shell; singlets). It is capable of performing computations on higher spin states; (e.g., triplets), but in general, not all the required matrix elements have; been coded for high-spin cases, meaning that results will correspond to an; approximate Mk-MRCC computation for high-spin cases. A Simple Example¶; The CORR_WFN allows you to select one of three methods; Mk-MRPT2 [PT2], Mk-MRCCSD [CCSD], or Mk-MRCCSD(T) [CCSD_T].; The CORR_MULTP option allows you to select the Slater; determinants with a particular \(M_s\) value. The WFN_SYM; keyword is neccesary if you do not want to compute the energy of the; totally-symmetric state. The FOLLOW_ROOT option may be used; to follow different roots of the effective Hamiltonian. A value of 1; instructs PSIMRCC to follow the solution with the lowest energy given; a certain set of determinants.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25molecule o2 {; 0 3; O; O 1 2.265122720724; units au; }; set {; basis cc-pvtz; }; set mcscf {; reference rohf; docc [3,0,",MatchSource.WIKI,psi4manual/1.2.1/psimrcc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psimrcc-1.html
https://psicode.org/psi4manual/1.2.1/psimrcc.html:5616,Availability,avail,available,5616," the effective Hamiltonian. A value of 1; instructs PSIMRCC to follow the solution with the lowest energy given; a certain set of determinants.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25molecule o2 {; 0 3; O; O 1 2.265122720724; units au; }; set {; basis cc-pvtz; }; set mcscf {; reference rohf; docc [3,0,0,0,0,2,1,1] # Doubly occupied MOs; socc [0,0,1,1,0,0,0,0] # Singly occupied MOs; }; set psimrcc {; corr_wfn ccsd # Do Mk-MRCCSD; frozen_docc [1,0,0,0,0,1,0,0] # Frozen MOs; restricted_docc [2,0,0,0,0,1,1,1] # Doubly occupied MOs; active [0,0,1,1,0,0,0,0] # Active MOs; frozen_uocc [0,0,0,0,0,0,0,0] # Frozen virtual MOs; corr_multp 1 # Select the Ms = 0 component; follow_root 1; wfn_sym B1g # Select the B1g state; }; energy('psimrcc'). Note that the oxygen molecule has 16 electrons (including core), while; the docc array contains only 7 doubly-occupied orbitals (or 14; electrons). Hence, two more electrons are available to place into; the active space (given by active), which consists of 2 orbitals.; Thus there are two active electrons in two orbitals. In this particular; example, we are using standard ROHF orbitals for the Mk-MRCCSD procedure,; rather than TCSCF orbitals. Nevertheless, with the present code,; these orbitals must be provided through the MCSCF module, as specified in the; set mcscf section above. Orbital ordering and selection of the model space¶; The reference determinants \(\Phi_\mu\) are specified in PSIMRCC; via occupational numbers. PSIMRCC requires that four arrays be specified; for this purpose. Frozen doubly occupied orbitals (FROZEN_DOCC) are doubly; occupied in each reference determinant and are not correlated in the; MRCC procedure.; Doubly occupied orbitals (RESTRICTED_DOCC) are doubly; occupied in each reference determinant and are correlated in the MRCC; procedure.; Active orbitals (ACTIVE) are partially occupied in each; reference determinant.; Frozen virtual orbitals (FROZEN_UOCC) are unoc",MatchSource.WIKI,psi4manual/1.2.1/psimrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psimrcc.html
https://psicode.org/psi4manual/1.2.1/psimrcc.html:2744,Deployability,configurat,configuration,2744,"he Mk-MRCC energy is a chosen eigenvalue of the effective Hamiltonian,; \(\textrm{H}^{eff}_{\mu \nu}\). \[\sum_\nu \textrm{H}^{eff}_{\mu \nu} c_\nu =E c_\nu\]; where. \[\textrm{H}^{eff}_{\mu \nu} = \left \langle \Phi_\mu \right | \hat{H}e^{\hat{T}^\nu} \left | \Phi_\nu \right \rangle \, \textrm{.}\]; PSI4 currently implements Mk-MRCC with singles and doubles; [Mk-MRCCSD] and Mk-MRCCSD with perturbative triples [Mk-MRCCSD(T)]; as formulated in [Evangelista:2010:074107]. A companion perturbation; method (Mk-MRPT2) has been developed based on the Mukherjee formalisim; as shown in [Evangelista:2009:4728].; The current version of the code is limited to reference active spaces; in which all determinants are connected to each other by no more than two; excitations. In practice, this usually means that the active space can have; at most two particles, or at most two holes. Examples would include; CAS(2,2), CAS(2,8), CAS(4,3), etc., where CAS(n,m) refers to a; complete-active-space configuration interaction (CAS-CI) reference with n; electrons in m orbitals. If the user specifies active spaces that do not fit; these limitations, then the code will still run, but some relevant; determinants will be missing, and the answer obtained will be an approximation; to the true Mk-MRCC procedure.; The PSIMRCC code itself does not perform orbital optimization. Hence, the; references used might be considered CAS-CI references, but not CASSCF; references (CASSCF implies that the orbitals have been optimized specifically; to minimize the energy of the CAS-CI reference). However, if one wishes to; use two-configuration self-consistent-field (TCSCF) orbitals, those can; be obtained using the multi-configuration self-consistent-field (MCSCF); component of PSIMRCC (specifying REFERENCE to be twocon).; This is suitable for describing diradicals. Otherwise, one may use RHF or; ROHF orbitals as input to PSIMRCC. Due to a current limitation in the code,; one must obtain orbitals using PSIMRCC’s MCS",MatchSource.WIKI,psi4manual/1.2.1/psimrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psimrcc.html
https://psicode.org/psi4manual/1.2.1/psimrcc.html:3364,Deployability,configurat,configuration,3364,"ch all determinants are connected to each other by no more than two; excitations. In practice, this usually means that the active space can have; at most two particles, or at most two holes. Examples would include; CAS(2,2), CAS(2,8), CAS(4,3), etc., where CAS(n,m) refers to a; complete-active-space configuration interaction (CAS-CI) reference with n; electrons in m orbitals. If the user specifies active spaces that do not fit; these limitations, then the code will still run, but some relevant; determinants will be missing, and the answer obtained will be an approximation; to the true Mk-MRCC procedure.; The PSIMRCC code itself does not perform orbital optimization. Hence, the; references used might be considered CAS-CI references, but not CASSCF; references (CASSCF implies that the orbitals have been optimized specifically; to minimize the energy of the CAS-CI reference). However, if one wishes to; use two-configuration self-consistent-field (TCSCF) orbitals, those can; be obtained using the multi-configuration self-consistent-field (MCSCF); component of PSIMRCC (specifying REFERENCE to be twocon).; This is suitable for describing diradicals. Otherwise, one may use RHF or; ROHF orbitals as input to PSIMRCC. Due to a current limitation in the code,; one must obtain orbitals using PSIMRCC’s MCSCF module regardless of what; orbital type is chosen, twocon, rhf, or rohf. An example of the; MCSCF input is given below.; PSIMRCC is most commonly used for low-spin cases (singlets or open-shell; singlets). It is capable of performing computations on higher spin states; (e.g., triplets), but in general, not all the required matrix elements have; been coded for high-spin cases, meaning that results will correspond to an; approximate Mk-MRCC computation for high-spin cases. A Simple Example¶; The CORR_WFN allows you to select one of three methods; Mk-MRPT2 [PT2], Mk-MRCCSD [CCSD], or Mk-MRCCSD(T) [CCSD_T].; The CORR_MULTP option allows you to select the Slater; determinants with",MatchSource.WIKI,psi4manual/1.2.1/psimrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psimrcc.html
https://psicode.org/psi4manual/1.2.1/psimrcc.html:3457,Deployability,configurat,configuration,3457,"ch all determinants are connected to each other by no more than two; excitations. In practice, this usually means that the active space can have; at most two particles, or at most two holes. Examples would include; CAS(2,2), CAS(2,8), CAS(4,3), etc., where CAS(n,m) refers to a; complete-active-space configuration interaction (CAS-CI) reference with n; electrons in m orbitals. If the user specifies active spaces that do not fit; these limitations, then the code will still run, but some relevant; determinants will be missing, and the answer obtained will be an approximation; to the true Mk-MRCC procedure.; The PSIMRCC code itself does not perform orbital optimization. Hence, the; references used might be considered CAS-CI references, but not CASSCF; references (CASSCF implies that the orbitals have been optimized specifically; to minimize the energy of the CAS-CI reference). However, if one wishes to; use two-configuration self-consistent-field (TCSCF) orbitals, those can; be obtained using the multi-configuration self-consistent-field (MCSCF); component of PSIMRCC (specifying REFERENCE to be twocon).; This is suitable for describing diradicals. Otherwise, one may use RHF or; ROHF orbitals as input to PSIMRCC. Due to a current limitation in the code,; one must obtain orbitals using PSIMRCC’s MCSCF module regardless of what; orbital type is chosen, twocon, rhf, or rohf. An example of the; MCSCF input is given below.; PSIMRCC is most commonly used for low-spin cases (singlets or open-shell; singlets). It is capable of performing computations on higher spin states; (e.g., triplets), but in general, not all the required matrix elements have; been coded for high-spin cases, meaning that results will correspond to an; approximate Mk-MRCC computation for high-spin cases. A Simple Example¶; The CORR_WFN allows you to select one of three methods; Mk-MRPT2 [PT2], Mk-MRCCSD [CCSD], or Mk-MRCCSD(T) [CCSD_T].; The CORR_MULTP option allows you to select the Slater; determinants with",MatchSource.WIKI,psi4manual/1.2.1/psimrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psimrcc.html
https://psicode.org/psi4manual/1.2.1/psimrcc.html:8226,Deployability,update,updated,8226," in each reference determinant and are not correlated in the; MRCC procedure.; Doubly occupied orbitals (RESTRICTED_DOCC) are doubly; occupied in each reference determinant and are correlated in the MRCC; procedure.; Active orbitals (ACTIVE) are partially occupied in each; reference determinant.; Frozen virtual orbitals (FROZEN_UOCC) are unoccupied in; all reference determinants and are excluded from the correlated wave; function. The model space is selected by considering all possible occupations; of the electrons among the orbitals in the active space that result; in determinants with the correct symmetry (WFN_SYM); and the correct \(\textrm{M}_s\) value specified by the keyword; CORR_MULTP. Note that this does not consider the multiplicity; of the wavefunction. Thus, in order to obtain the wavefunction; with a set of \(\textrm{M}_s = 0\) reference determinants for; an open-shell system you should request a CORR_MULTP of; 1 within the PSIMRCC module, and select the root of the effective; Hamiltonian that corresponds to the state of interest. In addition,; the WFN_SYM keyword needs to be specified otherwise the; wavefunction belonging to the all-symmetric irrep will be selected. In; addition, it should be noted that for an open-shell singlet based; on two \(\textrm{M}_s = 0\) determinants the eigenvector is; [\(\frac{1}{\sqrt{2}}\text{,}\frac{1}{\sqrt{2}}\)], which corresponds; to a wavefunction of the following form:. \[\frac{1}{\sqrt{2}} \left( \chi_1 \alpha (1) \chi_2 \beta (2) + \chi_2 \alpha(1) \chi_1 \beta (2) \right)\]; See Appendix PSIMRCC for a complete list of PSIMRCC options. table of contents. PSIMRCC Implementation of Mk-MRCC Theory; A Simple Example; Orbital ordering and selection of the model space. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Theoretical Methods: SCF to FCI. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/psimrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psimrcc.html
https://psicode.org/psi4manual/1.2.1/psimrcc.html:716,Energy Efficiency,power,powerful,716,"﻿. PSIMRCC Implementation of Mk-MRCC Theory. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Theoretical Methods: SCF to FCI. PSIMRCC Implementation of Mk-MRCC Theory¶; Code author: Francesco A. Evangelista and Andrew C. Simmonett; Section author: Alexander E. Vaughn; Module: Keywords, PSI Variables, PSIMRCC; State-specific Multireference coupled cluster theories provide highly; accurate energies and properties of electronic states that require; a multiconfigurational zeroth-order wavefunction. The PSIMRCC; module contained in PSI4 implements the state-specific; multireference coupled-cluster approach of Mukherjee and co-workers; (Mk-MRCC). This method is implemented and shown to be a powerful tool in; [Evangelista:2006:154113] and [Evangelista:2008:124104]. Mk-MRCC is; based on the Jeziorski-Monkhorst ansatz [Jeziorski:1981:1668] for the; wavefunction, \(\Psi\). \[\left| \Psi \right \rangle = \sum_\mu^d e^{\hat{T}^\mu} \left| \Phi_\mu \right\rangle c_\mu \, \text{,}\]; where \(\Phi_\mu\) are the reference determinants,; \(\hat{T}^\mu\) are reference-specific excitation operators, and; \(c_\mu\) are expansion coefficients obtained through diagonalization; of the Mk-MRCC effective Hamiltonian matrix that allows the various; reference determinants to interact. As an example of how this works; the Mk-MRCCSD excitation operators for each reference is contracted; two-body terms. \[\hat{T}^\mu = \hat{T}^\mu_1 + \hat{T}^\mu_2\]; where. \[\hat{T}^\mu_1 = \sum_i^{\textrm{occ}(\mu)} \sum_a^{\textrm{vir}(\mu)} t_i^a (\mu) \hat{a}^\dagger_a \hat{a}_i\]; and. \[\hat{T}^\mu_2 =\frac{1}{4} \sum_i^{\textrm{occ}(\mu)} \sum_a^{\textrm{vir}(\mu)} t_{ij}^{ab} (\mu) \hat{a}^\dagger_b \hat{a}_j \hat{a}^\dagger_a \hat{a}_i\]; The Mk-MRCC energy is a chosen eigenvalue of the effective Hamiltonian,; \(\textrm{H}^{eff}_{\mu \nu}\). \[\sum_\nu \textrm{H}^{eff}_{\mu \nu} c_\nu =E c_\nu\]; where. \[\textrm{H}^{eff}_{\mu \nu} = \left \langle \Phi_\mu \right | \hat{H}e^{\hat{",MatchSource.WIKI,psi4manual/1.2.1/psimrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psimrcc.html
https://psicode.org/psi4manual/1.2.1/psimrcc.html:1767,Energy Efficiency,energy,energy,1767,"ool in; [Evangelista:2006:154113] and [Evangelista:2008:124104]. Mk-MRCC is; based on the Jeziorski-Monkhorst ansatz [Jeziorski:1981:1668] for the; wavefunction, \(\Psi\). \[\left| \Psi \right \rangle = \sum_\mu^d e^{\hat{T}^\mu} \left| \Phi_\mu \right\rangle c_\mu \, \text{,}\]; where \(\Phi_\mu\) are the reference determinants,; \(\hat{T}^\mu\) are reference-specific excitation operators, and; \(c_\mu\) are expansion coefficients obtained through diagonalization; of the Mk-MRCC effective Hamiltonian matrix that allows the various; reference determinants to interact. As an example of how this works; the Mk-MRCCSD excitation operators for each reference is contracted; two-body terms. \[\hat{T}^\mu = \hat{T}^\mu_1 + \hat{T}^\mu_2\]; where. \[\hat{T}^\mu_1 = \sum_i^{\textrm{occ}(\mu)} \sum_a^{\textrm{vir}(\mu)} t_i^a (\mu) \hat{a}^\dagger_a \hat{a}_i\]; and. \[\hat{T}^\mu_2 =\frac{1}{4} \sum_i^{\textrm{occ}(\mu)} \sum_a^{\textrm{vir}(\mu)} t_{ij}^{ab} (\mu) \hat{a}^\dagger_b \hat{a}_j \hat{a}^\dagger_a \hat{a}_i\]; The Mk-MRCC energy is a chosen eigenvalue of the effective Hamiltonian,; \(\textrm{H}^{eff}_{\mu \nu}\). \[\sum_\nu \textrm{H}^{eff}_{\mu \nu} c_\nu =E c_\nu\]; where. \[\textrm{H}^{eff}_{\mu \nu} = \left \langle \Phi_\mu \right | \hat{H}e^{\hat{T}^\nu} \left | \Phi_\nu \right \rangle \, \textrm{.}\]; PSI4 currently implements Mk-MRCC with singles and doubles; [Mk-MRCCSD] and Mk-MRCCSD with perturbative triples [Mk-MRCCSD(T)]; as formulated in [Evangelista:2010:074107]. A companion perturbation; method (Mk-MRPT2) has been developed based on the Mukherjee formalisim; as shown in [Evangelista:2009:4728].; The current version of the code is limited to reference active spaces; in which all determinants are connected to each other by no more than two; excitations. In practice, this usually means that the active space can have; at most two particles, or at most two holes. Examples would include; CAS(2,2), CAS(2,8), CAS(4,3), etc., where CAS(n,m) refers to a; compl",MatchSource.WIKI,psi4manual/1.2.1/psimrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psimrcc.html
https://psicode.org/psi4manual/1.2.1/psimrcc.html:3296,Energy Efficiency,energy,energy,3296,"74107]. A companion perturbation; method (Mk-MRPT2) has been developed based on the Mukherjee formalisim; as shown in [Evangelista:2009:4728].; The current version of the code is limited to reference active spaces; in which all determinants are connected to each other by no more than two; excitations. In practice, this usually means that the active space can have; at most two particles, or at most two holes. Examples would include; CAS(2,2), CAS(2,8), CAS(4,3), etc., where CAS(n,m) refers to a; complete-active-space configuration interaction (CAS-CI) reference with n; electrons in m orbitals. If the user specifies active spaces that do not fit; these limitations, then the code will still run, but some relevant; determinants will be missing, and the answer obtained will be an approximation; to the true Mk-MRCC procedure.; The PSIMRCC code itself does not perform orbital optimization. Hence, the; references used might be considered CAS-CI references, but not CASSCF; references (CASSCF implies that the orbitals have been optimized specifically; to minimize the energy of the CAS-CI reference). However, if one wishes to; use two-configuration self-consistent-field (TCSCF) orbitals, those can; be obtained using the multi-configuration self-consistent-field (MCSCF); component of PSIMRCC (specifying REFERENCE to be twocon).; This is suitable for describing diradicals. Otherwise, one may use RHF or; ROHF orbitals as input to PSIMRCC. Due to a current limitation in the code,; one must obtain orbitals using PSIMRCC’s MCSCF module regardless of what; orbital type is chosen, twocon, rhf, or rohf. An example of the; MCSCF input is given below.; PSIMRCC is most commonly used for low-spin cases (singlets or open-shell; singlets). It is capable of performing computations on higher spin states; (e.g., triplets), but in general, not all the required matrix elements have; been coded for high-spin cases, meaning that results will correspond to an; approximate Mk-MRCC computation for high",MatchSource.WIKI,psi4manual/1.2.1/psimrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psimrcc.html
https://psicode.org/psi4manual/1.2.1/psimrcc.html:4541,Energy Efficiency,energy,energy,4541,"ecifying REFERENCE to be twocon).; This is suitable for describing diradicals. Otherwise, one may use RHF or; ROHF orbitals as input to PSIMRCC. Due to a current limitation in the code,; one must obtain orbitals using PSIMRCC’s MCSCF module regardless of what; orbital type is chosen, twocon, rhf, or rohf. An example of the; MCSCF input is given below.; PSIMRCC is most commonly used for low-spin cases (singlets or open-shell; singlets). It is capable of performing computations on higher spin states; (e.g., triplets), but in general, not all the required matrix elements have; been coded for high-spin cases, meaning that results will correspond to an; approximate Mk-MRCC computation for high-spin cases. A Simple Example¶; The CORR_WFN allows you to select one of three methods; Mk-MRPT2 [PT2], Mk-MRCCSD [CCSD], or Mk-MRCCSD(T) [CCSD_T].; The CORR_MULTP option allows you to select the Slater; determinants with a particular \(M_s\) value. The WFN_SYM; keyword is neccesary if you do not want to compute the energy of the; totally-symmetric state. The FOLLOW_ROOT option may be used; to follow different roots of the effective Hamiltonian. A value of 1; instructs PSIMRCC to follow the solution with the lowest energy given; a certain set of determinants.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25molecule o2 {; 0 3; O; O 1 2.265122720724; units au; }; set {; basis cc-pvtz; }; set mcscf {; reference rohf; docc [3,0,0,0,0,2,1,1] # Doubly occupied MOs; socc [0,0,1,1,0,0,0,0] # Singly occupied MOs; }; set psimrcc {; corr_wfn ccsd # Do Mk-MRCCSD; frozen_docc [1,0,0,0,0,1,0,0] # Frozen MOs; restricted_docc [2,0,0,0,0,1,1,1] # Doubly occupied MOs; active [0,0,1,1,0,0,0,0] # Active MOs; frozen_uocc [0,0,0,0,0,0,0,0] # Frozen virtual MOs; corr_multp 1 # Select the Ms = 0 component; follow_root 1; wfn_sym B1g # Select the B1g state; }; energy('psimrcc'). Note that the oxygen molecule has 16 electrons (including core), while; the docc array c",MatchSource.WIKI,psi4manual/1.2.1/psimrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psimrcc.html
https://psicode.org/psi4manual/1.2.1/psimrcc.html:4744,Energy Efficiency,energy,energy,4744,"rbitals using PSIMRCC’s MCSCF module regardless of what; orbital type is chosen, twocon, rhf, or rohf. An example of the; MCSCF input is given below.; PSIMRCC is most commonly used for low-spin cases (singlets or open-shell; singlets). It is capable of performing computations on higher spin states; (e.g., triplets), but in general, not all the required matrix elements have; been coded for high-spin cases, meaning that results will correspond to an; approximate Mk-MRCC computation for high-spin cases. A Simple Example¶; The CORR_WFN allows you to select one of three methods; Mk-MRPT2 [PT2], Mk-MRCCSD [CCSD], or Mk-MRCCSD(T) [CCSD_T].; The CORR_MULTP option allows you to select the Slater; determinants with a particular \(M_s\) value. The WFN_SYM; keyword is neccesary if you do not want to compute the energy of the; totally-symmetric state. The FOLLOW_ROOT option may be used; to follow different roots of the effective Hamiltonian. A value of 1; instructs PSIMRCC to follow the solution with the lowest energy given; a certain set of determinants.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25molecule o2 {; 0 3; O; O 1 2.265122720724; units au; }; set {; basis cc-pvtz; }; set mcscf {; reference rohf; docc [3,0,0,0,0,2,1,1] # Doubly occupied MOs; socc [0,0,1,1,0,0,0,0] # Singly occupied MOs; }; set psimrcc {; corr_wfn ccsd # Do Mk-MRCCSD; frozen_docc [1,0,0,0,0,1,0,0] # Frozen MOs; restricted_docc [2,0,0,0,0,1,1,1] # Doubly occupied MOs; active [0,0,1,1,0,0,0,0] # Active MOs; frozen_uocc [0,0,0,0,0,0,0,0] # Frozen virtual MOs; corr_multp 1 # Select the Ms = 0 component; follow_root 1; wfn_sym B1g # Select the B1g state; }; energy('psimrcc'). Note that the oxygen molecule has 16 electrons (including core), while; the docc array contains only 7 doubly-occupied orbitals (or 14; electrons). Hence, two more electrons are available to place into; the active space (given by active), which consists of 2 orbitals.; Thus there are two act",MatchSource.WIKI,psi4manual/1.2.1/psimrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psimrcc.html
https://psicode.org/psi4manual/1.2.1/psimrcc.html:5419,Energy Efficiency,energy,energy,5419,"ond to an; approximate Mk-MRCC computation for high-spin cases. A Simple Example¶; The CORR_WFN allows you to select one of three methods; Mk-MRPT2 [PT2], Mk-MRCCSD [CCSD], or Mk-MRCCSD(T) [CCSD_T].; The CORR_MULTP option allows you to select the Slater; determinants with a particular \(M_s\) value. The WFN_SYM; keyword is neccesary if you do not want to compute the energy of the; totally-symmetric state. The FOLLOW_ROOT option may be used; to follow different roots of the effective Hamiltonian. A value of 1; instructs PSIMRCC to follow the solution with the lowest energy given; a certain set of determinants.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25molecule o2 {; 0 3; O; O 1 2.265122720724; units au; }; set {; basis cc-pvtz; }; set mcscf {; reference rohf; docc [3,0,0,0,0,2,1,1] # Doubly occupied MOs; socc [0,0,1,1,0,0,0,0] # Singly occupied MOs; }; set psimrcc {; corr_wfn ccsd # Do Mk-MRCCSD; frozen_docc [1,0,0,0,0,1,0,0] # Frozen MOs; restricted_docc [2,0,0,0,0,1,1,1] # Doubly occupied MOs; active [0,0,1,1,0,0,0,0] # Active MOs; frozen_uocc [0,0,0,0,0,0,0,0] # Frozen virtual MOs; corr_multp 1 # Select the Ms = 0 component; follow_root 1; wfn_sym B1g # Select the B1g state; }; energy('psimrcc'). Note that the oxygen molecule has 16 electrons (including core), while; the docc array contains only 7 doubly-occupied orbitals (or 14; electrons). Hence, two more electrons are available to place into; the active space (given by active), which consists of 2 orbitals.; Thus there are two active electrons in two orbitals. In this particular; example, we are using standard ROHF orbitals for the Mk-MRCCSD procedure,; rather than TCSCF orbitals. Nevertheless, with the present code,; these orbitals must be provided through the MCSCF module, as specified in the; set mcscf section above. Orbital ordering and selection of the model space¶; The reference determinants \(\Phi_\mu\) are specified in PSIMRCC; via occupational numbers. PSI",MatchSource.WIKI,psi4manual/1.2.1/psimrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psimrcc.html
https://psicode.org/psi4manual/1.2.1/psimrcc.html:1391,Integrability,contract,contracted,1391,"nce coupled cluster theories provide highly; accurate energies and properties of electronic states that require; a multiconfigurational zeroth-order wavefunction. The PSIMRCC; module contained in PSI4 implements the state-specific; multireference coupled-cluster approach of Mukherjee and co-workers; (Mk-MRCC). This method is implemented and shown to be a powerful tool in; [Evangelista:2006:154113] and [Evangelista:2008:124104]. Mk-MRCC is; based on the Jeziorski-Monkhorst ansatz [Jeziorski:1981:1668] for the; wavefunction, \(\Psi\). \[\left| \Psi \right \rangle = \sum_\mu^d e^{\hat{T}^\mu} \left| \Phi_\mu \right\rangle c_\mu \, \text{,}\]; where \(\Phi_\mu\) are the reference determinants,; \(\hat{T}^\mu\) are reference-specific excitation operators, and; \(c_\mu\) are expansion coefficients obtained through diagonalization; of the Mk-MRCC effective Hamiltonian matrix that allows the various; reference determinants to interact. As an example of how this works; the Mk-MRCCSD excitation operators for each reference is contracted; two-body terms. \[\hat{T}^\mu = \hat{T}^\mu_1 + \hat{T}^\mu_2\]; where. \[\hat{T}^\mu_1 = \sum_i^{\textrm{occ}(\mu)} \sum_a^{\textrm{vir}(\mu)} t_i^a (\mu) \hat{a}^\dagger_a \hat{a}_i\]; and. \[\hat{T}^\mu_2 =\frac{1}{4} \sum_i^{\textrm{occ}(\mu)} \sum_a^{\textrm{vir}(\mu)} t_{ij}^{ab} (\mu) \hat{a}^\dagger_b \hat{a}_j \hat{a}^\dagger_a \hat{a}_i\]; The Mk-MRCC energy is a chosen eigenvalue of the effective Hamiltonian,; \(\textrm{H}^{eff}_{\mu \nu}\). \[\sum_\nu \textrm{H}^{eff}_{\mu \nu} c_\nu =E c_\nu\]; where. \[\textrm{H}^{eff}_{\mu \nu} = \left \langle \Phi_\mu \right | \hat{H}e^{\hat{T}^\nu} \left | \Phi_\nu \right \rangle \, \textrm{.}\]; PSI4 currently implements Mk-MRCC with singles and doubles; [Mk-MRCCSD] and Mk-MRCCSD with perturbative triples [Mk-MRCCSD(T)]; as formulated in [Evangelista:2010:074107]. A companion perturbation; method (Mk-MRPT2) has been developed based on the Mukherjee formalisim; as shown in [Evangelista:2009:4",MatchSource.WIKI,psi4manual/1.2.1/psimrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psimrcc.html
https://psicode.org/psi4manual/1.2.1/psimrcc.html:2744,Modifiability,config,configuration,2744,"he Mk-MRCC energy is a chosen eigenvalue of the effective Hamiltonian,; \(\textrm{H}^{eff}_{\mu \nu}\). \[\sum_\nu \textrm{H}^{eff}_{\mu \nu} c_\nu =E c_\nu\]; where. \[\textrm{H}^{eff}_{\mu \nu} = \left \langle \Phi_\mu \right | \hat{H}e^{\hat{T}^\nu} \left | \Phi_\nu \right \rangle \, \textrm{.}\]; PSI4 currently implements Mk-MRCC with singles and doubles; [Mk-MRCCSD] and Mk-MRCCSD with perturbative triples [Mk-MRCCSD(T)]; as formulated in [Evangelista:2010:074107]. A companion perturbation; method (Mk-MRPT2) has been developed based on the Mukherjee formalisim; as shown in [Evangelista:2009:4728].; The current version of the code is limited to reference active spaces; in which all determinants are connected to each other by no more than two; excitations. In practice, this usually means that the active space can have; at most two particles, or at most two holes. Examples would include; CAS(2,2), CAS(2,8), CAS(4,3), etc., where CAS(n,m) refers to a; complete-active-space configuration interaction (CAS-CI) reference with n; electrons in m orbitals. If the user specifies active spaces that do not fit; these limitations, then the code will still run, but some relevant; determinants will be missing, and the answer obtained will be an approximation; to the true Mk-MRCC procedure.; The PSIMRCC code itself does not perform orbital optimization. Hence, the; references used might be considered CAS-CI references, but not CASSCF; references (CASSCF implies that the orbitals have been optimized specifically; to minimize the energy of the CAS-CI reference). However, if one wishes to; use two-configuration self-consistent-field (TCSCF) orbitals, those can; be obtained using the multi-configuration self-consistent-field (MCSCF); component of PSIMRCC (specifying REFERENCE to be twocon).; This is suitable for describing diradicals. Otherwise, one may use RHF or; ROHF orbitals as input to PSIMRCC. Due to a current limitation in the code,; one must obtain orbitals using PSIMRCC’s MCS",MatchSource.WIKI,psi4manual/1.2.1/psimrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psimrcc.html
https://psicode.org/psi4manual/1.2.1/psimrcc.html:3364,Modifiability,config,configuration,3364,"ch all determinants are connected to each other by no more than two; excitations. In practice, this usually means that the active space can have; at most two particles, or at most two holes. Examples would include; CAS(2,2), CAS(2,8), CAS(4,3), etc., where CAS(n,m) refers to a; complete-active-space configuration interaction (CAS-CI) reference with n; electrons in m orbitals. If the user specifies active spaces that do not fit; these limitations, then the code will still run, but some relevant; determinants will be missing, and the answer obtained will be an approximation; to the true Mk-MRCC procedure.; The PSIMRCC code itself does not perform orbital optimization. Hence, the; references used might be considered CAS-CI references, but not CASSCF; references (CASSCF implies that the orbitals have been optimized specifically; to minimize the energy of the CAS-CI reference). However, if one wishes to; use two-configuration self-consistent-field (TCSCF) orbitals, those can; be obtained using the multi-configuration self-consistent-field (MCSCF); component of PSIMRCC (specifying REFERENCE to be twocon).; This is suitable for describing diradicals. Otherwise, one may use RHF or; ROHF orbitals as input to PSIMRCC. Due to a current limitation in the code,; one must obtain orbitals using PSIMRCC’s MCSCF module regardless of what; orbital type is chosen, twocon, rhf, or rohf. An example of the; MCSCF input is given below.; PSIMRCC is most commonly used for low-spin cases (singlets or open-shell; singlets). It is capable of performing computations on higher spin states; (e.g., triplets), but in general, not all the required matrix elements have; been coded for high-spin cases, meaning that results will correspond to an; approximate Mk-MRCC computation for high-spin cases. A Simple Example¶; The CORR_WFN allows you to select one of three methods; Mk-MRPT2 [PT2], Mk-MRCCSD [CCSD], or Mk-MRCCSD(T) [CCSD_T].; The CORR_MULTP option allows you to select the Slater; determinants with",MatchSource.WIKI,psi4manual/1.2.1/psimrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psimrcc.html
https://psicode.org/psi4manual/1.2.1/psimrcc.html:3457,Modifiability,config,configuration,3457,"ch all determinants are connected to each other by no more than two; excitations. In practice, this usually means that the active space can have; at most two particles, or at most two holes. Examples would include; CAS(2,2), CAS(2,8), CAS(4,3), etc., where CAS(n,m) refers to a; complete-active-space configuration interaction (CAS-CI) reference with n; electrons in m orbitals. If the user specifies active spaces that do not fit; these limitations, then the code will still run, but some relevant; determinants will be missing, and the answer obtained will be an approximation; to the true Mk-MRCC procedure.; The PSIMRCC code itself does not perform orbital optimization. Hence, the; references used might be considered CAS-CI references, but not CASSCF; references (CASSCF implies that the orbitals have been optimized specifically; to minimize the energy of the CAS-CI reference). However, if one wishes to; use two-configuration self-consistent-field (TCSCF) orbitals, those can; be obtained using the multi-configuration self-consistent-field (MCSCF); component of PSIMRCC (specifying REFERENCE to be twocon).; This is suitable for describing diradicals. Otherwise, one may use RHF or; ROHF orbitals as input to PSIMRCC. Due to a current limitation in the code,; one must obtain orbitals using PSIMRCC’s MCSCF module regardless of what; orbital type is chosen, twocon, rhf, or rohf. An example of the; MCSCF input is given below.; PSIMRCC is most commonly used for low-spin cases (singlets or open-shell; singlets). It is capable of performing computations on higher spin states; (e.g., triplets), but in general, not all the required matrix elements have; been coded for high-spin cases, meaning that results will correspond to an; approximate Mk-MRCC computation for high-spin cases. A Simple Example¶; The CORR_WFN allows you to select one of three methods; Mk-MRPT2 [PT2], Mk-MRCCSD [CCSD], or Mk-MRCCSD(T) [CCSD_T].; The CORR_MULTP option allows you to select the Slater; determinants with",MatchSource.WIKI,psi4manual/1.2.1/psimrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psimrcc.html
https://psicode.org/psi4manual/1.2.1/psimrcc.html:3088,Performance,perform,perform,3088,"k-MRCC with singles and doubles; [Mk-MRCCSD] and Mk-MRCCSD with perturbative triples [Mk-MRCCSD(T)]; as formulated in [Evangelista:2010:074107]. A companion perturbation; method (Mk-MRPT2) has been developed based on the Mukherjee formalisim; as shown in [Evangelista:2009:4728].; The current version of the code is limited to reference active spaces; in which all determinants are connected to each other by no more than two; excitations. In practice, this usually means that the active space can have; at most two particles, or at most two holes. Examples would include; CAS(2,2), CAS(2,8), CAS(4,3), etc., where CAS(n,m) refers to a; complete-active-space configuration interaction (CAS-CI) reference with n; electrons in m orbitals. If the user specifies active spaces that do not fit; these limitations, then the code will still run, but some relevant; determinants will be missing, and the answer obtained will be an approximation; to the true Mk-MRCC procedure.; The PSIMRCC code itself does not perform orbital optimization. Hence, the; references used might be considered CAS-CI references, but not CASSCF; references (CASSCF implies that the orbitals have been optimized specifically; to minimize the energy of the CAS-CI reference). However, if one wishes to; use two-configuration self-consistent-field (TCSCF) orbitals, those can; be obtained using the multi-configuration self-consistent-field (MCSCF); component of PSIMRCC (specifying REFERENCE to be twocon).; This is suitable for describing diradicals. Otherwise, one may use RHF or; ROHF orbitals as input to PSIMRCC. Due to a current limitation in the code,; one must obtain orbitals using PSIMRCC’s MCSCF module regardless of what; orbital type is chosen, twocon, rhf, or rohf. An example of the; MCSCF input is given below.; PSIMRCC is most commonly used for low-spin cases (singlets or open-shell; singlets). It is capable of performing computations on higher spin states; (e.g., triplets), but in general, not all the required ",MatchSource.WIKI,psi4manual/1.2.1/psimrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psimrcc.html
https://psicode.org/psi4manual/1.2.1/psimrcc.html:3104,Performance,optimiz,optimization,3104,"k-MRCC with singles and doubles; [Mk-MRCCSD] and Mk-MRCCSD with perturbative triples [Mk-MRCCSD(T)]; as formulated in [Evangelista:2010:074107]. A companion perturbation; method (Mk-MRPT2) has been developed based on the Mukherjee formalisim; as shown in [Evangelista:2009:4728].; The current version of the code is limited to reference active spaces; in which all determinants are connected to each other by no more than two; excitations. In practice, this usually means that the active space can have; at most two particles, or at most two holes. Examples would include; CAS(2,2), CAS(2,8), CAS(4,3), etc., where CAS(n,m) refers to a; complete-active-space configuration interaction (CAS-CI) reference with n; electrons in m orbitals. If the user specifies active spaces that do not fit; these limitations, then the code will still run, but some relevant; determinants will be missing, and the answer obtained will be an approximation; to the true Mk-MRCC procedure.; The PSIMRCC code itself does not perform orbital optimization. Hence, the; references used might be considered CAS-CI references, but not CASSCF; references (CASSCF implies that the orbitals have been optimized specifically; to minimize the energy of the CAS-CI reference). However, if one wishes to; use two-configuration self-consistent-field (TCSCF) orbitals, those can; be obtained using the multi-configuration self-consistent-field (MCSCF); component of PSIMRCC (specifying REFERENCE to be twocon).; This is suitable for describing diradicals. Otherwise, one may use RHF or; ROHF orbitals as input to PSIMRCC. Due to a current limitation in the code,; one must obtain orbitals using PSIMRCC’s MCSCF module regardless of what; orbital type is chosen, twocon, rhf, or rohf. An example of the; MCSCF input is given below.; PSIMRCC is most commonly used for low-spin cases (singlets or open-shell; singlets). It is capable of performing computations on higher spin states; (e.g., triplets), but in general, not all the required ",MatchSource.WIKI,psi4manual/1.2.1/psimrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psimrcc.html
https://psicode.org/psi4manual/1.2.1/psimrcc.html:3256,Performance,optimiz,optimized,3256,"74107]. A companion perturbation; method (Mk-MRPT2) has been developed based on the Mukherjee formalisim; as shown in [Evangelista:2009:4728].; The current version of the code is limited to reference active spaces; in which all determinants are connected to each other by no more than two; excitations. In practice, this usually means that the active space can have; at most two particles, or at most two holes. Examples would include; CAS(2,2), CAS(2,8), CAS(4,3), etc., where CAS(n,m) refers to a; complete-active-space configuration interaction (CAS-CI) reference with n; electrons in m orbitals. If the user specifies active spaces that do not fit; these limitations, then the code will still run, but some relevant; determinants will be missing, and the answer obtained will be an approximation; to the true Mk-MRCC procedure.; The PSIMRCC code itself does not perform orbital optimization. Hence, the; references used might be considered CAS-CI references, but not CASSCF; references (CASSCF implies that the orbitals have been optimized specifically; to minimize the energy of the CAS-CI reference). However, if one wishes to; use two-configuration self-consistent-field (TCSCF) orbitals, those can; be obtained using the multi-configuration self-consistent-field (MCSCF); component of PSIMRCC (specifying REFERENCE to be twocon).; This is suitable for describing diradicals. Otherwise, one may use RHF or; ROHF orbitals as input to PSIMRCC. Due to a current limitation in the code,; one must obtain orbitals using PSIMRCC’s MCSCF module regardless of what; orbital type is chosen, twocon, rhf, or rohf. An example of the; MCSCF input is given below.; PSIMRCC is most commonly used for low-spin cases (singlets or open-shell; singlets). It is capable of performing computations on higher spin states; (e.g., triplets), but in general, not all the required matrix elements have; been coded for high-spin cases, meaning that results will correspond to an; approximate Mk-MRCC computation for high",MatchSource.WIKI,psi4manual/1.2.1/psimrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psimrcc.html
https://psicode.org/psi4manual/1.2.1/psimrcc.html:3983,Performance,perform,performing,3983,"ll be an approximation; to the true Mk-MRCC procedure.; The PSIMRCC code itself does not perform orbital optimization. Hence, the; references used might be considered CAS-CI references, but not CASSCF; references (CASSCF implies that the orbitals have been optimized specifically; to minimize the energy of the CAS-CI reference). However, if one wishes to; use two-configuration self-consistent-field (TCSCF) orbitals, those can; be obtained using the multi-configuration self-consistent-field (MCSCF); component of PSIMRCC (specifying REFERENCE to be twocon).; This is suitable for describing diradicals. Otherwise, one may use RHF or; ROHF orbitals as input to PSIMRCC. Due to a current limitation in the code,; one must obtain orbitals using PSIMRCC’s MCSCF module regardless of what; orbital type is chosen, twocon, rhf, or rohf. An example of the; MCSCF input is given below.; PSIMRCC is most commonly used for low-spin cases (singlets or open-shell; singlets). It is capable of performing computations on higher spin states; (e.g., triplets), but in general, not all the required matrix elements have; been coded for high-spin cases, meaning that results will correspond to an; approximate Mk-MRCC computation for high-spin cases. A Simple Example¶; The CORR_WFN allows you to select one of three methods; Mk-MRPT2 [PT2], Mk-MRCCSD [CCSD], or Mk-MRCCSD(T) [CCSD_T].; The CORR_MULTP option allows you to select the Slater; determinants with a particular \(M_s\) value. The WFN_SYM; keyword is neccesary if you do not want to compute the energy of the; totally-symmetric state. The FOLLOW_ROOT option may be used; to follow different roots of the effective Hamiltonian. A value of 1; instructs PSIMRCC to follow the solution with the lowest energy given; a certain set of determinants.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25molecule o2 {; 0 3; O; O 1 2.265122720724; units au; }; set {; basis cc-pvtz; }; set mcscf {; reference rohf; docc [3,0,",MatchSource.WIKI,psi4manual/1.2.1/psimrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psimrcc.html
https://psicode.org/psi4manual/1.2.1/psipep-1.html:435,Deployability,update,updated,435,"﻿. PsiPEP: Plans and Practices to Organize PSI4. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Contributions: Intro to Programming in PSI4. PsiPEP: Plans and Practices to Organize PSI4¶. PEP1: Proposing PsiPEP for PSI4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Contributions: Intro to Programming in PSI4. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/psipep-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psipep-1.html
https://psicode.org/psi4manual/1.2.1/psipep.html:435,Deployability,update,updated,435,"﻿. PsiPEP: Plans and Practices to Organize PSI4. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Contributions: Intro to Programming in PSI4. PsiPEP: Plans and Practices to Organize PSI4¶. PEP1: Proposing PsiPEP for PSI4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Contributions: Intro to Programming in PSI4. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/psipep.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psipep.html
https://psicode.org/psi4manual/1.2.1/psithonfunc-1.html:1495,Deployability,update,updated,1495,"﻿. Psithon Functions: Invoking a Calculation. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Psithon Functions: Invoking a Calculation¶; To allow arbitrarily complex computations to be performed, PSI4 is built; upon the Python interpreter, with modifications termed Psithon. Sec.; Psithon: Structuring an Input File describes the non-standard Python associated with; clean molecule, basis, and option specification in the PSI4 input file.; This documentation addresses the pure Python side- what functions allow; the efficient compiled code to be run, what functions post-process and; interact with that output, and how the ordinary (or ambitious) user can; extent PSI4’s functionality. Notes on Options; Single-Point Energy — energy(); Property; Basis Set Superposition Corrections; Geometry Optimization — optimize() and gradient(); Harmonic Vibrational Analysis and Visualization of Normal Modes — frequency() and hessian(); Visualization of Normal Modes. Database — database(); Output; Available Databases. Complete Basis Set; Output; Extrapolation Schemes; Aliases. Spectroscopic Constants for Diatomics; Function Intercalls; Embarrassing Parallelism; Generation of Cube Files — cubeprop(); Introduction; Cubeprop Tasks; Keywords. Orbital Visualization with VMD; Script Prerequisites; Running the Script; Script Options. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/psithonfunc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithonfunc-1.html
https://psicode.org/psi4manual/1.2.1/psithonfunc-1.html:540,Energy Efficiency,efficient,efficient,540,"﻿. Psithon Functions: Invoking a Calculation. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Psithon Functions: Invoking a Calculation¶; To allow arbitrarily complex computations to be performed, PSI4 is built; upon the Python interpreter, with modifications termed Psithon. Sec.; Psithon: Structuring an Input File describes the non-standard Python associated with; clean molecule, basis, and option specification in the PSI4 input file.; This documentation addresses the pure Python side- what functions allow; the efficient compiled code to be run, what functions post-process and; interact with that output, and how the ordinary (or ambitious) user can; extent PSI4’s functionality. Notes on Options; Single-Point Energy — energy(); Property; Basis Set Superposition Corrections; Geometry Optimization — optimize() and gradient(); Harmonic Vibrational Analysis and Visualization of Normal Modes — frequency() and hessian(); Visualization of Normal Modes. Database — database(); Output; Available Databases. Complete Basis Set; Output; Extrapolation Schemes; Aliases. Spectroscopic Constants for Diatomics; Function Intercalls; Embarrassing Parallelism; Generation of Cube Files — cubeprop(); Introduction; Cubeprop Tasks; Keywords. Orbital Visualization with VMD; Script Prerequisites; Running the Script; Script Options. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/psithonfunc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithonfunc-1.html
https://psicode.org/psi4manual/1.2.1/psithonfunc-1.html:750,Energy Efficiency,energy,energy,750,"﻿. Psithon Functions: Invoking a Calculation. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Psithon Functions: Invoking a Calculation¶; To allow arbitrarily complex computations to be performed, PSI4 is built; upon the Python interpreter, with modifications termed Psithon. Sec.; Psithon: Structuring an Input File describes the non-standard Python associated with; clean molecule, basis, and option specification in the PSI4 input file.; This documentation addresses the pure Python side- what functions allow; the efficient compiled code to be run, what functions post-process and; interact with that output, and how the ordinary (or ambitious) user can; extent PSI4’s functionality. Notes on Options; Single-Point Energy — energy(); Property; Basis Set Superposition Corrections; Geometry Optimization — optimize() and gradient(); Harmonic Vibrational Analysis and Visualization of Normal Modes — frequency() and hessian(); Visualization of Normal Modes. Database — database(); Output; Available Databases. Complete Basis Set; Output; Extrapolation Schemes; Aliases. Spectroscopic Constants for Diatomics; Function Intercalls; Embarrassing Parallelism; Generation of Cube Files — cubeprop(); Introduction; Cubeprop Tasks; Keywords. Orbital Visualization with VMD; Script Prerequisites; Running the Script; Script Options. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/psithonfunc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithonfunc-1.html
https://psicode.org/psi4manual/1.2.1/psithonfunc-1.html:208,Performance,perform,performed,208,"﻿. Psithon Functions: Invoking a Calculation. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Psithon Functions: Invoking a Calculation¶; To allow arbitrarily complex computations to be performed, PSI4 is built; upon the Python interpreter, with modifications termed Psithon. Sec.; Psithon: Structuring an Input File describes the non-standard Python associated with; clean molecule, basis, and option specification in the PSI4 input file.; This documentation addresses the pure Python side- what functions allow; the efficient compiled code to be run, what functions post-process and; interact with that output, and how the ordinary (or ambitious) user can; extent PSI4’s functionality. Notes on Options; Single-Point Energy — energy(); Property; Basis Set Superposition Corrections; Geometry Optimization — optimize() and gradient(); Harmonic Vibrational Analysis and Visualization of Normal Modes — frequency() and hessian(); Visualization of Normal Modes. Database — database(); Output; Available Databases. Complete Basis Set; Output; Extrapolation Schemes; Aliases. Spectroscopic Constants for Diatomics; Function Intercalls; Embarrassing Parallelism; Generation of Cube Files — cubeprop(); Introduction; Cubeprop Tasks; Keywords. Orbital Visualization with VMD; Script Prerequisites; Running the Script; Script Options. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/psithonfunc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithonfunc-1.html
https://psicode.org/psi4manual/1.2.1/psithonfunc-1.html:831,Performance,optimiz,optimize,831,"﻿. Psithon Functions: Invoking a Calculation. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Psithon Functions: Invoking a Calculation¶; To allow arbitrarily complex computations to be performed, PSI4 is built; upon the Python interpreter, with modifications termed Psithon. Sec.; Psithon: Structuring an Input File describes the non-standard Python associated with; clean molecule, basis, and option specification in the PSI4 input file.; This documentation addresses the pure Python side- what functions allow; the efficient compiled code to be run, what functions post-process and; interact with that output, and how the ordinary (or ambitious) user can; extent PSI4’s functionality. Notes on Options; Single-Point Energy — energy(); Property; Basis Set Superposition Corrections; Geometry Optimization — optimize() and gradient(); Harmonic Vibrational Analysis and Visualization of Normal Modes — frequency() and hessian(); Visualization of Normal Modes. Database — database(); Output; Available Databases. Complete Basis Set; Output; Extrapolation Schemes; Aliases. Spectroscopic Constants for Diatomics; Function Intercalls; Embarrassing Parallelism; Generation of Cube Files — cubeprop(); Introduction; Cubeprop Tasks; Keywords. Orbital Visualization with VMD; Script Prerequisites; Running the Script; Script Options. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/psithonfunc-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithonfunc-1.html
https://psicode.org/psi4manual/1.2.1/psithonfunc.html:1495,Deployability,update,updated,1495,"﻿. Psithon Functions: Invoking a Calculation. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Psithon Functions: Invoking a Calculation¶; To allow arbitrarily complex computations to be performed, PSI4 is built; upon the Python interpreter, with modifications termed Psithon. Sec.; Psithon: Structuring an Input File describes the non-standard Python associated with; clean molecule, basis, and option specification in the PSI4 input file.; This documentation addresses the pure Python side- what functions allow; the efficient compiled code to be run, what functions post-process and; interact with that output, and how the ordinary (or ambitious) user can; extent PSI4’s functionality. Notes on Options; Single-Point Energy — energy(); Property; Basis Set Superposition Corrections; Geometry Optimization — optimize() and gradient(); Harmonic Vibrational Analysis and Visualization of Normal Modes — frequency() and hessian(); Visualization of Normal Modes. Database — database(); Output; Available Databases. Complete Basis Set; Output; Extrapolation Schemes; Aliases. Spectroscopic Constants for Diatomics; Function Intercalls; Embarrassing Parallelism; Generation of Cube Files — cubeprop(); Introduction; Cubeprop Tasks; Keywords. Orbital Visualization with VMD; Script Prerequisites; Running the Script; Script Options. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/psithonfunc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithonfunc.html
https://psicode.org/psi4manual/1.2.1/psithonfunc.html:540,Energy Efficiency,efficient,efficient,540,"﻿. Psithon Functions: Invoking a Calculation. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Psithon Functions: Invoking a Calculation¶; To allow arbitrarily complex computations to be performed, PSI4 is built; upon the Python interpreter, with modifications termed Psithon. Sec.; Psithon: Structuring an Input File describes the non-standard Python associated with; clean molecule, basis, and option specification in the PSI4 input file.; This documentation addresses the pure Python side- what functions allow; the efficient compiled code to be run, what functions post-process and; interact with that output, and how the ordinary (or ambitious) user can; extent PSI4’s functionality. Notes on Options; Single-Point Energy — energy(); Property; Basis Set Superposition Corrections; Geometry Optimization — optimize() and gradient(); Harmonic Vibrational Analysis and Visualization of Normal Modes — frequency() and hessian(); Visualization of Normal Modes. Database — database(); Output; Available Databases. Complete Basis Set; Output; Extrapolation Schemes; Aliases. Spectroscopic Constants for Diatomics; Function Intercalls; Embarrassing Parallelism; Generation of Cube Files — cubeprop(); Introduction; Cubeprop Tasks; Keywords. Orbital Visualization with VMD; Script Prerequisites; Running the Script; Script Options. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/psithonfunc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithonfunc.html
https://psicode.org/psi4manual/1.2.1/psithonfunc.html:750,Energy Efficiency,energy,energy,750,"﻿. Psithon Functions: Invoking a Calculation. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Psithon Functions: Invoking a Calculation¶; To allow arbitrarily complex computations to be performed, PSI4 is built; upon the Python interpreter, with modifications termed Psithon. Sec.; Psithon: Structuring an Input File describes the non-standard Python associated with; clean molecule, basis, and option specification in the PSI4 input file.; This documentation addresses the pure Python side- what functions allow; the efficient compiled code to be run, what functions post-process and; interact with that output, and how the ordinary (or ambitious) user can; extent PSI4’s functionality. Notes on Options; Single-Point Energy — energy(); Property; Basis Set Superposition Corrections; Geometry Optimization — optimize() and gradient(); Harmonic Vibrational Analysis and Visualization of Normal Modes — frequency() and hessian(); Visualization of Normal Modes. Database — database(); Output; Available Databases. Complete Basis Set; Output; Extrapolation Schemes; Aliases. Spectroscopic Constants for Diatomics; Function Intercalls; Embarrassing Parallelism; Generation of Cube Files — cubeprop(); Introduction; Cubeprop Tasks; Keywords. Orbital Visualization with VMD; Script Prerequisites; Running the Script; Script Options. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/psithonfunc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithonfunc.html
https://psicode.org/psi4manual/1.2.1/psithonfunc.html:208,Performance,perform,performed,208,"﻿. Psithon Functions: Invoking a Calculation. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Psithon Functions: Invoking a Calculation¶; To allow arbitrarily complex computations to be performed, PSI4 is built; upon the Python interpreter, with modifications termed Psithon. Sec.; Psithon: Structuring an Input File describes the non-standard Python associated with; clean molecule, basis, and option specification in the PSI4 input file.; This documentation addresses the pure Python side- what functions allow; the efficient compiled code to be run, what functions post-process and; interact with that output, and how the ordinary (or ambitious) user can; extent PSI4’s functionality. Notes on Options; Single-Point Energy — energy(); Property; Basis Set Superposition Corrections; Geometry Optimization — optimize() and gradient(); Harmonic Vibrational Analysis and Visualization of Normal Modes — frequency() and hessian(); Visualization of Normal Modes. Database — database(); Output; Available Databases. Complete Basis Set; Output; Extrapolation Schemes; Aliases. Spectroscopic Constants for Diatomics; Function Intercalls; Embarrassing Parallelism; Generation of Cube Files — cubeprop(); Introduction; Cubeprop Tasks; Keywords. Orbital Visualization with VMD; Script Prerequisites; Running the Script; Script Options. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/psithonfunc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithonfunc.html
https://psicode.org/psi4manual/1.2.1/psithonfunc.html:831,Performance,optimiz,optimize,831,"﻿. Psithon Functions: Invoking a Calculation. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Psithon Functions: Invoking a Calculation¶; To allow arbitrarily complex computations to be performed, PSI4 is built; upon the Python interpreter, with modifications termed Psithon. Sec.; Psithon: Structuring an Input File describes the non-standard Python associated with; clean molecule, basis, and option specification in the PSI4 input file.; This documentation addresses the pure Python side- what functions allow; the efficient compiled code to be run, what functions post-process and; interact with that output, and how the ordinary (or ambitious) user can; extent PSI4’s functionality. Notes on Options; Single-Point Energy — energy(); Property; Basis Set Superposition Corrections; Geometry Optimization — optimize() and gradient(); Harmonic Vibrational Analysis and Visualization of Normal Modes — frequency() and hessian(); Visualization of Normal Modes. Database — database(); Output; Available Databases. Complete Basis Set; Output; Extrapolation Schemes; Aliases. Spectroscopic Constants for Diatomics; Function Intercalls; Embarrassing Parallelism; Generation of Cube Files — cubeprop(); Introduction; Cubeprop Tasks; Keywords. Orbital Visualization with VMD; Script Prerequisites; Running the Script; Script Options. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/psithonfunc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithonfunc.html
https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:1294,Availability,avail,available,1294,"some; pre-processing of the input file is performed before it is interpreted,; resulting in Python syntax that is customized for PSI, termed Psithon. In; this section we will describe the essential features of the Psithon language.; PSI4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; 1UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that the user’s ~/.psi4rc values can; override the builtins (in the input file, not in the C++ code).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files. # Do not modify this file! It is auto-generated by the document_options_and_tests; # script, from psi4topdir/psi4/include/psi4/physconst.h; h = 6.62606896E-34 # The Planck constant (Js) ; c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; R = 8.314472 # Universal gas constant (JK$^{-1}$mol$^{-1}$) ; bohr2angstroms = 0.52917720859 # Bohr to Angstroms conversion factor ; bohr2m = 0.52917720859E-10 # Bohr to meters conversion factor ; bohr2cm = 0.5291772",MatchSource.WIKI,psi4manual/1.2.1/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html
https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:1745,Availability,avail,available,1745,"4 source directory and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; 1UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that the user’s ~/.psi4rc values can; override the builtins (in the input file, not in the C++ code).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files. # Do not modify this file! It is auto-generated by the document_options_and_tests; # script, from psi4topdir/psi4/include/psi4/physconst.h; h = 6.62606896E-34 # The Planck constant (Js) ; c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; R = 8.314472 # Universal gas constant (JK$^{-1}$mol$^{-1}$) ; bohr2angstroms = 0.52917720859 # Bohr to Angstroms conversion factor ; bohr2m = 0.52917720859E-10 # Bohr to meters conversion factor ; bohr2cm = 0.52917720859E-8 # Bohr to centimeters conversion factor ; amu2g = 1.660538782E-24 # Atomic mass units to grams conversion factor ; amu2kg = 1.660538782E-27 # Atomic mass units to kg conversion factor ; au2amu = 5.485799097E-4 # Atomic units (m$@@e$) to atomic mass units conversion factor ; hartree2J = 4.359744E-18 # Hartree to joule conversion factor ; hartree2aJ = 4.359744 # Hartree to attojoule (10$^{-18}$J) conversion factor ; cal2J = ",MatchSource.WIKI,psi4manual/1.2.1/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html
https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:3930,Availability,avail,available,3930," Atomic units to Debye conversion factor for dipoles ; dipmom_debye2si = 3.335640952E-30 # Debye to SI units (Cm) conversion factor for dipoles ; c_au = 137.035999679 # Speed of light in atomic units ; hartree2ev = 27.21138 # Hartree to eV conversion factor ; hartree2wavenumbers = 219474.6 # Hartree to cm$^{-1}$ conversion factor ; hartree2kcalmol = 627.5095 # Hartree to kcal mol$^{-1}$ conversion factor ; hartree2kJmol = 2625.500 # Hartree to kilojoule mol$^{-1}$ conversion factor ; hartree2MHz = 6.579684E9 # Hartree to MHz conversion factor ; kcalmol2wavenumbers = 349.7551 # kcal mol$^{-1}$ to cm$^{-1}$ conversion factor ; e0 = 8.854187817E-12 # Vacuum permittivity (Fm$^{-1}$) ; na = 6.02214179E23 # Avagadro's number ; me = 9.10938215E-31 # Electron rest mass (in kg) . In Psithon input files, prepend physical constants with psi_ to; prevent clashes with user-defined variables (e.g., psi_h). In; PsiAPI mode, access as, e.g., psi4.constants.h. Memory Specification¶; By default, PSI4 assumes that 500 MiB of memory are available. While this is; enough for many computations, many of the algorithms will perform better if; more is available. To specify memory, the memory keyword should be used. The following; lines are all equivalent methods for specifying that 2 GB of RAM is available; to PSI4:; 1; 2; 3; 4; 5; 6; 7# all equivalent. memory 2 GB. memory 2000 MB. memory 2000000 kB. Please note that memory can be specified both in IEC binary units (1 KiB = 1024 bytes) and SI units (1 kB = 1000 bytes). PSI4 recognizes and obeys both of them correctly. The units are not case sensitive (Kb and KB are equivalent to kB).; By default, PSI4 performs a “sanity check” when parsing Psithon input files, enforcing a minimum memory requirement of 250 MiB. While it is generally not recomennded to do so, expert users can bypass this check by directly setting the number of bytes availble to PSI4:; 1; 2# setting available memory to 2 MB; set_memory_bytes(2000000). Please note that this memo",MatchSource.WIKI,psi4manual/1.2.1/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html
https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:4041,Availability,avail,available,4041,"o SI units (Cm) conversion factor for dipoles ; c_au = 137.035999679 # Speed of light in atomic units ; hartree2ev = 27.21138 # Hartree to eV conversion factor ; hartree2wavenumbers = 219474.6 # Hartree to cm$^{-1}$ conversion factor ; hartree2kcalmol = 627.5095 # Hartree to kcal mol$^{-1}$ conversion factor ; hartree2kJmol = 2625.500 # Hartree to kilojoule mol$^{-1}$ conversion factor ; hartree2MHz = 6.579684E9 # Hartree to MHz conversion factor ; kcalmol2wavenumbers = 349.7551 # kcal mol$^{-1}$ to cm$^{-1}$ conversion factor ; e0 = 8.854187817E-12 # Vacuum permittivity (Fm$^{-1}$) ; na = 6.02214179E23 # Avagadro's number ; me = 9.10938215E-31 # Electron rest mass (in kg) . In Psithon input files, prepend physical constants with psi_ to; prevent clashes with user-defined variables (e.g., psi_h). In; PsiAPI mode, access as, e.g., psi4.constants.h. Memory Specification¶; By default, PSI4 assumes that 500 MiB of memory are available. While this is; enough for many computations, many of the algorithms will perform better if; more is available. To specify memory, the memory keyword should be used. The following; lines are all equivalent methods for specifying that 2 GB of RAM is available; to PSI4:; 1; 2; 3; 4; 5; 6; 7# all equivalent. memory 2 GB. memory 2000 MB. memory 2000000 kB. Please note that memory can be specified both in IEC binary units (1 KiB = 1024 bytes) and SI units (1 kB = 1000 bytes). PSI4 recognizes and obeys both of them correctly. The units are not case sensitive (Kb and KB are equivalent to kB).; By default, PSI4 performs a “sanity check” when parsing Psithon input files, enforcing a minimum memory requirement of 250 MiB. While it is generally not recomennded to do so, expert users can bypass this check by directly setting the number of bytes availble to PSI4:; 1; 2# setting available memory to 2 MB; set_memory_bytes(2000000). Please note that this memory setting only governs the maximal memory usage of the major data structures and actual total memo",MatchSource.WIKI,psi4manual/1.2.1/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html
https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:4189,Availability,avail,available,4189,"s = 219474.6 # Hartree to cm$^{-1}$ conversion factor ; hartree2kcalmol = 627.5095 # Hartree to kcal mol$^{-1}$ conversion factor ; hartree2kJmol = 2625.500 # Hartree to kilojoule mol$^{-1}$ conversion factor ; hartree2MHz = 6.579684E9 # Hartree to MHz conversion factor ; kcalmol2wavenumbers = 349.7551 # kcal mol$^{-1}$ to cm$^{-1}$ conversion factor ; e0 = 8.854187817E-12 # Vacuum permittivity (Fm$^{-1}$) ; na = 6.02214179E23 # Avagadro's number ; me = 9.10938215E-31 # Electron rest mass (in kg) . In Psithon input files, prepend physical constants with psi_ to; prevent clashes with user-defined variables (e.g., psi_h). In; PsiAPI mode, access as, e.g., psi4.constants.h. Memory Specification¶; By default, PSI4 assumes that 500 MiB of memory are available. While this is; enough for many computations, many of the algorithms will perform better if; more is available. To specify memory, the memory keyword should be used. The following; lines are all equivalent methods for specifying that 2 GB of RAM is available; to PSI4:; 1; 2; 3; 4; 5; 6; 7# all equivalent. memory 2 GB. memory 2000 MB. memory 2000000 kB. Please note that memory can be specified both in IEC binary units (1 KiB = 1024 bytes) and SI units (1 kB = 1000 bytes). PSI4 recognizes and obeys both of them correctly. The units are not case sensitive (Kb and KB are equivalent to kB).; By default, PSI4 performs a “sanity check” when parsing Psithon input files, enforcing a minimum memory requirement of 250 MiB. While it is generally not recomennded to do so, expert users can bypass this check by directly setting the number of bytes availble to PSI4:; 1; 2# setting available memory to 2 MB; set_memory_bytes(2000000). Please note that this memory setting only governs the maximal memory usage of the major data structures and actual total memory usage is slightly higher. This is usually a negligible, except when setting tiny memory allowances.; One convenient way to override the PSI4 default memory is to place a; memory",MatchSource.WIKI,psi4manual/1.2.1/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html
https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:4785,Availability,avail,availble,4785,"user-defined variables (e.g., psi_h). In; PsiAPI mode, access as, e.g., psi4.constants.h. Memory Specification¶; By default, PSI4 assumes that 500 MiB of memory are available. While this is; enough for many computations, many of the algorithms will perform better if; more is available. To specify memory, the memory keyword should be used. The following; lines are all equivalent methods for specifying that 2 GB of RAM is available; to PSI4:; 1; 2; 3; 4; 5; 6; 7# all equivalent. memory 2 GB. memory 2000 MB. memory 2000000 kB. Please note that memory can be specified both in IEC binary units (1 KiB = 1024 bytes) and SI units (1 kB = 1000 bytes). PSI4 recognizes and obeys both of them correctly. The units are not case sensitive (Kb and KB are equivalent to kB).; By default, PSI4 performs a “sanity check” when parsing Psithon input files, enforcing a minimum memory requirement of 250 MiB. While it is generally not recomennded to do so, expert users can bypass this check by directly setting the number of bytes availble to PSI4:; 1; 2# setting available memory to 2 MB; set_memory_bytes(2000000). Please note that this memory setting only governs the maximal memory usage of the major data structures and actual total memory usage is slightly higher. This is usually a negligible, except when setting tiny memory allowances.; One convenient way to override the PSI4 default memory is to place a; memory command in the ~/.psi4rc file (Sec. ~/.psi4rc File). For example,; the following makes the default memory 2 GB.; 1set_memory(2000000000). However, unless you’re assured of having only one job running on a node at; a time (and all nodes on the filesystem with ~/.psi4rc have similar memory; capacities), it is advised to set memory in the input file on a; per-calculation basis.; That same command can be used for PsiAPI mode:; 1psi4.set_memory(int(5e8)). Note; For parallel jobs, the memory keyword represents the total memory; available to the job, not the memory per thread. Molecule and",MatchSource.WIKI,psi4manual/1.2.1/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html
https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:4818,Availability,avail,available,4818,"user-defined variables (e.g., psi_h). In; PsiAPI mode, access as, e.g., psi4.constants.h. Memory Specification¶; By default, PSI4 assumes that 500 MiB of memory are available. While this is; enough for many computations, many of the algorithms will perform better if; more is available. To specify memory, the memory keyword should be used. The following; lines are all equivalent methods for specifying that 2 GB of RAM is available; to PSI4:; 1; 2; 3; 4; 5; 6; 7# all equivalent. memory 2 GB. memory 2000 MB. memory 2000000 kB. Please note that memory can be specified both in IEC binary units (1 KiB = 1024 bytes) and SI units (1 kB = 1000 bytes). PSI4 recognizes and obeys both of them correctly. The units are not case sensitive (Kb and KB are equivalent to kB).; By default, PSI4 performs a “sanity check” when parsing Psithon input files, enforcing a minimum memory requirement of 250 MiB. While it is generally not recomennded to do so, expert users can bypass this check by directly setting the number of bytes availble to PSI4:; 1; 2# setting available memory to 2 MB; set_memory_bytes(2000000). Please note that this memory setting only governs the maximal memory usage of the major data structures and actual total memory usage is slightly higher. This is usually a negligible, except when setting tiny memory allowances.; One convenient way to override the PSI4 default memory is to place a; memory command in the ~/.psi4rc file (Sec. ~/.psi4rc File). For example,; the following makes the default memory 2 GB.; 1set_memory(2000000000). However, unless you’re assured of having only one job running on a node at; a time (and all nodes on the filesystem with ~/.psi4rc have similar memory; capacities), it is advised to set memory in the input file on a; per-calculation basis.; That same command can be used for PsiAPI mode:; 1psi4.set_memory(int(5e8)). Note; For parallel jobs, the memory keyword represents the total memory; available to the job, not the memory per thread. Molecule and",MatchSource.WIKI,psi4manual/1.2.1/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html
https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:5705,Availability,avail,available,5705,"mennded to do so, expert users can bypass this check by directly setting the number of bytes availble to PSI4:; 1; 2# setting available memory to 2 MB; set_memory_bytes(2000000). Please note that this memory setting only governs the maximal memory usage of the major data structures and actual total memory usage is slightly higher. This is usually a negligible, except when setting tiny memory allowances.; One convenient way to override the PSI4 default memory is to place a; memory command in the ~/.psi4rc file (Sec. ~/.psi4rc File). For example,; the following makes the default memory 2 GB.; 1set_memory(2000000000). However, unless you’re assured of having only one job running on a node at; a time (and all nodes on the filesystem with ~/.psi4rc have similar memory; capacities), it is advised to set memory in the input file on a; per-calculation basis.; That same command can be used for PsiAPI mode:; 1psi4.set_memory(int(5e8)). Note; For parallel jobs, the memory keyword represents the total memory; available to the job, not the memory per thread. Molecule and Geometry Specification¶. Molecule and Geometry Specification; Coordinates; Molecule Keywords; Multiple Molecules; Ghost Atoms; Isotopic Substitution; PubChem Database; Symmetry; Non-Covalently Bonded Molecule Fragments; Advanced Python. To add EFP fragments to a molecule, see Molecule Specification. Job Control Keywords¶; PSI4 comprises a number of C++ modules that each perform; specific tasks and are callable directly from the Python front end. Each module; recognizes specific keywords in the input file which control its function.; These keywords are detailed in Appendix Keywords by Module.; The keywords can be made global, or scoped to apply to; certain specific modules. The following examples demonstrate some of the ways; that global keywords can be specified:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21# all equivalent. set globals basis cc-pVDZ. set basis cc-pVDZ. set globals b",MatchSource.WIKI,psi4manual/1.2.1/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html
https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:9376,Availability,avail,available,9376,"last four commands in the above example were to read; 1; 2; 3; 4set basis cc-pVDZ; energy('ccsd'); set ccenergy print 3; set scf print 1. the commands that set the print level would be ineffective, as they would be; processed after the CCSD computation completes.; In PsiAPI mode, one can use commands set_options() and; set_module_options() like below. Note that these values; should be of correct type, strings for strings, floats for floats like; convergences. The function ~psi4.core.clean_options that reinitializes; all options may also be useful to separate calculations in a PsiAPI; session.; 1; 2; 3; 4; 5; 6; 7; 8; 9psi4.set_options({; 'scf_type': 'pk',; 'e_convergence': 1.e-5,; 'soscf': True; }). psi4.set_module_options({; 'geom_maxiter': 50; }). Basis Sets¶. Basis Sets; Built-In Basis Sets; Mixing Basis Sets; Decontracted Basis Sets; User-Defined Basis Sets; Inputting effective core potentials (ECPs). PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results; of each computation available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of; H2 and H atom:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19molecule h2 {; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h {; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol * (2*h_energy - h2_energy); print ""De=%f"" % D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module, and PSI Variables by Alpha defines them. These can be; accessed through the get_variable() function. For example",MatchSource.WIKI,psi4manual/1.2.1/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html
https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:10481,Availability,avail,available,10481,"ish the previous example of; H2 and H atom:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19molecule h2 {; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h {; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol * (2*h_energy - h2_energy); print ""De=%f"" % D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module, and PSI Variables by Alpha defines them. These can be; accessed through the get_variable() function. For example, after; performing a density fitted MP2 computation, both the spin component; scaled energy and the unscaled MP2 energy are made available:; 1; 2e_mp2 = get_variable('MP2 TOTAL ENERGY'); e_scs_mp2 = get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; are cleared at the start of each energy(), etc. in an input; file by clean_variables().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the; last will include SCF TOTAL ENERGY but not; FCI TOTAL ENERGY.; The entire dictionary of PSI variables can be obtained through; get_variables(). Return Values¶; Most of the usual user computation functions (i.e.,; energy(), optimize(), and; frequency()) return simply the current total energy.; Consult the descriptions of other functions in Psithon Functions: Invoking a Calculation for; what quantities they return and for what data structures t",MatchSource.WIKI,psi4manual/1.2.1/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html
https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:11474,Availability,avail,available,11474,"th the spin component; scaled energy and the unscaled MP2 energy are made available:; 1; 2e_mp2 = get_variable('MP2 TOTAL ENERGY'); e_scs_mp2 = get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; are cleared at the start of each energy(), etc. in an input; file by clean_variables().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the; last will include SCF TOTAL ENERGY but not; FCI TOTAL ENERGY.; The entire dictionary of PSI variables can be obtained through; get_variables(). Return Values¶; Most of the usual user computation functions (i.e.,; energy(), optimize(), and; frequency()) return simply the current total energy.; Consult the descriptions of other functions in Psithon Functions: Invoking a Calculation for; what quantities they return and for what data structures they make; available for post-processing. Many users need only deal with the simple return; form for the computation functions.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11# E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = energy(...); E = optimize(...); E = frequency(...); G = gradient(...) # used by optimize(); H = hessian(...) # used by frequency(). For more elaborate post-processing of computations, adding; return_wfn=True keyword argument additionally returns; Wavefunction.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16# power user returns; E, wfn = energy(..., return_wfn=True); E, wfn = optimize(..., return_wfn=True); E, wfn = frequency(..., return_wfn=True); G, wfn = gradient(..., return_wfn=True) # used by optimize(); H, wfn = hessian(..., return_wfn=True) # used by frequency(). # print gradient array and its rms; wfn.gradient",MatchSource.WIKI,psi4manual/1.2.1/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html
https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:14009,Deployability,update,update,14009,"s strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign.; The geometry specification supports delayed initialization of variable,; which permits potential energy scans. As an example, we can scan both the; angle and bond length in water:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16molecule h2o{; O; H 1 R; H 1 R 2 A; }. Rvals = [0.9, 1.0, 1.1]; Avals = range(102, 106, 2). set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). The declarations of Rvals and Avals are both completely standard Python syntax.; Having named our molecule h2o we can then set the values of R and A within; the loops. Note that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the set keyword.; Cartesian geometries, because of details of the geometry update process,; need to be specified within the loop(s) along with their basis set when; geometry scans are performed. See scf4 for analogous Z-matrix; and Cartiesian scans. Tables of Results¶; The results of computations can be compactly tabulated with the Table() Psithon; function. For example, in the following potential energy surface scan for water; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27molecule h2o {; O; H 1 R; H 1 R 2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(100,102,2). table=Table(rows=[""R"",""A""], cols=[""E(SCF)"",""E(SCS)"",""E(DFMP2)""]). set basis cc-pvdz. for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('mp2'); escf = get_variable('SCF TOTAL ENERGY'); edfmp2 = get_variable('MP2 TOTAL ENERGY'); escsmp2 = get_variable('SCS-MP2 TOTAL ENERGY'); table[R][A] = [escf, escsmp2, edfmp2]. print table; relative=table.copy(); relative.absolute_to_relative(); print relative. we first define a table (on line 10) with two row indices and three column; ind",MatchSource.WIKI,psi4manual/1.2.1/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html
https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:15715,Deployability,integrat,integrated,15715,"R; for A in Avals:; h2o.A = A; energy('mp2'); escf = get_variable('SCF TOTAL ENERGY'); edfmp2 = get_variable('MP2 TOTAL ENERGY'); escsmp2 = get_variable('SCS-MP2 TOTAL ENERGY'); table[R][A] = [escf, escsmp2, edfmp2]. print table; relative=table.copy(); relative.absolute_to_relative(); print relative. we first define a table (on line 10) with two row indices and three column; indices. As the potential energy scan is performed, the results are stored; (line 22) and the final table is printed to the output file (line 24). The; table is converted from absolute energies to relative energies (in kcal mol-1); on line 26, before being printed again. The relative energies are reported with; respect to the lowest value in each column. More examples of how to control the; formatting of the tables can be found in the sample input files provided; see; Appendix Test Suite and Sample Inputs for a complete listing. Python Wrappers¶; The Python foundations of the PSI4 driver and Psithon syntax permit; many commonly performed post-processing procedures to be integrated into; the PSI4 suite.; As seen in the neon dimer example from the tutorial section,; the nbody_gufunc() wrapper provides automatic computation of; counterpoise-corrected interaction energies between two molecules. For; example,; 1energy('mp2', bsse_type='cp'). will compute the counterpoise-corrected density-fitted MP2 interaction energy; between two molecules.; PSI4 also provides the cbs() wrapper,; which automatically computes a complete-basis-set extrapolation (and; automatically sets up the computations with different basis sets required to; do the extrapolation). For example,:; 1; 2; 3; 4; 5# all equivalent. cbs('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). energy('mp2/cc-pv[dt]z'). will compute a 2-point Helgaker extrapolation of the correlation energy; using the cc-pVDZ and cc-pVTZ basis sets (with method MP2) and add this; extrapolated correlation energy to the Hartree–Fock energy in the; lar",MatchSource.WIKI,psi4manual/1.2.1/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html
https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:18034,Deployability,update,updated,18034,"he cbs() wrapper,; which automatically computes a complete-basis-set extrapolation (and; automatically sets up the computations with different basis sets required to; do the extrapolation). For example,:; 1; 2; 3; 4; 5# all equivalent. cbs('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). energy('mp2/cc-pv[dt]z'). will compute a 2-point Helgaker extrapolation of the correlation energy; using the cc-pVDZ and cc-pVTZ basis sets (with method MP2) and add this; extrapolated correlation energy to the Hartree–Fock energy in the; largest basis (cc-pVTZ). cbs() can; either be called directly, as in the first example, or the convenience; syntax of the equivalent second example can be used.; Another very useful and powerful feature of PSI4 is the ability; to compute results on entire databases of molecules at a time,; as provided by the database() wrapper. For example,:; 1database('mp2', 'S22', cp=1, benchmark='S22B'). will perform DF-MP2 counterpoise-corrected interaction energies; (cp=1) on all members of Hobza’s S22 database set of van der Waals; dimers, and then compare the results against the S22B benchmark energies.; Built-in databases include S22, A24, HTBH, HBC6, HSG, S22by5, S66, JSCH,; NCB31, S66by8, and NBC10, among others.; These wrapper functions are discussed separately in; Psithon Functions: Invoking a Calculation. Note that the options documented for Python; functions are placed as arguments in the command that calls the function,; not in the set {...} block or with any other set command. table of contents. Psithon: Structuring an Input File; Physical Constants; Memory Specification; Molecule and Geometry Specification; Job Control Keywords; Basis Sets; PSI Variables; Return Values; Loops; Tables of Results; Python Wrappers. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html
https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:2248,Energy Efficiency,meter,meters,2248,"s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that the user’s ~/.psi4rc values can; override the builtins (in the input file, not in the C++ code).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files. # Do not modify this file! It is auto-generated by the document_options_and_tests; # script, from psi4topdir/psi4/include/psi4/physconst.h; h = 6.62606896E-34 # The Planck constant (Js) ; c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; R = 8.314472 # Universal gas constant (JK$^{-1}$mol$^{-1}$) ; bohr2angstroms = 0.52917720859 # Bohr to Angstroms conversion factor ; bohr2m = 0.52917720859E-10 # Bohr to meters conversion factor ; bohr2cm = 0.52917720859E-8 # Bohr to centimeters conversion factor ; amu2g = 1.660538782E-24 # Atomic mass units to grams conversion factor ; amu2kg = 1.660538782E-27 # Atomic mass units to kg conversion factor ; au2amu = 5.485799097E-4 # Atomic units (m$@@e$) to atomic mass units conversion factor ; hartree2J = 4.359744E-18 # Hartree to joule conversion factor ; hartree2aJ = 4.359744 # Hartree to attojoule (10$^{-18}$J) conversion factor ; cal2J = 4.184 # Calorie to joule conversion factor ; dipmom_au2si = 8.47835281E-30 # Atomic units to SI units (Cm) conversion factor for dipoles ; dipmom_au2debye = 2.54174623 # Atomic units to Debye conversion factor for dipoles ; dipmom_debye2si = 3.335640952E-30 # Debye to SI units (Cm) conversion factor for dipoles ; c_au = 137.035999679 # Speed of light in atomic units ; hartree2ev = 27.21138 # Hartree to eV conversion factor ; hartree2wavenumbers = 219474.6 # Hartree to cm$^{-1}$ conversion factor ; hartree2kcalmol = 627.50",MatchSource.WIKI,psi4manual/1.2.1/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html
https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:2615,Energy Efficiency,joule,joule,2615,"uiltins (in the input file, not in the C++ code).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files. # Do not modify this file! It is auto-generated by the document_options_and_tests; # script, from psi4topdir/psi4/include/psi4/physconst.h; h = 6.62606896E-34 # The Planck constant (Js) ; c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; R = 8.314472 # Universal gas constant (JK$^{-1}$mol$^{-1}$) ; bohr2angstroms = 0.52917720859 # Bohr to Angstroms conversion factor ; bohr2m = 0.52917720859E-10 # Bohr to meters conversion factor ; bohr2cm = 0.52917720859E-8 # Bohr to centimeters conversion factor ; amu2g = 1.660538782E-24 # Atomic mass units to grams conversion factor ; amu2kg = 1.660538782E-27 # Atomic mass units to kg conversion factor ; au2amu = 5.485799097E-4 # Atomic units (m$@@e$) to atomic mass units conversion factor ; hartree2J = 4.359744E-18 # Hartree to joule conversion factor ; hartree2aJ = 4.359744 # Hartree to attojoule (10$^{-18}$J) conversion factor ; cal2J = 4.184 # Calorie to joule conversion factor ; dipmom_au2si = 8.47835281E-30 # Atomic units to SI units (Cm) conversion factor for dipoles ; dipmom_au2debye = 2.54174623 # Atomic units to Debye conversion factor for dipoles ; dipmom_debye2si = 3.335640952E-30 # Debye to SI units (Cm) conversion factor for dipoles ; c_au = 137.035999679 # Speed of light in atomic units ; hartree2ev = 27.21138 # Hartree to eV conversion factor ; hartree2wavenumbers = 219474.6 # Hartree to cm$^{-1}$ conversion factor ; hartree2kcalmol = 627.5095 # Hartree to kcal mol$^{-1}$ conversion factor ; hartree2kJmol = 2625.500 # Hartree to kilojoule mol$^{-1}$ conversion factor ; hartree2MHz = 6.579684E9 # Hartree to MHz conversion factor ; kcalmol2wavenumbers = 349.7551 # kcal mol$^{-1}$ to cm$^{-1}$ conversion factor ; e0 = 8.854187817E-12 # Vacuum permittivity (Fm$^{-1}$) ; na = 6.02214179E23 # Avagadro's numbe",MatchSource.WIKI,psi4manual/1.2.1/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html
https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:2747,Energy Efficiency,joule,joule,2747,"n all PSI4 input files. # Do not modify this file! It is auto-generated by the document_options_and_tests; # script, from psi4topdir/psi4/include/psi4/physconst.h; h = 6.62606896E-34 # The Planck constant (Js) ; c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; R = 8.314472 # Universal gas constant (JK$^{-1}$mol$^{-1}$) ; bohr2angstroms = 0.52917720859 # Bohr to Angstroms conversion factor ; bohr2m = 0.52917720859E-10 # Bohr to meters conversion factor ; bohr2cm = 0.52917720859E-8 # Bohr to centimeters conversion factor ; amu2g = 1.660538782E-24 # Atomic mass units to grams conversion factor ; amu2kg = 1.660538782E-27 # Atomic mass units to kg conversion factor ; au2amu = 5.485799097E-4 # Atomic units (m$@@e$) to atomic mass units conversion factor ; hartree2J = 4.359744E-18 # Hartree to joule conversion factor ; hartree2aJ = 4.359744 # Hartree to attojoule (10$^{-18}$J) conversion factor ; cal2J = 4.184 # Calorie to joule conversion factor ; dipmom_au2si = 8.47835281E-30 # Atomic units to SI units (Cm) conversion factor for dipoles ; dipmom_au2debye = 2.54174623 # Atomic units to Debye conversion factor for dipoles ; dipmom_debye2si = 3.335640952E-30 # Debye to SI units (Cm) conversion factor for dipoles ; c_au = 137.035999679 # Speed of light in atomic units ; hartree2ev = 27.21138 # Hartree to eV conversion factor ; hartree2wavenumbers = 219474.6 # Hartree to cm$^{-1}$ conversion factor ; hartree2kcalmol = 627.5095 # Hartree to kcal mol$^{-1}$ conversion factor ; hartree2kJmol = 2625.500 # Hartree to kilojoule mol$^{-1}$ conversion factor ; hartree2MHz = 6.579684E9 # Hartree to MHz conversion factor ; kcalmol2wavenumbers = 349.7551 # kcal mol$^{-1}$ to cm$^{-1}$ conversion factor ; e0 = 8.854187817E-12 # Vacuum permittivity (Fm$^{-1}$) ; na = 6.02214179E23 # Avagadro's number ; me = 9.10938215E-31 # Electron rest mass (in kg) . In Psithon input files, prepend physical constants with psi_ to; prevent clashes ",MatchSource.WIKI,psi4manual/1.2.1/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html
https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:7844,Energy Efficiency,energy,energy,7844,"lack of quotes around cc-pVDZ, even though it is a string. The; Psithon preprocessor automatically wraps any string values in set commands in; strings. The last three examples provide a more convenient way for specifying; multiple keywords:; 1; 2; 3; 4; 5set {; basis = cc-pVDZ; print = 1; reference = rhf; }. For arguments that require an array input, standard Python list syntax should; be used, viz.:; 1; 2; 3set {; docc = [3, 0, 1, 1]; }. List/matrix inputs may span multiple lines, as long as the opening [ is; on the same line as the name of the keyword.; Any of the above keyword specifications can be scoped to individual modules,; by adding the name of the module after the set keyword. Omitting the module; name, or using the name global or globals will result in the keyword being; applied to all modules. For example, in the following input; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13molecule{; o; h 1 roh; h 1 roh 2 ahoh. roh = 0.957; ahoh = 104.5; }. set basis cc-pVDZ; set ccenergy print 3; set scf print 1; energy('ccsd'). the basis set is set to cc-pVDZ throughout, the SCF code will have a print; level of 1 and the ccenergy code, which performs coupled cluster computations,; will use a print level of 3. In this example a full CCSD computation is; performed by running the SCF code first, then the coupled cluster modules;; the energy() Python helper function ensures that this is performed correctly.; Note that the Python interpreter executes commands in the order they appear in; the input file, so if the last four commands in the above example were to read; 1; 2; 3; 4set basis cc-pVDZ; energy('ccsd'); set ccenergy print 3; set scf print 1. the commands that set the print level would be ineffective, as they would be; processed after the CCSD computation completes.; In PsiAPI mode, one can use commands set_options() and; set_module_options() like below. Note that these values; should be of correct type, strings for strings, floats for floats like; convergences. The func",MatchSource.WIKI,psi4manual/1.2.1/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html
https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:8169,Energy Efficiency,energy,energy,8169,"ts that require an array input, standard Python list syntax should; be used, viz.:; 1; 2; 3set {; docc = [3, 0, 1, 1]; }. List/matrix inputs may span multiple lines, as long as the opening [ is; on the same line as the name of the keyword.; Any of the above keyword specifications can be scoped to individual modules,; by adding the name of the module after the set keyword. Omitting the module; name, or using the name global or globals will result in the keyword being; applied to all modules. For example, in the following input; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13molecule{; o; h 1 roh; h 1 roh 2 ahoh. roh = 0.957; ahoh = 104.5; }. set basis cc-pVDZ; set ccenergy print 3; set scf print 1; energy('ccsd'). the basis set is set to cc-pVDZ throughout, the SCF code will have a print; level of 1 and the ccenergy code, which performs coupled cluster computations,; will use a print level of 3. In this example a full CCSD computation is; performed by running the SCF code first, then the coupled cluster modules;; the energy() Python helper function ensures that this is performed correctly.; Note that the Python interpreter executes commands in the order they appear in; the input file, so if the last four commands in the above example were to read; 1; 2; 3; 4set basis cc-pVDZ; energy('ccsd'); set ccenergy print 3; set scf print 1. the commands that set the print level would be ineffective, as they would be; processed after the CCSD computation completes.; In PsiAPI mode, one can use commands set_options() and; set_module_options() like below. Note that these values; should be of correct type, strings for strings, floats for floats like; convergences. The function ~psi4.core.clean_options that reinitializes; all options may also be useful to separate calculations in a PsiAPI; session.; 1; 2; 3; 4; 5; 6; 7; 8; 9psi4.set_options({; 'scf_type': 'pk',; 'e_convergence': 1.e-5,; 'soscf': True; }). psi4.set_module_options({; 'geom_maxiter': 50; }). Basis Sets¶. Basis Sets; Built-In",MatchSource.WIKI,psi4manual/1.2.1/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html
https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:8433,Energy Efficiency,energy,energy,8433,"me of the keyword.; Any of the above keyword specifications can be scoped to individual modules,; by adding the name of the module after the set keyword. Omitting the module; name, or using the name global or globals will result in the keyword being; applied to all modules. For example, in the following input; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13molecule{; o; h 1 roh; h 1 roh 2 ahoh. roh = 0.957; ahoh = 104.5; }. set basis cc-pVDZ; set ccenergy print 3; set scf print 1; energy('ccsd'). the basis set is set to cc-pVDZ throughout, the SCF code will have a print; level of 1 and the ccenergy code, which performs coupled cluster computations,; will use a print level of 3. In this example a full CCSD computation is; performed by running the SCF code first, then the coupled cluster modules;; the energy() Python helper function ensures that this is performed correctly.; Note that the Python interpreter executes commands in the order they appear in; the input file, so if the last four commands in the above example were to read; 1; 2; 3; 4set basis cc-pVDZ; energy('ccsd'); set ccenergy print 3; set scf print 1. the commands that set the print level would be ineffective, as they would be; processed after the CCSD computation completes.; In PsiAPI mode, one can use commands set_options() and; set_module_options() like below. Note that these values; should be of correct type, strings for strings, floats for floats like; convergences. The function ~psi4.core.clean_options that reinitializes; all options may also be useful to separate calculations in a PsiAPI; session.; 1; 2; 3; 4; 5; 6; 7; 8; 9psi4.set_options({; 'scf_type': 'pk',; 'e_convergence': 1.e-5,; 'soscf': True; }). psi4.set_module_options({; 'geom_maxiter': 50; }). Basis Sets¶. Basis Sets; Built-In Basis Sets; Mixing Basis Sets; Decontracted Basis Sets; User-Defined Basis Sets; Inputting effective core potentials (ECPs). PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results; of each c",MatchSource.WIKI,psi4manual/1.2.1/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html
https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:9300,Energy Efficiency,power,power,9300,"last four commands in the above example were to read; 1; 2; 3; 4set basis cc-pVDZ; energy('ccsd'); set ccenergy print 3; set scf print 1. the commands that set the print level would be ineffective, as they would be; processed after the CCSD computation completes.; In PsiAPI mode, one can use commands set_options() and; set_module_options() like below. Note that these values; should be of correct type, strings for strings, floats for floats like; convergences. The function ~psi4.core.clean_options that reinitializes; all options may also be useful to separate calculations in a PsiAPI; session.; 1; 2; 3; 4; 5; 6; 7; 8; 9psi4.set_options({; 'scf_type': 'pk',; 'e_convergence': 1.e-5,; 'soscf': True; }). psi4.set_module_options({; 'geom_maxiter': 50; }). Basis Sets¶. Basis Sets; Built-In Basis Sets; Mixing Basis Sets; Decontracted Basis Sets; User-Defined Basis Sets; Inputting effective core potentials (ECPs). PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results; of each computation available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of; H2 and H atom:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19molecule h2 {; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h {; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol * (2*h_energy - h2_energy); print ""De=%f"" % D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module, and PSI Variables by Alpha defines them. These can be; accessed through the get_variable() function. For example",MatchSource.WIKI,psi4manual/1.2.1/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html
https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:9653,Energy Efficiency,energy,energy,9653," can use commands set_options() and; set_module_options() like below. Note that these values; should be of correct type, strings for strings, floats for floats like; convergences. The function ~psi4.core.clean_options that reinitializes; all options may also be useful to separate calculations in a PsiAPI; session.; 1; 2; 3; 4; 5; 6; 7; 8; 9psi4.set_options({; 'scf_type': 'pk',; 'e_convergence': 1.e-5,; 'soscf': True; }). psi4.set_module_options({; 'geom_maxiter': 50; }). Basis Sets¶. Basis Sets; Built-In Basis Sets; Mixing Basis Sets; Decontracted Basis Sets; User-Defined Basis Sets; Inputting effective core potentials (ECPs). PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results; of each computation available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of; H2 and H atom:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19molecule h2 {; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h {; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol * (2*h_energy - h2_energy); print ""De=%f"" % D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module, and PSI Variables by Alpha defines them. These can be; accessed through the get_variable() function. For example, after; performing a density fitted MP2 computation, both the spin component; scaled energy and the unscaled MP2 energy are made available:; 1; 2e_mp2 = get_variable('MP2 TOTAL ENERGY'); e_scs_mp2 = get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI vari",MatchSource.WIKI,psi4manual/1.2.1/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html
https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:9737,Energy Efficiency,energy,energy,9737," values; should be of correct type, strings for strings, floats for floats like; convergences. The function ~psi4.core.clean_options that reinitializes; all options may also be useful to separate calculations in a PsiAPI; session.; 1; 2; 3; 4; 5; 6; 7; 8; 9psi4.set_options({; 'scf_type': 'pk',; 'e_convergence': 1.e-5,; 'soscf': True; }). psi4.set_module_options({; 'geom_maxiter': 50; }). Basis Sets¶. Basis Sets; Built-In Basis Sets; Mixing Basis Sets; Decontracted Basis Sets; User-Defined Basis Sets; Inputting effective core potentials (ECPs). PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results; of each computation available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of; H2 and H atom:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19molecule h2 {; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h {; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol * (2*h_energy - h2_energy); print ""De=%f"" % D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module, and PSI Variables by Alpha defines them. These can be; accessed through the get_variable() function. For example, after; performing a density fitted MP2 computation, both the spin component; scaled energy and the unscaled MP2 energy are made available:; 1; 2e_mp2 = get_variable('MP2 TOTAL ENERGY'); e_scs_mp2 = get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the ou",MatchSource.WIKI,psi4manual/1.2.1/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html
https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:9831,Energy Efficiency,energy,energy,9831,"ful to separate calculations in a PsiAPI; session.; 1; 2; 3; 4; 5; 6; 7; 8; 9psi4.set_options({; 'scf_type': 'pk',; 'e_convergence': 1.e-5,; 'soscf': True; }). psi4.set_module_options({; 'geom_maxiter': 50; }). Basis Sets¶. Basis Sets; Built-In Basis Sets; Mixing Basis Sets; Decontracted Basis Sets; User-Defined Basis Sets; Inputting effective core potentials (ECPs). PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results; of each computation available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of; H2 and H atom:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19molecule h2 {; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h {; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol * (2*h_energy - h2_energy); print ""De=%f"" % D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module, and PSI Variables by Alpha defines them. These can be; accessed through the get_variable() function. For example, after; performing a density fitted MP2 computation, both the spin component; scaled energy and the unscaled MP2 energy are made available:; 1; 2e_mp2 = get_variable('MP2 TOTAL ENERGY'); e_scs_mp2 = get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; are cleared at the start of each energy(), etc. in an input; file by clean_variables().; So if you",MatchSource.WIKI,psi4manual/1.2.1/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html
https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:9915,Energy Efficiency,energy,energy,9915,"ful to separate calculations in a PsiAPI; session.; 1; 2; 3; 4; 5; 6; 7; 8; 9psi4.set_options({; 'scf_type': 'pk',; 'e_convergence': 1.e-5,; 'soscf': True; }). psi4.set_module_options({; 'geom_maxiter': 50; }). Basis Sets¶. Basis Sets; Built-In Basis Sets; Mixing Basis Sets; Decontracted Basis Sets; User-Defined Basis Sets; Inputting effective core potentials (ECPs). PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results; of each computation available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of; H2 and H atom:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19molecule h2 {; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h {; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol * (2*h_energy - h2_energy); print ""De=%f"" % D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module, and PSI Variables by Alpha defines them. These can be; accessed through the get_variable() function. For example, after; performing a density fitted MP2 computation, both the spin component; scaled energy and the unscaled MP2 energy are made available:; 1; 2e_mp2 = get_variable('MP2 TOTAL ENERGY'); e_scs_mp2 = get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; are cleared at the start of each energy(), etc. in an input; file by clean_variables().; So if you",MatchSource.WIKI,psi4manual/1.2.1/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html
https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:10029,Energy Efficiency,energy,energy,10029,"-5,; 'soscf': True; }). psi4.set_module_options({; 'geom_maxiter': 50; }). Basis Sets¶. Basis Sets; Built-In Basis Sets; Mixing Basis Sets; Decontracted Basis Sets; User-Defined Basis Sets; Inputting effective core potentials (ECPs). PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results; of each computation available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of; H2 and H atom:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19molecule h2 {; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h {; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol * (2*h_energy - h2_energy); print ""De=%f"" % D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module, and PSI Variables by Alpha defines them. These can be; accessed through the get_variable() function. For example, after; performing a density fitted MP2 computation, both the spin component; scaled energy and the unscaled MP2 energy are made available:; 1; 2e_mp2 = get_variable('MP2 TOTAL ENERGY'); e_scs_mp2 = get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; are cleared at the start of each energy(), etc. in an input; file by clean_variables().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the; last will include ",MatchSource.WIKI,psi4manual/1.2.1/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html
https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:10437,Energy Efficiency,energy,energy,10437,"ish the previous example of; H2 and H atom:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19molecule h2 {; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h {; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol * (2*h_energy - h2_energy); print ""De=%f"" % D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module, and PSI Variables by Alpha defines them. These can be; accessed through the get_variable() function. For example, after; performing a density fitted MP2 computation, both the spin component; scaled energy and the unscaled MP2 energy are made available:; 1; 2e_mp2 = get_variable('MP2 TOTAL ENERGY'); e_scs_mp2 = get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; are cleared at the start of each energy(), etc. in an input; file by clean_variables().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the; last will include SCF TOTAL ENERGY but not; FCI TOTAL ENERGY.; The entire dictionary of PSI variables can be obtained through; get_variables(). Return Values¶; Most of the usual user computation functions (i.e.,; energy(), optimize(), and; frequency()) return simply the current total energy.; Consult the descriptions of other functions in Psithon Functions: Invoking a Calculation for; what quantities they return and for what data structures t",MatchSource.WIKI,psi4manual/1.2.1/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html
https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:10465,Energy Efficiency,energy,energy,10465,"ish the previous example of; H2 and H atom:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19molecule h2 {; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h {; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol * (2*h_energy - h2_energy); print ""De=%f"" % D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module, and PSI Variables by Alpha defines them. These can be; accessed through the get_variable() function. For example, after; performing a density fitted MP2 computation, both the spin component; scaled energy and the unscaled MP2 energy are made available:; 1; 2e_mp2 = get_variable('MP2 TOTAL ENERGY'); e_scs_mp2 = get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; are cleared at the start of each energy(), etc. in an input; file by clean_variables().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the; last will include SCF TOTAL ENERGY but not; FCI TOTAL ENERGY.; The entire dictionary of PSI variables can be obtained through; get_variables(). Return Values¶; Most of the usual user computation functions (i.e.,; energy(), optimize(), and; frequency()) return simply the current total energy.; Consult the descriptions of other functions in Psithon Functions: Invoking a Calculation for; what quantities they return and for what data structures t",MatchSource.WIKI,psi4manual/1.2.1/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html
https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:10835,Energy Efficiency,energy,energy,10835,"""De=%f"" % D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module, and PSI Variables by Alpha defines them. These can be; accessed through the get_variable() function. For example, after; performing a density fitted MP2 computation, both the spin component; scaled energy and the unscaled MP2 energy are made available:; 1; 2e_mp2 = get_variable('MP2 TOTAL ENERGY'); e_scs_mp2 = get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; are cleared at the start of each energy(), etc. in an input; file by clean_variables().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the; last will include SCF TOTAL ENERGY but not; FCI TOTAL ENERGY.; The entire dictionary of PSI variables can be obtained through; get_variables(). Return Values¶; Most of the usual user computation functions (i.e.,; energy(), optimize(), and; frequency()) return simply the current total energy.; Consult the descriptions of other functions in Psithon Functions: Invoking a Calculation for; what quantities they return and for what data structures they make; available for post-processing. Many users need only deal with the simple return; form for the computation functions.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11# E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = energy(...); E = optimize(...); E = f",MatchSource.WIKI,psi4manual/1.2.1/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html
https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:11231,Energy Efficiency,energy,energy,11231,"ines them. These can be; accessed through the get_variable() function. For example, after; performing a density fitted MP2 computation, both the spin component; scaled energy and the unscaled MP2 energy are made available:; 1; 2e_mp2 = get_variable('MP2 TOTAL ENERGY'); e_scs_mp2 = get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; are cleared at the start of each energy(), etc. in an input; file by clean_variables().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the; last will include SCF TOTAL ENERGY but not; FCI TOTAL ENERGY.; The entire dictionary of PSI variables can be obtained through; get_variables(). Return Values¶; Most of the usual user computation functions (i.e.,; energy(), optimize(), and; frequency()) return simply the current total energy.; Consult the descriptions of other functions in Psithon Functions: Invoking a Calculation for; what quantities they return and for what data structures they make; available for post-processing. Many users need only deal with the simple return; form for the computation functions.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11# E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = energy(...); E = optimize(...); E = frequency(...); G = gradient(...) # used by optimize(); H = hessian(...) # used by frequency(). For more elaborate post-processing of computations, adding; return_wfn=True keyword argument additionally returns; Wavefunction.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16# power user returns; E, wfn = energy(..., return_wfn=True); E, wfn = optimize(..., return_wfn=True); E, wfn = frequency(..., return_wfn=True); G, wfn = gradient(..., return_wfn=",MatchSource.WIKI,psi4manual/1.2.1/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html
https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:11303,Energy Efficiency,energy,energy,11303,"ines them. These can be; accessed through the get_variable() function. For example, after; performing a density fitted MP2 computation, both the spin component; scaled energy and the unscaled MP2 energy are made available:; 1; 2e_mp2 = get_variable('MP2 TOTAL ENERGY'); e_scs_mp2 = get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; are cleared at the start of each energy(), etc. in an input; file by clean_variables().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the; last will include SCF TOTAL ENERGY but not; FCI TOTAL ENERGY.; The entire dictionary of PSI variables can be obtained through; get_variables(). Return Values¶; Most of the usual user computation functions (i.e.,; energy(), optimize(), and; frequency()) return simply the current total energy.; Consult the descriptions of other functions in Psithon Functions: Invoking a Calculation for; what quantities they return and for what data structures they make; available for post-processing. Many users need only deal with the simple return; form for the computation functions.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11# E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = energy(...); E = optimize(...); E = frequency(...); G = gradient(...) # used by optimize(); H = hessian(...) # used by frequency(). For more elaborate post-processing of computations, adding; return_wfn=True keyword argument additionally returns; Wavefunction.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16# power user returns; E, wfn = energy(..., return_wfn=True); E, wfn = optimize(..., return_wfn=True); E, wfn = frequency(..., return_wfn=True); G, wfn = gradient(..., return_wfn=",MatchSource.WIKI,psi4manual/1.2.1/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html
https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:11638,Energy Efficiency,energy,energy,11638,"ion. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; are cleared at the start of each energy(), etc. in an input; file by clean_variables().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the; last will include SCF TOTAL ENERGY but not; FCI TOTAL ENERGY.; The entire dictionary of PSI variables can be obtained through; get_variables(). Return Values¶; Most of the usual user computation functions (i.e.,; energy(), optimize(), and; frequency()) return simply the current total energy.; Consult the descriptions of other functions in Psithon Functions: Invoking a Calculation for; what quantities they return and for what data structures they make; available for post-processing. Many users need only deal with the simple return; form for the computation functions.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11# E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = energy(...); E = optimize(...); E = frequency(...); G = gradient(...) # used by optimize(); H = hessian(...) # used by frequency(). For more elaborate post-processing of computations, adding; return_wfn=True keyword argument additionally returns; Wavefunction.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16# power user returns; E, wfn = energy(..., return_wfn=True); E, wfn = optimize(..., return_wfn=True); E, wfn = frequency(..., return_wfn=True); G, wfn = gradient(..., return_wfn=True) # used by optimize(); H, wfn = hessian(..., return_wfn=True) # used by frequency(). # print gradient array and its rms; wfn.gradient.print_out(); print wfn.gradient().rms(). # format output for other programs; molden(wfn, 'mycalc.molden'). # access array in another format; np.array(wfn.hessian()). Loops¶; Python provides many control structures, any of which can be used within PSI4; input files",MatchSource.WIKI,psi4manual/1.2.1/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html
https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:11776,Energy Efficiency,energy,energy,11776,"ables(). Note that PSI variables; are cleared at the start of each energy(), etc. in an input; file by clean_variables().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the; last will include SCF TOTAL ENERGY but not; FCI TOTAL ENERGY.; The entire dictionary of PSI variables can be obtained through; get_variables(). Return Values¶; Most of the usual user computation functions (i.e.,; energy(), optimize(), and; frequency()) return simply the current total energy.; Consult the descriptions of other functions in Psithon Functions: Invoking a Calculation for; what quantities they return and for what data structures they make; available for post-processing. Many users need only deal with the simple return; form for the computation functions.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11# E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = energy(...); E = optimize(...); E = frequency(...); G = gradient(...) # used by optimize(); H = hessian(...) # used by frequency(). For more elaborate post-processing of computations, adding; return_wfn=True keyword argument additionally returns; Wavefunction.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16# power user returns; E, wfn = energy(..., return_wfn=True); E, wfn = optimize(..., return_wfn=True); E, wfn = frequency(..., return_wfn=True); G, wfn = gradient(..., return_wfn=True) # used by optimize(); H, wfn = hessian(..., return_wfn=True) # used by frequency(). # print gradient array and its rms; wfn.gradient.print_out(); print wfn.gradient().rms(). # format output for other programs; molden(wfn, 'mycalc.molden'). # access array in another format; np.array(wfn.hessian()). Loops¶; Python provides many control structures, any of which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; 1; 2; 3; 4basis_s",MatchSource.WIKI,psi4manual/1.2.1/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html
https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:12093,Energy Efficiency,power,power,12093,"e entire dictionary of PSI variables can be obtained through; get_variables(). Return Values¶; Most of the usual user computation functions (i.e.,; energy(), optimize(), and; frequency()) return simply the current total energy.; Consult the descriptions of other functions in Psithon Functions: Invoking a Calculation for; what quantities they return and for what data structures they make; available for post-processing. Many users need only deal with the simple return; form for the computation functions.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11# E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = energy(...); E = optimize(...); E = frequency(...); G = gradient(...) # used by optimize(); H = hessian(...) # used by frequency(). For more elaborate post-processing of computations, adding; return_wfn=True keyword argument additionally returns; Wavefunction.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16# power user returns; E, wfn = energy(..., return_wfn=True); E, wfn = optimize(..., return_wfn=True); E, wfn = frequency(..., return_wfn=True); G, wfn = gradient(..., return_wfn=True) # used by optimize(); H, wfn = hessian(..., return_wfn=True) # used by frequency(). # print gradient array and its rms; wfn.gradient.print_out(); print wfn.gradient().rms(). # format output for other programs; molden(wfn, 'mycalc.molden'). # access array in another format; np.array(wfn.hessian()). Loops¶; Python provides many control structures, any of which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; 1; 2; 3; 4basis_sets = [""cc-pVDZ"", ""cc-pVTZ"", ""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_sets is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to t",MatchSource.WIKI,psi4manual/1.2.1/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html
https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:12122,Energy Efficiency,energy,energy,12122,"e entire dictionary of PSI variables can be obtained through; get_variables(). Return Values¶; Most of the usual user computation functions (i.e.,; energy(), optimize(), and; frequency()) return simply the current total energy.; Consult the descriptions of other functions in Psithon Functions: Invoking a Calculation for; what quantities they return and for what data structures they make; available for post-processing. Many users need only deal with the simple return; form for the computation functions.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11# E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = energy(...); E = optimize(...); E = frequency(...); G = gradient(...) # used by optimize(); H = hessian(...) # used by frequency(). For more elaborate post-processing of computations, adding; return_wfn=True keyword argument additionally returns; Wavefunction.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16# power user returns; E, wfn = energy(..., return_wfn=True); E, wfn = optimize(..., return_wfn=True); E, wfn = frequency(..., return_wfn=True); G, wfn = gradient(..., return_wfn=True) # used by optimize(); H, wfn = hessian(..., return_wfn=True) # used by frequency(). # print gradient array and its rms; wfn.gradient.print_out(); print wfn.gradient().rms(). # format output for other programs; molden(wfn, 'mycalc.molden'). # access array in another format; np.array(wfn.hessian()). Loops¶; Python provides many control structures, any of which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; 1; 2; 3; 4basis_sets = [""cc-pVDZ"", ""cc-pVTZ"", ""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_sets is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to t",MatchSource.WIKI,psi4manual/1.2.1/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html
https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:12864,Energy Efficiency,energy,energy,12864," energy(...); E = optimize(...); E = frequency(...); G = gradient(...) # used by optimize(); H = hessian(...) # used by frequency(). For more elaborate post-processing of computations, adding; return_wfn=True keyword argument additionally returns; Wavefunction.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16# power user returns; E, wfn = energy(..., return_wfn=True); E, wfn = optimize(..., return_wfn=True); E, wfn = frequency(..., return_wfn=True); G, wfn = gradient(..., return_wfn=True) # used by optimize(); H, wfn = hessian(..., return_wfn=True) # used by frequency(). # print gradient array and its rms; wfn.gradient.print_out(); print wfn.gradient().rms(). # format output for other programs; molden(wfn, 'mycalc.molden'). # access array in another format; np.array(wfn.hessian()). Loops¶; Python provides many control structures, any of which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; 1; 2; 3; 4basis_sets = [""cc-pVDZ"", ""cc-pVTZ"", ""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_sets is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign.; The geometry specification supports delayed initialization of variable,; which permits potential energy scans. As an example, we can scan both the; angle and bond length in water:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16molecule h2o{; O; H 1 R; H 1 R 2 A; }. Rvals = [0.9, 1.0, 1.1]; Avals = range(102, 106, 2). set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). The declarations of Rvals and Avals are both completely standard Python syntax.; Having named our molecule h2o we can then set the values of R and A within",MatchSource.WIKI,psi4manual/1.2.1/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html
https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:13276,Energy Efficiency,energy,energy,13276,"; G, wfn = gradient(..., return_wfn=True) # used by optimize(); H, wfn = hessian(..., return_wfn=True) # used by frequency(). # print gradient array and its rms; wfn.gradient.print_out(); print wfn.gradient().rms(). # format output for other programs; molden(wfn, 'mycalc.molden'). # access array in another format; np.array(wfn.hessian()). Loops¶; Python provides many control structures, any of which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; 1; 2; 3; 4basis_sets = [""cc-pVDZ"", ""cc-pVTZ"", ""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_sets is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign.; The geometry specification supports delayed initialization of variable,; which permits potential energy scans. As an example, we can scan both the; angle and bond length in water:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16molecule h2o{; O; H 1 R; H 1 R 2 A; }. Rvals = [0.9, 1.0, 1.1]; Avals = range(102, 106, 2). set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). The declarations of Rvals and Avals are both completely standard Python syntax.; Having named our molecule h2o we can then set the values of R and A within; the loops. Note that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the set keyword.; Cartesian geometries, because of details of the geometry update process,; need to be specified within the loop(s) along with their basis set when; geometry scans are performed. See scf4 for analogous Z-matrix; and Cartiesian scans. Tables of Results¶; The results of computations c",MatchSource.WIKI,psi4manual/1.2.1/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html
https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:13606,Energy Efficiency,energy,energy,13606,"l structures, any of which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; 1; 2; 3; 4basis_sets = [""cc-pVDZ"", ""cc-pVTZ"", ""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_sets is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign.; The geometry specification supports delayed initialization of variable,; which permits potential energy scans. As an example, we can scan both the; angle and bond length in water:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16molecule h2o{; O; H 1 R; H 1 R 2 A; }. Rvals = [0.9, 1.0, 1.1]; Avals = range(102, 106, 2). set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). The declarations of Rvals and Avals are both completely standard Python syntax.; Having named our molecule h2o we can then set the values of R and A within; the loops. Note that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the set keyword.; Cartesian geometries, because of details of the geometry update process,; need to be specified within the loop(s) along with their basis set when; geometry scans are performed. See scf4 for analogous Z-matrix; and Cartiesian scans. Tables of Results¶; The results of computations can be compactly tabulated with the Table() Psithon; function. For example, in the following potential energy surface scan for water; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27molecule h2o {; O; H 1 R; H 1 R 2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(100,102,2). table=Table(rows=[""R"",""A""], cols=[""E(SCF)"",""E(SCS)"",""E(DFMP2)""",MatchSource.WIKI,psi4manual/1.2.1/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html
https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:14335,Energy Efficiency,energy,energy,14335," 13; 14; 15; 16molecule h2o{; O; H 1 R; H 1 R 2 A; }. Rvals = [0.9, 1.0, 1.1]; Avals = range(102, 106, 2). set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). The declarations of Rvals and Avals are both completely standard Python syntax.; Having named our molecule h2o we can then set the values of R and A within; the loops. Note that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the set keyword.; Cartesian geometries, because of details of the geometry update process,; need to be specified within the loop(s) along with their basis set when; geometry scans are performed. See scf4 for analogous Z-matrix; and Cartiesian scans. Tables of Results¶; The results of computations can be compactly tabulated with the Table() Psithon; function. For example, in the following potential energy surface scan for water; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27molecule h2o {; O; H 1 R; H 1 R 2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(100,102,2). table=Table(rows=[""R"",""A""], cols=[""E(SCF)"",""E(SCS)"",""E(DFMP2)""]). set basis cc-pvdz. for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('mp2'); escf = get_variable('SCF TOTAL ENERGY'); edfmp2 = get_variable('MP2 TOTAL ENERGY'); escsmp2 = get_variable('SCS-MP2 TOTAL ENERGY'); table[R][A] = [escf, escsmp2, edfmp2]. print table; relative=table.copy(); relative.absolute_to_relative(); print relative. we first define a table (on line 10) with two row indices and three column; indices. As the potential energy scan is performed, the results are stored; (line 22) and the final table is printed to the output file (line 24). The; table is converted from absolute energies to relative energies (in kcal mol-1); on line 26, before being printed again. The relative energies are reported with; respect to the lowest value in each column. More ",MatchSource.WIKI,psi4manual/1.2.1/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html
https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:14689,Energy Efficiency,energy,energy,14689,"the loops. Note that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the set keyword.; Cartesian geometries, because of details of the geometry update process,; need to be specified within the loop(s) along with their basis set when; geometry scans are performed. See scf4 for analogous Z-matrix; and Cartiesian scans. Tables of Results¶; The results of computations can be compactly tabulated with the Table() Psithon; function. For example, in the following potential energy surface scan for water; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27molecule h2o {; O; H 1 R; H 1 R 2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(100,102,2). table=Table(rows=[""R"",""A""], cols=[""E(SCF)"",""E(SCS)"",""E(DFMP2)""]). set basis cc-pvdz. for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('mp2'); escf = get_variable('SCF TOTAL ENERGY'); edfmp2 = get_variable('MP2 TOTAL ENERGY'); escsmp2 = get_variable('SCS-MP2 TOTAL ENERGY'); table[R][A] = [escf, escsmp2, edfmp2]. print table; relative=table.copy(); relative.absolute_to_relative(); print relative. we first define a table (on line 10) with two row indices and three column; indices. As the potential energy scan is performed, the results are stored; (line 22) and the final table is printed to the output file (line 24). The; table is converted from absolute energies to relative energies (in kcal mol-1); on line 26, before being printed again. The relative energies are reported with; respect to the lowest value in each column. More examples of how to control the; formatting of the tables can be found in the sample input files provided; see; Appendix Test Suite and Sample Inputs for a complete listing. Python Wrappers¶; The Python foundations of the PSI4 driver and Psithon syntax permit; many commonly performed post-processing procedures to be integrated into; the PSI4 suite.; As seen in the neon dimer exa",MatchSource.WIKI,psi4manual/1.2.1/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html
https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:15062,Energy Efficiency,energy,energy,15062," are performed. See scf4 for analogous Z-matrix; and Cartiesian scans. Tables of Results¶; The results of computations can be compactly tabulated with the Table() Psithon; function. For example, in the following potential energy surface scan for water; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27molecule h2o {; O; H 1 R; H 1 R 2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(100,102,2). table=Table(rows=[""R"",""A""], cols=[""E(SCF)"",""E(SCS)"",""E(DFMP2)""]). set basis cc-pvdz. for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('mp2'); escf = get_variable('SCF TOTAL ENERGY'); edfmp2 = get_variable('MP2 TOTAL ENERGY'); escsmp2 = get_variable('SCS-MP2 TOTAL ENERGY'); table[R][A] = [escf, escsmp2, edfmp2]. print table; relative=table.copy(); relative.absolute_to_relative(); print relative. we first define a table (on line 10) with two row indices and three column; indices. As the potential energy scan is performed, the results are stored; (line 22) and the final table is printed to the output file (line 24). The; table is converted from absolute energies to relative energies (in kcal mol-1); on line 26, before being printed again. The relative energies are reported with; respect to the lowest value in each column. More examples of how to control the; formatting of the tables can be found in the sample input files provided; see; Appendix Test Suite and Sample Inputs for a complete listing. Python Wrappers¶; The Python foundations of the PSI4 driver and Psithon syntax permit; many commonly performed post-processing procedures to be integrated into; the PSI4 suite.; As seen in the neon dimer example from the tutorial section,; the nbody_gufunc() wrapper provides automatic computation of; counterpoise-corrected interaction energies between two molecules. For; example,; 1energy('mp2', bsse_type='cp'). will compute the counterpoise-corrected density-fitted MP2 interaction energy; between two molecules.; PSI4 also provides the ",MatchSource.WIKI,psi4manual/1.2.1/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html
https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:16058,Energy Efficiency,energy,energy,16058,"ndices. As the potential energy scan is performed, the results are stored; (line 22) and the final table is printed to the output file (line 24). The; table is converted from absolute energies to relative energies (in kcal mol-1); on line 26, before being printed again. The relative energies are reported with; respect to the lowest value in each column. More examples of how to control the; formatting of the tables can be found in the sample input files provided; see; Appendix Test Suite and Sample Inputs for a complete listing. Python Wrappers¶; The Python foundations of the PSI4 driver and Psithon syntax permit; many commonly performed post-processing procedures to be integrated into; the PSI4 suite.; As seen in the neon dimer example from the tutorial section,; the nbody_gufunc() wrapper provides automatic computation of; counterpoise-corrected interaction energies between two molecules. For; example,; 1energy('mp2', bsse_type='cp'). will compute the counterpoise-corrected density-fitted MP2 interaction energy; between two molecules.; PSI4 also provides the cbs() wrapper,; which automatically computes a complete-basis-set extrapolation (and; automatically sets up the computations with different basis sets required to; do the extrapolation). For example,:; 1; 2; 3; 4; 5# all equivalent. cbs('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). energy('mp2/cc-pv[dt]z'). will compute a 2-point Helgaker extrapolation of the correlation energy; using the cc-pVDZ and cc-pVTZ basis sets (with method MP2) and add this; extrapolated correlation energy to the Hartree–Fock energy in the; largest basis (cc-pVTZ). cbs() can; either be called directly, as in the first example, or the convenience; syntax of the equivalent second example can be used.; Another very useful and powerful feature of PSI4 is the ability; to compute results on entire databases of molecules at a time,; as provided by the database() wrapper. For example,:; 1database('mp2', 'S22', cp=1, benchm",MatchSource.WIKI,psi4manual/1.2.1/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html
https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:16417,Energy Efficiency,energy,energy,16417," formatting of the tables can be found in the sample input files provided; see; Appendix Test Suite and Sample Inputs for a complete listing. Python Wrappers¶; The Python foundations of the PSI4 driver and Psithon syntax permit; many commonly performed post-processing procedures to be integrated into; the PSI4 suite.; As seen in the neon dimer example from the tutorial section,; the nbody_gufunc() wrapper provides automatic computation of; counterpoise-corrected interaction energies between two molecules. For; example,; 1energy('mp2', bsse_type='cp'). will compute the counterpoise-corrected density-fitted MP2 interaction energy; between two molecules.; PSI4 also provides the cbs() wrapper,; which automatically computes a complete-basis-set extrapolation (and; automatically sets up the computations with different basis sets required to; do the extrapolation). For example,:; 1; 2; 3; 4; 5# all equivalent. cbs('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). energy('mp2/cc-pv[dt]z'). will compute a 2-point Helgaker extrapolation of the correlation energy; using the cc-pVDZ and cc-pVTZ basis sets (with method MP2) and add this; extrapolated correlation energy to the Hartree–Fock energy in the; largest basis (cc-pVTZ). cbs() can; either be called directly, as in the first example, or the convenience; syntax of the equivalent second example can be used.; Another very useful and powerful feature of PSI4 is the ability; to compute results on entire databases of molecules at a time,; as provided by the database() wrapper. For example,:; 1database('mp2', 'S22', cp=1, benchmark='S22B'). will perform DF-MP2 counterpoise-corrected interaction energies; (cp=1) on all members of Hobza’s S22 database set of van der Waals; dimers, and then compare the results against the S22B benchmark energies.; Built-in databases include S22, A24, HTBH, HBC6, HSG, S22by5, S66, JSCH,; NCB31, S66by8, and NBC10, among others.; These wrapper functions are discussed separately in; Psi",MatchSource.WIKI,psi4manual/1.2.1/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html
https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:16508,Energy Efficiency,energy,energy,16508," listing. Python Wrappers¶; The Python foundations of the PSI4 driver and Psithon syntax permit; many commonly performed post-processing procedures to be integrated into; the PSI4 suite.; As seen in the neon dimer example from the tutorial section,; the nbody_gufunc() wrapper provides automatic computation of; counterpoise-corrected interaction energies between two molecules. For; example,; 1energy('mp2', bsse_type='cp'). will compute the counterpoise-corrected density-fitted MP2 interaction energy; between two molecules.; PSI4 also provides the cbs() wrapper,; which automatically computes a complete-basis-set extrapolation (and; automatically sets up the computations with different basis sets required to; do the extrapolation). For example,:; 1; 2; 3; 4; 5# all equivalent. cbs('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). energy('mp2/cc-pv[dt]z'). will compute a 2-point Helgaker extrapolation of the correlation energy; using the cc-pVDZ and cc-pVTZ basis sets (with method MP2) and add this; extrapolated correlation energy to the Hartree–Fock energy in the; largest basis (cc-pVTZ). cbs() can; either be called directly, as in the first example, or the convenience; syntax of the equivalent second example can be used.; Another very useful and powerful feature of PSI4 is the ability; to compute results on entire databases of molecules at a time,; as provided by the database() wrapper. For example,:; 1database('mp2', 'S22', cp=1, benchmark='S22B'). will perform DF-MP2 counterpoise-corrected interaction energies; (cp=1) on all members of Hobza’s S22 database set of van der Waals; dimers, and then compare the results against the S22B benchmark energies.; Built-in databases include S22, A24, HTBH, HBC6, HSG, S22by5, S66, JSCH,; NCB31, S66by8, and NBC10, among others.; These wrapper functions are discussed separately in; Psithon Functions: Invoking a Calculation. Note that the options documented for Python; functions are placed as arguments in the comman",MatchSource.WIKI,psi4manual/1.2.1/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html
https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:16614,Energy Efficiency,energy,energy,16614," listing. Python Wrappers¶; The Python foundations of the PSI4 driver and Psithon syntax permit; many commonly performed post-processing procedures to be integrated into; the PSI4 suite.; As seen in the neon dimer example from the tutorial section,; the nbody_gufunc() wrapper provides automatic computation of; counterpoise-corrected interaction energies between two molecules. For; example,; 1energy('mp2', bsse_type='cp'). will compute the counterpoise-corrected density-fitted MP2 interaction energy; between two molecules.; PSI4 also provides the cbs() wrapper,; which automatically computes a complete-basis-set extrapolation (and; automatically sets up the computations with different basis sets required to; do the extrapolation). For example,:; 1; 2; 3; 4; 5# all equivalent. cbs('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). energy('mp2/cc-pv[dt]z'). will compute a 2-point Helgaker extrapolation of the correlation energy; using the cc-pVDZ and cc-pVTZ basis sets (with method MP2) and add this; extrapolated correlation energy to the Hartree–Fock energy in the; largest basis (cc-pVTZ). cbs() can; either be called directly, as in the first example, or the convenience; syntax of the equivalent second example can be used.; Another very useful and powerful feature of PSI4 is the ability; to compute results on entire databases of molecules at a time,; as provided by the database() wrapper. For example,:; 1database('mp2', 'S22', cp=1, benchmark='S22B'). will perform DF-MP2 counterpoise-corrected interaction energies; (cp=1) on all members of Hobza’s S22 database set of van der Waals; dimers, and then compare the results against the S22B benchmark energies.; Built-in databases include S22, A24, HTBH, HBC6, HSG, S22by5, S66, JSCH,; NCB31, S66by8, and NBC10, among others.; These wrapper functions are discussed separately in; Psithon Functions: Invoking a Calculation. Note that the options documented for Python; functions are placed as arguments in the comman",MatchSource.WIKI,psi4manual/1.2.1/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html
https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:16641,Energy Efficiency,energy,energy,16641," listing. Python Wrappers¶; The Python foundations of the PSI4 driver and Psithon syntax permit; many commonly performed post-processing procedures to be integrated into; the PSI4 suite.; As seen in the neon dimer example from the tutorial section,; the nbody_gufunc() wrapper provides automatic computation of; counterpoise-corrected interaction energies between two molecules. For; example,; 1energy('mp2', bsse_type='cp'). will compute the counterpoise-corrected density-fitted MP2 interaction energy; between two molecules.; PSI4 also provides the cbs() wrapper,; which automatically computes a complete-basis-set extrapolation (and; automatically sets up the computations with different basis sets required to; do the extrapolation). For example,:; 1; 2; 3; 4; 5# all equivalent. cbs('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). energy('mp2/cc-pv[dt]z'). will compute a 2-point Helgaker extrapolation of the correlation energy; using the cc-pVDZ and cc-pVTZ basis sets (with method MP2) and add this; extrapolated correlation energy to the Hartree–Fock energy in the; largest basis (cc-pVTZ). cbs() can; either be called directly, as in the first example, or the convenience; syntax of the equivalent second example can be used.; Another very useful and powerful feature of PSI4 is the ability; to compute results on entire databases of molecules at a time,; as provided by the database() wrapper. For example,:; 1database('mp2', 'S22', cp=1, benchmark='S22B'). will perform DF-MP2 counterpoise-corrected interaction energies; (cp=1) on all members of Hobza’s S22 database set of van der Waals; dimers, and then compare the results against the S22B benchmark energies.; Built-in databases include S22, A24, HTBH, HBC6, HSG, S22by5, S66, JSCH,; NCB31, S66by8, and NBC10, among others.; These wrapper functions are discussed separately in; Psithon Functions: Invoking a Calculation. Note that the options documented for Python; functions are placed as arguments in the comman",MatchSource.WIKI,psi4manual/1.2.1/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html
https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:16842,Energy Efficiency,power,powerful,16842,"raction energies between two molecules. For; example,; 1energy('mp2', bsse_type='cp'). will compute the counterpoise-corrected density-fitted MP2 interaction energy; between two molecules.; PSI4 also provides the cbs() wrapper,; which automatically computes a complete-basis-set extrapolation (and; automatically sets up the computations with different basis sets required to; do the extrapolation). For example,:; 1; 2; 3; 4; 5# all equivalent. cbs('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). energy('mp2/cc-pv[dt]z'). will compute a 2-point Helgaker extrapolation of the correlation energy; using the cc-pVDZ and cc-pVTZ basis sets (with method MP2) and add this; extrapolated correlation energy to the Hartree–Fock energy in the; largest basis (cc-pVTZ). cbs() can; either be called directly, as in the first example, or the convenience; syntax of the equivalent second example can be used.; Another very useful and powerful feature of PSI4 is the ability; to compute results on entire databases of molecules at a time,; as provided by the database() wrapper. For example,:; 1database('mp2', 'S22', cp=1, benchmark='S22B'). will perform DF-MP2 counterpoise-corrected interaction energies; (cp=1) on all members of Hobza’s S22 database set of van der Waals; dimers, and then compare the results against the S22B benchmark energies.; Built-in databases include S22, A24, HTBH, HBC6, HSG, S22by5, S66, JSCH,; NCB31, S66by8, and NBC10, among others.; These wrapper functions are discussed separately in; Psithon Functions: Invoking a Calculation. Note that the options documented for Python; functions are placed as arguments in the command that calls the function,; not in the set {...} block or with any other set command. table of contents. Psithon: Structuring an Input File; Physical Constants; Memory Specification; Molecule and Geometry Specification; Job Control Keywords; Basis Sets; PSI Variables; Return Values; Loops; Tables of Results; Python Wrappers. «; hide menu.",MatchSource.WIKI,psi4manual/1.2.1/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html
https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:6921,Integrability,wrap,wraps,6921,"atabase; Symmetry; Non-Covalently Bonded Molecule Fragments; Advanced Python. To add EFP fragments to a molecule, see Molecule Specification. Job Control Keywords¶; PSI4 comprises a number of C++ modules that each perform; specific tasks and are callable directly from the Python front end. Each module; recognizes specific keywords in the input file which control its function.; These keywords are detailed in Appendix Keywords by Module.; The keywords can be made global, or scoped to apply to; certain specific modules. The following examples demonstrate some of the ways; that global keywords can be specified:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21# all equivalent. set globals basis cc-pVDZ. set basis cc-pVDZ. set globals basis = cc-pVDZ. set basis = cc-pVDZ. set globals{; basis cc-pVDZ; }. set {; basis cc-pVDZ; }. set {; basis = cc-pVDZ; }. Note the lack of quotes around cc-pVDZ, even though it is a string. The; Psithon preprocessor automatically wraps any string values in set commands in; strings. The last three examples provide a more convenient way for specifying; multiple keywords:; 1; 2; 3; 4; 5set {; basis = cc-pVDZ; print = 1; reference = rhf; }. For arguments that require an array input, standard Python list syntax should; be used, viz.:; 1; 2; 3set {; docc = [3, 0, 1, 1]; }. List/matrix inputs may span multiple lines, as long as the opening [ is; on the same line as the name of the keyword.; Any of the above keyword specifications can be scoped to individual modules,; by adding the name of the module after the set keyword. Omitting the module; name, or using the name global or globals will result in the keyword being; applied to all modules. For example, in the following input; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13molecule{; o; h 1 roh; h 1 roh 2 ahoh. roh = 0.957; ahoh = 104.5; }. set basis cc-pVDZ; set ccenergy print 3; set scf print 1; energy('ccsd'). the basis set is set to cc-pVDZ throughout, the SCF code will have ",MatchSource.WIKI,psi4manual/1.2.1/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html
https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:13035,Integrability,wrap,wraps,13035," 15; 16# power user returns; E, wfn = energy(..., return_wfn=True); E, wfn = optimize(..., return_wfn=True); E, wfn = frequency(..., return_wfn=True); G, wfn = gradient(..., return_wfn=True) # used by optimize(); H, wfn = hessian(..., return_wfn=True) # used by frequency(). # print gradient array and its rms; wfn.gradient.print_out(); print wfn.gradient().rms(). # format output for other programs; molden(wfn, 'mycalc.molden'). # access array in another format; np.array(wfn.hessian()). Loops¶; Python provides many control structures, any of which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; 1; 2; 3; 4basis_sets = [""cc-pVDZ"", ""cc-pVTZ"", ""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_sets is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign.; The geometry specification supports delayed initialization of variable,; which permits potential energy scans. As an example, we can scan both the; angle and bond length in water:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16molecule h2o{; O; H 1 R; H 1 R 2 A; }. Rvals = [0.9, 1.0, 1.1]; Avals = range(102, 106, 2). set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). The declarations of Rvals and Avals are both completely standard Python syntax.; Having named our molecule h2o we can then set the values of R and A within; the loops. Note that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the set keyword.; Cartesian geometries, because of details of the geometry update process,; need to be specified within the loop(s) along with their b",MatchSource.WIKI,psi4manual/1.2.1/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html
https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:15715,Integrability,integrat,integrated,15715,"R; for A in Avals:; h2o.A = A; energy('mp2'); escf = get_variable('SCF TOTAL ENERGY'); edfmp2 = get_variable('MP2 TOTAL ENERGY'); escsmp2 = get_variable('SCS-MP2 TOTAL ENERGY'); table[R][A] = [escf, escsmp2, edfmp2]. print table; relative=table.copy(); relative.absolute_to_relative(); print relative. we first define a table (on line 10) with two row indices and three column; indices. As the potential energy scan is performed, the results are stored; (line 22) and the final table is printed to the output file (line 24). The; table is converted from absolute energies to relative energies (in kcal mol-1); on line 26, before being printed again. The relative energies are reported with; respect to the lowest value in each column. More examples of how to control the; formatting of the tables can be found in the sample input files provided; see; Appendix Test Suite and Sample Inputs for a complete listing. Python Wrappers¶; The Python foundations of the PSI4 driver and Psithon syntax permit; many commonly performed post-processing procedures to be integrated into; the PSI4 suite.; As seen in the neon dimer example from the tutorial section,; the nbody_gufunc() wrapper provides automatic computation of; counterpoise-corrected interaction energies between two molecules. For; example,; 1energy('mp2', bsse_type='cp'). will compute the counterpoise-corrected density-fitted MP2 interaction energy; between two molecules.; PSI4 also provides the cbs() wrapper,; which automatically computes a complete-basis-set extrapolation (and; automatically sets up the computations with different basis sets required to; do the extrapolation). For example,:; 1; 2; 3; 4; 5# all equivalent. cbs('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). energy('mp2/cc-pv[dt]z'). will compute a 2-point Helgaker extrapolation of the correlation energy; using the cc-pVDZ and cc-pVTZ basis sets (with method MP2) and add this; extrapolated correlation energy to the Hartree–Fock energy in the; lar",MatchSource.WIKI,psi4manual/1.2.1/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html
https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:15830,Integrability,wrap,wrapper,15830,"][A] = [escf, escsmp2, edfmp2]. print table; relative=table.copy(); relative.absolute_to_relative(); print relative. we first define a table (on line 10) with two row indices and three column; indices. As the potential energy scan is performed, the results are stored; (line 22) and the final table is printed to the output file (line 24). The; table is converted from absolute energies to relative energies (in kcal mol-1); on line 26, before being printed again. The relative energies are reported with; respect to the lowest value in each column. More examples of how to control the; formatting of the tables can be found in the sample input files provided; see; Appendix Test Suite and Sample Inputs for a complete listing. Python Wrappers¶; The Python foundations of the PSI4 driver and Psithon syntax permit; many commonly performed post-processing procedures to be integrated into; the PSI4 suite.; As seen in the neon dimer example from the tutorial section,; the nbody_gufunc() wrapper provides automatic computation of; counterpoise-corrected interaction energies between two molecules. For; example,; 1energy('mp2', bsse_type='cp'). will compute the counterpoise-corrected density-fitted MP2 interaction energy; between two molecules.; PSI4 also provides the cbs() wrapper,; which automatically computes a complete-basis-set extrapolation (and; automatically sets up the computations with different basis sets required to; do the extrapolation). For example,:; 1; 2; 3; 4; 5# all equivalent. cbs('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). energy('mp2/cc-pv[dt]z'). will compute a 2-point Helgaker extrapolation of the correlation energy; using the cc-pVDZ and cc-pVTZ basis sets (with method MP2) and add this; extrapolated correlation energy to the Hartree–Fock energy in the; largest basis (cc-pVTZ). cbs() can; either be called directly, as in the first example, or the convenience; syntax of the equivalent second example can be used.; Another very useful and p",MatchSource.WIKI,psi4manual/1.2.1/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html
https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:16119,Integrability,wrap,wrapper,16119," is converted from absolute energies to relative energies (in kcal mol-1); on line 26, before being printed again. The relative energies are reported with; respect to the lowest value in each column. More examples of how to control the; formatting of the tables can be found in the sample input files provided; see; Appendix Test Suite and Sample Inputs for a complete listing. Python Wrappers¶; The Python foundations of the PSI4 driver and Psithon syntax permit; many commonly performed post-processing procedures to be integrated into; the PSI4 suite.; As seen in the neon dimer example from the tutorial section,; the nbody_gufunc() wrapper provides automatic computation of; counterpoise-corrected interaction energies between two molecules. For; example,; 1energy('mp2', bsse_type='cp'). will compute the counterpoise-corrected density-fitted MP2 interaction energy; between two molecules.; PSI4 also provides the cbs() wrapper,; which automatically computes a complete-basis-set extrapolation (and; automatically sets up the computations with different basis sets required to; do the extrapolation). For example,:; 1; 2; 3; 4; 5# all equivalent. cbs('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). energy('mp2/cc-pv[dt]z'). will compute a 2-point Helgaker extrapolation of the correlation energy; using the cc-pVDZ and cc-pVTZ basis sets (with method MP2) and add this; extrapolated correlation energy to the Hartree–Fock energy in the; largest basis (cc-pVTZ). cbs() can; either be called directly, as in the first example, or the convenience; syntax of the equivalent second example can be used.; Another very useful and powerful feature of PSI4 is the ability; to compute results on entire databases of molecules at a time,; as provided by the database() wrapper. For example,:; 1database('mp2', 'S22', cp=1, benchmark='S22B'). will perform DF-MP2 counterpoise-corrected interaction energies; (cp=1) on all members of Hobza’s S22 database set of van der Waals; dimers, and",MatchSource.WIKI,psi4manual/1.2.1/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html
https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:16977,Integrability,wrap,wrapper,16977,"raction energies between two molecules. For; example,; 1energy('mp2', bsse_type='cp'). will compute the counterpoise-corrected density-fitted MP2 interaction energy; between two molecules.; PSI4 also provides the cbs() wrapper,; which automatically computes a complete-basis-set extrapolation (and; automatically sets up the computations with different basis sets required to; do the extrapolation). For example,:; 1; 2; 3; 4; 5# all equivalent. cbs('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). energy('mp2/cc-pv[dt]z'). will compute a 2-point Helgaker extrapolation of the correlation energy; using the cc-pVDZ and cc-pVTZ basis sets (with method MP2) and add this; extrapolated correlation energy to the Hartree–Fock energy in the; largest basis (cc-pVTZ). cbs() can; either be called directly, as in the first example, or the convenience; syntax of the equivalent second example can be used.; Another very useful and powerful feature of PSI4 is the ability; to compute results on entire databases of molecules at a time,; as provided by the database() wrapper. For example,:; 1database('mp2', 'S22', cp=1, benchmark='S22B'). will perform DF-MP2 counterpoise-corrected interaction energies; (cp=1) on all members of Hobza’s S22 database set of van der Waals; dimers, and then compare the results against the S22B benchmark energies.; Built-in databases include S22, A24, HTBH, HBC6, HSG, S22by5, S66, JSCH,; NCB31, S66by8, and NBC10, among others.; These wrapper functions are discussed separately in; Psithon Functions: Invoking a Calculation. Note that the options documented for Python; functions are placed as arguments in the command that calls the function,; not in the set {...} block or with any other set command. table of contents. Psithon: Structuring an Input File; Physical Constants; Memory Specification; Molecule and Geometry Specification; Job Control Keywords; Basis Sets; PSI Variables; Return Values; Loops; Tables of Results; Python Wrappers. «; hide menu.",MatchSource.WIKI,psi4manual/1.2.1/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html
https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:17379,Integrability,wrap,wrapper,17379,"he cbs() wrapper,; which automatically computes a complete-basis-set extrapolation (and; automatically sets up the computations with different basis sets required to; do the extrapolation). For example,:; 1; 2; 3; 4; 5# all equivalent. cbs('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). energy('mp2/cc-pv[dt]z'). will compute a 2-point Helgaker extrapolation of the correlation energy; using the cc-pVDZ and cc-pVTZ basis sets (with method MP2) and add this; extrapolated correlation energy to the Hartree–Fock energy in the; largest basis (cc-pVTZ). cbs() can; either be called directly, as in the first example, or the convenience; syntax of the equivalent second example can be used.; Another very useful and powerful feature of PSI4 is the ability; to compute results on entire databases of molecules at a time,; as provided by the database() wrapper. For example,:; 1database('mp2', 'S22', cp=1, benchmark='S22B'). will perform DF-MP2 counterpoise-corrected interaction energies; (cp=1) on all members of Hobza’s S22 database set of van der Waals; dimers, and then compare the results against the S22B benchmark energies.; Built-in databases include S22, A24, HTBH, HBC6, HSG, S22by5, S66, JSCH,; NCB31, S66by8, and NBC10, among others.; These wrapper functions are discussed separately in; Psithon Functions: Invoking a Calculation. Note that the options documented for Python; functions are placed as arguments in the command that calls the function,; not in the set {...} block or with any other set command. table of contents. Psithon: Structuring an Input File; Physical Constants; Memory Specification; Molecule and Geometry Specification; Job Control Keywords; Basis Sets; PSI Variables; Return Values; Loops; Tables of Results; Python Wrappers. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html
https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:1022,Modifiability,variab,variables,1022,"File. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Psithon: Structuring an Input File¶; To allow arbitrarily complex computations to be performed, PSI4 was built; upon the Python interpreter. However, to make the input syntax simpler, some; pre-processing of the input file is performed before it is interpreted,; resulting in Python syntax that is customized for PSI, termed Psithon. In; this section we will describe the essential features of the Psithon language.; PSI4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; 1UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that the user’s ~/.psi4rc values can; override the builtins (in the input file, not in the C++ code).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files. # Do not modify this file! It is auto-generated by the document_options_and_tests; # script, from psi4topdir/psi4/include/psi4/physconst.h; h = 6.62606896E-34 # The Planck constant (Js) ; c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; kb = 1.380650",MatchSource.WIKI,psi4manual/1.2.1/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html
https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:1281,Modifiability,variab,variable,1281,"some; pre-processing of the input file is performed before it is interpreted,; resulting in Python syntax that is customized for PSI, termed Psithon. In; this section we will describe the essential features of the Psithon language.; PSI4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; 1UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that the user’s ~/.psi4rc values can; override the builtins (in the input file, not in the C++ code).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files. # Do not modify this file! It is auto-generated by the document_options_and_tests; # script, from psi4topdir/psi4/include/psi4/physconst.h; h = 6.62606896E-34 # The Planck constant (Js) ; c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; R = 8.314472 # Universal gas constant (JK$^{-1}$mol$^{-1}$) ; bohr2angstroms = 0.52917720859 # Bohr to Angstroms conversion factor ; bohr2m = 0.52917720859E-10 # Bohr to meters conversion factor ; bohr2cm = 0.5291772",MatchSource.WIKI,psi4manual/1.2.1/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html
https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:1529,Modifiability,variab,variables,1529,"on. In; this section we will describe the essential features of the Psithon language.; PSI4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; 1UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that the user’s ~/.psi4rc values can; override the builtins (in the input file, not in the C++ code).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files. # Do not modify this file! It is auto-generated by the document_options_and_tests; # script, from psi4topdir/psi4/include/psi4/physconst.h; h = 6.62606896E-34 # The Planck constant (Js) ; c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; R = 8.314472 # Universal gas constant (JK$^{-1}$mol$^{-1}$) ; bohr2angstroms = 0.52917720859 # Bohr to Angstroms conversion factor ; bohr2m = 0.52917720859E-10 # Bohr to meters conversion factor ; bohr2cm = 0.52917720859E-8 # Bohr to centimeters conversion factor ; amu2g = 1.660538782E-24 # Atomic mass units to grams conversion factor ; amu2kg = 1.660538782E-",MatchSource.WIKI,psi4manual/1.2.1/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html
https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:3778,Modifiability,variab,variables,3778,"# Calorie to joule conversion factor ; dipmom_au2si = 8.47835281E-30 # Atomic units to SI units (Cm) conversion factor for dipoles ; dipmom_au2debye = 2.54174623 # Atomic units to Debye conversion factor for dipoles ; dipmom_debye2si = 3.335640952E-30 # Debye to SI units (Cm) conversion factor for dipoles ; c_au = 137.035999679 # Speed of light in atomic units ; hartree2ev = 27.21138 # Hartree to eV conversion factor ; hartree2wavenumbers = 219474.6 # Hartree to cm$^{-1}$ conversion factor ; hartree2kcalmol = 627.5095 # Hartree to kcal mol$^{-1}$ conversion factor ; hartree2kJmol = 2625.500 # Hartree to kilojoule mol$^{-1}$ conversion factor ; hartree2MHz = 6.579684E9 # Hartree to MHz conversion factor ; kcalmol2wavenumbers = 349.7551 # kcal mol$^{-1}$ to cm$^{-1}$ conversion factor ; e0 = 8.854187817E-12 # Vacuum permittivity (Fm$^{-1}$) ; na = 6.02214179E23 # Avagadro's number ; me = 9.10938215E-31 # Electron rest mass (in kg) . In Psithon input files, prepend physical constants with psi_ to; prevent clashes with user-defined variables (e.g., psi_h). In; PsiAPI mode, access as, e.g., psi4.constants.h. Memory Specification¶; By default, PSI4 assumes that 500 MiB of memory are available. While this is; enough for many computations, many of the algorithms will perform better if; more is available. To specify memory, the memory keyword should be used. The following; lines are all equivalent methods for specifying that 2 GB of RAM is available; to PSI4:; 1; 2; 3; 4; 5; 6; 7# all equivalent. memory 2 GB. memory 2000 MB. memory 2000000 kB. Please note that memory can be specified both in IEC binary units (1 KiB = 1024 bytes) and SI units (1 kB = 1000 bytes). PSI4 recognizes and obeys both of them correctly. The units are not case sensitive (Kb and KB are equivalent to kB).; By default, PSI4 performs a “sanity check” when parsing Psithon input files, enforcing a minimum memory requirement of 250 MiB. While it is generally not recomennded to do so, expert users can bypass t",MatchSource.WIKI,psi4manual/1.2.1/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html
https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:9964,Modifiability,variab,variable,9964,"ful to separate calculations in a PsiAPI; session.; 1; 2; 3; 4; 5; 6; 7; 8; 9psi4.set_options({; 'scf_type': 'pk',; 'e_convergence': 1.e-5,; 'soscf': True; }). psi4.set_module_options({; 'geom_maxiter': 50; }). Basis Sets¶. Basis Sets; Built-In Basis Sets; Mixing Basis Sets; Decontracted Basis Sets; User-Defined Basis Sets; Inputting effective core potentials (ECPs). PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results; of each computation available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of; H2 and H atom:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19molecule h2 {; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h {; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol * (2*h_energy - h2_energy); print ""De=%f"" % D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module, and PSI Variables by Alpha defines them. These can be; accessed through the get_variable() function. For example, after; performing a density fitted MP2 computation, both the spin component; scaled energy and the unscaled MP2 energy are made available:; 1; 2e_mp2 = get_variable('MP2 TOTAL ENERGY'); e_scs_mp2 = get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; are cleared at the start of each energy(), etc. in an input; file by clean_variables().; So if you",MatchSource.WIKI,psi4manual/1.2.1/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html
https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:10198,Modifiability,variab,variables,10198,"is Sets; Inputting effective core potentials (ECPs). PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results; of each computation available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of; H2 and H atom:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19molecule h2 {; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h {; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol * (2*h_energy - h2_energy); print ""De=%f"" % D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module, and PSI Variables by Alpha defines them. These can be; accessed through the get_variable() function. For example, after; performing a density fitted MP2 computation, both the spin component; scaled energy and the unscaled MP2 energy are made available:; 1; 2e_mp2 = get_variable('MP2 TOTAL ENERGY'); e_scs_mp2 = get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; are cleared at the start of each energy(), etc. in an input; file by clean_variables().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the; last will include SCF TOTAL ENERGY but not; FCI TOTAL ENERGY.; The entire dictionary of PSI variables can be obtained through; get_variables(). Return Values¶; Most of the usual user computation fun",MatchSource.WIKI,psi4manual/1.2.1/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html
https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:10208,Modifiability,variab,variables,10208,"is Sets; Inputting effective core potentials (ECPs). PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results; of each computation available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of; H2 and H atom:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19molecule h2 {; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h {; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol * (2*h_energy - h2_energy); print ""De=%f"" % D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module, and PSI Variables by Alpha defines them. These can be; accessed through the get_variable() function. For example, after; performing a density fitted MP2 computation, both the spin component; scaled energy and the unscaled MP2 energy are made available:; 1; 2e_mp2 = get_variable('MP2 TOTAL ENERGY'); e_scs_mp2 = get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; are cleared at the start of each energy(), etc. in an input; file by clean_variables().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the; last will include SCF TOTAL ENERGY but not; FCI TOTAL ENERGY.; The entire dictionary of PSI variables can be obtained through; get_variables(). Return Values¶; Most of the usual user computation fun",MatchSource.WIKI,psi4manual/1.2.1/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html
https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:10631,Modifiability,variab,variables,10631,"ence rhf; h2_energy = energy('scf'). molecule h {; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol * (2*h_energy - h2_energy); print ""De=%f"" % D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module, and PSI Variables by Alpha defines them. These can be; accessed through the get_variable() function. For example, after; performing a density fitted MP2 computation, both the spin component; scaled energy and the unscaled MP2 energy are made available:; 1; 2e_mp2 = get_variable('MP2 TOTAL ENERGY'); e_scs_mp2 = get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; are cleared at the start of each energy(), etc. in an input; file by clean_variables().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the; last will include SCF TOTAL ENERGY but not; FCI TOTAL ENERGY.; The entire dictionary of PSI variables can be obtained through; get_variables(). Return Values¶; Most of the usual user computation functions (i.e.,; energy(), optimize(), and; frequency()) return simply the current total energy.; Consult the descriptions of other functions in Psithon Functions: Invoking a Calculation for; what quantities they return and for what data structures they make; available for post-processing. Many users need only deal with the simple return; form for the computation functions.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11# E is ",MatchSource.WIKI,psi4manual/1.2.1/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html
https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:10791,Modifiability,variab,variables,10791,"""De=%f"" % D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module, and PSI Variables by Alpha defines them. These can be; accessed through the get_variable() function. For example, after; performing a density fitted MP2 computation, both the spin component; scaled energy and the unscaled MP2 energy are made available:; 1; 2e_mp2 = get_variable('MP2 TOTAL ENERGY'); e_scs_mp2 = get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; are cleared at the start of each energy(), etc. in an input; file by clean_variables().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the; last will include SCF TOTAL ENERGY but not; FCI TOTAL ENERGY.; The entire dictionary of PSI variables can be obtained through; get_variables(). Return Values¶; Most of the usual user computation functions (i.e.,; energy(), optimize(), and; frequency()) return simply the current total energy.; Consult the descriptions of other functions in Psithon Functions: Invoking a Calculation for; what quantities they return and for what data structures they make; available for post-processing. Many users need only deal with the simple return; form for the computation functions.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11# E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = energy(...); E = optimize(...); E = f",MatchSource.WIKI,psi4manual/1.2.1/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html
https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:11110,Modifiability,variab,variables,11110," multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module, and PSI Variables by Alpha defines them. These can be; accessed through the get_variable() function. For example, after; performing a density fitted MP2 computation, both the spin component; scaled energy and the unscaled MP2 energy are made available:; 1; 2e_mp2 = get_variable('MP2 TOTAL ENERGY'); e_scs_mp2 = get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; are cleared at the start of each energy(), etc. in an input; file by clean_variables().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the; last will include SCF TOTAL ENERGY but not; FCI TOTAL ENERGY.; The entire dictionary of PSI variables can be obtained through; get_variables(). Return Values¶; Most of the usual user computation functions (i.e.,; energy(), optimize(), and; frequency()) return simply the current total energy.; Consult the descriptions of other functions in Psithon Functions: Invoking a Calculation for; what quantities they return and for what data structures they make; available for post-processing. Many users need only deal with the simple return; form for the computation functions.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11# E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = energy(...); E = optimize(...); E = frequency(...); G = gradient(...) # used by optimize(); H = hessian(...) # used by frequency(). For more elaborate post-processing of computations, adding; return_wfn=True keyword argument additionally returns; Wavefunction.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16# power user returns; E, wfn ",MatchSource.WIKI,psi4manual/1.2.1/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html
https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:13118,Modifiability,variab,variable,13118," 15; 16# power user returns; E, wfn = energy(..., return_wfn=True); E, wfn = optimize(..., return_wfn=True); E, wfn = frequency(..., return_wfn=True); G, wfn = gradient(..., return_wfn=True) # used by optimize(); H, wfn = hessian(..., return_wfn=True) # used by frequency(). # print gradient array and its rms; wfn.gradient.print_out(); print wfn.gradient().rms(). # format output for other programs; molden(wfn, 'mycalc.molden'). # access array in another format; np.array(wfn.hessian()). Loops¶; Python provides many control structures, any of which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; 1; 2; 3; 4basis_sets = [""cc-pVDZ"", ""cc-pVTZ"", ""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_sets is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign.; The geometry specification supports delayed initialization of variable,; which permits potential energy scans. As an example, we can scan both the; angle and bond length in water:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16molecule h2o{; O; H 1 R; H 1 R 2 A; }. Rvals = [0.9, 1.0, 1.1]; Avals = range(102, 106, 2). set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). The declarations of Rvals and Avals are both completely standard Python syntax.; Having named our molecule h2o we can then set the values of R and A within; the loops. Note that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the set keyword.; Cartesian geometries, because of details of the geometry update process,; need to be specified within the loop(s) along with their b",MatchSource.WIKI,psi4manual/1.2.1/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html
https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:13241,Modifiability,variab,variable,13241,"; G, wfn = gradient(..., return_wfn=True) # used by optimize(); H, wfn = hessian(..., return_wfn=True) # used by frequency(). # print gradient array and its rms; wfn.gradient.print_out(); print wfn.gradient().rms(). # format output for other programs; molden(wfn, 'mycalc.molden'). # access array in another format; np.array(wfn.hessian()). Loops¶; Python provides many control structures, any of which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; 1; 2; 3; 4basis_sets = [""cc-pVDZ"", ""cc-pVTZ"", ""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_sets is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign.; The geometry specification supports delayed initialization of variable,; which permits potential energy scans. As an example, we can scan both the; angle and bond length in water:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16molecule h2o{; O; H 1 R; H 1 R 2 A; }. Rvals = [0.9, 1.0, 1.1]; Avals = range(102, 106, 2). set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). The declarations of Rvals and Avals are both completely standard Python syntax.; Having named our molecule h2o we can then set the values of R and A within; the loops. Note that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the set keyword.; Cartesian geometries, because of details of the geometry update process,; need to be specified within the loop(s) along with their basis set when; geometry scans are performed. See scf4 for analogous Z-matrix; and Cartiesian scans. Tables of Results¶; The results of computations c",MatchSource.WIKI,psi4manual/1.2.1/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html
https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:13852,Modifiability,variab,variable,13852,"y('scf'). The declaration of basis_sets is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign.; The geometry specification supports delayed initialization of variable,; which permits potential energy scans. As an example, we can scan both the; angle and bond length in water:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16molecule h2o{; O; H 1 R; H 1 R 2 A; }. Rvals = [0.9, 1.0, 1.1]; Avals = range(102, 106, 2). set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). The declarations of Rvals and Avals are both completely standard Python syntax.; Having named our molecule h2o we can then set the values of R and A within; the loops. Note that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the set keyword.; Cartesian geometries, because of details of the geometry update process,; need to be specified within the loop(s) along with their basis set when; geometry scans are performed. See scf4 for analogous Z-matrix; and Cartiesian scans. Tables of Results¶; The results of computations can be compactly tabulated with the Table() Psithon; function. For example, in the following potential energy surface scan for water; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27molecule h2o {; O; H 1 R; H 1 R 2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(100,102,2). table=Table(rows=[""R"",""A""], cols=[""E(SCF)"",""E(SCS)"",""E(DFMP2)""]). set basis cc-pvdz. for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('mp2'); escf = get_variable('SCF TOTAL ENERGY'); edfmp2 = get_variable('MP2 TOTAL ENERGY'); escsmp2 = get_variable('SCS-MP2 TOTAL ENERGY'); table[R][A] = [escf, escsmp2, edf",MatchSource.WIKI,psi4manual/1.2.1/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html
https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:13918,Modifiability,variab,variables,13918,"y('scf'). The declaration of basis_sets is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign.; The geometry specification supports delayed initialization of variable,; which permits potential energy scans. As an example, we can scan both the; angle and bond length in water:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16molecule h2o{; O; H 1 R; H 1 R 2 A; }. Rvals = [0.9, 1.0, 1.1]; Avals = range(102, 106, 2). set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). The declarations of Rvals and Avals are both completely standard Python syntax.; Having named our molecule h2o we can then set the values of R and A within; the loops. Note that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the set keyword.; Cartesian geometries, because of details of the geometry update process,; need to be specified within the loop(s) along with their basis set when; geometry scans are performed. See scf4 for analogous Z-matrix; and Cartiesian scans. Tables of Results¶; The results of computations can be compactly tabulated with the Table() Psithon; function. For example, in the following potential energy surface scan for water; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27molecule h2o {; O; H 1 R; H 1 R 2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(100,102,2). table=Table(rows=[""R"",""A""], cols=[""E(SCF)"",""E(SCS)"",""E(DFMP2)""]). set basis cc-pvdz. for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('mp2'); escf = get_variable('SCF TOTAL ENERGY'); edfmp2 = get_variable('MP2 TOTAL ENERGY'); escsmp2 = get_variable('SCS-MP2 TOTAL ENERGY'); table[R][A] = [escf, escsmp2, edf",MatchSource.WIKI,psi4manual/1.2.1/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html
https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:194,Performance,perform,performed,194,"﻿. Psithon: Structuring an Input File. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Psithon: Structuring an Input File¶; To allow arbitrarily complex computations to be performed, PSI4 was built; upon the Python interpreter. However, to make the input syntax simpler, some; pre-processing of the input file is performed before it is interpreted,; resulting in Python syntax that is customized for PSI, termed Psithon. In; this section we will describe the essential features of the Psithon language.; PSI4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; 1UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that the user’s ~/.psi4rc values can; override the builtins (in the input file, not in the C++ code).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files. # Do not modify this file! It is auto-generated by the document_options_and_tests; # script, from psi4topdir/psi4/include/psi4/physconst.h; h = 6.62606896E-34 # The Planck constant (Js) ; c = 2.99792458E8 # Speed of l",MatchSource.WIKI,psi4manual/1.2.1/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html
https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:335,Performance,perform,performed,335,"﻿. Psithon: Structuring an Input File. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Psithon: Structuring an Input File¶; To allow arbitrarily complex computations to be performed, PSI4 was built; upon the Python interpreter. However, to make the input syntax simpler, some; pre-processing of the input file is performed before it is interpreted,; resulting in Python syntax that is customized for PSI, termed Psithon. In; this section we will describe the essential features of the Psithon language.; PSI4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; 1UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that the user’s ~/.psi4rc values can; override the builtins (in the input file, not in the C++ code).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files. # Do not modify this file! It is auto-generated by the document_options_and_tests; # script, from psi4topdir/psi4/include/psi4/physconst.h; h = 6.62606896E-34 # The Planck constant (Js) ; c = 2.99792458E8 # Speed of l",MatchSource.WIKI,psi4manual/1.2.1/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html
https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:946,Performance,perform,performing,946,"﻿. Psithon: Structuring an Input File. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Psithon: Structuring an Input File¶; To allow arbitrarily complex computations to be performed, PSI4 was built; upon the Python interpreter. However, to make the input syntax simpler, some; pre-processing of the input file is performed before it is interpreted,; resulting in Python syntax that is customized for PSI, termed Psithon. In; this section we will describe the essential features of the Psithon language.; PSI4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; 1UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that the user’s ~/.psi4rc values can; override the builtins (in the input file, not in the C++ code).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files. # Do not modify this file! It is auto-generated by the document_options_and_tests; # script, from psi4topdir/psi4/include/psi4/physconst.h; h = 6.62606896E-34 # The Planck constant (Js) ; c = 2.99792458E8 # Speed of l",MatchSource.WIKI,psi4manual/1.2.1/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html
https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:1510,Performance,load,loaded,1510,"on. In; this section we will describe the essential features of the Psithon language.; PSI4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; 1UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that the user’s ~/.psi4rc values can; override the builtins (in the input file, not in the C++ code).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files. # Do not modify this file! It is auto-generated by the document_options_and_tests; # script, from psi4topdir/psi4/include/psi4/physconst.h; h = 6.62606896E-34 # The Planck constant (Js) ; c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; R = 8.314472 # Universal gas constant (JK$^{-1}$mol$^{-1}$) ; bohr2angstroms = 0.52917720859 # Bohr to Angstroms conversion factor ; bohr2m = 0.52917720859E-10 # Bohr to meters conversion factor ; bohr2cm = 0.52917720859E-8 # Bohr to centimeters conversion factor ; amu2g = 1.660538782E-24 # Atomic mass units to grams conversion factor ; amu2kg = 1.660538782E-",MatchSource.WIKI,psi4manual/1.2.1/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html
https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:1560,Performance,load,loaded,1560,"uite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; 1UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that the user’s ~/.psi4rc values can; override the builtins (in the input file, not in the C++ code).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files. # Do not modify this file! It is auto-generated by the document_options_and_tests; # script, from psi4topdir/psi4/include/psi4/physconst.h; h = 6.62606896E-34 # The Planck constant (Js) ; c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; R = 8.314472 # Universal gas constant (JK$^{-1}$mol$^{-1}$) ; bohr2angstroms = 0.52917720859 # Bohr to Angstroms conversion factor ; bohr2m = 0.52917720859E-10 # Bohr to meters conversion factor ; bohr2cm = 0.52917720859E-8 # Bohr to centimeters conversion factor ; amu2g = 1.660538782E-24 # Atomic mass units to grams conversion factor ; amu2kg = 1.660538782E-27 # Atomic mass units to kg conversion factor ; au2amu = 5.485799097E-4 # Atomic units (m$@@e$) to atomic mass units conversion fa",MatchSource.WIKI,psi4manual/1.2.1/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html
https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:4014,Performance,perform,perform,4014,"o SI units (Cm) conversion factor for dipoles ; c_au = 137.035999679 # Speed of light in atomic units ; hartree2ev = 27.21138 # Hartree to eV conversion factor ; hartree2wavenumbers = 219474.6 # Hartree to cm$^{-1}$ conversion factor ; hartree2kcalmol = 627.5095 # Hartree to kcal mol$^{-1}$ conversion factor ; hartree2kJmol = 2625.500 # Hartree to kilojoule mol$^{-1}$ conversion factor ; hartree2MHz = 6.579684E9 # Hartree to MHz conversion factor ; kcalmol2wavenumbers = 349.7551 # kcal mol$^{-1}$ to cm$^{-1}$ conversion factor ; e0 = 8.854187817E-12 # Vacuum permittivity (Fm$^{-1}$) ; na = 6.02214179E23 # Avagadro's number ; me = 9.10938215E-31 # Electron rest mass (in kg) . In Psithon input files, prepend physical constants with psi_ to; prevent clashes with user-defined variables (e.g., psi_h). In; PsiAPI mode, access as, e.g., psi4.constants.h. Memory Specification¶; By default, PSI4 assumes that 500 MiB of memory are available. While this is; enough for many computations, many of the algorithms will perform better if; more is available. To specify memory, the memory keyword should be used. The following; lines are all equivalent methods for specifying that 2 GB of RAM is available; to PSI4:; 1; 2; 3; 4; 5; 6; 7# all equivalent. memory 2 GB. memory 2000 MB. memory 2000000 kB. Please note that memory can be specified both in IEC binary units (1 KiB = 1024 bytes) and SI units (1 kB = 1000 bytes). PSI4 recognizes and obeys both of them correctly. The units are not case sensitive (Kb and KB are equivalent to kB).; By default, PSI4 performs a “sanity check” when parsing Psithon input files, enforcing a minimum memory requirement of 250 MiB. While it is generally not recomennded to do so, expert users can bypass this check by directly setting the number of bytes availble to PSI4:; 1; 2# setting available memory to 2 MB; set_memory_bytes(2000000). Please note that this memory setting only governs the maximal memory usage of the major data structures and actual total memo",MatchSource.WIKI,psi4manual/1.2.1/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html
https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:4551,Performance,perform,performs,4551,"214179E23 # Avagadro's number ; me = 9.10938215E-31 # Electron rest mass (in kg) . In Psithon input files, prepend physical constants with psi_ to; prevent clashes with user-defined variables (e.g., psi_h). In; PsiAPI mode, access as, e.g., psi4.constants.h. Memory Specification¶; By default, PSI4 assumes that 500 MiB of memory are available. While this is; enough for many computations, many of the algorithms will perform better if; more is available. To specify memory, the memory keyword should be used. The following; lines are all equivalent methods for specifying that 2 GB of RAM is available; to PSI4:; 1; 2; 3; 4; 5; 6; 7# all equivalent. memory 2 GB. memory 2000 MB. memory 2000000 kB. Please note that memory can be specified both in IEC binary units (1 KiB = 1024 bytes) and SI units (1 kB = 1000 bytes). PSI4 recognizes and obeys both of them correctly. The units are not case sensitive (Kb and KB are equivalent to kB).; By default, PSI4 performs a “sanity check” when parsing Psithon input files, enforcing a minimum memory requirement of 250 MiB. While it is generally not recomennded to do so, expert users can bypass this check by directly setting the number of bytes availble to PSI4:; 1; 2# setting available memory to 2 MB; set_memory_bytes(2000000). Please note that this memory setting only governs the maximal memory usage of the major data structures and actual total memory usage is slightly higher. This is usually a negligible, except when setting tiny memory allowances.; One convenient way to override the PSI4 default memory is to place a; memory command in the ~/.psi4rc file (Sec. ~/.psi4rc File). For example,; the following makes the default memory 2 GB.; 1set_memory(2000000000). However, unless you’re assured of having only one job running on a node at; a time (and all nodes on the filesystem with ~/.psi4rc have similar memory; capacities), it is advised to set memory in the input file on a; per-calculation basis.; That same command can be used for PsiAPI ",MatchSource.WIKI,psi4manual/1.2.1/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html
https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:6140,Performance,perform,perform,6140,"efault memory is to place a; memory command in the ~/.psi4rc file (Sec. ~/.psi4rc File). For example,; the following makes the default memory 2 GB.; 1set_memory(2000000000). However, unless you’re assured of having only one job running on a node at; a time (and all nodes on the filesystem with ~/.psi4rc have similar memory; capacities), it is advised to set memory in the input file on a; per-calculation basis.; That same command can be used for PsiAPI mode:; 1psi4.set_memory(int(5e8)). Note; For parallel jobs, the memory keyword represents the total memory; available to the job, not the memory per thread. Molecule and Geometry Specification¶. Molecule and Geometry Specification; Coordinates; Molecule Keywords; Multiple Molecules; Ghost Atoms; Isotopic Substitution; PubChem Database; Symmetry; Non-Covalently Bonded Molecule Fragments; Advanced Python. To add EFP fragments to a molecule, see Molecule Specification. Job Control Keywords¶; PSI4 comprises a number of C++ modules that each perform; specific tasks and are callable directly from the Python front end. Each module; recognizes specific keywords in the input file which control its function.; These keywords are detailed in Appendix Keywords by Module.; The keywords can be made global, or scoped to apply to; certain specific modules. The following examples demonstrate some of the ways; that global keywords can be specified:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21# all equivalent. set globals basis cc-pVDZ. set basis cc-pVDZ. set globals basis = cc-pVDZ. set basis = cc-pVDZ. set globals{; basis cc-pVDZ; }. set {; basis cc-pVDZ; }. set {; basis = cc-pVDZ; }. Note the lack of quotes around cc-pVDZ, even though it is a string. The; Psithon preprocessor automatically wraps any string values in set commands in; strings. The last three examples provide a more convenient way for specifying; multiple keywords:; 1; 2; 3; 4; 5set {; basis = cc-pVDZ; print = 1; reference = rhf; }. For argume",MatchSource.WIKI,psi4manual/1.2.1/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html
https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:7976,Performance,perform,performs,7976," commands in; strings. The last three examples provide a more convenient way for specifying; multiple keywords:; 1; 2; 3; 4; 5set {; basis = cc-pVDZ; print = 1; reference = rhf; }. For arguments that require an array input, standard Python list syntax should; be used, viz.:; 1; 2; 3set {; docc = [3, 0, 1, 1]; }. List/matrix inputs may span multiple lines, as long as the opening [ is; on the same line as the name of the keyword.; Any of the above keyword specifications can be scoped to individual modules,; by adding the name of the module after the set keyword. Omitting the module; name, or using the name global or globals will result in the keyword being; applied to all modules. For example, in the following input; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13molecule{; o; h 1 roh; h 1 roh 2 ahoh. roh = 0.957; ahoh = 104.5; }. set basis cc-pVDZ; set ccenergy print 3; set scf print 1; energy('ccsd'). the basis set is set to cc-pVDZ throughout, the SCF code will have a print; level of 1 and the ccenergy code, which performs coupled cluster computations,; will use a print level of 3. In this example a full CCSD computation is; performed by running the SCF code first, then the coupled cluster modules;; the energy() Python helper function ensures that this is performed correctly.; Note that the Python interpreter executes commands in the order they appear in; the input file, so if the last four commands in the above example were to read; 1; 2; 3; 4set basis cc-pVDZ; energy('ccsd'); set ccenergy print 3; set scf print 1. the commands that set the print level would be ineffective, as they would be; processed after the CCSD computation completes.; In PsiAPI mode, one can use commands set_options() and; set_module_options() like below. Note that these values; should be of correct type, strings for strings, floats for floats like; convergences. The function ~psi4.core.clean_options that reinitializes; all options may also be useful to separate calculations in a PsiAPI; session.; 1",MatchSource.WIKI,psi4manual/1.2.1/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html
https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:8089,Performance,perform,performed,8089,"ts that require an array input, standard Python list syntax should; be used, viz.:; 1; 2; 3set {; docc = [3, 0, 1, 1]; }. List/matrix inputs may span multiple lines, as long as the opening [ is; on the same line as the name of the keyword.; Any of the above keyword specifications can be scoped to individual modules,; by adding the name of the module after the set keyword. Omitting the module; name, or using the name global or globals will result in the keyword being; applied to all modules. For example, in the following input; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13molecule{; o; h 1 roh; h 1 roh 2 ahoh. roh = 0.957; ahoh = 104.5; }. set basis cc-pVDZ; set ccenergy print 3; set scf print 1; energy('ccsd'). the basis set is set to cc-pVDZ throughout, the SCF code will have a print; level of 1 and the ccenergy code, which performs coupled cluster computations,; will use a print level of 3. In this example a full CCSD computation is; performed by running the SCF code first, then the coupled cluster modules;; the energy() Python helper function ensures that this is performed correctly.; Note that the Python interpreter executes commands in the order they appear in; the input file, so if the last four commands in the above example were to read; 1; 2; 3; 4set basis cc-pVDZ; energy('ccsd'); set ccenergy print 3; set scf print 1. the commands that set the print level would be ineffective, as they would be; processed after the CCSD computation completes.; In PsiAPI mode, one can use commands set_options() and; set_module_options() like below. Note that these values; should be of correct type, strings for strings, floats for floats like; convergences. The function ~psi4.core.clean_options that reinitializes; all options may also be useful to separate calculations in a PsiAPI; session.; 1; 2; 3; 4; 5; 6; 7; 8; 9psi4.set_options({; 'scf_type': 'pk',; 'e_convergence': 1.e-5,; 'soscf': True; }). psi4.set_module_options({; 'geom_maxiter': 50; }). Basis Sets¶. Basis Sets; Built-In",MatchSource.WIKI,psi4manual/1.2.1/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html
https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:8222,Performance,perform,performed,8222,"ts that require an array input, standard Python list syntax should; be used, viz.:; 1; 2; 3set {; docc = [3, 0, 1, 1]; }. List/matrix inputs may span multiple lines, as long as the opening [ is; on the same line as the name of the keyword.; Any of the above keyword specifications can be scoped to individual modules,; by adding the name of the module after the set keyword. Omitting the module; name, or using the name global or globals will result in the keyword being; applied to all modules. For example, in the following input; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13molecule{; o; h 1 roh; h 1 roh 2 ahoh. roh = 0.957; ahoh = 104.5; }. set basis cc-pVDZ; set ccenergy print 3; set scf print 1; energy('ccsd'). the basis set is set to cc-pVDZ throughout, the SCF code will have a print; level of 1 and the ccenergy code, which performs coupled cluster computations,; will use a print level of 3. In this example a full CCSD computation is; performed by running the SCF code first, then the coupled cluster modules;; the energy() Python helper function ensures that this is performed correctly.; Note that the Python interpreter executes commands in the order they appear in; the input file, so if the last four commands in the above example were to read; 1; 2; 3; 4set basis cc-pVDZ; energy('ccsd'); set ccenergy print 3; set scf print 1. the commands that set the print level would be ineffective, as they would be; processed after the CCSD computation completes.; In PsiAPI mode, one can use commands set_options() and; set_module_options() like below. Note that these values; should be of correct type, strings for strings, floats for floats like; convergences. The function ~psi4.core.clean_options that reinitializes; all options may also be useful to separate calculations in a PsiAPI; session.; 1; 2; 3; 4; 5; 6; 7; 8; 9psi4.set_options({; 'scf_type': 'pk',; 'e_convergence': 1.e-5,; 'soscf': True; }). psi4.set_module_options({; 'geom_maxiter': 50; }). Basis Sets¶. Basis Sets; Built-In",MatchSource.WIKI,psi4manual/1.2.1/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html
https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:10360,Performance,perform,performing,10360,"ish the previous example of; H2 and H atom:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19molecule h2 {; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h {; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol * (2*h_energy - h2_energy); print ""De=%f"" % D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module, and PSI Variables by Alpha defines them. These can be; accessed through the get_variable() function. For example, after; performing a density fitted MP2 computation, both the spin component; scaled energy and the unscaled MP2 energy are made available:; 1; 2e_mp2 = get_variable('MP2 TOTAL ENERGY'); e_scs_mp2 = get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; are cleared at the start of each energy(), etc. in an input; file by clean_variables().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the; last will include SCF TOTAL ENERGY but not; FCI TOTAL ENERGY.; The entire dictionary of PSI variables can be obtained through; get_variables(). Return Values¶; Most of the usual user computation functions (i.e.,; energy(), optimize(), and; frequency()) return simply the current total energy.; Consult the descriptions of other functions in Psithon Functions: Invoking a Calculation for; what quantities they return and for what data structures t",MatchSource.WIKI,psi4manual/1.2.1/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html
https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:11241,Performance,optimiz,optimize,11241,"ines them. These can be; accessed through the get_variable() function. For example, after; performing a density fitted MP2 computation, both the spin component; scaled energy and the unscaled MP2 energy are made available:; 1; 2e_mp2 = get_variable('MP2 TOTAL ENERGY'); e_scs_mp2 = get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; are cleared at the start of each energy(), etc. in an input; file by clean_variables().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the; last will include SCF TOTAL ENERGY but not; FCI TOTAL ENERGY.; The entire dictionary of PSI variables can be obtained through; get_variables(). Return Values¶; Most of the usual user computation functions (i.e.,; energy(), optimize(), and; frequency()) return simply the current total energy.; Consult the descriptions of other functions in Psithon Functions: Invoking a Calculation for; what quantities they return and for what data structures they make; available for post-processing. Many users need only deal with the simple return; form for the computation functions.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11# E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = energy(...); E = optimize(...); E = frequency(...); G = gradient(...) # used by optimize(); H = hessian(...) # used by frequency(). For more elaborate post-processing of computations, adding; return_wfn=True keyword argument additionally returns; Wavefunction.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16# power user returns; E, wfn = energy(..., return_wfn=True); E, wfn = optimize(..., return_wfn=True); E, wfn = frequency(..., return_wfn=True); G, wfn = gradient(..., return_wfn=",MatchSource.WIKI,psi4manual/1.2.1/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html
https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:11793,Performance,optimiz,optimize,11793,"iables; are cleared at the start of each energy(), etc. in an input; file by clean_variables().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the; last will include SCF TOTAL ENERGY but not; FCI TOTAL ENERGY.; The entire dictionary of PSI variables can be obtained through; get_variables(). Return Values¶; Most of the usual user computation functions (i.e.,; energy(), optimize(), and; frequency()) return simply the current total energy.; Consult the descriptions of other functions in Psithon Functions: Invoking a Calculation for; what quantities they return and for what data structures they make; available for post-processing. Many users need only deal with the simple return; form for the computation functions.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11# E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = energy(...); E = optimize(...); E = frequency(...); G = gradient(...) # used by optimize(); H = hessian(...) # used by frequency(). For more elaborate post-processing of computations, adding; return_wfn=True keyword argument additionally returns; Wavefunction.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16# power user returns; E, wfn = energy(..., return_wfn=True); E, wfn = optimize(..., return_wfn=True); E, wfn = frequency(..., return_wfn=True); G, wfn = gradient(..., return_wfn=True) # used by optimize(); H, wfn = hessian(..., return_wfn=True) # used by frequency(). # print gradient array and its rms; wfn.gradient.print_out(); print wfn.gradient().rms(). # format output for other programs; molden(wfn, 'mycalc.molden'). # access array in another format; np.array(wfn.hessian()). Loops¶; Python provides many control structures, any of which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; 1; 2; 3; 4basis_sets = [""cc-pVDZ"", ""cc-pVTZ",MatchSource.WIKI,psi4manual/1.2.1/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html
https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:11856,Performance,optimiz,optimize,11856," file by clean_variables().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the; last will include SCF TOTAL ENERGY but not; FCI TOTAL ENERGY.; The entire dictionary of PSI variables can be obtained through; get_variables(). Return Values¶; Most of the usual user computation functions (i.e.,; energy(), optimize(), and; frequency()) return simply the current total energy.; Consult the descriptions of other functions in Psithon Functions: Invoking a Calculation for; what quantities they return and for what data structures they make; available for post-processing. Many users need only deal with the simple return; form for the computation functions.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11# E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = energy(...); E = optimize(...); E = frequency(...); G = gradient(...) # used by optimize(); H = hessian(...) # used by frequency(). For more elaborate post-processing of computations, adding; return_wfn=True keyword argument additionally returns; Wavefunction.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16# power user returns; E, wfn = energy(..., return_wfn=True); E, wfn = optimize(..., return_wfn=True); E, wfn = frequency(..., return_wfn=True); G, wfn = gradient(..., return_wfn=True) # used by optimize(); H, wfn = hessian(..., return_wfn=True) # used by frequency(). # print gradient array and its rms; wfn.gradient.print_out(); print wfn.gradient().rms(). # format output for other programs; molden(wfn, 'mycalc.molden'). # access array in another format; np.array(wfn.hessian()). Loops¶; Python provides many control structures, any of which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; 1; 2; 3; 4basis_sets = [""cc-pVDZ"", ""cc-pVTZ"", ""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set;",MatchSource.WIKI,psi4manual/1.2.1/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html
https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:12161,Performance,optimiz,optimize,12161,"riables(). Return Values¶; Most of the usual user computation functions (i.e.,; energy(), optimize(), and; frequency()) return simply the current total energy.; Consult the descriptions of other functions in Psithon Functions: Invoking a Calculation for; what quantities they return and for what data structures they make; available for post-processing. Many users need only deal with the simple return; form for the computation functions.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11# E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = energy(...); E = optimize(...); E = frequency(...); G = gradient(...) # used by optimize(); H = hessian(...) # used by frequency(). For more elaborate post-processing of computations, adding; return_wfn=True keyword argument additionally returns; Wavefunction.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16# power user returns; E, wfn = energy(..., return_wfn=True); E, wfn = optimize(..., return_wfn=True); E, wfn = frequency(..., return_wfn=True); G, wfn = gradient(..., return_wfn=True) # used by optimize(); H, wfn = hessian(..., return_wfn=True) # used by frequency(). # print gradient array and its rms; wfn.gradient.print_out(); print wfn.gradient().rms(). # format output for other programs; molden(wfn, 'mycalc.molden'). # access array in another format; np.array(wfn.hessian()). Loops¶; Python provides many control structures, any of which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; 1; 2; 3; 4basis_sets = [""cc-pVDZ"", ""cc-pVTZ"", ""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_sets is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixi",MatchSource.WIKI,psi4manual/1.2.1/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html
https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:12285,Performance,optimiz,optimize,12285,"the current total energy.; Consult the descriptions of other functions in Psithon Functions: Invoking a Calculation for; what quantities they return and for what data structures they make; available for post-processing. Many users need only deal with the simple return; form for the computation functions.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11# E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = energy(...); E = optimize(...); E = frequency(...); G = gradient(...) # used by optimize(); H = hessian(...) # used by frequency(). For more elaborate post-processing of computations, adding; return_wfn=True keyword argument additionally returns; Wavefunction.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16# power user returns; E, wfn = energy(..., return_wfn=True); E, wfn = optimize(..., return_wfn=True); E, wfn = frequency(..., return_wfn=True); G, wfn = gradient(..., return_wfn=True) # used by optimize(); H, wfn = hessian(..., return_wfn=True) # used by frequency(). # print gradient array and its rms; wfn.gradient.print_out(); print wfn.gradient().rms(). # format output for other programs; molden(wfn, 'mycalc.molden'). # access array in another format; np.array(wfn.hessian()). Loops¶; Python provides many control structures, any of which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; 1; 2; 3; 4basis_sets = [""cc-pVDZ"", ""cc-pVTZ"", ""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_sets is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign.; The geometry specification supports delayed initialization of variable,; which permits potential energy sca",MatchSource.WIKI,psi4manual/1.2.1/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html
https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:14118,Performance,perform,performed,14118,"s strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign.; The geometry specification supports delayed initialization of variable,; which permits potential energy scans. As an example, we can scan both the; angle and bond length in water:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16molecule h2o{; O; H 1 R; H 1 R 2 A; }. Rvals = [0.9, 1.0, 1.1]; Avals = range(102, 106, 2). set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). The declarations of Rvals and Avals are both completely standard Python syntax.; Having named our molecule h2o we can then set the values of R and A within; the loops. Note that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the set keyword.; Cartesian geometries, because of details of the geometry update process,; need to be specified within the loop(s) along with their basis set when; geometry scans are performed. See scf4 for analogous Z-matrix; and Cartiesian scans. Tables of Results¶; The results of computations can be compactly tabulated with the Table() Psithon; function. For example, in the following potential energy surface scan for water; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27molecule h2o {; O; H 1 R; H 1 R 2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(100,102,2). table=Table(rows=[""R"",""A""], cols=[""E(SCF)"",""E(SCS)"",""E(DFMP2)""]). set basis cc-pvdz. for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('mp2'); escf = get_variable('SCF TOTAL ENERGY'); edfmp2 = get_variable('MP2 TOTAL ENERGY'); escsmp2 = get_variable('SCS-MP2 TOTAL ENERGY'); table[R][A] = [escf, escsmp2, edfmp2]. print table; relative=table.copy(); relative.absolute_to_relative(); print relative. we first define a table (on line 10) with two row indices and three column; ind",MatchSource.WIKI,psi4manual/1.2.1/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html
https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:15077,Performance,perform,performed,15077," are performed. See scf4 for analogous Z-matrix; and Cartiesian scans. Tables of Results¶; The results of computations can be compactly tabulated with the Table() Psithon; function. For example, in the following potential energy surface scan for water; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27molecule h2o {; O; H 1 R; H 1 R 2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(100,102,2). table=Table(rows=[""R"",""A""], cols=[""E(SCF)"",""E(SCS)"",""E(DFMP2)""]). set basis cc-pvdz. for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('mp2'); escf = get_variable('SCF TOTAL ENERGY'); edfmp2 = get_variable('MP2 TOTAL ENERGY'); escsmp2 = get_variable('SCS-MP2 TOTAL ENERGY'); table[R][A] = [escf, escsmp2, edfmp2]. print table; relative=table.copy(); relative.absolute_to_relative(); print relative. we first define a table (on line 10) with two row indices and three column; indices. As the potential energy scan is performed, the results are stored; (line 22) and the final table is printed to the output file (line 24). The; table is converted from absolute energies to relative energies (in kcal mol-1); on line 26, before being printed again. The relative energies are reported with; respect to the lowest value in each column. More examples of how to control the; formatting of the tables can be found in the sample input files provided; see; Appendix Test Suite and Sample Inputs for a complete listing. Python Wrappers¶; The Python foundations of the PSI4 driver and Psithon syntax permit; many commonly performed post-processing procedures to be integrated into; the PSI4 suite.; As seen in the neon dimer example from the tutorial section,; the nbody_gufunc() wrapper provides automatic computation of; counterpoise-corrected interaction energies between two molecules. For; example,; 1energy('mp2', bsse_type='cp'). will compute the counterpoise-corrected density-fitted MP2 interaction energy; between two molecules.; PSI4 also provides the ",MatchSource.WIKI,psi4manual/1.2.1/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html
https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:15672,Performance,perform,performed,15672,"R; for A in Avals:; h2o.A = A; energy('mp2'); escf = get_variable('SCF TOTAL ENERGY'); edfmp2 = get_variable('MP2 TOTAL ENERGY'); escsmp2 = get_variable('SCS-MP2 TOTAL ENERGY'); table[R][A] = [escf, escsmp2, edfmp2]. print table; relative=table.copy(); relative.absolute_to_relative(); print relative. we first define a table (on line 10) with two row indices and three column; indices. As the potential energy scan is performed, the results are stored; (line 22) and the final table is printed to the output file (line 24). The; table is converted from absolute energies to relative energies (in kcal mol-1); on line 26, before being printed again. The relative energies are reported with; respect to the lowest value in each column. More examples of how to control the; formatting of the tables can be found in the sample input files provided; see; Appendix Test Suite and Sample Inputs for a complete listing. Python Wrappers¶; The Python foundations of the PSI4 driver and Psithon syntax permit; many commonly performed post-processing procedures to be integrated into; the PSI4 suite.; As seen in the neon dimer example from the tutorial section,; the nbody_gufunc() wrapper provides automatic computation of; counterpoise-corrected interaction energies between two molecules. For; example,; 1energy('mp2', bsse_type='cp'). will compute the counterpoise-corrected density-fitted MP2 interaction energy; between two molecules.; PSI4 also provides the cbs() wrapper,; which automatically computes a complete-basis-set extrapolation (and; automatically sets up the computations with different basis sets required to; do the extrapolation). For example,:; 1; 2; 3; 4; 5# all equivalent. cbs('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). energy('mp2/cc-pv[dt]z'). will compute a 2-point Helgaker extrapolation of the correlation energy; using the cc-pVDZ and cc-pVTZ basis sets (with method MP2) and add this; extrapolated correlation energy to the Hartree–Fock energy in the; lar",MatchSource.WIKI,psi4manual/1.2.1/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html
https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:17055,Performance,perform,perform,17055,"he cbs() wrapper,; which automatically computes a complete-basis-set extrapolation (and; automatically sets up the computations with different basis sets required to; do the extrapolation). For example,:; 1; 2; 3; 4; 5# all equivalent. cbs('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). energy('mp2/cc-pv[dt]z'). will compute a 2-point Helgaker extrapolation of the correlation energy; using the cc-pVDZ and cc-pVTZ basis sets (with method MP2) and add this; extrapolated correlation energy to the Hartree–Fock energy in the; largest basis (cc-pVTZ). cbs() can; either be called directly, as in the first example, or the convenience; syntax of the equivalent second example can be used.; Another very useful and powerful feature of PSI4 is the ability; to compute results on entire databases of molecules at a time,; as provided by the database() wrapper. For example,:; 1database('mp2', 'S22', cp=1, benchmark='S22B'). will perform DF-MP2 counterpoise-corrected interaction energies; (cp=1) on all members of Hobza’s S22 database set of van der Waals; dimers, and then compare the results against the S22B benchmark energies.; Built-in databases include S22, A24, HTBH, HBC6, HSG, S22by5, S66, JSCH,; NCB31, S66by8, and NBC10, among others.; These wrapper functions are discussed separately in; Psithon Functions: Invoking a Calculation. Note that the options documented for Python; functions are placed as arguments in the command that calls the function,; not in the set {...} block or with any other set command. table of contents. Psithon: Structuring an Input File; Physical Constants; Memory Specification; Molecule and Geometry Specification; Job Control Keywords; Basis Sets; PSI Variables; Return Values; Loops; Tables of Results; Python Wrappers. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html
https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:4563,Safety,sanity check,sanity check,4563,"214179E23 # Avagadro's number ; me = 9.10938215E-31 # Electron rest mass (in kg) . In Psithon input files, prepend physical constants with psi_ to; prevent clashes with user-defined variables (e.g., psi_h). In; PsiAPI mode, access as, e.g., psi4.constants.h. Memory Specification¶; By default, PSI4 assumes that 500 MiB of memory are available. While this is; enough for many computations, many of the algorithms will perform better if; more is available. To specify memory, the memory keyword should be used. The following; lines are all equivalent methods for specifying that 2 GB of RAM is available; to PSI4:; 1; 2; 3; 4; 5; 6; 7# all equivalent. memory 2 GB. memory 2000 MB. memory 2000000 kB. Please note that memory can be specified both in IEC binary units (1 KiB = 1024 bytes) and SI units (1 kB = 1000 bytes). PSI4 recognizes and obeys both of them correctly. The units are not case sensitive (Kb and KB are equivalent to kB).; By default, PSI4 performs a “sanity check” when parsing Psithon input files, enforcing a minimum memory requirement of 250 MiB. While it is generally not recomennded to do so, expert users can bypass this check by directly setting the number of bytes availble to PSI4:; 1; 2# setting available memory to 2 MB; set_memory_bytes(2000000). Please note that this memory setting only governs the maximal memory usage of the major data structures and actual total memory usage is slightly higher. This is usually a negligible, except when setting tiny memory allowances.; One convenient way to override the PSI4 default memory is to place a; memory command in the ~/.psi4rc file (Sec. ~/.psi4rc File). For example,; the following makes the default memory 2 GB.; 1set_memory(2000000000). However, unless you’re assured of having only one job running on a node at; a time (and all nodes on the filesystem with ~/.psi4rc have similar memory; capacities), it is advised to set memory in the input file on a; per-calculation basis.; That same command can be used for PsiAPI ",MatchSource.WIKI,psi4manual/1.2.1/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html
https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:3820,Security,access,access,3820," to SI units (Cm) conversion factor for dipoles ; dipmom_au2debye = 2.54174623 # Atomic units to Debye conversion factor for dipoles ; dipmom_debye2si = 3.335640952E-30 # Debye to SI units (Cm) conversion factor for dipoles ; c_au = 137.035999679 # Speed of light in atomic units ; hartree2ev = 27.21138 # Hartree to eV conversion factor ; hartree2wavenumbers = 219474.6 # Hartree to cm$^{-1}$ conversion factor ; hartree2kcalmol = 627.5095 # Hartree to kcal mol$^{-1}$ conversion factor ; hartree2kJmol = 2625.500 # Hartree to kilojoule mol$^{-1}$ conversion factor ; hartree2MHz = 6.579684E9 # Hartree to MHz conversion factor ; kcalmol2wavenumbers = 349.7551 # kcal mol$^{-1}$ to cm$^{-1}$ conversion factor ; e0 = 8.854187817E-12 # Vacuum permittivity (Fm$^{-1}$) ; na = 6.02214179E23 # Avagadro's number ; me = 9.10938215E-31 # Electron rest mass (in kg) . In Psithon input files, prepend physical constants with psi_ to; prevent clashes with user-defined variables (e.g., psi_h). In; PsiAPI mode, access as, e.g., psi4.constants.h. Memory Specification¶; By default, PSI4 assumes that 500 MiB of memory are available. While this is; enough for many computations, many of the algorithms will perform better if; more is available. To specify memory, the memory keyword should be used. The following; lines are all equivalent methods for specifying that 2 GB of RAM is available; to PSI4:; 1; 2; 3; 4; 5; 6; 7# all equivalent. memory 2 GB. memory 2000 MB. memory 2000000 kB. Please note that memory can be specified both in IEC binary units (1 KiB = 1024 bytes) and SI units (1 kB = 1000 bytes). PSI4 recognizes and obeys both of them correctly. The units are not case sensitive (Kb and KB are equivalent to kB).; By default, PSI4 performs a “sanity check” when parsing Psithon input files, enforcing a minimum memory requirement of 250 MiB. While it is generally not recomennded to do so, expert users can bypass this check by directly setting the number of bytes availble to PSI4:; 1; 2# setting ",MatchSource.WIKI,psi4manual/1.2.1/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html
https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:10294,Security,access,accessed,10294,"Python, PSI4 makes the most pertinent results; of each computation available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of; H2 and H atom:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19molecule h2 {; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h {; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol * (2*h_energy - h2_energy); print ""De=%f"" % D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module, and PSI Variables by Alpha defines them. These can be; accessed through the get_variable() function. For example, after; performing a density fitted MP2 computation, both the spin component; scaled energy and the unscaled MP2 energy are made available:; 1; 2e_mp2 = get_variable('MP2 TOTAL ENERGY'); e_scs_mp2 = get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; are cleared at the start of each energy(), etc. in an input; file by clean_variables().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the; last will include SCF TOTAL ENERGY but not; FCI TOTAL ENERGY.; The entire dictionary of PSI variables can be obtained through; get_variables(). Return Values¶; Most of the usual user computation functions (i.e.,; energy(), optimize(), and; frequency()) return simply the current total energy",MatchSource.WIKI,psi4manual/1.2.1/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html
https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:12517,Security,access,access,12517,"th the simple return; form for the computation functions.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11# E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = energy(...); E = optimize(...); E = frequency(...); G = gradient(...) # used by optimize(); H = hessian(...) # used by frequency(). For more elaborate post-processing of computations, adding; return_wfn=True keyword argument additionally returns; Wavefunction.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16# power user returns; E, wfn = energy(..., return_wfn=True); E, wfn = optimize(..., return_wfn=True); E, wfn = frequency(..., return_wfn=True); G, wfn = gradient(..., return_wfn=True) # used by optimize(); H, wfn = hessian(..., return_wfn=True) # used by frequency(). # print gradient array and its rms; wfn.gradient.print_out(); print wfn.gradient().rms(). # format output for other programs; molden(wfn, 'mycalc.molden'). # access array in another format; np.array(wfn.hessian()). Loops¶; Python provides many control structures, any of which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; 1; 2; 3; 4basis_sets = [""cc-pVDZ"", ""cc-pVTZ"", ""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_sets is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign.; The geometry specification supports delayed initialization of variable,; which permits potential energy scans. As an example, we can scan both the; angle and bond length in water:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16molecule h2o{; O; H 1 R; H 1 R 2 A; }. Rvals = [0.9, 1.0, 1.1]; Avals = range(102, 106, 2). set basis cc-pvdz; set scf e",MatchSource.WIKI,psi4manual/1.2.1/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html
https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:13833,Security,access,access,13833,"y('scf'). The declaration of basis_sets is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign.; The geometry specification supports delayed initialization of variable,; which permits potential energy scans. As an example, we can scan both the; angle and bond length in water:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16molecule h2o{; O; H 1 R; H 1 R 2 A; }. Rvals = [0.9, 1.0, 1.1]; Avals = range(102, 106, 2). set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). The declarations of Rvals and Avals are both completely standard Python syntax.; Having named our molecule h2o we can then set the values of R and A within; the loops. Note that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the set keyword.; Cartesian geometries, because of details of the geometry update process,; need to be specified within the loop(s) along with their basis set when; geometry scans are performed. See scf4 for analogous Z-matrix; and Cartiesian scans. Tables of Results¶; The results of computations can be compactly tabulated with the Table() Psithon; function. For example, in the following potential energy surface scan for water; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27molecule h2o {; O; H 1 R; H 1 R 2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(100,102,2). table=Table(rows=[""R"",""A""], cols=[""E(SCF)"",""E(SCS)"",""E(DFMP2)""]). set basis cc-pvdz. for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('mp2'); escf = get_variable('SCF TOTAL ENERGY'); edfmp2 = get_variable('MP2 TOTAL ENERGY'); escsmp2 = get_variable('SCS-MP2 TOTAL ENERGY'); table[R][A] = [escf, escsmp2, edf",MatchSource.WIKI,psi4manual/1.2.1/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html
https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:564,Testability,test,test,564,"﻿. Psithon: Structuring an Input File. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Psithon: Structuring an Input File¶; To allow arbitrarily complex computations to be performed, PSI4 was built; upon the Python interpreter. However, to make the input syntax simpler, some; pre-processing of the input file is performed before it is interpreted,; resulting in Python syntax that is customized for PSI, termed Psithon. In; this section we will describe the essential features of the Psithon language.; PSI4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; 1UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that the user’s ~/.psi4rc values can; override the builtins (in the input file, not in the C++ code).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files. # Do not modify this file! It is auto-generated by the document_options_and_tests; # script, from psi4topdir/psi4/include/psi4/physconst.h; h = 6.62606896E-34 # The Planck constant (Js) ; c = 2.99792458E8 # Speed of l",MatchSource.WIKI,psi4manual/1.2.1/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html
https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:654,Testability,test,test,654,"﻿. Psithon: Structuring an Input File. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Psithon: Structuring an Input File¶; To allow arbitrarily complex computations to be performed, PSI4 was built; upon the Python interpreter. However, to make the input syntax simpler, some; pre-processing of the input file is performed before it is interpreted,; resulting in Python syntax that is customized for PSI, termed Psithon. In; this section we will describe the essential features of the Psithon language.; PSI4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; 1UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that the user’s ~/.psi4rc values can; override the builtins (in the input file, not in the C++ code).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files. # Do not modify this file! It is auto-generated by the document_options_and_tests; # script, from psi4topdir/psi4/include/psi4/physconst.h; h = 6.62606896E-34 # The Planck constant (Js) ; c = 2.99792458E8 # Speed of l",MatchSource.WIKI,psi4manual/1.2.1/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html
https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:17031,Testability,benchmark,benchmark,17031,"corrected density-fitted MP2 interaction energy; between two molecules.; PSI4 also provides the cbs() wrapper,; which automatically computes a complete-basis-set extrapolation (and; automatically sets up the computations with different basis sets required to; do the extrapolation). For example,:; 1; 2; 3; 4; 5# all equivalent. cbs('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). energy('mp2/cc-pv[dt]z'). will compute a 2-point Helgaker extrapolation of the correlation energy; using the cc-pVDZ and cc-pVTZ basis sets (with method MP2) and add this; extrapolated correlation energy to the Hartree–Fock energy in the; largest basis (cc-pVTZ). cbs() can; either be called directly, as in the first example, or the convenience; syntax of the equivalent second example can be used.; Another very useful and powerful feature of PSI4 is the ability; to compute results on entire databases of molecules at a time,; as provided by the database() wrapper. For example,:; 1database('mp2', 'S22', cp=1, benchmark='S22B'). will perform DF-MP2 counterpoise-corrected interaction energies; (cp=1) on all members of Hobza’s S22 database set of van der Waals; dimers, and then compare the results against the S22B benchmark energies.; Built-in databases include S22, A24, HTBH, HBC6, HSG, S22by5, S66, JSCH,; NCB31, S66by8, and NBC10, among others.; These wrapper functions are discussed separately in; Psithon Functions: Invoking a Calculation. Note that the options documented for Python; functions are placed as arguments in the command that calls the function,; not in the set {...} block or with any other set command. table of contents. Psithon: Structuring an Input File; Physical Constants; Memory Specification; Molecule and Geometry Specification; Job Control Keywords; Basis Sets; PSI Variables; Return Values; Loops; Tables of Results; Python Wrappers. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. © Copyright 2018, The Psi",MatchSource.WIKI,psi4manual/1.2.1/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html
https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:17237,Testability,benchmark,benchmark,17237,"he cbs() wrapper,; which automatically computes a complete-basis-set extrapolation (and; automatically sets up the computations with different basis sets required to; do the extrapolation). For example,:; 1; 2; 3; 4; 5# all equivalent. cbs('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). energy('mp2/cc-pv[dt]z'). will compute a 2-point Helgaker extrapolation of the correlation energy; using the cc-pVDZ and cc-pVTZ basis sets (with method MP2) and add this; extrapolated correlation energy to the Hartree–Fock energy in the; largest basis (cc-pVTZ). cbs() can; either be called directly, as in the first example, or the convenience; syntax of the equivalent second example can be used.; Another very useful and powerful feature of PSI4 is the ability; to compute results on entire databases of molecules at a time,; as provided by the database() wrapper. For example,:; 1database('mp2', 'S22', cp=1, benchmark='S22B'). will perform DF-MP2 counterpoise-corrected interaction energies; (cp=1) on all members of Hobza’s S22 database set of van der Waals; dimers, and then compare the results against the S22B benchmark energies.; Built-in databases include S22, A24, HTBH, HBC6, HSG, S22by5, S66, JSCH,; NCB31, S66by8, and NBC10, among others.; These wrapper functions are discussed separately in; Psithon Functions: Invoking a Calculation. Note that the options documented for Python; functions are placed as arguments in the command that calls the function,; not in the set {...} block or with any other set command. table of contents. Psithon: Structuring an Input File; Physical Constants; Memory Specification; Molecule and Geometry Specification; Job Control Keywords; Basis Sets; PSI Variables; Return Values; Loops; Tables of Results; Python Wrappers. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html
https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:284,Usability,simpl,simpler,284,"﻿. Psithon: Structuring an Input File. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Psithon: Structuring an Input File¶; To allow arbitrarily complex computations to be performed, PSI4 was built; upon the Python interpreter. However, to make the input syntax simpler, some; pre-processing of the input file is performed before it is interpreted,; resulting in Python syntax that is customized for PSI, termed Psithon. In; this section we will describe the essential features of the Psithon language.; PSI4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; 1UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that the user’s ~/.psi4rc values can; override the builtins (in the input file, not in the C++ code).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files. # Do not modify this file! It is auto-generated by the document_options_and_tests; # script, from psi4topdir/psi4/include/psi4/physconst.h; h = 6.62606896E-34 # The Planck constant (Js) ; c = 2.99792458E8 # Speed of l",MatchSource.WIKI,psi4manual/1.2.1/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html
https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:10806,Usability,clear,cleared,10806,"""De=%f"" % D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module, and PSI Variables by Alpha defines them. These can be; accessed through the get_variable() function. For example, after; performing a density fitted MP2 computation, both the spin component; scaled energy and the unscaled MP2 energy are made available:; 1; 2e_mp2 = get_variable('MP2 TOTAL ENERGY'); e_scs_mp2 = get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; are cleared at the start of each energy(), etc. in an input; file by clean_variables().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the; last will include SCF TOTAL ENERGY but not; FCI TOTAL ENERGY.; The entire dictionary of PSI variables can be obtained through; get_variables(). Return Values¶; Most of the usual user computation functions (i.e.,; energy(), optimize(), and; frequency()) return simply the current total energy.; Consult the descriptions of other functions in Psithon Functions: Invoking a Calculation for; what quantities they return and for what data structures they make; available for post-processing. Many users need only deal with the simple return; form for the computation functions.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11# E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = energy(...); E = optimize(...); E = f",MatchSource.WIKI,psi4manual/1.2.1/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html
https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:11278,Usability,simpl,simply,11278,"ines them. These can be; accessed through the get_variable() function. For example, after; performing a density fitted MP2 computation, both the spin component; scaled energy and the unscaled MP2 energy are made available:; 1; 2e_mp2 = get_variable('MP2 TOTAL ENERGY'); e_scs_mp2 = get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; are cleared at the start of each energy(), etc. in an input; file by clean_variables().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the; last will include SCF TOTAL ENERGY but not; FCI TOTAL ENERGY.; The entire dictionary of PSI variables can be obtained through; get_variables(). Return Values¶; Most of the usual user computation functions (i.e.,; energy(), optimize(), and; frequency()) return simply the current total energy.; Consult the descriptions of other functions in Psithon Functions: Invoking a Calculation for; what quantities they return and for what data structures they make; available for post-processing. Many users need only deal with the simple return; form for the computation functions.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11# E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = energy(...); E = optimize(...); E = frequency(...); G = gradient(...) # used by optimize(); H = hessian(...) # used by frequency(). For more elaborate post-processing of computations, adding; return_wfn=True keyword argument additionally returns; Wavefunction.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16# power user returns; E, wfn = energy(..., return_wfn=True); E, wfn = optimize(..., return_wfn=True); E, wfn = frequency(..., return_wfn=True); G, wfn = gradient(..., return_wfn=",MatchSource.WIKI,psi4manual/1.2.1/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html
https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:11540,Usability,simpl,simple,11540,"2 = get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; are cleared at the start of each energy(), etc. in an input; file by clean_variables().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the; last will include SCF TOTAL ENERGY but not; FCI TOTAL ENERGY.; The entire dictionary of PSI variables can be obtained through; get_variables(). Return Values¶; Most of the usual user computation functions (i.e.,; energy(), optimize(), and; frequency()) return simply the current total energy.; Consult the descriptions of other functions in Psithon Functions: Invoking a Calculation for; what quantities they return and for what data structures they make; available for post-processing. Many users need only deal with the simple return; form for the computation functions.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11# E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = energy(...); E = optimize(...); E = frequency(...); G = gradient(...) # used by optimize(); H = hessian(...) # used by frequency(). For more elaborate post-processing of computations, adding; return_wfn=True keyword argument additionally returns; Wavefunction.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16# power user returns; E, wfn = energy(..., return_wfn=True); E, wfn = optimize(..., return_wfn=True); E, wfn = frequency(..., return_wfn=True); G, wfn = gradient(..., return_wfn=True) # used by optimize(); H, wfn = hessian(..., return_wfn=True) # used by frequency(). # print gradient array and its rms; wfn.gradient.print_out(); print wfn.gradient().rms(). # format output for other programs; molden(wfn, 'mycalc.molden'). # access array in another format",MatchSource.WIKI,psi4manual/1.2.1/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html
https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:11756,Usability,simpl,simple,11756,"ables(). Note that PSI variables; are cleared at the start of each energy(), etc. in an input; file by clean_variables().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the; last will include SCF TOTAL ENERGY but not; FCI TOTAL ENERGY.; The entire dictionary of PSI variables can be obtained through; get_variables(). Return Values¶; Most of the usual user computation functions (i.e.,; energy(), optimize(), and; frequency()) return simply the current total energy.; Consult the descriptions of other functions in Psithon Functions: Invoking a Calculation for; what quantities they return and for what data structures they make; available for post-processing. Many users need only deal with the simple return; form for the computation functions.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11# E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = energy(...); E = optimize(...); E = frequency(...); G = gradient(...) # used by optimize(); H = hessian(...) # used by frequency(). For more elaborate post-processing of computations, adding; return_wfn=True keyword argument additionally returns; Wavefunction.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16# power user returns; E, wfn = energy(..., return_wfn=True); E, wfn = optimize(..., return_wfn=True); E, wfn = frequency(..., return_wfn=True); G, wfn = gradient(..., return_wfn=True) # used by optimize(); H, wfn = hessian(..., return_wfn=True) # used by frequency(). # print gradient array and its rms; wfn.gradient.print_out(); print wfn.gradient().rms(). # format output for other programs; molden(wfn, 'mycalc.molden'). # access array in another format; np.array(wfn.hessian()). Loops¶; Python provides many control structures, any of which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; 1; 2; 3; 4basis_s",MatchSource.WIKI,psi4manual/1.2.1/psithoninput-1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html
https://psicode.org/psi4manual/1.2.1/psithoninput.html:1294,Availability,avail,available,1294,"some; pre-processing of the input file is performed before it is interpreted,; resulting in Python syntax that is customized for PSI, termed Psithon. In; this section we will describe the essential features of the Psithon language.; PSI4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; 1UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that the user’s ~/.psi4rc values can; override the builtins (in the input file, not in the C++ code).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files. # Do not modify this file! It is auto-generated by the document_options_and_tests; # script, from psi4topdir/psi4/include/psi4/physconst.h; h = 6.62606896E-34 # The Planck constant (Js) ; c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; R = 8.314472 # Universal gas constant (JK$^{-1}$mol$^{-1}$) ; bohr2angstroms = 0.52917720859 # Bohr to Angstroms conversion factor ; bohr2m = 0.52917720859E-10 # Bohr to meters conversion factor ; bohr2cm = 0.5291772",MatchSource.WIKI,psi4manual/1.2.1/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput.html
https://psicode.org/psi4manual/1.2.1/psithoninput.html:1745,Availability,avail,available,1745,"4 source directory and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; 1UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that the user’s ~/.psi4rc values can; override the builtins (in the input file, not in the C++ code).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files. # Do not modify this file! It is auto-generated by the document_options_and_tests; # script, from psi4topdir/psi4/include/psi4/physconst.h; h = 6.62606896E-34 # The Planck constant (Js) ; c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; R = 8.314472 # Universal gas constant (JK$^{-1}$mol$^{-1}$) ; bohr2angstroms = 0.52917720859 # Bohr to Angstroms conversion factor ; bohr2m = 0.52917720859E-10 # Bohr to meters conversion factor ; bohr2cm = 0.52917720859E-8 # Bohr to centimeters conversion factor ; amu2g = 1.660538782E-24 # Atomic mass units to grams conversion factor ; amu2kg = 1.660538782E-27 # Atomic mass units to kg conversion factor ; au2amu = 5.485799097E-4 # Atomic units (m$@@e$) to atomic mass units conversion factor ; hartree2J = 4.359744E-18 # Hartree to joule conversion factor ; hartree2aJ = 4.359744 # Hartree to attojoule (10$^{-18}$J) conversion factor ; cal2J = ",MatchSource.WIKI,psi4manual/1.2.1/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput.html
https://psicode.org/psi4manual/1.2.1/psithoninput.html:3930,Availability,avail,available,3930," Atomic units to Debye conversion factor for dipoles ; dipmom_debye2si = 3.335640952E-30 # Debye to SI units (Cm) conversion factor for dipoles ; c_au = 137.035999679 # Speed of light in atomic units ; hartree2ev = 27.21138 # Hartree to eV conversion factor ; hartree2wavenumbers = 219474.6 # Hartree to cm$^{-1}$ conversion factor ; hartree2kcalmol = 627.5095 # Hartree to kcal mol$^{-1}$ conversion factor ; hartree2kJmol = 2625.500 # Hartree to kilojoule mol$^{-1}$ conversion factor ; hartree2MHz = 6.579684E9 # Hartree to MHz conversion factor ; kcalmol2wavenumbers = 349.7551 # kcal mol$^{-1}$ to cm$^{-1}$ conversion factor ; e0 = 8.854187817E-12 # Vacuum permittivity (Fm$^{-1}$) ; na = 6.02214179E23 # Avagadro's number ; me = 9.10938215E-31 # Electron rest mass (in kg) . In Psithon input files, prepend physical constants with psi_ to; prevent clashes with user-defined variables (e.g., psi_h). In; PsiAPI mode, access as, e.g., psi4.constants.h. Memory Specification¶; By default, PSI4 assumes that 500 MiB of memory are available. While this is; enough for many computations, many of the algorithms will perform better if; more is available. To specify memory, the memory keyword should be used. The following; lines are all equivalent methods for specifying that 2 GB of RAM is available; to PSI4:; 1; 2; 3; 4; 5; 6; 7# all equivalent. memory 2 GB. memory 2000 MB. memory 2000000 kB. Please note that memory can be specified both in IEC binary units (1 KiB = 1024 bytes) and SI units (1 kB = 1000 bytes). PSI4 recognizes and obeys both of them correctly. The units are not case sensitive (Kb and KB are equivalent to kB).; By default, PSI4 performs a “sanity check” when parsing Psithon input files, enforcing a minimum memory requirement of 250 MiB. While it is generally not recomennded to do so, expert users can bypass this check by directly setting the number of bytes availble to PSI4:; 1; 2# setting available memory to 2 MB; set_memory_bytes(2000000). Please note that this memo",MatchSource.WIKI,psi4manual/1.2.1/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput.html
https://psicode.org/psi4manual/1.2.1/psithoninput.html:4041,Availability,avail,available,4041,"o SI units (Cm) conversion factor for dipoles ; c_au = 137.035999679 # Speed of light in atomic units ; hartree2ev = 27.21138 # Hartree to eV conversion factor ; hartree2wavenumbers = 219474.6 # Hartree to cm$^{-1}$ conversion factor ; hartree2kcalmol = 627.5095 # Hartree to kcal mol$^{-1}$ conversion factor ; hartree2kJmol = 2625.500 # Hartree to kilojoule mol$^{-1}$ conversion factor ; hartree2MHz = 6.579684E9 # Hartree to MHz conversion factor ; kcalmol2wavenumbers = 349.7551 # kcal mol$^{-1}$ to cm$^{-1}$ conversion factor ; e0 = 8.854187817E-12 # Vacuum permittivity (Fm$^{-1}$) ; na = 6.02214179E23 # Avagadro's number ; me = 9.10938215E-31 # Electron rest mass (in kg) . In Psithon input files, prepend physical constants with psi_ to; prevent clashes with user-defined variables (e.g., psi_h). In; PsiAPI mode, access as, e.g., psi4.constants.h. Memory Specification¶; By default, PSI4 assumes that 500 MiB of memory are available. While this is; enough for many computations, many of the algorithms will perform better if; more is available. To specify memory, the memory keyword should be used. The following; lines are all equivalent methods for specifying that 2 GB of RAM is available; to PSI4:; 1; 2; 3; 4; 5; 6; 7# all equivalent. memory 2 GB. memory 2000 MB. memory 2000000 kB. Please note that memory can be specified both in IEC binary units (1 KiB = 1024 bytes) and SI units (1 kB = 1000 bytes). PSI4 recognizes and obeys both of them correctly. The units are not case sensitive (Kb and KB are equivalent to kB).; By default, PSI4 performs a “sanity check” when parsing Psithon input files, enforcing a minimum memory requirement of 250 MiB. While it is generally not recomennded to do so, expert users can bypass this check by directly setting the number of bytes availble to PSI4:; 1; 2# setting available memory to 2 MB; set_memory_bytes(2000000). Please note that this memory setting only governs the maximal memory usage of the major data structures and actual total memo",MatchSource.WIKI,psi4manual/1.2.1/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput.html
https://psicode.org/psi4manual/1.2.1/psithoninput.html:4189,Availability,avail,available,4189,"s = 219474.6 # Hartree to cm$^{-1}$ conversion factor ; hartree2kcalmol = 627.5095 # Hartree to kcal mol$^{-1}$ conversion factor ; hartree2kJmol = 2625.500 # Hartree to kilojoule mol$^{-1}$ conversion factor ; hartree2MHz = 6.579684E9 # Hartree to MHz conversion factor ; kcalmol2wavenumbers = 349.7551 # kcal mol$^{-1}$ to cm$^{-1}$ conversion factor ; e0 = 8.854187817E-12 # Vacuum permittivity (Fm$^{-1}$) ; na = 6.02214179E23 # Avagadro's number ; me = 9.10938215E-31 # Electron rest mass (in kg) . In Psithon input files, prepend physical constants with psi_ to; prevent clashes with user-defined variables (e.g., psi_h). In; PsiAPI mode, access as, e.g., psi4.constants.h. Memory Specification¶; By default, PSI4 assumes that 500 MiB of memory are available. While this is; enough for many computations, many of the algorithms will perform better if; more is available. To specify memory, the memory keyword should be used. The following; lines are all equivalent methods for specifying that 2 GB of RAM is available; to PSI4:; 1; 2; 3; 4; 5; 6; 7# all equivalent. memory 2 GB. memory 2000 MB. memory 2000000 kB. Please note that memory can be specified both in IEC binary units (1 KiB = 1024 bytes) and SI units (1 kB = 1000 bytes). PSI4 recognizes and obeys both of them correctly. The units are not case sensitive (Kb and KB are equivalent to kB).; By default, PSI4 performs a “sanity check” when parsing Psithon input files, enforcing a minimum memory requirement of 250 MiB. While it is generally not recomennded to do so, expert users can bypass this check by directly setting the number of bytes availble to PSI4:; 1; 2# setting available memory to 2 MB; set_memory_bytes(2000000). Please note that this memory setting only governs the maximal memory usage of the major data structures and actual total memory usage is slightly higher. This is usually a negligible, except when setting tiny memory allowances.; One convenient way to override the PSI4 default memory is to place a; memory",MatchSource.WIKI,psi4manual/1.2.1/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput.html
https://psicode.org/psi4manual/1.2.1/psithoninput.html:4785,Availability,avail,availble,4785,"user-defined variables (e.g., psi_h). In; PsiAPI mode, access as, e.g., psi4.constants.h. Memory Specification¶; By default, PSI4 assumes that 500 MiB of memory are available. While this is; enough for many computations, many of the algorithms will perform better if; more is available. To specify memory, the memory keyword should be used. The following; lines are all equivalent methods for specifying that 2 GB of RAM is available; to PSI4:; 1; 2; 3; 4; 5; 6; 7# all equivalent. memory 2 GB. memory 2000 MB. memory 2000000 kB. Please note that memory can be specified both in IEC binary units (1 KiB = 1024 bytes) and SI units (1 kB = 1000 bytes). PSI4 recognizes and obeys both of them correctly. The units are not case sensitive (Kb and KB are equivalent to kB).; By default, PSI4 performs a “sanity check” when parsing Psithon input files, enforcing a minimum memory requirement of 250 MiB. While it is generally not recomennded to do so, expert users can bypass this check by directly setting the number of bytes availble to PSI4:; 1; 2# setting available memory to 2 MB; set_memory_bytes(2000000). Please note that this memory setting only governs the maximal memory usage of the major data structures and actual total memory usage is slightly higher. This is usually a negligible, except when setting tiny memory allowances.; One convenient way to override the PSI4 default memory is to place a; memory command in the ~/.psi4rc file (Sec. ~/.psi4rc File). For example,; the following makes the default memory 2 GB.; 1set_memory(2000000000). However, unless you’re assured of having only one job running on a node at; a time (and all nodes on the filesystem with ~/.psi4rc have similar memory; capacities), it is advised to set memory in the input file on a; per-calculation basis.; That same command can be used for PsiAPI mode:; 1psi4.set_memory(int(5e8)). Note; For parallel jobs, the memory keyword represents the total memory; available to the job, not the memory per thread. Molecule and",MatchSource.WIKI,psi4manual/1.2.1/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput.html
https://psicode.org/psi4manual/1.2.1/psithoninput.html:4818,Availability,avail,available,4818,"user-defined variables (e.g., psi_h). In; PsiAPI mode, access as, e.g., psi4.constants.h. Memory Specification¶; By default, PSI4 assumes that 500 MiB of memory are available. While this is; enough for many computations, many of the algorithms will perform better if; more is available. To specify memory, the memory keyword should be used. The following; lines are all equivalent methods for specifying that 2 GB of RAM is available; to PSI4:; 1; 2; 3; 4; 5; 6; 7# all equivalent. memory 2 GB. memory 2000 MB. memory 2000000 kB. Please note that memory can be specified both in IEC binary units (1 KiB = 1024 bytes) and SI units (1 kB = 1000 bytes). PSI4 recognizes and obeys both of them correctly. The units are not case sensitive (Kb and KB are equivalent to kB).; By default, PSI4 performs a “sanity check” when parsing Psithon input files, enforcing a minimum memory requirement of 250 MiB. While it is generally not recomennded to do so, expert users can bypass this check by directly setting the number of bytes availble to PSI4:; 1; 2# setting available memory to 2 MB; set_memory_bytes(2000000). Please note that this memory setting only governs the maximal memory usage of the major data structures and actual total memory usage is slightly higher. This is usually a negligible, except when setting tiny memory allowances.; One convenient way to override the PSI4 default memory is to place a; memory command in the ~/.psi4rc file (Sec. ~/.psi4rc File). For example,; the following makes the default memory 2 GB.; 1set_memory(2000000000). However, unless you’re assured of having only one job running on a node at; a time (and all nodes on the filesystem with ~/.psi4rc have similar memory; capacities), it is advised to set memory in the input file on a; per-calculation basis.; That same command can be used for PsiAPI mode:; 1psi4.set_memory(int(5e8)). Note; For parallel jobs, the memory keyword represents the total memory; available to the job, not the memory per thread. Molecule and",MatchSource.WIKI,psi4manual/1.2.1/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput.html
https://psicode.org/psi4manual/1.2.1/psithoninput.html:5705,Availability,avail,available,5705,"mennded to do so, expert users can bypass this check by directly setting the number of bytes availble to PSI4:; 1; 2# setting available memory to 2 MB; set_memory_bytes(2000000). Please note that this memory setting only governs the maximal memory usage of the major data structures and actual total memory usage is slightly higher. This is usually a negligible, except when setting tiny memory allowances.; One convenient way to override the PSI4 default memory is to place a; memory command in the ~/.psi4rc file (Sec. ~/.psi4rc File). For example,; the following makes the default memory 2 GB.; 1set_memory(2000000000). However, unless you’re assured of having only one job running on a node at; a time (and all nodes on the filesystem with ~/.psi4rc have similar memory; capacities), it is advised to set memory in the input file on a; per-calculation basis.; That same command can be used for PsiAPI mode:; 1psi4.set_memory(int(5e8)). Note; For parallel jobs, the memory keyword represents the total memory; available to the job, not the memory per thread. Molecule and Geometry Specification¶. Molecule and Geometry Specification; Coordinates; Molecule Keywords; Multiple Molecules; Ghost Atoms; Isotopic Substitution; PubChem Database; Symmetry; Non-Covalently Bonded Molecule Fragments; Advanced Python. To add EFP fragments to a molecule, see Molecule Specification. Job Control Keywords¶; PSI4 comprises a number of C++ modules that each perform; specific tasks and are callable directly from the Python front end. Each module; recognizes specific keywords in the input file which control its function.; These keywords are detailed in Appendix Keywords by Module.; The keywords can be made global, or scoped to apply to; certain specific modules. The following examples demonstrate some of the ways; that global keywords can be specified:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21# all equivalent. set globals basis cc-pVDZ. set basis cc-pVDZ. set globals b",MatchSource.WIKI,psi4manual/1.2.1/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput.html
https://psicode.org/psi4manual/1.2.1/psithoninput.html:9376,Availability,avail,available,9376,"last four commands in the above example were to read; 1; 2; 3; 4set basis cc-pVDZ; energy('ccsd'); set ccenergy print 3; set scf print 1. the commands that set the print level would be ineffective, as they would be; processed after the CCSD computation completes.; In PsiAPI mode, one can use commands set_options() and; set_module_options() like below. Note that these values; should be of correct type, strings for strings, floats for floats like; convergences. The function ~psi4.core.clean_options that reinitializes; all options may also be useful to separate calculations in a PsiAPI; session.; 1; 2; 3; 4; 5; 6; 7; 8; 9psi4.set_options({; 'scf_type': 'pk',; 'e_convergence': 1.e-5,; 'soscf': True; }). psi4.set_module_options({; 'geom_maxiter': 50; }). Basis Sets¶. Basis Sets; Built-In Basis Sets; Mixing Basis Sets; Decontracted Basis Sets; User-Defined Basis Sets; Inputting effective core potentials (ECPs). PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results; of each computation available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of; H2 and H atom:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19molecule h2 {; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h {; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol * (2*h_energy - h2_energy); print ""De=%f"" % D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module, and PSI Variables by Alpha defines them. These can be; accessed through the get_variable() function. For example",MatchSource.WIKI,psi4manual/1.2.1/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput.html
https://psicode.org/psi4manual/1.2.1/psithoninput.html:10481,Availability,avail,available,10481,"ish the previous example of; H2 and H atom:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19molecule h2 {; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h {; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol * (2*h_energy - h2_energy); print ""De=%f"" % D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module, and PSI Variables by Alpha defines them. These can be; accessed through the get_variable() function. For example, after; performing a density fitted MP2 computation, both the spin component; scaled energy and the unscaled MP2 energy are made available:; 1; 2e_mp2 = get_variable('MP2 TOTAL ENERGY'); e_scs_mp2 = get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; are cleared at the start of each energy(), etc. in an input; file by clean_variables().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the; last will include SCF TOTAL ENERGY but not; FCI TOTAL ENERGY.; The entire dictionary of PSI variables can be obtained through; get_variables(). Return Values¶; Most of the usual user computation functions (i.e.,; energy(), optimize(), and; frequency()) return simply the current total energy.; Consult the descriptions of other functions in Psithon Functions: Invoking a Calculation for; what quantities they return and for what data structures t",MatchSource.WIKI,psi4manual/1.2.1/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput.html
https://psicode.org/psi4manual/1.2.1/psithoninput.html:11474,Availability,avail,available,11474,"th the spin component; scaled energy and the unscaled MP2 energy are made available:; 1; 2e_mp2 = get_variable('MP2 TOTAL ENERGY'); e_scs_mp2 = get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; are cleared at the start of each energy(), etc. in an input; file by clean_variables().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the; last will include SCF TOTAL ENERGY but not; FCI TOTAL ENERGY.; The entire dictionary of PSI variables can be obtained through; get_variables(). Return Values¶; Most of the usual user computation functions (i.e.,; energy(), optimize(), and; frequency()) return simply the current total energy.; Consult the descriptions of other functions in Psithon Functions: Invoking a Calculation for; what quantities they return and for what data structures they make; available for post-processing. Many users need only deal with the simple return; form for the computation functions.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11# E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = energy(...); E = optimize(...); E = frequency(...); G = gradient(...) # used by optimize(); H = hessian(...) # used by frequency(). For more elaborate post-processing of computations, adding; return_wfn=True keyword argument additionally returns; Wavefunction.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16# power user returns; E, wfn = energy(..., return_wfn=True); E, wfn = optimize(..., return_wfn=True); E, wfn = frequency(..., return_wfn=True); G, wfn = gradient(..., return_wfn=True) # used by optimize(); H, wfn = hessian(..., return_wfn=True) # used by frequency(). # print gradient array and its rms; wfn.gradient",MatchSource.WIKI,psi4manual/1.2.1/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput.html
https://psicode.org/psi4manual/1.2.1/psithoninput.html:14009,Deployability,update,update,14009,"s strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign.; The geometry specification supports delayed initialization of variable,; which permits potential energy scans. As an example, we can scan both the; angle and bond length in water:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16molecule h2o{; O; H 1 R; H 1 R 2 A; }. Rvals = [0.9, 1.0, 1.1]; Avals = range(102, 106, 2). set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). The declarations of Rvals and Avals are both completely standard Python syntax.; Having named our molecule h2o we can then set the values of R and A within; the loops. Note that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the set keyword.; Cartesian geometries, because of details of the geometry update process,; need to be specified within the loop(s) along with their basis set when; geometry scans are performed. See scf4 for analogous Z-matrix; and Cartiesian scans. Tables of Results¶; The results of computations can be compactly tabulated with the Table() Psithon; function. For example, in the following potential energy surface scan for water; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27molecule h2o {; O; H 1 R; H 1 R 2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(100,102,2). table=Table(rows=[""R"",""A""], cols=[""E(SCF)"",""E(SCS)"",""E(DFMP2)""]). set basis cc-pvdz. for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('mp2'); escf = get_variable('SCF TOTAL ENERGY'); edfmp2 = get_variable('MP2 TOTAL ENERGY'); escsmp2 = get_variable('SCS-MP2 TOTAL ENERGY'); table[R][A] = [escf, escsmp2, edfmp2]. print table; relative=table.copy(); relative.absolute_to_relative(); print relative. we first define a table (on line 10) with two row indices and three column; ind",MatchSource.WIKI,psi4manual/1.2.1/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput.html
https://psicode.org/psi4manual/1.2.1/psithoninput.html:15715,Deployability,integrat,integrated,15715,"R; for A in Avals:; h2o.A = A; energy('mp2'); escf = get_variable('SCF TOTAL ENERGY'); edfmp2 = get_variable('MP2 TOTAL ENERGY'); escsmp2 = get_variable('SCS-MP2 TOTAL ENERGY'); table[R][A] = [escf, escsmp2, edfmp2]. print table; relative=table.copy(); relative.absolute_to_relative(); print relative. we first define a table (on line 10) with two row indices and three column; indices. As the potential energy scan is performed, the results are stored; (line 22) and the final table is printed to the output file (line 24). The; table is converted from absolute energies to relative energies (in kcal mol-1); on line 26, before being printed again. The relative energies are reported with; respect to the lowest value in each column. More examples of how to control the; formatting of the tables can be found in the sample input files provided; see; Appendix Test Suite and Sample Inputs for a complete listing. Python Wrappers¶; The Python foundations of the PSI4 driver and Psithon syntax permit; many commonly performed post-processing procedures to be integrated into; the PSI4 suite.; As seen in the neon dimer example from the tutorial section,; the nbody_gufunc() wrapper provides automatic computation of; counterpoise-corrected interaction energies between two molecules. For; example,; 1energy('mp2', bsse_type='cp'). will compute the counterpoise-corrected density-fitted MP2 interaction energy; between two molecules.; PSI4 also provides the cbs() wrapper,; which automatically computes a complete-basis-set extrapolation (and; automatically sets up the computations with different basis sets required to; do the extrapolation). For example,:; 1; 2; 3; 4; 5# all equivalent. cbs('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). energy('mp2/cc-pv[dt]z'). will compute a 2-point Helgaker extrapolation of the correlation energy; using the cc-pVDZ and cc-pVTZ basis sets (with method MP2) and add this; extrapolated correlation energy to the Hartree–Fock energy in the; lar",MatchSource.WIKI,psi4manual/1.2.1/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput.html
https://psicode.org/psi4manual/1.2.1/psithoninput.html:18034,Deployability,update,updated,18034,"he cbs() wrapper,; which automatically computes a complete-basis-set extrapolation (and; automatically sets up the computations with different basis sets required to; do the extrapolation). For example,:; 1; 2; 3; 4; 5# all equivalent. cbs('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). energy('mp2/cc-pv[dt]z'). will compute a 2-point Helgaker extrapolation of the correlation energy; using the cc-pVDZ and cc-pVTZ basis sets (with method MP2) and add this; extrapolated correlation energy to the Hartree–Fock energy in the; largest basis (cc-pVTZ). cbs() can; either be called directly, as in the first example, or the convenience; syntax of the equivalent second example can be used.; Another very useful and powerful feature of PSI4 is the ability; to compute results on entire databases of molecules at a time,; as provided by the database() wrapper. For example,:; 1database('mp2', 'S22', cp=1, benchmark='S22B'). will perform DF-MP2 counterpoise-corrected interaction energies; (cp=1) on all members of Hobza’s S22 database set of van der Waals; dimers, and then compare the results against the S22B benchmark energies.; Built-in databases include S22, A24, HTBH, HBC6, HSG, S22by5, S66, JSCH,; NCB31, S66by8, and NBC10, among others.; These wrapper functions are discussed separately in; Psithon Functions: Invoking a Calculation. Note that the options documented for Python; functions are placed as arguments in the command that calls the function,; not in the set {...} block or with any other set command. table of contents. Psithon: Structuring an Input File; Physical Constants; Memory Specification; Molecule and Geometry Specification; Job Control Keywords; Basis Sets; PSI Variables; Return Values; Loops; Tables of Results; Python Wrappers. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput.html
https://psicode.org/psi4manual/1.2.1/psithoninput.html:2248,Energy Efficiency,meter,meters,2248,"s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that the user’s ~/.psi4rc values can; override the builtins (in the input file, not in the C++ code).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files. # Do not modify this file! It is auto-generated by the document_options_and_tests; # script, from psi4topdir/psi4/include/psi4/physconst.h; h = 6.62606896E-34 # The Planck constant (Js) ; c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; R = 8.314472 # Universal gas constant (JK$^{-1}$mol$^{-1}$) ; bohr2angstroms = 0.52917720859 # Bohr to Angstroms conversion factor ; bohr2m = 0.52917720859E-10 # Bohr to meters conversion factor ; bohr2cm = 0.52917720859E-8 # Bohr to centimeters conversion factor ; amu2g = 1.660538782E-24 # Atomic mass units to grams conversion factor ; amu2kg = 1.660538782E-27 # Atomic mass units to kg conversion factor ; au2amu = 5.485799097E-4 # Atomic units (m$@@e$) to atomic mass units conversion factor ; hartree2J = 4.359744E-18 # Hartree to joule conversion factor ; hartree2aJ = 4.359744 # Hartree to attojoule (10$^{-18}$J) conversion factor ; cal2J = 4.184 # Calorie to joule conversion factor ; dipmom_au2si = 8.47835281E-30 # Atomic units to SI units (Cm) conversion factor for dipoles ; dipmom_au2debye = 2.54174623 # Atomic units to Debye conversion factor for dipoles ; dipmom_debye2si = 3.335640952E-30 # Debye to SI units (Cm) conversion factor for dipoles ; c_au = 137.035999679 # Speed of light in atomic units ; hartree2ev = 27.21138 # Hartree to eV conversion factor ; hartree2wavenumbers = 219474.6 # Hartree to cm$^{-1}$ conversion factor ; hartree2kcalmol = 627.50",MatchSource.WIKI,psi4manual/1.2.1/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput.html
https://psicode.org/psi4manual/1.2.1/psithoninput.html:2615,Energy Efficiency,joule,joule,2615,"uiltins (in the input file, not in the C++ code).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files. # Do not modify this file! It is auto-generated by the document_options_and_tests; # script, from psi4topdir/psi4/include/psi4/physconst.h; h = 6.62606896E-34 # The Planck constant (Js) ; c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; R = 8.314472 # Universal gas constant (JK$^{-1}$mol$^{-1}$) ; bohr2angstroms = 0.52917720859 # Bohr to Angstroms conversion factor ; bohr2m = 0.52917720859E-10 # Bohr to meters conversion factor ; bohr2cm = 0.52917720859E-8 # Bohr to centimeters conversion factor ; amu2g = 1.660538782E-24 # Atomic mass units to grams conversion factor ; amu2kg = 1.660538782E-27 # Atomic mass units to kg conversion factor ; au2amu = 5.485799097E-4 # Atomic units (m$@@e$) to atomic mass units conversion factor ; hartree2J = 4.359744E-18 # Hartree to joule conversion factor ; hartree2aJ = 4.359744 # Hartree to attojoule (10$^{-18}$J) conversion factor ; cal2J = 4.184 # Calorie to joule conversion factor ; dipmom_au2si = 8.47835281E-30 # Atomic units to SI units (Cm) conversion factor for dipoles ; dipmom_au2debye = 2.54174623 # Atomic units to Debye conversion factor for dipoles ; dipmom_debye2si = 3.335640952E-30 # Debye to SI units (Cm) conversion factor for dipoles ; c_au = 137.035999679 # Speed of light in atomic units ; hartree2ev = 27.21138 # Hartree to eV conversion factor ; hartree2wavenumbers = 219474.6 # Hartree to cm$^{-1}$ conversion factor ; hartree2kcalmol = 627.5095 # Hartree to kcal mol$^{-1}$ conversion factor ; hartree2kJmol = 2625.500 # Hartree to kilojoule mol$^{-1}$ conversion factor ; hartree2MHz = 6.579684E9 # Hartree to MHz conversion factor ; kcalmol2wavenumbers = 349.7551 # kcal mol$^{-1}$ to cm$^{-1}$ conversion factor ; e0 = 8.854187817E-12 # Vacuum permittivity (Fm$^{-1}$) ; na = 6.02214179E23 # Avagadro's numbe",MatchSource.WIKI,psi4manual/1.2.1/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput.html
https://psicode.org/psi4manual/1.2.1/psithoninput.html:2747,Energy Efficiency,joule,joule,2747,"n all PSI4 input files. # Do not modify this file! It is auto-generated by the document_options_and_tests; # script, from psi4topdir/psi4/include/psi4/physconst.h; h = 6.62606896E-34 # The Planck constant (Js) ; c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; R = 8.314472 # Universal gas constant (JK$^{-1}$mol$^{-1}$) ; bohr2angstroms = 0.52917720859 # Bohr to Angstroms conversion factor ; bohr2m = 0.52917720859E-10 # Bohr to meters conversion factor ; bohr2cm = 0.52917720859E-8 # Bohr to centimeters conversion factor ; amu2g = 1.660538782E-24 # Atomic mass units to grams conversion factor ; amu2kg = 1.660538782E-27 # Atomic mass units to kg conversion factor ; au2amu = 5.485799097E-4 # Atomic units (m$@@e$) to atomic mass units conversion factor ; hartree2J = 4.359744E-18 # Hartree to joule conversion factor ; hartree2aJ = 4.359744 # Hartree to attojoule (10$^{-18}$J) conversion factor ; cal2J = 4.184 # Calorie to joule conversion factor ; dipmom_au2si = 8.47835281E-30 # Atomic units to SI units (Cm) conversion factor for dipoles ; dipmom_au2debye = 2.54174623 # Atomic units to Debye conversion factor for dipoles ; dipmom_debye2si = 3.335640952E-30 # Debye to SI units (Cm) conversion factor for dipoles ; c_au = 137.035999679 # Speed of light in atomic units ; hartree2ev = 27.21138 # Hartree to eV conversion factor ; hartree2wavenumbers = 219474.6 # Hartree to cm$^{-1}$ conversion factor ; hartree2kcalmol = 627.5095 # Hartree to kcal mol$^{-1}$ conversion factor ; hartree2kJmol = 2625.500 # Hartree to kilojoule mol$^{-1}$ conversion factor ; hartree2MHz = 6.579684E9 # Hartree to MHz conversion factor ; kcalmol2wavenumbers = 349.7551 # kcal mol$^{-1}$ to cm$^{-1}$ conversion factor ; e0 = 8.854187817E-12 # Vacuum permittivity (Fm$^{-1}$) ; na = 6.02214179E23 # Avagadro's number ; me = 9.10938215E-31 # Electron rest mass (in kg) . In Psithon input files, prepend physical constants with psi_ to; prevent clashes ",MatchSource.WIKI,psi4manual/1.2.1/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput.html
https://psicode.org/psi4manual/1.2.1/psithoninput.html:7844,Energy Efficiency,energy,energy,7844,"lack of quotes around cc-pVDZ, even though it is a string. The; Psithon preprocessor automatically wraps any string values in set commands in; strings. The last three examples provide a more convenient way for specifying; multiple keywords:; 1; 2; 3; 4; 5set {; basis = cc-pVDZ; print = 1; reference = rhf; }. For arguments that require an array input, standard Python list syntax should; be used, viz.:; 1; 2; 3set {; docc = [3, 0, 1, 1]; }. List/matrix inputs may span multiple lines, as long as the opening [ is; on the same line as the name of the keyword.; Any of the above keyword specifications can be scoped to individual modules,; by adding the name of the module after the set keyword. Omitting the module; name, or using the name global or globals will result in the keyword being; applied to all modules. For example, in the following input; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13molecule{; o; h 1 roh; h 1 roh 2 ahoh. roh = 0.957; ahoh = 104.5; }. set basis cc-pVDZ; set ccenergy print 3; set scf print 1; energy('ccsd'). the basis set is set to cc-pVDZ throughout, the SCF code will have a print; level of 1 and the ccenergy code, which performs coupled cluster computations,; will use a print level of 3. In this example a full CCSD computation is; performed by running the SCF code first, then the coupled cluster modules;; the energy() Python helper function ensures that this is performed correctly.; Note that the Python interpreter executes commands in the order they appear in; the input file, so if the last four commands in the above example were to read; 1; 2; 3; 4set basis cc-pVDZ; energy('ccsd'); set ccenergy print 3; set scf print 1. the commands that set the print level would be ineffective, as they would be; processed after the CCSD computation completes.; In PsiAPI mode, one can use commands set_options() and; set_module_options() like below. Note that these values; should be of correct type, strings for strings, floats for floats like; convergences. The func",MatchSource.WIKI,psi4manual/1.2.1/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput.html
https://psicode.org/psi4manual/1.2.1/psithoninput.html:8169,Energy Efficiency,energy,energy,8169,"ts that require an array input, standard Python list syntax should; be used, viz.:; 1; 2; 3set {; docc = [3, 0, 1, 1]; }. List/matrix inputs may span multiple lines, as long as the opening [ is; on the same line as the name of the keyword.; Any of the above keyword specifications can be scoped to individual modules,; by adding the name of the module after the set keyword. Omitting the module; name, or using the name global or globals will result in the keyword being; applied to all modules. For example, in the following input; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13molecule{; o; h 1 roh; h 1 roh 2 ahoh. roh = 0.957; ahoh = 104.5; }. set basis cc-pVDZ; set ccenergy print 3; set scf print 1; energy('ccsd'). the basis set is set to cc-pVDZ throughout, the SCF code will have a print; level of 1 and the ccenergy code, which performs coupled cluster computations,; will use a print level of 3. In this example a full CCSD computation is; performed by running the SCF code first, then the coupled cluster modules;; the energy() Python helper function ensures that this is performed correctly.; Note that the Python interpreter executes commands in the order they appear in; the input file, so if the last four commands in the above example were to read; 1; 2; 3; 4set basis cc-pVDZ; energy('ccsd'); set ccenergy print 3; set scf print 1. the commands that set the print level would be ineffective, as they would be; processed after the CCSD computation completes.; In PsiAPI mode, one can use commands set_options() and; set_module_options() like below. Note that these values; should be of correct type, strings for strings, floats for floats like; convergences. The function ~psi4.core.clean_options that reinitializes; all options may also be useful to separate calculations in a PsiAPI; session.; 1; 2; 3; 4; 5; 6; 7; 8; 9psi4.set_options({; 'scf_type': 'pk',; 'e_convergence': 1.e-5,; 'soscf': True; }). psi4.set_module_options({; 'geom_maxiter': 50; }). Basis Sets¶. Basis Sets; Built-In",MatchSource.WIKI,psi4manual/1.2.1/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput.html
https://psicode.org/psi4manual/1.2.1/psithoninput.html:8433,Energy Efficiency,energy,energy,8433,"me of the keyword.; Any of the above keyword specifications can be scoped to individual modules,; by adding the name of the module after the set keyword. Omitting the module; name, or using the name global or globals will result in the keyword being; applied to all modules. For example, in the following input; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13molecule{; o; h 1 roh; h 1 roh 2 ahoh. roh = 0.957; ahoh = 104.5; }. set basis cc-pVDZ; set ccenergy print 3; set scf print 1; energy('ccsd'). the basis set is set to cc-pVDZ throughout, the SCF code will have a print; level of 1 and the ccenergy code, which performs coupled cluster computations,; will use a print level of 3. In this example a full CCSD computation is; performed by running the SCF code first, then the coupled cluster modules;; the energy() Python helper function ensures that this is performed correctly.; Note that the Python interpreter executes commands in the order they appear in; the input file, so if the last four commands in the above example were to read; 1; 2; 3; 4set basis cc-pVDZ; energy('ccsd'); set ccenergy print 3; set scf print 1. the commands that set the print level would be ineffective, as they would be; processed after the CCSD computation completes.; In PsiAPI mode, one can use commands set_options() and; set_module_options() like below. Note that these values; should be of correct type, strings for strings, floats for floats like; convergences. The function ~psi4.core.clean_options that reinitializes; all options may also be useful to separate calculations in a PsiAPI; session.; 1; 2; 3; 4; 5; 6; 7; 8; 9psi4.set_options({; 'scf_type': 'pk',; 'e_convergence': 1.e-5,; 'soscf': True; }). psi4.set_module_options({; 'geom_maxiter': 50; }). Basis Sets¶. Basis Sets; Built-In Basis Sets; Mixing Basis Sets; Decontracted Basis Sets; User-Defined Basis Sets; Inputting effective core potentials (ECPs). PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results; of each c",MatchSource.WIKI,psi4manual/1.2.1/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput.html
https://psicode.org/psi4manual/1.2.1/psithoninput.html:9300,Energy Efficiency,power,power,9300,"last four commands in the above example were to read; 1; 2; 3; 4set basis cc-pVDZ; energy('ccsd'); set ccenergy print 3; set scf print 1. the commands that set the print level would be ineffective, as they would be; processed after the CCSD computation completes.; In PsiAPI mode, one can use commands set_options() and; set_module_options() like below. Note that these values; should be of correct type, strings for strings, floats for floats like; convergences. The function ~psi4.core.clean_options that reinitializes; all options may also be useful to separate calculations in a PsiAPI; session.; 1; 2; 3; 4; 5; 6; 7; 8; 9psi4.set_options({; 'scf_type': 'pk',; 'e_convergence': 1.e-5,; 'soscf': True; }). psi4.set_module_options({; 'geom_maxiter': 50; }). Basis Sets¶. Basis Sets; Built-In Basis Sets; Mixing Basis Sets; Decontracted Basis Sets; User-Defined Basis Sets; Inputting effective core potentials (ECPs). PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results; of each computation available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of; H2 and H atom:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19molecule h2 {; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h {; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol * (2*h_energy - h2_energy); print ""De=%f"" % D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module, and PSI Variables by Alpha defines them. These can be; accessed through the get_variable() function. For example",MatchSource.WIKI,psi4manual/1.2.1/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput.html
https://psicode.org/psi4manual/1.2.1/psithoninput.html:9653,Energy Efficiency,energy,energy,9653," can use commands set_options() and; set_module_options() like below. Note that these values; should be of correct type, strings for strings, floats for floats like; convergences. The function ~psi4.core.clean_options that reinitializes; all options may also be useful to separate calculations in a PsiAPI; session.; 1; 2; 3; 4; 5; 6; 7; 8; 9psi4.set_options({; 'scf_type': 'pk',; 'e_convergence': 1.e-5,; 'soscf': True; }). psi4.set_module_options({; 'geom_maxiter': 50; }). Basis Sets¶. Basis Sets; Built-In Basis Sets; Mixing Basis Sets; Decontracted Basis Sets; User-Defined Basis Sets; Inputting effective core potentials (ECPs). PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results; of each computation available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of; H2 and H atom:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19molecule h2 {; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h {; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol * (2*h_energy - h2_energy); print ""De=%f"" % D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module, and PSI Variables by Alpha defines them. These can be; accessed through the get_variable() function. For example, after; performing a density fitted MP2 computation, both the spin component; scaled energy and the unscaled MP2 energy are made available:; 1; 2e_mp2 = get_variable('MP2 TOTAL ENERGY'); e_scs_mp2 = get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI vari",MatchSource.WIKI,psi4manual/1.2.1/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput.html
https://psicode.org/psi4manual/1.2.1/psithoninput.html:9737,Energy Efficiency,energy,energy,9737," values; should be of correct type, strings for strings, floats for floats like; convergences. The function ~psi4.core.clean_options that reinitializes; all options may also be useful to separate calculations in a PsiAPI; session.; 1; 2; 3; 4; 5; 6; 7; 8; 9psi4.set_options({; 'scf_type': 'pk',; 'e_convergence': 1.e-5,; 'soscf': True; }). psi4.set_module_options({; 'geom_maxiter': 50; }). Basis Sets¶. Basis Sets; Built-In Basis Sets; Mixing Basis Sets; Decontracted Basis Sets; User-Defined Basis Sets; Inputting effective core potentials (ECPs). PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results; of each computation available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of; H2 and H atom:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19molecule h2 {; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h {; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol * (2*h_energy - h2_energy); print ""De=%f"" % D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module, and PSI Variables by Alpha defines them. These can be; accessed through the get_variable() function. For example, after; performing a density fitted MP2 computation, both the spin component; scaled energy and the unscaled MP2 energy are made available:; 1; 2e_mp2 = get_variable('MP2 TOTAL ENERGY'); e_scs_mp2 = get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the ou",MatchSource.WIKI,psi4manual/1.2.1/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput.html
https://psicode.org/psi4manual/1.2.1/psithoninput.html:9831,Energy Efficiency,energy,energy,9831,"ful to separate calculations in a PsiAPI; session.; 1; 2; 3; 4; 5; 6; 7; 8; 9psi4.set_options({; 'scf_type': 'pk',; 'e_convergence': 1.e-5,; 'soscf': True; }). psi4.set_module_options({; 'geom_maxiter': 50; }). Basis Sets¶. Basis Sets; Built-In Basis Sets; Mixing Basis Sets; Decontracted Basis Sets; User-Defined Basis Sets; Inputting effective core potentials (ECPs). PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results; of each computation available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of; H2 and H atom:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19molecule h2 {; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h {; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol * (2*h_energy - h2_energy); print ""De=%f"" % D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module, and PSI Variables by Alpha defines them. These can be; accessed through the get_variable() function. For example, after; performing a density fitted MP2 computation, both the spin component; scaled energy and the unscaled MP2 energy are made available:; 1; 2e_mp2 = get_variable('MP2 TOTAL ENERGY'); e_scs_mp2 = get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; are cleared at the start of each energy(), etc. in an input; file by clean_variables().; So if you",MatchSource.WIKI,psi4manual/1.2.1/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput.html
https://psicode.org/psi4manual/1.2.1/psithoninput.html:9915,Energy Efficiency,energy,energy,9915,"ful to separate calculations in a PsiAPI; session.; 1; 2; 3; 4; 5; 6; 7; 8; 9psi4.set_options({; 'scf_type': 'pk',; 'e_convergence': 1.e-5,; 'soscf': True; }). psi4.set_module_options({; 'geom_maxiter': 50; }). Basis Sets¶. Basis Sets; Built-In Basis Sets; Mixing Basis Sets; Decontracted Basis Sets; User-Defined Basis Sets; Inputting effective core potentials (ECPs). PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results; of each computation available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of; H2 and H atom:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19molecule h2 {; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h {; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol * (2*h_energy - h2_energy); print ""De=%f"" % D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module, and PSI Variables by Alpha defines them. These can be; accessed through the get_variable() function. For example, after; performing a density fitted MP2 computation, both the spin component; scaled energy and the unscaled MP2 energy are made available:; 1; 2e_mp2 = get_variable('MP2 TOTAL ENERGY'); e_scs_mp2 = get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; are cleared at the start of each energy(), etc. in an input; file by clean_variables().; So if you",MatchSource.WIKI,psi4manual/1.2.1/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput.html
https://psicode.org/psi4manual/1.2.1/psithoninput.html:10029,Energy Efficiency,energy,energy,10029,"-5,; 'soscf': True; }). psi4.set_module_options({; 'geom_maxiter': 50; }). Basis Sets¶. Basis Sets; Built-In Basis Sets; Mixing Basis Sets; Decontracted Basis Sets; User-Defined Basis Sets; Inputting effective core potentials (ECPs). PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results; of each computation available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of; H2 and H atom:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19molecule h2 {; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h {; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol * (2*h_energy - h2_energy); print ""De=%f"" % D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module, and PSI Variables by Alpha defines them. These can be; accessed through the get_variable() function. For example, after; performing a density fitted MP2 computation, both the spin component; scaled energy and the unscaled MP2 energy are made available:; 1; 2e_mp2 = get_variable('MP2 TOTAL ENERGY'); e_scs_mp2 = get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; are cleared at the start of each energy(), etc. in an input; file by clean_variables().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the; last will include ",MatchSource.WIKI,psi4manual/1.2.1/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput.html
https://psicode.org/psi4manual/1.2.1/psithoninput.html:10437,Energy Efficiency,energy,energy,10437,"ish the previous example of; H2 and H atom:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19molecule h2 {; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h {; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol * (2*h_energy - h2_energy); print ""De=%f"" % D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module, and PSI Variables by Alpha defines them. These can be; accessed through the get_variable() function. For example, after; performing a density fitted MP2 computation, both the spin component; scaled energy and the unscaled MP2 energy are made available:; 1; 2e_mp2 = get_variable('MP2 TOTAL ENERGY'); e_scs_mp2 = get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; are cleared at the start of each energy(), etc. in an input; file by clean_variables().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the; last will include SCF TOTAL ENERGY but not; FCI TOTAL ENERGY.; The entire dictionary of PSI variables can be obtained through; get_variables(). Return Values¶; Most of the usual user computation functions (i.e.,; energy(), optimize(), and; frequency()) return simply the current total energy.; Consult the descriptions of other functions in Psithon Functions: Invoking a Calculation for; what quantities they return and for what data structures t",MatchSource.WIKI,psi4manual/1.2.1/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput.html
https://psicode.org/psi4manual/1.2.1/psithoninput.html:10465,Energy Efficiency,energy,energy,10465,"ish the previous example of; H2 and H atom:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19molecule h2 {; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h {; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol * (2*h_energy - h2_energy); print ""De=%f"" % D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module, and PSI Variables by Alpha defines them. These can be; accessed through the get_variable() function. For example, after; performing a density fitted MP2 computation, both the spin component; scaled energy and the unscaled MP2 energy are made available:; 1; 2e_mp2 = get_variable('MP2 TOTAL ENERGY'); e_scs_mp2 = get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; are cleared at the start of each energy(), etc. in an input; file by clean_variables().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the; last will include SCF TOTAL ENERGY but not; FCI TOTAL ENERGY.; The entire dictionary of PSI variables can be obtained through; get_variables(). Return Values¶; Most of the usual user computation functions (i.e.,; energy(), optimize(), and; frequency()) return simply the current total energy.; Consult the descriptions of other functions in Psithon Functions: Invoking a Calculation for; what quantities they return and for what data structures t",MatchSource.WIKI,psi4manual/1.2.1/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput.html
https://psicode.org/psi4manual/1.2.1/psithoninput.html:10835,Energy Efficiency,energy,energy,10835,"""De=%f"" % D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module, and PSI Variables by Alpha defines them. These can be; accessed through the get_variable() function. For example, after; performing a density fitted MP2 computation, both the spin component; scaled energy and the unscaled MP2 energy are made available:; 1; 2e_mp2 = get_variable('MP2 TOTAL ENERGY'); e_scs_mp2 = get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; are cleared at the start of each energy(), etc. in an input; file by clean_variables().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the; last will include SCF TOTAL ENERGY but not; FCI TOTAL ENERGY.; The entire dictionary of PSI variables can be obtained through; get_variables(). Return Values¶; Most of the usual user computation functions (i.e.,; energy(), optimize(), and; frequency()) return simply the current total energy.; Consult the descriptions of other functions in Psithon Functions: Invoking a Calculation for; what quantities they return and for what data structures they make; available for post-processing. Many users need only deal with the simple return; form for the computation functions.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11# E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = energy(...); E = optimize(...); E = f",MatchSource.WIKI,psi4manual/1.2.1/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput.html
https://psicode.org/psi4manual/1.2.1/psithoninput.html:11231,Energy Efficiency,energy,energy,11231,"ines them. These can be; accessed through the get_variable() function. For example, after; performing a density fitted MP2 computation, both the spin component; scaled energy and the unscaled MP2 energy are made available:; 1; 2e_mp2 = get_variable('MP2 TOTAL ENERGY'); e_scs_mp2 = get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; are cleared at the start of each energy(), etc. in an input; file by clean_variables().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the; last will include SCF TOTAL ENERGY but not; FCI TOTAL ENERGY.; The entire dictionary of PSI variables can be obtained through; get_variables(). Return Values¶; Most of the usual user computation functions (i.e.,; energy(), optimize(), and; frequency()) return simply the current total energy.; Consult the descriptions of other functions in Psithon Functions: Invoking a Calculation for; what quantities they return and for what data structures they make; available for post-processing. Many users need only deal with the simple return; form for the computation functions.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11# E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = energy(...); E = optimize(...); E = frequency(...); G = gradient(...) # used by optimize(); H = hessian(...) # used by frequency(). For more elaborate post-processing of computations, adding; return_wfn=True keyword argument additionally returns; Wavefunction.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16# power user returns; E, wfn = energy(..., return_wfn=True); E, wfn = optimize(..., return_wfn=True); E, wfn = frequency(..., return_wfn=True); G, wfn = gradient(..., return_wfn=",MatchSource.WIKI,psi4manual/1.2.1/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput.html
https://psicode.org/psi4manual/1.2.1/psithoninput.html:11303,Energy Efficiency,energy,energy,11303,"ines them. These can be; accessed through the get_variable() function. For example, after; performing a density fitted MP2 computation, both the spin component; scaled energy and the unscaled MP2 energy are made available:; 1; 2e_mp2 = get_variable('MP2 TOTAL ENERGY'); e_scs_mp2 = get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; are cleared at the start of each energy(), etc. in an input; file by clean_variables().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the; last will include SCF TOTAL ENERGY but not; FCI TOTAL ENERGY.; The entire dictionary of PSI variables can be obtained through; get_variables(). Return Values¶; Most of the usual user computation functions (i.e.,; energy(), optimize(), and; frequency()) return simply the current total energy.; Consult the descriptions of other functions in Psithon Functions: Invoking a Calculation for; what quantities they return and for what data structures they make; available for post-processing. Many users need only deal with the simple return; form for the computation functions.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11# E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = energy(...); E = optimize(...); E = frequency(...); G = gradient(...) # used by optimize(); H = hessian(...) # used by frequency(). For more elaborate post-processing of computations, adding; return_wfn=True keyword argument additionally returns; Wavefunction.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16# power user returns; E, wfn = energy(..., return_wfn=True); E, wfn = optimize(..., return_wfn=True); E, wfn = frequency(..., return_wfn=True); G, wfn = gradient(..., return_wfn=",MatchSource.WIKI,psi4manual/1.2.1/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput.html
https://psicode.org/psi4manual/1.2.1/psithoninput.html:11638,Energy Efficiency,energy,energy,11638,"ion. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; are cleared at the start of each energy(), etc. in an input; file by clean_variables().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the; last will include SCF TOTAL ENERGY but not; FCI TOTAL ENERGY.; The entire dictionary of PSI variables can be obtained through; get_variables(). Return Values¶; Most of the usual user computation functions (i.e.,; energy(), optimize(), and; frequency()) return simply the current total energy.; Consult the descriptions of other functions in Psithon Functions: Invoking a Calculation for; what quantities they return and for what data structures they make; available for post-processing. Many users need only deal with the simple return; form for the computation functions.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11# E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = energy(...); E = optimize(...); E = frequency(...); G = gradient(...) # used by optimize(); H = hessian(...) # used by frequency(). For more elaborate post-processing of computations, adding; return_wfn=True keyword argument additionally returns; Wavefunction.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16# power user returns; E, wfn = energy(..., return_wfn=True); E, wfn = optimize(..., return_wfn=True); E, wfn = frequency(..., return_wfn=True); G, wfn = gradient(..., return_wfn=True) # used by optimize(); H, wfn = hessian(..., return_wfn=True) # used by frequency(). # print gradient array and its rms; wfn.gradient.print_out(); print wfn.gradient().rms(). # format output for other programs; molden(wfn, 'mycalc.molden'). # access array in another format; np.array(wfn.hessian()). Loops¶; Python provides many control structures, any of which can be used within PSI4; input files",MatchSource.WIKI,psi4manual/1.2.1/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput.html
https://psicode.org/psi4manual/1.2.1/psithoninput.html:11776,Energy Efficiency,energy,energy,11776,"ables(). Note that PSI variables; are cleared at the start of each energy(), etc. in an input; file by clean_variables().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the; last will include SCF TOTAL ENERGY but not; FCI TOTAL ENERGY.; The entire dictionary of PSI variables can be obtained through; get_variables(). Return Values¶; Most of the usual user computation functions (i.e.,; energy(), optimize(), and; frequency()) return simply the current total energy.; Consult the descriptions of other functions in Psithon Functions: Invoking a Calculation for; what quantities they return and for what data structures they make; available for post-processing. Many users need only deal with the simple return; form for the computation functions.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11# E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = energy(...); E = optimize(...); E = frequency(...); G = gradient(...) # used by optimize(); H = hessian(...) # used by frequency(). For more elaborate post-processing of computations, adding; return_wfn=True keyword argument additionally returns; Wavefunction.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16# power user returns; E, wfn = energy(..., return_wfn=True); E, wfn = optimize(..., return_wfn=True); E, wfn = frequency(..., return_wfn=True); G, wfn = gradient(..., return_wfn=True) # used by optimize(); H, wfn = hessian(..., return_wfn=True) # used by frequency(). # print gradient array and its rms; wfn.gradient.print_out(); print wfn.gradient().rms(). # format output for other programs; molden(wfn, 'mycalc.molden'). # access array in another format; np.array(wfn.hessian()). Loops¶; Python provides many control structures, any of which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; 1; 2; 3; 4basis_s",MatchSource.WIKI,psi4manual/1.2.1/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput.html
https://psicode.org/psi4manual/1.2.1/psithoninput.html:12093,Energy Efficiency,power,power,12093,"e entire dictionary of PSI variables can be obtained through; get_variables(). Return Values¶; Most of the usual user computation functions (i.e.,; energy(), optimize(), and; frequency()) return simply the current total energy.; Consult the descriptions of other functions in Psithon Functions: Invoking a Calculation for; what quantities they return and for what data structures they make; available for post-processing. Many users need only deal with the simple return; form for the computation functions.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11# E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = energy(...); E = optimize(...); E = frequency(...); G = gradient(...) # used by optimize(); H = hessian(...) # used by frequency(). For more elaborate post-processing of computations, adding; return_wfn=True keyword argument additionally returns; Wavefunction.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16# power user returns; E, wfn = energy(..., return_wfn=True); E, wfn = optimize(..., return_wfn=True); E, wfn = frequency(..., return_wfn=True); G, wfn = gradient(..., return_wfn=True) # used by optimize(); H, wfn = hessian(..., return_wfn=True) # used by frequency(). # print gradient array and its rms; wfn.gradient.print_out(); print wfn.gradient().rms(). # format output for other programs; molden(wfn, 'mycalc.molden'). # access array in another format; np.array(wfn.hessian()). Loops¶; Python provides many control structures, any of which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; 1; 2; 3; 4basis_sets = [""cc-pVDZ"", ""cc-pVTZ"", ""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_sets is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to t",MatchSource.WIKI,psi4manual/1.2.1/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput.html
https://psicode.org/psi4manual/1.2.1/psithoninput.html:12122,Energy Efficiency,energy,energy,12122,"e entire dictionary of PSI variables can be obtained through; get_variables(). Return Values¶; Most of the usual user computation functions (i.e.,; energy(), optimize(), and; frequency()) return simply the current total energy.; Consult the descriptions of other functions in Psithon Functions: Invoking a Calculation for; what quantities they return and for what data structures they make; available for post-processing. Many users need only deal with the simple return; form for the computation functions.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11# E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = energy(...); E = optimize(...); E = frequency(...); G = gradient(...) # used by optimize(); H = hessian(...) # used by frequency(). For more elaborate post-processing of computations, adding; return_wfn=True keyword argument additionally returns; Wavefunction.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16# power user returns; E, wfn = energy(..., return_wfn=True); E, wfn = optimize(..., return_wfn=True); E, wfn = frequency(..., return_wfn=True); G, wfn = gradient(..., return_wfn=True) # used by optimize(); H, wfn = hessian(..., return_wfn=True) # used by frequency(). # print gradient array and its rms; wfn.gradient.print_out(); print wfn.gradient().rms(). # format output for other programs; molden(wfn, 'mycalc.molden'). # access array in another format; np.array(wfn.hessian()). Loops¶; Python provides many control structures, any of which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; 1; 2; 3; 4basis_sets = [""cc-pVDZ"", ""cc-pVTZ"", ""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_sets is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to t",MatchSource.WIKI,psi4manual/1.2.1/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput.html
https://psicode.org/psi4manual/1.2.1/psithoninput.html:12864,Energy Efficiency,energy,energy,12864," energy(...); E = optimize(...); E = frequency(...); G = gradient(...) # used by optimize(); H = hessian(...) # used by frequency(). For more elaborate post-processing of computations, adding; return_wfn=True keyword argument additionally returns; Wavefunction.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16# power user returns; E, wfn = energy(..., return_wfn=True); E, wfn = optimize(..., return_wfn=True); E, wfn = frequency(..., return_wfn=True); G, wfn = gradient(..., return_wfn=True) # used by optimize(); H, wfn = hessian(..., return_wfn=True) # used by frequency(). # print gradient array and its rms; wfn.gradient.print_out(); print wfn.gradient().rms(). # format output for other programs; molden(wfn, 'mycalc.molden'). # access array in another format; np.array(wfn.hessian()). Loops¶; Python provides many control structures, any of which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; 1; 2; 3; 4basis_sets = [""cc-pVDZ"", ""cc-pVTZ"", ""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_sets is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign.; The geometry specification supports delayed initialization of variable,; which permits potential energy scans. As an example, we can scan both the; angle and bond length in water:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16molecule h2o{; O; H 1 R; H 1 R 2 A; }. Rvals = [0.9, 1.0, 1.1]; Avals = range(102, 106, 2). set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). The declarations of Rvals and Avals are both completely standard Python syntax.; Having named our molecule h2o we can then set the values of R and A within",MatchSource.WIKI,psi4manual/1.2.1/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput.html
https://psicode.org/psi4manual/1.2.1/psithoninput.html:13276,Energy Efficiency,energy,energy,13276,"; G, wfn = gradient(..., return_wfn=True) # used by optimize(); H, wfn = hessian(..., return_wfn=True) # used by frequency(). # print gradient array and its rms; wfn.gradient.print_out(); print wfn.gradient().rms(). # format output for other programs; molden(wfn, 'mycalc.molden'). # access array in another format; np.array(wfn.hessian()). Loops¶; Python provides many control structures, any of which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; 1; 2; 3; 4basis_sets = [""cc-pVDZ"", ""cc-pVTZ"", ""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_sets is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign.; The geometry specification supports delayed initialization of variable,; which permits potential energy scans. As an example, we can scan both the; angle and bond length in water:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16molecule h2o{; O; H 1 R; H 1 R 2 A; }. Rvals = [0.9, 1.0, 1.1]; Avals = range(102, 106, 2). set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). The declarations of Rvals and Avals are both completely standard Python syntax.; Having named our molecule h2o we can then set the values of R and A within; the loops. Note that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the set keyword.; Cartesian geometries, because of details of the geometry update process,; need to be specified within the loop(s) along with their basis set when; geometry scans are performed. See scf4 for analogous Z-matrix; and Cartiesian scans. Tables of Results¶; The results of computations c",MatchSource.WIKI,psi4manual/1.2.1/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput.html
https://psicode.org/psi4manual/1.2.1/psithoninput.html:13606,Energy Efficiency,energy,energy,13606,"l structures, any of which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; 1; 2; 3; 4basis_sets = [""cc-pVDZ"", ""cc-pVTZ"", ""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_sets is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign.; The geometry specification supports delayed initialization of variable,; which permits potential energy scans. As an example, we can scan both the; angle and bond length in water:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16molecule h2o{; O; H 1 R; H 1 R 2 A; }. Rvals = [0.9, 1.0, 1.1]; Avals = range(102, 106, 2). set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). The declarations of Rvals and Avals are both completely standard Python syntax.; Having named our molecule h2o we can then set the values of R and A within; the loops. Note that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the set keyword.; Cartesian geometries, because of details of the geometry update process,; need to be specified within the loop(s) along with their basis set when; geometry scans are performed. See scf4 for analogous Z-matrix; and Cartiesian scans. Tables of Results¶; The results of computations can be compactly tabulated with the Table() Psithon; function. For example, in the following potential energy surface scan for water; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27molecule h2o {; O; H 1 R; H 1 R 2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(100,102,2). table=Table(rows=[""R"",""A""], cols=[""E(SCF)"",""E(SCS)"",""E(DFMP2)""",MatchSource.WIKI,psi4manual/1.2.1/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput.html
https://psicode.org/psi4manual/1.2.1/psithoninput.html:14335,Energy Efficiency,energy,energy,14335," 13; 14; 15; 16molecule h2o{; O; H 1 R; H 1 R 2 A; }. Rvals = [0.9, 1.0, 1.1]; Avals = range(102, 106, 2). set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). The declarations of Rvals and Avals are both completely standard Python syntax.; Having named our molecule h2o we can then set the values of R and A within; the loops. Note that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the set keyword.; Cartesian geometries, because of details of the geometry update process,; need to be specified within the loop(s) along with their basis set when; geometry scans are performed. See scf4 for analogous Z-matrix; and Cartiesian scans. Tables of Results¶; The results of computations can be compactly tabulated with the Table() Psithon; function. For example, in the following potential energy surface scan for water; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27molecule h2o {; O; H 1 R; H 1 R 2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(100,102,2). table=Table(rows=[""R"",""A""], cols=[""E(SCF)"",""E(SCS)"",""E(DFMP2)""]). set basis cc-pvdz. for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('mp2'); escf = get_variable('SCF TOTAL ENERGY'); edfmp2 = get_variable('MP2 TOTAL ENERGY'); escsmp2 = get_variable('SCS-MP2 TOTAL ENERGY'); table[R][A] = [escf, escsmp2, edfmp2]. print table; relative=table.copy(); relative.absolute_to_relative(); print relative. we first define a table (on line 10) with two row indices and three column; indices. As the potential energy scan is performed, the results are stored; (line 22) and the final table is printed to the output file (line 24). The; table is converted from absolute energies to relative energies (in kcal mol-1); on line 26, before being printed again. The relative energies are reported with; respect to the lowest value in each column. More ",MatchSource.WIKI,psi4manual/1.2.1/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput.html
https://psicode.org/psi4manual/1.2.1/psithoninput.html:14689,Energy Efficiency,energy,energy,14689,"the loops. Note that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the set keyword.; Cartesian geometries, because of details of the geometry update process,; need to be specified within the loop(s) along with their basis set when; geometry scans are performed. See scf4 for analogous Z-matrix; and Cartiesian scans. Tables of Results¶; The results of computations can be compactly tabulated with the Table() Psithon; function. For example, in the following potential energy surface scan for water; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27molecule h2o {; O; H 1 R; H 1 R 2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(100,102,2). table=Table(rows=[""R"",""A""], cols=[""E(SCF)"",""E(SCS)"",""E(DFMP2)""]). set basis cc-pvdz. for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('mp2'); escf = get_variable('SCF TOTAL ENERGY'); edfmp2 = get_variable('MP2 TOTAL ENERGY'); escsmp2 = get_variable('SCS-MP2 TOTAL ENERGY'); table[R][A] = [escf, escsmp2, edfmp2]. print table; relative=table.copy(); relative.absolute_to_relative(); print relative. we first define a table (on line 10) with two row indices and three column; indices. As the potential energy scan is performed, the results are stored; (line 22) and the final table is printed to the output file (line 24). The; table is converted from absolute energies to relative energies (in kcal mol-1); on line 26, before being printed again. The relative energies are reported with; respect to the lowest value in each column. More examples of how to control the; formatting of the tables can be found in the sample input files provided; see; Appendix Test Suite and Sample Inputs for a complete listing. Python Wrappers¶; The Python foundations of the PSI4 driver and Psithon syntax permit; many commonly performed post-processing procedures to be integrated into; the PSI4 suite.; As seen in the neon dimer exa",MatchSource.WIKI,psi4manual/1.2.1/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput.html
https://psicode.org/psi4manual/1.2.1/psithoninput.html:15062,Energy Efficiency,energy,energy,15062," are performed. See scf4 for analogous Z-matrix; and Cartiesian scans. Tables of Results¶; The results of computations can be compactly tabulated with the Table() Psithon; function. For example, in the following potential energy surface scan for water; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27molecule h2o {; O; H 1 R; H 1 R 2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(100,102,2). table=Table(rows=[""R"",""A""], cols=[""E(SCF)"",""E(SCS)"",""E(DFMP2)""]). set basis cc-pvdz. for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('mp2'); escf = get_variable('SCF TOTAL ENERGY'); edfmp2 = get_variable('MP2 TOTAL ENERGY'); escsmp2 = get_variable('SCS-MP2 TOTAL ENERGY'); table[R][A] = [escf, escsmp2, edfmp2]. print table; relative=table.copy(); relative.absolute_to_relative(); print relative. we first define a table (on line 10) with two row indices and three column; indices. As the potential energy scan is performed, the results are stored; (line 22) and the final table is printed to the output file (line 24). The; table is converted from absolute energies to relative energies (in kcal mol-1); on line 26, before being printed again. The relative energies are reported with; respect to the lowest value in each column. More examples of how to control the; formatting of the tables can be found in the sample input files provided; see; Appendix Test Suite and Sample Inputs for a complete listing. Python Wrappers¶; The Python foundations of the PSI4 driver and Psithon syntax permit; many commonly performed post-processing procedures to be integrated into; the PSI4 suite.; As seen in the neon dimer example from the tutorial section,; the nbody_gufunc() wrapper provides automatic computation of; counterpoise-corrected interaction energies between two molecules. For; example,; 1energy('mp2', bsse_type='cp'). will compute the counterpoise-corrected density-fitted MP2 interaction energy; between two molecules.; PSI4 also provides the ",MatchSource.WIKI,psi4manual/1.2.1/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput.html
https://psicode.org/psi4manual/1.2.1/psithoninput.html:16058,Energy Efficiency,energy,energy,16058,"ndices. As the potential energy scan is performed, the results are stored; (line 22) and the final table is printed to the output file (line 24). The; table is converted from absolute energies to relative energies (in kcal mol-1); on line 26, before being printed again. The relative energies are reported with; respect to the lowest value in each column. More examples of how to control the; formatting of the tables can be found in the sample input files provided; see; Appendix Test Suite and Sample Inputs for a complete listing. Python Wrappers¶; The Python foundations of the PSI4 driver and Psithon syntax permit; many commonly performed post-processing procedures to be integrated into; the PSI4 suite.; As seen in the neon dimer example from the tutorial section,; the nbody_gufunc() wrapper provides automatic computation of; counterpoise-corrected interaction energies between two molecules. For; example,; 1energy('mp2', bsse_type='cp'). will compute the counterpoise-corrected density-fitted MP2 interaction energy; between two molecules.; PSI4 also provides the cbs() wrapper,; which automatically computes a complete-basis-set extrapolation (and; automatically sets up the computations with different basis sets required to; do the extrapolation). For example,:; 1; 2; 3; 4; 5# all equivalent. cbs('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). energy('mp2/cc-pv[dt]z'). will compute a 2-point Helgaker extrapolation of the correlation energy; using the cc-pVDZ and cc-pVTZ basis sets (with method MP2) and add this; extrapolated correlation energy to the Hartree–Fock energy in the; largest basis (cc-pVTZ). cbs() can; either be called directly, as in the first example, or the convenience; syntax of the equivalent second example can be used.; Another very useful and powerful feature of PSI4 is the ability; to compute results on entire databases of molecules at a time,; as provided by the database() wrapper. For example,:; 1database('mp2', 'S22', cp=1, benchm",MatchSource.WIKI,psi4manual/1.2.1/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput.html
https://psicode.org/psi4manual/1.2.1/psithoninput.html:16417,Energy Efficiency,energy,energy,16417," formatting of the tables can be found in the sample input files provided; see; Appendix Test Suite and Sample Inputs for a complete listing. Python Wrappers¶; The Python foundations of the PSI4 driver and Psithon syntax permit; many commonly performed post-processing procedures to be integrated into; the PSI4 suite.; As seen in the neon dimer example from the tutorial section,; the nbody_gufunc() wrapper provides automatic computation of; counterpoise-corrected interaction energies between two molecules. For; example,; 1energy('mp2', bsse_type='cp'). will compute the counterpoise-corrected density-fitted MP2 interaction energy; between two molecules.; PSI4 also provides the cbs() wrapper,; which automatically computes a complete-basis-set extrapolation (and; automatically sets up the computations with different basis sets required to; do the extrapolation). For example,:; 1; 2; 3; 4; 5# all equivalent. cbs('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). energy('mp2/cc-pv[dt]z'). will compute a 2-point Helgaker extrapolation of the correlation energy; using the cc-pVDZ and cc-pVTZ basis sets (with method MP2) and add this; extrapolated correlation energy to the Hartree–Fock energy in the; largest basis (cc-pVTZ). cbs() can; either be called directly, as in the first example, or the convenience; syntax of the equivalent second example can be used.; Another very useful and powerful feature of PSI4 is the ability; to compute results on entire databases of molecules at a time,; as provided by the database() wrapper. For example,:; 1database('mp2', 'S22', cp=1, benchmark='S22B'). will perform DF-MP2 counterpoise-corrected interaction energies; (cp=1) on all members of Hobza’s S22 database set of van der Waals; dimers, and then compare the results against the S22B benchmark energies.; Built-in databases include S22, A24, HTBH, HBC6, HSG, S22by5, S66, JSCH,; NCB31, S66by8, and NBC10, among others.; These wrapper functions are discussed separately in; Psi",MatchSource.WIKI,psi4manual/1.2.1/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput.html
https://psicode.org/psi4manual/1.2.1/psithoninput.html:16508,Energy Efficiency,energy,energy,16508," listing. Python Wrappers¶; The Python foundations of the PSI4 driver and Psithon syntax permit; many commonly performed post-processing procedures to be integrated into; the PSI4 suite.; As seen in the neon dimer example from the tutorial section,; the nbody_gufunc() wrapper provides automatic computation of; counterpoise-corrected interaction energies between two molecules. For; example,; 1energy('mp2', bsse_type='cp'). will compute the counterpoise-corrected density-fitted MP2 interaction energy; between two molecules.; PSI4 also provides the cbs() wrapper,; which automatically computes a complete-basis-set extrapolation (and; automatically sets up the computations with different basis sets required to; do the extrapolation). For example,:; 1; 2; 3; 4; 5# all equivalent. cbs('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). energy('mp2/cc-pv[dt]z'). will compute a 2-point Helgaker extrapolation of the correlation energy; using the cc-pVDZ and cc-pVTZ basis sets (with method MP2) and add this; extrapolated correlation energy to the Hartree–Fock energy in the; largest basis (cc-pVTZ). cbs() can; either be called directly, as in the first example, or the convenience; syntax of the equivalent second example can be used.; Another very useful and powerful feature of PSI4 is the ability; to compute results on entire databases of molecules at a time,; as provided by the database() wrapper. For example,:; 1database('mp2', 'S22', cp=1, benchmark='S22B'). will perform DF-MP2 counterpoise-corrected interaction energies; (cp=1) on all members of Hobza’s S22 database set of van der Waals; dimers, and then compare the results against the S22B benchmark energies.; Built-in databases include S22, A24, HTBH, HBC6, HSG, S22by5, S66, JSCH,; NCB31, S66by8, and NBC10, among others.; These wrapper functions are discussed separately in; Psithon Functions: Invoking a Calculation. Note that the options documented for Python; functions are placed as arguments in the comman",MatchSource.WIKI,psi4manual/1.2.1/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput.html
https://psicode.org/psi4manual/1.2.1/psithoninput.html:16614,Energy Efficiency,energy,energy,16614," listing. Python Wrappers¶; The Python foundations of the PSI4 driver and Psithon syntax permit; many commonly performed post-processing procedures to be integrated into; the PSI4 suite.; As seen in the neon dimer example from the tutorial section,; the nbody_gufunc() wrapper provides automatic computation of; counterpoise-corrected interaction energies between two molecules. For; example,; 1energy('mp2', bsse_type='cp'). will compute the counterpoise-corrected density-fitted MP2 interaction energy; between two molecules.; PSI4 also provides the cbs() wrapper,; which automatically computes a complete-basis-set extrapolation (and; automatically sets up the computations with different basis sets required to; do the extrapolation). For example,:; 1; 2; 3; 4; 5# all equivalent. cbs('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). energy('mp2/cc-pv[dt]z'). will compute a 2-point Helgaker extrapolation of the correlation energy; using the cc-pVDZ and cc-pVTZ basis sets (with method MP2) and add this; extrapolated correlation energy to the Hartree–Fock energy in the; largest basis (cc-pVTZ). cbs() can; either be called directly, as in the first example, or the convenience; syntax of the equivalent second example can be used.; Another very useful and powerful feature of PSI4 is the ability; to compute results on entire databases of molecules at a time,; as provided by the database() wrapper. For example,:; 1database('mp2', 'S22', cp=1, benchmark='S22B'). will perform DF-MP2 counterpoise-corrected interaction energies; (cp=1) on all members of Hobza’s S22 database set of van der Waals; dimers, and then compare the results against the S22B benchmark energies.; Built-in databases include S22, A24, HTBH, HBC6, HSG, S22by5, S66, JSCH,; NCB31, S66by8, and NBC10, among others.; These wrapper functions are discussed separately in; Psithon Functions: Invoking a Calculation. Note that the options documented for Python; functions are placed as arguments in the comman",MatchSource.WIKI,psi4manual/1.2.1/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput.html
https://psicode.org/psi4manual/1.2.1/psithoninput.html:16641,Energy Efficiency,energy,energy,16641," listing. Python Wrappers¶; The Python foundations of the PSI4 driver and Psithon syntax permit; many commonly performed post-processing procedures to be integrated into; the PSI4 suite.; As seen in the neon dimer example from the tutorial section,; the nbody_gufunc() wrapper provides automatic computation of; counterpoise-corrected interaction energies between two molecules. For; example,; 1energy('mp2', bsse_type='cp'). will compute the counterpoise-corrected density-fitted MP2 interaction energy; between two molecules.; PSI4 also provides the cbs() wrapper,; which automatically computes a complete-basis-set extrapolation (and; automatically sets up the computations with different basis sets required to; do the extrapolation). For example,:; 1; 2; 3; 4; 5# all equivalent. cbs('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). energy('mp2/cc-pv[dt]z'). will compute a 2-point Helgaker extrapolation of the correlation energy; using the cc-pVDZ and cc-pVTZ basis sets (with method MP2) and add this; extrapolated correlation energy to the Hartree–Fock energy in the; largest basis (cc-pVTZ). cbs() can; either be called directly, as in the first example, or the convenience; syntax of the equivalent second example can be used.; Another very useful and powerful feature of PSI4 is the ability; to compute results on entire databases of molecules at a time,; as provided by the database() wrapper. For example,:; 1database('mp2', 'S22', cp=1, benchmark='S22B'). will perform DF-MP2 counterpoise-corrected interaction energies; (cp=1) on all members of Hobza’s S22 database set of van der Waals; dimers, and then compare the results against the S22B benchmark energies.; Built-in databases include S22, A24, HTBH, HBC6, HSG, S22by5, S66, JSCH,; NCB31, S66by8, and NBC10, among others.; These wrapper functions are discussed separately in; Psithon Functions: Invoking a Calculation. Note that the options documented for Python; functions are placed as arguments in the comman",MatchSource.WIKI,psi4manual/1.2.1/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput.html
https://psicode.org/psi4manual/1.2.1/psithoninput.html:16842,Energy Efficiency,power,powerful,16842,"raction energies between two molecules. For; example,; 1energy('mp2', bsse_type='cp'). will compute the counterpoise-corrected density-fitted MP2 interaction energy; between two molecules.; PSI4 also provides the cbs() wrapper,; which automatically computes a complete-basis-set extrapolation (and; automatically sets up the computations with different basis sets required to; do the extrapolation). For example,:; 1; 2; 3; 4; 5# all equivalent. cbs('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). energy('mp2/cc-pv[dt]z'). will compute a 2-point Helgaker extrapolation of the correlation energy; using the cc-pVDZ and cc-pVTZ basis sets (with method MP2) and add this; extrapolated correlation energy to the Hartree–Fock energy in the; largest basis (cc-pVTZ). cbs() can; either be called directly, as in the first example, or the convenience; syntax of the equivalent second example can be used.; Another very useful and powerful feature of PSI4 is the ability; to compute results on entire databases of molecules at a time,; as provided by the database() wrapper. For example,:; 1database('mp2', 'S22', cp=1, benchmark='S22B'). will perform DF-MP2 counterpoise-corrected interaction energies; (cp=1) on all members of Hobza’s S22 database set of van der Waals; dimers, and then compare the results against the S22B benchmark energies.; Built-in databases include S22, A24, HTBH, HBC6, HSG, S22by5, S66, JSCH,; NCB31, S66by8, and NBC10, among others.; These wrapper functions are discussed separately in; Psithon Functions: Invoking a Calculation. Note that the options documented for Python; functions are placed as arguments in the command that calls the function,; not in the set {...} block or with any other set command. table of contents. Psithon: Structuring an Input File; Physical Constants; Memory Specification; Molecule and Geometry Specification; Job Control Keywords; Basis Sets; PSI Variables; Return Values; Loops; Tables of Results; Python Wrappers. «; hide menu.",MatchSource.WIKI,psi4manual/1.2.1/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput.html
https://psicode.org/psi4manual/1.2.1/psithoninput.html:6921,Integrability,wrap,wraps,6921,"atabase; Symmetry; Non-Covalently Bonded Molecule Fragments; Advanced Python. To add EFP fragments to a molecule, see Molecule Specification. Job Control Keywords¶; PSI4 comprises a number of C++ modules that each perform; specific tasks and are callable directly from the Python front end. Each module; recognizes specific keywords in the input file which control its function.; These keywords are detailed in Appendix Keywords by Module.; The keywords can be made global, or scoped to apply to; certain specific modules. The following examples demonstrate some of the ways; that global keywords can be specified:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21# all equivalent. set globals basis cc-pVDZ. set basis cc-pVDZ. set globals basis = cc-pVDZ. set basis = cc-pVDZ. set globals{; basis cc-pVDZ; }. set {; basis cc-pVDZ; }. set {; basis = cc-pVDZ; }. Note the lack of quotes around cc-pVDZ, even though it is a string. The; Psithon preprocessor automatically wraps any string values in set commands in; strings. The last three examples provide a more convenient way for specifying; multiple keywords:; 1; 2; 3; 4; 5set {; basis = cc-pVDZ; print = 1; reference = rhf; }. For arguments that require an array input, standard Python list syntax should; be used, viz.:; 1; 2; 3set {; docc = [3, 0, 1, 1]; }. List/matrix inputs may span multiple lines, as long as the opening [ is; on the same line as the name of the keyword.; Any of the above keyword specifications can be scoped to individual modules,; by adding the name of the module after the set keyword. Omitting the module; name, or using the name global or globals will result in the keyword being; applied to all modules. For example, in the following input; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13molecule{; o; h 1 roh; h 1 roh 2 ahoh. roh = 0.957; ahoh = 104.5; }. set basis cc-pVDZ; set ccenergy print 3; set scf print 1; energy('ccsd'). the basis set is set to cc-pVDZ throughout, the SCF code will have ",MatchSource.WIKI,psi4manual/1.2.1/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput.html
https://psicode.org/psi4manual/1.2.1/psithoninput.html:13035,Integrability,wrap,wraps,13035," 15; 16# power user returns; E, wfn = energy(..., return_wfn=True); E, wfn = optimize(..., return_wfn=True); E, wfn = frequency(..., return_wfn=True); G, wfn = gradient(..., return_wfn=True) # used by optimize(); H, wfn = hessian(..., return_wfn=True) # used by frequency(). # print gradient array and its rms; wfn.gradient.print_out(); print wfn.gradient().rms(). # format output for other programs; molden(wfn, 'mycalc.molden'). # access array in another format; np.array(wfn.hessian()). Loops¶; Python provides many control structures, any of which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; 1; 2; 3; 4basis_sets = [""cc-pVDZ"", ""cc-pVTZ"", ""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_sets is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign.; The geometry specification supports delayed initialization of variable,; which permits potential energy scans. As an example, we can scan both the; angle and bond length in water:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16molecule h2o{; O; H 1 R; H 1 R 2 A; }. Rvals = [0.9, 1.0, 1.1]; Avals = range(102, 106, 2). set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). The declarations of Rvals and Avals are both completely standard Python syntax.; Having named our molecule h2o we can then set the values of R and A within; the loops. Note that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the set keyword.; Cartesian geometries, because of details of the geometry update process,; need to be specified within the loop(s) along with their b",MatchSource.WIKI,psi4manual/1.2.1/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput.html
https://psicode.org/psi4manual/1.2.1/psithoninput.html:15715,Integrability,integrat,integrated,15715,"R; for A in Avals:; h2o.A = A; energy('mp2'); escf = get_variable('SCF TOTAL ENERGY'); edfmp2 = get_variable('MP2 TOTAL ENERGY'); escsmp2 = get_variable('SCS-MP2 TOTAL ENERGY'); table[R][A] = [escf, escsmp2, edfmp2]. print table; relative=table.copy(); relative.absolute_to_relative(); print relative. we first define a table (on line 10) with two row indices and three column; indices. As the potential energy scan is performed, the results are stored; (line 22) and the final table is printed to the output file (line 24). The; table is converted from absolute energies to relative energies (in kcal mol-1); on line 26, before being printed again. The relative energies are reported with; respect to the lowest value in each column. More examples of how to control the; formatting of the tables can be found in the sample input files provided; see; Appendix Test Suite and Sample Inputs for a complete listing. Python Wrappers¶; The Python foundations of the PSI4 driver and Psithon syntax permit; many commonly performed post-processing procedures to be integrated into; the PSI4 suite.; As seen in the neon dimer example from the tutorial section,; the nbody_gufunc() wrapper provides automatic computation of; counterpoise-corrected interaction energies between two molecules. For; example,; 1energy('mp2', bsse_type='cp'). will compute the counterpoise-corrected density-fitted MP2 interaction energy; between two molecules.; PSI4 also provides the cbs() wrapper,; which automatically computes a complete-basis-set extrapolation (and; automatically sets up the computations with different basis sets required to; do the extrapolation). For example,:; 1; 2; 3; 4; 5# all equivalent. cbs('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). energy('mp2/cc-pv[dt]z'). will compute a 2-point Helgaker extrapolation of the correlation energy; using the cc-pVDZ and cc-pVTZ basis sets (with method MP2) and add this; extrapolated correlation energy to the Hartree–Fock energy in the; lar",MatchSource.WIKI,psi4manual/1.2.1/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput.html
https://psicode.org/psi4manual/1.2.1/psithoninput.html:15830,Integrability,wrap,wrapper,15830,"][A] = [escf, escsmp2, edfmp2]. print table; relative=table.copy(); relative.absolute_to_relative(); print relative. we first define a table (on line 10) with two row indices and three column; indices. As the potential energy scan is performed, the results are stored; (line 22) and the final table is printed to the output file (line 24). The; table is converted from absolute energies to relative energies (in kcal mol-1); on line 26, before being printed again. The relative energies are reported with; respect to the lowest value in each column. More examples of how to control the; formatting of the tables can be found in the sample input files provided; see; Appendix Test Suite and Sample Inputs for a complete listing. Python Wrappers¶; The Python foundations of the PSI4 driver and Psithon syntax permit; many commonly performed post-processing procedures to be integrated into; the PSI4 suite.; As seen in the neon dimer example from the tutorial section,; the nbody_gufunc() wrapper provides automatic computation of; counterpoise-corrected interaction energies between two molecules. For; example,; 1energy('mp2', bsse_type='cp'). will compute the counterpoise-corrected density-fitted MP2 interaction energy; between two molecules.; PSI4 also provides the cbs() wrapper,; which automatically computes a complete-basis-set extrapolation (and; automatically sets up the computations with different basis sets required to; do the extrapolation). For example,:; 1; 2; 3; 4; 5# all equivalent. cbs('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). energy('mp2/cc-pv[dt]z'). will compute a 2-point Helgaker extrapolation of the correlation energy; using the cc-pVDZ and cc-pVTZ basis sets (with method MP2) and add this; extrapolated correlation energy to the Hartree–Fock energy in the; largest basis (cc-pVTZ). cbs() can; either be called directly, as in the first example, or the convenience; syntax of the equivalent second example can be used.; Another very useful and p",MatchSource.WIKI,psi4manual/1.2.1/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput.html
https://psicode.org/psi4manual/1.2.1/psithoninput.html:16119,Integrability,wrap,wrapper,16119," is converted from absolute energies to relative energies (in kcal mol-1); on line 26, before being printed again. The relative energies are reported with; respect to the lowest value in each column. More examples of how to control the; formatting of the tables can be found in the sample input files provided; see; Appendix Test Suite and Sample Inputs for a complete listing. Python Wrappers¶; The Python foundations of the PSI4 driver and Psithon syntax permit; many commonly performed post-processing procedures to be integrated into; the PSI4 suite.; As seen in the neon dimer example from the tutorial section,; the nbody_gufunc() wrapper provides automatic computation of; counterpoise-corrected interaction energies between two molecules. For; example,; 1energy('mp2', bsse_type='cp'). will compute the counterpoise-corrected density-fitted MP2 interaction energy; between two molecules.; PSI4 also provides the cbs() wrapper,; which automatically computes a complete-basis-set extrapolation (and; automatically sets up the computations with different basis sets required to; do the extrapolation). For example,:; 1; 2; 3; 4; 5# all equivalent. cbs('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). energy('mp2/cc-pv[dt]z'). will compute a 2-point Helgaker extrapolation of the correlation energy; using the cc-pVDZ and cc-pVTZ basis sets (with method MP2) and add this; extrapolated correlation energy to the Hartree–Fock energy in the; largest basis (cc-pVTZ). cbs() can; either be called directly, as in the first example, or the convenience; syntax of the equivalent second example can be used.; Another very useful and powerful feature of PSI4 is the ability; to compute results on entire databases of molecules at a time,; as provided by the database() wrapper. For example,:; 1database('mp2', 'S22', cp=1, benchmark='S22B'). will perform DF-MP2 counterpoise-corrected interaction energies; (cp=1) on all members of Hobza’s S22 database set of van der Waals; dimers, and",MatchSource.WIKI,psi4manual/1.2.1/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput.html
https://psicode.org/psi4manual/1.2.1/psithoninput.html:16977,Integrability,wrap,wrapper,16977,"raction energies between two molecules. For; example,; 1energy('mp2', bsse_type='cp'). will compute the counterpoise-corrected density-fitted MP2 interaction energy; between two molecules.; PSI4 also provides the cbs() wrapper,; which automatically computes a complete-basis-set extrapolation (and; automatically sets up the computations with different basis sets required to; do the extrapolation). For example,:; 1; 2; 3; 4; 5# all equivalent. cbs('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). energy('mp2/cc-pv[dt]z'). will compute a 2-point Helgaker extrapolation of the correlation energy; using the cc-pVDZ and cc-pVTZ basis sets (with method MP2) and add this; extrapolated correlation energy to the Hartree–Fock energy in the; largest basis (cc-pVTZ). cbs() can; either be called directly, as in the first example, or the convenience; syntax of the equivalent second example can be used.; Another very useful and powerful feature of PSI4 is the ability; to compute results on entire databases of molecules at a time,; as provided by the database() wrapper. For example,:; 1database('mp2', 'S22', cp=1, benchmark='S22B'). will perform DF-MP2 counterpoise-corrected interaction energies; (cp=1) on all members of Hobza’s S22 database set of van der Waals; dimers, and then compare the results against the S22B benchmark energies.; Built-in databases include S22, A24, HTBH, HBC6, HSG, S22by5, S66, JSCH,; NCB31, S66by8, and NBC10, among others.; These wrapper functions are discussed separately in; Psithon Functions: Invoking a Calculation. Note that the options documented for Python; functions are placed as arguments in the command that calls the function,; not in the set {...} block or with any other set command. table of contents. Psithon: Structuring an Input File; Physical Constants; Memory Specification; Molecule and Geometry Specification; Job Control Keywords; Basis Sets; PSI Variables; Return Values; Loops; Tables of Results; Python Wrappers. «; hide menu.",MatchSource.WIKI,psi4manual/1.2.1/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput.html
https://psicode.org/psi4manual/1.2.1/psithoninput.html:17379,Integrability,wrap,wrapper,17379,"he cbs() wrapper,; which automatically computes a complete-basis-set extrapolation (and; automatically sets up the computations with different basis sets required to; do the extrapolation). For example,:; 1; 2; 3; 4; 5# all equivalent. cbs('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). energy('mp2/cc-pv[dt]z'). will compute a 2-point Helgaker extrapolation of the correlation energy; using the cc-pVDZ and cc-pVTZ basis sets (with method MP2) and add this; extrapolated correlation energy to the Hartree–Fock energy in the; largest basis (cc-pVTZ). cbs() can; either be called directly, as in the first example, or the convenience; syntax of the equivalent second example can be used.; Another very useful and powerful feature of PSI4 is the ability; to compute results on entire databases of molecules at a time,; as provided by the database() wrapper. For example,:; 1database('mp2', 'S22', cp=1, benchmark='S22B'). will perform DF-MP2 counterpoise-corrected interaction energies; (cp=1) on all members of Hobza’s S22 database set of van der Waals; dimers, and then compare the results against the S22B benchmark energies.; Built-in databases include S22, A24, HTBH, HBC6, HSG, S22by5, S66, JSCH,; NCB31, S66by8, and NBC10, among others.; These wrapper functions are discussed separately in; Psithon Functions: Invoking a Calculation. Note that the options documented for Python; functions are placed as arguments in the command that calls the function,; not in the set {...} block or with any other set command. table of contents. Psithon: Structuring an Input File; Physical Constants; Memory Specification; Molecule and Geometry Specification; Job Control Keywords; Basis Sets; PSI Variables; Return Values; Loops; Tables of Results; Python Wrappers. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput.html
https://psicode.org/psi4manual/1.2.1/psithoninput.html:1022,Modifiability,variab,variables,1022,"File. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Psithon: Structuring an Input File¶; To allow arbitrarily complex computations to be performed, PSI4 was built; upon the Python interpreter. However, to make the input syntax simpler, some; pre-processing of the input file is performed before it is interpreted,; resulting in Python syntax that is customized for PSI, termed Psithon. In; this section we will describe the essential features of the Psithon language.; PSI4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; 1UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that the user’s ~/.psi4rc values can; override the builtins (in the input file, not in the C++ code).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files. # Do not modify this file! It is auto-generated by the document_options_and_tests; # script, from psi4topdir/psi4/include/psi4/physconst.h; h = 6.62606896E-34 # The Planck constant (Js) ; c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; kb = 1.380650",MatchSource.WIKI,psi4manual/1.2.1/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput.html
https://psicode.org/psi4manual/1.2.1/psithoninput.html:1281,Modifiability,variab,variable,1281,"some; pre-processing of the input file is performed before it is interpreted,; resulting in Python syntax that is customized for PSI, termed Psithon. In; this section we will describe the essential features of the Psithon language.; PSI4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; 1UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that the user’s ~/.psi4rc values can; override the builtins (in the input file, not in the C++ code).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files. # Do not modify this file! It is auto-generated by the document_options_and_tests; # script, from psi4topdir/psi4/include/psi4/physconst.h; h = 6.62606896E-34 # The Planck constant (Js) ; c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; R = 8.314472 # Universal gas constant (JK$^{-1}$mol$^{-1}$) ; bohr2angstroms = 0.52917720859 # Bohr to Angstroms conversion factor ; bohr2m = 0.52917720859E-10 # Bohr to meters conversion factor ; bohr2cm = 0.5291772",MatchSource.WIKI,psi4manual/1.2.1/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput.html
https://psicode.org/psi4manual/1.2.1/psithoninput.html:1529,Modifiability,variab,variables,1529,"on. In; this section we will describe the essential features of the Psithon language.; PSI4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; 1UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that the user’s ~/.psi4rc values can; override the builtins (in the input file, not in the C++ code).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files. # Do not modify this file! It is auto-generated by the document_options_and_tests; # script, from psi4topdir/psi4/include/psi4/physconst.h; h = 6.62606896E-34 # The Planck constant (Js) ; c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; R = 8.314472 # Universal gas constant (JK$^{-1}$mol$^{-1}$) ; bohr2angstroms = 0.52917720859 # Bohr to Angstroms conversion factor ; bohr2m = 0.52917720859E-10 # Bohr to meters conversion factor ; bohr2cm = 0.52917720859E-8 # Bohr to centimeters conversion factor ; amu2g = 1.660538782E-24 # Atomic mass units to grams conversion factor ; amu2kg = 1.660538782E-",MatchSource.WIKI,psi4manual/1.2.1/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput.html
https://psicode.org/psi4manual/1.2.1/psithoninput.html:3778,Modifiability,variab,variables,3778,"# Calorie to joule conversion factor ; dipmom_au2si = 8.47835281E-30 # Atomic units to SI units (Cm) conversion factor for dipoles ; dipmom_au2debye = 2.54174623 # Atomic units to Debye conversion factor for dipoles ; dipmom_debye2si = 3.335640952E-30 # Debye to SI units (Cm) conversion factor for dipoles ; c_au = 137.035999679 # Speed of light in atomic units ; hartree2ev = 27.21138 # Hartree to eV conversion factor ; hartree2wavenumbers = 219474.6 # Hartree to cm$^{-1}$ conversion factor ; hartree2kcalmol = 627.5095 # Hartree to kcal mol$^{-1}$ conversion factor ; hartree2kJmol = 2625.500 # Hartree to kilojoule mol$^{-1}$ conversion factor ; hartree2MHz = 6.579684E9 # Hartree to MHz conversion factor ; kcalmol2wavenumbers = 349.7551 # kcal mol$^{-1}$ to cm$^{-1}$ conversion factor ; e0 = 8.854187817E-12 # Vacuum permittivity (Fm$^{-1}$) ; na = 6.02214179E23 # Avagadro's number ; me = 9.10938215E-31 # Electron rest mass (in kg) . In Psithon input files, prepend physical constants with psi_ to; prevent clashes with user-defined variables (e.g., psi_h). In; PsiAPI mode, access as, e.g., psi4.constants.h. Memory Specification¶; By default, PSI4 assumes that 500 MiB of memory are available. While this is; enough for many computations, many of the algorithms will perform better if; more is available. To specify memory, the memory keyword should be used. The following; lines are all equivalent methods for specifying that 2 GB of RAM is available; to PSI4:; 1; 2; 3; 4; 5; 6; 7# all equivalent. memory 2 GB. memory 2000 MB. memory 2000000 kB. Please note that memory can be specified both in IEC binary units (1 KiB = 1024 bytes) and SI units (1 kB = 1000 bytes). PSI4 recognizes and obeys both of them correctly. The units are not case sensitive (Kb and KB are equivalent to kB).; By default, PSI4 performs a “sanity check” when parsing Psithon input files, enforcing a minimum memory requirement of 250 MiB. While it is generally not recomennded to do so, expert users can bypass t",MatchSource.WIKI,psi4manual/1.2.1/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput.html
https://psicode.org/psi4manual/1.2.1/psithoninput.html:9964,Modifiability,variab,variable,9964,"ful to separate calculations in a PsiAPI; session.; 1; 2; 3; 4; 5; 6; 7; 8; 9psi4.set_options({; 'scf_type': 'pk',; 'e_convergence': 1.e-5,; 'soscf': True; }). psi4.set_module_options({; 'geom_maxiter': 50; }). Basis Sets¶. Basis Sets; Built-In Basis Sets; Mixing Basis Sets; Decontracted Basis Sets; User-Defined Basis Sets; Inputting effective core potentials (ECPs). PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results; of each computation available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of; H2 and H atom:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19molecule h2 {; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h {; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol * (2*h_energy - h2_energy); print ""De=%f"" % D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module, and PSI Variables by Alpha defines them. These can be; accessed through the get_variable() function. For example, after; performing a density fitted MP2 computation, both the spin component; scaled energy and the unscaled MP2 energy are made available:; 1; 2e_mp2 = get_variable('MP2 TOTAL ENERGY'); e_scs_mp2 = get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; are cleared at the start of each energy(), etc. in an input; file by clean_variables().; So if you",MatchSource.WIKI,psi4manual/1.2.1/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput.html
https://psicode.org/psi4manual/1.2.1/psithoninput.html:10198,Modifiability,variab,variables,10198,"is Sets; Inputting effective core potentials (ECPs). PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results; of each computation available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of; H2 and H atom:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19molecule h2 {; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h {; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol * (2*h_energy - h2_energy); print ""De=%f"" % D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module, and PSI Variables by Alpha defines them. These can be; accessed through the get_variable() function. For example, after; performing a density fitted MP2 computation, both the spin component; scaled energy and the unscaled MP2 energy are made available:; 1; 2e_mp2 = get_variable('MP2 TOTAL ENERGY'); e_scs_mp2 = get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; are cleared at the start of each energy(), etc. in an input; file by clean_variables().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the; last will include SCF TOTAL ENERGY but not; FCI TOTAL ENERGY.; The entire dictionary of PSI variables can be obtained through; get_variables(). Return Values¶; Most of the usual user computation fun",MatchSource.WIKI,psi4manual/1.2.1/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput.html
https://psicode.org/psi4manual/1.2.1/psithoninput.html:10208,Modifiability,variab,variables,10208,"is Sets; Inputting effective core potentials (ECPs). PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results; of each computation available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of; H2 and H atom:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19molecule h2 {; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h {; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol * (2*h_energy - h2_energy); print ""De=%f"" % D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module, and PSI Variables by Alpha defines them. These can be; accessed through the get_variable() function. For example, after; performing a density fitted MP2 computation, both the spin component; scaled energy and the unscaled MP2 energy are made available:; 1; 2e_mp2 = get_variable('MP2 TOTAL ENERGY'); e_scs_mp2 = get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; are cleared at the start of each energy(), etc. in an input; file by clean_variables().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the; last will include SCF TOTAL ENERGY but not; FCI TOTAL ENERGY.; The entire dictionary of PSI variables can be obtained through; get_variables(). Return Values¶; Most of the usual user computation fun",MatchSource.WIKI,psi4manual/1.2.1/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput.html
https://psicode.org/psi4manual/1.2.1/psithoninput.html:10631,Modifiability,variab,variables,10631,"ence rhf; h2_energy = energy('scf'). molecule h {; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol * (2*h_energy - h2_energy); print ""De=%f"" % D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module, and PSI Variables by Alpha defines them. These can be; accessed through the get_variable() function. For example, after; performing a density fitted MP2 computation, both the spin component; scaled energy and the unscaled MP2 energy are made available:; 1; 2e_mp2 = get_variable('MP2 TOTAL ENERGY'); e_scs_mp2 = get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; are cleared at the start of each energy(), etc. in an input; file by clean_variables().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the; last will include SCF TOTAL ENERGY but not; FCI TOTAL ENERGY.; The entire dictionary of PSI variables can be obtained through; get_variables(). Return Values¶; Most of the usual user computation functions (i.e.,; energy(), optimize(), and; frequency()) return simply the current total energy.; Consult the descriptions of other functions in Psithon Functions: Invoking a Calculation for; what quantities they return and for what data structures they make; available for post-processing. Many users need only deal with the simple return; form for the computation functions.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11# E is ",MatchSource.WIKI,psi4manual/1.2.1/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput.html
https://psicode.org/psi4manual/1.2.1/psithoninput.html:10791,Modifiability,variab,variables,10791,"""De=%f"" % D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module, and PSI Variables by Alpha defines them. These can be; accessed through the get_variable() function. For example, after; performing a density fitted MP2 computation, both the spin component; scaled energy and the unscaled MP2 energy are made available:; 1; 2e_mp2 = get_variable('MP2 TOTAL ENERGY'); e_scs_mp2 = get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; are cleared at the start of each energy(), etc. in an input; file by clean_variables().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the; last will include SCF TOTAL ENERGY but not; FCI TOTAL ENERGY.; The entire dictionary of PSI variables can be obtained through; get_variables(). Return Values¶; Most of the usual user computation functions (i.e.,; energy(), optimize(), and; frequency()) return simply the current total energy.; Consult the descriptions of other functions in Psithon Functions: Invoking a Calculation for; what quantities they return and for what data structures they make; available for post-processing. Many users need only deal with the simple return; form for the computation functions.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11# E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = energy(...); E = optimize(...); E = f",MatchSource.WIKI,psi4manual/1.2.1/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput.html
https://psicode.org/psi4manual/1.2.1/psithoninput.html:11110,Modifiability,variab,variables,11110," multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module, and PSI Variables by Alpha defines them. These can be; accessed through the get_variable() function. For example, after; performing a density fitted MP2 computation, both the spin component; scaled energy and the unscaled MP2 energy are made available:; 1; 2e_mp2 = get_variable('MP2 TOTAL ENERGY'); e_scs_mp2 = get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; are cleared at the start of each energy(), etc. in an input; file by clean_variables().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the; last will include SCF TOTAL ENERGY but not; FCI TOTAL ENERGY.; The entire dictionary of PSI variables can be obtained through; get_variables(). Return Values¶; Most of the usual user computation functions (i.e.,; energy(), optimize(), and; frequency()) return simply the current total energy.; Consult the descriptions of other functions in Psithon Functions: Invoking a Calculation for; what quantities they return and for what data structures they make; available for post-processing. Many users need only deal with the simple return; form for the computation functions.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11# E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = energy(...); E = optimize(...); E = frequency(...); G = gradient(...) # used by optimize(); H = hessian(...) # used by frequency(). For more elaborate post-processing of computations, adding; return_wfn=True keyword argument additionally returns; Wavefunction.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16# power user returns; E, wfn ",MatchSource.WIKI,psi4manual/1.2.1/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput.html
https://psicode.org/psi4manual/1.2.1/psithoninput.html:13118,Modifiability,variab,variable,13118," 15; 16# power user returns; E, wfn = energy(..., return_wfn=True); E, wfn = optimize(..., return_wfn=True); E, wfn = frequency(..., return_wfn=True); G, wfn = gradient(..., return_wfn=True) # used by optimize(); H, wfn = hessian(..., return_wfn=True) # used by frequency(). # print gradient array and its rms; wfn.gradient.print_out(); print wfn.gradient().rms(). # format output for other programs; molden(wfn, 'mycalc.molden'). # access array in another format; np.array(wfn.hessian()). Loops¶; Python provides many control structures, any of which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; 1; 2; 3; 4basis_sets = [""cc-pVDZ"", ""cc-pVTZ"", ""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_sets is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign.; The geometry specification supports delayed initialization of variable,; which permits potential energy scans. As an example, we can scan both the; angle and bond length in water:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16molecule h2o{; O; H 1 R; H 1 R 2 A; }. Rvals = [0.9, 1.0, 1.1]; Avals = range(102, 106, 2). set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). The declarations of Rvals and Avals are both completely standard Python syntax.; Having named our molecule h2o we can then set the values of R and A within; the loops. Note that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the set keyword.; Cartesian geometries, because of details of the geometry update process,; need to be specified within the loop(s) along with their b",MatchSource.WIKI,psi4manual/1.2.1/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput.html
https://psicode.org/psi4manual/1.2.1/psithoninput.html:13241,Modifiability,variab,variable,13241,"; G, wfn = gradient(..., return_wfn=True) # used by optimize(); H, wfn = hessian(..., return_wfn=True) # used by frequency(). # print gradient array and its rms; wfn.gradient.print_out(); print wfn.gradient().rms(). # format output for other programs; molden(wfn, 'mycalc.molden'). # access array in another format; np.array(wfn.hessian()). Loops¶; Python provides many control structures, any of which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; 1; 2; 3; 4basis_sets = [""cc-pVDZ"", ""cc-pVTZ"", ""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_sets is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign.; The geometry specification supports delayed initialization of variable,; which permits potential energy scans. As an example, we can scan both the; angle and bond length in water:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16molecule h2o{; O; H 1 R; H 1 R 2 A; }. Rvals = [0.9, 1.0, 1.1]; Avals = range(102, 106, 2). set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). The declarations of Rvals and Avals are both completely standard Python syntax.; Having named our molecule h2o we can then set the values of R and A within; the loops. Note that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the set keyword.; Cartesian geometries, because of details of the geometry update process,; need to be specified within the loop(s) along with their basis set when; geometry scans are performed. See scf4 for analogous Z-matrix; and Cartiesian scans. Tables of Results¶; The results of computations c",MatchSource.WIKI,psi4manual/1.2.1/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput.html
https://psicode.org/psi4manual/1.2.1/psithoninput.html:13852,Modifiability,variab,variable,13852,"y('scf'). The declaration of basis_sets is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign.; The geometry specification supports delayed initialization of variable,; which permits potential energy scans. As an example, we can scan both the; angle and bond length in water:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16molecule h2o{; O; H 1 R; H 1 R 2 A; }. Rvals = [0.9, 1.0, 1.1]; Avals = range(102, 106, 2). set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). The declarations of Rvals and Avals are both completely standard Python syntax.; Having named our molecule h2o we can then set the values of R and A within; the loops. Note that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the set keyword.; Cartesian geometries, because of details of the geometry update process,; need to be specified within the loop(s) along with their basis set when; geometry scans are performed. See scf4 for analogous Z-matrix; and Cartiesian scans. Tables of Results¶; The results of computations can be compactly tabulated with the Table() Psithon; function. For example, in the following potential energy surface scan for water; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27molecule h2o {; O; H 1 R; H 1 R 2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(100,102,2). table=Table(rows=[""R"",""A""], cols=[""E(SCF)"",""E(SCS)"",""E(DFMP2)""]). set basis cc-pvdz. for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('mp2'); escf = get_variable('SCF TOTAL ENERGY'); edfmp2 = get_variable('MP2 TOTAL ENERGY'); escsmp2 = get_variable('SCS-MP2 TOTAL ENERGY'); table[R][A] = [escf, escsmp2, edf",MatchSource.WIKI,psi4manual/1.2.1/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput.html
https://psicode.org/psi4manual/1.2.1/psithoninput.html:13918,Modifiability,variab,variables,13918,"y('scf'). The declaration of basis_sets is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign.; The geometry specification supports delayed initialization of variable,; which permits potential energy scans. As an example, we can scan both the; angle and bond length in water:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16molecule h2o{; O; H 1 R; H 1 R 2 A; }. Rvals = [0.9, 1.0, 1.1]; Avals = range(102, 106, 2). set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). The declarations of Rvals and Avals are both completely standard Python syntax.; Having named our molecule h2o we can then set the values of R and A within; the loops. Note that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the set keyword.; Cartesian geometries, because of details of the geometry update process,; need to be specified within the loop(s) along with their basis set when; geometry scans are performed. See scf4 for analogous Z-matrix; and Cartiesian scans. Tables of Results¶; The results of computations can be compactly tabulated with the Table() Psithon; function. For example, in the following potential energy surface scan for water; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27molecule h2o {; O; H 1 R; H 1 R 2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(100,102,2). table=Table(rows=[""R"",""A""], cols=[""E(SCF)"",""E(SCS)"",""E(DFMP2)""]). set basis cc-pvdz. for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('mp2'); escf = get_variable('SCF TOTAL ENERGY'); edfmp2 = get_variable('MP2 TOTAL ENERGY'); escsmp2 = get_variable('SCS-MP2 TOTAL ENERGY'); table[R][A] = [escf, escsmp2, edf",MatchSource.WIKI,psi4manual/1.2.1/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput.html
https://psicode.org/psi4manual/1.2.1/psithoninput.html:194,Performance,perform,performed,194,"﻿. Psithon: Structuring an Input File. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Psithon: Structuring an Input File¶; To allow arbitrarily complex computations to be performed, PSI4 was built; upon the Python interpreter. However, to make the input syntax simpler, some; pre-processing of the input file is performed before it is interpreted,; resulting in Python syntax that is customized for PSI, termed Psithon. In; this section we will describe the essential features of the Psithon language.; PSI4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; 1UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that the user’s ~/.psi4rc values can; override the builtins (in the input file, not in the C++ code).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files. # Do not modify this file! It is auto-generated by the document_options_and_tests; # script, from psi4topdir/psi4/include/psi4/physconst.h; h = 6.62606896E-34 # The Planck constant (Js) ; c = 2.99792458E8 # Speed of l",MatchSource.WIKI,psi4manual/1.2.1/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput.html
https://psicode.org/psi4manual/1.2.1/psithoninput.html:335,Performance,perform,performed,335,"﻿. Psithon: Structuring an Input File. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Psithon: Structuring an Input File¶; To allow arbitrarily complex computations to be performed, PSI4 was built; upon the Python interpreter. However, to make the input syntax simpler, some; pre-processing of the input file is performed before it is interpreted,; resulting in Python syntax that is customized for PSI, termed Psithon. In; this section we will describe the essential features of the Psithon language.; PSI4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; 1UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that the user’s ~/.psi4rc values can; override the builtins (in the input file, not in the C++ code).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files. # Do not modify this file! It is auto-generated by the document_options_and_tests; # script, from psi4topdir/psi4/include/psi4/physconst.h; h = 6.62606896E-34 # The Planck constant (Js) ; c = 2.99792458E8 # Speed of l",MatchSource.WIKI,psi4manual/1.2.1/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput.html
https://psicode.org/psi4manual/1.2.1/psithoninput.html:946,Performance,perform,performing,946,"﻿. Psithon: Structuring an Input File. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Psithon: Structuring an Input File¶; To allow arbitrarily complex computations to be performed, PSI4 was built; upon the Python interpreter. However, to make the input syntax simpler, some; pre-processing of the input file is performed before it is interpreted,; resulting in Python syntax that is customized for PSI, termed Psithon. In; this section we will describe the essential features of the Psithon language.; PSI4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; 1UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that the user’s ~/.psi4rc values can; override the builtins (in the input file, not in the C++ code).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files. # Do not modify this file! It is auto-generated by the document_options_and_tests; # script, from psi4topdir/psi4/include/psi4/physconst.h; h = 6.62606896E-34 # The Planck constant (Js) ; c = 2.99792458E8 # Speed of l",MatchSource.WIKI,psi4manual/1.2.1/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput.html
https://psicode.org/psi4manual/1.2.1/psithoninput.html:1510,Performance,load,loaded,1510,"on. In; this section we will describe the essential features of the Psithon language.; PSI4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; 1UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that the user’s ~/.psi4rc values can; override the builtins (in the input file, not in the C++ code).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files. # Do not modify this file! It is auto-generated by the document_options_and_tests; # script, from psi4topdir/psi4/include/psi4/physconst.h; h = 6.62606896E-34 # The Planck constant (Js) ; c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; R = 8.314472 # Universal gas constant (JK$^{-1}$mol$^{-1}$) ; bohr2angstroms = 0.52917720859 # Bohr to Angstroms conversion factor ; bohr2m = 0.52917720859E-10 # Bohr to meters conversion factor ; bohr2cm = 0.52917720859E-8 # Bohr to centimeters conversion factor ; amu2g = 1.660538782E-24 # Atomic mass units to grams conversion factor ; amu2kg = 1.660538782E-",MatchSource.WIKI,psi4manual/1.2.1/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput.html
https://psicode.org/psi4manual/1.2.1/psithoninput.html:1560,Performance,load,loaded,1560,"uite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; 1UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that the user’s ~/.psi4rc values can; override the builtins (in the input file, not in the C++ code).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files. # Do not modify this file! It is auto-generated by the document_options_and_tests; # script, from psi4topdir/psi4/include/psi4/physconst.h; h = 6.62606896E-34 # The Planck constant (Js) ; c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; R = 8.314472 # Universal gas constant (JK$^{-1}$mol$^{-1}$) ; bohr2angstroms = 0.52917720859 # Bohr to Angstroms conversion factor ; bohr2m = 0.52917720859E-10 # Bohr to meters conversion factor ; bohr2cm = 0.52917720859E-8 # Bohr to centimeters conversion factor ; amu2g = 1.660538782E-24 # Atomic mass units to grams conversion factor ; amu2kg = 1.660538782E-27 # Atomic mass units to kg conversion factor ; au2amu = 5.485799097E-4 # Atomic units (m$@@e$) to atomic mass units conversion fa",MatchSource.WIKI,psi4manual/1.2.1/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput.html
https://psicode.org/psi4manual/1.2.1/psithoninput.html:4014,Performance,perform,perform,4014,"o SI units (Cm) conversion factor for dipoles ; c_au = 137.035999679 # Speed of light in atomic units ; hartree2ev = 27.21138 # Hartree to eV conversion factor ; hartree2wavenumbers = 219474.6 # Hartree to cm$^{-1}$ conversion factor ; hartree2kcalmol = 627.5095 # Hartree to kcal mol$^{-1}$ conversion factor ; hartree2kJmol = 2625.500 # Hartree to kilojoule mol$^{-1}$ conversion factor ; hartree2MHz = 6.579684E9 # Hartree to MHz conversion factor ; kcalmol2wavenumbers = 349.7551 # kcal mol$^{-1}$ to cm$^{-1}$ conversion factor ; e0 = 8.854187817E-12 # Vacuum permittivity (Fm$^{-1}$) ; na = 6.02214179E23 # Avagadro's number ; me = 9.10938215E-31 # Electron rest mass (in kg) . In Psithon input files, prepend physical constants with psi_ to; prevent clashes with user-defined variables (e.g., psi_h). In; PsiAPI mode, access as, e.g., psi4.constants.h. Memory Specification¶; By default, PSI4 assumes that 500 MiB of memory are available. While this is; enough for many computations, many of the algorithms will perform better if; more is available. To specify memory, the memory keyword should be used. The following; lines are all equivalent methods for specifying that 2 GB of RAM is available; to PSI4:; 1; 2; 3; 4; 5; 6; 7# all equivalent. memory 2 GB. memory 2000 MB. memory 2000000 kB. Please note that memory can be specified both in IEC binary units (1 KiB = 1024 bytes) and SI units (1 kB = 1000 bytes). PSI4 recognizes and obeys both of them correctly. The units are not case sensitive (Kb and KB are equivalent to kB).; By default, PSI4 performs a “sanity check” when parsing Psithon input files, enforcing a minimum memory requirement of 250 MiB. While it is generally not recomennded to do so, expert users can bypass this check by directly setting the number of bytes availble to PSI4:; 1; 2# setting available memory to 2 MB; set_memory_bytes(2000000). Please note that this memory setting only governs the maximal memory usage of the major data structures and actual total memo",MatchSource.WIKI,psi4manual/1.2.1/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput.html
https://psicode.org/psi4manual/1.2.1/psithoninput.html:4551,Performance,perform,performs,4551,"214179E23 # Avagadro's number ; me = 9.10938215E-31 # Electron rest mass (in kg) . In Psithon input files, prepend physical constants with psi_ to; prevent clashes with user-defined variables (e.g., psi_h). In; PsiAPI mode, access as, e.g., psi4.constants.h. Memory Specification¶; By default, PSI4 assumes that 500 MiB of memory are available. While this is; enough for many computations, many of the algorithms will perform better if; more is available. To specify memory, the memory keyword should be used. The following; lines are all equivalent methods for specifying that 2 GB of RAM is available; to PSI4:; 1; 2; 3; 4; 5; 6; 7# all equivalent. memory 2 GB. memory 2000 MB. memory 2000000 kB. Please note that memory can be specified both in IEC binary units (1 KiB = 1024 bytes) and SI units (1 kB = 1000 bytes). PSI4 recognizes and obeys both of them correctly. The units are not case sensitive (Kb and KB are equivalent to kB).; By default, PSI4 performs a “sanity check” when parsing Psithon input files, enforcing a minimum memory requirement of 250 MiB. While it is generally not recomennded to do so, expert users can bypass this check by directly setting the number of bytes availble to PSI4:; 1; 2# setting available memory to 2 MB; set_memory_bytes(2000000). Please note that this memory setting only governs the maximal memory usage of the major data structures and actual total memory usage is slightly higher. This is usually a negligible, except when setting tiny memory allowances.; One convenient way to override the PSI4 default memory is to place a; memory command in the ~/.psi4rc file (Sec. ~/.psi4rc File). For example,; the following makes the default memory 2 GB.; 1set_memory(2000000000). However, unless you’re assured of having only one job running on a node at; a time (and all nodes on the filesystem with ~/.psi4rc have similar memory; capacities), it is advised to set memory in the input file on a; per-calculation basis.; That same command can be used for PsiAPI ",MatchSource.WIKI,psi4manual/1.2.1/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput.html
https://psicode.org/psi4manual/1.2.1/psithoninput.html:6140,Performance,perform,perform,6140,"efault memory is to place a; memory command in the ~/.psi4rc file (Sec. ~/.psi4rc File). For example,; the following makes the default memory 2 GB.; 1set_memory(2000000000). However, unless you’re assured of having only one job running on a node at; a time (and all nodes on the filesystem with ~/.psi4rc have similar memory; capacities), it is advised to set memory in the input file on a; per-calculation basis.; That same command can be used for PsiAPI mode:; 1psi4.set_memory(int(5e8)). Note; For parallel jobs, the memory keyword represents the total memory; available to the job, not the memory per thread. Molecule and Geometry Specification¶. Molecule and Geometry Specification; Coordinates; Molecule Keywords; Multiple Molecules; Ghost Atoms; Isotopic Substitution; PubChem Database; Symmetry; Non-Covalently Bonded Molecule Fragments; Advanced Python. To add EFP fragments to a molecule, see Molecule Specification. Job Control Keywords¶; PSI4 comprises a number of C++ modules that each perform; specific tasks and are callable directly from the Python front end. Each module; recognizes specific keywords in the input file which control its function.; These keywords are detailed in Appendix Keywords by Module.; The keywords can be made global, or scoped to apply to; certain specific modules. The following examples demonstrate some of the ways; that global keywords can be specified:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21# all equivalent. set globals basis cc-pVDZ. set basis cc-pVDZ. set globals basis = cc-pVDZ. set basis = cc-pVDZ. set globals{; basis cc-pVDZ; }. set {; basis cc-pVDZ; }. set {; basis = cc-pVDZ; }. Note the lack of quotes around cc-pVDZ, even though it is a string. The; Psithon preprocessor automatically wraps any string values in set commands in; strings. The last three examples provide a more convenient way for specifying; multiple keywords:; 1; 2; 3; 4; 5set {; basis = cc-pVDZ; print = 1; reference = rhf; }. For argume",MatchSource.WIKI,psi4manual/1.2.1/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput.html
https://psicode.org/psi4manual/1.2.1/psithoninput.html:7976,Performance,perform,performs,7976," commands in; strings. The last three examples provide a more convenient way for specifying; multiple keywords:; 1; 2; 3; 4; 5set {; basis = cc-pVDZ; print = 1; reference = rhf; }. For arguments that require an array input, standard Python list syntax should; be used, viz.:; 1; 2; 3set {; docc = [3, 0, 1, 1]; }. List/matrix inputs may span multiple lines, as long as the opening [ is; on the same line as the name of the keyword.; Any of the above keyword specifications can be scoped to individual modules,; by adding the name of the module after the set keyword. Omitting the module; name, or using the name global or globals will result in the keyword being; applied to all modules. For example, in the following input; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13molecule{; o; h 1 roh; h 1 roh 2 ahoh. roh = 0.957; ahoh = 104.5; }. set basis cc-pVDZ; set ccenergy print 3; set scf print 1; energy('ccsd'). the basis set is set to cc-pVDZ throughout, the SCF code will have a print; level of 1 and the ccenergy code, which performs coupled cluster computations,; will use a print level of 3. In this example a full CCSD computation is; performed by running the SCF code first, then the coupled cluster modules;; the energy() Python helper function ensures that this is performed correctly.; Note that the Python interpreter executes commands in the order they appear in; the input file, so if the last four commands in the above example were to read; 1; 2; 3; 4set basis cc-pVDZ; energy('ccsd'); set ccenergy print 3; set scf print 1. the commands that set the print level would be ineffective, as they would be; processed after the CCSD computation completes.; In PsiAPI mode, one can use commands set_options() and; set_module_options() like below. Note that these values; should be of correct type, strings for strings, floats for floats like; convergences. The function ~psi4.core.clean_options that reinitializes; all options may also be useful to separate calculations in a PsiAPI; session.; 1",MatchSource.WIKI,psi4manual/1.2.1/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput.html
https://psicode.org/psi4manual/1.2.1/psithoninput.html:8089,Performance,perform,performed,8089,"ts that require an array input, standard Python list syntax should; be used, viz.:; 1; 2; 3set {; docc = [3, 0, 1, 1]; }. List/matrix inputs may span multiple lines, as long as the opening [ is; on the same line as the name of the keyword.; Any of the above keyword specifications can be scoped to individual modules,; by adding the name of the module after the set keyword. Omitting the module; name, or using the name global or globals will result in the keyword being; applied to all modules. For example, in the following input; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13molecule{; o; h 1 roh; h 1 roh 2 ahoh. roh = 0.957; ahoh = 104.5; }. set basis cc-pVDZ; set ccenergy print 3; set scf print 1; energy('ccsd'). the basis set is set to cc-pVDZ throughout, the SCF code will have a print; level of 1 and the ccenergy code, which performs coupled cluster computations,; will use a print level of 3. In this example a full CCSD computation is; performed by running the SCF code first, then the coupled cluster modules;; the energy() Python helper function ensures that this is performed correctly.; Note that the Python interpreter executes commands in the order they appear in; the input file, so if the last four commands in the above example were to read; 1; 2; 3; 4set basis cc-pVDZ; energy('ccsd'); set ccenergy print 3; set scf print 1. the commands that set the print level would be ineffective, as they would be; processed after the CCSD computation completes.; In PsiAPI mode, one can use commands set_options() and; set_module_options() like below. Note that these values; should be of correct type, strings for strings, floats for floats like; convergences. The function ~psi4.core.clean_options that reinitializes; all options may also be useful to separate calculations in a PsiAPI; session.; 1; 2; 3; 4; 5; 6; 7; 8; 9psi4.set_options({; 'scf_type': 'pk',; 'e_convergence': 1.e-5,; 'soscf': True; }). psi4.set_module_options({; 'geom_maxiter': 50; }). Basis Sets¶. Basis Sets; Built-In",MatchSource.WIKI,psi4manual/1.2.1/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput.html
https://psicode.org/psi4manual/1.2.1/psithoninput.html:8222,Performance,perform,performed,8222,"ts that require an array input, standard Python list syntax should; be used, viz.:; 1; 2; 3set {; docc = [3, 0, 1, 1]; }. List/matrix inputs may span multiple lines, as long as the opening [ is; on the same line as the name of the keyword.; Any of the above keyword specifications can be scoped to individual modules,; by adding the name of the module after the set keyword. Omitting the module; name, or using the name global or globals will result in the keyword being; applied to all modules. For example, in the following input; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13molecule{; o; h 1 roh; h 1 roh 2 ahoh. roh = 0.957; ahoh = 104.5; }. set basis cc-pVDZ; set ccenergy print 3; set scf print 1; energy('ccsd'). the basis set is set to cc-pVDZ throughout, the SCF code will have a print; level of 1 and the ccenergy code, which performs coupled cluster computations,; will use a print level of 3. In this example a full CCSD computation is; performed by running the SCF code first, then the coupled cluster modules;; the energy() Python helper function ensures that this is performed correctly.; Note that the Python interpreter executes commands in the order they appear in; the input file, so if the last four commands in the above example were to read; 1; 2; 3; 4set basis cc-pVDZ; energy('ccsd'); set ccenergy print 3; set scf print 1. the commands that set the print level would be ineffective, as they would be; processed after the CCSD computation completes.; In PsiAPI mode, one can use commands set_options() and; set_module_options() like below. Note that these values; should be of correct type, strings for strings, floats for floats like; convergences. The function ~psi4.core.clean_options that reinitializes; all options may also be useful to separate calculations in a PsiAPI; session.; 1; 2; 3; 4; 5; 6; 7; 8; 9psi4.set_options({; 'scf_type': 'pk',; 'e_convergence': 1.e-5,; 'soscf': True; }). psi4.set_module_options({; 'geom_maxiter': 50; }). Basis Sets¶. Basis Sets; Built-In",MatchSource.WIKI,psi4manual/1.2.1/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput.html
https://psicode.org/psi4manual/1.2.1/psithoninput.html:10360,Performance,perform,performing,10360,"ish the previous example of; H2 and H atom:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19molecule h2 {; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h {; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol * (2*h_energy - h2_energy); print ""De=%f"" % D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module, and PSI Variables by Alpha defines them. These can be; accessed through the get_variable() function. For example, after; performing a density fitted MP2 computation, both the spin component; scaled energy and the unscaled MP2 energy are made available:; 1; 2e_mp2 = get_variable('MP2 TOTAL ENERGY'); e_scs_mp2 = get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; are cleared at the start of each energy(), etc. in an input; file by clean_variables().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the; last will include SCF TOTAL ENERGY but not; FCI TOTAL ENERGY.; The entire dictionary of PSI variables can be obtained through; get_variables(). Return Values¶; Most of the usual user computation functions (i.e.,; energy(), optimize(), and; frequency()) return simply the current total energy.; Consult the descriptions of other functions in Psithon Functions: Invoking a Calculation for; what quantities they return and for what data structures t",MatchSource.WIKI,psi4manual/1.2.1/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput.html
https://psicode.org/psi4manual/1.2.1/psithoninput.html:11241,Performance,optimiz,optimize,11241,"ines them. These can be; accessed through the get_variable() function. For example, after; performing a density fitted MP2 computation, both the spin component; scaled energy and the unscaled MP2 energy are made available:; 1; 2e_mp2 = get_variable('MP2 TOTAL ENERGY'); e_scs_mp2 = get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; are cleared at the start of each energy(), etc. in an input; file by clean_variables().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the; last will include SCF TOTAL ENERGY but not; FCI TOTAL ENERGY.; The entire dictionary of PSI variables can be obtained through; get_variables(). Return Values¶; Most of the usual user computation functions (i.e.,; energy(), optimize(), and; frequency()) return simply the current total energy.; Consult the descriptions of other functions in Psithon Functions: Invoking a Calculation for; what quantities they return and for what data structures they make; available for post-processing. Many users need only deal with the simple return; form for the computation functions.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11# E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = energy(...); E = optimize(...); E = frequency(...); G = gradient(...) # used by optimize(); H = hessian(...) # used by frequency(). For more elaborate post-processing of computations, adding; return_wfn=True keyword argument additionally returns; Wavefunction.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16# power user returns; E, wfn = energy(..., return_wfn=True); E, wfn = optimize(..., return_wfn=True); E, wfn = frequency(..., return_wfn=True); G, wfn = gradient(..., return_wfn=",MatchSource.WIKI,psi4manual/1.2.1/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput.html
https://psicode.org/psi4manual/1.2.1/psithoninput.html:11793,Performance,optimiz,optimize,11793,"iables; are cleared at the start of each energy(), etc. in an input; file by clean_variables().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the; last will include SCF TOTAL ENERGY but not; FCI TOTAL ENERGY.; The entire dictionary of PSI variables can be obtained through; get_variables(). Return Values¶; Most of the usual user computation functions (i.e.,; energy(), optimize(), and; frequency()) return simply the current total energy.; Consult the descriptions of other functions in Psithon Functions: Invoking a Calculation for; what quantities they return and for what data structures they make; available for post-processing. Many users need only deal with the simple return; form for the computation functions.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11# E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = energy(...); E = optimize(...); E = frequency(...); G = gradient(...) # used by optimize(); H = hessian(...) # used by frequency(). For more elaborate post-processing of computations, adding; return_wfn=True keyword argument additionally returns; Wavefunction.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16# power user returns; E, wfn = energy(..., return_wfn=True); E, wfn = optimize(..., return_wfn=True); E, wfn = frequency(..., return_wfn=True); G, wfn = gradient(..., return_wfn=True) # used by optimize(); H, wfn = hessian(..., return_wfn=True) # used by frequency(). # print gradient array and its rms; wfn.gradient.print_out(); print wfn.gradient().rms(). # format output for other programs; molden(wfn, 'mycalc.molden'). # access array in another format; np.array(wfn.hessian()). Loops¶; Python provides many control structures, any of which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; 1; 2; 3; 4basis_sets = [""cc-pVDZ"", ""cc-pVTZ",MatchSource.WIKI,psi4manual/1.2.1/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput.html
https://psicode.org/psi4manual/1.2.1/psithoninput.html:11856,Performance,optimiz,optimize,11856," file by clean_variables().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the; last will include SCF TOTAL ENERGY but not; FCI TOTAL ENERGY.; The entire dictionary of PSI variables can be obtained through; get_variables(). Return Values¶; Most of the usual user computation functions (i.e.,; energy(), optimize(), and; frequency()) return simply the current total energy.; Consult the descriptions of other functions in Psithon Functions: Invoking a Calculation for; what quantities they return and for what data structures they make; available for post-processing. Many users need only deal with the simple return; form for the computation functions.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11# E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = energy(...); E = optimize(...); E = frequency(...); G = gradient(...) # used by optimize(); H = hessian(...) # used by frequency(). For more elaborate post-processing of computations, adding; return_wfn=True keyword argument additionally returns; Wavefunction.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16# power user returns; E, wfn = energy(..., return_wfn=True); E, wfn = optimize(..., return_wfn=True); E, wfn = frequency(..., return_wfn=True); G, wfn = gradient(..., return_wfn=True) # used by optimize(); H, wfn = hessian(..., return_wfn=True) # used by frequency(). # print gradient array and its rms; wfn.gradient.print_out(); print wfn.gradient().rms(). # format output for other programs; molden(wfn, 'mycalc.molden'). # access array in another format; np.array(wfn.hessian()). Loops¶; Python provides many control structures, any of which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; 1; 2; 3; 4basis_sets = [""cc-pVDZ"", ""cc-pVTZ"", ""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set;",MatchSource.WIKI,psi4manual/1.2.1/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput.html
https://psicode.org/psi4manual/1.2.1/psithoninput.html:12161,Performance,optimiz,optimize,12161,"riables(). Return Values¶; Most of the usual user computation functions (i.e.,; energy(), optimize(), and; frequency()) return simply the current total energy.; Consult the descriptions of other functions in Psithon Functions: Invoking a Calculation for; what quantities they return and for what data structures they make; available for post-processing. Many users need only deal with the simple return; form for the computation functions.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11# E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = energy(...); E = optimize(...); E = frequency(...); G = gradient(...) # used by optimize(); H = hessian(...) # used by frequency(). For more elaborate post-processing of computations, adding; return_wfn=True keyword argument additionally returns; Wavefunction.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16# power user returns; E, wfn = energy(..., return_wfn=True); E, wfn = optimize(..., return_wfn=True); E, wfn = frequency(..., return_wfn=True); G, wfn = gradient(..., return_wfn=True) # used by optimize(); H, wfn = hessian(..., return_wfn=True) # used by frequency(). # print gradient array and its rms; wfn.gradient.print_out(); print wfn.gradient().rms(). # format output for other programs; molden(wfn, 'mycalc.molden'). # access array in another format; np.array(wfn.hessian()). Loops¶; Python provides many control structures, any of which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; 1; 2; 3; 4basis_sets = [""cc-pVDZ"", ""cc-pVTZ"", ""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_sets is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixi",MatchSource.WIKI,psi4manual/1.2.1/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput.html
https://psicode.org/psi4manual/1.2.1/psithoninput.html:12285,Performance,optimiz,optimize,12285,"the current total energy.; Consult the descriptions of other functions in Psithon Functions: Invoking a Calculation for; what quantities they return and for what data structures they make; available for post-processing. Many users need only deal with the simple return; form for the computation functions.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11# E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = energy(...); E = optimize(...); E = frequency(...); G = gradient(...) # used by optimize(); H = hessian(...) # used by frequency(). For more elaborate post-processing of computations, adding; return_wfn=True keyword argument additionally returns; Wavefunction.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16# power user returns; E, wfn = energy(..., return_wfn=True); E, wfn = optimize(..., return_wfn=True); E, wfn = frequency(..., return_wfn=True); G, wfn = gradient(..., return_wfn=True) # used by optimize(); H, wfn = hessian(..., return_wfn=True) # used by frequency(). # print gradient array and its rms; wfn.gradient.print_out(); print wfn.gradient().rms(). # format output for other programs; molden(wfn, 'mycalc.molden'). # access array in another format; np.array(wfn.hessian()). Loops¶; Python provides many control structures, any of which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; 1; 2; 3; 4basis_sets = [""cc-pVDZ"", ""cc-pVTZ"", ""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_sets is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign.; The geometry specification supports delayed initialization of variable,; which permits potential energy sca",MatchSource.WIKI,psi4manual/1.2.1/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput.html
https://psicode.org/psi4manual/1.2.1/psithoninput.html:14118,Performance,perform,performed,14118,"s strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign.; The geometry specification supports delayed initialization of variable,; which permits potential energy scans. As an example, we can scan both the; angle and bond length in water:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16molecule h2o{; O; H 1 R; H 1 R 2 A; }. Rvals = [0.9, 1.0, 1.1]; Avals = range(102, 106, 2). set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). The declarations of Rvals and Avals are both completely standard Python syntax.; Having named our molecule h2o we can then set the values of R and A within; the loops. Note that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the set keyword.; Cartesian geometries, because of details of the geometry update process,; need to be specified within the loop(s) along with their basis set when; geometry scans are performed. See scf4 for analogous Z-matrix; and Cartiesian scans. Tables of Results¶; The results of computations can be compactly tabulated with the Table() Psithon; function. For example, in the following potential energy surface scan for water; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27molecule h2o {; O; H 1 R; H 1 R 2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(100,102,2). table=Table(rows=[""R"",""A""], cols=[""E(SCF)"",""E(SCS)"",""E(DFMP2)""]). set basis cc-pvdz. for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('mp2'); escf = get_variable('SCF TOTAL ENERGY'); edfmp2 = get_variable('MP2 TOTAL ENERGY'); escsmp2 = get_variable('SCS-MP2 TOTAL ENERGY'); table[R][A] = [escf, escsmp2, edfmp2]. print table; relative=table.copy(); relative.absolute_to_relative(); print relative. we first define a table (on line 10) with two row indices and three column; ind",MatchSource.WIKI,psi4manual/1.2.1/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput.html
https://psicode.org/psi4manual/1.2.1/psithoninput.html:15077,Performance,perform,performed,15077," are performed. See scf4 for analogous Z-matrix; and Cartiesian scans. Tables of Results¶; The results of computations can be compactly tabulated with the Table() Psithon; function. For example, in the following potential energy surface scan for water; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27molecule h2o {; O; H 1 R; H 1 R 2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(100,102,2). table=Table(rows=[""R"",""A""], cols=[""E(SCF)"",""E(SCS)"",""E(DFMP2)""]). set basis cc-pvdz. for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('mp2'); escf = get_variable('SCF TOTAL ENERGY'); edfmp2 = get_variable('MP2 TOTAL ENERGY'); escsmp2 = get_variable('SCS-MP2 TOTAL ENERGY'); table[R][A] = [escf, escsmp2, edfmp2]. print table; relative=table.copy(); relative.absolute_to_relative(); print relative. we first define a table (on line 10) with two row indices and three column; indices. As the potential energy scan is performed, the results are stored; (line 22) and the final table is printed to the output file (line 24). The; table is converted from absolute energies to relative energies (in kcal mol-1); on line 26, before being printed again. The relative energies are reported with; respect to the lowest value in each column. More examples of how to control the; formatting of the tables can be found in the sample input files provided; see; Appendix Test Suite and Sample Inputs for a complete listing. Python Wrappers¶; The Python foundations of the PSI4 driver and Psithon syntax permit; many commonly performed post-processing procedures to be integrated into; the PSI4 suite.; As seen in the neon dimer example from the tutorial section,; the nbody_gufunc() wrapper provides automatic computation of; counterpoise-corrected interaction energies between two molecules. For; example,; 1energy('mp2', bsse_type='cp'). will compute the counterpoise-corrected density-fitted MP2 interaction energy; between two molecules.; PSI4 also provides the ",MatchSource.WIKI,psi4manual/1.2.1/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput.html
https://psicode.org/psi4manual/1.2.1/psithoninput.html:15672,Performance,perform,performed,15672,"R; for A in Avals:; h2o.A = A; energy('mp2'); escf = get_variable('SCF TOTAL ENERGY'); edfmp2 = get_variable('MP2 TOTAL ENERGY'); escsmp2 = get_variable('SCS-MP2 TOTAL ENERGY'); table[R][A] = [escf, escsmp2, edfmp2]. print table; relative=table.copy(); relative.absolute_to_relative(); print relative. we first define a table (on line 10) with two row indices and three column; indices. As the potential energy scan is performed, the results are stored; (line 22) and the final table is printed to the output file (line 24). The; table is converted from absolute energies to relative energies (in kcal mol-1); on line 26, before being printed again. The relative energies are reported with; respect to the lowest value in each column. More examples of how to control the; formatting of the tables can be found in the sample input files provided; see; Appendix Test Suite and Sample Inputs for a complete listing. Python Wrappers¶; The Python foundations of the PSI4 driver and Psithon syntax permit; many commonly performed post-processing procedures to be integrated into; the PSI4 suite.; As seen in the neon dimer example from the tutorial section,; the nbody_gufunc() wrapper provides automatic computation of; counterpoise-corrected interaction energies between two molecules. For; example,; 1energy('mp2', bsse_type='cp'). will compute the counterpoise-corrected density-fitted MP2 interaction energy; between two molecules.; PSI4 also provides the cbs() wrapper,; which automatically computes a complete-basis-set extrapolation (and; automatically sets up the computations with different basis sets required to; do the extrapolation). For example,:; 1; 2; 3; 4; 5# all equivalent. cbs('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). energy('mp2/cc-pv[dt]z'). will compute a 2-point Helgaker extrapolation of the correlation energy; using the cc-pVDZ and cc-pVTZ basis sets (with method MP2) and add this; extrapolated correlation energy to the Hartree–Fock energy in the; lar",MatchSource.WIKI,psi4manual/1.2.1/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput.html
https://psicode.org/psi4manual/1.2.1/psithoninput.html:17055,Performance,perform,perform,17055,"he cbs() wrapper,; which automatically computes a complete-basis-set extrapolation (and; automatically sets up the computations with different basis sets required to; do the extrapolation). For example,:; 1; 2; 3; 4; 5# all equivalent. cbs('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). energy('mp2/cc-pv[dt]z'). will compute a 2-point Helgaker extrapolation of the correlation energy; using the cc-pVDZ and cc-pVTZ basis sets (with method MP2) and add this; extrapolated correlation energy to the Hartree–Fock energy in the; largest basis (cc-pVTZ). cbs() can; either be called directly, as in the first example, or the convenience; syntax of the equivalent second example can be used.; Another very useful and powerful feature of PSI4 is the ability; to compute results on entire databases of molecules at a time,; as provided by the database() wrapper. For example,:; 1database('mp2', 'S22', cp=1, benchmark='S22B'). will perform DF-MP2 counterpoise-corrected interaction energies; (cp=1) on all members of Hobza’s S22 database set of van der Waals; dimers, and then compare the results against the S22B benchmark energies.; Built-in databases include S22, A24, HTBH, HBC6, HSG, S22by5, S66, JSCH,; NCB31, S66by8, and NBC10, among others.; These wrapper functions are discussed separately in; Psithon Functions: Invoking a Calculation. Note that the options documented for Python; functions are placed as arguments in the command that calls the function,; not in the set {...} block or with any other set command. table of contents. Psithon: Structuring an Input File; Physical Constants; Memory Specification; Molecule and Geometry Specification; Job Control Keywords; Basis Sets; PSI Variables; Return Values; Loops; Tables of Results; Python Wrappers. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput.html
https://psicode.org/psi4manual/1.2.1/psithoninput.html:4563,Safety,sanity check,sanity check,4563,"214179E23 # Avagadro's number ; me = 9.10938215E-31 # Electron rest mass (in kg) . In Psithon input files, prepend physical constants with psi_ to; prevent clashes with user-defined variables (e.g., psi_h). In; PsiAPI mode, access as, e.g., psi4.constants.h. Memory Specification¶; By default, PSI4 assumes that 500 MiB of memory are available. While this is; enough for many computations, many of the algorithms will perform better if; more is available. To specify memory, the memory keyword should be used. The following; lines are all equivalent methods for specifying that 2 GB of RAM is available; to PSI4:; 1; 2; 3; 4; 5; 6; 7# all equivalent. memory 2 GB. memory 2000 MB. memory 2000000 kB. Please note that memory can be specified both in IEC binary units (1 KiB = 1024 bytes) and SI units (1 kB = 1000 bytes). PSI4 recognizes and obeys both of them correctly. The units are not case sensitive (Kb and KB are equivalent to kB).; By default, PSI4 performs a “sanity check” when parsing Psithon input files, enforcing a minimum memory requirement of 250 MiB. While it is generally not recomennded to do so, expert users can bypass this check by directly setting the number of bytes availble to PSI4:; 1; 2# setting available memory to 2 MB; set_memory_bytes(2000000). Please note that this memory setting only governs the maximal memory usage of the major data structures and actual total memory usage is slightly higher. This is usually a negligible, except when setting tiny memory allowances.; One convenient way to override the PSI4 default memory is to place a; memory command in the ~/.psi4rc file (Sec. ~/.psi4rc File). For example,; the following makes the default memory 2 GB.; 1set_memory(2000000000). However, unless you’re assured of having only one job running on a node at; a time (and all nodes on the filesystem with ~/.psi4rc have similar memory; capacities), it is advised to set memory in the input file on a; per-calculation basis.; That same command can be used for PsiAPI ",MatchSource.WIKI,psi4manual/1.2.1/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput.html
https://psicode.org/psi4manual/1.2.1/psithoninput.html:3820,Security,access,access,3820," to SI units (Cm) conversion factor for dipoles ; dipmom_au2debye = 2.54174623 # Atomic units to Debye conversion factor for dipoles ; dipmom_debye2si = 3.335640952E-30 # Debye to SI units (Cm) conversion factor for dipoles ; c_au = 137.035999679 # Speed of light in atomic units ; hartree2ev = 27.21138 # Hartree to eV conversion factor ; hartree2wavenumbers = 219474.6 # Hartree to cm$^{-1}$ conversion factor ; hartree2kcalmol = 627.5095 # Hartree to kcal mol$^{-1}$ conversion factor ; hartree2kJmol = 2625.500 # Hartree to kilojoule mol$^{-1}$ conversion factor ; hartree2MHz = 6.579684E9 # Hartree to MHz conversion factor ; kcalmol2wavenumbers = 349.7551 # kcal mol$^{-1}$ to cm$^{-1}$ conversion factor ; e0 = 8.854187817E-12 # Vacuum permittivity (Fm$^{-1}$) ; na = 6.02214179E23 # Avagadro's number ; me = 9.10938215E-31 # Electron rest mass (in kg) . In Psithon input files, prepend physical constants with psi_ to; prevent clashes with user-defined variables (e.g., psi_h). In; PsiAPI mode, access as, e.g., psi4.constants.h. Memory Specification¶; By default, PSI4 assumes that 500 MiB of memory are available. While this is; enough for many computations, many of the algorithms will perform better if; more is available. To specify memory, the memory keyword should be used. The following; lines are all equivalent methods for specifying that 2 GB of RAM is available; to PSI4:; 1; 2; 3; 4; 5; 6; 7# all equivalent. memory 2 GB. memory 2000 MB. memory 2000000 kB. Please note that memory can be specified both in IEC binary units (1 KiB = 1024 bytes) and SI units (1 kB = 1000 bytes). PSI4 recognizes and obeys both of them correctly. The units are not case sensitive (Kb and KB are equivalent to kB).; By default, PSI4 performs a “sanity check” when parsing Psithon input files, enforcing a minimum memory requirement of 250 MiB. While it is generally not recomennded to do so, expert users can bypass this check by directly setting the number of bytes availble to PSI4:; 1; 2# setting ",MatchSource.WIKI,psi4manual/1.2.1/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput.html
https://psicode.org/psi4manual/1.2.1/psithoninput.html:10294,Security,access,accessed,10294,"Python, PSI4 makes the most pertinent results; of each computation available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of; H2 and H atom:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19molecule h2 {; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h {; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol * (2*h_energy - h2_energy); print ""De=%f"" % D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module, and PSI Variables by Alpha defines them. These can be; accessed through the get_variable() function. For example, after; performing a density fitted MP2 computation, both the spin component; scaled energy and the unscaled MP2 energy are made available:; 1; 2e_mp2 = get_variable('MP2 TOTAL ENERGY'); e_scs_mp2 = get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; are cleared at the start of each energy(), etc. in an input; file by clean_variables().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the; last will include SCF TOTAL ENERGY but not; FCI TOTAL ENERGY.; The entire dictionary of PSI variables can be obtained through; get_variables(). Return Values¶; Most of the usual user computation functions (i.e.,; energy(), optimize(), and; frequency()) return simply the current total energy",MatchSource.WIKI,psi4manual/1.2.1/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput.html
https://psicode.org/psi4manual/1.2.1/psithoninput.html:12517,Security,access,access,12517,"th the simple return; form for the computation functions.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11# E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = energy(...); E = optimize(...); E = frequency(...); G = gradient(...) # used by optimize(); H = hessian(...) # used by frequency(). For more elaborate post-processing of computations, adding; return_wfn=True keyword argument additionally returns; Wavefunction.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16# power user returns; E, wfn = energy(..., return_wfn=True); E, wfn = optimize(..., return_wfn=True); E, wfn = frequency(..., return_wfn=True); G, wfn = gradient(..., return_wfn=True) # used by optimize(); H, wfn = hessian(..., return_wfn=True) # used by frequency(). # print gradient array and its rms; wfn.gradient.print_out(); print wfn.gradient().rms(). # format output for other programs; molden(wfn, 'mycalc.molden'). # access array in another format; np.array(wfn.hessian()). Loops¶; Python provides many control structures, any of which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; 1; 2; 3; 4basis_sets = [""cc-pVDZ"", ""cc-pVTZ"", ""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_sets is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign.; The geometry specification supports delayed initialization of variable,; which permits potential energy scans. As an example, we can scan both the; angle and bond length in water:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16molecule h2o{; O; H 1 R; H 1 R 2 A; }. Rvals = [0.9, 1.0, 1.1]; Avals = range(102, 106, 2). set basis cc-pvdz; set scf e",MatchSource.WIKI,psi4manual/1.2.1/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput.html
https://psicode.org/psi4manual/1.2.1/psithoninput.html:13833,Security,access,access,13833,"y('scf'). The declaration of basis_sets is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign.; The geometry specification supports delayed initialization of variable,; which permits potential energy scans. As an example, we can scan both the; angle and bond length in water:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16molecule h2o{; O; H 1 R; H 1 R 2 A; }. Rvals = [0.9, 1.0, 1.1]; Avals = range(102, 106, 2). set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). The declarations of Rvals and Avals are both completely standard Python syntax.; Having named our molecule h2o we can then set the values of R and A within; the loops. Note that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the set keyword.; Cartesian geometries, because of details of the geometry update process,; need to be specified within the loop(s) along with their basis set when; geometry scans are performed. See scf4 for analogous Z-matrix; and Cartiesian scans. Tables of Results¶; The results of computations can be compactly tabulated with the Table() Psithon; function. For example, in the following potential energy surface scan for water; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27molecule h2o {; O; H 1 R; H 1 R 2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(100,102,2). table=Table(rows=[""R"",""A""], cols=[""E(SCF)"",""E(SCS)"",""E(DFMP2)""]). set basis cc-pvdz. for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('mp2'); escf = get_variable('SCF TOTAL ENERGY'); edfmp2 = get_variable('MP2 TOTAL ENERGY'); escsmp2 = get_variable('SCS-MP2 TOTAL ENERGY'); table[R][A] = [escf, escsmp2, edf",MatchSource.WIKI,psi4manual/1.2.1/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput.html
https://psicode.org/psi4manual/1.2.1/psithoninput.html:564,Testability,test,test,564,"﻿. Psithon: Structuring an Input File. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Psithon: Structuring an Input File¶; To allow arbitrarily complex computations to be performed, PSI4 was built; upon the Python interpreter. However, to make the input syntax simpler, some; pre-processing of the input file is performed before it is interpreted,; resulting in Python syntax that is customized for PSI, termed Psithon. In; this section we will describe the essential features of the Psithon language.; PSI4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; 1UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that the user’s ~/.psi4rc values can; override the builtins (in the input file, not in the C++ code).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files. # Do not modify this file! It is auto-generated by the document_options_and_tests; # script, from psi4topdir/psi4/include/psi4/physconst.h; h = 6.62606896E-34 # The Planck constant (Js) ; c = 2.99792458E8 # Speed of l",MatchSource.WIKI,psi4manual/1.2.1/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput.html
https://psicode.org/psi4manual/1.2.1/psithoninput.html:654,Testability,test,test,654,"﻿. Psithon: Structuring an Input File. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Psithon: Structuring an Input File¶; To allow arbitrarily complex computations to be performed, PSI4 was built; upon the Python interpreter. However, to make the input syntax simpler, some; pre-processing of the input file is performed before it is interpreted,; resulting in Python syntax that is customized for PSI, termed Psithon. In; this section we will describe the essential features of the Psithon language.; PSI4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; 1UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that the user’s ~/.psi4rc values can; override the builtins (in the input file, not in the C++ code).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files. # Do not modify this file! It is auto-generated by the document_options_and_tests; # script, from psi4topdir/psi4/include/psi4/physconst.h; h = 6.62606896E-34 # The Planck constant (Js) ; c = 2.99792458E8 # Speed of l",MatchSource.WIKI,psi4manual/1.2.1/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput.html
https://psicode.org/psi4manual/1.2.1/psithoninput.html:17031,Testability,benchmark,benchmark,17031,"corrected density-fitted MP2 interaction energy; between two molecules.; PSI4 also provides the cbs() wrapper,; which automatically computes a complete-basis-set extrapolation (and; automatically sets up the computations with different basis sets required to; do the extrapolation). For example,:; 1; 2; 3; 4; 5# all equivalent. cbs('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). energy('mp2/cc-pv[dt]z'). will compute a 2-point Helgaker extrapolation of the correlation energy; using the cc-pVDZ and cc-pVTZ basis sets (with method MP2) and add this; extrapolated correlation energy to the Hartree–Fock energy in the; largest basis (cc-pVTZ). cbs() can; either be called directly, as in the first example, or the convenience; syntax of the equivalent second example can be used.; Another very useful and powerful feature of PSI4 is the ability; to compute results on entire databases of molecules at a time,; as provided by the database() wrapper. For example,:; 1database('mp2', 'S22', cp=1, benchmark='S22B'). will perform DF-MP2 counterpoise-corrected interaction energies; (cp=1) on all members of Hobza’s S22 database set of van der Waals; dimers, and then compare the results against the S22B benchmark energies.; Built-in databases include S22, A24, HTBH, HBC6, HSG, S22by5, S66, JSCH,; NCB31, S66by8, and NBC10, among others.; These wrapper functions are discussed separately in; Psithon Functions: Invoking a Calculation. Note that the options documented for Python; functions are placed as arguments in the command that calls the function,; not in the set {...} block or with any other set command. table of contents. Psithon: Structuring an Input File; Physical Constants; Memory Specification; Molecule and Geometry Specification; Job Control Keywords; Basis Sets; PSI Variables; Return Values; Loops; Tables of Results; Python Wrappers. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. © Copyright 2018, The Psi",MatchSource.WIKI,psi4manual/1.2.1/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput.html
https://psicode.org/psi4manual/1.2.1/psithoninput.html:17237,Testability,benchmark,benchmark,17237,"he cbs() wrapper,; which automatically computes a complete-basis-set extrapolation (and; automatically sets up the computations with different basis sets required to; do the extrapolation). For example,:; 1; 2; 3; 4; 5# all equivalent. cbs('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). energy('mp2/cc-pv[dt]z'). will compute a 2-point Helgaker extrapolation of the correlation energy; using the cc-pVDZ and cc-pVTZ basis sets (with method MP2) and add this; extrapolated correlation energy to the Hartree–Fock energy in the; largest basis (cc-pVTZ). cbs() can; either be called directly, as in the first example, or the convenience; syntax of the equivalent second example can be used.; Another very useful and powerful feature of PSI4 is the ability; to compute results on entire databases of molecules at a time,; as provided by the database() wrapper. For example,:; 1database('mp2', 'S22', cp=1, benchmark='S22B'). will perform DF-MP2 counterpoise-corrected interaction energies; (cp=1) on all members of Hobza’s S22 database set of van der Waals; dimers, and then compare the results against the S22B benchmark energies.; Built-in databases include S22, A24, HTBH, HBC6, HSG, S22by5, S66, JSCH,; NCB31, S66by8, and NBC10, among others.; These wrapper functions are discussed separately in; Psithon Functions: Invoking a Calculation. Note that the options documented for Python; functions are placed as arguments in the command that calls the function,; not in the set {...} block or with any other set command. table of contents. Psithon: Structuring an Input File; Physical Constants; Memory Specification; Molecule and Geometry Specification; Job Control Keywords; Basis Sets; PSI Variables; Return Values; Loops; Tables of Results; Python Wrappers. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4manual/1.2.1/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput.html
https://psicode.org/psi4manual/1.2.1/psithoninput.html:284,Usability,simpl,simpler,284,"﻿. Psithon: Structuring an Input File. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Psithon: Structuring an Input File¶; To allow arbitrarily complex computations to be performed, PSI4 was built; upon the Python interpreter. However, to make the input syntax simpler, some; pre-processing of the input file is performed before it is interpreted,; resulting in Python syntax that is customized for PSI, termed Psithon. In; this section we will describe the essential features of the Psithon language.; PSI4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; 1UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that the user’s ~/.psi4rc values can; override the builtins (in the input file, not in the C++ code).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files. # Do not modify this file! It is auto-generated by the document_options_and_tests; # script, from psi4topdir/psi4/include/psi4/physconst.h; h = 6.62606896E-34 # The Planck constant (Js) ; c = 2.99792458E8 # Speed of l",MatchSource.WIKI,psi4manual/1.2.1/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput.html
https://psicode.org/psi4manual/1.2.1/psithoninput.html:10806,Usability,clear,cleared,10806,"""De=%f"" % D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module, and PSI Variables by Alpha defines them. These can be; accessed through the get_variable() function. For example, after; performing a density fitted MP2 computation, both the spin component; scaled energy and the unscaled MP2 energy are made available:; 1; 2e_mp2 = get_variable('MP2 TOTAL ENERGY'); e_scs_mp2 = get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; are cleared at the start of each energy(), etc. in an input; file by clean_variables().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the; last will include SCF TOTAL ENERGY but not; FCI TOTAL ENERGY.; The entire dictionary of PSI variables can be obtained through; get_variables(). Return Values¶; Most of the usual user computation functions (i.e.,; energy(), optimize(), and; frequency()) return simply the current total energy.; Consult the descriptions of other functions in Psithon Functions: Invoking a Calculation for; what quantities they return and for what data structures they make; available for post-processing. Many users need only deal with the simple return; form for the computation functions.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11# E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = energy(...); E = optimize(...); E = f",MatchSource.WIKI,psi4manual/1.2.1/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput.html
https://psicode.org/psi4manual/1.2.1/psithoninput.html:11278,Usability,simpl,simply,11278,"ines them. These can be; accessed through the get_variable() function. For example, after; performing a density fitted MP2 computation, both the spin component; scaled energy and the unscaled MP2 energy are made available:; 1; 2e_mp2 = get_variable('MP2 TOTAL ENERGY'); e_scs_mp2 = get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; are cleared at the start of each energy(), etc. in an input; file by clean_variables().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the; last will include SCF TOTAL ENERGY but not; FCI TOTAL ENERGY.; The entire dictionary of PSI variables can be obtained through; get_variables(). Return Values¶; Most of the usual user computation functions (i.e.,; energy(), optimize(), and; frequency()) return simply the current total energy.; Consult the descriptions of other functions in Psithon Functions: Invoking a Calculation for; what quantities they return and for what data structures they make; available for post-processing. Many users need only deal with the simple return; form for the computation functions.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11# E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = energy(...); E = optimize(...); E = frequency(...); G = gradient(...) # used by optimize(); H = hessian(...) # used by frequency(). For more elaborate post-processing of computations, adding; return_wfn=True keyword argument additionally returns; Wavefunction.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16# power user returns; E, wfn = energy(..., return_wfn=True); E, wfn = optimize(..., return_wfn=True); E, wfn = frequency(..., return_wfn=True); G, wfn = gradient(..., return_wfn=",MatchSource.WIKI,psi4manual/1.2.1/psithoninput.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput.html
